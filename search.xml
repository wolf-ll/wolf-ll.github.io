<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>思路整理</title>
      <link href="/2025/03/08/java-ti-mu-jing-jian/"/>
      <url>/2025/03/08/java-ti-mu-jing-jian/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c8dafcb9886ff53f260648d03a713b4649ca2dec73f2781fe6be88d9ff326893">e5e963fdc9daf54d686e4a098ee1ff75389b5e1b07cf2bef315bf3df422a2bd0687b84da758f553f858dd8273236b6a12e34447723d2f850e9e0001085db18a3ce209614ece04825c3243ceb04ad05a6781c46e27f4c2cfdff264fbf9a9b072bf484448aaf19a1a1562311703254fcfc28d124d7a7caa6ca916dc297f7dd7d3eead948e92234c5ded2c6478354b79bed274b229ac852682b2905a1685dc8f06639f05b9dde049267b55054af88971feba67ba9c2cd1ab95e315aa601bc78648fb78f6dfb79e1913d3991a4e9702f5761be0046e78053e62ed38e2be37de9314eb6854c444a6fa7e5c5852fb55f6bf22d2c6e54b55e54f7aec8456e078db525733023c7d4e9a42bfcc8c6e4e81002060a7323b7e8bdb2d33e2f1de8f9de57f4f42a0c6d058b81ef55150b7128fc36356e0ffed0def115da1cd15671e03a0fab8da8ef3427d10cc072e410320d5ed50961059da23984417ae90d711e5228c6d7d0539794f6b2309df77cdd1b99abaa154cff2254c2a14f5b9475161aa9ccebd087024f55b450d30914ca45580c0d39976dda3e1db0a99424b08fc441ca3ff7335f4a6d5968549c2ea16c733d65b5935ebaefc93e208c48bd990156d994314480c9c0abf4e04c5dff19944a264e19f48337e6f548502fcb51ef5f97380c6f378aabe4df642b89aa83a08e33890a3a859766d603c61fafcbc78667aaa4ad7223bd449dcf025cdead72ef4846e29cf1d20227d0533441f82903403625cce3189a54b65b02668ac9c96b07033877566284c0b390eb224b13fea9c49e2730e776ffe041ab247157c750cfec696a70581201db9f7b57273be5e1206860857d4fbf597d4066c5feba5a3f65899cc197ac9267dcaea758c549e0026ab650d1d712bc2d62c0fae1bc017475af2ebd1090377ca1d4c542fbc2fc5e544e8d1b879bdf644de9084915e57e5cf7f2bd60d0d1d2ee27b91db4351c9308edc3b40e8660942095aa7a25e9569f06d4cd22c6113520832b49ffaa031902826e02132ddf6ad8c1e1aa0a391f8f347e23d17563ce14cc1d4a7841cde122e54e46424ab4560b03ba02510c001f8e339291ba814d320fb0f066eb6456cae1b46c4dd087df3fadfc426595295ec1023f4db83dcc8b1f1bb865ca8d095e7a2669dbdbd00f7770e48d3abc255e993879dc81b3c7e726ac5cb060f4ad129c02859c900a890883659d68b8a701fd9189c60fbc9dd48b7493df7bbbb954e9e3172226c48ae3f68de0b0d8f6e1016de96db178842ab7d91c41e7c1d9fd8770ba7370dc710b5fb01b19166dac9b18a13c8f57c8c3d8d81c59b145f3b6d6ccf0b48c0f7b5cae2cdb4f4c6df00c6e15ea66c1dae3cb337f1de102f706a530a37ea7a7d0adf20d57b9847421504d53f65880d91ce1258a2fddd95688028c00d1e4e46670c7d2695484750ea0a5eff9a82bede6308db4676bdfbcf9f821ceeabea3e8e11729261eb703d57799a3ca56261f1fc4c472ac8a66a229352ecfc7897e5cd46641f60165504006752914eb226d86ed5184272530a0aabca9b1b09fa451c56d29b70dda2a1fc72071bf8451fc739322875b144a992c99d691319a1a5484193096087dc7eb43a1a0266796aeb0cddf37f3f0bc5ce8a7420104f1377990a6869923fcfa36994a2fea07daf52071f30db1d0c05b561d6fa194f472fcded1adf98483d8ac4e3d630d6d63bacb19ba0df18015c18ba0eadc67fe4930cd7cc69b42d335a1da4aa1aa7c1b4b3f944b783fdf436fbf88f365cccd134a0f6709f1d7147938f9294f3da82ec49f1c5c168b691bca0ad7df0e0cca27fe95ee811f13b1147612669faa2911ebc3aa919983558f777f797f811a9f125c6f4f57695df73c85273701ccf39a28c7dc15cd102cbf08557f79e69709c7130e5865e65f75aa69af8a54f0f3de432f03d7a25f019433b0bd3ef42d73414154dbe4ad334adaf797415e3721af238b50a3b4d735ac7751c750673f81174caa1c63230b96ed08fb292f32fa4b25a21b625769da6b0225358db0a89be118909dcf12315a878eef6c67725768a3d87f9feff2232457e52090c52adaba55ac33f8e5d13674f49625b0d7cc6b51b8c8126670aec4d1070950697a7af120a196511cfdc17247d82556e1f861799d5a49281d4638c82ee87c1f38e2a0189997758107e85c716657dc8fb4b58b4b0f56d9aee9e31f2c995f4a0c1eaf5c6482a6cb69f75216a579d347550365a62f6a543a7ed511564b97285fe8b3500add05158fc0607dc7ff2af4680b852487602ab33a934a98dff9ad0ed38c97758888db089af7e88613f6dee17e02b7bff743341956b2d2d48bad360478ddd8826ffb79a5ea2b93343547300ab9a34d5d0b3d787dec095a0eaea8f62b8136405ea5d7dff991af0d506aa515713a6d68e0ef6ea979caae3402b438c87e5985a6adcf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目记录</title>
      <link href="/2025/03/08/xiang-mu-ji-lu/"/>
      <url>/2025/03/08/xiang-mu-ji-lu/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9a0a7a9001247045f85893862f1decc5d1bdf71fbe76f640bf4916cfb869077a">e5e963fdc9daf54d686e4a098ee1ff75389b5e1b07cf2bef315bf3df422a2bd0fc830aea3267ddff370848028e638cd0cc8a5b93e53c054afe392e6fc035b81ecb8d06955d75b64f2316e05737625b3a362824a6a241e0d999530f65d7d300144a902f94fe5908b8a5e54165b1d7a230feab21212510e01d715a356a2f151e96ebb5a3f2448f1395e72988531c84d96af7b08e045b73abf074f0c5d8daaf1ed353c2b42667e8a92b75ceb3a5b9a5375ba43109015f85194f4f42e7b19e91fa0261a858dce1cb6956d99bec16c99da519559cb195ad6f91779ba6a017f0f360e5fed06ff9ad7452b8f37b6be51b6120bb3290c6ee9dd1794be748c758f1e569b4ac97bd20ac5b8e2a1247e008c49fa3469b6a274ba877f928948d922ff535c634aa495c7775f27923dc3d25a92d23ba658907d02dc62f16a9cad56399e30a23930c74e3b90c7b57f03c4638da6f748f2fdeef73af8fed030436835fe2f69c01b78def021d356e91b78d66b2fb7d05c9a17dc0cb05a75e9ad801a83751f58ccaecb4f79837066538693b4984a8a0ebb3bfb7a0000dab0c02eb5e3f7783120f0668f34724ab2ddff17fffe869a5154784ad4ddda425294cbfb344586408c261749d13d5a2fe01509a453cdfeaaa18f45b0cbc394588de87f4ee351b0fd6ca0be0a005714177f02803e72fdb25a470c15dab0b1d3f999efe55a28734c46752131d0a3cef289d1bd63559656a6f236172593fb5cf4a80c0e9d704d20c8c5464f26960b89382800c769e9f648f5e9746f6142ceb68b70dc535343813c5960d2beb64a87502c0091f68b70a505120058de8f484ee17b2e14ea3fc83b3d723606ea6485488515125e88d98e452feb02eb678c31065ddc82269357c37cabfe6ed38b4aada988859526b4aad6379b0bf297080f474765c6731742c7f654ff9362634d02705ee55a9028c4e1b4812fa84dc1280239c727d226b3b855ae05130f9195fe7a99f97affd175bc916115fed8b887bdcd5efece6e3cd9e4468294579d4ba1c56636802379533ba6bddbe4e5fc1b1f4f652b13821b0c22c341181b399c499b8d77ec684a9dea42bf65ce48f4bae7ef061fcdf6717039e8e30d972160c7841004501fbd40ecb5553ca5c5b22b1fa4b7f49d8178d7115b900425938dbf837307b71019e2baac16b027398c57edd3f9569311908c278daf6096eb4200117283e7dffa03d077788a2255d8f106a22bc9e4d104de65524661076e2d7b3aa9d9c5eeb0066ad9a48784cd0bb8c82a0539cf344a16a9807e154b10b825ad7eec93372aa1c73fcb6eca88e32e84b65b80325accc795cc45165f0132d8123db86bd883364059f0604a1bfd4d5755e89934a364360401d15a19498a93f42fb42242dfad47921e31200ab84bacdd4f74f010a4597785068c70a3cfd0025104150b9ce336b199bd7b455f9a6487e7966ca947d8359d9974ed70cda032867dbc0545ead28305972bdef8ca9f9990f52567a92d341f70f8813262dda358cda75187bb14f1d1906c6c97c42e517a8904fb13d7d45400ec044ebb4ea9f4a38609cc906ae8028640092602de303c3808926f1576d1fda35259ce16103f532b84fde61af6e3f54f80659ebc2e5f1386fd89efed218fcdf99bd97a37186af7b4475154458b46edff90633782f22904153651b381ccadc5bf908cb1c71a9f14808667a2acf57607dfafadc83830378dabd710ab8d3a4858fbeb6ba7cb0f9db93c53a7118731eae5d52cdc864329732d17abb3e5eabe1256d8c8da30bdf61a463db9e4a0f7c63a2c9af93ff023864292481134a2d96df5f14f0e6569e783c0a11034072de078dcff3010c03bda8d5cc7609b10cb546c85cc35279f60c64a458f9da55880e514a16fc3bcf0218a1286fa4b2cd847fa6676cc27af4708b6e19b655fea10ada8e14207dd303f83bb0f9be9751bd9aedced830e3bde6ff2327e1e6fe9512a374cc681efaef351a70a82492b66ef520facaefe684ed2bbcc0238f42ad50888b46057068490ceebbd1b370cd9ae4cb24764e1d0a0c8ff7299b98ff89fdc416ba7e2b4b5232839f1673ba81ea413b21b2cddfa01ff63971d70a9fac843671d4ae69a4e3e81303fed348866c077c053ca345cadca5568a5b06f0fff7ca9bd6f2f2c70cd744935cb533dd15689739ce6786e24a1aaab23c2f2efecb27a5a03504d367d5a03a49919916e9e6144fe7f5afa1298590d3a18c2ea8a525d6d08458e23fcfde232cd76bd2dd361be351c23835b8951d998fc40e1739b0847460e86f29756f677a7496b1eb1689cfab96585d34e51cdae83c57e1c6e2b1c80dfea99c21f190d36a6ff19f946abb3c10c5fc5575fcedac6f1a438e288be8e35ec54348fcbcde5fb9e7b364492c2fa5834e65a9831b74bd2c1d84670c7797887a34d64c2c0efdc7680b0f5f2a6b6ffafe61df56a16afba79f99a90f5c17bf77b71f0ff1f236a7df6ec84f897a060489f3db127b4499cdca41fabffb7f49ce875ea60e62fec43294b3e2d1dd3beebc40d09391d77bf2559567d6387b5bbff07dd36f1cb2fe1a772d96d998bbcb9067a0072f5b15d994e296479f20e52f18f6fa6c842f6529e1b63f5e669e481853d43dca6587540b41f16333c215e3f2606e5394509f4ec9b4ecbaf7858a454e9d10e44cdaa5d3765408a107b07ad5ed63169e30a13d594054f3451e5fe3ccff2e91c6f68b579ffb0abcb8d15dadf14fdba53101eccf8ad6eabb6b2665125f61ddfc31e151741ca845ecd5f042685a181085f6124af5a4af75cc19edb80219791a8c4cb2cae0ff6996f89ace86b111141434a778b3040cc2ee7b5524852ff1ea99e7bd761c980ea7dcc8fb71c2c7167eb507e8755cd734bc9bcb2d160446421ad4b939faf8e13c105ca121f94c1e28728a3438f03a19a804750f4c0c53c4f45b382cd162bc1828f4c0aedcbb8ad1d1d2818bbc3ac1c5178056d0bf8e490aef825db2b6d31a885d9cb27792ea4c2cfc1b1b618078e88d011f315456b44e27093b0792c0ebf08630375bec7987a49198062683ba34dd9ed5a333d6111b25dd2241b0b4fa05be3dcdff35698976bbd3fe436a5a11e8e8ec317875de154f1255b06f319788ada0052b67171df9fe7837a8e64a6870b3b3740a9441ff9b9d80739ba2016c2c3d67cafcbbb8cb8b195d5bdf47041217edc7606b9a3291c346dbad6c3b0fcffb1f054193a9b8da7c04d319d776a84665455df22806e1bf53ef92c8942b09887b3c5c0e24c0075886a9ac89df014bde63ca678301528878d88ec569f3baf8153bf95147a59907b03db414a9b7392faa08cac370a3e7dabdd059abc9be564c58dd889b6025ed34c5863a9a1266cc075f0a99ca634fac6925ed7ee883234b49ed1bdd84e9fc01dc118e8d918bfa0008f4ed3cbeccdf3268589832834d068fc964109a284fc2546ae75a541c4af1ee70a55cc23e3bdefd396b1190bb9a9b86d9117eaf7fc6ce1bed2a1dbd75ce44573707574d6ef7c91d36d52d2b6b5fcfb37c3dba52261e59b19e4867e2512881b37a3628ac884a86cad0694548557528113125ee434afa5477c4003c4fa98979e601bad3a1e8fe58a48d88f111829be1025213a66c2e633fff901fa6c6ca38091714f9f61b49a48c9a3cb69b8b582a42ce0baabbbcffcb6d52b579ce23349bfecb498d4b3abccfc210ff761ec071e6448ce9185a86405acdcb9969fdaa2faa92d55367d55ac30ae2051809fcde2ee7a0c79f1c31561c16962a1bf5a26d5989973737ad558bba5b8312e18582107c68deb96aa6b273c426a23ac19c485582a5b193601c44a2bd2b6fba04dfbfb986ff9e73055f0a431aea42a1ed79113581ac58b4728e0fff1c310537c6b50611e683dac55b8ad4b40ce5c3150959261d03c2d86cb18943087a6e87b93d63f43726112b6256d622d1fe27860207eb234dc4a2a9fc2a6bf2b5a4146f18b92c77b41347e1e35b7b9db6bca379bac3d700a5d1bfd0d398477d7b1c67673396775a1b63f94ada2ce5ea968a5f3cae5df8f91e60097434557e61cee4b8de73ce420f06c4002bbc7dac58c37866c0bfd4af0c30d94f290fc58f0ec63d51c5b6e5c6d6bf76dc893622c6de160a359da093623a654609d3cd61ae8fab3ece8ed6f455d4ddc8636bd5860f45d9ffab4753e6cb31b4f1e608b4c52373dc3a927a9e06fe9f1f10df033a2fcf27e3ac051d2e62703bfae24fc27977d3c280c540ac6197bd189caf39dc3c66b3ac25c95e5110035e649b22fe59a769d25a987a7f9dd7fa6a2fa497a419d03c5ac9bcd96aeaed5ee3026155f7c23a1c9baba171d19d7b52ddb86d13de5219cf16013c2dbd00567e6224667dfb8cf50b6634205a5af98aec6386ae07af20da61da7b52c3ffb440afcac2581218618f2d74e5148635482a0efb2a9c1524f6e7e0c63b3e2ae54787f95dc92ad17f57343d4a06f93bdf67aab4d3edc6bcaa5dd29d74b705a34eca2565c85bd9eafbfe87c4b7bec8ae286964c971df5cb872a2c9d77f53756764a353874dd7a327e907d79d30aad778e18a1084ceb3982e0b28d09829fa07e76bbb20c4a5f00467232aaf14000c3a9df27b3576d48f31636e0a4cf789688faddee2c1d07358c7c8c07b8b0f971a7040cb612ac845fc4b6d45dba7fd22555f2bb8579a0255c42c52a3405424e96c3101e72ec2e545696670bc7ed4fe6ed3d6f569bdfa0b0bcb5cf967b817d6907e333373cbfb84aeeb2e19d578242084d856d797d7e07d391ff0b2426819bb650a4d2e4707171a172d49a24489fb0cdc84680b842b37f2135b7a9becfcbc03bb083711197d9288fa4b808e68cc172bde4212a241d7c769fdb6dc9e28292a9cf3452ffddb42ca2c5154f9f13cdcf77e2da73e958d1d8da21ef75b8ed758ff4ce086ace66f4d394c89af4c7fd2ca52dae14cd75756c991710247f0ec78795a624c98b277ce9bfecfba67b689f73f203248180ab877d89af65f566692eaf0fd7b40278e97438bfcf091870ac005f8c32d591e68cdbcb588d00b8d4a91fb234e2eaf85018d2e0f42109edf767825a874fb7a97dd8a72d2f1cb79cb2e6dae85b282b30876e00b92edd3e138045b58cd4628959fe214fd496263e39060c032a83ace3e1f203dd4ca03eba90f1c8f29c357c3b53e827769ff3346bd69379e2982af15bca3c0c27b08e12ee3c93e46238487ffa5caff991616b6788b2c77226ddfde8b2ec47815da9e27936bdd55147c249b13378da11cbeb90654adfe2f399801a7e409d9c9a64a3659c396426e32d1229f5ddf717e8a3a9ab05fa41ded07f0634f80f6476a15ec9025acd2284c8a93013a7706165db6615122a6a01b80f15af1003b14f71b8388c407acca06e7060909aab1197b5cda437c5f24709fa6be22956ccfa5f9d9b02f9d0d099194957685a0a0addda143ffe6e46160e0169799dfab343d573732339b5bb85c4b480fa5b6cf07c7ff923a650235248bcc7acf8776aad1c51d078dcedd0aff9baf3ba94bee9fc60220b6dabebc2e944f7a21c184a976b075fea738c418c06147f71fbe85e9a5f26c434203321d564e160b81bbfe776d4f2fa58b6d75aaa66f8fc83493e3cd1fc4b29189434b1bb460adeb5da91eab9e12d43e457549125581a12999751f83f193599a78168e20852d5712cdf4b2e4b1d4f1b564e02d10c14dc1a4757f8f50e7db1a7b43a1759fcd27b5f9d9515b0eb03275d8d178d776d51dc55cab59d342b7037584a32dc9375a787850496f2889d64e1d586b862f0c0891a29223fde472d7312c01431ba6d69d432b582ce71c9f082124174abb73eabe096a6ffb1d29c2d23f5b6d6c9dd2f02c27de14931db8ebb0502cd0fa76950253fed6673347293feb2d9b08fbf61bf7606c690129229f4b0a7c9119a68dcf2c8aaf385b075e9144026c8f34875ccea09c8934c14abe36bb5f0d805b221938761dae52c283337672325161310605a14eb381b22769a6bfaae7e9d879822728e02be1c2e29f11b47eef562f59f9392178452420d103981ecff559880375a5f8c55fb1465ae7c94d9f57d0004860b3d4ba6d551400bcf41d7ffd98f4cde768b05e88a7c8db106658d839ce6b742029eadc478734cad53531818041b4d0d67cdc1a99590d959a645507ac8ea14a1e67398f8eb4757fb01b64a11d1b8395ad1772ee0fc3a326064625aae01378f47d5dd251fc37cc8e9fcba4e0631e039a05a3699055c8ca5e737968d34f84c49100c19911f950c708b460524b9f61e057513ee3e516ee42f7a07cd394dc8f6cfcbef858d1ee0e6a705b9e86a6d12ba61d503a56004d2d31fb045b27fa899cf9c9c0a2dbb84ceedfec7272d090eb84084671c2e5502e3ff9f7069f71d1d6cb51bbac2a25f4caa899565a91335283d015de064034d91bf0abdb6f4b7c504ea6927aad69fc3ec7301c1ca0a2d83845773ec9aaf3df26f49f6027fae306c616708aaf543979fd985a3723bd0a8e2c91226dbe37ad647216b6f56c9784b1bf08999e3f7d48cdf1c5d36bbe77c84852a43767c9fcad22b52075de35ce7c14e29104d33c45c349738bcbac379529c3d6d771bcf9cf96ba579ab7635952f986120bd0e5c1557e892056f5d954e6d81d2c74121970f1e75a0e7ae697c4fe31185e32d011b9e7c683f449933b417896d95deabe26d9540fdada8b4c53f057c20a5003a0b5f36a7c42a21b8518323a6b56f3520b7a800ff20fe554f0840f1d8d165e1cc891dbcd7835f81e5b3ad48f664aee1b1daf74c423abf1f0a4617357ef3d589240f11c3589ca8aa06684a529b5cc82920d4c0d3ae6b2ef7b5538ebfcdb39bc95cc62695d3a1a3eb1f8d5f705f28b719e4735080e2d2f3e27c0806a11656f45e5fdb455771298eff7a75a7806803c0980d0cbeba2c75c97024290def803a36b8166d99cace4e32688c971a114cd4d392d58e162d2e87465634c61bbe712f2aa99aeb6198f7be9f89b287a4ca7a1c8ecec3af60a7ab20fdac8ed61197ba905d0bbae69ac11b13cf73eca5d66da39ef7da2ea5f3a14d29717b7f95be169efe513ec6023a532bf225057f1eb42a0bb9e4456e09e7e54d44308fd8155e336a032e868067d7b2ea77030120ddcf3aa5b4007756d050aef2eedf7264fb0981ead6db754dd6ba3ce84d3182624091271e4f3f152696ce1166ef4ccdb6977bc80b40abfd64b4c136e8d2a7d6015717d879637dcf50bb71f80627d8476ec2e211e90d08a884faf79752f89e51c9ff75e1fa6f3ae07a5430641efe65f14dd5126a27c670aa0f30a7b56cc2555bf9a3e6ff9d9450492991f7f009e13d21a3a619b71f6916dfde28ed288974c8cad43c1c1fbdc53df4f847ad2f4fc93e397ee43106ebaf542e83cce9049848a9e4479794547bf04bbcd88864b65aaa906926840cb2873ec744dc42a3a93aa9454fd58529a0524c1c7122b1a2d9723da55e468db5b19198d2e688b354735b2325ed16aca7630309b25fb9b22b2b3dd54275a84c235121edd09a95cede3c6cab329d936372eca4b929145b1cb5cfb72073f22e0cea5b2df099a62b1ea01582cad3c79e69fa7796869d9bf482451ff32fadde7e4f610bb645e2c591163862f290fe847929106006ec5735d0b361ea3e85227aa5511ce72c176a6edf6ee675c6661013c3259201bdf0f74ef65dcf8354466bdb6d3017a4523ac6c1d2ddf9193f7571965aa2a3ecb2c7ad92b76d11d577b40457b9c14134a5de6b27e1da6f60c7c30741030b8447ea9945bfbf767646923dd8266c364a3f89af01fe50dbf62fb2165045b030ac1bf9852c50fec5ccba44b91312eb755725bde39c596ca70fc5191e1b48eef56b31d8049bd12164ac3b0d27f398bb60067c18029c2189a87abd848c13fbd6c601c340f8d0f84e12337453b416fd3ec920761ae94cee3fb9260e77e025ba21feec85dc9063c639e945550911cc1b22a3b2f0745729e483078d96edeb25d460e78370bd3411662a3d6fe18a0a6743c2b7ece59eaf3d2436f374046d9f5eddb07e1bb5cab8309fb774411e09d78d565f32a49eea80e0e2fbba47ec685d2b0e521dd82cf5f17943d15ff766d921302362b052dced4fb1a8c127b5dbc889555e53c0d6e6e188ad73959827d884feee655ad45a477381424f8832cb8661dfd9304e6443ad984b4f9a31edeb98a047b0081107db4772c09b67a4c2798599188d3eb36c2a4bb2e7ce65d6be91c2fbdd7a2454461eb0da32654a5a7096be1c64e928a39ab3f57df096274a70965b5a5435e7af182507421bf80f29e0cf9b55b6b52fb175f239a3b907e6570e90d5c91601bd3b6cfa5222a916110803de0fa26e7a39d81945d83c8cac5060c66120130d00e7d78c7e82a9cb7c94fcd7373a23e503a02c6e3565194a2d6521975c3e3c7ed9d2f3af4fb895cfa7574d46eec6e40d662b67ac7d19343aef51f5d016b9253260f1cf956c21d8002097f978dc8d46ef534e799086318424a2018583f78f06c08f39a93886f0e12bcf84c53f2e88ccc3efd71bdee799882af0b2991efc58da628220d5bc14de716ef258bef9321ddbdb3c1846beb3f4d2bcb93ec97fbaae5e445eb47ceff677f79f5f569d668baa6d60d7d2fed7c97861c83ed1a9a490532ad9b4c13a1daa1583d4f51a41aa8655be522b35b5bece3cfdd83e8fe8d7809ff4f0375817f79eec152ac91bd0185981382ac0dbe0b44e24b577b9e4483351e73c16be87800c352437db5834bbe46f0e8fa8a670f8b9ea0fd62710b6e1bde92d5b8882dc9f3adc4e39f38188dbe389993126a5243e8ed106038ded10d11aa8238593b6446f7b8d3d43b888fa8d2a27cbaaca490da137132046a0df1341ddfa2e71d6a15a20a18c2aab9b01892cdb5781420e80964250d879cfb595a518989490a502d9d0ee48f2f5f9b9a9bcc4e848f692bb1d975da61b9000fa5c9048cd3d68d09736eb78097e18953550b44ef65048ef3173772b5185f6fe9a3d916a5aee67c2255b20b324bf614b9f51279802e8f594c216425bc3625ddbcff733a42c47bd22b32c5662aa6b6f3f19e11c79cd70959fb8e2ae412bdda81445210f89a07385bc939506784f18966a82bf879603f94cef797f932a0eac3bee61a8b035a74631e056ed1736650a8960ed49eed33c9c7850519c2483296531f394e9c716369b4dbeab6cc781ce096b1f02fa78684c22a7c98effe95e611bfe789547395bb9f5c0db665410d22848d6ab8294c621f5fc83a71dafe2f7bedfdcd49e7e84479a08c4ee71b3dbfd8e1901bfe8749ef270f3011a429883610f809de6b06575f92c63f52d7383156a86e9323d10a8e7008a9c20c0b69a41d8559ea0cddcf7ec8a9131b7c0fa4087475bcd2ebf93f5ab3008292167a44e7dce092b4498ec0e1355ef62cf30e3f988b54c2715ffe9d4dd3c25ebb1a0b71f21e9b8b31646194712ea97714aec4dee2fcc8708cbbed17c83371d27f2a0ebab8fafaa72af0551a074b2bb2985d9922b13f94eb95dbbcaf06935a5548d0d31bbf698b435b84d3c246345f64a6ed790064453d8f9b92260633be7762bee15c06726d54a608f0f7ce85eb9ea2b0322a727fe2c24fed53999fa319e67f0c6ca5091309abf64ac0cfabd2d9a058e07419c812b1377a88ee8ca2e4a7a4b1406e72e5d2ede1b7d81c447ef44da6b48aecb9f3152dcaba22b0225f2e0bd0449c7013ebd94f6842da77e49793f5955336d040c1f8df579718d6b8423b63ad9c784e406d9da4fec154cdc0394399021e904cb76b1782bee79434b96284e3da66bd9f36ebceaefff4a0712a66ced645886e6d57529161be812ce41ef5eccc511cb111b26d9e67ffff8df6202be3f73e75460c1da65b1c498aa6dad515179d741c06edeaa90f337a2b7a5bdef675c490559d30183bec0de3d08e75055e8fd57c8ecfd167c31a2e9443f72c9d37577fd37a27d6640b42561e47d9da64e3d309d0a88d4ca6f3a2366803ac39a8708e9ca6b5287badccdab2b430fae489a2a1cc804549c906cd3ba6f44940c7b793ee409d46248f89892da349aa5bbd87742f6c0095303b6fdb438fa31aa5337eea98a6a363fc0b0b40e28942e479e65b55a1eca1f0b68d5afe7e0210f63e711322201d60f43341694690283bfa7dd1e6f9a0ab0e3b898aa1e98797ae143cb3c47613e99c1024ee7cf59b5b7df6d74f39c264ce3a4862e24550ea63807a63fdb084046afc97f237c0a168fe2e621df4af2a798e991e68615d38a9a02cfe54bb599758dfa604d54b84325a15861e4ba4cd5bfc38597581305ce1af31418ee62638f771a31d24bdcb2a731f7dfd706d6d78b5fae443395c4e611df5e4fc17133de61846124282be006dc9745b37fd0f2a206b457431de73bd7273a99bb2d06347e819faa9f192f9a18767afc0e686a66119c04238bee3d80557ed8c03bc34a308f64581ddc6a1270ae75dc00a88d5a565d094491e393a28276ca613fe064f4ec9e294ae82f8316a1617d2298477c1ffbd6acf0c09d5c2919162e7c797edc3f7c3db41021ff5606185694fcb4fb017164514d08de4ff6dce29366c0b4b77b140a8132955a7a97bc773fdde6e5ba75a582b86cc891c392995b5580e3282cbad7ed9df781b2b8a91ea67ef98397acd3d4a7bced1c612212f46be9c5a6cd729a632aa59f244baff8bd9c92c9c54d0b52cbb1f9c8410f614dfa2bd0c59327e1045af5cac95c76b264054a8c48c848c8e21c5b5135bb07f8fb1ab078f20b2022667870c73ff404dd34a733561857be6fbb6a301fce6d41480c832985d8c4be87ca09b7bcc80120aceba36461be89f73a7a6afac1c9f47a2bf1bdb89da79bcb97e308473bcfd8e8cd257b153498e61b409fdf876e5931b0fb7de69c3bb3fbe66852ea805bcdec7ff4ccdd085b026932306debd5361156268067d72420f2d53a1c5dfa60c6281003ba497d646ffa7e140aeb6b8ae54ef4f2b70275a4c658caa187bb7f46336c608833772e79669d3ea712ddc09f4dc0d538454524d04b4be8b29a767727a590d0b83b8e72542c5b6b3548021ed963fe3fa57e4c0d6b8e219a75c8f9ab4d2dcfcacf25315467884b2c1bb664254b26d37922374692cc69fab3422f990955877f07f7e0e5777a1be0dced41b51e4656ed53574d5560a4b00e08b4f6fa714f434ac07edbe5a88f60eb41f31722a5d93a2419caf346dcfea1ef6b41e54d694d38231a067661d0e36fb629d3e6ce301e600b6dd01c46b69423d5b402fcae3bb4203e06caa3ab5775730dd261dfc0d0c2e8251253ecbf581170e485cef378c0540b665f8672f95ac7f75c1e8107bdc2a734827a5e8e77a58cd731643d45dad91cc189f6c21cda95bcf25b8d78685ef4478690fbcce0b86e1c67e146e7b2ae5c36db11b4589156f04ddf22ee5c56384f86f2304d11b44d358f5d3e4ccac387b36c297727e47b557483cbacb35d485a18c285709a4d86f891dc9d787f5983aab576d24227482216a3974384b31815f73b0e1a28f55a58155f1d5445ec6044e76ae74d0a1d5ccf428b5d782a20abdb27a0138b84d3448fa05aca0181c8b8c48835bd7848ad1cdc496cc44fff50355122e9fbc68a6bc28e0cbb3be9079790b7f033ec3ec49a9c7e9b37833a785eec2dd15c31a01b73aa4a7cc0262bcedbac0fb0b433d1acb8fd728db7aeed19a23b92819d096c430f008d20ae3fd1bf8cb5ab3628f7e807caa483b41b65af8369d649ea25910c4df56f90df09348570af837a18349cc000160b923c465096e622fc14eb0262a0607b15cacfcd862092492645e9342a29598cf7b245fc7d83400de643ca2e9e092767e51698b4eb32ded4352130203437f9f85ff78f1c40342e3158870533f7732288a256b0161c3d7c014d2a3e212759f7500b187c6a8a390a4b5b4643e6ba0db2efffad6478c70a05839a66a1ab943e71613f52fdd779ebea1ce4b11cd7ff0763d4ebc799ffeca31c0468df8a4586ce6de820669d50d5ace26b12cb07d539762d0d0f775e7ee5ee15e7bf11f722a8065dfa8aefdb9add206f1c56fe0a96053421045414ece8de8d0fc35e6544b0ff7e43637b7917857d95aeb2f588f0462f8ee4d5ccaf5c7b6fedbec16ef50f2207bad96707b8f96541940b74fa114aed8b11079d5843338dd22ce96eae3de0444bd77b1a1c25da1d13c151148efc3810bb1b03d3ccb144e58a2cc858cb7648844664c3b279d70653fff3400160444866ff6d1d7e11dd562fc732149a04e684c04dcb4d7d8db72fc01ed5fe409ec454e092673757c2928d8415ff58505613d0c347598574cff88fbb62af0c962cf37c3aaaf64f15b6595a424a8c9d5b401b53129fa51e679fefcb0adddf2564dc4e5be4db270aa8264b65a36b17415ef28b0114f45d19e213d8c9479be38da070827703bc194f2faeb687272411045ef59c2d55d014d1a0506bec9d2c57ffcfa9f27fcc3dbc58e9500c8d5acfd863fa7ee5a396b5ba7171e566d5ed160586084f3d350f15e2e02358b6204f8b632c9883c0f5e176eed676878fd844354dcc8f6b5101291042a1be4be4b6d12ddcbca33fb9210ae72ae78a48ef138b53654e6062d1442ea25e823f79ecb760a3b7395a16e7d5d8e4a983684ced3ff4e06fe580b0d5b2f8cb4a8ae4d6122a5213153537f01a57928ea7298d0ce24c144c8b66ad146e4190f74b1b12bf7a4259d93decf739a8a27aaed293ecdc322a1f1deb14f0aeb337a44543d6ea56a9fafc5cd3657361cba04d769ca2b53abea10b87c8f0fad7894d279b2cacbb56a1c01e188450ebedca452a9e947e63399e3433275de84d22282edcc62e7636b679602e9c099df05277513e0f7e5ca4629f69a9a768f69fc3750b32dbf8ea814d30e3b93bbf278a67fa5474a6bdf4953805d3e13cef2d35ccdc16a5986d547a5d2e5eab5dd9a21dd81bc7a7ac7d8717c671f00b1f03ad9c680de00468be562e742ec31cb2beeae3e7bd7f0646729863f3f0e0e24c0c6818628d1f7a5ba908f231e21b1fe6e8dc04a2bc2a784e022a632ce321093f14b9e565e13b00534b17d445ad3841e6658921f028ed97b0dea01b9f31b85bff8e0e0bc1b3a922bab0e05402780e5014f1170079cd946b10e154cb33cdbe39375133d6273310bea12ba2a693baebb5cceb605b8fa4d7932274807aa06d513b4d2abba4a5004b4e284c6a8dddbd9c1365c597f875056f5edb4de2c97bee8ba63f8ab152e7d055dfc1e80a12755b85cad60a32cb936e29374993777582bd1b41c7ea75c1c0f7474b451c123b23b0687b8e708d5961486726a4e6e786fe658395f01006061e91fc2214505d627445dfc488f406fc25e5e6eba3ae8505e3794fe1a930b4ce786ce93f5ed30acdfdc983887a97e9d440a5e8f0608eb0dd5ae1fe0bda4c52d690f0d03bae1d19cd5abcf05f78e7aabd048117d7a049144aeca0369d31a9be5988476ea8ce26037cb226cb33f2cd28c5e1250a703b200ed6b6471a943e503bd00f5a2cf2e76975122e2a4b1b99177c94468dee71d9aed577416507b1815295435048ad3c7eadaa6605d2b3240be90eca189b669f26b8dc52376a0d9f127396e7f9112e8d20362b5a8b1f8cf25b60e554f47375d7cc58deb39dfe794baabb31dcb61ea4536fdd5998ac3facb54431246d7defc85a210907ae560b205b7f16784979a006c48467359489eb0aad9ea4038e0f1645f287aa7b0a8f4560b7ab436a9dacd5c6c9529d84bf7bdae81707163e8a2a85dd6d2ed4e81e7c774b09176eca827117fe407761547dc3f3bf1213d1204fe4ff487a0b3957fa74ea2ae0a222cf623eee62da14a7c7634c273f416e670c4aaa8205cdc7aca5ae39b4ebd182e570fa29bc2cab16bb84b144e4ce6ce98ec142becdac7a0861bab2f51c61465fc3546cf4f15ec2c986c11b86a69f11673e8016520a50d91162de80c29b321cda8887449cb47f5916ea0e04351851f42bd702b2bc3b5bbab670d29954f4615cd3dcbb2a8762ddeef319e4415f27a44dba66370e4d55964be5f83394c02ff92a6f082ec482217e9358c421f362399a56d06d7ee16fee39cea4a838721e45d5584d73c9526526efa90232488f38267a059962345fcb0859917b1f6119a2e0a0b47c51adc3158a0f18c647664539db61cb247d62474fcc83da7af3d4a0559f8dbb55a33090a171689f1d62d897abbe8d7146f1b5a98dd37698f88eba4671a96bb5b2cbb8779fd65612de024fb8afceb4f0335dd40322d8cf970310dc9fea91d933317ba5714358cec072935040e9c59159ab0b6cc0a3031884af28ebe840c4f8b0689e8c63763db8907e4bbed72af8b8340d6a44f3640a0016583cfe5065cdab1e789ef8c16c1aba39b1d5e0addfd641ab5ad8ffef416b41028f0b2971bd8ad1d94547d8c1872a026cc3656cb21d1424031b4e614a8297188b3ef7d4e3dfe366c4da9f5163d28b3add86c1997a7a7e62f55a2f2a4514b80ed3f9f44e22f66b90b8529cf1cec604347eebcf6156f0592bfe7199436ec2c9708afb0f78e410cdac76ae85cdc815249bfb4b641a877c02c3426de685ae2465a45524a68893e8d25d6699f4dd2f40e362acbf8a8fcb5d20a1eb0785418e48a11fe07280d8457afaf096f9193e56546439b622c9a2fd62110e839f3a11c832bcb2fb5371f0245dca0f4c0ebe75bbc1c23cb81f13360d9581dbbb875e36157e847098dc6b7e9ae9d6287e188d85c140bcc6224caeee527ede827c3ef3a636d9c93541fb6d7d3f2664d8362366db0b9fc272ee15fa86b3838222a0c9fec254e5e4b2bd847180e2f12dc9d5e08cf661b786725053f75d0ee73e8d952575b0faccd6206d8a8c9480cdeebbdf137d6f7417d343d8d642807be5625db6f1152d6db5ef6c9c516ba8ca0e2732a9e32a2f47a05545bad8a49889c0b284f05f8904eb0de33e99373f1f7ecd1da155ef294c648c4636effa3474e577699ce539bcfe3298669714b0d552bff9a36d03598f00ba2c296e4326b98f09d6b0dfbb0f3a4d1b1d364fb501b05c283c12bc639a869699f4a9d0b06a23d739cef3e9d31a03b57d5670d1f796c321ef34c9ff64923acb9a5e3029465557a408c9312fde827e95f657432bc73ae67267f372851e8a7220187b5f93d34499107bc7da44b55fd0803710fcf507fcfdc0a04cbd722f9e1b8227da1ddef2d57a44248c07c11e3750ee15f9ef176beededb3b2d378e7496bb4d016cc76a985920fa4e0655cb70738c3029c5940d11ab36d3756ba7e1a0ed376d04f7a3fd2eb9a5502b9444a1ed2c7285cf047d59a4d583ab7e0c14b8d648326a97f46db24634908b589ec26d170e5d66f3f82a01493d186d103d51831a7b0a3f5ce6c3db7d369119570ff3cd385713d76fe66e0a3c4c6c6f5d8f53e70fdd64dc0f7097a84e4e5647e79246cd8a47158c579996f043ffd87499afed94c31e3ace43746762e57c3c9be1c2cc04cb169851a7d16f64ce80676897d78967c60435411bdc7b4f36d13e3b3810b4e5067ac1cb0ae177787e694d0bff12d1ed21b0cb44a13e72db55248e0231f7345329842f94eaf0e08ad7e4501f9dbe852b29f7dc858390232b2230f78f59fe597846a27b8590ba8aa48ee00617334e44bb62c994f4fab5ca5cb02e7324ebdf3d75921647fc79074e2bcab9e65a161f4bc2070e762aa06227a6c2f640163ae9f2294d4a7741d1bdacafedc927c64b89aa4ea67d399f26373e352912b6142e2587960654c26ec13af0cef059308f57f48fcd6437d92da0f51505924e24eec54dd0d636156c270a11d01651163b482079cd62900b76bccfe1eee3b7b1ec709e3bed857f92a39fe0581852c92d54c68ac2b622941e255ee60327c964599843ca73ec3c0a1a588b3e85680375ec4a7a78158482630159bcd4de2ec8f876415242a0216b7da22c71cadd469b18e7472ae55cf18b30d7770e6e8dfe74ab1eb456a19f62bec056b27dc269cf6a7c2e4a3b1a88de1ddef7d3e8a07e265c59afd7fd0ea910e7b0485f7b28744ff4fdaa6c654703656f80a985197c192199f9da9657162ef777916ef06fffa47504a8bd5fda5db1914eca3d3462bb8f292a99107f350187a49d0af0d75fd940110c4f3b0bf44fcad55b1e6f2d90c4cd0d619fe2afb03c53a5bbed9ec5383440275bff0cd649f5f277b059cb8c60b6453759caa8fdcc32e66337fe8ac841750db9b41db4691451f933076ddec0ec88b5fe2ee78657e43fe12f55631894ab40bcaf466c8bcff93d5cb976bd44a9e75d11fbfabc42a7252fa7945281ecc20ff883b461fc6ff8d34390b5c133f3e61dc7234b6bdcb791af9b875771a5eca3103456f7580995aa7dd069e945dcc8e0d6998fdd63260c84acfb7ac95ea5b8b23c670e285966f43f5a0ac6919c123460cba9cc0836b837369fefe57cb72af7b700812ef721f025e59262e1b18fb0507754f8c4f0beaf7507371a3093a8250221394a6af301884ac39f95196b5042666accc46bff30f6c2053a16ff1484598d766ff5ab45060c48e403f8fafdb8a699c645727f6468b2f05887b870f09c600904c70424bbcd659591e21ca9cdcbe2f5a6cf914251cbfdb565b4bdae2df3349aee5bf7751f8df02751e745f68f1f45db8f42525da0be2d7ffb3d50537023f569fdd2daef7c9685009eb2d910d417fc816c233cc687d6b5127802e6a20c327016d1a19877f06bc058163d26d7e7d2b3f95a33b3135f644cdfdd4a8dede2cf3e7286fb7ce3039f1ee34089636b37b585bda5c6b325db1b9827874b7fc242a7a02bc81ddb77cf510aeb029124c10253ed0c2a6b078ca20df919b5c5dc622fb2d4e3a931c3512af5589048345e465cc84455bd20a72317dedd66418df819fab51a9fd71e182254998275367615ea7fc9d00245d876acb2c1da1894f0a3e2fd078f03c9533c6f5c420b549a0e40cc979b30c416f830e214e59ec128a72bfbf5a7950273d4315dbdf5bf4ed11e02eaf3ad678aa05efc3c3061db07fce54b85fda7db0f6ef93536989e30ec71beb96ad3233998ea440d662894eff669a457fcd6f1a9acb002afdc740b3b4e659f720356e16c8e5f82875c50f7bbc656eb4045ab9057dd89657a10b7d665d3ea2afb21f4b93c04d410dc861527de6970102492db4b8376d50abefa596578435cb5e9823ae3e124fcfa8a47d53dd9a20d363e417c632ea2f5f09e088ec1edcd00480da54ea13ffdcc606a952fbc46a1487336d81b526fc6c2bd0deeeff99e66735be74c74c9ae6727869c815c3f9438fcd4701ea5eb411625be70b883d093209a9ff9e020976237d37a7a33769d1dfd70c3deb72413437c0510d7f86b4c0d1afe5a50e2b72d8c8bde4c9d3c6025c58a7a24ada8ed400f7d328b485cddd5ecd96773b60cadcd8df00d82e9485b75e51c832f4359d9044720dbcb199b3d8046f60e66cee810e85f4501df2e6d3fdcdb637752d24651812e982d498295f49f6da52f167992cf482e80be49e618621d71182499195e5ac4100180f96fa5ecee04b25c8b79f17b14ace128e0056395a5b522f7879920e7b3b18f6b70a87e490e5803f4df8ee8861639b5803ba90eaa485ea79ef7f89e9bab73583dd5ead953d443a7ffbebf3a36e16a7198d91219d2f20e99298e6509c6863602f9b86139541de84903e8a52550ce5a87da2f89798f67ccb4a57196df990bb134da43d24e62535e51198db21ec245cb103fe64be086faccbfb64e4affe4dc744e431b0099790f4adab4e46785ab45bf3f14588ca06c3bc4d1a4f3dfcad5a0d65ff210ae120d4d594ece89dc4b5906b5db6928767a01d94ac36ef17815740f85e21c852403b1e96465e5a709bf5fda477bca7bf30c7d479a86e3fe206a7d06cb2329cbcee01f8b322298e8ee057322e5ab8d8907768e2ca950fce9be35f2722cc7c4eb071812580c97fae1c5a530c9fea7206d9c1951afc5e60e8332e09b43c15b11d3f8ac3ea5b387606969b96823a11dfc80bc2657485ec5dfdcf1264bd91a387646f96c84ce2b469afe1aca71c2ba5e1c782f901aa3f44ae0b246c2d49c8dba229c69fca0cedbc5d8d773eea0d6a8d0c0fb9e6d16579047b05f5c0d580548563351c49098a6b34a602ce6c91599a41ac8cf4da8535963bd10e630357269e438be6524f53816f1a21948084b662757ba245170895924140a669ca6b2f4787c66048ff819c58bab5c706749d71cb53b052f3fab4aee1eb529f5451f53e7f19a5dfbf7bf8ca0900cef675a50fea13f94425998b2b30a6a2ce473b71362842b5a1d5999f14bda064a8608f616e39a38c3408dd234dc3e0c9d863062a212c516d41de4089a34b4c350a43d1b437d29a8a8f5f7d8c218c5134bf10e4cacbbfc7b3f368ba1acae3399e34504e079c06321968956f07e0378b541b5dc1bc29a4153037ab2274d09ec47d28f4a5e866744e46b58c0158787f748e959cb156500a1e9c99ca33f948982d5078ee8d2fef95c69c7beef1e80f6d3c6898982a4b3859b3f7d67a6375ef180c29589c7802f670d61db9be0171d655031ae96c4172228f328d046fc5855439049d7a940ce4b7ac4e513f7471035dcf1ad7e1746fcc50f06a90526fb2bd0b0a57c471da144062d3082c95f3170153e4ecc5ce0e6a2693ba07082a11696c0797b14b0c90a257dafa6121e0b4988ea20104c8c4f451e0a19634780387a50f5a0a3bd79da67d101791a84bc2dadf17a3d50df4e1611dde66848fcd9b3dbbc33955a034833fcab66536e812bfc1c1817a167ca18c211e20b79151b4dbe302e4e33448b1ab01f740cc3b982b2621cec7f122044dfa981769c41abf8a29b419d3bcee02bbc176f82578fef7ec6b83b6c616ec3ad68cc8a8886783ffdaf90fb5287d58480480ec2e768a6118910dafbc100722f15447c9d523cf0322f66ee2c5709617088fcdd9da0754b266942a894e5daf5ad4b0591586d470a8080891cc8cc07f6925335ecffaf9d798333a53c7f556a3faf6426eadb7965d8170acdfd142a1f246f8db4b326f64284075ec21f9428ee923cf85046a26772ae616275130f9ce521ac49c728e4b965e15df73a1f83bda4703ccf1b31ec9bf915010494ae831113bde2ff3549dbd019bc6c6a815a2bad52035f2ab89f46cb4312e5dddf56f1c2fea6385d900d45e12cb4fa72fbd22a82ff5197d0807abd900370e4e2b3fa1ffe7f5e272ff3c517c1e9145fab0b6178245b1a93d1e570e073ac0abb89bc686615d27c333c73b3d8d82aa42b852d3e8f76ef06e62393744f5dcdd274cebdec18697c3791ed572f450f7d69cdbac0be8126cb6bd547c7368762c2c889485090d57381f8c699bf6908d38ed7329b4a3e4358880f3a3663985472c8e1b8b0f479b55e7d9a6c9caab91f53a055131f28649e5114d86ae59ecea3875e43dad8e8f2add87088c6aa57a529d9611dc3f55bbbdfdc60a2b4ebbe9c6fc416715ca4133cc6ff3c2f6fe51c8c23a698380320edc4f02253cab2b72d76cb0f8369a6709f44bbcae0f4c934236333d78a094b1904bbc8d11946ac2efb6021884d5987dd272e23bded4d7ebd316f84e5763764419cc0788a8f9505b9a0ede85c93fd78f0c2ddd6c58c6e9df6a658b782d85bd1caec4aaf12ec19ec936123407256f37403e706d6509afdf0b282ce9bf76733e4fa7f6636af379b678f6b5fd85f46b552d9929d73fcf06fd63e044d9dbd8f7891e65059f32cef8e949cb76368546b7248c49ecd5539bbb5c7a74260b19e8ec75aebf8aa6a0ce8c1a974ce74c7111326ae8566f603fc13bc6a1f5e6e94a2110f9508e069ffb17173fc11b2cc5a7c1c0f183f2bdec5c3ce0eb4b003b5894fa7d347cbdebcfb91976134ef6e9cd4909a07dd57365fbcb06f5b6a84b431aab3a96824f2e073c49b89a6d119c760bbbae74aca69212d4c95c0e2ddeb9bc9cbb9ee4c809bb89d3e66dc6d2adee09d37e15d028ad75ac857c95b701fd977b0b572dc11c537861f1e1ba990fd136240c0a50feefca16e9feb2b57febafa52d6fbbb14b62c138a72e80f7790b3b2a04df0342fa73b4736d31f579dbe290da300fd4f0465575e2372df2c37d236bea40719b41a91ee6c61250069bce640ecb9e8fdc2064fd21d1a8c2f8ef487b3f12199374695d219361609d9e68fd4abc9ae63653b4146fc63bb1023c8355b7dd20577e7c007d18e47368b927fa7b34a1efc07ce5eabd12b8815efb4b179a414a362929c5dccff008f6174fd985c670d470ea75f5287bd766ffe35ea9c88b81925d7c37cfbf50a2677919935a8e24d1c7a422df3850d8f0c835dd2ef4a07f0741b2adff17b3435ad286cc6b4c7f77dfd4effebe899ca41edef2c202df5b49ebbfe770d61e3ce3a842c04c4ac789f399d5bb20964fe6430faf571b54b2b8d98138bf1e60db1c6c4273f22949eee243d2cd25aa9124867d64158a96cf2bd2a36f70cbd221a288a8a62b5b11463a16b752e8c4c10b25222ff5e96fe2775853fe62acf83e9caaba0e2f3ae3978ba2ec42d1cb70b5353f382dc42f0caee55ef51c236f5396a27c214870369ca9c8feab413fa64972638c6028776c97ea011fd934520170b03b207fd35ad10dbe7fd3fe19a28d00dd0db7544b5d5c876e52b6464df7777ad9345d65c63eb4092a1af9c81451f9386a1619754e75720bf4fbe18bb3c53207c610bfbafa1a0afaefd693f57c695d1ea635b400f082b0de7c477898ca514dc6c8a5612c605190f77ae686a8a918886382a9981270077975854d43724f75f74bc948ea81bfa489481b64f8d39d442b48f669af3004343d923d28f8db21742d2066d4f970d446efec9fa288c74a81ba01d9fe9944ed29ad1cc75b3290fcf441b5b0d5b27df8140cbb17404751c1bd29b87cdd2ea8876dabf7f0a9e75d872211cf21a4d3acaeee17dc81b955d4af670358c4783598d7e8d9aced5bd6bb281504dabd4ee206b602d042a80bdefdd681d3b0f414df88ceff4e1272336dac69d00b537d79bc167f32dc25299bc9f601032397845ab4decdff7c0732d9adf2be518bd1191ab8c50ccf1960667cb48e2c7944b8b07815b91d4d2ad11c17db1bf58ece8cadaf5101cb1636743693a827b83061a8540317ff02336e1500ec19f5961ee38f27df71af1186ba350bc0dd1e1be800340cc45962e198663d32bfbe0d66d66499d01405947e5cfb94edb66705eb6a694dbd6fe50d137daa7f6ef14171852947fd11a1059d7fbd77ebd957b2cf27ce7c8e343b5a046a24d1fe4c057286ecfa6faa2e0e4c4ef87f25544dd71281bafb0e4ec4bf49d1588ba13697baf38318408548ec286fb40e4d4d27d77fb5799366ae9657ff257409435a0a367fd0cdd78f2e88d3ff5ba7392f4aaa5cb6c7ec08c75e2252cf34bfaaa44d40b556c618aeabb7b31dcd490043e23dfd77f50c918d33f327da468e4d267f99151ff6f48ca0705cb986303b7f12dea2e2565158ccab466014c952d943df34a2c1a96535a2b6183825f8008fb39522953a9ad585672fa61c7e5b634f224c898fc6931bbb60a9f4dafdba5b35b5f53a6f785de16c494a8232586f44a8eb4fb2a8a1e00de1bdb5cdda35c97290498eaad63f5d5e3855c09f76a15453076a7473355ce2698b1b9d5926ce8d3e083dfce650816e50ef5c1ae2af3c159deaf2ae45cb6f687d75287499ac18d7d7f0feb0b121ce165de5ca0b8d7139a2088d0fdac354b09f5f39357444cec889db276634c90fbcc2b401bb8164e6af686132acf02597b85dfe6ac86fb674103b578e3001257e4e635958ca6f8bbda3ccf4f1a60966f20332822fcfec44833a8b57f6036303821454b2604f5f8ee8b5c356350b3c7378e3408d20aee4a495ce8834539a7a0247921d1afa89f0f6faccf9bdaeadc55e52ff44c2e4b0eec423b569fdb04bb8d38942aab5979defccaaa1d3b623ff3c8c2ea1ec26fbc9de96a19c06495e34f76a1d06ea5702b2d816f8a4f9728023bee70da64a51f75834af268d3910e206ec8779d6f08ca4144d894495e512549db5ffa1c4d55978f2f40f1b7ff16cb379e6a9bbfef6babb350bd29e11d8396c3294363da71497851eb969ba36e429d6e346343f1ba673895209bfb943195747252f3213c9c9bc1baafc9ea5adc4378ebd4a162bc27ce61b6f2ff3a88f4d842eb85d1d91e39d28442b904720b2c4d135b6930e012aa1d0ffeaa559545b8a9d238da9d35d6299bee818325f37bebdd663b83a835ecc5f4018887962c3ee0ede00096888a24ce681915c458e964bd6efa4dc9f70848f0f152744bc29f0ce4fe98e0a1ae5c8eaaa7c6ba00752a4fd23cf31f42da7e43bb89a434d5b4ae883e480e5bf286203d9942af5e38d9649709b81b841bf596c0656beee79ecda395df1f1766c59ec304a186415506103f64382157e091096c610f75c18ddac97c03b86d41d8c6de91a6098fc1733c45bcdd0196402f46d53a1b8352181c7e6976036d39b7bba05dab8ca81b7345f8774b2b98de12648f368d8e1cda2632d1ff89323fd8e75551cb99fb53fa8caae80e1ca24bf852f17be47182138245810ff22486c3d53f4fe22b7959e0ceb8720e10a0a58af9b5285acb53878af60f05f9af0842c1d5f790daff5ddfa25e83345cb08f187a42f54b1ae4586dbaf450d62785ba77edf5aa45f9387f728e666b29f0e8cd0c2883f1a0b8682d3ace1552e9759fe2ab2ae81005f6a8b7ee891740a8dab8352d0f24fb4a740420c27ab2f2b173de4da63536aeb9d4a50fbb5fa53aa1fdede7dd5b3c5a85ff2e473fa3d62316c29ddd9640da023ebd1bf451eaa6b8582149499bc7789fd93ffa141af811e93654034daa37742abd67572a658647835db092b388ab0c3324c1201744b4eed165813f96b61308eddd242d84ca61db509911fe29084b793512c892ab971dd3ca52c90608abf45c3de538f51440f0c68a17fe9f3bf533354cd22efb2bed1a59704e556522e0bd547cdc147a716b385d85b22c91a4caa2cacd891c33b4f1b4d553e38f45ad2248d45812a24c79632e5c669454bff92a4b79d2670e36a69f8d58f069ae25d64cd4f1b4794ce4bfdf80ab73333251faa97ac7452fab4130fd2eb6f2c4e4e9b8c396f421c93f8f301647d1a56251a30ec8a681b3e26d4b392d4e1e896006f9cfb8bde8b00f649356d0b5919bdd83f8662199283644516cf21a04060f69bbf44bcb268884401eeda671ab82833f5201baff008068b1bb7c4fdc94720ee06d913cb11abc71739ddfc367a1c7449e59dbe9cf719a90fe3a74ec8567b86e970fda82e941ecac3b11ed0bd1339e95f8329eff110c9a1e8948b28cb7f6579e2cc8978c2903d2881025aff59aa00010d90aa3a131e5f3bba4989df25828eab055daf3b73e3736089976df6a34a40bd326a40cc96ee9288d241f3949999a3c7a0ca3ed83ce790ef8f85639ceeaf94fe83b59c9b46e56af515ed902a55b4333a3d479e4dba961d3e5f44d2b0791f9ad104b0b27961988063d5ed7a725c9016d70bcb0f9b427a335e302a6887a769f7d0ef652ce27d1aaec8eb4701c39f9614854680248783d73fa65358892530be33def26e25e98bf76e63af5afe385474ffe54bdc64e37704f0325a3c3968c4d7a8b9b2ef67212f801076909f97e70bff508b0b57f18e3ccd191bdc93e4020adc590d5eb7426a820b835b436ae3381aea9dabc9c64c08902806fbf3bc16317c1add7ce3873848c41f171f44797931de10eef2d4e979019eb0d8aa9fb2d82ec32768b3bfb1c6f8b3de252bb7677f8416813fc87462e834d41ab31da2f9058c97caf5faae02f3b8dd730c8292bded6bc9f7988b1c179ffc609e5ede1af0d3ec877f4253dcc1be24a8bc9581a411e6c6297f841ef6555a27344880bd8ef47dac6261ac5ef84b76d8113d7845e20e12a9a52a14a37ecbae0d2345a6da8ce896be036ff785e35224430db16a056c271dc77b25c0abcee58ea1110a78dad40fe3a689aab1cef4970a18b62e6c389d215871511bcc7cf2995bfa14991487e77c9b62a2d923eb185a7ab82d8a98104b1da060cdf755be9fc7bc4761ef7c06f4bb057c8f8c8ab34a68b21dc917af66d820c73e72e3b64f87c704240ad1392f6b2de65bdc01fa0cb5ebf8da56df7b9387beb44dd21e2e33feeefe747aa8329cf451a1765182d78c0e1d95534a5c5007110677b06e91383751316389870f354e39f24a50a2ec373caa60d1696f599f480a073bc5efc03a8177f50fdbf3ff759fc37dcd7bff144a41a213b13f98758ea52f586ac4be389cef169a7ce4b25be11113991dac5d0569bd21c33e479bc00be0ff04dd527d448ba4983300acb451c459f3b6210688f2e379f61a578fb10f4ad5ddf068635555d790b1c4ec564df0ed3fcc503739918e5ff39154b8dcbaacafc5ee74b90049c634cafc5be3df44413ab9591eda017f8f2e3e68042e6f61954fa849c200e97f1342f2af59e788eac669e978ac0b88f4f5394612d4bc771556f1af9e32820850edd4e0ab14fd655c37b55bb3809f328f3b2b1fcc4b9f51db87ccd09c07d7293e775ffe8f1468fd12a89f3db0e84ed9b728da923f2303cf51e5ad7b6f25d5a4ce371ff6940bde5b3fa3ea710c518aa02341d03e25e451eb33df004773079b7632e83df4e8480d110422643496fe3ab897e1adf9abbc3df376e429488bc9226cae16106fd123f34eef44fc0aab04225d5aa1c54021d429dc9a840e68437951453032ed654a725c5339cedc80315edd214381f350c2fdc16f6e31fe7e8cc1f4cad97925deec6de091ee8141e0f7900efc368d7dd32fcddc27ef2383aa3e5e25f10aecc6e4fe1c24e59ce391948de58a86763d08c03302ee78027b869f387179c771ab797b935cdb4383674a0fa1402282671a2e79bf3d85ca261adf95bcce9cf2b8f02852f68e3f54ab8e12a9c796ae2bb26f00bc6af702d71588a8bd2c860fb6607e68caa173d5aed497584279dbee53594efab0da54362394ce5353396e3b7bdeb6a218f076a4226cc5e1d54441fc37ae83ac14bcf76869738f093f001771038721c749c4a2eaf5334c0602df495496310114c56f7cd7bd0ec94a9b2b48bdbf097ce0f2475dc53ca2d015be1efa4d38ad53534a7be4e58a19aa4e338ddbd7b3f09c786fb6bb6812b6a8436153ea8adcc4a207b2eae087ca75d6bc0b8367d6c61dea671e4beab27e002516bc5e19f9d712a06760e94f57e488b89501055614aa102ed441b46ff54185689d6443e408b505adaf0a257b7b61759002cfa7aa7a2af2afdd57035f5cf174bb68e5c2f6b5c025a451f23b057870526ab4862ff282ae0d0d15fab3f915831cc57fef8fb93ec222d34b9c9ba747e3f8cc417a2e6ea3680ec90bae9d9896859ca25f8c6193c632aa31862332fbf704fff04454cc92858c3ddefe5db42b67bf8f05d0b501c35f958c2e681f23fbc89d72e9c7746e813dd3fd4e5562e1414902c456e0677db62ff566aa046282c92aea02e61a99ac05320f717365efa93653ac5c842ca62ba1cce782fbc93480862e253c8faa5b85f3eebeecef891f9059230f6734c309ae9f242194f18dc58a8e353e45b5dcad2cd3713423ab9f29ebff4e7e0682524716fa49f822225ae79e189c1a209ed60e496dbef174a9d2ca9482f1dd23c57262faac54c97e6418deb8b1239a76e8d911255403ede07dccf874033034924d55cc5b31bd9a2b3769a4e71b092b1142ac9c5c7e84877952b5a8664259cc5aa75a503cfa821d4fc24380f37850055810d8092a81ee10850fb35c921a7cb2534a620fe3d086721c2b0144088be087509f3e35a078265dcaba9dcaae01b1079bebd795d5f5629555157f942b062c46187c5f555d74992ed9d2e5906bc571f7f4cc867a93a58a871883672ecdd6f7b44ffb6d95415e899842dbb601c2e4df437e16538f9ddb767ad3a16969f765be5bc05ea9590ded31b52d8ccbee81cd594c2fde055351d45cf49958e5218970e9be45dee3debb82b5b0395416814504e8cbbec12cb1dd2e7998ed19269dfe866654187d1dc5310feecb2bbd2d0cb9aa2dcf6eebee7743ad1dd089c231517263653e11036dcadb310cb9f8c358e9a97c8c30e738bf4e407d1c3b14a7a64148048df670a5bed0268c62c1f8924f06e0c99685ed04f7a8a03d2fba0100d4a87ba5479111e8916d905230c961d98060fe052793541ef9fd6ec4193894b46a26aa518d2e65ea6d7722fb02e01050a34344ef068cf6a537d221887f771188dacc6a00d608040d5643790f4a8d46d461c9a79e169d418834772358405d632de559db259f30e3bf4bfeb6df50b8ed6ca7ca7e0bebc08bb7427e35296cc36f4eb96ee5e186e0c8fdf6adea30fe76be2b78bd1b03a88c357c4e9951d2f2656ebec7aa0658786ca01b22be043379aa6dd1371d0535b77936f1577deb18d2c12c2dd1594260f6ee81d0af76ff7e682dd3647a665441d48b978678ede6dd061ef8fa48a78ea5689804e88a48ba2d4cf176881a36bc6c8e49565725a08547a110eba26e3a65735d28527e24673a20829e97abbeab1285b30b1a3a8f5082178d2286d7bfd42993620eb0e6d5165eab7f1dd43556610285c9cd3ca88ff81d5d9f40c7e23e6fca1e7b138fd5d9880315f15cfdf5a958b4586dec58c15191f4ab7156fafb9bdf9bb36461777d1e037faf0b83dccf832611c16af9f4998e3099bb49f794b81fdde1a93f1aaaee947df5ed33f08ab32a8ccec4cfef2d08720b3095732f848e8c50cc5e3d71f4263349038adc9b3be156d0bd035e59df0655451e6b8304df94024beaa4abae11b45b0a1b62c2f4342c5a27559e7f2a3593ce7e0fc7ed1033ba9f29e7961009c3beeb2cdf2946ef5a8d68c0a509a35b8e61204317d12a0063043cd9a3d69d74c011e611ae9d00a566ea41b37510c75cb11b52ef5f7966be2757e087af76500272ae660e89dcbcf212b213c3f336b414c74c627ed79e23b2708890f92f9cea45a3dd0dc9bf968bec534dedf78e28dc32a08b1282857ec1dd90566846ff551afd126e8b34190ee5d6ee644ac9de74cf3f92d4bd0b8ac6b39d4cefabeb3b1848e66002315f05d210447382576d191786653b7bfe7703b76463542417a4a6779bc7eb2ab8fe9946d959dc6e6d8cc562c294fcfd400f9a6d03d9533b72fde38958dcf6cd3e3699cf52e5ba4040ae66e697d16ceb5e0a1b6a4e8ca6150dd049258812cd82987afae21c8499fbc9e5b95a2d076d0ad517c31e3d096f3c00a86e922001d179f3f17603a00330ced1f845b7a6a63820c9423e2fddba209a6d4f5244cb4f856381b9b8f0f521d13d46bce28f0c912400dad132c8cc6487d1c63bc14aac515ec7e9aed9c5370018ecf2d462d62eba2262d3c140a68e225b287e3f919c0c6d0213c8ed5f104024805f120d874a606a36050c20a439b495f443ceac0356c4fbfa6ecff5c158df902b9dc857db120fed7175c6742eb849ebdab66a30afee2c13ef56cbf178a973d3e1dea4f6543ba3b78186c6404e5d61497f7c726a538898ca77cf6dc31438e69369342275f77d34b90e5b51ce5b21d01e07ab008642588a2683f347e41b58d271484cffcd5695b7a9dd28e296184c02fd0928a66769c47685dfc276a5aa029572138b0c49feb4fd0b88606a014e999e26097e0b181c9ec648795d90d01fdfca2dfc3ca5c6976eaf61cace2b1822b5754c3b4ca67e16d67c65d7f3e64f1dca06fa1297a4ba72da45612d1be55af56aec584c81727c5edaeffe422a2121bae606a6cc13543b651c5ce14e10958037ae1150cae778ceb53f137c2af62dc99484c215e6f24191c3d27c4399c15a4967e7e02ffbe24e1ffa47cdbc3317c088f67f808dc7619eea9bd7a763eba96bc4926dfc2cbee8881adf22478b8f15c3cb43594937004cbf553d04a4a91b26bafb015e38881cea71eec0a8d87292df6632b29bb747d8feaa35b2420520b9476841db06766cf7ba3fabd657af18c8e25a8e971cd177a682a146bed4f279b2066a1855ef68fbb01f65cb6b646020edb314b20ade1df7fa38291f62f33d032d965fdfb918813a52ec23094acbc3546eaed213c4f1b026b561544a24a440a82f02cdd8d137873fdcc8103b0307a5f928d827e0300a5713337ec00b47b9b3d1fddf44957bb1d8cfd104d2985591c385a8afc36cbcfc987f09c9f3fec453a2383a2a6825e01d2a04f5cf2fdeb2f988226b457695a0fd2a06976cbee0e0d0c9ad9530dfdd5978c36d0bbca23e7483f4b59c72e512bc1e0d06261964d6534bf9c4a7757cf73bf23bb64c3855039b529f7db54e1daebf4409b338a26fb0bd75d507d82ee27a0e3bd13034ce11f9dc8374475b5cf0438d0d14728556bdc42b171d43a6a621dcd82516bab40c18041fc150095c8d0349c47c3ca77efeb40033610c6af1778ab47369e94f72450ffb95e6d5bd817249311b0d07af7e4d8f6cdc6b4c885d1832c4197499e3c92eb7a5c5bedd9814c8aa2f6b32d541bdf0071797d17cc726877664d6d966125e9e19d6591f1d8b77ab34a75d217a8c9e0c4ac946c182addeb3a5ad48b91a0a959a00118f0b251107424129b988d1d8ba90d8c386e3cedd5766abcde97168d4c2fb9a3f29732d9624e9c4b14e44b7e52daf71137ec29b2299be916b9f1a3a87bbc5ec9ec3eb7e1673c8ccb890e789b87e29bb8e499630fc62cba3d8becf84594edb0cfee1e3d2c189b0f242757270b0d22a80583ff661b7408576fb07b145076281f7c2ff48c853505304e923378ac54c014863eef5c6e878660669fdc10d3b9b2f88eceeb953cc04982ecd3ad43e6a4ea8cb8c1b242c86b5f3b2fe3ccc3c1afefaf01214c657d366ed9e1a54fd226834c17d79790445e3b2153eda807d625d9350a3462d1c7bbd3aef9b1a21742953b14075023928e0edb42892e75bcd43280c04e290901dbcb160dc1cbd4917bd16f3b6ef7d21f231791410c385f8bdcc851368a04bdeac968017710436bca744a97f2be2f665104d298da2bd4362601b4a43bd9c0a4990887f56c7cddc19d21d681b20ed40bbd77b4d56538cebe81b3c9ba610957eb228c64dcb1ada97578dd584d063d177c8d4fa7ef114d05b1ff76a15d554d0b830da073ec5770adab25ea90da25c934486988bec4dcf369b1fb08354ebe9e5c47c332c093d813ba4800a41795b2d7a625a39238aa6bed03450e3b93d3fffb7f4f0511255d128691d88c484f2e3b5acc24dffe8e813071b94560073fe272a175f78733f1b671e2a2881252065fb5abc96cd289cf22d7f24f2b63ed6f3cf45e15616cceb4c48d52bdd73d4325febb6b7f9235daed94ec925a67fabad29918d87f3bf8c65c35d349b6d9e55581a40e07627af2de889f65bd16238e30a2dd5ecd7b010389eef8dce16ce88eebe96f5f8aded5445e9c705a82025a78eb50f1f5f29afc92effd4480549c58d9663f5164729cca4e6712979f2bbd1ed1b53beb0e2d511f85a9672091583fc5246341a857fff530d3b4f46299356970afaff788abc55f4e46145be974ac74c14e029f93e6b66a6b78d0ca45980804917ea08caaeebf69c073dc7ba17e06f02f14e9bafd7dcce01d267029fac2d5ad72c280af3b055738761366c86625d7367107b56642f14231ed8ef5c366f22b009782a06b6557c0ed711b583f3402f41e68d4d68c45abe5b2ef3e7a558de472fd00757f69ca3f7cac723b1e14ab26bb828231365c248ffea70d061cc782951e7ac5906636023c8bb534c0ffc06645da52684c3515529eb3d09b45ea8e4863ae5f6943e73c82e78daaae4f4910902d5b1794e77a478d5ccafb00db0b72dac300423bb8a479db09a10671e33cf9babf56032c00f6b9abd08f539c1db1077f0a914ba10157976ede0d52b6d412416afa340c47cd1bc0bac03342c5aed0b18406cc9e133c839b037172b18cdb5ab24369cb21185a6a75845369f56233697a34c30a6a009965bff6bb594d0a932c089258fcb59da27e303846d809c80e70f99df510ed7c1b7db8acd302b3dcfac0729c0b00fbc324f0634792e598f6a5bdfce76bf56f4d22c1999b36b9df06602cce8af95a73f5a2a4cb1fbf06545fa82003345e2ebf826e5899c459dc59e660ffff31b3ec592e1e06b46095949d0e9bf979fc569e7cdb36f227e5c020f3fc7a5d3173e8ba46ef9628efcbc19c0ab343b5eeaae5ee18163ca37a398b1aaa30e8840da1543b9ac1a27a3350a738a061a54badebd758941150f81427534516be76a8d8594e1e1d674701be15170236ae746e8164feed3c794249c15a5198af5a72e4c94747776d1a32228f0119e92ec1c0412cd052011c7d0d025130326c85ef4bca51f41297eb02736fef76452b584e5dbea63dffc4d63d7e6c516eee15144f542fe44f0d031942224d0e430984d2736dc7d4e805848c27dbe0c4d54b0ea665eaf85cc281df20e46bab6f8f68ea496ccd413f066d2f0e268a1b82595dad818cf5df62dfa55b7d73b6733c21d6cf5001aa8b6359b289bebb423d707322562c2c692ea21aff14b91e2936aff17254ff8dac6eeb2339258231320a1f4f5c856ae2fb4123d7954797bec5b97e3fd6616d2fec4c333aaa9aeb1f6dc51aa6fdff2d3908399699e4feaadd02357e13f7d6d5c81be2ed5ad48f5785c21358e887e7c683b4f7c34d545790e6ce13f6b52dc9d46e5be1bfdd6e95233e91711c03fcc51bde644ffb084ce1ff31832b993d0496155dad8c1ec92b76f19a387bc37efc5562ce8e313f0b53e93013e5b95b4518933cdd2b22dd7c243396786f09585f69ad0f3cdda8a507cbf788acc4838eb1a31025121aab0fb27213ad43569b89f796289fcc7e55dff022a389fb83e4b3da33c11bc68e6e12568710947f422952bd28592cb6eecdaadf4b6e7a703ea2c32831a363237499b75fd2266c3aa44c85ab8eb5653a52bc94048daec3754c74f3ef897f27c8ba44d8c4ef1b603d12b84dccfb71bcbb4e66b260cb4bb5b475be8c78c6453500e9f9b677ea8ac2acabea3861717f1354571653e81b8b02018c70975adb978e628bf309a71da5067e6a6226b1ccf49a0fb0e036643addc0b68600ff3b5ba194b91e4532439eefccb13370ae715cd91c6c4646989725ba46af700c8418e5eb970fea5e3e4c9fa3ac9ea0a48fd760c7c69e232a2f1bcf5ee325bfd96c09e03476fc4e4ab52e5941ebe51f3a116277ad707fe99a01f450d0a2580ebbef6a2c0675cf2ac5b55c5839d433399048052cc60a2dcf95887de95717fe07ebef7a7bff8e6d43ece32096b9eea12e74328ededcc8f0d03ad8d190b86b7b412ef8e740f6e62700f7fbdfb68f0fdece1720c3fc76376d040cb2fb41c2861024639aa0414db038d88f191f9746df4f10a6bd37a8900bb6e2005afb277e64a02ab261b12ac0f03796ae1a152a7a2b801dcbe91fb5377356c2d5ebc1b9938a7b4640c97dfb6d176c9901acdc032c7b49b7c3ea465360680f084401ae3dbd1ab9261e06fe9b7fb5386bb9a1f45ccea3eeab6ba352ae60d02b349b980df254fdb7adbae73e7595a037fd9e47910239b2d306b80ea46244d76f443f4d643379193349327f149fce11d0e7c4f24d1bff80ddb1e88a7643c1c59f214718c0897db2eaed1af89eb3b615357d87a85f1dfd14a7bf4a2ae01cceb20b0dedcb25a56b639cfc3e23dc0fbf50d551b1972c3ec88d2996a2fe12f9299e2453d8cf5c718e2db01dc138214ca82371edee7a2071b42a72509aa005a9c1cd9bd6b6f52d1069bc0185824a8c90782b68a03f1f1ded6f46395f5e92bc8ad6528cb743eaccbd2578713b93bfd993e9072d1b7048e7a274bc6b175af44607a43c6451fd40e4892cf2a5fe1e828e16b6a7ac5d5a8e2bfa6d11adaae4b7ba32dafdcf6b76d645acf65d4a40d34396ff69ede3c5d2fc9c63799d4001b28ebed52716e8784a6c6c92dc4be4a8250a136910750575db81af1f04dad74f980c9167c50e2cc01465649bb16390dcac9c6f3fd48cab250960556080c1ea883709abd3dfbbde995243c0749e54b8fb2cf4cf0caf2741c8527be86c6f9250d9e0bfa976819e3e4db4143fa3d8a8c75420c0b1c617fe3d81da30165f338d591fb34a575fd9391c5384cccf6cdbb2a86ea8249f44b6f6511e289758a2bd5740ec97c357e4dcf26063e6ab5f888bad9d5d12bda0809c50a62657da09575c30104bed6230db1a8ae35737c77be6d5541d465752e810933da1c50d0eb229c3f1fcd4890e6451731b4690d8ff6aa1457df20e2578881b81e262c104677249a0d066df78897f4d7cfc62ac9df68582581f78147c75f53b31fd94a0013523910b5ff9a0192ec23954d5f5900e00edc2685769cbf7cc953f0455f599f95a2b3d3c174b969305fdbe63d6ad9cc0e6b7550165c8a62c787e3c3c01d102d10995030dac2985e871630ed15e97a48c186ae1c4305b3b01f792a81dfcf27a7d5f053f5b79bb0fd9a7e22621622128e5ca6f49ec7d5c9aa01112658e1cb491b2efcf027791a564ee5de228480b7f014c7dff821844943018bdbd8eafa622ab9677e48a4fb097c35feeaaf3c9bcda2416c9ad9511d6a0aa4ecefbdc439427bc7e184eb4adfb74b71540520c9bd7ddf8a6f1e6ec7595e3e9743bd74f1d6737b07a21967f7401bbb1256ad3d832737cbae0cb49bc24886aed1570c3aa369ef6d6c52d2fad8850fee0b62ce5304751ed407a43f8df5200d40c8dc45723d581c1727e5d1a1dfc2ff4fc5c27fba4d8598edf594a15f75904445c3d46e1a5c608f6c8e3d88460aa474335ffc077a6229af23fa89498805030c1655d72399555eb3cfe79c81ad8a6e9abef89c8021f12c71080ef3145c9ea1ac68a616134048776a37816cb7a3622657ab0bc75cacf201eb79d75bfa47818bdb8bbc684feb14da5f3c487a9a72278a56f522653ae9f4d72df4b4729d50301533ba563831213f19c91d1fca8765fd4c93d4c028dfd88f6a869167cd522d3bfcee43036e0b7bacd64980f6f7eae1b46dc06ca310625dbeeb8f91bd86045a255c24d87faa228958d83bafd08044b58f65edd707b1205f384916a15a26378cb8a6d61957295054f76dde733d43f8e89eb03a923db9b0fd31ea612150a38ad3210508dd5d43e5ac37953f3417a9178c056e43f20ce8cb60da7dd1609833c743d0022353c169d5799337d458bfdb099a28ecd632d12fa32b970901f6af2f524ad306c5f2dd23e06b5e61dafdecf1948cf5d3550fc020edb75f5d8d4e0b42280d301773f7ce2bafe5791bc85995ff4b178f2e1c07ca3a52b7de328d5606fb037b95b46a946d3ab4d5e1cd46d9fb6208fbcbf73700bcf169726e413e3e758a8b98e84b2d009415727676b11d291e1203beef299e26da0443f0c53ac2f309dc5c760e60ee27bc3f2469d16e5beec203468fe41d55403b94051065f0aeb3e5bcab3d73a3312e5305ac52f5af214eb3ba7aa35a218be7c51b5121f5c0d8b1579dff7d19f1b44cd0c4c0d3df5f5980182190a1575c9857fd220b058246f28bfbddffd7677548e5e8ece6ecb9f92c154706a343162fa77a17e6be989b8268604c2524746a4f7c34e77356e2b21f5e44b3ad26ac0348b0b4d72a55ae187b441dd767e46d0668b9744b29a3f79fbfa23b83dc7be16004e1397253bd9cc9c4c0354a7c6f857b21167d9f3eca9aaac09881eb06fb70fdb9a5184fc3999ed120772299749adb404f320893190eb82d9ac21a6348498058cc446793c8aca193713949fca44039e2b23c2e89b9280aa5ed5675e19e836556804d5675f85f7ace0c73ded57d0aff6168a4c456fe4e603f32702163ec256d963a6ed1907bf92376a634d10c1905115ae06c54c3a67df86cfb92756e4f4b4f87280a1b1551ebd145268725417baf7543baf9d879f5ea4c18b4ca56bf02a2da3986337d3101c8e2a1b125724c97ec7393e6bb79e813e548e2f46f3dba903a3633daa642b141414d9c300044c3198a82caa3060497424d14ce124411d3b7ebd1499fa8d2ca10276f3b9cf24ca4381cc8074d209d2a70a10c709f3b6f5c4b89e908305d5869ebc3a3d95000e1b4108dd5b4aa14bad6fdc5e5a13711f42edc3d01e0476bea2ca0c723667c272d5552e87af183913d5c4d9c49a9e3f304b9bcf506cfee9f6b1add73128b1f6bc15a392dd8a625aa7e562fbd3155aad0a76c709378d12e210e28ea3ec7b20532aea2cd81b8ca0082916c41a94299b0f3243ad99741ecbac8201bd009b89700e9f51f617ef97e446d16e178034dc6340ef39a26372d87c393c7ea8a4f3bbb92fcc7473b7f3b90392c014d74cd2f707da7e4a452ec8014166ef1aaef84be1685b63d3ccb84e8f98f75d9023c226757cefb8630eb70ab54ee42237e9918e8d93559eb7bbce1cd0737910bce9ebdadb4e9da944ec4e27480a16417710c906e154eff3e32dec279cd34440fb0a9eec7921f0b45b713edc85583e3cc72244a691a382f6d4e4b057d632d212e02afe647e7548d30833b5880a50b53c2b6ca244655f31666a9beb6476327e39ecb3c2b78d723dcfb8ce21fe3d209c7da45f294fbf73c913e14142466cecf36384452b1a08b3b7bcc2a04abcca714690367b8bfd23c8912dbc531464686707f8965f723be61cd57555d4ee388a9d0fb2768673aa1111b6dec5681d3e3caded087e90f4ddb25c053d1b6ac097ce9b34ba674dfd7f9306bfb61c4bc7d9cfa0ea4f7fbba3d9ca9c3fc980d3b96a956cb95611201b85bb6b3b0f778f5f7754d431e23bdf89f25da5262b99533d2e2abcb462f81f2d08ea84e462db51f1f6d6d4492d0da1b0416dac9e40af354bb886741bf4f589882d70d87d041a12a08aa125f3a384600218b0a31b3b07dd3e5f614649b72e174fe48d8660fa75a33226360710aa1f5e9c4713e19b20c1da4fdf6a70f5bc9c3979625d9967e06914bbfa09596b57aa8c6faf8b0608467f4abf20f26c5f1385bdc38c88a491722f52786ecc2336636731b81d95457c99a2d69879f60873b2b70ef191cb7eb06e542fdb429d3dc31951facea95512347ef2356c8ac76ed6b43562b01b6a1e84992988240bbc5916abaf8d00c8913dfdba8df396e5e9e64a300e5e9fe0db4d6a8ab10fe98fb6ad7ba926d7a91dd22347cd55c01e338418ee8bbbcaba5b5b22362247712b54860d0a0b7dcf3a5949c6fd961393a39b9bd6b9123dd2a95e06493f2c39ab3167517e457541abc6e7476e17d3025082eb41ae973a5387ed592c5455684975631bd31ab7017dac78411bb17c3d02efa4b62cccf424e7815baea32a63d688e2a5d9493be6b77d9ac9da8d7c35fe4fe0ccb66478a6df46f5877a5d5ae38e6f55f6648e5ed2226e07eaf47820c67f9ada8b661fed515736d95cfec926cbc3dd79c1462861393d652b0a88346ee88bf5d6b134465837ab083201626b5592946bd1d7ddde6efea4383407ff28361cf736d3d13ca19a4b67385128d7d3676d9642bcc820ce1d13353b33c50e2880f1f311ae5bfb2e5f92fa1ae81cb223fae994b742dc66942673bc1267c0349a456918ac3c5a7efa1b4a18b51a7ce4e200c2dde20845943ecdb9a7a3dc2aae1a82a28b1e552d6a3359cb9088ae5a51037bca67eca190d128b88ef37eefc34d18bb4ba8ed296b9d03f9daf93a30a2d123c38c953537a3fe44dbdb4044cc48c316824cf9f75c77d436b4d8aa2fe20995e4dad84c4971b841363a1ef41d43e4421fbf02c3080ed9eee3eb6c6865e911cbbc63c4804380c742ef77016d0d8446c0c6694f3f8a50deae62e33df93d784380fdc0ff2a0ec224dec0f1b0f8859c78abee29144920a0827c9dc994111b583312e5b137353306bae4ccd44e6801c5d4f0a148d596bbc5eae3fbc48445df604c1c8d8b5f6103f51ca6340de35745355780854dfc03717e465ef6a36ce1a518249a36d94cf4d46e7b677fe9eba5bdc065c4a33236e6e18edac638b80c12f528c5a5fbab8945dc8884ca182f1eab200b645d7d29d825210a8f9bbfce8005d647a82e9f9f3b9433605c0b109eff625187dd56f111a6cf5c343cbda8925652ba0460ec20be0b93f2b2ee69e83686ed6553d25285c6108ca9e00c1a2bca37b68ce6be2e7a786a5549e3beb71bc6df92da03d53cf1e573dca5ff6eb2ecced883453966577d837a2c7ab80949279a1130451d8b4f0738e1995cb40b4558ac2cacc8486bd3bd1a1bb7523673b01a1332cf7e7289ad8dc42e0f5539ed9c1fb60eaaa6ee8312aede50c1ecf0ba39f4f7ba0d94f6af17d69332931bc037beab7b8f914b020818c0286d429b917c0ab46d2f43cd8bf6b46a24b7bb267d49c7437897bc43976df75dd59968e487f0416b9b3f973cead740e2d39f122a0b3824a2c84d76a3a25df29a8b892d541f779dc104fd8a62d954d5c35e61a47fbca8fc5a7ea9cfe3d494d80530a474fa175d22c9d02c997d48aa9647c9a16a0c1b9de60d8b920511424eb039a706b429c686181aab72e03962353e189fb00cfc8e0944b7d344d07025a54ed2d7229bac449606fe1136534a4a5adf64866759228da62279209eb0c000d0c7ac94a3f24d5156525a9577cd18fcf8e23f3a77bda1e9d728b65b33d5df57b8fd98bd76898453d8f9644b2b39cd9bc1162e7c119e7518380c52c336cd2906e37867f6b49f3ca0937cb78ed6caafca387de91f883605252585ac5fe6ce0a50797231fb39454fca3571217c2d6777f40910668b72789b1099fc404b5c91f20bd99a9e6554e1e8dcad5382ce058ae417651e9f816a846353baa9d6b82abe99cb9502f3513eaf7d1b8a29906425bf011c0b621090fb9bd142a00da012793e020ce9d62e90a524b21d2410c3b15a00116fbae4fac322e665504b71e48dbc02eaec6680d88c5a59fdff229bed6f2d0facf08bfa4c98c784a750f0c0dde23bfc0c16346eedc70f9fd44069fb7b9b2e676abf1fdd0c76631b8df0801c976f710301ed1e81ebc162269a4f14279aeaae67caa43c4a3aa85be572cec3e24e9892a7d671ad6b6df1408d546a354fc7a718962e7d5ba3e2fddb2e9b40582b5f827e1a4fbdbab5be18ecb6981b5671b179d830d1d989375872f740c2be7bee644d33439f21a32679a72c293220a807a27db3e80db9f1108bf14504ff15fe8dcb30533dc38591f087f21a149c91ea65607945694fc64da4c85eac6c45492d2bae096ca99f5e5a34430973b16d2f5d2479427f70087670f9bd53ec30e71a0fa0dfba72d3ed29fa0d95e5c2acc1ad6d1010b38b7788e3ae43f6dd5ab1c881660959fd3697e2b20edd289fd6f46308778c84d98bf9a8a75bc04ac295c2b05113ce302c306baeb2ff8b98882add9b7f24e0440579ea446c2e64e6650f2a0aac25ea281781d38a7d6e0c30fba83a1a3b3784caef989fb3dfc2a0c978c608cb3523bdf231cba78029a91357b3f105478b060c5296a768064946e0d3120c90346eb42c75c752566375f96d400de8c8bcc58d67adb5d3ef3916a173ab0db8e7897b8e4423bb9a5388619d9d5b7fcda4d4505acdf0e54679352643683f621c14ff66d31899ccdf9fb95f93d3bcd19c86d12a48d9dca32ce258c705723252b7eea065dc00e5de31f64140f1b4ec746841f15937cbb1f3224f358971abc25430360f8cb63aa3beafbcb32f201f022536a35849589d7393728274ff9cdc10d04330ce943abc886409de9a32e1996c2ec6da160bc81cb46c7cdaf6c85229f87f728307e6d7990d3d96b84c29a031c6dd9e1fb8ae5d4dc23a3eaff938727a0fe35adfe6dbe9ca254ddf6a4e3da11c750c20532ae4b5c4e428c3d9c3b4a5f02668d8c0782397d8e330bdab28d1c9de5b07b23da1108dc6cb25f83366c877ba7a6a5d0f99925dbfe01fcd0d743d18a459b34da88398e700ae2929fee44a91508d8713386f63b7ca60ccbcf916257adb3a72d2514db44ab7edfe2694918aaa035d83ae4a2c9f8822aa09f2e28d5b9cd19fbb0f72ce14cbc64213e155e10c56194207b2ca1a5f5a67fefe7fe15fc1038b6358d42beb2b1bde2abfd98be3107c4b7c55a0049ea0db833b9c9bbd3da6f8867f954e60d6688562689644551857c7b0cbf12df96cc70e1a348d835433e3c77747cdbd3eda33b77fc4b60f038655caa1dd2cb1c81fc6169b17cc8b06edc0f5da402996d9c101d3acb70b7491beffdd8d7fa51e37bb9218605e2633f55c3709e1e4c6d6fc0fffe9e91cfaf0c7df191f1f3e0ca6c89e0bebd8ba79f131e9a5299c907dd4068dc6241361764c7d111b6c31756eb2cdecf598f9e8225c9de9c6a063dedef6c446b74bc56d53129ba52d77fdd693d571df79bf94a8515379515b6960005c692fcf8fc7ff5a64a71d5fc72a35d146a0a68e33f0b3b3c6e2387254b024baf3cd3ccd76802713cf04a9ededd9e06f267ab561f12da0b65ca062485217fcb8db6b0699eced88aa226c40e3ea30f41b4f3905f951c5f38d1c32981aa0ee2f45d31615010d806e91af8f9e7d9cb96954dd73f21bfa5d7fe84e0b738eedde351b26ab92bac17a8a54d6e5f42738e1c0648d68bcd3d0ef350cf02fef865587f46d6ba7e17619400811d37d135f0adf1b97c21be55726edf8a13434b8d1a5013d05c3d182b84a358ad4d77ba0509f94143079360c2ad72024eda55f207d749a51ffa4ffce70cfffacbee67b4ce4bb12d9097bcf089ed890d2ace05c5a07586f4b458207f5f138beca3bc0b0b45ed0fa13f5ce194b25a5e8fbb9ebbc7cb047c27324409274766e1edba5eae4416bb9c5adc033bbab6bc95e3d65c929bc3e9db04a848531b0d813d4752d97ffd3cebe77172a93fa9acd238128cfb70bfa761ed7221ede15c2aa233f89c35726dc0440902789794f7b3f391d534295b4492cb09e4510751e0f664b9f4eb3314b12f772b5f0a03d2d4f5eb0748caba93c1efff7f177b78be5d51cd604ca8d8e1980b5e2abeed67dfc1237f5e5616b88be9b8b6990accf864d2852ed4f81dab9433cc0507bfbb7c73ea7401e079913e7d95a561e0a5b352103ec0b90cee0483ddb79d2a2bc7eb774a7d0af537ca019045cc0cd6da58d8c74f757537599ed63614ae7b638632c443120be1825d5b10dea0af9e9553e2a6425169d7276a29319ed2d53ad1932663572c218a24c90286840ff511d05aba4e4086678800e9b94d0223ec39329e25291b24229f463547231db0ca9cb7bcea1a9d66ec28dbb038e9e79e8cf3041344f39b9641cf97fd1b45cb996e218b8ec7fd6016fd376b8a6a933e7e22ce60d5bbe6c412e5ff34e4d942caadcaf5f7955e57e91a7c7afaaf4621bed89ace748eda4dbaacbb6f1030924b95753d37c904d4e42649a6bfd0c6c4d62fbb2a84040e857087aa740f077a650b3379d13a4eac1fd1cd9894b1c946b13c4a64446a57166a61810ffe14b0f466bfa423812faf2c2c40063bc524d657b02e4c2b0df434827bd9814f19d04f64a2ab6d6979ee41fc5305e6f17494ba6c7b34ea579a2f01014933d4b6dc3a80826b7f6464e997c681224cd4e7dd266f1964e62a57e4d0b1feaf1c9b3b34669e1830d46fcaf79c236f90f52d24f22137147a535663b139380402326eed8d48fc559523a26335d11eb49dcccc290e4ebe450d30c2277bdef4a7f0f6d2edf760ea1cf5a64208fbf24cecf01781215c2b1a9802750b75aeab61bf7acac217957d35da18caa64e1f4300098f0908b3ccc8e450a1b7a5600797d21b5251ec62babc56c32ba29d99cab876eaa20ba296593ab21ef1e9293a5462b478faeefbe10c46adbd49bfb25f733a9ac3305e486bf90a536c359b8612c39c91d357ff940ea09a80e678ed8b9b16a4ae83dceb587ce79fdf9bf9dcdc1b777bf000d8ed7687525e6fc3e299acd7df6d52f05992ce8dc3ed036c589d19681e3312a5dcdc25f6398cb5eb852aac0e1563c783b7254e52f3889f85de69785766731f48bd8440f38010fa9968a1700645da6411a1f13d91ebc6c787ed8285811d7a5d74e4bc174ed79eae12d1fab680a57050e84c15955a140592cf435aff99a262637def8ecd8b0ae9937f955a7ae26b301e26095d27481ad9674317b2181d45c80022f71e9f13718f01e858615b3ceb99c21b40cecd98ee1dbeb4c401cc844aa4186de289a1f78078b55766aeb29f01b57d6a10219df0678fdb235cd10919b8536e792e9f718ca6318e499f3da9ac67d72f743c6c4686b586e399b1dd55643cc34a3133ea30c9bfa58a81f172df37588bb8967bc24cc920d55e61a39025556b73e7441764489e13324033ef260858842bc875982046cba1f4b1d5f27a4d8c311ba4842f08a628e2cd5856496cc2507d2297153037c4758adcefb3280eab5b3d46e4b754266c8e7bcaac6d5f31d3c6f7b6bab04cde37f41719b8050378bb215a8922d5986c1d6775c08340f47bd52671142baa51cd4b2a75661add42a2161453c84a9f6f456f44315463c515c7d0eea73e86da1b5a3aa01ab8fe89db8ec546866eaa7fa07bbf3b377cb73fc86175df4171c931443f05b997ff8e3596672f8dd75959aa07786953be4133627c51317bc9c4ab49f48e7bc473e3cce4aa08dde287161914c008a07b1e6414537782cf9c50680f6b58364d504631bc9fbdc7ee6b480c9c5e2bae326f3ddbe003a7fc0d86656aa872ca51514f7b0a50153ffc3c2a456aafa6696c0e49795dea3ba4fd5209db652aa70476304e95051308646f8288ff58aedbe7f61498b931901389235058a2f24e67c47bab50506fe1ebea9492e9ec21e057a928e5ab836c1be60822237427a12f1d7bd4427ebc0f8356d21bf663d2e489f62552e0ed84f82208378b77933bac7172c813b67e5a6d1e67286591eea11b038d1292f6aa0039c1c9b13877fee6033262a09ef09138416f49df7100f3d89edc06d0d9d83492d6d780520bc3a0815d58e27fbb49b5123d7a7fe24e49a6b63696da14041b8187a409d1fe9fcb75b4d0844edbb50d48b5cf96f46661ba362c45dfc2cf4a9b046349084beb1533e61bd06ddc4dd9833d95772624a2b8a8ddde035ed58d7a13384e3e3f5716050143aa24f76e5da20c64614d956de5718066fb337a271b9611bc09da92f64e22f9829c12b23bb07c48f785c89ab9af65752d8a0e80333bb0ec91ce261fc177306596e0d97a8c9847304c10bce35f0023f6edc6e90c6bbd49de993bc55610f8ee294c7cb3a1fa0d983936837c2ccc927a239b391b3fe07c2b6e5bbb666773683b9b8c71c388db2434273d1ee50be1fa4fe90fbb29270d380cf347908769e038327da1ade044ab221d0619e32dcb9643a7d415e311e2f8736b194bce700e2097d4d8515a72c5dcf12c94a8635fe0909a548613053ad4b8cf251380e87579219b7f6804f09b94c385b45b86855cb5a4c606e55b673c4977aa1e8d466fb49a293aa4b4f8945abf5dd30eb7762a2361e0dabd4fff8081fee96334ba484777ea8f6aef8e720471b98f798597b39fe3aa9e3639c82649c792ffeda480b5ce24bd632943f1a7b1df344f0b0133122bdda9eaf386c9be93465bb656dc98cd10da45b3879f5390961d1eee502388998a65d14b9e437a82e67e89e091b880849ebd298939afe2f5db55c79d2f0f42ecefba467435ed0c50b463a842e124c83b86c3c6d7cb4681f57d7d6fc03400f00f44be214f8c558bef84c0cdb6f9b2229e0991627c281d4f66c4610bba2bf53003f1bcd3d55940d7669d1a816dee54f9a488f1c019831ec463725726ca64861d1dec7a616fb6f047dbe5da6c888a44634b2b089dee2330b5dd833eb774ab3c241ce38cf9d18e269da285c5c81e1442cb426402c29f5dda20847c62228f19c31ab2680e0ab6737d06613f084378df8d98a52eed3ed0874c8308bb62638d58a7a12d59bafe6417b23623a6eb3cf3cf8b11099c53d6d3fe49b873433874043eb11ccf3b92fd67046cd6712987ccd07463e6cba765273021b747a9f6014111b82339945bd9e11858a0b26f3df200738a7cb70f8d2cbf04736d43ad69cdf7402bf77a56da416838cee01273a0796b1eecf20efb0ae33cd4e5796f85420a97eb54248c09c722a31d58996f0d70bb17606fc3efa2212df901d6b07e629cade63c29f45860ee868cd93be810e0e55fa6c520e2345c9399f56e801e6c9c894160ac67c57387343659feaf444c1910bc4fe203060030546ece20d84497e91d01b015fd8acd8580fed679bf244c73aa0663ece05d556b7558b3af39f04e27d7dfa945873764a73b5f2218f309078021b698e1706c9b149ba40e8b6d62557f4ab1647d2c741fa2799d1bf3cb0d38f85b2ac0ef4c557dead9786c293938c00ccf624107cc0899e497482e5662dd4047d0eae843834640837c572a7ced27bb51aabc126a67c2c68dccabca07c5688d2ccb376cda4a8e1a14a35da74894f5073c12cffa2185b2104c6d695b3290c1e625f4f4df5550068ed3d207ab3881beddafe1a98af04d0d321d8b46a6a1ea524dd74d6f54f6e47d908c3a9129af755fec25587f81feaa1afccc9a4cfa115370405af226498bd913177fc38c9082d8c26fe1bde702e753c665a127a5e027e650560dd0282571faa8f218a33da8193dc44cff6f4763bd080a36420ee9666de31035470494e763c48d49cb0b03bfcc4205242891df5ac155736fc88060bc7e759db05ecc2adcefda8a061ced477fa86e3f37e4e66f80af614eeeb7c7e95ef83ada3f1005f9c33862f19d174ca32af7515dc490ec6c1e62f47fe5f29b3ae5c7ef41fc911972ef9c68ae61acbe43606656e8855d7c397404c38d7f5813610d4c079fbf68c12729af78d755b413edff765e94d5cab8327cd3a926e8c13e0522201f57d90c5e1e75b4c216122ec691898a7c8d4bc248ac84fc85f28b766b5634ce69e1f83b82749aa4b4f22b93a1453136d3ac4811145c87111f8b7575565fce72a47b47f3a1c9e330d58f0b820b216bea0e4e26ac55eacb6ffa517d656da268401c0c9fdc9f0b2df95f7012f52f8a144d321ea9dd105681cc85cbc4c211b8cdeb8c8b506c1580532c3764720ee92c3880ec3f442c4130cc13e05c0323b8562828e2c2ab6995aa5c8e5d7a17e3ce9bf3065796e2d1e96ea4888c6224da924ad69b8834e33160cb12f14bd6a33514760c913d96e5687fcdc89378e29285398f7e297017c37483386f9c6dacbb8429e0e7e666e5a4918f8033a07128b526652426cdcc6276fab238d3fc4aee9d15007c748de871b4a5ba448539e7c3a1d4ebc89cc46d87791b2fa7ca6054c6a08b4a73df79ffdae577599d700723abf9e22620fd64161b3eb2bdb6350ff362e226bb4faaf47fbba71951b6e2ed315afe6d5977ed2bce26f3ae509132c4b25165ed0fc1771296e6686d8b10c4ade9baef966175281d18bbd18231ec26c7e56a76f2e09ad6baf8eb38e2ef62ff872b79d269e9c1095d3a45046f9e68b3695806012cd0037fd2f678db6dde17c01523050ac7fa591862f8cb17ea098fee48e2d967ebed917802851438457c7540c0ab0edf053154ac44005450bdf9f17ab991f5860cd19c4c1fcbdd991ac25a415e15dc6fba5db87a958ded55f59bb3eda0c475b808638223849648827bd8b9eb4b49428c89e12374c5d2874667fad793e0ea9760ae41a3ae3bb56447ca5e6d23e860caa18b70d8076f1f6af6ab4af4407b94ac96d15b0d3ea168b6e4409769680c277f12d18f6f57b7886bea6d53a61c69fd62c8d6b468c30f50378a4c9278fa6ba0f6bb00935c0a66c919aa6222d635b6635c0aba9987c41b9df621940057f979e02ec99acfc0997aca372027046f6349806a1db3321fa641b7a3610b28a828b00381243f80eea448e1b2252dd9ff158ff6cf39c7c29075ffd0e3565b5e8199cac4f7076129eab59821ceab9d3d983fb82317decab9aaa07d7c3c82abc0d0fbc8a53846272ff9f94a24675fb5f53bb9fdb4b88950e366d38a80778957c7974f945606500f04511308fe08090368b30e7b7b2fa987df6e420a50b1202d69d3f8526b659a3d3ba34dafebc1d56228537ecdafb9f7bdca1e0cbc500caacba4c6846600c1b5a0273c3e3952b8ac88eb16a5c1d01b4fbc866e4b2212352946c13e44429e79b12157a2491370b9f7a6bccb6a27c1641acfb34dde314237402eeeeb2be9c45fb4fab388dacbc9ee780998041eb477c9400744eb3a2a54c0864dfd5c51e98b67f07cabe223e5bf93d9cd5232c6647c2e437cbf3b9f8d8db0a35971ad9610267abacf80ab57f6398cd39d5f68177e8dabbf9b4beed3bddec175cb74f89a0ca5ac7b637ed3a95fbf4fac656c3a7f79b8dcd7975de94a12b8799347474a6809f28ffd494a76c00119b37d081bad500906d4f213f3b2dca343166ff9b9e0e5327b8811d152e6c293096e25892ba4c48511e278eeb43114deb2a5a55e4b09983f08c06e1ff5e015bf7f2495a34834cdae00d615c191cec2076e293fd098cf5c9019038eff5597d2a651a24c90afead92169595ae3872c17879b7671a934b71a0310581c43faa8472f5dc589277b428a33ac014946d8030607c13b524ddf9b970bac764cfe53892655f25652e0162561d4cba5c2bf922c2868cbafd43ceda1948d12d5b047057bfcc088b7922ac5b9d632e7dee264fc38cd1a87651b7cc03bcae981c00e38a7ebb66941fe7da62835e2b2126a772121a8e8df71b2f434c3b65af84fd156f10c07aaf3cb66e1c595abf3f55f91049748e30bac1611bd83479bc97c98ce8c83fa8cac7fd3c607233e9a0d4e57519b34b91b9ac216c57a72a88d116178ea5939f8632e17bdd6982ced3499b20c00ef387c0c89993f81849c35b82d806cf25836a3eb967acb4a3c4a1318f273b4a3b882c634a6da0adc08dadd844571ad1cea7424cdd8a95195d49adc2ba0a679465bfe6ec5af711d6aee761b4ec67ec80526a34d4af03beb94f3a121238e941a3ff9b16bb79b151e5b890810ebdd9e7fd44effeaff27c90370484a19badfc1d0d0f4d9866a2eea8d209b286453ff5b8ffc02f5901bf71a414b65c34c02d1906aec3de0be49e579c562f092a90d045b6b4916837a20ddbb262d0e93a7ad5473a34855e5aa6f050be44684993616853fd2192e12dc4e1a01d4f172c50840364f0a6d074c1569099a5c6704eb8c73d218da19b5303f4f0e2cf13e96c2b763b4f17ecd6ca90a76ac53810058fc29a5b92583f80ed12c76c990cb94c4dc884d4c766af52bad11a2300441f7ab70fc4781c90e54f8948068e3af0817b9ccc60a9d302e89759e816e3a331071e34d5ea47b28a1e8f595d297c4e56b3a439ce11af6d6760535a624d40e96e0f99429ccb38dd79a8fbcdcaa58eac1f3f1de00fca434bd7c737bf83754dc6b16a77c92d4520dc886d021525ece44ca7981f20606cef701d93e2d9b4093c0860d06246aac5ff459e8343a55ed661b538fc2dfb63616199ee571cc033e59f758e35b9cac0f347e9b56395ce220cebef881fd74e3df1d32ae3bfc61d28e1919f3e6d18574614953298ddea784998c2fc36029c53e505ee19c5ed9757b1a6ade643e63ed1829e150cc9321002b64f9eb62c11351fc053df673f9185616c70f6409536ca433e46123ae25173e80afdfd0762d319a199d1efb571c80f6e282d2c9dea9e10c022a9d83319016303300c98925f9e3ec262be0c5d2560db6ad4d8ce4caaca16d1ecea32c43527508a407ca1a4589215447beee2230a79043476a620ec85cf29100b55cc27f175e99dd4e38e65132695c1cb0db09333c31ceee62ee3babf112a8c87fad2f3dbecfe22bf96ce45597288cb29ff4cb607344089ecefc1fabb180973528e2bf635b87e9d42d94e90b763df38e548f577386f642df160c3c0e77ce77730b6b5f55c5e50cd1bb78f644f6f2b01bbc121cd16be1c8ff80e0f4727e35416267d81ae98c932304f5a7f339493a2211f69fc2193db65124215e346ef504146d1404159abc2493513688bff7da8163bc97c5e6cd25ea5c5e0394566b49b080c08567b1eec8ef8b7294b01a70d164c5ec9f597e0f1a1b54bd4093f72b7786566cd4b59f9c4a46f7af44882baf259dc163ecd4dd9c1b4ba047d1d329da3b84559ee0dd952e7b628648cfd4e8d5cdec8869de634f3fd85f16895afc30be4bcd75000cd0aac413dd8207aefe187b0fc29f5eb5e74cc3a23c454bbe80eb05b0d4a86adac7e90b09bd01822b3980dc38beda2c2e280c88ac288ea1bf480d1c092812dc648158c40dd92c36b759465675f9a4e1297415d7091f8dbd8a780f7b1bc3b9a082fcfe506c6740c96105061bd3fe657a6b31d6cbfe71d19a933310e2be46ec83ddd946113997804ebc40ff75f8b8563ad3afa8b7de3376b15187025af6e53543526ec438fd7af286ddcd60922aa3bfccfd176a32060f087bc2184be43160609dd5a162286f0759b6b7ef8b94a7bebb0afe6ad3642a5d04725b12714c56f90b62794eb25d1fa5f63823cecc8a0c1d028da3f13d71a3f8a89606819f124dd759d922da4cb1c16fe43f1719d728765cf651cf4918ffddaf97986d9282ae729ba0956fed2b7ae3b253ce15f40dfabde82d5369a723d10440388f314f12e8d3d20a775625af771dcbf8ec0e96eb22b34f3eb288f4c4725577e72e08eed5446d6e4a59e5937427e1e59cfd4ba470ba743330a9ec7386a5111fd0e1aadb586ab325b92da3ba4aa1104c6ec4a8f0dda7b5203831778f357a2ad6f23407150575420fbc412d1f1769458d9c2338881ab04ca09a95e4228a7abc5e42204bf7fe25320e04fb99b5d0632c7d70530f7ff62ebbfcf192c8651714860fc15f88f3f2d7f88c1562dcf6c961db470ca9b7f540e97b242fca00caaa3ff3fc7f1da7649a4e07175d89d048d948070694351818c5abfe992c78565ae4192b750552ada5161e2b268fff74a140639912302878b9b05fe385bf74d2e23a7f2ff763406e5c215430afe6ca4b4fda7ce7d231478f1ca6bcbcf2cd5926ac78dc13bbf9f80727a039ed039d4b39c82685490bc21cf8f7b4a5e49d52b13b255113935cdfce182cf3186464c5744c8caba305a95c1270b14b96e2a3b1205be24a74b2a829ad02cd1d04b7841e16cb7133373ad2b752185efd6ebd17f1fa486a6c47862cc5439df7eed9fed26f76f8405af5ac5324e08e181e8fd0aaa76489365ac10f43a16e8b043f7a9f15285c14204a37d26ca9dcbd65c0e61614fd996438ac72111d5b3c8c598276fabd0b4a58d3c7e694cece231553fadec05a709dd41bfae5a6ccd025bf23f4dd4136bbcc879719d18a5198a6b0a13c3bbc13513da02b6df228b17dc9d3df089e1f12d503172903bb9a72ad7f2baef224a01bdcaa29b6b227942bbdb22021bf6b3a8e16203a074131510823a045285b412251c4ba87636fd1887d4a0dbb7d0bc3db6c9b7e80101c2ab4d0bf3e884fe21e08406446e8840a31c6b8fa8a3fe3dcf5811a4e0151331a71cc4a121ed1f470a6524f0eb5d9a3651fe2f8af71460337609efcf452f5b4e7b83b7cabc0a0d8f9c5120ac89d7bc52f2522b399053b1f2fadecefad696d85786df58b4ca77874929b978ad323b6bdb13553dc229c0024541bf25f14c805b4025fd3efcb13f8fefa9abdc83cc72cfd5d263cb93daf08c3528bfd66223125573bb05fe32163cfc6a01a7974dddf859712be4a062a882e9c43978a0116184e097226b55e39e1d37f947d949ab2557679b9ada0ffdf827fff7c37fe0c3fcb895e29c20aee3522c366771067424a05b1a52e6c88aa8ecbc001727c0fc2dde46334d5e69ec633fad69f643f879aadcae503e97076dd3e0c424c1e90996a945dc78e914fc29c068a59b58f0c3ab9ac60a4d79e5417ddaedbd89a34731d11dc7ad4c10bf79c9931dead7db90f35c748a32852ba6dc28524860f27faea6a53daf81431d859530593c97e51c928284957ae02ac07b811e5cfd1485b61438dd321284a65e620ff4c669b1ca9b6019b7663630d206f16a56efeb5276f5e688876cb0a82ec10cbc5f24c09fbd13f71f9fbf28233997e51a64551bc0b48e82b2e1e6fd4efb9f6bc0cd3cc2f47e518c25597d3eb62c4dca2d2d84217c60f78157fafcf4d832a9306ec0cdcc5ee867d3b6f2d322cf3ebc4912578737f6e6858338d9c8f2700aa969c746ab3f901c4182f6e0500e1adc4773f76c0fed478cf65c8909e7a6bd84d42c9a2134443094494d8cc9612338c52ed31d643b2bf2a495b0acf310bd2d5541cd6b1a6c0a6d4cfe1d7f9f709d6af7cbaffcbebea034a6a0d09053782d20f28c03f4d915b302676d547375432daf9d56d31d4e1b9ea022b7dffc6c4d4f397dc5a2705cbb47f9a1464d9fe003363ba01b0fc86d4d09485ab847430ace01b7c322da48fadfe2a3cdd294037ce1dde2e95ccaeb93c1f0bf5fb608dd9ddd9b75f46922be73cc4f5639eccefa4a415be45dacc2864ff250bdfb685075e2f22bed4cbd6e7b317f925bd50227ffc22e97d4d9f96f464abfc716afe10a4c8328b58fa7d8cf664fec2fd786f28ee7c2070487d8ee464482abfa2f7270294a24501465ad1ffca1933471183d526e17aec6540e882f3af7b71da953972aa0995360326e4503b8ce31810883a6596a02ccc330e4ec18a9af6fcc8fd31a0c064cdc2889f0234baa02ef2f925db1ad7053a7c444edbeb5d883bc558796f53b54fec39eed5f17a69395a9b18dc174f94a34d8f3cd31d6ce117d63c2f22e53a1521359adf8730dabfc107e349a86ea71cb1bdd81984bd3398c803f7db5f62d2d4a336bee5617fc2167f686cdb432dea90524968230bb8bcf7fec14dfc89566ec02ff9c9fe79475ae8fa1e1a6c504f5574d4a90a0174c286ac741bee633057efeba941836024d60295930bd04dfcc799cbec71f2f2ce1c399649a2b5fa5e796c962f134c93a23b59fc97e53547d3525a73e2c36db4f1a7c7a1622f23a59cf1c99e12e0f8ea46fb79422fcee602591974ffc843e7dadf2a9c77a978060593bf922908799078e45afd35e9d0fd199637d234d6ae82ae42deadd237abc2502c11e62fdf9edfb6e4e5b8396e1a06f57186f4544325a92072df0f9671adad29ad5790a55a51ede03821fb58da9e8790d985c5dd6a741c4b2825f66388b423222533424f437985978f6db738363bb15961517989eded5754f5aceb87a26fd95e4a2267e4cffdc8a887c6d62c428355c376a9f7e67a89352fb5b6598c5575f38de3f454d87e36d6d704f72fb2746a1844c18442e88611e34bd774bfa57252ba4abda0ab986b08ba9dc03bab62d4e59697707c0d27aa473ea2288dccf58531dbf80144825d491b1161e23fcdf872a16b31b64baec1259929fa3e90884a866a0fbf7ebf0192b3dfc62476c7b6ff269fdcebcd99230a4e353eb042a04122b47649f0ed3bf5199d56b823f4d2f3373cdb0098e3e0f430f4ab5c10c8cc93a438b5fe08b415cd8131ec706c975b784b8008f0c8c2b73a802135e87d3293b3e562f008c343597d9f5fcc4dd3f9bccb9f615bc599fc7ef25e7f8fc8ae7fd679cac940c45371793c2f136db6feb7f53bfebbcb9025ca1d897524f275a65a9f4eb306c2de7bef46c77c2481b187cecd62913827b55734a4ad39e07bf31b4149c3f7672fc89fc48df452b57379d2460d6c072c3dc766d8652a023bfe31c984e1f793cfb329e46711f1de72eddfde1f171b21b4e010432b6520f64d355e5e9b00ee4cfb7391941b7dd7164012dab15e23e7d2ee60f33ea1110e777b71f98027de21203b8b9d29eba634cbc2b1209bac2e85a3c9ba8a6e35573f94deb0c52ebe7d4738780f7cf7cdb6ed2db5c86f92a29bcb3a5fd4581726e66666c7faf5e200654df64821272298fcc9f85baa9265c99bfcd117aa7a033758c2a022653778efcf720bf772f9c3eeeb089ff046c01399c01034fce29c6fe68ae5dab9362ba71e4466c6db2ef6bfb41fd7cc1225d700a907005c7bf1d85d4e0fbeed6072392a46ed5e85e665b79b5575bb824c88205332e47d2d5c6fcb7ce7b2af37b46e0a1f9580deb369ef7e305c1b7c23fb53aa838d998effc7b77f2e82f81326016b7a390ddeb5e0058726ea94059a9029f4af604839078da04474d84f1ebfb722723718af7e053841c11431d5deaf9f3c7d5107e9cc0780b88af35d3ad25750542eb3dfc51b9b1d690c431bfec74167bd366661b1b04d6235d2a91b30109ca88c542d2fc218e24e9a64bcc6d19c3c82e348992624f7719ceaf3a57f619a3fa52fdfe7d86c926ced6c9b36a142a5506c1f6cbacfde0212c3a7984e1a3f30210688f2d9c992c0c0ef0f14b78cdf116771005a9d8505ce7f210544d63def7970a9dd8a464cae4e37f502b1c23ea04cb4147b2022aed6596033d78cb04ebb43b48e278e466f03ac048ab6a75a54cbf21577335d3b93c046197993bcdab92a9d958b206b53584ecfe9b287305679453493fc6ae42a59bdb171162f6842e2e8c24b272fcc404af95ec8c8f819ff2a32fe6b5925695f8975178afb26d952b4e958414351573c2f100da42b46251ecaa1287a4285349bb38e3aebba74f06e52c397c2c6a7ffbb4c10ce692837259a3059c2d192af5148c6c577d3a089b1cd790618ef64c9b9df628be5158cd9cd6d4128c747035b4dd2546b31c4ad1cf3b2a1c85cfda49988a8df0a0ad4ce7b8f44d822c6016d559b72517aa3ce6dd024adf0e74497bdb6d0fb7472c3fed0d696e2a403cab9bd49ee0c3dc714ac90711b9c3339f49e35022004478992fb7ed6c8b47077f9016c3dc0a6c7f4786a66084526754151e28dbca69f50b5b3b0147c329e4943db0b2d557713000ce6ea561e2a089e8d40eec07c2274980e54c3fa34e123fa5dd54a208a6de6c035b073516c4dc752506b5209bdccb475305bcead761a187d210f44c5653b64a87ed428bdb083f95d1a36f439eec69e54837c43f2ab13dbffa5bb5db78bf08de1db5a8c7c6499762efa6255fb195c196fa8709f8ba78b828c95fc625dc11fe69248beb5f944106917e0f207436f8a02a2e1202205e32446c4b2b6ef07f0601f5a486956bb059adc5175787f4c3fa8a2493e4c67acb61bcfbb53d2893f1cf5e6ceb7100161132a8aa817c3c194e12f34decfde798c3ebba259096ad4742d8c99050bf9be3665e0759842df8f850dffa63a69d576e410c108f24370cf5f295056fbdaded26470f9f3b8179461faa2a846deabb7b1e93acebfb4c27277fb1e247bfd5809d921cfa9ac67ee48d5397b8e20f67518fff13a908974d37f9e780361334d42232abb5a2817f5c8d3923740bf5d929bc9100adf3e14b56aa4f63803aa370f6a08eefe26aeca89b5ae75bd30a1a4ac81f97d148a24790d5cd4c530fd422436e5a35cadd8bb4f977a3969293492c2db4cc8a6ca0ba6ce5a83788683b017b7d63df793110d732e9bf689cd0db2174e8e5b6938ef7dea985ff7cef83965e856ee5fc36649ea6694fb149c02ff3e870d85f2343c2f0acaf99b6d120c5323061330cd5ff1b481f40fc3064b7d6037e33a96d8faa35d3d84dac1f164e6feaaf055008bba07b474f02c6867d8085e71902d750d29c1063098d1606aeba1f808ca3de3eb43bda6dfaf913fbc326c23eea6bb9ced22c92b9efc1400cc4ca1de8bcb8cbf8a7d2beacc51a746a7ee55464545fa7511f4332a9d9b676b4097e4623be7368ab5ccd1e6f1164ca5735911626d48ad4583ad69ba683d8735ab5630561cd37b3b6e04ca6744b14e903e29899e61e1961099c759afe455a3e4f3b6c82c1d5ff50d1f7361f145528152543a26bb929cc67789e820558d268f1896695c9bd7d654e67aa00d53c4856c1e7ca914c10b06df7659571afd80e0371135b46c2263da2699f03a35037719ba56dccd05ca31a529cb7ece840debb8366bb8e77c4d7d86d34320e5be1762cd7d7bdae41307bbaf301988249e9865c78fd375041fbb0c89c07dcffff2ac624703905f2954a758b632808e381f682fb183073d722c6a02deef43110853819554c3afbbf3d5b6b293ffea0ef21f51cc455b7fdc5f2e40852deebcf793507b0ad8fc159ee51ae1086f8704170561a8c6e97c84f996ddf837dc2d28665c706f6fba585e49ce27f2347c3800a9f49ff49f14d91c38cb5a93e92a0b4249d0d2985eae6ffc0614d7318ddabac5045e4e56ef3d33134fb07911e5ff3c0248518f384b9d0aba2553203e452cc723f0cf8f1aa0f0c3b11defb76839b204788e6cf2885e3cb28056e9160700de89361e3eac5cc18f4da980bd16f397def726f821770eea3faa5da67557b9cd11ade0a17dfe0d66df31c44600ccf968e2143813d91b08299e10ac84832d10dad8c7ed4d18dee20a641c326ec1eedf04adc43300e17ef0059398b7cd96abd5c240db61641ee0cbdce1400932c7c5dd592c4fd18f8c6e4f2c0b50b0b2e9e3b6f87c05b2b87749ec2298267844a131607475385ce3982f47ff02c409f7f1b6b96df5d63b81783cd31d5cbf73d1971e04da79f814ffecc87d82f28667715cd605195d4080645ea2500d54bf675a75b650e411e91e60417f16913249b301bfc62288570dd81b2685c0587380f54baee39c5614fa4ade0e261e298b1244186e91ee5d0f131f74330d97139d8a9488745516f3edda1575acbb9a169babd9d10c2246e5abe9e53902afe00dbbedd3b0804cdfb5d19cce4d5b625430c1ae52373638a8fb6cf4444eab4ae3ee2cee99a4f0c4454844ad59c5f70b1dab49af258c6d1ccc7aa294a59f92a7f9b80a44195b9620118c2005a040d29ee0ce1f25e7ae9e5adb5e4133b49a1f43b1aa179a08537ae0dbc920e2d5802e843631ebe99c86dd689695f10c6d64ca22f6d49159bef6865053f21d8a5984962ce66647b4525ba3af3e595d7c4da6468352adcd71660ae956fcc12e0171e811cb7e5bd1872496c9ebb06e82c837c6c181c3d1f48ee0f2dee61c0442ed1eaab04148de090b3ff6c45f0963c5e90a4bb577e6bbfc83b8ba73133b7886eeefdd80706a430ee8399e27e5b5fba6dec4d13ea6dcd56ffc44d872701d4b1075b1603e2e83511f035295fa61d316f01e43840e4ee083a88704c6c51ef8c07b8e3b57ade879d47bae18d701c25fa544783ffe99540dd45cf72539e3de5664f0ddfea39f35f29d6ce32b4ae81dfa9cdda9ddfe84e3f8787a7cd184e8be5b5fb990890b520b4d21a200b780903b212fc5edc51e7c9d44cb715f1579601586e65f96c6c7cf84b3bb84e14cc450a202652065d07fe0e7af5478e0a0b16deb86b0f66cf430d2f67c499e231a8a9e3fcb62337ead0649d213726981d472ea744d1d66402a233027a31af42ca61b528dfcc51c91c042e744c48c709424341d627bb3b7a3b4d1cb1eb27c289d04818c38314c4c21773778bbc81a5542e84a98a004e6f7960cef14df441dc2380cfe3b89a52108564485122e17c5d8eed28a02b3b4d7be1233b9d855f263c36fae5f3378f6dcbf60fb9c0e985ff4f7ebf020eb28c55670deced7320645cf441827b8f401deac013e0643d5d1d5356f0c7789b235b2be1218ff4611d3d265b451f9cf6c501590500138af4de2094d4af8012cdf0810d17bb21b91d73ca09c5aac9ed14830f0490accd0238de20df9f70ce58dda80fb774f48f647510927b09fcb3205aa651ffe22bc10dc5486237a5565bccda5d41e594fb92c3d2c7c393b98fb432bad87d30fe209f821cc91c35d0a0656847594a5ac1c42d558cf25f9d97b121cf33c5fa55152043887cb424fc3bd6fcae9a6dccd8165718ac324d469134394c9fa4dff5c49fbc1f6ce07bdc9945cb3b96289b705ca5a04d65c7f7cbcc4adea702f4fd21a4f2205842076231a99406ded4a480d18ce922229dffbc6e32536935b8d64ab5b609572a5d33a1a233d903c4bf6b27a572a2e441ee8e0b0639651115c20adde290b2aa0c360c9bcbfea146f1462dd831005afdc0652ac1517233122460c94954ff17d47f241a5270ad42f91b97d4b91760a7ac07b554da6451f089946d81d455d9284e41040d09ead1905f352b9c132ead00baef8fa64f6341a2adaf6ec1f4db7c8a60541ba97dadd70d4a0425c9956d71c1860c84d4e53fefa3a8c12a86dbc5dd887c6c6afaeb798cb53cb74cb29eaa739d6b9d4732f1bc6855c66d1c1c13e4ba9afc1844ffdfcef34d4b6a05c855f05319d50e88c78a91c43af3968bba46d424087cec820a6c445a8d74002a317ab084abe5283ece54f351a462c3331b4a0f26e6cb1fc57005b37dc8ef5b1647cfd0b18b168c1408d9c82d1f17ebe59ea5023b5dad5396c95fb4ca368009a6cc8625806d2efec7cd661dd42c30578720cd42d0fb024532726c462ee64afc8239a937900627545f2a17448b8538ebdc1f306adc013fded22221bdc88094da0341ebbaf9c258a1ea3831ba5f220e454add3bf1051d6ec224ebca0ac6db5fd20c5669e47b8e1c7977f79f8294f29286596884808fedf0ec10383789e0c00c2e820c70bc689254c188c7deb61fb02fe5cd6d561addb9ed101e5f11d51e58a36d9dbbf4a2ecdb3ed71f2f4466f37b0c62296bb13f3093ccfd3bdb9bdb518c612ec87423d4a71df74842ed9ecd53f97f038ba3b3059c11bd470d641ff6fd77891abf5e8fb05487a82314230fd0aa01f640d419a5ae295b3e141de1da6d5f3bc61087b0834445abe08e78e7a99188e28e67e8f3d9dfb31876a23e5ceaad6141f862198b4432935f0c0cb88f515896d5b73cd093edeab4e52fb515e59b4c13eb080ec850e013052861b87466c4156df6fa21cc98a5e4af07b91eaaef0336e36756a3b65f8df99ac04bbb53448ca6672ec734ba312f333f4f566e51890f35fbc14c38c21a81993bc4ad1a6513dd5f420b702c745377848a4cd722e7ddc7b405494194f6e5b7685fdfc12584deb1fe73890235118dedfc47ec7d59353c797d26b709459598559f69b3efa9cc9b7528f2399eb87b5a0942f3c4d1885ce778b8f705e379ee055cc578d70181ccb724cdc8cb5cd6c6d84223722b2fe7b7173d78cff960715cec23427d8839424a7a4d4cfc0c56c46fa35ee3fc29214d1f1898776363d729ed6514072277a0e2e19cb3b28e915c597c972d9fbf84cf80f58db91f21b73074918b99a651a06fad3c428e0646d9a79add989b7bb89286b116d32802eeaff0e0345a08ee17da47f3322221f66f6c762a25d2f94a2a7be6bf2f0693877644b2633e8469a2f39ed23815cca84e7993dafe0402fa5c0c43f4d0a49e907ab1f9f0406e12de8577c243b5f8521dc13410fa4f4f4109840683f1fd62bd08c962ea3527b0b81264028368acc683c316970600c17f9e04a655a84acaba1e4c227736fffd13306087d21715b9ef5b42bc080c7a7551e32a690f36b91abbc9b912bf2c54c0525923a646e1833baf128892b40351ccda2a43da1fffc65759508344ec4801771644fc11ff9943a77c76bd658db2706cb01631efe535802bc8b6c0220f8c1a128fda007dcd53f1b049654c77bef8f4d3d934b515cb25cb301585eb4c5b0eb33d2b3d88e95a9376d530448d52996dd70eb2c037237e647921cc2cd949331427caf3d6deffb4ad8fde512469ca3165ac136d4ecaf7fa5fd924566f7279869d4c92648233ea6d25c6753972862387322153e375804ea912120e99c71d5b118f9c4c5bbb29e5d3579be01981e07c43352c881ff659dc525aba29b891577a0b69a01efa9756e88f046b00718903d3cf57a12bb2e7e60c1549db578f7234d1f1355d49a35424a8a8cb00954fc7a3f7700c977abcd376b22f03412d23518dbe5433b4f4d044691d428342078da82f033fb229b5614468fcf50f6b1fc733569499ec4701b35c3580162f9a7ad50edda9247b897f467ef743869ee00ef1b91a4ff1ae1f7c6bb3cf0328671b1adcf9465431f99653475759d046ac215c3b24112c57f4d54fbf30eda2899d5df2a78dd74d38676c9e0c2b5792355d07f2f3bbca0e679ce5cbbf309940c7c0df8f6d5eee829d49db43e333369847e41562f5c8f1e7fc0ec706e8eec5c174763ead5db81fae0a6b862a19be45f1edd8b62ffec13885f94b3de2711f469bd3f7cedb86edf78856279fb83d23a88cd978da4024382f6bf33f64de2b10b1d96990abe2cf8e6278696739693ebfa05698888d88b2ecb3b7725d900746bd1e3c7fca62ea84a0e5a8577fc645e5333d5b9a3271d5eaa121c197d83c5fd4a876bada81d34f17927c7477db606b7bce882b55d3b5724794bdb5a9cf18c81985bfa8aa7ea6bbe3addf2b0604b3a8f05d3c46029da7bdc3761aa55a679baa2d4890731a35d1f3af5cf56cfac54adeb744ad81c052616d41fe27ae17f3d2ce469087e2441450e7725c78289e6ca6b3eb0fe59bb8c236c3603e8ae470f79f79a03be169320ad89c2de09435fe841dac79dc9b25ac7b387253546011320c887d3456e661eb9002c867fae6b69e31d073d7d4c7df4de8b4a03a2d99da5762f2a3607285b2daf5ddb09f2270405e8e8afc0216b84afc6c1fd5df9711fece1517a1b83d16625042e3fa660dfe3a13a617d2304bad9616e40cd802490fcacb6d72347928a5a3f2056b92af68c0ab73137bd26addfa9e53390cc57ea71caf49b1f885583df02a26aac0d8260c313ec54b5051506e8bda71f11c70a7a250c1ae1da1296c053c995bed1f00d5116aa4eecf191efcac05ae9972f4b4058604ee3b60251f1578aad0c04827d47515b92a677fa6dd3c830e21cf0ed3ce2efb51bda6e333d61435ed954b66470552a18e2eedf5f017788f885ba3859848b0c58496d397264e496328ae365bbe0799c18a14d9d40f2daa541ce81aec605d3117161f7a501e568c1a8d5a33f8cf42e15b0201409daa881bf7e0c6cdc94b97636b676d1dd33469a07ca3e7db384296fea5c8b06966bd3a79c1c852b48a199c77045909432194cefff9e5d0773069bc3094d798c698c616884f978f7f9943e66caf4dad60ca8b1b6cd244fb3116adbd2fa64b190ad5371856c659413964fbe6ba45c23356002cbe5c42e0160e94e82456adc2c80391aa90ceac879460c87b9a527815f47e02fa5927ffa157675b9c0789649f08c2ddaa0e25599739a0dad270c2d3177d2fb2ab1d98c0bf63790ab751571e67baab8fa39ad7edd9696234f10bbdb9e125928554b4af56c372f7ab6146ddbf3f9c7c8b49a6276dcf92e330f7054408f476b10b70b18ad1bb2cb5ab9cc11492d373acf6a36361cfb46623f1a26bd622e9193149bc7c09cd76ee9ac19760ad7171fd91aba6b042de74499d915fdcf91d7e2cadb339b28603dea264911b5acda3496c15f66c659f60123f65897b9a9d309f3c8af4b279c52616178fb5aa0ef337a78faff9d387e36708c072f0f4466ef65b2fc1392f1138c36ff608e97dfad6c8ab79c9a1a0659aa15e26be58cd5e0cf27ecae7b4fae0a730d4279169b8b12a379d20093d5e5ab7ad1f3b0b4bde85abe924729cf8f301596b152d6d4638952c9bff86532d67fcd82d8f76c8d50df5e62b92c6b062f767ec881dde48d67a843057945298087bfb6ca40076752d390c1af61a99bddaefe02802b708e7a263244e2c77ebcb1831ae45561a6f2b561d5e6994b0abab9586b610f364ae284af5ff2f3bb878c6c4b6c752e99a91f6aa6823586890e92f377aeda4448c5f5cf0f33079d2806a38834a3cdba894ee110c66edfd5a80bf3ed62f7df50e6457ecc5e1e214f680e120b4e39f52b19efc7985b062aa36b9be4f5601f926557a8b82afc0810312d43dde9b3cf5aa0a4a1808fa17e050a319b77e0f1fa9e82f7483bb9209ea8ff8b74970bbf6feddb09ddaf97d584e965a64485c26318976afb49ee023ca1ca22c5877265f85141bb64f4e2a9b2d916b71e24520f2af70371966b0d2c6d7da1f031b0f6272ebc65bb246eed65542b0dd5004f09da911cdc4134ac0743ed02d05fe8a643665d10c4a108d93b20289e754c4885c9f2e199eef415011e1af1ad361868afc6f0dbfe6283aaab825b1713a1ae5ef4425b9b68ea5038f9281f62a3d0dc973dfc244b46e1a5885ec92d8e8cd1eeafef869e86779efdd903265dbfad5cc46aa0423996a6fe3cbc89d679973ba4b49419f29b2a20741fc2b641840d4890c7fadf184c0d6d97fdc60206b0629334fc8c7f1c3ab2f61bfd212046224e8fe9b1e52c2a19095c93ef1f9d5b53dde187d0657375d85c5dde3dfdd6fd4f95b2a2b15c5bf2403132fc0ca2480ed161bc571894b4e129aaef264deba10d5c280d383ffc0eb92a8e70c77a933469e99deebcc4ab0d8ad9973f124a9337dda8d782bfaaa2051e8001d86b6cd723280fdf5a622a2842112456243d3cf8ddaad7b0cd29ee8641093163ac4562950f0708ba69b1afce78a7d5edb4ffb0f315b281bc625fc789af1f41e109dc284a1becb6d33420621eaedb98ced8680011e0cfba1f6e0574ad54f7d61b0eff275a697908b9b78a62b3b5f54b39579d0c4aee6334d85b9ecb854c3c0815089bbbdaf166a408ed98606be07fcf7f8df88cc0a1e9d5b7ab12e83f08a34e87953803d561e18df4198f2a77215e1fe5de4fcec4962de2d69c9c4e3d80ec9e8af67a44359e7d3baa0292b173242c7a5bff77cdc41a08d3658618dc66904f47ee9afee532f9b76894b488a552646e4785bc50ef45c8167e2a6db04129aa105b54f543a92813db90948d14dfea2f37830b707d70b139e8754b348c8eaae59ef17d58103e6eb18ccf6a38e934f3316555e76300cdd5c5effca0a82d1c70cb0b96dfc1dce262fab0d3a72fb1fc66ed7f0ec192d12185d4e3077f984fc6cfaaed6a4ac75318319f43a296dae1dcf25347f0d107ac651dfe3e79e7bf80531c268e095e46bcf7018a916ee3e1b3a229adb32e2842985a2c5ad2c35fe1617174c40d2a72324ce4c2810b1d5237ed5a9a5c89d30901f9ec9f4a347790ae18d8dda7c74fe1a7dc58b8c7fac66ad66cba21ac943be64d794b3f58670b1e679420531f0455d08ce25cf5f35e5abc2066ce6c1804a83bb6a8f42180bb6bb6629bee77da826f5a5bd1ffec71eb56bc29a452fe95fe8be33787739949321e1489c6dd9bb9085afb80be5b61c55f2c9e5e928cebab5a96b24800769c68523dc372ce4df53972e745ca8b2a0b7087442f85dca05a112c38de6b13e3b751df157271f72083d6600b5c05cc3a96b11fedf9e9baa84fe40e101f84a0123585c85c3a0a4435b1ee5144e7e86d10b6357473ff19b6a6442236a1f346f2bf48a9779be7bf27e22d4fbea16d51e1cbc259941423a09a9fbdf489c1d0bc05f959b056fd9f474b906a411933bb5640c2a4246362c369c2b51c1baae21126a36d168aa30c2f9b7bf22ad070142ef22688784ee484a893ca18a1d46df240137dbb50524634dcec885eb4b5b61379c3143e49e0670496e0898999131a92d290633e96a3d0a1f9206948891fa68ebaa12f21166571f523c61c4f5ba73e33a7cf9ca7aa666106d83c5015beda5383ac2438577f803e9a2736c2d9597a734ac2efebbdcd90f12e3ca28ac3fef5c45ae789b2711be623e63f8b0d1db0158a79e60721ccdb63a782dfa2b88b6d7306f0d616d13f65ee13386d7691d4c255cf8e7c2fd187140957e12aeef650275c1f57885283a100e699ed626c7d4cde97fbd432f64e84595f89cc4c3861575058c301d0b06aa862b45819b52f8a201560d0e8734931734aa091afe773e54f8f350a05b39a8301798be4064dd406c3371e475e11ab3e18f2219e1dc4836f9265af21e0bdc1dff04fc7ad8464e33ba281441da6d201a466570c0a3561ddbfb073b6d6acc1e6d0a79067b0fd778258fdd5e11998039a3b6cdc2cf55e45d8ac06c3173fe006df3853f9007e8811eb8ea8c3d0f2b3c6d9678990bf6bc246422e2542e78651f3e5e65df0bb19eb1a9ac8596167bd71deb3e235e85475b0063d96888370af68b3d43c893caaf2b6ab2574f02b21cd6041fe54d79c77551de86ff93d626ce8968a2a39bc4d2e21a9ba06e3b530fd6cdf605abae504e608b6d6e4163a8cc6463bbf35385b47ab8dcd06de2193748d3b9064db3098cec1ad924eb2ef496daed52d1a5b0ba39f6a8550755ff79191205245b684dbf76d66c25a015da88bd7f30d2ff32262ef8bcddb426df39905349d344a952cedfbc454b8071812e3ac5960802fc3f8cb850c2dbec12b3ef9b45d52f1f93cd044af1ca7b423fef531eb1e97d2965c49089900bff8408311b5b71b4ca9580e80a87b2e5026d7e3aedc6e3c5af85c543cbd7421fc44e91b9108682a470663e0478fffcb7e8b57f83d113a17057427b220c8d3f000ba1949a7941b4928720230b639aea85f46640170d84b0067df58f666f70e5b0fa263469c6bdac8fcf25ed053bd94e05fb487d123d115b2cec38421d07f6ac54924ebe0cba98252906097d2f6b59c6154755ee1a0dbadcae6f1aff6c38f783fb26f0a72379a023c012a9e3332e4e1f1a106c9a54d8c4833655c91c4ff9f278fb537cd7648a1f0eb935c4d2923552486012fe7107a9fae2848376efcfba94db21aab6da803f2d0241a75b9c4e6f33f4fc09dbe6c4b52d713356fb2f319af190d8b0095f3aa7a338c10634e3ec5c20165cbef520d5b0a3313dd8c06ab87b40eb3492989248403acf1659d95244bc5062a8b83c4df2402b65aa4f8b5deb436f622a328536ad078c83847a8abafe84de952c9b4c1a3ec6b315280d9b163297b40ff1c8e64fdba17c0dd8e9ccd4887633bda13442b6d606b2dfc2d2d229d5cb8ca6f29df56c4f7cb9c623dcc12b48fb158325757f1dfba30d60cb53f94a1e7a12e431042b8e6d02ce838375830f7979d9d89c6cc1081bc93fb3f60361a469d69603eb5b330b6f37b2a9b6307637356df9f236dc35b78ca118ebad80362d0a21acc2ed53bebd08423ea4a067713e86561f2e92899a4ae237e9f3bec1cbd4c5738b8f625ea8e318aaa6df0ee75a1c2aa798522e98d586a07e72e66a24d1e893de061cc9cb4b490ccd2b96e788021b78b8e9cafd300ea1602f11556db6826ceb72a2706954a6304382fa7d1e963661311a2e9ca9e17ff951e1b1c467d3a3cae85f17115e4721c719d76d4ce13cee6565d2d18804bfe279a4d0ab9c27ecf5d4336e7c21f7193a98535dace8d780fbf4a3b8cf49a51084dc56de51e0312a76be6f3eb724aeb9496c4b073226f7349730a9729a6e44a1a85b8892fd16ab392f48c776565f2ae42bc508b015f2b9e6bb8b20856e54dfa9101c833f87e5e79691a0da22bccdeebc84ffc73ad4ca5aa1313e36231258f202029fdeae9d2d0a02f9569f148b810e37fc1aba648d70ec3d5428b729d1400bce9e4d4c789487ba16ccc206e1495a7569a2525910c51fc916e771776c5db91ae0bcc8c755f3cee2bc592b116b4e453101cd5e86788e4bd6b36acc9ffb422bc2f87e23db7a6da4b1f1ce88b67481c7cc9c23fe6ba74ffa39f81e7922318cd7a459d1fd9a19031bf1c435ff692bab8d5f2e4eb947c693d0b0778e3a3740ca0f4e89120761f4178f5176d2949b47099e34dfc943a2a2cdbc939b3dea7020aae5cab51d0cf6839e7b6d3ce52484c79838ebb5e7305e090cb971d6db6e2b42d22438e0ca06ba02e4678c994c2bf200312a346c0bdd71b87ce0d40475ef85775e97f868df9d767468c64c93433daa694e4ef20e1432fb1a30d6090375c29d1bb063045d6cdc1f9b06cfcc504c055af6cbd9a451ef53653aa15471157c1822d75133e6276a1271da40b252d8c61cc8d7530c5e1f40fe2a4352dd06df21bbc1df57352b3b2df42643ba342dfc75266343cc457d58b9305525ec5ef7185f9b7d098bd01804b8c0b09b8d5ef3b0aff9352271845d1154768780f16aeb4a6988ea18c7cc02fdafb7a87ac9a1adb436a7e38a502f8d00f9dbdf968177ad07e959e924a94ee64ee418d99c227546e5457f1ed460c7dc8adee9736b9d353aaaa36e0f3055f446f9e2c8885ee7f7a7b71697265409a065e5369290fa4047f388c28507f269cf9e9d34355d4bfb94ebdf91adb0069c6a3a05fb1ad1167ab4aa313c3cda65d5b66a9bc26e739cf0c7c5d7b682b627376d2d31e807299bb471f02cae497c9b59929b5c64ae502495f23d2a9daf324275bb9bacbf1eb6060bdd67dc767173f1003ae92d94ef1f9bb46605372c3cb9e7f615ff29fe760dac2c701be9d2105fd1ba2efb74fd6a851200614bb30fb65595a5fce43d3d0151ec74040c52cfe75ef7c60c16e5dee72a521bf04596236eb2317326428051c704111f493676d2788f3aaaa7a94073612a2cb008f2394a222bc7588e0d484f3cde48d245ff3a39e67265bf0c9b0b4b3343ed6ae7d065346bc967cfc8812e88d2b2dfc86e03b4078f2bdb95ab56dadd00721be9c9de14c71e2b873db3a40ad38797bc1b6da354f60067197671293311ddbd84780729cff3b3ee1a3dd3040698d04890696b4e5b2a1a8a92eb9397a06537d6a8b3e99624a164080b46982e2097d507098abfbba4bdd5a67e1bb6e2d653caebe9cc7a504950f5d01229242e2197d4e18ab278ea46721b1235329823fcc9aea640b5954dba64f3baf9a23fbf279ea4a13fd6f420392310a1711bcdec814cbd09be424026cacd161821b3b59e55789259e0f2dc3610ec0336dd02a6ba38b78d04de23365ef0dff41ad2290f443e9258d737d0885a22bfba179a390d5655518144e9cdee877640d7d034b04ec324a50493e32b6933e974998f27166a4af40f372bddf18d837bfb03fc264afbee6895942883634f26ff0c6dfaf3bda38c7d7f0760a51867c555750f1f16fdbcbc64a825a56ca8873dff642b1b2a405fbec5389bfb71fac5a1cef80757fdd29e4dab1ecd4ce432dc3ce44a8d45c2dc52597e09946ed64e987bc921c70f0a9b5fdfa9bf7abfc4536fbac8b785732615af593938adb6f01bd8b48367fa86ba3cfca4605402f3b30b772a0b1201e8addfeeaf8b361a687f1fc7e8ddb373abb5c6eb86d8e5374f346bc36b105ac8d83de48ba0753ed70f7d3b8c70034e6bde25cd96959d614c5b478933adf95bdd59c2ef9cec5636f6eea755915a86db9c7d77ac382237d0c2eaa373e09610bf8b0a386f684ca5c93a004dd1135a5ed60252327cf01b8996d65862eceb709ac7e76c6f5f03a086b4c9a6060b6c6694a9ba15255ab5926e700de6530ceb7a2a37964aca0489cc75a34eafec419a67f7af2d7780083a2e1df311cbfdcf890e4b482990e6e9177c027f07530b19f5f22581437afd989242a76572d18ed040e2c422ade1a2ffa51ba47a1763af3a8645501514faafa941d42b69685e6a1880fc52967242b5cd4affdce0d1a09d8145d635d8fccee0815434178f8c3055c18d9a6fb9a66c5a84cb2afd003c264080561d1dba79671483ad020638d03cd6bcee2319933968e7033078b3c891e88fe43e9822cb147bc4d5ecca3f89c82e77fbc9bd4369d41bba1b597db74dc4ac4ff91a991ab3fd5b2ba0ce31d199a20b8cc8ef3179de90786b3669382e334f5a4f9774913ecc0e155d46a9e5785e345b6ae612d552a45a5b5c773d62c0bf8ade285dbfd52fb757a743596c0c0fe8f5682edd9be3321fca4f1c00451fb5e1c3976ede6adc5659bd090727a373d8655503f9a317c40ddb7378361db3270cc0ac0e851c2845526ccd638e01a66220e8b979d82ba452d3ce40f548fccba7db21035307237c77afa78cd086d3b8672ffd72da8655f5a443e0ad0d3adbdb868d5c96431eb304323e66fefbedbc445f60754d4c55e19d756d84bc710250e57cc1e850799afc5ea7f006a984548858429cc0dc72f16d02c3f94535274dc3046d0e5143249071f339d49742ae22c826ff60530d487e5f4f064a852ef283d6c8597b5476b98c64bf46dc7bf8b81247c0d68e60fd2915a251b39404f34ed7b454595521224b9038c332adb4a30388b6f06e9a932103ea0e76aa4e23d15078ac8ed15999fbc9d6793f0fb10491a9eed2cb50606f0beba4dd376b06cf2af72162adfb4fe33ef0f914ab3b42de7ad5189dd6f72b28867102f943219a8e0167981059d46ad77292c51eb5e99e42af630a28eafdb1e45116c491661988f995c805f94faabe277e85d2606d87a67b3f07bd2418a7daf4c3aa1c7328a72139f547d54f93bcab3fe6711a4a3d86e48666feef932be2a82b4a1b82d09b5f44435272c50ee8e4d28ad90cbe546021cb557254bcf3fff758f8ef9f6645bb626bce3af42217e21151b65a77534faa79cbe09797030f34755e4d8342cca45e0817e0f8c2939cb5b867e7a34d8deba8cff79fe4f90dd04f55a36200fb5f25935ace623836622d537d497ba79e2f41b58014c8677b46d497e99821334f4bb49c2a75c78916293d2b2dda2a5c4f45ed8557f612286fd33c20544140aed5cfe5d595af91d2c2aa9ebb5c8331aefff81f5561e513f3497b678509902da1e9361d17b1eefd537c88798d3167713ff8cc256d95fe7a1c4ba000a3f6d2f3d9c66c97ca47296eee7a4539e41e1b386263c03117759aa31b03cc842e0fa935cca293dedbc03d9661e535b1fa28cf38dd82c527790d26970a2a750976335ea8dfb8aea67e217af50b426f6b5eca6f79f66b7775c235bfc3cff9429897c9825f0bd92ba6582168f0ccb6f626614e2b8cd8f3abb02a0a20fcf36956702dffa00db32ab94534da78dddd7251e17e12210868cf38324265d1b6b50b50c19efdd3b99f0a9a1896724113169eedf88008d5726d295449234d1ccfd062efa3c231152f9984355d003f50b887db4293ed7d18e331776d1db6bbe5f4d776c5ee8904940eddfdfff03b74be72e8947ddcfecbc8c9ec3667ddc23201db5c0fb8fe5ad67d7c867be17e468081c77dc4ea86b415cf8d567b920f74722ac54e2d56df406907a78354ca610235338fc3e4c3f393e4d42fdf5ba41311c7f9bc55bd62dcba71a37c057ed1863a8a51cc5a78d0f3c9256aa7c407320fb8ce29e125871194e1fffc0622be61116be0e7bcb9c320ea52264d4ad88c2bbb71fecc2c4965545834686f11a5aebcb5055648d7f310222c7a891c2a67c3a4c73ecbb4fd9291391f64ee56291fe79f96fb2c8ee1916507e7c3fa3c791490b50834029173d24d8bb38a0069e228ecb1530e49328d666889ae3f1e4642fd71032ae44f2f91a5dc91ceb21e96469ff50c5ba7a68052a4da32407ed607c0152b426fa39d6b82698a2d74f0ca678d7dff20ee3652c76a66f949f9fccf10c6f531da3e588d437cd465e3666a80a2e7a83f8968993a16ebd3933a3730a7748e03ebe65dc89a1042c2d360a2a0bf8331c80de52f3a93247ab74131864ce62cf6f6067d77d96f1e4a6a3af6076afcb3454f5d71d4a4275e6ac0b90dc38bdf8e23ec02faff3eea7ef6f23977968f9cfa9c860d45b5362163864a3d8fc3d654e272629dd476a189fa7d37822283d67cb40fc14fcb13083d948c01ce71ed4cd38e8706e0e978805d2fb564740a0fca65ef7eaa54802a193944d87615f63daebee80b16f7104b1f378c7bf5f414974370f0955f5cba941ac5375e69befcdfa7d05151d7a066f602e3e8831857c24c0e731cc0336f543a7a1c009725f1234a2833f675617ed4b61a74da4e47d45b53c245842a7785b6f37f9d2eda907b6e754974a4858959464cae5ccc893ad27bfac641c057c7ebf42873622de035031f50d41f544f8917edcc1b9f3c115678cb6529e5a05b4266cdc28027b5542782246ab7a440a7dcd8bd8f503a929ba5a40e1ade459fbcb3ae90c1391aca47829ba75767e6c6cd47599d24672d4cb20d137021cf2491bccf86f91dff6a80d3ec53dc51a2954ca33c6b131908ae54b8a8b810a14ebaf52469d453316a7770f122726bf6f744828da121a0ea246303a597aaf1aa6f6de25b75680eb6423b77297d4cb41748f767182ca74866cc6a9531d8859c196668dd5a5dc9ef4fe9a39c985a689cd8d17f708f6e86d28dee96cd904cf0ea8f4e56b12efefb18e267aa71bf3e1dd19cd07484781b2d571b69ca5ba4ec70867f52d7371bfc99eb1724dcbcd1fbe50dce5b52d0efbf939801bd334dd4cd909efaee04630736131f5df1532a2a8ab118ed4c7e560100b52cb27f11f63894f7cac04ee3f241abca4b2a2113bbc0085061bf6ab8206de7afe18ae167f6e614a3dfeb23544ca56909730ad6f81bd03695cee1c7c13ff581b8d8fb55f1bce5d2738fab65e4788fde3f6047b3d41d2d9cb261d056ca2dcdc2900d48621aa84f91a6572c54ead474f418f8259d0da1ba1367a0908973823b3e0f34f68cc3384ba06e98db028a92d4fb167e906229e681b8452ae5d861b2472864dc157c38491e58eed7a10987ab538797a79bebbf80c7f4383ecea730af85809a05d8066540489b691307df328dcbb65d5b7b448352d75678874a619ca18a1e3ac85cbb4aa65bc3c6739f04060edb0bd5daf8ec732e9a87d15baa05f151e5156e9b00fe60e2406da452e7a7af0fc6db1bd49003bcbded6f20cc408b33c4962296d3d59e930c00946b293eaf1395184ae7af9fe7d2aaac37bfc5b241ba58be4f0e2885c2e1f71e8821a4eb46083e3be88fd64c89d1de4fce8fd79e84ed142ec728cd73fa94744cf164233b4ed218042cf028ed977e824d2b6dcaec9f282143a927dc5212ba28c001ff97bd90876efeb492342da4308da9ae72385c849bf2e88d8d77784da726ec5e2d9c9cc15148b75c1970cf08b1b255eed4e13e03ce3c3cef56a6f24fedb463b3243ef4e5dc0a091134a43c156f7f287976609d8364845da60ff6449f64c3889f1ee91cbbda13f6ae98d6e7ef24ca131183e1b0b75d35465ca239d244fc009f5f81082d15bebe78e647d17ec9ce8ed9c0f1920d4bddce8af4b0a130b9acb9098853c7e1619747b42a55bb1e98901f50d9ef0e5a48b1908c7600dccfeb2625f1bcff88c6cb500e50995d050faf06f5edacfa6b18746e2827d327c630f5e705cd2efe249cbeb8e46aff57d4c4d1e6bde6386cff7030740d4f803e5eb1af802cc4f3362501b2eba56fb22420e3c90eb5ee17f4430fa22462a42cef23902318940667755a13fac0386d49b8edda49658662d3f7450f0e86f50cecaed62a10597aac4aef3a12a2e4385fbd33b8ad35de935d759bdd59330bc9dd2c5bf8635ef54adf98ee6400febdb6db6c1452d9a5d0f2a6d99ddb79b3f121b0121eaf47631dfc9963ea52901284fbd93df180b0db6d4efcf905e6410372b8f2f0a8c8d8c440d573b1f200ad84fbbb9bbdb3213722cf1dff7fcc50b16db81c4b41bc12199aa7e5aeb57840ac61bb5236e775ba4481553beeec514b730851a747b666ad5ed81da3c7c5a68f5ec061f96f713f48c3e0952c99eebfc1e1dbe682495ad7ecd27eeac637993dd2cd8415dc077824638e703fa42a20c81f20d046f6817bfa37dfb1ea4f7ab078bb1957681fb2c7612c56a375fa6708323cc7b848c55764338f9329d1bcba887814a3b72ee9e7a327ae9f91ae07a12eb45eab2ea02d880bad30b762a110cfc2a42f22900018fdb692871c2953d1f791759998e5306ac4e2f537c068a27cc303527cc0652e13e9d283fcbf3fe4f664b28b219f694cff5a676e6ddbbf4927938b61fca1d96fca73e1978dc7a2af140b1793b54b597e70ef48f61d0782b18fc53da6ac467e4a2609bf3bc261d78a3e71201d1c63b479e0931add7bd1fc24a34ed70e134f29a8bea16fa409d6fd1c07c37288659e275624039a573a49d00595c0a676931ef8c80dd25411fef866ce672a85d61a14e34cded6cde8e1919df124f93aad0fbc7c894413a8f51752cbf9a30b4705cf106114906fe9583df3ba686064e4d629dd531fb8e9dad6938c891aaa1f8f41de58bf4dcbf0f33c1872c57571ca87cc6d6a3e6cddf0c3ac9403e3fedafd00141b5f7fe76cfb9ceb97d23607f61572efc8b7675772c44ea6ea3d8be5cb586cc8b0614e776f0fb65fe2a939e88b84fd7b394016bf3d05cad1f5c436daffc582c78e1966d0fe1fc2aee9cab0818e255f8f4013d2dc6ae0eb51c322f0aef59c975b08415e09f0a08772f4cfcd0cacd392a6c138a195b6f0ec048a621ce9e9ba3a45c7a2bebf42fb109c57c5b32d2f4c22d4e59a31741ee5a49094cfa40d87af30fb1644595d96780af951601280c5ed2376f68b7f6205db4f86d8f0c7838fdfdd6781b3166b591300503b761c51565108d3105ea19e43f0208d2ba220ba61d0b688cf7d0331ed2d0ff30f5423e15029def6ebc20326299ade2fd36e4236011b2235310414a927e93d597f214df85eb35630e7791f486a395948e64ea9ca5cd53107deb28782d4943cc29d82d454fab258f413ff8a1dc3679818c73cf743f4e44d20947af2119860719e9d814fcdfcb3502971471ac4629d752dd7002f159f4bd1273acefc3f5442cc35656c844121d485e2060fe398a6379770e112a7782763213136c37feabde02372aa97b737eb4f6d7456d0482fb919621bb4aa1fcc2e6b1f323243231ce6ca9e2afa831485b0fdb3148a687367f9e63ec6edfe5c45b837e449ac2169cd17fa09790cbbe14f87e8805959bb2e429cc3fdc9966fd75dd0f886fc14c688de872d2d4111526bb5d86cde7cc47341fb874a20149645d59e4f4133c780d0bdebc3956c8311e442cca66b90e5f9ea6bc02c777818740354bd96739e21864034af977a7f7f1033c5b1f2b1ac68dd9d4c02ab4118902ec2d6e5afda80e07a88bd49b4d584030808a8db31e3369f7d37c89966a3c76f33b6786e9b9ec2ef5585abb31ac7a055d901db27b286ef7bd5306e0ffa4e0b3c85fa9c60bfc6bbfe6643a526ad88e5df2a656210246f44ea308b3bcdbcf262dd30558b4bb32af09b987781b6b7cc5c6a610c73db4a3d10874d2ae369de987fc5f0a4787d0f13f9610545065d796baeb4f0c340c5470737ea14304578af2e25c38061d5563cf951a2bab3bd68b5685372072266e72fce4cd116c11388fc568284ca602b7a09db96060cf9fdbffe718ad72a1330f991c691121b7019ae015110542e26b93537f6a8a7b8a19505dc48e3c8f4bfad7ccf4775a2be30b5ae52e67b6b5ffb69483a3a78fb570f14ce6b0a0a8bed3e087eb6e332c2aa84eb742cef1c222310aed7d47fc9520a0b324e9f484a05bcfe04e34131436bbc3a561848ec2f0c57459030fe2af6949bc75fbb871fee1fdd73bc591c47a6a222b52e5ff68158d9f08bf67cd7332b70099e1ff5ab3c7d39c219932d4c876bb14b3738b67cd124dc4bdec27ac6a5dcdaae1d386ac6813510370f334edee4ccc744ba2e306b3badcc96881b6db486e0e23d8b0ded7b1546f92181d6caa3e94510cd2aa211f05321599d3601445b77c89ce9cf7c8a45e542c5031dfd20828cf58aec27ea2d347fd826713f6e37254da7d2e5f682077d153c607ac1876be890046fcf24ce2d1f5451da9e215349329d1ba3e5f3afbfafd4969b66ef572e0473520c46e3aaed32136a3d1d564b0cfffec69b01be0fdf5df4ccda19af7ad09c6ff83a16e3369c00f3148b4dde01637d5ab4db6d7998514867fa7640ca03193aac79255b012dbc7529ca0db030903a9445be41754f3339a6bb89b54b76d608c5013aab4c42fb675919edb34a77c4ca60b8fbeecdbfbf52ad2138aad0050d29655eedfa7bc35fcf15ba1e80109e53bb115c48e9157a914d0d2701c01e13822e610e4a1df50d0b8f89fdb291a2b643c76113f597e64cd3f22fcc3fba69c5c5f4fc3e204aeb0d4cc8e33542c4900bb1348aab865d252b409e250c74056fb81fe3fcbcfb5ee6f536d6dafe376b4856b5b4c13545732239b5d3e812caf99003aad2e6f904dbb0719025a1cd7fad89eb1722b6c7699b3c74efcde66f9c794ed2051dbb74efa9b10591c9b7799be797232896b542c5a0eb0dd4b8232b6e71eb1401b5278034f330b8f5ae5d702c134d34ccedc827adfcdecba9a080bf9fac52e1bcf9ee3ed3f450ea38fcef2e426718ba54e733eeb9e20eeed998931c0db4dd00a816d9ff7f9a1619899c500b6ab30bdc5174f4fe82f00558fc1e075e8896ef4f05b1343b047801849f86b36aff7c62244ce83f02ad8bc8bb057601cb1e8d0cf4febe571d01c954ffb04277adf900a395a47bffeeccb28a3032a2623134356f10583994b3a4302510e09063c97736afdaeccc6182472d70bdfa6b07a979d7fdee8878f510b34f9551f4d4d40c9e7acd6efedf5f2e84650df6c662017438748652449153730355b8e1262ec71c078a333250cd71e7f0e58b69490ee1410cddb915cbd38d211383a8394fe5d45a6dcbe45ba2cb63eb1a74b8ee2ac8bb18e01746aab2a7012c6ef92842fcb7c6e6e611abd6f3e587c7201b0b04ebd850b8c7a2d0825e5f9e882e6da9576349d4b1b0061c6cb4699235ea4d629aef10a02417cd3fe48a1661faeab36e62b6b124c13d86694ea2a1aa76032d684da13cf973c02c6b335546d4be54708220695d5d6535cc969978ed91eb86a5a67e3781d8817952a509a1abf439737a63feb59a6274fa130c33b07df20fdf38422efeb18a4ff288bdc0b9b9c8171194d2737aa85d6bef066ddd42c7fc4e9c058f9785fbc03e5a77e1bc980a431f19add2d7b624cc2a5ae6b5ad8bd203f7643d042759b90e173a95cfa30e26c149fe6dd4ec3602ad0b3179f04fb3c1c2532d658621ee39b492bf65abab4508878f713b1c006c5031e12d860d11bddabb9a3c544f1024c42791406fd869685c4c7a9d39addcdbb36b95e3697be757630b40611143dbd316bf4a399f1d465dfba16c801089f472fbc734c655cf227f207920c6060d2e84b24a0574e2cb4bc81f3dc4df63b11f84b2377212106fc1e86c029e9bb9c900dc1c1bf525f89678c09d6d00ab43d9cced85efc733ac81170f618dc36e86111dd4a08d319ce2ba27263768ee1bf324e1c0cb15c1a951eaf51db56fa3524cccebfde91537c24d21215aecf51d48e21514995fa22d8178ce01c8c4a558206de9c4f543698ed02106c5afd0e3b7b2c92e496cb5bbb4698e1b8a844085598cfbc3d1c06bd29fc01b933a89d95739b8e2768c2adcd6024b92e1cdd016cb3ff5a521f3b5d89411e2b91af8dfd84aa99a2e74c495e1b7868471917d77427fff8d616089d5f0798411ea0e1f534f2fcc9afc34be103f6c5a077875e62f089a3f6a497473b95a5f33737a9797fd5074547e9f05ae4f51408f92ef1143658cdfca4e1919642ee39694793c70e037463a4acb8a145231edd6b64f0414f129a518f24755a26647077dc8bbc7ced70fd645fbd17678a29024b76d283c6fa5bac21afec5fa06e77e0e162e5bc58a6c88eb9e9d8c2c069e3a0b19ad5db90a44379d68c03c664b420fc62c6cb0fc1b7b4d822515864620ca37ef6ddcc3c7405c1ec71492ecab9d66b2e76ed9ef687eb98ba1168a3fcb74f2828c4a04dce0d90afde9220f34a65e8ee189f0d6372b0df01884390956b93c9cfb04dbb89d9365e7c1bc3e494e3e6b4506ab299a0d94e7a2653cf3e20f8e7d26b4268ded16040fb275a542b653b672b641a3e11cd66c160b01e64b43aa5c089905e857942f2fd7fb1601c653d20ee3cfba3968f3ed4d8c921592e2431e7fe638e335b7a496c96b9757821d85e9e1421b460cdf7044b986d3dfb2c23f915a3812eb3eaa739365f604a26b79589f61148f0385307846f6ff71f9fcc9a1dd1bc2bae47ca1e33e9bb57549907733a4d63a239d74eb0d32f9f3ad326c113e1f95e31990a11cdf733fd514bf58a32d354b99a64abb5af96fd4cbe8a52fd362b8ddb5f174b208755fca02d6387f9d0d0cbabe1910df61bce24be84c5d553195e8276e1e910c60cfe8abb8971e5d6b592f4ec5c0e8e5e25083277fb55679f6968c736ed59dabe19b5a4cdb991a0885223d83c42b755f796d2439f5e1400a842ba2b6985b6ef18f71be5e73120e5178f0b4b3af3b4306005ca63e7d7e2611476895e9399c7515ec97394e041b931acced522b912c17302d2a27c0003b83e16a044322ada91edf2aabddb9d575ad0d5bed4e4fbb1202fa537e9ae9ec63e9b3999638efb57d4e7bc3acd64bf40b76521186a9e4d8106eeafb5384773024c7b4433d033f6f8f25c76fe5d0e76238f860f390cfc31f0b15a7972b81bfc84c107f95c03adaa9a9173b8aeaace6ebe6b34b2444007caed43bf15534eb6d0458f6d22499826a5af3b4facf74162edbab2db46a46d876c69c99ee53f5b1f58c242f996bad9a70ca2c3dcd4ec5e6eb56ffd171ea6522129cbeaed51c0b31397a1f2755aa2286ed56e98b30faea11c20519ba2cf564ed457b2239617eff67d971a7e379b7db1643622cdcf41ffa61d57ae30bbf8e5b503cae5bdf8092d5b31a30196ad1b52f519dacd6359a47734bb70c10269e9a764ae0184773aaed5e7479d573c54193c4358cb226d21c34f1b71b2617aedc61a2b97900bc47be73b58bfa2c1317b79c8e97337bc011d991d5ed0a1c62043b174a6d89f5425caad5b4e1f39cad604ad60f99b44568adf5108b6ec64f5f918783d5d353dc1b75b2c1171605d3086fd9b352a63d4df933931413fc9e0b93efe0f083efe3d46d5d1019c4459bd5107d36034e91a384a79ba051a06949ea135e6f8892ecd840325aaeb50f897853bd56ad12f197982b323525bdf98d2486f942be5d50bf4586ff40676ab1e2a6904150a7db1793eecca9febed61135515ca2b51bc558631d1c932228e79a1d64e8fc84f82757c400add4b253b2257dbf6432a147926e6a4a495841e078a016a68e3a5a0761834c1d32a0f25b5eaba8c0ad46275786efb9fa890742478ee8bb08ded22aaccc3c997184d43be968263e456744663a39f34dc29831ca8705d5fc2cccbd4dceb0dd1ff636601a4e95660aa31d5cc2d9c49ec688ef1349ad6a6288cd4f88999e94f33ff4d2bee927991cdb2decd3cb94b2c62bc8c643556b09e2ea38dd80b568dc5105670a5a4ebb923102e61a89372a9f21b9518fb497dbbf9d5430374f832869ce5aed12ec436df63972333a3dc5a095d9bb6b3e2e6ea71409416d153fc09709a0f7efed8d4547525f227461a6a9d0c034ed3238948feff8e9c29a59e3eb80722a851d33fbd1a12c91ef82e6e865601a41d6be11eede26e4b7fe261efb2165b366763960e53ca99bb38db29d027d7e8ae83dc9888190945680891576db9baedd55215327ef360fd4e339c9cfe91219560fb4d3fb9ff3fbc755fe7c9327121989bb3ccf169cdda80fcab01747dde960d18655ff2b71c1dfe00571cc8adda0ffae6c6f36ecce6dbc2877412be9e43080fb0f738b9009f2649214589692080d2654309f48d0a3ad6fed2e410e43cfd6c1e8b836cb88e1d5514842e6496d94ff0f001232c04b4622ab9bce6c7f3924035c479580d24c7fcb987682a45fcd0db3875a920130d4e7f1f0d7cb60cd122f61681eeb122b1728c9ccf5813c38a4c2d9db5e27833e0bb58042d8ec3c1a4681dbf10bd0fe5fa8e2006f94c31a157632220010e623bfcb29c77d84a52fc63c7a996ecbaea778faf6b4e955dd16b69b0cf4019736f8b4431e682614b845c01d37a39204b504e37eb1662a367d31bf999da223eb7d845650c54ecebff7d487ae7bb8605f90ee93241c946d4d22aab8c756de6af526c152d7d82da548c1bb7319083954d000e1ae8d2a8e8d500e85a1d650ad319776a7a8d520b91e84e0ab27fcc203ef9ca205247b393b26677bddf9f315c7af741c2e83c0f00ea1d1c40c46c12af5126b68d03cd5b29a63b2d7f55a70a7fd0f21e1b921b0455bad8aee15d5a699aee8eb59dd6585e9c087be6cae5a23a423dde240855452d9becc0a8226812bda69df8228eabe40bea5f5d78a56251228c076639c82f69cfc76c508e84f3c8e9b2b503e91105e1b345d967b3e5004785ff8290e22279ecb8243bbb967824348776140c7eb6e1abe90d15007a1a4b58f70fd5316c2147d8ce52d24ddfceb62cc424016a38778f093b080879cb70b82a78ed954431010a7f6f8c83d12bfc209b5d2f13b09e5c71e265334dac23943270d520cedec4cdb051e42318cad9ddf98e362c0a17c0cc036d386f1965e5733a1ea60c3309895dd3dc11a0642130598d7227567d4f5e0245cd42677938d52a81377db3b7ced56297c26c7f46ad1902bb0be47c527ea6bbb2b9689d896cbad8328e30d74b442b7a585983f268696a91c55e80a68b9cac8771b7fbac5d9a8f8e4cc2ba15534ca16192659a9e24b002e8a9dcec08f8f2f742fc6ad6c1cc006bc246ef7c610592481e94f17fa324d1db4177703e4acc56a2271971d95868dd5e65846baebc8152d8131c18aa06214ad3c213c2af26084f32549c3a232d2cec4e305256cb69616cd9d52b17db44930678721223b83a83958192014bfb1497af26d118f609bd860cca3bd48d86c6b989dc689e44ad6346ef62e7915ea532fada6adebb854a7c50d1680fd268e8d29b89c9e38dca5e1e29904d3495426fbfa50aceaa67423a7578e415cdfe1908af33add89f0129b5d75f8b59265da77b9f865d79ca45f8c4738601265879840acea08abe053162c3e5591769d5c0fc474175569573a9454a44ce249bdb579c75f786af2da0a05084bb5962ef984668bc238cfc1591198328ca77ef6cdad8a373918a724c79525a3fe8a843255dc46eb761d5203bf0def2541218d61e5e1a16f4070ba9f9ad3d46e67eb87d89ece023c6b2e69f8ce9efa171af0dbb5c5c47e8810ea36c3c29ee9973f8ce5445292a7ffbbed26ea224a351d7130f784f6ba5d1de3f20dad8b29afa974d8aec2add6538785f086ec88f38ebeed57c37fa09197167bcbddef1b6489be2c98ba1ac1d60ebab0ef61626f6cde352a3ff52b950babc172c61910270519f7ef5846f99f2a38b178c2315b6c8a0c1a1e8a404feed14564d1841ddaa2414ca97cd334645ba1e7fc9ec76a8c8f88259319b867cce8ef03189d314de78707ce21d98d9d15e33f0b19d8b6cc1af77135ede996447d5347d511fb6d17dedba61c8700243fb86a12947dadb13c833523614f7affb3a815b322b24be6306cd59c400b6899e23ec12029f2853575a45d354de2b31024b0e339a43ace0238e97f4acf2f564421d33daef37b23cece1f6fb988d95ca1fa016b9d81fdef0ae9bf4e9a7f03646e2f330cb8157208dc888937f231e622c67aac055db10b6af403c812274b37b4c5d7163e3ada9376a1d673d2ea20e4d6cb687e0e793ec33b604ef303bfc3cabc4ffae4c92da9d1f302e1e38f8f67095075db49198413ca0411ed1c00bfb5fed7d6581889d82320c318920bec934268681bff21e9eef3fcad170966dc991095728a9ada6652817673e4b006dd9a617102b8aa84254089ce004bdc5e26952147a05638ea6d22246bbe93fceb7c5e2843c7d221d7c0d74af641f992ba165939ff9c6df032795b5745f2225b0d90c75b4cb500046e176a6bdf42a58cfcfa68589708ac0595834fc0f7802b3912e39a1158dbc17f3c9bac297e190401eb8d84e2099c8a0083fa0fbe47b1285fa995e92f76c0e185a58bafaee2ab946d7473784114749cd3fe335f2583d070bb306e61982c3cd51c05b4604532f4e83d74f5915af846e71f0ed63024f40bcfdea032f3a96560404bbbba510116cc1095e4adeb4982acbef1bd1ef2ca2b21dc9dc85e8bcecead3e1c4c52c3d34126acaf25c26f77829a5b20666efaa70c1d5549033a62ad5aef732f7ec50f0b337872970138931112d20412e04ec9114aefc8d5c236eaf1b75e38dac99849149f93d1b41843af403d9b3832f0ab2517f6db262f3d1db43dff945e3725cb2b185a2a27c6ee3e640d59b783a32c06c1dd9774b2c1dbed071d141cc54be8b25e17ed1317dcbd3d14c8b9747de46b702ad00b55da9a49474c5d1190b1333f9ec15e57705e8e7cb9ed0252e2ece4eab645bc94789c91764f5c621c2d85095be625526e7bd2fa7cda952555be893da624accd7745e0a9dfb808fa728540dd0b404ffbc42a3e42441cd92efd64b008150f7fd96d0055c51ccd1a905702671f6ede20551acf997fe60ec3ca5f2b4c5d8082de05470acb8ab931b0d3c0c1451d1c47156377bc0601245624c533f612fdbb6476d907ce2f6103ef883a4f8b62c1ac948e21af3e96be665a59780daba01e34924172dbd0c8c020ae7a11342c4b65361437f2baa8a638ba2b58a44f60788e9ee6b1960e969f78987e9a106034af5c9ebcc18379c086a5852ddf4e357aa59bac6d43e50b3c7545adfe14a56bb8bcca9412fd9b6a7ec8659f285790d689e0dd247eacad97a1c1de752ddc6a5357eab890f4a179b66754de2bc7d304219bb8314fc28390386cf89a986eb346258178fda40d3739b4106ccb461987d0bc3bbaeb833adc458b709fad45a5f49da02f40311ec745d634264da03a0faf3970e42d23f2c79031ad6ec24e879f84108cb9c5fe65b808ffd05058fed202cd765bd7aa33a4a62c176d0e783ea609fde892ea8d11a99764aacd7ef32e34e57ce6a71411c5b0027c94e64d0b2889a3faa16c3dde756ac6d77e075a94eb6744ddc89dbc27d9ef6f4ef9ea1c0f737677d446c0f761fbf5229269aea2191a534254770e9faf7290bdd15345999bb0038688804b749cd366a9e2404bb2817e1136ca93670e363f1cc5fcd1b7daa3c4bbf4815d52c0998ec4262b9388e838fb106dfeb9586dc8150077f4856f70d1a28e3393c555bf041694b8a4164aa25a001bd65dc43c3461e89fedd8f901ccaa24a0a4013dbab70366207358c18e3eae449db28dade7d0057ddf7372aee4e6aa2b2dcb18bcda1a0be5cdccd261b337f90d838f34df67c1e4fa1584302932262f55c906378b4ee36768acaf006abeea42e67fb8afcbcd01285ad8423161e9df6839d924a29c29816eeb1f3d71afa4bec701581cb24e3ebeca31b753d42e9283526e1ff2b6c12e05ea370e2b6a757770f715302659bfad5483d503736f442b162b5ba848ed36d3200e30ad5521747fc29082ccf731f84e5248ee96aaaeb71bb5369ac437f60a2eea8da9d0e1b000678b9dc0196462235c45215d3b2270a52a3a8c6e5dc9c1ae90e298dc0fa88be21ce4645c09c849fe9ee2502ce1a22faa51948cc9847047ed96ebec192ba7d10648aa06acb3f3c3a861733227a70d900874a7d82f29f09aa4b1107917218544e7bd3867f714e46bfee3b2ac898a95d219736b45270440fc956c287f311fc871508a5e62477c3dfeb03f6e8ac188e7faf5f4d9816508c8807c1c9ae2c27c907f7601826ce5f449b9eb2dea2f94c7ee34e696298e9b58012e25be332d14d18e1b3a13415e6caabe6c7f476abf24885d906ed3eeb1c130428f95bd2c6e41c4d8c49803cff1fb9ac4edafdd894ae9fe1bd62fa0c211c6a9e024f6d35717a6512461dc55417cbdeaedab1335f5548d1326b3d8b3758e0ffe4463abd7c8e489bec2fdf514c76b103ec51bb04b21c0b17291e9d2690a60ead027759ee4c1003750d6a1403fa3e6d5b09b88f5cf8fd7e0a8608787f51d6237fe6b03e01837e8d838c2f7ab54bff1d44b3cd08da59dd2362ebea8c52e94d95ca039ee2061751459f278b81eae0fa2afd18548ecf72fd18cd8dc57974939fcd725dc4c0c4d2a78596a8251c5d4dd729402bdc92b49f44721f68ac031abf3236620392cf93f08a2d404aa716ed5f8d051be16e978ee2ad2e95c78f14915470bddf0650eaceb73c5d94dc5fcb99a0b2dc05fb39d2261948e648f227fdfa5938a0f84890e5e276530609405770f2392cb7c2b667b737c93104e726ca20391e58d45ea7bd1c8406dcb2b7e49f24172a558127e671057ccd9d867c036190f6e2b9463ba4ce9fd1a398e9c1c7af7a1ad9c2b46a7a24b6b3e45819ef10ef12f8c00610361e302f434d5254592de4e989e2876bdfb52c54fa8681a3104ef23a11b0a2f4dff125f1ee2016a7a3676ffdcd3de23376d909d9c431664046fe4d29750d4425a1832616bd0bb9e6c1c05412ef881e4cab52408c596409aad1aeb9d58055019d35489dbc87a8ae90669c23bcc7a43b9de1d3b2a1a8cc283258b9c77e74a7a124425e912de6baebbf1efe6f6492513485d90fbcbed450510d2efd4366ec5ce06744b86b3701f314f6b200a251ee5b16c41d3b57c16248e350410be855948ef72276796c69a675f0d4e89a869d87054287fd6d7ae56327ab0cc31a1c4c004841bf478d25f970bd0d1c1ec83c72507632123da260abcfcac8b794b3c5ede116ed857ff6567c192185a7c8b7317af37c1eac776a51ab9be1ed30a58cd1e81a6ed168b73b58b950a066ae2a9c6003f191d2deb9909d4244f740fbc5271c224486c0e536a446d08f78f94c2faabb2914e6b98c3dc25aebcf77669f63ef165cc7639c99f5640a4da691e184c32beba2f4f5b09e852d377d55f6bc35a61a6f7b0aae65849effef9322e071fbedc210aa08c3a94021a29f9ce50fd5e4602d58eda69730255d42f1ec85e6cab57221517f7b39faa40848900de9c9ff23a43baf8631a18d8bb73506cf3f18a1be504dfc54d99fc034a25540aecdcfaeb54344f99b868f59bc59c89847cbd069e99d3935e6510f2e85c7290279e970e72d352029af1818857d9b80f6804ff23cf7b8549ccfb183091b6855414ee7e5595d3668a52d86612a2643f128d417595014a93b8be511848d13a21441fe45d4ac9ad09f1396ab0d05210817854c4d86991bae0f9328a2ec202a8ee95570f691521c90cc736a379b49a98333e7ffc15bf9df313053e7b93b0e10f8596a1d371a3a7a22db86bc4338ec1adc851b36a176aeb170e71b9719dc3b69394fc7c28aa3a020190c88c9320ca8c6bcc46efe4ba8cbad2852746a9439eb33a556f5837c82bfda22494ccbefd15467fddef0dab6db956c9b75dc1dd1a4842d50e13d3d4967c3f1e8791c94586e3f4c0892fba8e2afb32dd38d40e88dbcfe21d718ea2fe2fb5327dc2b780a307c09f379904f5451b712510716e50f0a70f21b02a36e6a47a287d39fb6ee0619c18c67b7a6ed18e8095e2c6f19980d0f183168d67daeefcf3b2a963dc178eb526b488af070105d1a4d9ca9c77db88180d151cdb7ab9637418cbd6b5317080d4fd168beab4475038d76f008851272117e53d04b6b6c1058f62ca2ddbc8979f35f118855c191c508ef0cb4d1a930a42d8756c92dbbc5308df750b205b846a3575671326cbcbc579c2e97ab69673108e176af4bcb7490f1639ead2bba4ece6a84f4e3403c39ae5ef8b5a3b393538d7ca98d3251c94ec69ea799348c352314952d40747fce5f3855ff038dc1203abfdbd64bda4fb5cf3e329c99a8f4867fb9163dfda3441e20702bd5b524c14847cfb88070e29e72b5b7e36cd0d10841d780d226d3bc982507cab5976a2838262cbfc748a73f86f3b6f1c793aa763aceeb8d0b3cd15869347dce6d7c71d98eabb83a71c96b460c8eeba323b05c21c10ff0ea133f6c892e6036dd42ee3ae2d17a0b9df85953f9626b6ab1406481791f708773d91a7b51bfaaa7ed8eae1fb46c617276cecc46719d37d3f75e1602ddd91b61389205f07b33730d296dc89855b9506906b3fba6967130ddb04e4075ec9c7daf478e2e88d5a0d38b258ee849d671dda0da4285a634ba41ab661f0a47f4119a10bde912eb795ed4a5728f3082a23cd358d9471f3cfea0bac79be6e504d76bb907a052c1939d405cb912ca3154fc16837d8cb065a98eaae39cba274cd0460e96fd0cbbe06c1ca1d42a0e98bdd599e2dd5f7b8741735eeb03ba66251ea23e971e97bd27c846b206a2cf9bf9d5ec760248ef58d0836050ab724ccc1c670cd1aabf5e3f4d30cf5769acf718381636500d7213a2fb1b96b07788f1ce0b35f25b4a9c2441e14ac8bbca6be8f365ae91cbaf24a5fdeffb47022dae8b84fa1df3f386fb3f17014a49c72c98b5ab58fc77c6c63342cbe8fd69c0f80a1c9e77dbf37e7406b61f2231ec095e45f2a6df3bd44b49320df42247a239d19e6126b377b427f10d8e52515c9e9df25a94fcbb3185ab1c7190712adb85cb9290c372a335295ec24f95d0b7fb04e7384b29166bd9df869c1d2c270c941d33a78cb79d950883f0a0b109f67d6f55c1f7599bcbf53e6b8c2ea950f7ff309dd8e16c4b7800eedd22bb28e9d2008db0332767fb9e7c7fe3fb9bb55469b3723780874b58ec14b4c9de1ce81f8c4a3f075a30a753cb0bbd04be2f255cf3098c00c81a4b71db2656c1d198f46810a529a94a796de3a5dcef2db67817d2a58322c7c6333a02891ef9a70180584deb43c328b8e897c9bfe0dd29401186086ed5d2f760b9de85d07719ec3a18691abd3a4207f0374e8df4373b56c82f87eae128bdcb2a41d26f6a0b72e903ff9ca6407b5f30116ddacd82194cdb51ff56f510ff3953510461974a35dad7a63bcad8919c8d31b06834a1ab7b8b19f20cced05bdb7049884b397fa935d67204cfff6173d9d286724b3211e69f9166472172f1faebba7e63c4ca75271664c9810970404bcd609e8a0e5e5dd0f316366ba3e1927bd2e8a546e125cc06e536e8d669699d2615eee6082471ac2dc99e5f7b5fb33d45f20f014247d0dd8929cb496e32dd4107b7a8a693e5e1766e82cb72aeaf056cf9e6c0c6988c6efe66b80851e68a8f1bb167c1aeaabf4571b96d5708e76c1174229cb8e9d4659da6a05883fc16daf497cf7295c82896757cda553da3dce900b91095aaa2f92c33ae79b3542ec4169dbba179e0b8ffc6de251a893fee6eddd51f45e3a8200d02bc894093b6a381adfddc9e4eb4b875260eb34e87863b6201c349a215120ceb37a73426ea754a8af2f2bbf0e86c24086758da79592c3acdc79b1420981684a00d0bc624fd4d9fcb5a61538aa1c0e8a0300a8e1ff852ed117653133a51b303b091ef6b0ff97982031987a99c59fac008fb5f0855a9b53c733204d408a16939822dbb936c0fab8b85fc1dae74b1ccb780481a5ca087bd220168b0ff28987e04a85350617b2f9bb2a5c85b35fb70251dfa0a87896d5563d4941082f31fadafcfab968a6fa3ab3daaeaab93702809e1235229b73f5c88221593e963b9d21309140114c41f38096ad4fd791a72df03e3ea9022fec736b7ac2b8a4e91dcf45127702c996f3013050256ab5ef988ff27e8deaa13e1f88873356c33d1a8eddb4df7cdb10c7d6bd65681a4756bd2e1502e927284a7112f29b78c171a03152550373e38d02c88c0189a7def05ef108f9540d96b8320957591cd0c0eb52962c224f3a2d105a94cfb2540c5c44c54b0b7e8bab7569a5df57e7eb251dcc3d6d9115d4bc8ff6d02f132bb022d90416365cb1169a8898361f26577b0449ea147fca29f761d45345681eb30265a15a61b5be1abb1213c7dbb58ae9895ddad5a3e1adca66aa3c797d3310c7f2849eaa1d00151d0501e0a5d13e5d090d3faa03c89507cbd94ec1a482780c47657c941e7871ff7e4c55191b2bc1a4b3a81c3b4e4688181e9f4aa9a1205c61d4366f81842da16b3c2e1c556e24e0714fd7d94e6f2bf971c91319e6377a87889583c027719c1f551f960e75a74f639504ed35adb928f1cbd613b9478de1784931291c48edf2b7e2c298995757cc9b2155bf9632f5eb05a6540bc3cae5a23eebbb78cc562974f3818fd437d1cabfb9bf164a0bba9c0be53a9ebe3a77c1d52f6507faaa2d63468b0d7ddc64cdbf5173e3bd9faf1a2b8321f18622bea43be5cc6b6c3148fa3f88af937a35d43045448d5956d832e47d8ce12c1206db00fc174769aa5c94d357782b09958b456a91c84c2e54723ea3ca27f26d3ff50796c4c5cb799f5f5a992dcf1a9403ab180239aa712dd854efcf6d3ce18156efc223a7418ac4a37efd6e430a24c1c439f5dbfbe20fedb60dc339998fd5cf23d92ea0457a8860815e459d416defc31e2c4cf353089413ac17c679ccd3bf858880baf94b722a19f76d555e01ae2303c3fb69d95595b81964d875fba8722bbf610b48a6b330b18a5b880e7fe23cc0da222ba83164627caf2621249d123abe97c4e03c8a5b896895ade2682539887b117d4e0f7af57024624b22630c96229abbb010222edffe3992de8f73cc712fee3a242a654128672bd64a24be15ff81c39dbc72dc5a1732a7f5877489737b2a171ad376c5fe8cf645b2924870eadad28de996e45dfe52493cc386b4cd4852c8e0ee4d7654234a978c9ac498783ecde9c90dd4765607795e73f551027096d16e8893fed4940ff3a42c5e97709b5ffffe543484524093bb1e48610cd4d0736a17183acc7a33999d3f459209a1ce13cbca7facb5fd6407e0fcd511ecdf0891de576d55c21d4ecb8930903222602b61f94f6a9c45df2379d2c6e4b1105fe983f962672fce3cfe43638ac0e91a1bec131c98c295252ec0c8ab2cb8837603a0b7599e1aaf81278e96aa65488bdceda5a142922880fd64418ad4b736581eea5e2381856e977fa8a4b0c5223093f0d119791065728bf1f512410c77636a990dbc773fa1134e7a3b261c25b17aa4e8affefed7f531ba7f8e10c29078dbfa7aaf9b7c6bf993c87af33049e8efdadd079088a34b979dd9971621d49838e609eb02035c178ce16396975c0f844f0943347c69fa53a7b5c8f9d086a830a2d68bea40ecfa6bdeb2cac56b2b6acab0343f9bf43c73fb910638f53a0f7495a3fbc5391f705ba758319be1c42c8ef28228604f01f3d08ce0cdb42c431e0c5c674d5a4e4cd7befb3b7c62cf428955b9553c5b0cadac39594a8822504a74489083bee233ccc69499978fc98abfceeab724bf4a0c8067e72823fdbffd25b90a8196d06193dc648fe760384dfe515bb6242af5250cd6be18fb8f1c716b98ab7925048c9361baa9c6321c8e43e236645f94c1575047df60777b8db1757887bae8a50076373216b7b8202852a61b86e1e7c1b1ed7f3886f0a4d3ca09ca19f7041db8d6356afc046c139d70d7479702815692c17acc2b630c34da0433ba868ce799e022cf9a2a547c534ab37cc014ac6fe4ac62312731b1e6452e580d06cebcb934ce0549e336763ac08de1f28f34f15496a41116426dad41508960f8f358cffca69c0e7f4436753afb2b03ae2c1aaa2b8702a41f66e92f4de596c66c40d69fe133d2dcccc19cf01f64b97228847ab27177312efd634ff6035bc8b48821e5de2db3e17cebad1cdc171968cb37fedeaef4e9dc87cd88216d90f15b01305b6315c123f3f8c0de6430c8fecda0dbd4c2049cce322322066e83c1421e2a1f8a1447b00a2c967be5d9e1336cc71c16e99e769842752bbeb9ecef19c86c89b227247b33bd44dbb177e2c68f4ba0e0df23e37e33ee712b0119b8195e84be12f03f3ba8333618f83e0679868da49a3d8f9c11f7e3a51820958831ece8b7d13011eaa6d33dbd2e3b874fad23994ab1aafde231f36b9abef5d96ce4639eacc52b7d57ebc25c6a10db044b393edfb699bec61bbce1ef72656c9767752a652f209b400d17d67662841e15091e21e5c94e0efa8e195a3c60051596679995a32db6404d5174db75f73dbc64c5c9a7e3b5949059e0731799b56c2bbc6d29c906b3881a2e93f841d5efedcca4906fc10196b436e3b5d9548c5d4a6c639d4fa461ff96abdd61d79af87bf3ec02f2ee83b98954022e5c327efdef55c3ee58442ade91d02da14a35594d7120462ec3ca773024e74c6f6a653b8bd57fa0ab7bdbb1b87fca66a435f33b9cf3d37066adf66180749da326af1a02165b3b65cc38a619b57c7c9da05ac12f066cf05d71de3ef6edad8ac53ec39e351c606b2569265cadf04069b1246c622ce91be26a9af440bc60e00f37f938095bb26355000b6ea24e4a3350dfb1ebeaa6020a432df056a4136c5de19994481317bee3011092a97c8b543915790d5969f0baf1306969c73d6e4302d6cb4d54c3ff7517c0600bba563eb34ba31e227c13dc11343323a3f56388edc6de205828ca97801c790709bc44adabd25938da239b19bfc56b2c0da1520a3ea73d2d627c6254eaaee5d682e190c5e62214fb4dde9005cbaeb219a5430a3d40581753352dcf118463bd1a29183e2ae20ca72a45a9eed57acd5b69a50a3b3ff6efc018a9c0af4347fba40e40754d7368da08728744db75b6dcf29ef722d5c04fe1f15764619cce983a303c58ffc4799fe7f723fe95a521332fb494e4cdf2499cec142822740330f2937c2d5c289a30b60e2e6eaa7954dc2426c09d996c5741d6a443ac1f07cecec2091a70d22f06535eb550117df72babb5992d42b571a8e5e3eac42249a385631abb874fbf83451953c129f1321092ef8845730239a0628d4b4d41d338fcf447a4f08fc31fe890ba560d6a4e2a5b294fa02cc4dd25d97d2faf047a9b6708ac397ccc780e01af1f4034f40ddbb7ed87947a058105ebca0462d3fd3da6513936160b45fc6b3e3ec66c1815e343e531f0e5cd08db71a443776f9135af264530fa62d3d6f3468071b863770ce06480b992b15d363f88ee0c254b275f7807bcc7527721fbabd8c369537d7265f9b3852b9bc6c552dd71afc141697e830fd75d31a1d6d980da18657bea1c49ac36f632f4e2a82ba76266de2dad7f417a7150b42185780e72ce1bac31e9b2f350a7cf31873574a15ba208ceb33cb37c667b49ec253c1cd25d87b5189fb177d7a655f58fd05ca8725af397ce0018de020e2acbe01ce058e8f7f32836bb982b655d77188cdfabfccf7b3e77cd14524ddf6801e2eadf88d7c4d28a0a1cb62db16c5269ca1f1efc743e637db8d03e504c425dddcc6c2c1a701eb753f342bc2210e191f53dafd61852f9b2481e973046eec0414cece6504db3240d72b9d73b2843f3eb4024d3053d28576fc1f95e45c86381e2d925cdc5eec853ca61213839eb2cab67341a6e922fcf7647a6e098f2f18afd6aa6ad42b5abf7abe4df826911fb3cde3731a005d7cc5fa9a4c0efa64d462b654a56213cf7d605a42efc44298707cf6bb1b6fe71e1873ebb06c2b51a453cb28602c4cbaf19f3dce4ff9012383019e47640e823677c88400d801785eec7cc773d82bb38ea73acabb939501f507e290ba71b5e636c1114a9d646487552022da341feb3abab9de224b93ae9573586ed787b041b630524b0c5e3c7f13298e374f13ae647dfa8ad4071a34d724fb2cf7557700892893b6a02ef3b453c4d22f10fc615f3d8906bed25b383e57939c543347c2a3afb7852a8702cb4ed819d3ae7700d1c20d7468856ddd6b5b2ae984bcebdd590e78c2f4ebcc0116319eaf5cc972ec8f9d23d6bc943a53338f5abdf634777a7f1e82978a0861e97e79360ddf36a80be2d4a7574450a923ceb2472e8df75e2c59792bf78ee74d037f6778927c32e2bef3d13158b38f17ee8c462b04420375226e27dfe458d209a7695e971cc5aa6b806b84e6f5eea8e3a4ffdae476a971c4fb1364b0e46d1d67addeb5feba547c5e7c3194683115902e1f51c04deaf4426e42c37f00098d1ec59b23ccb24e64b61d3178896193f851cb0563e16fef5000a03e1f861265c1776a88bf77d19c264884f201f872ce04fd2d973643a11fc6b01bfb090a07dd91e21b4c587bb6b3827c3b85f6f72de2449688a169ee8bec1e08c06487424b44f1f65356a26c05115c19f8f778119245ee044efdfd8d864f45b77577854b28bd73cf9a6a0edea9349ff92ff4194800cdbf16cfa569d28d5b6145d3cb299e124daa6ad26ef836537a9b2ea009415af1027dc5c3ea31235df05c867bf97278f3dd8ac25516a03e5b473abf858ac068babde81597f60895dcaf7c7fcf84945d610ca46894a51c38620912e16df008e943f98aa32cb5f8d0dce03329e59acf7b7c5bcc8d3778f7b1ac0ed30797906b216f083d7ff70d04f3758439a33144abd8a5f23965392922c845bc3b12bd9da813dd0c713fffd0fd9494cdf83b13e2591ee4c5033c52db13862142fb88ab609bf0b57e298a5ee4d4c05f2da523c40486ace264b4b89b521b57ca7f938ac060c6bf8fbd39438ec540c646240827271a2274324566d933095f4050912cf15b1411ced482305f9ef5b73eae48fa6acd93749e0abdaa8c7eb409f41c0f80a240ece4f309af6b8d640892129a6aae2a172642279d4dafe2ca835c90aff1517ebac5ff0a1762a1c9e1c4550a961cb26ec107944e93be188949c313df5f7fd84140f9ec7c312f90fe64d39449f3834516ba3ae556fee7b085a753ee4e916e0274512fc3823877d3497fd4c1dcc59e9b11a386e4437f2d6af24f11f4b1b7499f99ab19a2ad1a1c00d0eae5a2549f6958ecb659788c9d7c992dad124ffa3b26f5282f5af5bd18bd917fe98ac2762cc8a2e27c986c0dd76920ecd7cf4f8ee293265941ade7b1141856c806b8192ac74aa2c55c143f7598b98cca9ff48b58b1ac6a47a8cc3868cb17e4c177a931a3b1b6f5c7e4d006fc92b004aa49dbd171680c8522412fb1f426f09805a5a2cf6cccefc7b622de9fff165958c81dfc7f37950ddefcc310706809f89ffb586a3eb2c46ab2141a0335bd80f1a1d0e24062f4c98f88a4b0684052b3a869f10941ab233a318eaf66524d6fedb1687e655e5ad0a479789d7ff442acc22969e633b63469b6a33af65d7f494047e9721b60aa29ea1c0c0ec278920676f9c1dd972f75e9fd4c4d4daca9f358c4f63eda7caeff5dfd4d5eb4c093a62ecc3314b5cf2ae0ee877f2c2ccaad4972b3332c30ceef09b161b38aa33068ccbaf7c61163bd73bcb75e6a6c6da1e66f42c04720f259b2cebc27a46b84dd8325559cb55edd8fb40a535c319f402be75b186a576a20df2dc14aacbc53b6bbe229bad74872b317f151dee24af588c940e7ae571addba80e0b36de7cd7a3f708bbe23ad3ffea7ae1c18fe7ea889683c481bce6d8011821d00dfc0d4a8652a621e77243ff3d7b229fbf3081015c5f2f24216fa485466350169f469f4c0a538345c965b3a9784746fa42208fe18d88fa76a831360bdf4010118883482dd1636f8b26f58901e7a2ce2ec5c862271bf1d2e6ee867aea96ca822edb863bb58a8096843129a382e021ea6080914309cdda40fbed5ddad93a4280824ca9872c6978cadc80b4de64fb42c9876f7711883c26aa72f2e5a2801a4326a1d641544a5db22eef907aa4ca78d530cecfb64c6d82d9b2f4518aed5fb6a0e94ea6554e7a36910a66185e270c3f05caa963cfc6a205ee8ea2f9426c763305c7e4e2c0a07dc4b7754c46df7e58a990b9e006e1019831052c9dd27384cd6bd46286a1d07fb07a90ad0a9741ef29dde71ef7c8454f59c001fe0a337851c6af7352d97dc1e5af8f33aac4d83c4ed9c23e8337f7cecaeddd10100bcf45990973c574045aca839c328ec26c9b2b263cefc345664d71b9df0119de411629aac4f28dba10f55f34a1c51cbb2acef65a54768412cb7e276c5df2240e6e866b30e948e3127ea0f3decf0fe06540d6eb8b96839030d8f1213a8f7eefeab44123f41347268e9977e1d984d0a11b14fba1b5df66ca6019ec8e58e448a0caf30456d62e079bbaba2050b1a8e83a77c8191863ef12f41b2774b18bbaeaa70939603bb054f34fe4ca98e8e5a0758af9e2d1ad5eb98e61a69bc187b23f08dbfd920e467b5b91406fbe520e97118934bf034ec8cdae072005c87e0937730e08381edefdb1401f7e633e65f20dbacfe843415f143f43ad0ca2e61c93615a71835eaa579763927188ba26d45f87ca041909db4f6d35bdbd991859c8dec8f079cb5056c00b4194b4a786ef89c0b9a8a9f6bc62e88c588efd5b68eca6c94d4fa1f658c4f78372446cebc81dea7714b3683b2027959a3dc5369a05d310b969087d96e5a58c06a640bd90d15d1ba739aa7d632f14cb0f3599e8f8ea41659144095930139f852d009ee9f99a1398e75a1925403eff9eaeb2e93b7824e596a4336d4be5dd065ecd58db1b13668c06546023f646fdfa6af8b32291f7289753f8554aa54b9047bfea4796f48d0c00b3c62391beb6d5b3eb38feed8323550e1c7e1cae96d1f2655dfc6e27d18c6f56bea243084959cc59fc2a9dde15077f95763bf1475d6bb9c24ed24cdd14c2c2f48010151e8fede94b3283551917caf7f417acb28af26d213607739f7f8dda30bfae82f26c9249b8e560be165de6c22c0398e7e06f6d06ebc97a6aa7cf8869a20b2d1a7e613efcc798a8f85cd175e1d7f22c8cfafeebab8aae81557d48c6ead8c5bcdf350be1d44be0bd7c407a069a78023a337bc86b5a0c711f0506c336c0efb391f699d25372033c0a4dcd031e0d65b252e6b2906349c7c8a0ed6202b273b28d8bf9a01ae232ca4c6ec90bb739eaaf16262533d086482d2350bf1a86ba9c0242b44725059a42f00baa513b874319eee2d0152441c9bea1f193b163824044267331583210b9d997a486a88e8a3a7c0080bf8d91be774db099c6186094595cefe9d9523d24a8ab20b05998ddd6dfd9a99e09fc9032b65f534c5316320656d9c6f123a89fc8ffa419af34bd23f52fd0eae2631403a5de34eb3d000d74ac67b1e5db4ec7794df6972fe44a941cc3160392592c4cccadad4b61b44587408cfa985b5637fa2f12560f5c86fbed1e672d889481617712352b43a0ae23d4f1b305c990d2bfa23a71694c2e923e80c3e5bbe369d61a852d53870c0751ea94ea7d93d1f057218a01087e71cb255724340406cd39fef54b7d9a6f78cd696ec8ce8a3920677c0d5864d5d4113bdcb449358cdf418f2d7bf7d4f677a274b3c5b1d1a39019633842676b45c00b1669108ca365ce65a0cf1e238199f2b7141ac2dceed25cfd7c9fe7d4f343d2d5bfe5238e0a5b363475d641fcc6110db8f3ee4ab81cfca82cce965e6391119f63dd5f2378810b9bbb2a304f5f71e84559bcafed260c2659e4f7b483aa81fe4a8ffc106ff4e77d721774cd1951f7d89c2d3bea8f9c05ad2fca645043edda259d1977729f2b85696174ea34390c200aea64e9c64013b5e99d0844887a5f4c7024c66a96c55cc8739f81e8ef2990d4b1b70558572cf015911dae0088001aa2aeabeff084913825facbdda5e4a83b1ecde5aecffeb4eb702d3426f4caf497faf1028a4b7575988c28be41152556801a3c9bba5021d39ff69f23dd636006358a7e711a8454f4d1f91d23369d107475322bf4e2ce1b5be9f5654886e02da910dec1c316ff2388de5df6028832e4f88b28a505913ba416c479a6f5592fa8c2ab29d1dbbeff34999a681c79da93bf0a5297023543c63f5d0131621d1f54303a6f1c3cdef1fc2ea910a29e809497414cf338e080f00afc3a05f0347df35232ee201265d60acc1e7b951a0764ffbd91f1ff5a0eaaea636fd4b684999306e81c1536575d086a9e882547ddfac256d635c9bf9f045749ef46af1408ced7f30b343eb3ebb6575149addfc4821514ec8320a0578e7489fb31b15311c4d0dc38e4f9e4d48b14e72af1af75459bacf4ab48cc53b3e31fb9827c235461f3777f92bba707da03b4876b55084f6e65005c7a1681e5a7bc3f956de4fe88f18e24670f77712549b3c8dafa5fea42fd60b34a16341af486d94c189fde0840495ef6c6f0a8d410c434c1205933e47076235d59d2c751d8d7c7cc5e1bd4b36cb9348c7563363115aa89dc265ffa92b3a13cde54e6b6b16e0f1f5c62d70b5318a20659251d6b12d735af4531d921a70085328263d0871751d6c4374b99b68cabe440041f05fef6951d61ec834d9e8666d29ff8df0aad0984b3abb42563b93d006e96d760aca551f6e72f804bcc1afb43581ee92f69560d21942ff21ab2b804d94e30836039c0927e6422984d10c8f2bdc01b7b62a2e46addfdc739ad479d1c0bc0f12e44a54e606d150833c9f2436a6297205aede42280682f1e59f1bff5a5447c5d5f390ec03c1ae09233f8fbcc60e7da72f3b123c4cf949e4da45bece25e25728776e282a5698eb20db6c8842b869a600889200c04d814d8f4a2f765f32e3a078eaa041d46b44c6fc4d9c05e057a39f5667939d0e3202edbd38f7173c6535dae2457b7237d28120c9a49fabfe08cd8fe900bea270061500c2c866b078dcc2ed41ec980f1191f422f8d5aa512c9751203f1b1b41cdda1ebc770618dff07c224e44a409689983d93d25bd5e9045112eb718fd6a4500ec5e58e41dfa331269437bcaaa6a3adece1e2bc5bd8406fd2f10c541a90ff39d9a082af1d8df2758461850bf5a42b5cf17cf99fe83ac5a17f7e298fd24de79a9e3f56ed33f2ef1aac0ebeb2f1d4c3d97d02487192bb2d9096b63c4f8e52afce18a77243c698746f0bcbbdb846971213b9b7b3e5078e28367c8e751bbb0fb1969669afd0597e01b71a7941cabce5cee24431ba70dd66204d09c54190b4f2707608b136f34f4209337121e6eaaf86aef31157b214f3ecc3dfa433c5a912f4a21faeb8ff41332b19d2d694e0770ae2cd073f97c223e93bdabe75d7dc70573e8268fddfbf0540cc4af78d1b1de01d36c38e7eaacde92c828624255738d3c2cc47e2c104b930c2e30b0a30ec918fe61056573a5368f033cb0ba5d44c1968ed3d02af28851ac2c5c886e34a1d26f93ac1589ea5effa7509258bf5f491a9a721fdc926b4b5f044ea661ff6d86bb7b2f885953981c4edb30efcbf116757681b1d3103cb4f2e27cbf28f7b665d33b7433109ea3a430947f0dad80542fddea0cb45f5264be9e8fcacc95ed6423fd7bbc267b1d674abc94ed7290a802b786a80e7bb7979f09f0779d1e9afac9dd915b552ad631573f0d505c092e6a771445b2a6816d55a75c5714a8a93044a01027bb43b2c3c00764dd903356c862c7263687fd1979286cd1145a0abb7d8c9c73324a2b9fe0d44eed80d6f4871882afa3f19b04347fdf1f828d4fc7c095674c6749457a8daeaefed9cd20d4474770b7ec89bb1296d8af2ef2f69babf91e6cb2a665cce33d06f7cc4773f17e052f186d1d3b067ce886c3ebd15a0156c237ab4f8b88abfdc475d95f1d21b6f70b881af41870d7558668a429f27023b4425b7ff534e92a64715fc9d0f4f412df35c32c9177171af92e0c8c1d6854ef060d0fcd7444d1c29a6e35cc051b4b42c4d0d1187b1def17871f20a1f4a55492dd78374287ddc63a0573845b81f1f855cae92d63c12125d710aa9a57f030251ce504ee55c7a05016d2dd2324c107c525037cff19573134b3f2832e5be16923236aa70d1107fc215dc662e597429357f11f70544868726128be323a9e92ab5b762c533940be66cebad064605a7e6bd7d51ef52f3d3203db84ca781b9c37ebcea626a2ea9fb52ca2af0a753b960040a9d5fa8d875c7718c5861e89651ddddb46df7c182049c77688c7fe5458b44c04019f7ed2987a5c22e241ff22b5f7556caac6c2d0c626fba2c83334473c16ec40564af985d436f77e607e78cae3c79f23b73acb9173787882129e1d1dac1e7fa749a7c6098a451aeb56078573d61a8f73eedc6f1cef1279b1b17bb385ce0d2039d4d757c18e295e623a290e5c32478c1a97a0d99282f1ae37e0e2e6718ce91bf73bbf9291a45ac1daca07fadc5279df730cab495566fb88cde96ef1b358d1813efdaf480d97fc526a9fb6d2140348ed08a127b822a1a6e7b1df24e57fbd90155e02e789341f9848826dafd21e170852de82adf7364b46007b4cbfa180311e9f68743c8da4cd8b68fce8b6c5e2120a9f92c46da1250ca884d1f14646c705a12566f011b77e4faa6b30847febacc37dae3b6123ac97ff6a6e5b9e8e56092b7ca1ff5f9b5b679f5f7c6fcd7d7b5c3d739a62b1e4b8b2a986b3077edb8929f44040629c120ee56ead49f2e84aace335f1e5014ebd4bf0a76d9ea036f791dc5f25d566aef5c99522d850f975741038c457836501468d140131873428b5acaa3566e218f031c4ca7140490a761f6fb331194f40ec5dcaa66a88418784e940f9cffd515b7c91392785b7f67c5751c24a5eba29887b21bb154ef13a9eb794d1e26722560a212c92c44dfd9c28448d665671b88278737a4a5af040668a7eb63f75f5a97fd742723c45f23e5085428018165b571d83f885be2e997b8b63cc37d3b543c4ee29b87a6164dbd8c011b1956f70faf39ea9b5f88bcf32f830424e11373204cbde39c131654cbec4ebeeb2d1596b26cdae1b0028a16aaa41f7c96f2fcebdfa7c6c8851230195d1d5eb9fce1f9e630f1a28a0db116995afa3779e493725eb65db682c9f53e75741b31081f644303fad56015c86a9e23feedd845a3bae21ab49f50cac0c760936e619d23d75de8e9c6149e6c236ed836155f79c1c93a5738e4166bd7e008d68daad1682fd1b64b419e67b1d43b13c9111e0f0b63217381dd8c2df158ac16a4b4b1da5a0fe4354122d190329c377ac95b99abab3979b61b8511086a47683c983c02f2aabc15a4190bbd14fe2f0f2a50d8dde345a97b328ce455e7f273e9aad4d613a608ae80dd2b034e1882760bdd557e74999381e4a9556f622369d36aa60daeb080f5938d1bc78e2fcfb17c1ddfb915f7520cd8a6ba136be3ec4d96153121afd19a3cc3a788d8b5e0696cb6390712a7900fa49f730129f3f389ded83f28fded8ebae96020c123e4e7218e95fcd95b7de68296356f15bed2d1164a3304fe291d66df16e85ff3288f0145de95ea9e0040a2f9824da35ab8b343037ed8bbfd7653a65e403f90c4402d31b49b04844af6021550087266ae36db3be39cd4a71649d55a5ccb38f7aa0ef67bf795378481d85de28ea3a495304ea945e96e87418ff8c1daaaf432ef1fb17a0ab77dc7b8a71d7bbe2333aadf47dbbfc4161432426731cac9225e3c15999acd06ced71a76d641100b0cc44a22e76aad379daee336e5483c81a69e0b70e44fac1c30590e6d7e94054d721936e0e27efb796b4eae0c2a5a02375f5e8e33c7374f41ae42f5ab2128ff01169888204154e14937ee27accfcc4fd25a6ef9cd2324523743d99bcf7d48aabc44d854f5363e00092f21d784d949cfe6c361bc38d6a381418b0bd19bb774228893c375e60af5bfce81a09fbb2dee033e09f90ebb7511d9129df4eeb2a67e28d4b5c6d54dac55fcb538ffd4774da109c4d6e851c7fb5f8d1c82b13e75f616979bf748c1e708bce0a5488132deb554c47b8f893e4297e32c505e89010679dae123c2234855c2c2d161c6b48968fe908021dba0ae787cf59fc99bff053ae2ea4a5c1d3707ba4e0cd370084f1080d6e66cf1de27f5de5ff0604a8218fc7f563a457db47914882277fe24f68c2f32fcf4f484453b6e81af4a7c402026cd3de31b4c145b0579e7f8cf427881e650adae558f3257be3e937cc8625d0716201ffc1c1a0b495a35753bafd93af4f7d3063aeb6ce3a6e89ae04b6210fb18221c13735dce8256793e205b6456c1825b738e21eb69153333c45742da170125a0894d4435d97aa4ba52dc636f7f21f8ef653ce782f76d153466aab8891c4d42aceaf24d3e1946c9765ce5782c26441723beb09500fbb568eada64d11d88d0314e71feca5c4516b11d20ff25ea205c1c2da0a53f81e43408852086987ca057945e13be4abb484486808ac04cbd3a6f0809bb3403902d04e701f38445e1468ac3776b39260ac524ec77b434b0900888b17ea6ebda859a4fa6a1dde8ec0f333dfb865c708689c0084c30f11a1c491fbf0512365394b43fc7410b90313a5881f5d1e4feb9298beae67d062431cc8358af30d759e60a03aa1ca084e54f9fc90775fdebe2f0f62a946b7cc573d3679aaa7e35b8d3d13e32a55fb7a490edd14b3c544aca3e30fce0d01a8f418af7559f3015e66f6ed035496451aa8857553bfc617b548ecc170cd12925e79bbe66512b0fd7ecaeb29fd4367a71878dbf379558694ead845c7a9304e90d63cb2c16e30537bf9d1fbb062877330071507865302266dd19d61338b5f60d223f3eeb75556fe055e7a2f87f4f46dc9ff78415131e6b0810a6e64968e15210ca1a757cda761337ce13059d5ba8aeac1e7e5bfbf0f550b66303790df5235da4513392836a932a5b00d40654e91ac052dd970e3a40bbcba74af5a4e8eed2cd882eb8f743733a7944e51aff72e55bba6332a3384d2fa820c6b97fcd7a70b8af9fd19bb04d7e0ae8e067431b46753550021b57bc18710f5c040fd8ceca40ad6cd3856ca620fb7829eecdb75d7cdd8dc566c2b4f5b1b0a6690d31b257906251b7c012bfefdaf508aed28c9ead6debd406299b2d1dc092e23474943f76c3d6c8e032cce841f4e00dd6648b670f28981ca71e76ddc69aceaf2581d7caaded551a01c869d51f12b8d2234ef533a1ab21a9dbfd568a8bcd66e27bbd4266c4827239ad729aa6c9343dd94d2537e34680ea630f2ad2ca12bda3972389cc7139026b85a40f7069181cf9175be29219a89f23aaa0bb871442eecf0ae530a35cae2d239efb25b0ec16990324dc4c452c4987f1ad38b283fe28f8dc05a80f7da42c467b484aee1b6d3f6300e95bf2d28592fa64da9c6556d753117254e03aee98db5856c55017b53943757f8bad6caa4ba0dc5ffb4f4bee9fd9c1396d7dee9c3ffcde7fb383039ce1cd11b011c4caae69b7539517164287ee61c0a896e330754a9715185d56b305b496fef7123d99cd6b9110ff8cb8d59a230a1d0ba5b4614be3b9a156184571c2eba2457ab077b56754da3e135f821702546d9e657ffad161b6b6bd9707e0a263db4d00b727110a172b70f459ddf28393957e0d0d79ecfcb6ac5e3641577459c0544c21c56c9d4203e49d41b1d25b74734f8ab842eaa073bbd6b8dd348f6fc87e64173e6b2cbf3a84e8221b48d23cab53eceb4ed21f42548be63db069b990c949322f4bd268de2e7ea2a1f78a5e314a20588387f3d505d587f49c4b58fc25704b1903f5c6278a2133a4a8b3f53b6ab63f65f27674d1483b7deee4d0f2cafd260ea96e18193868e7f454b33645c63719b2186c6fd2b197b04dfe27445472f9ba9c454623d1edfc37bae9d00feb9ac128ba919e2560c0e5efa5edf636be1de3a8c062faf96d1b562d336c1049f72c63dbf88e6df1e4cfe50a60fc996a289115cb84f4566340ff20f651a65168adbe22804bb8a3841cd3d641c0c83f19736af609bba90106caf019247735817e53ea0b4604bcc8a20cd2f92150728f8036415cd6ebd1d3790d9700868f3902f33a310de8dac07e77099e39320bc48fba5f84e96104c0788421958f63649a3670a6d7847c6bb87a4a4fb9b4047785f40196ab1af7faa4f6f339c023dbdee01fa3dc85844a34a2ff05d32d075a6d55dc9c77a4226a68c7413401f1a37f2404e8ec874de6c1d6cd7cca1e0e8b3f4de58c610ee1b41a3ccd20c4725c653cd6f72c95ca7884fabdc3dc69336bccde68a43a1709e4de49de29a0fe564157561096eb3ea64fb9c3f7468275b2bf5c5a2d735cadac5653ebe831ff0ded738fecc16adc89a9bcc5d492f33710190c855670efa7c72194bc43d9fede7625cc5631e8fd6b320d4b61ea67646296cc7c3c4fe15c24e176ac8c94503dd25b454060af971197231a19cf4756fd171d47078b6dd8ec14f1fd74a2119e18fca83a61b647021da5f1aa75d721a40b64cbd70bc03060c8cdb8c6d5831b6619ef7e8ee7ebfdeb27a8a5f4d265b8ca645d98a17f0dd3806bfd83cd2f5864e1278e0ec25a967d0feb9fe2004aa25c7b821bac3aae005b2105dd39e7235f94e6ec9ee951067ff8af0f2fd0f4182b97858de4dde661f1b853c3679084c45bbada04fba575b9d4064358efb75d8965663eb60aa69266f2018445414e1d6879828955b76290e59e1283dcc812e06855f3f0374862741a340a0604240fab08ffa12a7a14dc324d5553d7486d560fcc0aa1b070bdd1b523fff5549a423b504ddfc0e616e4924830b9dfdffca9f0ba4b681dea13e617caa5c14a3d47d7d196829cc1d05c13389d6cf4c899a6b29ba629bf4909bec796d79bf068d1039897be9ec9ac6ce429cf33d235f946381845140e0707d04ab4a497aec277f51ea6286f5b68fdc34894656aa1f77bf74a3ab9f67c206d228ed99482668dce4c7a60a48a1f5479123c380adf0f94d46ea33203cd73ba0746be8fb95d028177475c9bcfb718a13583f6ba2cd9e614233d28979bcfa72a80a97f787ec4e034cd87cd03b03a99bdeb3ddacd160a732047804836e230fca5aae389bbf4e0a171cf6dbbcb8b65f0659af63456ee5b98522652abf29abec1dd7675dbdc614f5d574cd031efe8ba03f32861e6c0dc4db61a97c6f7e82097336443cde315a1e9fadc38b242a12874ce106efb2f7d2af5eb85395b0695fbe328d9ec104edfe78da66fc764fd29f505c567ffe8f57194dfe659501a91451cdbd880c61e2c0d045e6f438727605625b608fcc7801c3efed23d6d80a2fab875966d9d5114ffbd97922122454f7cbc73a3cdfef438f02072d72d42a9197b4b2a0b401adcb8e37f512cd55bad17bd4ea99776e65e96c74bbf3df9a2af673e6ac1939b0acc2adf6aea30333beef826d71423cf764a286218a6d15d5d84a20e85dbe4d841f5a9bcd7b9640f7ae977475fc97798f13541bedc289c81b204302232f8893ceb8a0916b8c6adcecf1921c20a970f029a0215ee4ddcaaa0927551f006efbbfb182505673bf2d145d2309a6916d5b3e135e028d446a9b257a90ba20c0ff6250161b63225e8846ca36d3a2c54d5cadd38a3b56bbfc45300d43e9c9d7ec7d4d4d82126ff99766c90bf739fabf1d68d5e9b5f4a347408d926cf13dc54bee1316aedd55c2e24ce9cb0479580ab19d95674db13c6101711830abcf9d5d742a2af6e08f1721ef66f5505509fcc5132322335c1deeabec59fd90c1662c0a46d6c1fdfb4cddd879f165ae9332529d8a915888b258b8d70314aae6e00f443e0766f2b2f370fc8ca41516134f16972ab59f926d84d4c30530888413bcc71f1a5ff891c543931e6280dab0dc9ec4bae03c48f05b9fcccccfaab65df695583c0a5906284deeddbeed1808a5e95c05929a48ecc7352a1f55ad284376610aae9d853d7b82135fa4c2159992cd479713d6f5ac8b726d2a2abf9c49c9c3ceec2ffb0c66944a1cf9b0cbd1b5e690e5d1955711bb2777c5b5505ba6501a6166613c2b60004d087ce25a6875ccf8fbba9ff9710dc19b35173cf2338c9fa1e580b332dcce5eabaabcfff89690c034f27325a6d615c49ed783ab6970a779b6026537799aebfed7ca0dc0bf92ae8f37576f341ea0504326858f35daccc9cf939bd63c15fb14b81a3ebda2645a852124bbc3742c0e80ab5f8667b8ae47b5a0fd27204ff1991730c38835ddf15ede2f1cc7ec588254ffd8e0bc1e5b042cf33d2e6403c0503a393448f310f0dbb1af744e484e2fed2427c0ecd63196ab16913f93d822bf39934a8bc2d8ff2762d10a03ad271f19a16994b287d33b3bde4cc7f2e25be49bc14fd53f2f8cc536d05755a3913a65b944c9b717ad6a7b0ecadcccbe79d38081ccd82bb711e9e6c622eaf04f22a159ae122537b0671b2368894a85731226f0eb3c2a440b5420e826d633649b2b62bf311a810119faea1df85596d4ae88cf51c9a6a7d80655b75f0056dcc4cfa09816b88dd7ac600d8c0589479fa48451d94f57d9302f23652b360198c4ece16021c0c741963d45af6f1445787b9e5f4e4981c88d836dec4485de12429f70c65e44b69e0b814f16feee1af0780a423e1e6274221b229b63c8495b13a1abb7252e3f686c2ebf246e3d6f437c4bade3520465121255c3e5d6ff8ff01c4482e21047576d50a6df11ccafc0f151c6dd835a142a985d2204a724a12aa6b94330ca3b1eb29f254255e1f96b4c2f56c992094aba5a4fbff29c28e4cb574897a115a5a0bc05377bc3dc08ba5c15bdade0f024daabf4ad221abb9dd7be364f4a42d5d121b4de25966afa28e3d9b63cf3d8dbfb062160746383a2319de4e5a5650da0f903a57445e190887220ce246255e2cc8ad914be37cccc73e2d237527d96e536758a10d6c620e4382c20dc84645ed445e7f6c1d858f2e78f808eb7d9c2007635372b9f7531a7539988224b3555c8b0cd2e3b89e9582e1175e4a759ac6cea31da8102f58e37c0fc4ecd2d720ad5fa094d26078d981786f782d92aa961547985f8889562e41666a76b7f9ffde99c3f64646d815abcec9e5effdb4586af9f0a514c40a56366c684e140f7e0e8f52e49cab843f99ce197343110564e28cea272333c81e6c6d63806c6749735f2b88fb3102c2315bd6f54b3c4c8b4c21dfbe31683e9562256cb333dd7d0effbd1c9171398706380c363b22b9d42994a2cbe286ec43bbeabdefc62deb2c3391d273c8f3481909413ef59de92382db0b8be38e959e65bcce090804be94cd576be5fd8f989bfa3ffb3a6af14855e60ef140fee398db350f6ae77e318cc7b8fee02c186c91ca2e053198c8964f45f460d51e88b9bfc51bcfb550b4bd4b52097e942004665592c7999e0e8bd5e231d85e12f276ddfe5e15e48836288613caa0effb31c3792b316b0624966bab8bdb4d8290b56338903baf05be69155daafe53d5d90b0d3fdc9b9a7c0f627491948d0203510f0c5d86a26e32fd96d86d8fc764faeaaa76403ac708d279dcde3a5ded4ae04b3b92607dc9cf96b2e591b75f93ff09c520979e4b3d47349f6bbd463b2f6329ffcb4af11ffd6a9e6abf569faad654d1ec437c2f0b462eca50503df72055b2478caa762d54a9b78dd5c1366b60ce38e23ca01e00fbd94c60f746087f5072c118a30e9916e0318b460d0a2a72b834ebcc5d9f31d6190ddd5a78ea91121be5c76a8b5adfcb005a260e2368c94d6d6f4368067cbb5bc987841b9bf29dd98a15c2b8d113a9cfa64aac4c0b3a40e3506c02bd63c322612a668760b5a68a010a724990fbfd4f3407d13a139e1f8da0a7b1546781370d38179df651ac030f8cc7a8e6fdbcc660f3797c67cdef05af0567853f4a54bf6654fa4ea849699926a16ba1411dd3b964189a49da51b917bd3d4485488ce90882535b54c293f05bb375dd754b3171f8b580d9d98507b86a881633d45c35ec52be927bbb735491fb8224bbabe62b90a97dda67d631f61de1613660971583c6c17874ee31be391382e699380579fd169beeef9296f8336cf6cb9232a5b4fefcf94fa7d4ac7d0fa338798c57104a0957ad2507cccefb98a55c136a6004342d0c6a3e258320e2071a7c5bbe7f235b260e660a4413dba8471db4e670b0d60d06a0851deea0d312aad8ac773ea6c99b06bd645695c8e71b31c485f48234454e8f976c1899fab015a8f80de219ceefc427c67d0e265838d96a7d2031c9c15d94bcc3aedb287fd008b157f1955a622277e5571e577111370e8107d720e3a7e9a88f8ce14b76093277bb2eeae5ab6bc334b09a852e7793e4b0467abea5c74916304559d1f5bb227ef23ebe0dc1982d7bd0b3ca16cd42a8702c6f9064f86422a941df61d0b43e59ba5f6d430d4c9cfc7e87729b1b3bd73b11e655dba9903dc0d90585cd0516c75e174d3355335816fc027843ae84dd6f5f3c47a36313da9dbfe66a91dce5b77f4231aaf0cc25bb192b456bda1766be36909f7b798bf398e515e8a5eab87a7edbb00df9f4e0cbfae386958b2543c4018a0b21d8e6da3cc26e8116d3671be1d15ea2aad7e9f9639960d029b1a488c5bb506f33f2dbf57b2b820f94363d06f7add6bfd72964d10f7564475c811777eab838af66c97f4d5b8047781bc068b8348b63ee74ccec577fc5a8625c20c9f367cc909d56270dc64a0a2342fc7a2b6afe968225dde79e0059e8e9a039d833af45127f00bd87a6a43286415796e6cbf160ae1d71d1dcce66f1f1237b70fef7e0437f90591019f2fe33cc05704d6dd12b060bb39fe94deadb5dbe6557c6e3acc5a8d7baa8e75d3791845052d75ee7f257c2b9b6905d0c142c5c3b93d7ff03a80beb7e781eff8385ee7c4dbc1dd91a103bf834220ebd1ab5308055ef6556ecd5c078c66e69b1d1ff6aa32d717571d521ff0f7ed6837408830b0bcde836a54888d1ef33d98c7dfd1f51a1421286d6d72d3613544cee773bfe9cd94268728c21cfedca7c9d709c0dfd726364793915bf98df38752826820c1ae661316a9014952924ae6ba7c556cc59c0431cc1854f3d697d6e9d154d2813902a80daa2dc9e406db1f634a23b0b4bd358b6138f3a6549fe2aef1f377425a97d68fd326da3d96954e6b02d0e5ea30e849f62dacd0aab02a620ddbc2a74b4bb9271a6c4419facf336470ae1e99967e4cb1082c49478f08ad9362ca275b926e3cdd39546a3c5d083f73a8834055d9061160a60e958c9fa976a65bbad430f447f4e052b3830ee4d45cb06446894b69a8151cbaceb14a45db8ce269652b412ff0fd6d467d74100714b222b293952ea1a215b312a65dabc886f8e04c05036fee680a8bec9dc9df12dbb8a1c91ac342044a3358b816b6987b9c2a6608f81ffe530b0cdd45f0b16c57f733a11d3c6ea7a8f35c609ac4550db67d54ddc99d00029fc9e3998c5d921e4ea091d63cbd89380fd1028c36a1da33a8da2688f38f7f3874685084eb3828595cc2e047a024252e7e10c5834655eb8d565fc74eaeb307ea93499b2581b546fbcbb39694b5bda9a1df5e89729c7c697b2066542d4aaed0d1b64069762e72efa07dec16afde997c31d15b629fd54456dcccc7bbb305afbfe0909a16be327808407559f4b9e7b295855ad20b5ee247214222e82afdf5e8ab3d5a85072b023ccd6c428adfbe2b1a0d3ab523a595f1ee21d2b256dc9086ed3f4bb6a55a22a233a281c4b37b0a2dc4a69029f22fd06d4d01cf2efbd6d8f6e18909c9fee36e10979f6a321a9a551e5568a1f274518d98fbf23a5d9380f4b17ce9df72fc9b30364c79515a29e6d55628dc61dea27cd0eb08ac76a8ac4633abd09243fd7f67ea12f8c0d0fb22a2be358cd3cc3fc1d7c489319b04880069dca31f7530759a2c7f2d8fa8e6a94deaf68ecff14084b0c13f222b11bbe7413016765084e4be66de1056c328ba1d3aab542d69e41c6fe68d455697befeea6080139aecef260618a6aa334830b5a4ed343ae6176802735ae4a5dd333365c80725edfcd1417f90e81e8539d60a9ccb921695851a8f39cc8d802dd3e6be4ed94d0b94eb0adf82338f4e25476ec88c79f5a9ffbe7081bba3340442fd0c84a2e4c20c9d82c99e2d8e2fc4ffea0f486656491161a804d3c3274c63bec8c4e6cfe087fe9ba82da9e3cfad8c3e44d66f341d95fbcae9144390495ba5f69d02f1ea56534ee0b0c65dd43c435cf054e38436f28ae9d9979f158999df182f2d5d1d5ebbdef92fa53d5667a2c2b38b2440d158e12eb8b49922eccab690ef599e2f5ac184e56ea09b1e001f2b3a378695725d30b59c6eac3d3d9c614b9b6a8d75b4c5fa9699170660c7cede8ee399062ffeb11b65b823986b237a1a9a5ac94946295dcf91229c6d40f2391fd8c82be84e9c7cc3b821dfe2c49a92266b5798061d71ea87fa83be2f8dfeef258e56c711083a8de09945f96e1c835aa66321f57aa8ee8bc62bef9750cb0473438ae654404d8e4feca0c7f2745ff1b990f0caa95acde74e9fa97cbd5c18c7bb3433b0dd8085a1fa9acc25ef9577c718a86e68bbf93355f28172826b7f7c3e34f961775e55d77a87a18739c595d20872688e48055ccc20ca2a6f416b23b905f8c7c7da50cab99e45de57672ab6d368ccdf48ef926c111fda8048d78575679aed4ed02ce5b86ef88c8edc85a16634cea5318a2ed6df0d133e0815efda3f6296179efffe7a1017d4a3dd6834c2e3628e3fa6d63257bf59da3ffe00fd18b79ec2ca49ce9ba9c257627d7f5d2378618ec84c0b60e7a8a2076246c305bd46b0de2a56b195190fafa72f3fc15ca036edde998da53a04ce89958f034d02886bbca351178af229c55bb7a1f75ed7cacf6f3455c7031d858b1d9ea801096b3be019c426ba95b659c6215b0a3bf91e443640bb3fa048903fcc0c051a43820f5d0f8fef174fce95c781ca86d5d3d9d9895993bf1e31a0171ad110004634cfdbef5a08870dabde9c3f8fcea66016b2ea1c349db6323ea7318a60d3bd46a3677e5f1d32bea76ce4526f4b0b4677a997a64a2c18ea8464abaa568a0e66d3c83acb6aeef4185ed109fc8f6726be7676cec3634b13067f16abfec4bd4db87748bdfcadb85e741d6b391a94146cbdc88c80a36c29ae10f8d06c912195ece7d8b040473da1bc296970028ca91fcb1bbd617bb7f22d9c8b208942d7d13fee797647ba1c72a5ae5f9984fd7fe265fcfcf30fc96878ed92e4a67e3545a10cd7cb1e8763efae5517d53bb08fa162360ec81862c2b2df31bea70fbaf04c23ba8a6a626edf8575f7cbf30e5bd16798caf6db720ca424dbef04ace5908d034c2e743477ad6e1c99d46902bd0b2b482fd1615f5b9996162bfc9d1b75e01d7d68babfda707521bb8d8171f32711222ba78eb17f50e2795a673cf53e2602254b3cd48fd9490ee0aadc83eca52d17b7cfd7649fe113e70043d4cfe08c1e6bd674ae5f58ac025746c7489ced59926d4f2648fb41ef6f2cd0eaaaba9df20d162d0ee081947d37cce620dca345d737a6a322d25f34129245e8b97a333078ab99279b3a732fe51169efc30513ed9711455dcd4830987baf225067cd9dd7b2471224f72d700b34395989a6f0e75c147df0993ae9ed53a3ecaf660eb4cd8decf44173a6e1680adc9b88e4d36d981e173452c0d2c10c1a9ec592a4b4b1e45e4e2f3e7234a232f47f19dc211c01d33954914aa5b379be6c5877f5dd3d527aa789c48d8567efe90e16218be8260bcbdef0c561a9bca79c71faf7c7d745c3df9ae55ef154f393597a87c5e5c5093aab339cf29fdb504a5442f8a3c24949cd3d8ea67e2a5999a99d5f4feb5d79be10f15f5db56f3d59931939d7abc3f613184c566fb10c4691f748b07f4a175b72932e282a09e9b9d2bc66f66371ed090d46ff4a9ba164f459db298207988e7a14bf15488a002ab1a78d33c4f959f357d83d4b7583ee603973c7bb38f3032c298ca5d552330065d3dc18cde03a8c05c26717970a30bf47519374022e7b4cb82423222c9a84c69f4c53b6b5e06f95e37c21e68b9eebd1d297aad95de6e893c264db07bc545f8494c3eccfdebec5873f54a1895a15329477fce8eb066824d059f73330623e381b264653a45ee442f830838d7cb091e2f4b91fdeb41877eaca1af46276c65589bbbb392ebac7c9713e257ffa0fa2ab1de77f1ab50c8521f0088be758425888e470c68517152b1501db34cc6530fd2ae923b8e8afc07801574caf5fcaa117720d147de703cc56c2d0fa544fb6d8db4b41f2de54b3da484b4fa0bfd8f8c347fbf7e6c4b6ebc2aa7f1a640a8e0b9b883402959bfad20ca12cebba882d4e2d9e9b3776f549769a9b54bc27fb61b1e8fb541eb0e38cbba344924ea40884aacbfaa67dfc578b91d3e7901c80d3c3ae07ed9b857e92bce37732de6ca8305ba067407654f635649c35aa48381c75caf3daa77daed583b2e68f4cb26b910c652c32d880f51408739bbf836b62f859d5e626050d4827e89d098c4966120792ffdf66a61a0227c98c113c5465cec4aeeaf685aed286dfa26ec2d055384fac0accc3c82c619cc2fd72dea0b4240dea6d82d5bdbf39e1c797a6f7052aea45185b10af2843f0784922a0ff9612877fba1a459484bd649d11afe3d844d68e681b2b003053515d78032ba5a0de6a16ce1b630407be1819ef43f1ea302795fafae97fbb7a2953c6f00238b887640c76bda03c6ec2c56914194c2e3b8aac736eb312845ec73c9d0856b0f97579279a2b8521ab31a421464be389041adfbc39789abce3eb73e105314f6c774e16124a2d62aa42b51f1d5d55c6174d4a397a28ee90660b5d3385a00d2fc3c163afffe3a6d8dab193d74e3f84f554f70a0785d2ff07be23d94444e3bc8b859e8c6d760aac6fa29bb0340193dc2c781fe724faeb169f7daa03f21393fbe3a9fc02aec5f12a2a2166d6a94675685157516bf401d9bb66d94bf307316acbc5200828a97e7ab4772c915d6f5044be3c520dbff956ca1738b0689ac40a12422f1997e256618645940166b7cf83ff27cf5f4677cf2e1b90db2049c30613fd4979ed55eb8e167f91f5ad818663b3991e30ac9ebcb5b20d872b099b5c281e8ebb5f5df40c0e5dcca3ca44172b05e6f1036f839d95155a2730853d623872fae94dab0be310d10957a8d3b4085e2c935d6d0f0e8a4942e3dabba7446ae7f6563c464cf68be5e402383192068bfb53b996f1e3a1c10b73d5a172e011825277999cff07f6ae1ea1771f5e5e5370b621ba9d078ffb617b34cedf38c306f6850de9fdb8027d7220cfaa11a91e54f6e5b4a8867177f73bf6bd5760d9d52e1c6b3658dc65df08a073bfbac1226a0e31a83d57e1b3a4d52be6eed2ee866d1d265447369358dd22e1997a827f7ec5d3cbfdcef5f81b6051cd14fcdb293afad0288e22113bd29924f7728a513244f5bddd337ea9f90fc591d0214f864ee547e80393b47c4256d454b4b90f1ee77610acea68df8a0eaf252236d5149e09a543edfbf6e9ccbf6e16872899bada2b56cfef9ca17a62209b2319a844987bb6a519056b9587d437efa26d760547fb89270da91e97645cd69bc929c9bb0257d95abfa6393b189e7046864b1b67deeb4eaa5bda1986fae143d5878435eb045ade32d9fb63e27ffc23238465095916fff18fd6d16b3a07c015f33e6d6b8e623045fab19175ee115702c177d835fa84f2a23218ed2cf1002c8407dba714d202bcb1cf84e8d7f5b5187b174f789b1c084b6f5fa50cfe8ff3c8e7d340f990491e1b98581a1e488a4ba257a58a997768ca2acb3ecd00c8308bd41803259449b4a7ac2609ae3f5d954d6dd56791af5f55a8ebab186337d8b792339f750ec11a9997dfa5bf4c92f056c3b51708e1da5d5b0499f07929ee7456cb41369ed32994d149a56fac511d6f90200eaa43d62f73ee35973da695c5651c40061e8c93003bf3ce4cbba1325c30d72b1676021bae7a247197fde5b5345ebaea4b26c61d85a8e8dec7fe8e56dfa8c5725e509ace4151f911d6da0c59a39a552f54a0ffeaf2022eb0f44899992287a051e488c4ee5801de41ab810c7ba61a4275b79ca3d47e09a6020b721e2804b529e55c8840244b2d5d607a5ecbd9640852978d1039c21dea2b86964b300322679bc27fa476010b54d73a23a3559f66276396fd6c29887c3a17337d936297537e4ee395252b3cf55c39a4b1f7e200f1f202884558f93f8cabe41d9627aa22df9628ea3c9621016d84e981abea357192f0902544d7b4d52f55d2c0a58a06ad58dde25f6719abafca6e54dc3cc47c03491853fe1800a7158701aa5f848811f3ae5827c6c1eee5dc5f823fe608a902a3b55660664fbf0d4edb2409311e73ebebf0ae288ed3e883cdd106900868f28c75b572de986780419d6b94e515b11fd5665ce5697f039eb33f589978add160f9a2ffaf048be01f4ed05df74f267fd1feee0b3ee69777f130707d8c0290204d4ec6d2e8f4cd98af60566644e7604a6a1708ec8f1a8dc3e1e77686b07f4ae1c20ac59b3a5f32ce05d9ee59e7ab19cc8acc90dc4e6589b2c01db601a1fd02db719a55445488a88dc99a858111bb6323f424f9a52eb29cc2aa910be3add45b96e5d89f5e2a893cf1a8f3c6d070ff2ec7ba29e53539646909b344ca30cbfb2c28e96e1eda3b79d56e8cec0f46d502529741d021fe054522abba480dd89311ec1cbc868ded5dbea56a0fa848256d99c25bb05e28608d97aef8421bc7957c5b81d1fc7b1e88d7937a19d82b48363a3df8876a0eeb3599fe8c59df81e0cb2752657040068464c6238858b0f3cc82f1be0de6e7f6cb65cd92ffb3bb90c6e806fe3ac2e95b84008ebd05ae3278c8b2af75b34c47ae0b7827d00303fca060b29afe2064417b943e0d16fc3fa376a49359a892b2d558fd1af616fec8950d0ea8968d5bbaf9e3002a1def1d9c04c9c0c40f4bcedfe27f4e088ca67e4efd9a319f2d2afe994a18e6e55e8f676e8ac117d962651e7b5cb4874dc4ba842303b042a35055c9e71e2b7d3c201510d0fe87ca84a365888fe56b660dc2e886a83afc4d16c88f546f85d03792dbd0f0e0a6595afe4785a7d33eb8dd83fc38a7ec2c1412e88a4251fcce38edf4a657221ccd2c4f937df29dc91eb6fad066645b5f80a97feafcebc852ce37eecd70ecf901649f5d8708a7ee2d6380c05c102a77e588781ab19b7ff964a542bf3acc5528648303637d4c050e908f42ac308434b0f4618576b1c006b7c3298765d5470ccb8595aa3c36a959f95a615222e885f60b26a444d7e412c73f48ccc7f5c04601bb280542005cf9fb645013ebd930eafc060e75f3e33d9c0068958fcdcc1175e551e7cb0849805726aa80580de6a524f3de76bd551ae748512d312c8a560107475650f319192c1f6fc2de8f1a6e3d6bd38889e164f92cb9b8d65931793776bd3d8bbe1de10600c3b2dc5bd8a8ec9219e1b6a6dd231d8382d771af0f536412090f1ae81f45d98311a69087eed44e941d86def74f3c318c5cc148641b451ecdc3d99dfb728defa026cc2d4774a90ee27f8be690da84c80ba0879495eedbe1adf7447b0d8b7de1096b6e736236e13aae9910d0a46e5e8b2381ef50ecbee7c47b128401395d43fca632781516b7a0a909cf3a3216c72b6d8b562512ed014748b729ad62535dd5eb5ceed193ed8b6feb1a8d80fa4d5a21219cd0d5630abf0a9f6742a35463c24943426645d9a13da5fd9115e265685f4dd77bb53f3ff71f4e3f0dabe41c505a33ed5d6ed8f574dc4f1fe3d5247762577c472092a352483b01e6c550801befe58179804b2dbcc6c14c0549e4561cf8a70edcc8e32b9423e66a0cadf320ab4a5c706047f7ba2c105b2139edfef44a01db68346f086debfe912b22db066eba3001e3c0d9db655927dabfd4ccb16f865f6c97010dd81476c1299d9a9ba65394dfe7c27b929f0ca6d759f620d78995b4af131b575b1ad8f10aed1c041375baae0be833d06f579ff33efe013613f6f0478100c4e6a5f902118f16f885708f5e99cd36f206bc09520a08b2ac36cc13c0d55c401b02416d0fc166a4a985b054425caaa08d0cab40705ca2e8861c75bdb596ea939ebbb7c469a744a4535cba02a5ca2a40233d150ba66e13996d0609398fcacdf30430e3fb87916161ea193440fbe9ae29865f13ff0473b533cc60116cb98ed029258825ab8852cd94ac5fe084ab34d42aff92f20b1379172629b070b56a45a86ea4cf7eed7a0d650921d99add627ff2aebe26e3e7b64534b345171564962febfcd0c4a937dc3c58efbd2bc6f72551b1d28126a303863cc6965e1bc0804fb4544213c9e95301fcb29680189fc592619eeff16334fded3fa930cd9c995033ac72fd255c7eb3c6d3b79a86e91726d9c43f0ba5d91d78a5171271d0820619a60def7d69fc678be453a5f8b7d2657851251b39198e5d1597fcd0ae52dc35dff0da965573ad4dcdff852a0b8d161fd585f8b6108be5370ef6db4e6dc9ca6ae441211898b3f0bfa15389cd74acf1edfd3597ed9a87128cd617d8fcf2da8c0777c2cce39ab4d5809c2d456682cb7c66c20fe285cbe2c4b3f2be5b2d985ea425d8bdc30877b3f5ed7605e0b6f9a3fa445c47ed07689cf4cce835dde52f793ddc908f0cdd5b498a48f9fb0dfbdabf987ec2fc3919871433e04a727a6c43b091c1a7b667be25db86afb800db2fac2ba4d159702abe0c257832d70d8173b036acde29ff7f3d3acd057ac0f8de481bf12fc935922473f03461f70d378c2b809a13326697a3a9e0d211a0bc3684516a90e1a3535c15b934b9b9418b6a30cea740cb5a4b60c909c4536d3da31bd1269c0300b47ce46260167955389c80e21c90961c83d6dade04aca6858899c91f124f792dcf412a89840a23064c5a498a429e8aa4cea5bdc3fb42c49883a3f9bce2541608f32f10eb7eb3c780f3b0d6f82ad184a9d14d6560f32e0f1c4f9fbfefdac719ff8870e5404e8ef32af63c164fd94fd0fdc8a7111c3709201c32e5c7e93b37db899624083bf05e3902b2545e932f13ef10d406e258d2b48dfe7ce48c2b81fef026082e4388a222352b24f80dc7a6f6e4bc009a20880892f9e39653848a8526ad31b0914d7cdec0dc1b9a441134be9d741f7a96fec4601536965d635c64520a42521af047ccdcef708a69ce1758ba33945860efe6dd3b982232278fa2ede97fc07d0fe37a4732bd2b4fda192dc6569a8338038e32c11e58832f934c8561a305065aa5d16200a1e68eb6cb23df220ef5155e9a7bab49d50d11504b5989c9e8d934b1f653301f937e894339f684184e6eb6a25b7af9612586dd4adc14c9213e3d71bec9546161ceffc782b84a5277cbd11c2bdb115c62a2e2c6897b643287c85c1e4c17460b7a33f29349bfa55a1fb96cb13b083a700f6a7d3d9028f6d2895d42691336fad5d2ca445a9f5941da889ed8cbd9ba3ddabe66cc7a2a15a3ca983adc9634371f4f768b32092e14ee5e6014309ff67cef36aa9c93e50f9639813047cf0133e3cebdacd84a724b9d45c0e6be6fe735fae116e88cad448c55f0db705c2c8c0500178374db41ecef75743e14dbd28bac1d87e6d5b58122ee66e124ec493259ccf9ed7cea957d9028b1c8cbba49a45987bcc1d1d357ae14a235025e6c6bf2bd442bf19d84cad4aefc1d3898ae078e6a1da4678ebd6120e2880172cbdd92dddb37ace11d756a4454800d0c14e275a02cb714d2e748930223f77ef60bb706f06e83191e303d0854ccd2c45feaf606c6645d8568b8dc4ae2d687d003e069fd8a5f9c87efccd1839b3a7ffc7bbf8161478e51c0d6e83e6462c4cf195af55c21846a4710cc05395f7028b4d38fd7f8a22099927eb46529e3cf57ea6a9f8953158f545f6037646aecaacb8ca5170d1288c2f4a532a85b244c76292d1ae5734e782007af87d457ad2d4d5b3bc3b4962f4706aba5e8317ae4cf6b7bbec8606755cd0eb05dd1bfa6a42786455456bb4ae9d66409de52f53a18ef97bf531ad0aec0b7ef7cdd6dd9fde7793a2e541ca7f64bf16f622111dd8ff1cd5be6a9266b42edd7565e0ee1d7f57da7e538cf5dc429b8b4bbf3e8f376a40dee9eddeca345e0606eec182166d23b7db3cc6f9a27cdaf59246ea251db5dad22462d26cc0faabcfce4dc75f10d3154ab102e747cf45c2a383ad3dad35502cd44d07e98ddc37284a83c8db15936faef21bde07a73e0cbee67ba207120782849f33ba508f022969df9e36f0a9ec7366d330b28640aba8f9d5ee2abcfbbb08bec7f87b56850a42533b214e7c7d714df5a04f864edccd3f01a1002c529d9bd07af518a827fc2b5e64a0720a5632be9e94b6e1d19c4fa468495066121335d7378cb5e9f579b2ffe73210593b9f4e6a1e3f236e75c816ec49afdc6b121bf1b685dec341f49ccd96c525fdb61befe929af6838e9f4222c634596f697edf39feab4ca4d7a4b6a6d18764f827c54f72a785316f2424199bc1803e89f4bb1d6f9e58320ec151aeb40ed17253b60902e8139b67f3e75c2244b520e25c0c7d8532e8179c90a79a952c681610dc42df4f6b68206c7afe59d73b63aa1cda69496a6fbce53fda53e7f59d082a087d2bbf67e3516813dc7f3dc61555aa0ce1d50caaee2d111241821571ca22ef8c64e627556f50ca864a44c55ef290599b0796c1d394a6c2ee570af95355894e5480365fc550998b73ceeb595a4fd67f6cf34417b81ddc02e20fe09a36e9decded3e8e2479d20f6eb1576234bdcde1ed4a1930172b257de88a4bc8e3e950a41a680ce3c379a01c877c0f2aa5a065599c7c27d694355b94d82befe46cb21220dea865e11bf35817878b80046b6232dbce0a03cd214ee8f0024f311a8bc6536fb3ea5bc2dbc1dbae0becf213a700ca894d05142fc94c5daf5b0ac3b24dc1e7777cad76b53e0c94cf64fb9cad9967527b7a85f3f280e90023c6910228d0a10ffbe6eb2416a41c603645199fb6a539ede67df08554ffca0bee737c7452ae86290a2db0702f1cb9a4f674194b9c3c9031b6d299948216ace29bfcd2c592282a3a382f217b7c823d5503ee383fce2dd9e8b8b0a5c04c6c97a14968033096108fb23cf8d299d896687b6b3cb27ffa11290676401677970d954b78684b205ed71978b61e69c60ca8c762bcd2ba49ca9f41693aa6c55bfb315f924c9fd822458e61f1693be75e1707fb2829607b4468760301268bda45bc9f3aa3ebc2b722144361f0bd559b378df421842404f33ff8eb1fc6d807b55814bd78bf68566bfaaf2ffb00f4db161142a93df734517309b1929e99a88de739483a4fa2802f417561d0ae64cb78da47b79b48b7c2f6d8ee3f44ffd6080f6d1b3a9acfc952b02e0d40b5c65bf346a2c806f19b1a41f70bee186b133223a6b37fb633e5ec5b0c1bb1e39f4f938f5c61132bee13bde6d981137dbc4f60f8391214f888d16ec59bc1fe5e2a2a6a57e3c48fb71d3aed248c63a3118cc6a66ee609a34b0d5a92b195f6a134e51db4841074e82e5ebc46e13253291a845dad32db64935813e7c09c46fbb09cbe53a5822ef90ae93ee13d2197bbfd5648f1c2ff45c6ce84e0bcd269bb09129ffbbe0da064a8064e604df1baa519eeabe2d63930ff30736e4b3c0aea5fd3edbb5bc703a8f50d7eac2c2e6c3892563114c7019a2b5516a706743d15eaf2388c2cf14c7e6f684efcbe5b91af044fc0de7cac4c96ccc65b82559e1b2036e7bc9582e0e32d249c62b12d0d211d18664436b7965bb65b6475a2e71211a0a6677365dc22be0eb9fee2ecc89248dc0a429c6e99f9a83b582529b79b8bb91eec08aad6cf40cd305a09dfdb28ca00c05f5e8a10ae1b0c96c28af2e2fd5c2987e404ac06ff7b9703a732ee50495d94c5b203dd78ea274f78bf416cbf0f3866d64359a6fcbea5a949b4d7a3688bf10884fb85f9fe1b0f88906f0c327d699ae625789b72e9b8469d980833db127de24dbeb6d07a22b699120033224189170cff29a2438bd84eb873d01ce1daa4575b79c68c44da8b2416e95898f396aba5db22ab9922c4dc4115cfd10a2e8294c76b4ff149d3844eefc8c63b88ee510471cf01146ff09ebdc24feee7e9a653d9658988bed28bf88da448c3e2e4bd5176f3e3f04b68ed5658a92b227685eff527260f2fb8386a502ecf979f2265a3edc6602a274a827334ca3f87c1193008e01b116779ed647b96db15091234d3e9dfbec81d31399edcc45525ce9ea53e34690ac130be06f255ccad200f718f8fc2393e44265a1b677e15c8703672529e1f4a0c5bfb2080f8a4939195e83c6026c051d34b1ac774700965a98a1250860faa80ca8b288ba3f3d09ef3e8aa5237c1f1261b9bb6caa23fba82f7805e6482c92f875d6b4ab9e6c59cf2b675f116ea5ff13e41ba3baab95e54db80f45ec4573a9434dccab7c059d6cda92b402bc58de5fc82e4ba25447de179d20934dfb384eb136dcef4e297bc9c2d88c7b6d586cf5af4b4da86ac22f2cc3a0eda18423c7f0cf8d3e60af93df44bc60c1801fa28e22af29d84391594a07059d5cdeb1e5ec483f2f8293613ba0b31639d3c89b4aebb2e7bedfc1866ed41f36c682552b3d329f662c8d3ecb38f98b268cf26f5f85b257afd139521e3a06f3f04205f57c7d5c0252021f06bfa5c2b13199794cf4ae8ef572d88496aff28ebc0e99ce45d1a3b37d2c50cfe66d4228363f0c21fb1ba5e4c3c1818696e58e60dc7f76c272c74b1bbe671a3a6acf56288a7de892a5d4ab4a1ae1f3d13beb446db2a15a63cb3c5f7dec06bd8f37d5d3a292986c7f8d7331ec48f840f2707ea2eedd79ba73053a2788632df6b88e5182ca132ad295e95cbcb2c4157868d4fe885b57a612c3c3685fedc19bdc8daf52d53bb4072e393ea520f7427d7416eaa7810b29ab40d53da5dde5fd2ce09a332fb169533cc0ab3d64600856f44eeb1617f66bece489421ba4c72776d0c7d29ceeaad55b341d69e40351c266dea99caa835a5c86e6d075d64f040d2dada7eb5431e38ce6861be8ca0e1eaad0bc023b7af6dea4c072c3507aa2bc5e099f975808ecd30f2a58784ee5fb1db9585e906493d32a50e892341c068a1fe0589534f91e85165e4aa344a9969e2cc9c27d4427c0429cbc39a05a184b72b078b628d2070f5cafe6cf174d6f9a5a83aff2519a6293128082819f7dc4bb934587fb9323ad33709e1077a7478729c34a2428cd2ca7bef6f5affcd25fd081cf46b0447b4f2474cceb2c7087166298f1aa32cf893ce461762f3ea0da1e454af0c1c9f2ecb8462e0753262db7a08adccf7f99b7c89bc3c21565bef2a46426adb7096c784d7db11d75c4851b546d3773c6cedf33fe9cef52323a5f6c9df3a03f501789aebdd839bb5dc1287cfe7f157fc2c169e60d30f757c9165fd2b40c22e8d6924e75f95e163f95d8e620758733f8f4ab6262459902d107cbaaa4eea47abd8c1119461a737c18bfc6feebcc640ec7170d5508517df0783f3f1bd4979f71e5da41e4618e65c64c428f3eec29b82142044889de4eed96c93c27a80b419aa6d2533c89cd1bf1bc5d72a12eace21e748a0f6755b4603148a823eeb71ed3f0f021d8b48f47998c58a9bbd800301a4cd842f0a06630a31c7c77d4c3d3f2ec9e83024f0f7983e035db1b7e78c3a1640bd3f371dab4d761841bb739411f3d1c0c008c2356a8edaa00f36c07db070a3fd2329f5d9cd03ffc621f8d2769a092177a6c82780156903a946a2cee23be9091ff3d126eb53b695fd85ad9ed4da1682a2e46f41295531ea278b1c6d335cd3e5a86b27d8df6649811a95faae37ebc518ca84e6e00686ff0ff350ddff2bd898f54709948739105ed92b2dd8523d000a94869f8a8d243b77ca387f2ac1cc76d306440db87a8e2ab3f5882772329cb9f6e523a281aa6e855a6bead402ceaf2424cfce10d411a887c14c6a17f3e973958f1b60eb8107ba4d1f9e6e27fcd09e73ec4466dd6d76a589800a0e5e7af1971187473ffbfebd574e4b96df5644cebe0199512b32252f9bdc49c7bd68bd4bfeced76f17a1843eed947ba4668582f0bea3289361161dfdb4517790a333cc51f0abc589ccfa5c12e3b55e56a14c656812a567d8351d02e4e9fcbf752c4949ffca37c21f276e36db23c6f3cce641fbba36e81de078a83529063f53044583c0a8ce99b260eeb5337aa828f2819e0d5d96bfd164be801c43fdda2bda90126d4d70d6510c2931149ba0bf666215c903b030bf15fa104e5c0ab6ff75e374a41fc0ef15ecf177335af03f0449b19b0c0f3e87ce4a44f63f3eb8da172259f9e9edb718e4dad6e8c7ca778bc99c03f46ab8f5ccd69c188a8c1e29de12ace67eb4101316273b2c4415f37d07db7f10f172948fd1d7216380ff8c6a27a6c5b0b021a5eafc49dee02862706ebe1fd32eebc762f64a2006227d332901055a3d67aefa013c4656e4b37905e41bca4a31a32bb360b7168f3e525de1cc7eb419cb18a6808b51096f5745705822d0b53b1e4e94dd123362122366a68815a30b709c368e7f742d7c30d4d095a9b7cb58573106a4d3aaf14e96eb211db7fcd99551cbafe1214e073b446c659fd0cc53325b24201e7fac7c07711c5a69fa05fb8c8c01b8c871a03d5951aede6feb512c1ac4d98c94c9e3591597a2a0daa5c7735943c2d45a7064c5f1b61a214a3608842ce6bfe1470d8c766dc60eef037ba765d91f33915793cdd36caf4972fbb1d711d8b289478158d2457e33b1e515ad145f04bdfd2a416a9adb93c98a41408b0983d87468e319eb7791f25cb8bbaa647380f6296ca7cd5e31a2f485e3d9dfede5e2cb491ed34224932c4ab72a067f9117b9668cdc475a5fa0a4db505cd76f4fece09c30f1ed2b5401d9e37fab5ebb9f243d1fc1f4baa12c17e79ffa45cddd238599ec3111b8f58d4553102e8ea89c0e319d666f4ee638058dc048fbd78ad42da403b3a5696d11a3c6d690e0b875761fe65e0a1d9ff8d0df2e54e8f77fb145bb7f03f6ec0952a85f7303c37d88e15155eb5743f095abc554145d146c253bad27b019a2489b87b37edb59dbb51f7e838c088970a8104a718c537ae8c8f48843d5719eeff03f54a010e9575ffdc78ba1e4fc9b51983b25293097f5c1ad4c1613e0b759463c41b346a07edbc62b95a9ad00889c256f40962ae1de6f4a8254b0dd4f8ddabb2221678d200e65ef3d30bb2728f0a033565366aff334c1ba282c0fbc07fb9b3e56e93f617052a10d20aebd03c0905e3e8184cba678f215fc13ca9d91f36695175b2b6e877aa6605bcf7a4340e007e8f1d4f65cb0faa2375410ba7801c74d3aca04c1b3cf055b22a3abc9e1cd90b78792e84d6752dd2bfdfb6cc6ee92c2c8027e2c110a336832c62ce11803483cf26bea9c0dff47ee57677060d589407774bf023cbbdc761152c0f30387a2d160767edab7c6447cdab1b6fa3a83e94e27e59fd6f2006ac7d4f3e96b01b78b4d09b9b807d3174e06e3e46887ef6b58d03885ed125bff4670d5707b9c27daec40ae48bbec137889af297dae3f737d12579aa8b6e5777bddecc0a67bae64b828649b716cefdedefc4ca963af3e07f1196c248aa2d543c2eae3164287457128acfd89c9381f625fddbdde972d98c8b66c50644ead802577a8925588b8792f9edacc6d8618fdae68d9334a54ef5f567bd31b577755b4bbf646c8858faa0b273784c77eb1ced62ea73a6ad0a6ea9223a63660d5dfeb30dc910d7bd5adfccd28fca17e9ed2488a00fe57a9cfa2a669b38b89287259e9054c385e9a5154ffdd994acb71feebf38f2626cb3a453445451399f6276258998fdcb05ada9ffb6cd1cd6e5d0fcd26a09599d7551e09e8a22496b408d0c96411b0d0b2b9acc4ddd1f2890ddcbf5b038f71ec772f4fe5b7423e31b564ad5d6d5fbe12f11f5449c3d5beb83c92a2daba3141effaaaea6ba655eca5583815929b85d405d928b4384f8fe996967be01f5ea07e9faea62f97c7ff5ed12cca635e1f7731ad177fcdfe56a5997728141e5d3227d0b4629ef07191d74722dd427c8fd5e7344db1cbda265bdeac9d4aed916616c1bfc6e15ef7365c4221650a4fcf835a6687ce1424fef4c8c9b347eca90731bc9a9c94cf42508af6662c7bbe0134d2579414baf4a888a537e17a3c9d8a1756c067ee29345a63197f9aa03feaf9fa3e6361dcefd18f64e9c01b227f37f6cc29cc060f4b361c21efbbdf3f2b8d3cfddf110cc621c582bbbf4527c7d6c23489e9ea2ccf5bbc078e5e5a20dfaebce3b087d567d12f07ea61c8ee6fb24a0a3b993fcc7ca3d923e6f19e76a9d2bd3d2593bdc71e85626f359612d96d49a73a7aad91e2387e35e01a271ee3a2b6ae62bd566fea1f063e5df009fdf993ae4009edf074118882d9d72ed4076854596d955b36935f81b65e65fe3762608e538b403c2e9df18a30cb5cf38985c6b60d7428452b351d5a050573a9c1aa86f4c401b0d734f9669525e89151c87f6fa2f0a1a0ca4ff852ead4a90a3a7478d5cbcd485de4e979c9694336e47586406783cf85b45ffaf25c528d2c780a66a089ced31b76c6c3251d23fc2b9aafd2b21d7cc5492bea15f185fca4bbe0481daf9211c200260ca5d5adde46ff921a2b90d37bf8b36c8ca333cdd9559b315edd888e3cb3592f3120bd7e88a8522fd210b8dcd7033ce1ac98906c8834dfca13d4c7a2d220cf20e7f261f97dedfec100649d2da8dd5f9c5a44ca3ead9b2a9caf5b28f2675c0410120d712c7fbc04be58011448f076bbc1b08a5dba61a1c5d4d234bf7ab8db7f8bbbfda18d404036f24298930657484b2ded7bc8c273abe34e4aff454be343226d6599e355b75c8f455a63b771ae69c2f687a8317b3ef8d4d0f0d9b260cd32b5f06c55797b6114ea53375e5a8dede67594f95981d000525a6aef8f7b044160736564b503e098995987d12ee9b60f9ece88b855fe2286b5d21582c56fd6877bf3f23740c97e662c5082ef4817eb49400d5ad5d323c553898046addf7a5accdb7688d0971e2b229347ac94d368e21601d6fb1d964ce48e7663bc69770b66c2d87b62b4d4eb43ab17c96352bd9a4e4d2bc528a08fcc166b7b25593779af7b7db978afc7af004070965e3d6a6b000fa84db953888feeee7617b3397aa8e54f4485bade3fa728d22803ccb76f3e94fe43e061748307e9e28b3ac7d6481a9c3165ed31ad46f3538eb8b09ed7f3ce986758c76c1026e777a347609c93a4e46c684d8f0ac59e6b32c406bdcdf58b979032440abca0b8be7f00f50f95ee863a1e692cb6f3a98d43a7c09e721e8f6e3d564a2e54d82f07af9ddbfbf510a91e05164d435988e4f230304fea62f3be0c1a17ccf653b8121b62679c9668675419146ec6a02027a4513c56c21338363d7f365f86094ed7d5f68612bbef720820263b1308f1936d045389ac8e177123539c3c2190b28a5f722c3178135f7b57d371013dadeadf9ea5b9661d67df0d9ed75b61d1f5eba46960c74412e6cc29c332e574cdd1b99650c90b403c3e9939d573660b6cefe70073ceeeff44b8c0231067bbe64bf53e3f25e999a3e6685c154ca11c2015c6b3b4efa1a5af8cc953f265992befce717356a9672563c9bd21921cd5e42ebdf36000dc7b363788c5a12911bdc37b6e67e790abc5fb68194bba0efb006e491f5ba1624a5395e867d3f56c23b425ad4d4b06bff336c4ba33a49a1c7fca57bc6463f06a09c3474a80d411ca2d74c938606d404a23a74d55eee7f081c7d918ba520e14e6b283c3cc267ba143c593491ff68d28771926f4b410e8bf3fabed078d76d97df44f5a5e3d4dd0ca6c2fab0ad6976b082b6d0b35702cf68007031d2cef4abc92fafa0997618cbf6925f1f997b49662dda32267a1230e32d4dea299b78bda14616011ec841485d0bc7e3bfeb1205fa481a24d575dcc307131c86c3b5038ec68cc3a5a0f21e77feb09dd235e14432e76dbc3e2c6d7c5067700c2c3fcca604dcac840650bd30991d5179a0ad4e6daecee7ad0b53ff1b67a5eb68de4eedd88b36aae09ecd672d9cb7ed8adc80d44d1b63bbb4e9610dcb46343c746aefcb648587811a16092485ffb83bbe05d1d945456f1d88acc974ec50794006cb624a7e765bc9b2eb12c6c3e30b30b7ac5e7b24393c4fadb83ec3859e2968849631d73877372925fffd963b870223354a5b82c9e1a51ba368b0aa7dbe684ff0b3f77f2bb1204c2afce4e170c7be0415bfca05cdd910a60aee39eb5763b093089a77c99d5dc6d058282b45ec76b27c97b9b99dabf85babacb03a1b74e24484d3acc441c7cd92a5ca49f7bcee472a451425d40e1db4e757915b702aecfa9c90b613fc0648c21454c0b4f3da2dae9cb1f3615e5416a5c2aa994ffd1a86e77a09cb10fd5105dd234075f33e73948bbafcb339a6877be254e8d9a13c7614cac0eebd2b0614cf2a165f5163f13b5e4ab4c1fdeb2bdcf45800e82361dd132b329a80634344246d600bb770c144d4b080e4ff73b846632816662436300d37e31164c50a72f5b8e4135fa71357e3746b37f00e08ce9022bfad40c4dc7dd19b748e16550dd2fa6dfa398de8ae79f117a855adb097f15e7081f8392c47a5cd17b160057bf09bd730d9c30ed5bb0ad834c7bac3f9e9c9b6233ed3adc0abc6a44805ffcf7b7220f5aa765baac07e71ff41cfd14b848be5bf46df7d79699c0394691c97ba706ce4360b4efa3edacd5800f150867470e5ff530640c040427e6130e3837b9ccec8a57e798e794eb622146e47e5fc9ee8cf21b0cd3357d163377d0bd9b8c8e91324dd1ea4688e04c3b1f2eefe6704bae48b70f6daba2c8c865c7882f04f2a50f083b782ce57e982346f578f58711f238e56448699dddabdca6fb4ba5832400bb6d01862cc3413ee29be6f650b569cf210e5c0b4548dfef7d03056be6f11839fc130620ded3a62cf9d7c5ecbcac2b7ecfbb5fd1d9697a225e7870bcfba3795f3394e59092ce51caf7063165c3702629c67602b03a66a52066da554b7e4d540681851d732d6975adde8796c2044fec5480afa9991129b684d54572b56a5c44f20c229f88b7aee6ca7ba96efe4fbe8c3cff58081f27314fc9231701fa0aa879cbf44d98f63cecf8e69502883f2bf59e63b21eeb3c3d572125b86915c41998a82b26099169b5683f2a0125172d29613a575c47c64d80b89c6770464ddf8eee629de6eb7f18a71f282ae8a3cd274cd676067a4419e268a9d90dde55895813a67e385b82ea473bdad35dc9578511c735216893f7326f9a42e9e5430bf2009beec869184130af9af4d8188f5c4454b09ebbc99b6a210dcec8d76428d51ebdece991e3886138a8ee8e8b8a9ab7d9cc1ffee718a54cbc88b167f48c46538f42cbdbba7123a9ec3ddf5b8cc687f31a53c8c70d08a2a2c4baac5eaff85e8527b2088bee6bb88a15a4496cf4580ad65b3d9c2ae7ade8adc582ae7ac2ad7cc3f635e0a9cdf035c2799604729ada2646460c3b71d895715df54d6a38ab7fb612a709cfa6613bf72e4ef0ec4a1869281441cfc657b208178920b4dacebffdfd95743e91baa38539a8f793cf83fd6fa2964509c6bdd0344d6298adf28ed2d2cd8a20cebeda209e8efefc4ffce9b18b612ef807b82680801b16f2e5cad185ede6cd50a120265412d88119b40aa4bde892f4bbf0947ea8df1eeb3bca03ad7cbd1ed996e8d661d63ed3348c3cb96e3d02cd115bc20f2f2b2d43a5e5ed590037a68a7bdb7918c1d0c9b832bb48edfffef6d335fd096efe96a20962623b4f91cdd1aeefe2beed2031f91e235000bb2c4c457a20a073ea27243da53cc6df6a49eb10a2e6848997a6c54fa0a66f42b423954c66565a7f6d188f6fccf5363dccad760851b463f1b7cee0ccbebd18a3e2a4b93a755c05a1d2105460a334e3fa428356cb1b3bd87c5ca9fbbd1d35455016dc80e5e685aac3fddd5dafe935e90a23599116c11106532158595b8501a198194d2c5050008e9264f293e047e64b9ae06ef334c23a1c8957e09dfd2e08b32e6c967f49755d1bddd41b438b7f52eb86738cd5a2e76c1bfa50c7e4dfc8dfd0918aba2d11b966f6b9e737a285907906cfc3a5a25cb2756476beb87d7f0cea1b4249a116859fc6aaba930b909eb83a1d46978a0c5cd77f78fdfc6a8592a4832faa5edbca8b28cb468215afc37f555ad4065f0cccc3d02334cd1e80dd88e13f74fe9555998ac1dedf44e0dfb97c3d43fa8e97b61e607059ac37b9945c4751ad209707745d3a84b99c322fe1ba242af837134fff39c2595059c527e999564edd65658e4182c135f6ef866207c99942a068c54d326103ad04efeb5a74f5305205c703e496b5e8a494890bd67d7f5ca912c37814f6ba4fc8443300532c0b2b1733b520e288fd1bb20e846450dbb8f66e73291badf9ee9090712f68fcda97d49efabd2c5607ee28f13bf021a0841f2dd35807100280ae1238974967bde5b8ae3a603b77bc09f02b098727660238e64400f855071b02d4cfe973b9e479a2b21441c8d67a717b4590687b31ed851c2262692a89ff5fdb917d140d34ede52fe4526d42eb88e09a740c3ce6845c2e9d6746d0f2c2dbeb867f1d4920bf9acd105604e009ff0051699feaaa2efecc8686a1bc1ba2204b178c19ca773a4e9facdc1c31848ae50892fb6a5d415843f77f7091c1513d4682d4fc2f9f292d1ade3eff119c688e71832f1d70afca059dc1999c98d58eaaef0d724af3e243cb3ffa85d5a423efbc04676c0ceef6c7f62e63b4bd129cf5284c5e0f0efd1cc34d5c61daaec3d509e62856af5ab5e422623ff84c2a5e0807c75b11231816e9c9fd40378a4dd940deec5103e6162fe78015dc0bcf041af68012bf3627e148d7158efb986344c556f398ddf7036a11ad819ea18b8df31e3dd83a922e1db5104a341f667bd0491e87af0773b928aad7a6dd163b3c4468b8745e86d9099cccfd46f3d1183a41cf112d2aae17f4cfcbd48aa99f3900e273c0e9bba2025f9f0ae8f691cfaf39e72b999fc99555909445225dfb2c686dcc15c468974bb65541ddf349aba458370bc65c9ed142574ce07db32ef5abea23429b3113cff22b8765e82b4b3b67cf3687be6a6f44d417d2aab2c64cd4517f1b7b82ad88d75456a1dce4f295e476760c41997a95cdedc09cd6818f98e11d5c7fd6b1b044d2094c3a35af900ee4168414f58d473eeac1ca8f17f867461dfd57f137b7674592f34e86616c51aa74eb076f46424647ac47dac3aa1fd8ebdd89a7d91eb0aa1f60901816b3692d985521e646007432051cd6204a219ecf059db68bae42ddadc59aaad5430c0ea3699d1dae70f4ffd8e41b57b565d38d38c8bf7c8e8e3d65fea5f1159d7ecbda56c85fb0493e67ce48eb34282ded550dcb137c06e340c53fcdf2258a422a9863aa898e2d255a84ed664817a5841f99ee7a922503342c61c7cfba10717961f74a714595fcda52f7702d1f7085b46a03ee62752cfe8b0f6643da7d359e1b53c7263dfe227b530b8f443e1532f1cace82175c48776e4965e97bbd44578b60fb270bce48673e3727fb9cd25cd8ece9bd5b8bcb63da66d0a01450e4165ff6a962b35bb9f94bd61cd04021be5cb67914fd210fd3a934260645826086632cc43fdfa58c2ec359ae05ad3adee0a784c00043e4a6306a552262e962c0249d5318486db30936a8eb14aeb5b079c50e06c535c3ad1f80e3cc39947c07d6b52ed015ff66f6646972cd26000a38f7f5b1acf2ab550dec54b25ebff4a35be1422ced5a150f665e0184b4cf5e18eaa395b21a689fa8fe187c382c66db5004ff102c688810c66c287e42e7d13e4b5c28d5b800ead1447682e098741541c73b0951af174e473a137186d887c12fe0cdca4e260f9507604b5c9f29c77ac335bfc7f1d72a0b0ea550ab85c44c48868ff6abebf6739b3787974572a41b5466e9e7ae0125a5859eb9b581ef41a2d0d498c57c440b024c5d70a3b83411309204ce100d38e6e77c5361e5b9412d607384a490e138b64b92b50011d95140e879680ba5babb279f2d7f286fbb2b40e185aa9196567f97b1a5f4335aa3c40509378f9097de2f897233c08ba0061febc6c898f4b5a1d73c5e6b67c9a9209a50ee333b96b04a808abe0c1545c455b13b9b261830a38bfde214741db1854a162326f9fcbc436c6ccd78de71460075b264eb5abf04590609aa9306dd4b5038ddc31c880b7dc476c46522b2ff18b32bb35e9a3c945cc51051551699ef291cac6f8742557de7af7969903f284dc1fa0151cbf30ba6a07d1a5b09a7188c2e7453cb9b63b43ba934ffa5e2923843724c18c7ac25ea8707062593d57882e6ba92d2762e1b07ccc571a2157b5b5fcca38fc156e8860515306bec6eed15ee6099374251aaf720d1136060fcac72581c10be67110385149e81d8ee881ada39cd8e06298ee1a2e14b20fa54c7283c4de397e2b6d1842de25280932c3e68e4a6c73e2396049d9eaab4b3565e9c760c00f9f889393aec33dfa81ac5c1e35f190339ff17a7190a37ec5a29866cb1a87f7bdc13eb75313146ce242bd66c402e5d2bb6be5f88a3feb6bd0e9db9aa9b93bedd351acfdc42aa2d9ef4aa7bc174f90e55fbed7da5c03adfed5f36a0bf3d6cd16e422e2c20f779328758e65ec3115d6b6d7469de861061d73b2b1bb6083479160cd5a49ac0d051a5e56955c52e1d97b7a3c0b57437c818b95f93dc233297506efb74ca9b0c4a03a8373e843772d296e56e6cc895722631803e2ae89fca68e8efe873e5d6621d9eca7bf87e41448ca680926d4438f0948a1c0d31bbaa3adf59fdf2f38faae24033c724698cb336d76376367492f4dbebbe98a071f3d6d43b4b2167f71ee020dba2d33fc898f11b5382238aaeac3083511104d2b0b9cdd63633692e465b19313546fb5772ddc1241d69c6a507bd554897c045a695693ecf21e33aa2fedcda2ea9abbe8b99c15b361367a9aa3d7e5ae6e401219d8007495eeed60f2af2619c017be102a47ce72d7a3f1c25ee848d3105244e0ac2c91e8e418661b9408fa2bdf050ea470a7b06f7ad024d8d775199f3c5fea46cd78665405ce63cbe54c4a0403a3ce2dcbcbf4c811734c42ed0a8c06f0b1a71a084dfe95332e61e08b74e738cd72312615802a3e10c11e6e535a7a4e1744d051aa4471653296175815efd5b5e6f6b1cdb0c8fd9e3447662f766bef870fd5b6c4ca4134f3f9d83e1bea071061fdad35485e6dc80b70af016af5a0464dab5bdfa3a7ae7dbb099e53d3a79e9878ce22187d0df8773f5b47b54efef97babe1d105dd3698694601b3850020ca1c5fbf0bee00f18aef57bb54519e7e81acf70a60a305c61ec310a4b4e18b6bf916d06680cacb6c553024c54c8d65dac556fe6b25ef32e2b813f063ee04316008445cbdc176e0547075d0ab160700e06dd1c30cde71d635b6c1a1acd736f84b5b1862e2f08e99b6cf2c8bafd7d27d572c8b5f7e7115fc022b3ca7bfe6251211d8647a6b60a0f9028cd2f56da6c67095b6efed701696716bfa567ae97917d4f697ac82c0f3285c260832484e8e2a6bad4fff90b0d99cbc0aa0a10d9e107ebe4c38b127fa1b3054bfb97781f3a0edcb88fa2a8e605d116fc5d61fc4afada1fefac16c90ad24d6d9c685e0cf173f5856e69388f71abf5964993f283561ab0dd16847abc982c60278c867a4919bfce968067d26839daabfd4fb0057d50789c9bdc397bb2735a7bd4df153311b9bb9528de13ef5dd49ab3e3aab046f6d7917cff2d82000300dee75ed6f178143cda5c32917d1a094d70c3070e02a00faadd338e3030e39c2cde2365f19b6d1b3186bcf06de26127f7c8ccb1399142d3842a63c55e8a46f2db25cd52fee0c99f0e43c15194f234e756392981c3854c9e549636b056b8d675f0530c33a88d13df976fbba7f0cf5abdb076f9a509a5ea14393c3cf1423fb8239e506c9a287b54f36df186a8d39f4be4d1d47972aac69c7dd6a5036bbef5698ced56d2be24566bbbec75d635aa4383cf2b7a003c5f7dd58ea03b9c38b42d42e535647245018deef3d7437b0ebd8fbb880f7500bd66b611cc3fe86cf1a0ffb9503db0aaf23aec79aeaae8a4deeca7f3831042824bf5aa3507a1e237099263d07a9c9b9f6a82653e1f74a7ba73be8a0e66f9dc49686d710df2ddd0ff2f6e4b36ff0ffccb648cc9a806322ea18178a60f60ea2502909f79002f9594666d6034d762b039ce8e10bb59a2e13030a96e2bdf8471d09cd2b1db414d262f842a800ee09513fb65c701655eea40f397c77e49547ac2041570762890f97933cf1095df9e24e4b74fbc52bbc483e0d3f92091a926e6071d1758ea9f8d9ffebe5925d5158d5a4c63f5dd745cd9a82ab86ec6b2e445f48f6b2dcabe6b3aad32a940ac7a34a7d5d7c5893d03904ac5adba710ac99e41f2786aba7b76c9bd48462fa0ac0f0ed97dd512239131bb0cb3e675ac2ce231345181fb9802094b207d0af72f6396535ffac2cac75fee6b5d2cfffdc9e5dea2a2965b346339e9baeaa4573be4d7dba46903d3417b9a1b2b14df8e16a6db31814fb058528d924bf9f60433a08ca6adccf1ce964b8e4f3c071f765d0e817d97b61bd42b1aac38babdd5938654646adbced043a73b4c5fb5913dccf6004d766d0ca44c54bad25a24a1e88e768ac5ce0f65a93bf4c9792ddae3d0c2efc3ae3f6993ceec38508f7a31be3607b4f376738bd5954b5c1b9a3fc2b31447c40d37723804ce7a043a2285a1396b34d5a9b7e914261fc930a6ab938963c81cea7b3a26f15f3b0be1c5b9fae692909065fd29266f5712a16ad24d00e6ddaadf3509eb88ba9bc6077ea3baf6f8c4526d197c73a28dbad99de342cdeca5f0b2848e246efc4c6579ba63e13ca0f0244a485eebdd3ab3772eba42233f8c0d4aa464e1abb5d6ac0cdaac1fabb86e1fa7c30575aa4d86133740a370540e4fce22324ebeb63fbaba6b338281c789d4328ce79f3119b9e13fcc1cb986f1f93d7c14e6fe104cabe9f855c835bd89019629871b5e6b0190de4d02af43275491358afb0f1ac073928c93e647d1e530e071dab791daf67af87c5018ddfd65368cbb520e3d6cc5e72366700040db23ee4e461db42dac5e3cae9bfe5afe45a9072287442815afb2baa48002e8a31988ee25f5042940a576cf24a0713bcc8841660456e440a879e1a7967f05c0da01f9b63d2f6ff2e713263da851de56f5ed242840fb14add50c567c933842920dd3fbc9813adb6bc72e0d4dc3fbef9a0438686d7092e83406b4e05c38a2a516fed209cfacae2d96a17623ee07fa65e7175f7f6cbaa95cbbf72ac85e96f33402953f2649fb51cb462a682eee2de82ca6ea8ce3a7d5dbed3a8eaa735ac1a1598af0c783fbc2cc3cc26229a17b7450d5dcd163c25454454edf12170848ef9aa9df9a01438702557d567ddcfb64c19bed1dd3054e5aac53617556ec2cdac251ad410f5a93f67fce293629584599c1259a1f709c4bface826455f3a7a17ca237a7ece2ea881efe27e6874fbcf8aab2cdf1741c3e25fe2b821ebf5c1f0ded51ea19a65d6425fe1f8abfe4ab14a6cd176f20be758cb1efd1885284f973aacec5d0b678eb9bbdf22d09ab28928a97fe89a43c68cafe8b6bad6af7e728b3bdbdb0ecc279e476a666e022a513d82c1be649a24bf0b3a1dd6e159457c523a7dc80b89b7fe9a45e03a84b56a8341c2471389b5df1036ab91389e287d15cdf53511fbef5f6fc711bd989c0cd0cd70265529a7f8a3976e667b841b5f84d48121923675f0cac83d8564cee01f2cbdfe351fddc34bfa7bee9d04658b780f732d5f2350fcbb9b1406c53600782817ee2b0dd94734f07c832c6b4e9f9b6b8d8e0f8911f89a97d9cfb1ec70f1cde7280b18e93abe2f2a5833008650b72a90fab9d8003567bb915a6f458d1c412ccc0138ad7959ac4ab64108de14c6b1f265d5c6f6ed93c6c71a07dd95ae21b1094d50a9a77bee106d9937fbcf79ecd6e6e0c5500a4923defe9155f468d19c1cae17f459decafcc4a339fd4277a25eadc0953261e2ca5d45d3b94b626a8f05d1c439044a4962f3cc6a7126cda4829daf26a8bec114e06955100b0c6dd8e3e14d8d5f5b081774cafa3ef8edc1e9c7ca93452ada444a7adbc216cda4596c564d0b34bf6eab62a06d8fc3eb0bf98ba0b543d299687745fbffc8a0d2ee8fcf3666ee93fd3fcfbe0ee092f81294a81ba823fe3bfde0be831d2b50a4e71d352f0ec194cbfe0d4dc966f92b8eedb9b522b24d8f2d878ccf570ffcf0c371cdbab1f76953efb81ad5bedcdf29a9946cf46cdf09c25e6a63e2306e4f0280c36b545be9cf1e65ba2a297f5cd5207b2f2862f23e6f392ef8421e073195a6930532ef702ec85101b1dec8dd890bb7dff4071d8a34a1469dbe67b53690097ba6d39e8fd200a180de96a5ce17fecb2f28eada31508c7dadcb81b8323fb047248823f2e344bac39298af4c9754bc7496884e26f5cf218ea81eea5028753a3d771f777d57beb2b906dbca578c801908f42c11b7e8e59c88b70f402b516704dc7f25334b4ff5102b7efa43fe7ec9eebeb4495864ae805cb918a71852996af3b3bc23c9a30874f715319324823f427a13758b556530b101a8c83d0f7f1780c621026852e33c115589540b398850a8d2d69f9e38cb99b86ef7e722adc3e7ed3d201121c0f40597bd879c590701f0c1b784f7283a94ed5c06ddf729df71e19d9be327a56b916eba37a4b7402f776c0d533d6cd5e39f65da6db34cc22fc41b55a63280137c7d19bee44ee22883f4ae484cc9a5289af677623df2ef0d38e0c50a84f4fe41f1ae37b0b9fcefee391b91052c4c6f3f040bd93b344eafd9652d3299bdc5b1f29dc46275841de5e7f1ae3e9ec52886bc0bf6c680de69f15dc1a0d75757fb7cfccdcc91855edfb7619898fd1c632d3d5fd6a0437a0c5f8ac466d9a2b5af8821bf0cf2aff896cb6cbd1a68141c540e4a37f2fb65ecc00b19f57a2a831f7d3d29f7f7a95928668282f5c86b1ef5ec44e31e99bd69e31a1fa346c2522dfefeea1a850109581de79510a8577fb54f1b9258b8558110e380cbac503148fa85d6987aa71775283588a074544b2a36020ae97e4f0a3001d2aa7e4676696fdc3c0d14e7ca56d314c792ca61ef206dc030f985fcb3d3a3fa4c59deac22e56393ac216d138c98032b8cd3dd0625c4239c7b2feb1aff6614a004b1f21b9fb1a81d6f6ffa3b12d1e7898983af9f6803fc08e6019d806d49aa481303066d4a0c853ec631ab5e0970e5660741a78b4e9454db365c51b06011c2165f468b570f32772800001ac6937c3fcbb34868967e02a273fef3952a9e6f081be6c50262a7c0d8fca95598ac090a81bd43e473099c822e5a214594e9e2a0a5239e45f4b2b1f2bff5e41b642c3ac68ac62e47d46d2a82891727ef1b44f2eeccda20179791eca8113b1650cc1a5200d5658eeb7cd828bcd4f0c61122a87c3437ca82417bfcf168661a477e0b577c90957f55b5b2f30fff1a37528c56e07be1c5ad2faffbfb91505040caaee956b2b0027c90c76fa4461ab895c8185b1a0e7162d2a19ad49171a58ef8828aefa3feed832b78cf173bb8a39f9a68fa0cb435531bd1b33ea4adc5f7f531a8aa691dc74cd3702fe31d55e5b8d870d4f53186e72e4267b55487c41d00b5d97f203781e88f22f5c7fc96b725b48b86a526a9d8363ed148ccf65aa1dd131d3ec2b1f910983ad38982b303a6e4b524e25a649d932f21b5fbbfdd34c7fcb174cb5c0b58e9098c9953d271e05d6503763ced2da731683b60eed0faedb54f52cb6bc120d6fe52c73bce756a0cf70bf49a54672336c58ed9a2fbb136ee2cbf853cb43b8b2931f52f90a7eb02b9d8ce2e0478f8aa9c438c42d40ca86f353fc67faa43ddd44b752728174ca36fd77f3eede8283c209c9f881be85791c7bb7e58f4809e45c88711800c4bdcc1a3b8c421d2d135962f94cc76f56abdd680c9015de306d48b9037e0ccffbd337d89b1341d0a580913feed9045c7085b459aead3c5292ef0bd9b2db9fa248297356daf37f78eba0f92ece79d0721750a9d94b9d4b0f5a66b969d60c025a470cd610ed970e6512aa550146f639e3dba1d82a3252866ef87f55f1896b606b54b9bf89e05e746027d5be5cda66c1db678e5b10fd9aa5e46fe740cf16b174bbe7e957ac6bad043c97914dd4b0f7e7efa6126a3bf76f7c85a30d95d09b005abfdc07dd930d97f835980f3095fa888f8a970572355514f8d75e9d75c9cb06879e3b0446dcc55e35fe9bd1ef9e09be53e5945d29377fa1733448995b3e306f939209423a9559ab28e6db24ed77adde0ba0cf64f8d6deeb0377ef135183d0a14b1bf7ac9d73863d67e6c124c84d348e195b6aeafa1fab28fbffa839d02523b5752a0b54ce2769d263cb3029b80e1ff75ef36bb285831a5ef3da38e6c4bbfc98eb483efb7a93cfaf2161dc447eb2b53fa4a4ca18b5cba3042a5dd6e04f2becf1aa85e130ecb50d450d5c283c0d0cc7c9b87ee01d8070909658aadd872d0a1871befba9906e1ba2ea9ad4e554b2d9ca19124130fdfd072a288b01d0870c543a40e801040c29799f181e512454b970e0fe6d4207855614a25846fde38d457874e125793493e9aee0dd90840a63fb65c7cbe4af9df4e4fd86b085d1fe54361248b075c23fc7a4199eea050a6abf681db48a7ffbd3289297d24a972c3119242dc63af4acd14e7b0b4cbeddef436a0e0371beec4d48107aed1e3f872c197c356a59cd115a28c089a09da3101b05570b31c044d78dc0acdf0e093de3b3ef4bc8e5124c69631c3096a89dd3095d31d93c7c229dffdc6f60f437530bc3621bbfaf674b414e20303ced98459c16d11045fb09092d54570299501b3a632a7c03ea63f9adedc76d1e6746d46c9b4b04e58828e4d883ab5c6315b1bd4ec3ba4c69942629af251ba50edd7100919885e2cea4a309dbe7dc3f3502355ce5aacc9bffbfa6a25cb3e11f51f7046a40360f1f919e3c60d45c132f376dafeaa61bc014cd4df6d9999739b8691463248bb6a339281b804901117cb9a9c0d8c2014f5c33df5818b12fd7ac70e270c97400e783d4831e69581b78d76ec56e7b8b24a951514a3d93cdf5726b97c0118d4e5442830b3d5820cf82bd4715d8b242b922752f9cf7557325e63c34a308927db3d0b0252ea69e8ee0c6525603a86709242282da7958ee77d823c94a18a5fc2c846af868dd727ed5e28f8894a9244601accb7bbdfed97471f541e4748862fe7fcbe5aa230aff99225ff73f282bb491e21815523d196bc5a5ded5de9eccbed8842fbce2376d8eb04b3fb18b3fe2723723585708d156a03f87fe9e07cfea8dcbbe29dce4e3246fa45965fe7256eaa88faf23972bbbd900bfba3330b9b624a2188f98fa75739acc52aa1a3a34aba2fc4133517459389dfadb0ea7f874979df7c76203984623834a8403a6a9544c49ff5a89af4ecb024f9ba00b26426d717db4f5f9871567bd6ae3a1f466d9d2e32fdb0bcb2ee668ec46023d4e4ebe91afc720803132256ffec6d66c5c923be8d52ef478b9810625485c06a0d488c25e807f062f2c10b115574d1b1bc7402385589f8951e786acade8af2d847e302d2778c9a6e39c34fb17ed421525d29a0142c206fc83a6557f4d77dd3f36ef0d7bfd958c744052973c68df5869efad897b7d9788017e9009db752c762fc84f336e081349baf669b1dc03fa52bb1b225fade36b0b20dba34db36a013e1b85cd12f9fe19329141c3a5412bf64ef227905e0c3e4653419905bc645c9d3613f10f44e289cf8e7d23e371c027ecf1659bcf38af060b1b6e21c9aaacc1692d903797a6ea9d44d9a376245a13017ac82fca39316eb098b77373e7ac3f1aa6ee463db7e5135ac1d8a6d2cd8f7f751bba3a40d075791270a48d928526237d7a64323f5136fc7715b02220a10f30c79a77f87bc3d387f0ad072ef8db1210a797e0c559331e283c76729f761a59345ba56e2b152cd8bbdf95337d06848c119bd027a542c885ad0f5ee86107f1b3c56ac6553b74c451e205b079abcf3e0aeb2b6edec82d52c395de55ef3b723f73ad030d58072f59f7a766423035cdf8d26945fcdba00240c2e07d568c710aebdf71e3a041741d6b0525fee6cb08e444ac01aa1bb2d62eec0f4255c8e04429df1a674428090055a88a45b1b684b01f2bf7388a2b536ffe423e599e9bf6b50fb2fcfb7fdbc3fa1f0d8bb92b52706d2f749e2edcb677e624fd301daae317ebdd28c6fdc49ae262fe58b0759626496c9cb4a735a474e4dd5dcf049e6d853fcbeb442f0e89ba595ad5ed4d6cae5793661c26348b9db5e5266aee0acd4ea27a16f47443bfa40474a09f8caee2730d382815cc6b67bfde3456b9156dfc30d7e4700ff70388e5fb1550d8bb805a50541fee99ad711b65e4ab0784ebe05cb8ed85101c56e107543e2bb76d6424f875db8bd958e370fc5025508a09210147969f27d27241f091c8de0acf6c52e28c5c82bccdb71c955c2cb4c626134bf20fcb11dbe6a98d1075174060bfbdbea8ea1e89fb2d9fb2b04cbbbb024918e647bd575e30a49063a4c6b1a6e13e9f17e9e873c479bec340f8016727643d3077d0f49a59580cae5f1dd4a3f8c3ba05b9bfb782469dff5360fecfbb2bdafab1d780e121bfdedb2605c3e52b6743cab3431cf23393991cae6a55d0c61f5c7f64f9a1fa152cf971d02fe28397fe00b6c36d5300a47e58d77ad5540a3d16fc5d279e3ae0486826e0244cc37b8b5beee8e447f5331584b2626e358c6d3fafaf582891208981eb3d1b6d75048401edd38b38f6bea6ed5b371b88a33a1b1947ad53f46ff2829cea37f34402766f8cd682ced35df4fe0dc704e40db25c2d5b874b7066bb0da238fa95eb698c90d39f6e1884f2b01029b8731a0f2c602bdb3aa57575ee55e382964966c22385b075827fd39d63ff633a2f2da2d76f1f97f2717efe7d23a314137cf4a61d7e56498be2b5054d41638c6375afc7a2cc5d885e9cf8ae0d78f10dcd70c6653a0f7343b1a5b33522ba60584f2f1dfd22c346fd0905d21f74b22599ed0daab8bdfaf74b46f61a55ad6cbdced4648b79ddeccca9fee737f792ba241448263ccff0b6b78cf409d248cde5e77490de382ef76fdba418bc67506ab5022379ca500b34d65b2a597c648ee9c06607edaa9ba8c3efaeccccc7dd33157eec3919c982a9908567e8427a438148004f4b13ae5d7ced9a2edf5572bad40347e815c3123d3c4c496ae22eeaa2c220c94d4851b437ae29fcbb09084fcab958e556f5875bd4f3047e16a3b82ae7709357a91aa381ee32870159cdbf8e073479cea114c2a5551ccc33db0f3dfa16f9981a08735800910246884be4a46c90c26d489be2a1610d521b4b60e295365b6a6f952c1625ecac0a06aa989fc8eb79828162d3733ae6d9297b46c529578df88e2e0834a611608ce329acb923eaa893126b3e05053c905e66692ca9514e4a3079d03c4feaa43acc32e24b6033197acb7501d954bf33067f9d968c78d1cc64e1c216948e3c7274bc8cbd69998996c0d23fe1c07b32a99fe90db7b20ff18d4ce9620ff92fd9e93ef16bf771c3ff8509eb588b21c69688f0c48ea916a23b412803ac379cd46724684552401d9d939e5e0c85f41e1c73ee94075f4a56186034946642e48e181500e77f9ccd4b84b89cb48dbb9e4deeb9c74e5d6e08ee221816bca6e46617bf12974bd2a98b27f0fb068161446924e6d61013f418917b530d9251976cdda67444f174260cf3922b1d7d8779ed8a72e1253c6a850499f94caf2fd69ba3d28d902f3ae5e216c2614b51a05cad07944f621ed6151ff6b693bc998dad7bd300b522cfc68fca9800833792ae7289d7f86866da5e0af8cb6596336d3429dbb7eda28b44d093e35134f5df5b1fbb7b11c71e039fa1e63bc5cc986bf2fd65b7efb8d5f81aa14f9e0c3a4343f4d11bbf242e4db4b9b94c8e40338d1166674e54a7d1cc9be58c7e2fff4898de5d751bdc6b66ba10a4e7f7515636a40e17133c1b7eae519f57fb9f04983e4d6c50f111cb374c0a8dea27a17f6f63fd337215334b71f4c373f302b5088597ce053e228c9a83c650e6898c124c72a96ea05452c3ec62efcafd97705bdbb5029853541f7e06f4be70079481c07ff8f209a04856a5c9e131845b1d7995001559d45a09b91111e21b12f55574737222c5da1b415bba54ff4d6174d61f8d3a61f6b3534ed37a608b000e783527ee6c8aaf2aa0b9e5a4d871149f55ef6354286d4a6ad77bbdb639bbc3d89fa1217c1cc1874727b2c28f583622945ad3cd33e282f8864688bb53de5369d5efaa76a64fbfbc6c21a2d1edd43608b4033172d0ceaa8cac4bc212462e4e355b7c4e8c56733d981c868ef30a039c21f4d3638afe4a2d78c767ff95fa84f988a64e18f40e49a122b8144ae646a3a0165ca5b40bea6182a667c8186010145d673eb4673fab8bf06f2a900f4c5eaa1dcbf3e53f79256ae85dae99265c10bf6185e5f38cdcf8bc57b92f931628aa27d91bff392f90c57fcae64026186f54a61deb93bd19b76e0867ef5143f3b04c1c0591419c59875ae7f9b93586b942d8d47f0f893ec9799e3c3f1a907fa34189628eb418355fdb992a062af1446e8897601c051ceecdf07ccff85927f06afc60c86510e8876ba777a4cf150eca49bb133f34201bdcf992492fca37bb27db53f6b7e40b636f910b270bd6f3c90077b42537ef45b919a778086b88d15d5546e8e847d2d3d93d6ab85d4f90951176836cc8dd40d2fb43bf4e7f2ae9c997b1c5a5e8a38d8d2fcbc5f6b85769ea25603f5b86504116e210ae2a5b63626430a339db7ffa4e5ccb6a2b27453a21f39e69aecbeb40a34868eca7296bbaac7ff25aef134f9e748da768bbe13ce08977ea98e6a98e26143c2ef7b3401ce3460310a766b30c9045125162d7f64e811628b7997ad13627454317d2a51e07c97c909a5950761ac39da8c8ceb027010b745f037feaf0f6d96af013ab03a3f0f9064b689a0c2ffae71fd1f732ad5010934d242f4d7022c5a613ba0674642ecee50b5d3b463289389cb74e2825b1c2a2f144d8ab78be33047381ca556290a874d36013fdedd3bc418ccc0ca30216fb56f5ed7ce61f551e03743e2f4b73c82428174c1bf3b1eef03ecdb3f8064c6e687fb4ec733ce65057bf9b4f962380de8c9724eebfd7c0b1d6561db3094f49231b9e9957d3b68f8b7591007d063d439296f998c3a67bdba02ee3d77c5f1f73a8465136ddeb0ffb39fcac77b7ad39d260aaf4088f3a1a2fb703336435df15d9b0d722a6d1bb9edc145553c5244451d0a74b14f7eda4ff33f0ff594906ebb8c99870357b41985df489968ab7090c3f2f5de332f5f55b4bd30fa715df45bfb6c6c3cc5cc3c9506d1fa053b0e38e61c531576b4417d416224544b2b8af8b33c5c88616c6897e0ba9a219955aa6a855c4a253b09289d5ec926f5d62d8ef2bb55019d11711583208311c7660bba4c012ed9cb85d76105eb5024ea2fd1e36e7075b38420ff959f9c3b0db6432cc412d6896593100d8fff6c320836491df7d929e6c1165a3a98451798102772346723d2a2ff5e78fd06ccf67b00206a6dba7b8acb0b28737455d0db201928b9b32608d07e6ddca5f9009931e4be4860a3e265f5b3373b86c78a78bc326d4011f339b04ac71fad80ddc03b9a494eb75d1393f7dc9cbf5a099634b7303fb518a2037bef229e0432b7a1bb2cf21cbb56551d47eae25cd025041df9e5be996920ef984669fbf05a220d3de041196342ac13d2ec1d58e43ed20a3a00d7b3913a84212e5daf6200bd5f8ed875218c95915f726471f74617fdaa805f38119c6f9132c0681a26a7efb6b26f5d51bf0b25551e905f0348120757b78b916aa9021c99931a346b73b0e49a506daf879f41bc1b050e1792977f7186b1f7253afd3912a33119efa589d33009c18aa169832ce1fdffbd18731e8a0752c83b4f933f80682b02b490d36d84294de23ba56cd208498443b757f56d06a828d655ed8fece890ad188373d121675c71fe9315280df43c156b3fa1532531c1b6c979cc23fecb6d4c37256fb8010d38603797167b83e59c98190b3b919827c6b436a5ca68cf33a541d5d83a075412e7bb28f3e147cc4f2e2cce67a565d6aa2344189a80d4f984cb6816c3e879ad0b9a78e780e07ec5e45348f7143fef61295c615892286130af736cfa56842eedcd29e47eb2c705eb49eb482ca41b8264513d00f8748a9dc119b3462079783dbb8abf8f74815ef4516f590d7dd72356bc3027b3571f0d048817f886b73994111a383f6c89805ac3de54b8fa9ba681d860c5f356a3bb8d301e467f850db559086d482888e2698215ad8b6b583ae38e67bc58c97f6b76968cadf314e896f6e169cbc40f680b974a5b5db3321b05e236279fea5ed117a291fa432cc693f969534ae603c28f9c2b0a730820d949baa75df0786133f7033f814fd9674c028f4d7b8b96cfd2440474b5d68bcc8708c480d80cafa23bf124c83bb2d6bad65540bd9ffc600c7f66f8aa11a20ac792906ee15fdde9087d2e1d1cf143a74b2233b7033cf3aaa8140a641e36e0b050de7b06cbafa097cde8a4bb630aa8ea9484853292df0c65579df70f6a530019a2d6e2b66003f34763f3ace65d9882470b77b967819817c136374732fb6aa49009b18241e3a77ce637b631911ff2a0201263cf62d9a38481bff8b53c1f63fa2da83f4201d45e38201c92efcee402bb6aa05ec8a08ae76e5d123decdd1b305db6095e1232cb3e3b5ba324b821dbd04e0bed6355df249e289261a129d4f55be3b7ba33b161f4f76a278a43a32de673baa28d715f9d10b073b6da6a30bbe9bdb5c0ce2f858907d836b29cccaa6a405622a581d86c45eb07efecd0ceb977f638518e2b9b7ec0ac59885803878f632558a44a629833c4d9c4a953c2091d2235722903c89810c3bdb3fbd8c62bb6291f8b16b78e464c21cd0d986957f2f2a700a1a5717c71ba7d602456256afd1f5711deee5e4b9a325e4d86d8716938c3fe3054d6c625f191f1e4ab9a12cd664dd9d15e16a947edd91730bd8cea243ccde9d822d666b2fe90935e3d0027b8cff94e8f9680fb744e20c6e883c3e79567b9f1fbadb80444f99d0845904766077be0fc547cad30a66b63bea7549723831db54d10ae94aec73aa43501f24d6d44be5a2fc3391c79ae1d1914ea86e1db69e7a77d306532622997991320672aff4f575e12a71132ca854c8abf88a9e3b920ba0955ac0a622b23737319b6f8ba7ad5bdf944dbc171fdc881999a97bbe27b9f6b616d4af5291d3cee0457802a1eafdc6c6b716826b19fd3a4e6be8c69822121815bf1466710d5b0c2c53c35f0f3d9ce920a54277e408b67d47c8068a98d730196b2d33c31887ff1dc71652f07b3f8411e42fb2d1dc92829eea19e3376f706b28fd48a82741b64010c6cfc4035666de0c55472140f33e0ecb4cb6ab44fdaa9508b79a42c35f7e7fc1166198928dc8204c3995c5c424154cbfd6dcd8f54655691658972749a2048a2aacaaf620fe6e83cac716732a6f50663fe561f9af2fef8b6a9ff1d33dae275e7717a3976be531e5348a9eb0d8793ec447ff45759b3cf1c3974c5190315a13d6dc510684b0fdb11b6c03e64b79a0be6ba6f690a320f8a12b13c9573391c38d8c7a43186111af40af0c871ca0a15c25ab129f8f7879c261048dc3191aabbc3beba87f0dc73a459b7a00b643853cf5e4ab75c145212a8a84212097b01fccf6f11fb824c8f9164abac915cb6990f97741f0915ddacbb7fcfe7de2236f5cfe478ed52129e304b7d2f3ca8490cfdde7aac8456bfa675da6b4d2423f134fb9defa8ba10b3df95bac80ef1ae03131afc763b11aa4f608b10dd6711f7ffaac4ecef9dfba8b1c47a5e9822a1677ff3f5bc4c9da269d1e68e6ffa9d6b9f232de8a2afeef75bf3ffafb4f631134da17e27bb7069c8da906aaa5dd4180cc458c982387bedc6ad8864d6d612987c7b783d6d7373ee8994ab4811d50f8b72b3aed445b47ec7998049b19d3994ffffd45a4afa03447830d5382ed2b010319e8de6f8cf2e43c2b183270e5ab60d5bb0dcba75202d0215f2801ba0b0def20aba845645647d56deb5dcb10f900d43b7d086dacc15043837b321ea64bf55cbdf3102c23140829ead84594bf9a9beea8ca1c0953010f4c5a43ef3efe9772e592d06de44056a8c2a578a236df47d407aa14b22aad22003c21a6062c701a38288310382817f49982d5b17e83f97e594b8922375578c6b488f9065ed6a221f07ca9508837e9143bb6b792c02803d7194457a738c1e4e745ea55739ca9c0dda54b9e3b04b60c305e096c2644762bdf6cab6efb69a43a9139fbe7132c0ff0beee62566fe3238f8ef09d908df3c97ead7ccfba37f88cd6751fa665a2893b6d5596d2ed3f551148529e01d1cfc1d053d9d058ab43c1cb98aa699d12509ab8e842f6eeece7d9f3c2c53f54349cdb855f411541c918cd5a3228ccba43aa2a44c5f27c191f6100a522c639f160a018b42c6c9709f99ecaf47d9ad5f430234f90079f34f3fecefd8e659119f4d5efb4140da0b82196fac9d260ed8cccf411ddb9903069cd93bd3d00da46f9e809aab21b9c29366dab94b32835bb4584debcd1ec1320e9c2b77a8d55fb359dba940b9c18e936ba050229d34e43e8250e708c31cce5639132328301e61a99c1b4f96e00fda514ce4dfb63c1932ee684ef1c7dbdd353c4679265ef71f4a7cd6d291c3d6a28ca677ec27e9a42a9c3aecab179e57a0751bd3cbb805e03138a39520b2c24ce66fe011e5e45527ba1014a392c50f96a7e4d648cd531f57f5e1c0d9be46ba194236ff7b932b7462b6ceff11e4e662168eed8624a6dc3cb09268c921c829dbbc8c0f9642109e7b7992a88c467b269c9bf5678ec90cceee461c78413c60ffba5d68062701b02fbd3b57b867787735ef2749c3f73deacaa7798de505c5d5147e5d634521a92813bc3a61b75f8595eca032d98c4f3417c44caf09e14e6782623db0742a3a6b7efaf916a441469f71b9f82826012391df823ecf81d5eaf53bea3b5641904145a92113cdefbeddbc00c8d61d8c68879952624a938085191df6bf95547a93edf5eb9df3912abd3f55cd9a4fdd1555ff9c7349202df3c7963a80493fac7713e1a1e40773c8e4c6f181b5f86eb819f3d06824702ee1a99a0a09f2f3f37a6521de5c36eed5ab04a9dcd17468b3e92221675675da29376f3b26ce4d6dab077c1a708fab8b2950a79de493d0ba87022f105cadce71b9caeb4fbce73702707faa1d7daa43353ebc63d32da9da7ba2835475b75dd9a71c5136cf617b537200acb426341fbd622831dea5a5239bf33a698959a8e7eeb91438f14c3e7e63971dad6e5178e08976e1b03d00a6e3a20ea1588d429fe9a25be6ecf4915d132e107971baa08e468b0bf2c15681f6087ec89cfe1dd0b28cf864835fae96c2f7c50dedf27d95db288f640a2345afb5aa9508886fe657e16b62db57c22ddd3b8d490c752437171fe7e616d1ef0b37c32aaf978e35f9820075292ee0279a77dae768c8b202947791f5719d1366a694090f461354bf33dcb5506ec318bbe578b39a4f0b3a80d81bfb64ff2fdf52f3c6457d49495c7744666706a053d62c33bdb102a6f81bafaf793a0cb84ebc0d52891fa93666c51957f9ab59ed302ad0b4e3ac995c5bd7dad7aca6bdf583ce7de3f86ad9b80f6b0e73f4a8b13898279e2a4fbd4ef003227aec9eebb3d3d36afb05591843063b1840e35375de2b9e1bb5163c673895c1db72e1d28a599cffef402b95968f148dc47872c607fc52ec68c224aa057a4a5d177eb931b317ba50c9edbbffee03d2f02a068aa4fd514d1a88fe797fb614284cb88ba9915f08f7fd14298f9cd5d221e8ea185390f57463097e4fe4a412557cc73d511b94a8e0658931ba2815f8c86c7e89931128b7a8ad3ec15bcd6d7ee95bb29d0ede12a74f4a365bc94eb544dad8586baa557944adcca04c926d3bbc3217a11aabed7d8047cc9ab3b7fc65aba38748f1f18aa96a6397724e2c42c3b074b86b33933871ff3ba587b8520215bd26bef6a440345c22858db17889efa1b809e7c43d508f3cafcc00de934b778f8f4bda6388d2c1c59e0392f98e1a7c9116d6ac4d20525e1e52c28f7e48592a7a5c42a17b3f79dda7a17afeb41dffc41f92271ec7e0de2b81c68bd9dfca67dbb1570eb14974718572e510fe46d89cc1427c68acea6fb2288f7904ec7fb8036152e2f81551cf244d6658e6fd3b1c5f9a51497c04bd21792c26d04aa53aa879808808f02f7bc225dd90e903d844005dff0e5f5fe0a077b849563ed80b4461e4403c5b2e54143f188bec654dd7fccb0b14ab44ac6c9a62d340a5dd64d1789370cad03372e1127e8260a347adbb5fcedb15397fd45394c5273ca8936febd00f0e8c4e183e25a78cf11d91e6724b95fce02ffd1be59f3a297aa100df3a5eb4f42b230d4ed6a671ff6d6208c7da852e7cc10181312bda5234ceae9ec3ebc42e282b1832e524ef00244f5031b91c140f4a1b74f4b632b81551fd3c67619f595d437e19de7168af0dce91794806013ea4e96dc9e530838561fa59250e220276b48557b531f25910ce6d6ce3e5719b5c4c7a9480c4f6a4da65c2768b8af44ea0ddc42372b0c824111de72de9326c5367226a02009e5ccaa809e36d86e3ee7211fd19ec4bb200b7f07b8618e37a16edf3533014d76f8cbf40061d3a216fe66f786d1ebfec90815c4c39771b5cc5182cc20c31a77d84f3299a80912b74799a506954aa0bdd823b2bcba5287af186fffc0fe07d5765bd29119e81b67759a397f778bafc717c18b54725e6331fb034458e3213bf61139842ac12bdbfb6289bfcc116c715c45897e321c2d856ef94a72e5d0718bbc6dfd16df0432142d545fb214f37008de62b030b4f46be007bf5218308aba9f96472f83b92c980846832ae8545cdbb35d13082dff5c69c2a4c06ef4697ab3bf3b2ae596c013a628fb11e5c20719efb3d019b1f960d2b0fe04d8dbb876e48c5c6520786902b27d0ee442644a1bde890be8c25965d7e68ccf5bfbc7ac9aaf14848b96cc874708dc087e8f59e6e37b25592af8db8f23197d19742c48fb6c887ae454efc7fef4e18fa84b8aff9119e6d22c1a38782b5bea8bc36b07453be3ddb1d4e66e0b8417135d7f5e00c9380ef7e818437d1424ac4bd7bd77ee8f70c3ea615de5750062772163adc379829d713957687fb0e0c7df6b5043ae3db9d1b5d56f25c35f4a0f6f722f86069285f57055b4c3f55c4a73f617c195256c7dde79869d786092bc30b3c8b6a62002e40846ccf3502b9abcd3a926d223dcf26e38a07b2680b0256604b9299b2c7d2b3a58989965a88bb051e67f039d53ed9c40e6e7c195fb87a4221db62fdadfd7ee595d465a0e8c9dc82aef090e3328f1147386a054700365bc67432cafb8c230456195dd6e3e186d1ccd68f7ce0ddedcc0c9ee54167e10dea4ce545d4f7eb2cf616c5c8140df95d1af8e81f0fd5e1ee3478e34353f2cef82d6257c04e3946c1d14d2073f1ddd782ddac9cbcb6dfa67435ef6d86e489dd45742a8f8be594ba29ba2889aca4bf11b47b339c5b0b4fc37bd353c8f59baab07976b30f93a7eb414d8473c3175632f3445267e8d3c97f5d22f4f1eab8b5d59bc708d6db6e1fb68db44f0d10f8c736ec96af9901852a0477d5f010dce82e43a9b7dad392e812d0da7d5eccaebb8c4a630a460f9b0cdb9d199c862e39f8318f3b570bda33e988361793589bafe79b3021c5dd625921f6bc63dedd5e48123578eb55fc1e1c679586a1387533d58dddbdd6a1247a1104186c9e18ae4b996ec7ee56317a5b19cfcc71c32dae0c33520bbe2992627cbcc12fef4a586838085967d6403661250b12d50db1e608b951e0ab880c52d626e5019df7afa0ec071f7d4c5b12b7bbe85f0fa32494b6119845cfe1765e96d96cb87754631282b5b902a5f5f0f97c956bd015ffea4c4fe20e5baa6a5955b0a9d5789ffbc19a15a89c7c45632336fc62fa32571f8a811648c0bb19a4eec8c80027c41c9a56d8837732f4f667fb8f5ac065b67c7802ec0ac5e75b54521198266bd1e9023e36f15fc396d3a97d085f704b961acdd42a655c79b1693574b9ee221d1bacbb625c3a4057fe304a14e284dbc1dc06f895a577cb509ca188aaafcae4a349ed6e483323a3407b6b292a659bf834ac0d6249b523506236025adea1ca3a89c42eef886de5ddc1d56aec8e1dc9ed409ece1c5a5f155c7f52b9db13665d5dfc89a3a80fabaa3d30bc4bf32f559920c9f8bff2b3fce1206f157d5007ae8875feddfb3aecda73b2fba4da482a2774832251f48390ce5adeb46bc6795881469338ad4d200c40cf9cb87a60a5582f3010ffd29d0751624312548949101cbbe5e67fd651c64a85d5234627077782e89a0b9b06e9995c19bf7d02f287218774d3ce33fb3d1c16128007c20bab097649bea9a2df9c70e958e66fd5a7b68bc8069e043dbd76444eb40d4ef985307aa2631a266088bdf1dff64fe6df9e56fe0bedf8246639aed70dde03d2f3f5905c0e17c8fcd4021d2c1ffc8dac30c5617a65de9ae2894fed3379dd1d0b4b2e0c33c04cb5be052511df39eaac0fc180f1c38f8acdcf249c685595db1122739edde3af8df14999745cd2456f33280db8267dd27db34124af5fae6b9e4b084c1ba4b7ca1f0e8d9454c6d91a9e9da03c8f6cbea324b48d36953d47c3e0a6b7461ca445c6f158d203afce9ed4ea6a8172607a84ab38486c28e91c005491a0ebaa285ec63473d1ece22391fa693a19c53d8152d1d0a9fdb42e694730178c9df52890fdb8d812d741ef2023a24ff80af89ba394e51a022931b3ebab699c1994842b4d2e433444df119ef59b7db3b6c55ea30250a509c6f22b09cc4fec54d0d407810982a79c69e4f16eb14132877da2875ba7f396b227cc9283a1c5152c20c36ac2657890d7a00c8f3bc31ea5ab82f6f4c7b18b0b6f815c917ddbfa468ec85e9153461905cc09586824331c91b3a72ed3bcc2070a9a26a28136cf7beede2d9e934a396dcedc600da8d0042e7ee2f0a854365c085099c67ca69329b7fc13da5c106a80a5e96c410f4b2217844771e4b92413d9b37ff750056851ad21f8a28b6f481eded1adf55bec310a281116d42333a5548c553e572f947ecbc1c404b2330180714b124aaeeb76aa61b3f0df1c91140d91d4ae96a92fdc9b5f8943283b845f9014a25657fe636ae453fb6aa0fa351246760c1d7e5d8e2011af51e522e66ec521acbf70f5d8b459e2c4828224dbf11090accfa282b2010a3e145cf1ff2627e7aa990b055250b2dcdaf67dd74bf92d77d0ef7828b016c46677a57bb65745d82494fc98e46290351433782f9cbbc55b743df5fa70755e8ea2ddc563580cf3b6dc7d927742af23e36a04bf00b06e3e5b0f9266b7b6399006c6070861d46f57993b7bfe84cea6ef3b4fb25f69073944fb0b3358db2acbc78a05ca6363bcbf8f903a80e91da0a8e9d79617939e975196dc22944ed90974d456f8fcaa46596bf2af2bca9261a393e51caa84d57c9980515eda2c4b67caa464bc9fef2441e8b5469ad0524377849cdea6475581c115306d0d4e8fde04b3ad842839c25aab46cc01423d282b37d2b3903b9159aac81638673e25e891f441a9a3ff9970528ad42e1f2372ee7a0e020ee59b66d614b6bb8d2c5f1f0e1434b6dc379a887e28ca5507f2d8f1c4f5a5a49d3fba07a80ea4111b219af191601ba1c7709f024b4e1fcce4e04e16856901950d8c42bf438b210a993be41be6c3335829c106e35267eb67c3fa5b12a2be3ba24fc74a258e92114c6cd2fe458c71eee70ee7cc87c26cb4fb27652810af004341c64614f20c50fbb0d831d25dc5f79360ec6338e28c5791bfc0099ffca9015211fb16422b82dbf50de8871709b2dc6b3f9f98b6409ea64c6d53954748f7940d1a7c1d5d371c1c089b4891bfda70f5ea6cef643fdcfa3fc74a130e6874bd910eef0739c3b5eca78efd6831e7441f7e3b1fc07b6c20434e5b35482f441e222502a230c3ebfd0561a2313eda9b01e809b460fd0aa533ed104c5ad77882ef3a1098e221a8ea6364578bf298eb48883004d68afcb480a438f078a921093594a58fa51481eb582cff301d1aa83c51c5162f91098ccb263ac3315aa73984209658467516a45da0c172c18435e51acbaa383d74c51f75fb5171664e27df940aa137e6fcd4e53dd37e8f6ccd2c1cff399680ec036739e6c346ee84bfee13ecd2c90bfb5e076162eed5ee5f189ff88b4b9d446bbe773ee745833c72f0b8aba173cdcf2a85726f638ac50b9512f1aaefba663fc24eeedadb35103e58d1486695bf9c0ae3642661a1fd354ce2cfd229887f19ee1ab72ca21efa041318a7bd0f9770dd25f0b98c546d2e56ff207d7111b9f08b8cd7d19c6814a00e2cbc7fb02fdf6f7b145f4b8784df7830e468aedbaedaf2181f8984668d82e439ad77709ec49b99cbe91d2b1a14955dd8e8a9d4040080742a72e365c41a781cbf0929e3f3fc19ddf3676e46a7bfb56238227371c48eb04a22d6cb6c76673ed1d18401984c66a379d8a24171a3bc51370bc1693786db38eb5146ed1850b00790e15aa01cbb1867dcbd6ff8ea73788296be6750f44fd116ba49c7107e5ecc35ba5e8ec87abf70ed4e1dc18f3ce92ffd9c1d364cc99db53bbfb5009fac0e4af14fb810f2c385631d45acd434cc9216276912607dc2276a8cca727b500d134bf127c8a12c290eba41a1051499b8be5e0e829f975a66135a179aa4ffa832e1fc870b537ec008ac8557d2593bc2a58edf3a77b4741c58ba2bbc3bf489405905863d835b2cb8b8d4aad4a88dfe3a7069b77d0c75990660bb8b4a9bdd55c95b588608d3054e0398001411366134238bab85545d32080426e6e8d433778e89cadd5bb2585e5d62a1edd1fb43fa7f4d22f6e068b6d545080a1d094940d6170ac7878ad6d7bcf9d30fa1a9d56d5455b54014f95751320333cfc81db473d30b2469f039d2f688c54496c45d59b6fd38ae475536c0d85041846cc2ad44b8a00cf82c864a11e0ab307c126e3f98ddf8321c78c3b8df9630d3e567e939ce3703944de095a83ccf3c4a7ec6d78233f074997896d0746714f9154269a734ab1f2782b0aeaafcba5cf5e82eb73614e27a733f05ef05458d585132d72074d997f331786f32b10a04f4b5f4db098467c878471f3ff449f25c0579e03b3ee1429d29dca640cdc432126122040571aa85028e64d50870ea1a7b6529f57646f7b7e80edf36d1d53046625033cdbde448781f6334e56499e58a8f9e54a7e9e618ea66fd0a112f05854108cb7cc100cd306592a0fa88c07b27bb9d94e962083c51133a2c842e6e808dcb6eba720fe89a5ce52d6252a8412ebb1dbbd89ff4a1c214c2d1c7935dad2cc86981d2ec19478b110358f4730b81d5b67345e4fa33a9a86b75c4c239daaccef1b48c0b2f16626a95eb8d26838495c0bf9f42ad8c44b67f2a190dbae79a9bf5aae3c3062cc94a61ee97c1205ff4863f87a7453c014f139ddb4ef16cf37750aca837c3c66c0f416838d52c347e7df4e9c3f77d5942d96e44903dfe3fe20ff3151e4fc86f1517a83f893080b7ddc2de22c9c667ac33d13ecb331ff2dd6063811c7b96fafa1ee8a46c37f647959fa6503bff6719ee0978fb236090082c8382bd00995f57045080927baaa97316c11f26c7cfb170f531615b83623238a277577901ff785b807a04a9dbd86b3a59a5cc84e9584a3f46660d50dcd32e2381e47727b596525df1bfb509b08677096db71a6c9b39fae6e384ada6f10410c8bdd2adb48dc42d9dedc9a604f2d115bfaf959f496eaed8a8dfe1d5c51025fd02f7597dab16b0401fc1ec5fcf9eb079e8720fe41c2bb914871dd928e8aa89ecdb7b1d97911d7aeb61f73be73b3429805814f2989c07c2c42800fcd5a0671499b6e4d167f1bf3b2d4aff20f069f80a79c8975d8097bb88dc4cc4b236d890069e873df181e48746d42dd94157ef063d0ec7cb990eb4de80caafea6f1c764f0dc1b829bcb04940aeb5f95642cb8ae91e07f58a8e4a718a191b8222b99ed0fca9c517e87d046991b33c8c05d9444b5c7ab2dc59f833998ac1a75f26ad822fe220d525dcd22760126d42c76063f58dfd14b0975f7b18cd1f96e2efd35332051134efd70fc6ba69a29932dec8760284960f3a60fb6b682119b70b0d1717db69f2c99819f70d0533d38b759e14f573497493d11dda2bcaae3d9a301fe30c2fa820f0b14676506d1deb3622ca331bdb2171cde9556f9ba565e2ff79eb9589d8c899771046fe62e23f1d3ae9449370a0a4e6b34ec1c8ab67312c4846eac01c3ec25c92425e38da217b2d93818a35dd8c252673637a6015733407e9f08b2caa64337b44bb752102cb58a6ea1d4e1ac6bff77316ed5b65957408463d8956678457e648d215afc7a11480b9537e2782d099a64aebac5cdc36325f747ec8b389ea3c4167ffe4db6d0aea47f05da5d3dcebe2059b3f998d4be348ed8da72f541070b0d9fd46515b0ecb217e1524d260cdd2ffbf151f7e66e552abb1d1b050fd0b2b8f8373f420e42ef4d98cc166082895aae698861b3376411fb256a11a7046c48c25c63662c3dc09259179bf2aa0ea86fcece28376b48d6aa1af3acd71b7297847554669f1e6012a0fdcf64bd995fb8a70274c8531748661f6f197a1a28fbf943f0d9ebf3e5b68c8e8e164836729b60ed0f766ceaa9b6b911a8b1188b0bff70009b1b010fd5184760c04f8959e32699f2375f1ee9b3b86e380c9b4b8b356466ac9867201b43621e2b5c2ab19adb071454dcb4a9c0bed763d00ee6543cf22eb24e190763054d5a781de19028cddb5b8f6f532a9e433737f4472399f488bd9f18aba448b23f95696cdbc43dceb4816d08f8335395c085316fddb3b6606033b6918fa62525abaf6f64a96ee43bba9a9a3989e32d2642278d9d7e56000fce5e97032584411ddbd549ef875cbc167fbc547dd7f487b3e45f59f5c22a36e3c2c74c2fae4a58878ae2b7a926f6a64d6633e38724e52e90c6f1bf24c819a2465778bdfed52fa7354a08099b7cf6910b489a45a0c05bfbf5c95b283f14695c6ebb9d951df714e7ba8484dd82fc409440c6dfc066bd58d2b01d014acf430fd65476783f5532140e57bf385069a94a79c7e2dfbc325124ec74f11f50b79490d755550baa2185e6a651ac9a0048b02dbff90f1e5527f37f5929293354b9b956102e409674e751e01a9bca7686af6ef7cbd23341f45aed37d304c5b8e6197cded9e872882d2ffc4b3c822aeed313b16b21d23df94d3c6e9f1b2941e4f44daf6f3f3aecc2eb4b70a756adf2b62ee98a9d0022fd7b777e645e2bfb7a8ee6c8786b2b8f83c0001a056368d88285269ad583ceb26fc070a9c4a7e6f7b1ecd942dee1c6889675de830eb638830c2f153b85c29d48f73f7ff28568d5054c07ec39b78ab944a1dcc7c8259323a4838c09511532dff1226abefa2d0836335e6cdc26d8605fc08de51a9071c47c73858ba62e8ac12d3d179963e86d31270e9c6c3b9794a30b41a98335183f110780c6bf75d4f52bb6ab4cab4a1e3741c7966f5d2d6d83350205bb401dad933a7eb49e03b3da2a246041b645a2018a42be052ea30e510f4bdddbed4cf7d00849f6dc55ff7c01a5b5ab5282b873058c824de66afe8572bc93a7aef4bfc75817f35cf7afd156b79b27198685d9715904739a18ca1590b869b10461b61bd3576ca3d6510a7e0228b4c7b3414481504024eb3b9eee9f2c440aa3ebd9d3d33a20d476db30ed12c529626073f4a6b5160cebc64179f8e9071a58e4cd462fa04727f080405d55ebdf92ec3cb3468a99cda5bc0c4b64a6ca8777494199edd5887abc95c3cd71f569fdfeb171326eb843b67cd774816f63ff47d53f5608f79c6098649c14a6f1b304a71bb009529e569bb570317b609792b5d194765f38b6695546e2e1b25852c5153a58f17063efc8b2605829425dee2da64e60575dae5210f827f8fdfbf972c2ce832d5a1673cd5c0dd803d22ec15237fa0cccb3024733c5c74a5f0c357ec1a710f40cafc5f6ec41942b17667147e43b5a4f870e80dca2eedfecb689196cb0269118dacf36d2b62ce12ce1b8323b161bd6458c9bf20dced31b193be9f83b55cbd9f6e6dbba901aeccd3b1e48d90e1e616a9fb96cbc82d32369993343c07849136d4dc222055edb09e059d15378566b1b0be974168881009387d93e7a657479ae5fd76e15f52a7a5e7ee476d8cf0729c17189497a962dcb140b4e48be4f6c573af82dd636546f84eb435bf74cdaa8979f8bad8d00cf7dd5e027fac51aebb982abd427d4f0733e449ddbaf55d9e33cc70c84dd458e68fe18e82fad5300a7c3a3ec75366552ea578f3b024c3c2ed6a681ce91b95d605a1b8d4e5e8a1016dacf8e51ec776c164ff47a4909973861589389e4a4ca88da5da14345f46cd811e2f78f8d3661031d6ada458c24bbf27c74135ed8c2b99d99c633fad4759b8f7f2371982e356b940dd9c130e61df7f2f1a762ce0c2c6088d77aa99154bf74a4844fd3c6ada847a86d93272f45d268cbf4629b68e2a630e6f0c5d7e8eca8f62f19e97fcb3d646abdaf08d945d891f6e616707df7baeef69f6e2d9697b5154f51d430436ecd82fc5f3cc258f974a5981d701b9fac0fdfd8a675ab25837d6da33584b5a935c31fb724058d9ca641f99c1e82525db475577486caf1d75552afa04f3869328604dbed5afbbe7b6e3acdc2321dc76796d26efa3ebc65df930e6644ec8ad2c1b2b9ca2719aedcb2f8fe5ca35a6bbbe6cb507ae9baa05a316c9f2d446a438c8b75551ba53bb029961c15b868885d79f76312ef9c8f508dde94a277fe07f46260bf668717069fb86cf2c7b436f0444bafda938811aec89484aac43c95707b2cf8c76150649ebf0e408a826d46bb399944f8f1e81810c408d3940bdd3df10699c9fbb7381cf3d031649e4643a35ca981e917f93a905d31674832788f835344fbd74a1afa67a8db5e1da0b87b6bfdf417018f2062b243a3a9cf3ba2571fb2946198af0dccc4b05512b0003a843701a39ba12fb7beeaa8c3322db1d56e314fc7cbe86d4998bd9d54bb40f5416227edd42be1ee7e0a83585f7a41510e0822bdf920e03d241b6e248c27a82f8f6251fb3c3c0df7cb92414060efad647eb62f9b40f62dc9765b81b896e725d2a04d1b8cf5fa9b9653833fee33d957cdb97b00626be85ac0c2159dfee4f13f1343f3e1758da4167cc270a875a6cd4720baf1e20e8b287a212cfc44504ff6994029c3eae5e1be4f0b7a2f6397b4d7260ecdf494af459b571a859e820c023943cc6c50fbe7ee46cd75a17d13ebb1c6c3ec7dc7c15b4236eab058951c3ce8789468feea29c5a966387ea43b367baf103ae8d39c722080da149b8bd8560456391ebc8f8516036bf0313eb08999945fc025c766d65ad6136843eed983d5ee545188ddfe2e4f0bdb83e295f435246a2d31ab212ab562d25c8b97544fdd428d5458506d14fd2f264a89dcf0bf3716cdf05264851fe1c9b93c966ab2f818dc0f330f5f7a9f05e77b71c48e3e8ef452fb9aa2462c843552c6b4867a394ea789cee8de6337eb6df5af4565efba0571b7cc9d26be1c1a98fd5a3f4ec63554a1cf2563168df496e76084ce6028227adf33d5cd4b96af953a79197052f4e177aee42a0602ae7557f8b4cfac632af662f950f1ff402eea446bba1e80bd852055532fae34e04366fabfb53f2a54d271500bcd85de1bad24ce4033774d6f97e4a6514a695b1f95a3d71cda83743c8d450bbcd12a9b87c81dc8b358cdb9d9d8b003998c88e1de0d291354bf88d3859e251ffcbd55fab055e5e0a7c74bbe04c641481065f824077e1a33a41422d8c7d8f99fe396c90de6eeac6d337eccc764d250528e9f0bd35ab5edc591728367b8de52c896d867ecdc7cf8cbed1697fdc86cc529c16aaede7fc30aada1cbac6351fe8218735fbf1dcc981fbc49301e63b0e951f015baf9fd82fba174251097a22ffb9de70b4545d9fcceed05bb3ff2bbc847ad2e9c6f7f5223ab07e9eb7f11104d2621971496d38dc78b03cea5b346e3a743c6ba48e3b64cd6122ef3c73a31211f6a9c953a8f81c64b870165661772b868f3dc19319b8b5bcb3b7eb61a6bb02e011ddf604021e6882b14543d264213458c5b7937a24673cac14a8a4aa5217a30d5eb64a9f5bbba4ee162e679395720cc33f83016a5ac6a593a5a1d4609416d00d8989c722fd40d5d7d7e015328525785e82553d75adf17060f5426fcd0a24bcc170c3585a9cd3ae38360fe74103cb590f8a52904bc848ddebf0992d2ad98ba3944cf67a41d442dd9d8602b5455a314c5c1e2708b5a26a8b829b967b7f82b8e82d554076aed7c12ea6506aa7ba68fa5a058d385cf2745d94c5ba851ce427e0ac71c4f72e7c2529889a5b987b88a85eeb847ef02f912f0b7d45539b2cd3d522ab169f8fb04e66ca423848b8dfaf522406700607335378233c8f7b11aa1f8d2eccff1acfc4ab53edab73e5e767b7ac5703fa6527a2d3b2e9848b9500b8be53ce0b6b27249fb90a0beab2edb2f80853814829fcbaab9096b6b96c83bebb48596b9e25af91bacacf8569001585481d8502faf5511aba7507ed38acb77d6ea4e03f07637bf438a669a4bd3b19f745064c3427409a6fab5d54840501cc6e30cc0b59f0913c3693fe5d7c843e0f56727ed2f6c9fe0227a23ba314601707b680b16e3c41b3d198afe19861ce6433bcf5cbfc3751b7e42e72e5789c32e4570608502eabeef1967b09fee0e04f8a8905b50bf7d9748e54a5d8ae22eb3c5545c18ae03b96bc469e7943b8bf5eb026f57798698e35452c60b8cd9966b33705b72ed455e7e10cac4522eb1783f7173f0b17be9555209669e512f624ee4586dbdb6af980c59ddb059f5f9fc3dbf13cdb5dc6acb895e147a86d8ad3e60302aa4229f1f50e5abc857dddcc82da0fe4d77db190c4ae9f53e413c1f88c65ba42c7df90088f75ea86955cf9371ab9ee09f39a69707651b68e747e44dd17844be3edd9ebafe633df46423c6e6439ebe159b4bfe97272e964c35f59ee62d50bdb8a82f992e9bee9e028227feba88c6d0b4e3d4ef8ec7c0d1399604e14d656c9f17078ec0f4753e25ab5d1a2c6900f95581972b19a740680aa7e997f127a2de68d466378e4f84cd9d3afef8c937218d22fb7745f3fcf3865e90ad534cfb517215f226fe750d1e1c180d967e9eb8b2afe02f122b19414baded95cb4991e8c94bf9d45628bda26326ec4fd31279b0f90286112c9ce306c1e28bc5a3b0249690693fb66c0361f2cda2ac9363a83aa15372b75f5f3bf0cd98e81dde28dc129f0ee520233e6169ba270dc765dced8da6c64139c80cab188d0e4f6510f03a8ae8729fb315202bd8cc5627d32d4d055b93d410e7b346a94e24b0fc1a531ccd3aed30481352a53a295025303292c1835b5256ff5124b39c0586857a63fbb4dcd8603da45b22a302b5853580bcf8104e7fcb72e178b14696e2fffbb95401c30530eb856b3dfc31a863603968189a195e1f3190b7ecc3b411f00a4945f4e3cc07ac4636039b1d0d55dc0193428c3e6f2a0ab9197158b0de8babf704525d756eda7fb98e77095f7901962a7115ea81adbaba730c0fa22e739af1cabd4cf8d54cee41fdf787003ffafc1429e2a84d535550b94107057431ef69f41f2a52c0e1ebed61c1a114efb09d98fbd4e9c6c07dfcdf8f44a735aa39e50d2c2a946a5e9b95154b0c914b0803a83c5939b0d80ddaa7cfe3455fc66e5bab06ee7cefaad1507a4716fe27d8b26a1eefbe066207a3f4f3367a717d585e119fc33e617cb386c91414972e8901a3c864caa8e98c25a4d160889f1576f1c35ec00187734d172c2a1a65ac4aa95f48c46ddea788f91b947cc55c942d973edf147892fc64d19385c66fcd60aee3441020b7091c35ff8a3a1f960f9a7040f9f8f4d5bc3b32ea5cdbea71bb04f034d195a1a01a97c64a3bd851aa596c5e3cbc28018ae33e0f2a8bd606f47ae8dda728233ab8761efde6585e50b456d7eb75626950f5a17b6b1d5f57cccc8c389e96fbbe71633c0dfb03a4379930914b926c52f044e2f0738de9dbcc36ebfee587a870850db8311ad059f8332f4e9e020e2daf3c53e976973374d94e38c9711ecb926b82c9e9776e10b9cfb39a277867ff9b2319c6cfc4d6215478c77d8b852865430f9753dbf2123af3d84e28ba0b7022d14696014f4e41778e88fa9535d5431b0d4649aac01c0bbe690c3e08d0374debb9039047e00e7bdbeceea47c96af9eb51efa5244ab4ffc7ea1ffa8161f59642ca7c075a9cb97f72e49aba8f62e28c551575bd1f532a5ed5ca02b945435bdf323652f48d517d130f958f8cc1135b07db736e32784a9f67912fa9842564ffea3bb90e8d7bdbe69b2dadee8622ebaca67c7198c50c9ba327ba31b5679c1d7112479cf5ee1cce4464a65d360f8ff188b5dc5b4fb3dfc31adfcba97845362bb852bf0ce5aa02dd443dfa4a258071c2590c67a9c055b714012ee8c49a768404abae6af1273b08951dc87193e87fc5f8be87a045888692ec2a93819349a5050ae6b8d9949917d811189972c385804ab642419909c858d63bb72ddb6cdec07a47ca80725fe9dbf40a20c0d7614285d3a0568b3b8dd6a80e08f252949c4de1b52027f13910f0af214000d29dfc1316d9e57decacf115aa66088c919c464f9aa4cda740c0929647e597de3ecca57925e8e05af24ff6b4ae9c156ed360bb1f32f0258147ef69ec1342e49f58db83274de25d6ebf8fc542e5af931070441ee47ae9cb13d3aeafaf768067ae668eba4d3091c1a5268dfea6ed65d3c5aa61a73f98a8191292cc26da989cfeaf27e907600ad0e602ff3f085e532b73af8188a9e6424bc27a5f0869f956a7bcf59b8ef5255a356b9b36409bb04ead39f88f7c185bf3aef4c9e0ee64f22962fa1e0049dbf7b35cde5e60aee0b95c79470b3fad10bfdf964cddc066c4791b80ce05cb0fda6240c6a01ce9528e3f0a31848ec6df361b121d989311d97d9cb614d8b04bf31c1536759e11ec2e0685bd310605a760eb999dbeaa792c6291b4b5b09b401521bc87a7bc188e14a56b2116ce2d08af5524021cd898240b6b7550e2375ddfff9253040a4e0477661078fcbda40cd388c72fb8dabe62bff9aabd5117cf1c0418cbaa5e6e6c42a102440439c96dc4675321a954aa7beb97a6285ca73e776c803627399c0ec8bf4f5b0cd7b7c63a68963a4e81a6ce0aa54ab512897c3143c4fa4cddf151b01f2a837cf4748148889207b8f252a88892bce6733fdae2bd5e2374187147c45565e685a87823be3d0d255699e708725f1aba7eb9a47f067e6c97c33c14b01c8fa644788d914fdedff461c11825b68c4372a2b7d65ee02192d72ae233d83e0d1836dee1cc0b6b4b392b794699c47ffa54b599b9d1a0feaea41914e152d0cf480214bd0ae3c017bede9b2c7793393047fd34876c20de479f108a9e45e27b00ff8752347650a5cb2164ef00ba5bd27c45a1babffad81075ca111cf8b366ff5d0eb74b4fb9ff6eabd5f5e81ed38606c4b38be1a1d0f647682699d92007433e11275b3e8b2553a04eb4285aeb873d2ce0f52ac6316eb748cf862e2c219b7829f9a9485d444bfd793949467ecc7c2a379eeee7659a5ff088da2c73ee92daca69ee8cd63a644a400968de335b90035b06699c1b99243f87c500fb2277eb8b71fd0a8f3af3f12416cc1ede6300b024532609f731949ccf9392bd8d9891834bcf7f5795f9cc4959adf1eb97be5a716ccb1617093ea7d673989cb8d4dc5c9fed8d3c2f8a40ecebf6d616f634ea3c6fa400f728ef9bfdd09232c0bd10889f7339840719018db40a1a8ca3fab9966a66c100023aa5cfbd8f83a7f2c53c053c5a966c71476e271712bf77535ad91b712f9abda11d1412653ea36e53968fd64d78c348882557c9433218b51b6b84c3e08409dfd432afd7cab89f39f993560653db7a965c6c3d5cd14d2544076e2b5d4a459807344b02d33b9d8dc2e56d58893ec9e5c6c5a4246ddc46f225fc8a95983b8df3ab2a52599bd1f70ad7706f029e199824004a823b70c8e8fc79cee7aa6a40d9194bbe3818a298c90e23029b7636158dd89f7ed8eca2d27feda16501e331e298a4bb2f61c17425f38d91d667eda46651296cfd9d084c19a2af09c8c5431b98d3a9777fa8aeb38a756eb919a25735dfe491802e5ba12808848306f8a50e8de80209f2cab757a584c6599fef566fbf4695c18b9a8f4c0fa2d92a5aaa47d9b9623c9f1c1757fa6e90c4f827528f4196db6c131ccef80c333cece7ac8ad407db1d98ec2c92a5a84a70682ba845347563ece9f08df397f40954c06daff35c398d1e8551c6104838bafc407e44e4735c1359cf5fa4cb0dc3c453be657a48aa5d2df3131194395c3ea4b7eefcfb389f9484b56556264e3540204852cd7cb2f3e798f56cadc496dcd74fc5c546e8255d7dd1ad386599b51189485c07f8a93e8c07d5c3e0ce1b3e7edf63f7be63ce88ca6c0dc5108c16f88cc8e30f810dc07e7a68796bee39945ce5a86052a19e1081d9aceea31bdf8311424f919933247d1697f77d3b3f25e1546d70ba977c266995f4e427624812e47179406141527d24cfc69ebb299497538218d04f77649abc380e341760f2951577631f8d9c7bd5c7f9f69c3deb73c0eb774fb19b9a70272b52dcbb2ffedf2c25bbe1a519a0f6e6b564d6ffd522185b1515af4b5990ec4e249ca9ba8e1844d4f2ab1453abaaed95b98ec0e085ce446f5168873ad5978122725ff89541b952df7c48f326e2ddf328684572ca42f3c3a1efc109a46220d3d81082acf76e4ca9ab0fc0d333b501433e968f5da76afaced36b2a5ffc1b66cbe64ab1b1cd3f561f49942ebfe9b733230ed77fb195cc6f5d4922ce51b2d2258c987696892de625f551ebd759fa2b955cfe27ec9ce7dfb5d4afa72ace3ba23096f622a4c3f1bbbca05cb047792489b59b796330104746ab26b380b386382b01c77d283a4ae0b15b9fcfb681a44ccbeaac0e0d6c027820191c67c6cbea00cb8f7fdff422af82ab824c4b603f764df7b430ec685380f1fe43b65cd0e15121c65334a74b78ce49c0cd684cce3d5c080f70ffc35b736fe0dd01c1b38670e432f39b837c50eb777072ec30053931515230fb779a47689a1b2dca4604676c5dfbd012f012e8f04da764f4a3a308dcdad25b403d9c69392f884f95dd849fdde2c455902de024605a8b34baa224fa678fd9770726905aff5028f0c2b899f47ced4d6ee84370dac4412716f96b235751709c6535b4fa3781ee70e0a485263e1abb0a07a67712fbaf15fcb26d23bed41babfcb6650c654495b6fd1d94fa9e83129354346c8f3306ee7e7e5339000965e5539ced07aa132c13cebfba362109eeeb239eb010b3f222f3868e86ee82860c4cfdc03d3a519df5bc9d8c6d2c663d99805ca0655f7f8edc952faaa99e03d307c43c2d3c088610799930eed93777ef59a8429cbb776ab52fad39a1835e79093409540e6ef718167a61ac2b5efeef144b62607f859261f270938f4620db1dd58b6f24a037a89b8e41e1547d17023db4e22fe8725e2a2542c0165f3262988acdd33f1f1dee75335eb2438cc08468dd4a6a3b818ed4278c1d5285a7e5dd1cf5da3a054ea84046b8f53b1ad2dc5a2dc4ee18aa0b7197e44ba4543efdb2ffc0177502eb59bb5aeaacafa16a537fed06d482a3a4e763592a268e5d4f88090cb4d76052860e961039a9b7185d7842491e88d438ea16fd87e996b97fd890242a4ce748fe3aa6d22d2ba87078cdefaeaaa1b9ee28dbd4646dcf2079f630c653c55a33c799e6ef79a75785470c7103174c5e066e2153d1bacbae791efe93f78dd22443138bbffa35ba1c67fa4fdfc061d1825f9904a28c8472e73b87fa872164525a6b9bcb0b3e422b53518415b4bf3d0d5bc93c0976d9acd400c63abec6b3457cdc223f4d35f4860a32dd43c94016b0efe6e06054df390c11eca9a7714ab88b1bee15cc924ccbd1822372249f411c97e6ed0fc9b8ea939f652181fb3d342780af87ffbaf2f180104d925bd8dad2cd3879e0b57aa3cd0c7892c7e2f537943dfcdf0b9fc2cb520deaee01fe7069bdfb946f8324462716af22136566da458b34cc9d0c4f7f022e7cc550816621fb6f7be88af7fda1b0f5876cd7b7e060d59e0a089923ff4e1bc305e13be7f24804633e367dd068e7096f1d643f26f0a2ea8141cbd640395221d4ffe897853a8ff48aba9f6e3a0244eafc0b41936d4cbe8510812e0407d576e0f9a553547f0ac8108b92c8a0540dc532fb1089418e4faffb7c657b03cf72d17be7dd919f4b364d54f07383e41cfde4cd6a7f47b1dd81bd469815aa4f99d4085b42b047e9db3da338cc016bb1dffed7dd22e5039c9c75202482b1eb0fa86558f4b507543204d1cb44edbcdbb977634da818f8a62ce8a6d6ba6e804d70ffa93a4ae16ba66c405ca92bf69ec0032f6bbd6845854a8c7897d14eaaca94fa266628c57fa2453c3a36d28ffcc90341852365e38922cf08efcd7758717d3e0d75fa0ffdb9a6fe95e5499b82376a7f158619a124b664620a86cd8b4457da7ce96ffeb4abe12cf8f8ffd5cdcfcf3967128d7b3e72ba145b34844e843421a09d783b619f07779d83c837656593b6fa5e4a32476aeb24b0f1498e022b7ac538815042921582a9175f432e022f49cf281d78c7f1738b5e0c0ee8f0f7f01e47faa0d36bb0950e2d5a3064bbc4f7e0f9739ce21f94038522f9f0132829cccc1350eedaeb9b063d8243c41a3d9d5e5848f82abab5e9f892bebe8768fa0cf46da1ff9cc88eeeaad4bddb11c8db9002cd34b852e2580868dc893f4b448ced8b79fb917255d01ed28caed03db8f2474b00223289657d0bb6e87dcbccb533b15bd431f0bf9d06dafcb8f35772d92774d90f6d5875ad6e8373ea5b94290c6aea5f5bd3a7492c27635be82ff30347b39027eae09ed7ae7a15f2e1bb3cc92c40367bdddcbcad0334076cbc7901b056151f69a326f21757be3e6a958840e11781bad177873606e7563c0eb86b69598213bb1e6ce7a54392bb855a1fb480bacc85d47953cf33199ed7e14914295815dda1f6ddbcb5ab6395c278cf23e1c71d8bebcbc3ef53d9f9f0de1573b8408379f0e58666f4c80dd286d8124ab4d28c235d411abc76f9ee6305cea0d341dd83d8cc4ea2c99bcaa6458739d786c971dd552663c1509bbeacb21fa03d2b85ee7735cc714602c799c886b06ae81e48cf52b1c43584d7907ff6024d5219e25f4f118383cc1a7efeffd187f4268db50761deb5ac0b503cf05ae47ace086a020c595a509e7913fca1093b0310c07cead719406bfdddd67ba703fe436505d4bfc62f5fa9ea6ebb93e8aef39ae0320fce257bf86485b32a872a18395bcf062b1da99a27293ec2e3a3ab6811066f5ba54622226fb35231f7bcf3c239cac678555d87f9df24de8d0765cde2fd67b18e8c6a3ea8a22487ae5db372fb673eca6c8f6c52a6ed30a735bb7249eeea25e5aa36b37b1c00a9c4d1cbe09b055551e943541e47464d9f2749966fa80aee5ed6d2cb51aebccc71f20200db1ef9e8ecb47ee1baa25340b80dac8fa297a61481954ae265cca23956bc02be05cc828a7e5491382f66043a5b6f5618bbcc13e503637bff5bd3534dd6378ee66fca36b5f0fc51c2b525dd0e15d5e71aa49f2910569aa9ad3485f12e25ec77275f563f621e7a5199ede65b2ed688fe61b4d4de44b212de997c64d376ab9dfaf7e60416fc0c0c08907438e0013f0f042b0293dd211193568aeb60778e1c9fb1eb45509bc59a656ba2e211c84c5a3b5c08f26c87638a153f37aec5b99292f4a55965c1a825e17d3796bd2d7eb4fcf07a13e575cd72990521b037a694be45fdef5af0abc13c8b994ff7fa39e7dd619dfa5fae9f01f02f0ad65ef21483e2c70c0026433f92f77b2021e719a37e234b1d01dea5bd298c69a15e5e6cdbeca5f6ac0d14394f2d343588ac3f5147a0dd68c7acfd8689746652a75c67bd5daef96464a1ffae1d110cfe98676c49e16a4006be38de4434465705b9d5123df059e30000e33633fd416f60f7dcadd3dc731a992073128261c7747eb0dd3379a16a5981ce83bff386a099db61281078620daac21b9e039a3f89e63a0e4e6d6eb5330fbd600e6d3247f3a1f59cd93418a33d02b2201cdddac1a18259deeb66bc6c2db506d56015582906354f0b9c97f2706ec83520085c177e2e06883b0247bc74809ac401da14674a0fbf91f08cc8739244911655f5dd5878b4f51057fc712319388734df0b8076f3195c71e1eea29a7e7d090b671645b68e9383472f934fe2dac2d548ba185bc80d9cd593c75e9b254e75a9819c993b2f9cba2592df8fd3f78553f172a7bc229084a1be122451487e285b9710f7916965b5d1b0f318381ba44e7fb37ce52f76e31769fcc590a89bedd0f52f78123c0ea68807cee098345cc875d556fb4797ab490e3730348f3c135a22d8fd43bf353369efef5708da24ad99df2dbbec3d3c6a46f7a69e41a40ae88a19fb1711822e8a56145efd5c692b0b433f75ef25450c6042c41dd1d2a2a7cc68f8e1c4ca9320a01854d2735de776911e267050c9f1cd9201569eda2e644851ef3988064ea06ffeb2517561a36b1fa2a83e872874f891e1ac6c9597d530c83c320cac6f0787052c8e032cc1df8a7bb20aef4e3a9856d230102d91cfab8ca14a89ce514e065664a03a6d0607fa66a00bbc71e91eb3ed6b3a2612e7ae9f0ff80a2a6d5b21af24693afc73542b3b784e14b6b5fa01c4b5c9b605563861ef7504ad08afaf71ca8466cee01a8b7e87de8bfc0d826b6cdcc96e8d0fc9e241e546874137e4196c06b8ae02128ff1c133f312cce0de45e7e91616fd61e397fb69027518cbbf39ad5d80206e4e6665d72520d53d512c8cfb82dba13cbe735aadcefe77e8074abb842b8bbdaa3bab596bafeacbb24dc04f47d373e9b54a0857c2d2f69fc31a703d917d5bb62eb80fd0b5799174b651f8a39b068184fe9f38fbba6771ebb79e997d980903650b021fe8edc600bb260273d600ba7a4be7da01f63a10ca68dd8b4c7fe7cd4eca78d9bff5807a69a0caa9bad9212ee108089783726c8e5468731a0d201b530745c2d0d932e7d2c3511e4ee84240797c972e4f944080f4ccf19a25f98e75d90fa3027ae5deaa222d117e6881231ab81e195fc8922acc2e14767af6059275f1b891f0c9714fafb628dd3012cc417141a9283703b7c7ab45e552a36598b450d5c2f8443a607b1a11543facffcb60bbb1b26b8b7cf26982a3404f90c7e9ca06f6cec739316c09561ca58c503b99d9860bf75800f8e5ffe9a1f3317fc38a97b02d43b2f6a4e5473f116ff998007e3f63921408fd96de97e1d4c8350622845bfe0e6ef16dcb07d83f29040e6f54fec79b2c0cb83f01e4b9fba0ddad2b9070961246abe84c31dfbaa452c70baa9a730cdab98ff7861e79c615c38c1ddd90cf62cb44fd7882c63f7df6d22ab8d1ddd803f2fb25364a6554b0f4e3e6de57371abea6452867e8a1f64901fe47266a04dded7d6faa91913508ae877943c52f8a7add5aefd9354385a06ec2031cce8407c4a27a24c963a2387786deca19d29b3d31e7433bea984d7fd26a99ba6c8cfa3a0a6dce9c6d08d3ab76a439acaba8718625ae463535f7805d2d146299a93652349fe0392b81020c9554e452bb91014da2412242c548609818c53afa702912876ac0ce36a080d7a06b42c595620064dcb609b09dc81605692c922dd492fd17cf78facc0883fca2396b955adb4c63aed88bae66af7aaae23b9a7f1c0f10f75a7ff2ee4a9fca02aa9b1e7bf137a519689c2e72d28c24468ddf25a8ea739d77d5f4a68779824411d889a118fc6295355882989fd2774c0c51a7bdabc75fc994ae85445c89cae32773d205b0d406976a40beaaab149540797cc1e90f242b24efdea9f3a817dee925a57e4f4e3a76a6e54d49c746fb9b426165d1083544753a34cac19fc61c47e630f8a7af44b4cfbc34eb2174a45ca6d96b870cc4f37bbd778d92d064b5a4f06aa63b34001b66b11369167cca6140b92780686c2461060c77e9eedeb543b02a32c4d61cf914e488be8df0c2d8b45e5d1141b74c841253a41a7ce8abbefc3c10d933cca99d0f64b963d7564bc2e8fab212814c4b3d216f6b0307df042bafac4f14dbc3c957778acc43ec08fcf6238ac007c9dd74c7f26d8d4c0243c167dcd5a758c4c2673b38cfe61eeb5fc165df5c4a0c8e3e3891cac904df20c63f257974112afe48e482c162a86796fea91c44a3c58797f26d20d1593c4a8b19b5ca8e658a2cac09541a9a8e9b51701e5569595472f9ab37a1480000bfe2ff74c8ab58ca6c87f062e254a034d363964fe6e30a3c8bfa04b8ef78819f2716cc21e27a3c4a4ec5b4a2402700dd28a83d13601fcadf48bdf76f2753af0562edd04bd6d90af493e95200315f925495d6cb548cb918ac75443cb36e85141d765d45f489c2f0145f4b1279ec57973dc6286793c8f1c0ef7349e469baafc58dc6f4ae0d9ceac42658abcf289d6fc2f578d944a01bc66d9f26b718132329a47ed106f7b0568fe875b94bfb93daae133d5a0a0b2fe9d93865c1751f6f64afa19a61dfc96e7bb3b9da17ba882e76de917091f4956c3ad21e5567b523f34f2604d63cb1d44dcfbedcce67f7b325dda24aa046145787f85539b726a067e4adbca2d91fb81d5d7108ae3a808d23a5d2b17cc924e6a8cd2ab469a42f4139cb43b9f85c5ef6501db53391e8997ba15facbb0c4631c79c4ef03b91ee842cfcf6959bf614ce3bd4c2f7e0f7c66a548de7c847a04fc65575907c5dd976832d394d2f5639f588bb5e6590fcf79d40cb3577bfdd5f555c64fe5d0f75e28be7b05bace4f2e77585d297bdd9afe27d4082b038eaa167c961d03dba0834e1ad61d30dfa4fe54212a93d36a2ac318f4391e21f23c38cb2970fc47f2a7dde4f76d5b5eb08fd273c16c3199bfe51c940c9d955b71bc35efa6dabd33e01047c98aabe4e1d86bb2a32fff5576dc781ed985a2301abb36d36fcf7287fd6de6d5bde8f22636cf8760e6e0877deac83227a6ac3fcf17162aec4353aba56ae0e26b6abb89872c6bbe8909b94ef5b8af437f929223e18aa7b2fc61a68c60e27ddb1c9b7629dcb13575946dcfb33d89e922955c58c6970e6d5253f7964d0c97bd1bc70072b58cb36a431106e45b926eca9057aaef09786e683ea01b2370d159d37d436d8ce73d5c3d98deb121b2efe52cd12901f341317037eb072a8b3aadac6d55898f8bb10e9a631e9ce8553144243febdb0417c0daaabcaec2e85f736623da7752d8e11cf24aed6b5b8e98be5ae5ee0b5a2156b821058ec666e75181637bc24780b97255c31547fa4fa9efec16df54eb9325ad89e16a4381257e3267a950bf6014160e843833a5756c3074f43f974179421274911bf8af14591cfc94d38fe95c6fbe5c1419d246d15e04f554cfec8d3bae5b2b5a837cfdc84f7a44173b81d84ff4913ff7de0a571cc3d7f09ff87ae3ced3f93ab9eadc2341f41174af431bcf0afd70809ea6e430ae661dd0797ef28e389b243f62f02135283aee3a3a9adb989c0816a693a016ba853fa2d7fce46a073a6fe336912a28c6b442bf663781e77206ab2fe36267ee4e48b9d8c6f07684f2f0c23ef5440164aadcfea21b870a1a78e8c2e8285662822b9c288802cd548e4a55ef9bd10d1136b1fcf44d511f87e2fac00d249db9b29d5f88e12cbf3d9d3f6bc8723f24354815065eec4df9d8b62a3074a679caf556b07d8d8cd929fb5df1298aff70f541f181e8b036858159065ef21a2208eb121305517ade22f25ac43f0ff44a8090530106b218ffaa42ab86a15992d2f3b3b02b0d68508d84d1a17171feb81cbd025dbb8601467dc23edc4135bd59cb05db0a0fde5369542e82d3b8559a517137dca4f384801ce2f98741bf6aa6bf948f4b3cfea33a8f748281f38f1b988c105edde5c7fac4e7a218a3741f5df71f76e167b7568c1e2c0582cf567d7612e21178189ce3ca6817bec41dd7809872b8f0e43aa67577f8b0ce2fef67761bef32dac060d8f991e525b03f92c7d52f8cf0d258b56e7b63bea722c7d549670b7ac2cbabf3565eafcff89cc0b2cbb02cb0a7fa05a4e1c1bcaf19afa0f4943f45312f4bedf7a9d8318df1387cf621f679af64a7d32c809d9f113b7eea840b454e800e4d1c9688cdee61899f9680f9d52f56724d8b2056f68b69f263558c671882fd1bd09644d8a96061645b5687d494e0d3ae70c7a17e08e36823afb6a19a42bf644055361e9d8b762033ff322e4b67e19a6444f76499b162caf0e0c221f17398e56d00086499882c359c2010d6bd5f947c7d2415fd65b99223f6e704a95d79605df352f0f10056bceaf8266f07499544779b97e6c5d661610130834260498dbc79b1231aa611b0787e836aca74c5711393dd7049cf2fe6e79d9dc49640dbcd1d287ae309e00b2c0c0a345fe184ea935b97adb66b3d3d580e5c386660d8dc7debcf847f001526672aad108a82e37c321c37d24828e39287664a71b08fe4ab58d6115b40e38240c572ece4c32470778397b8623d84fad4c4601ffd61d4cc2b0c8004e9d43493bfa7a227c0bfb156d401886f9aae352a0691ef8d78c481c6bceb68aae51547c913e951303cf890cc2887a87d9d8956eacbd21aff76b99e6c28931647d39c91e1a6f057e72cfb95c7df7feb41d81bc921204685f4fc15f0ca7a2aa6271541447a44a149f4300e8cd9b207c2c568f3ee86eb4b037cc73ff56e6c1f2a42b7ad98d4dfb5730038ce51ccefdbba5021bc1e49ad39a18576e454f8443f2c9ad268310e95b6a22430ab0343ea9d92dc2d82fbd2c61ac58f885310081674e6a778db44c1b819c3c958333a5a4d9ddb46ff2c1a5cdaf340a8aff3c8f9663df8a63994e97c9f8d4eb032b812e157e5e471bbacdd650c51f7f3e428c118c58dabf5be541aae81b371b09e7b00d5de88487947f768afd2f4d7a1c62507d8d83c8dd0523cd3a90a5ce943aea0706fce02fe72b43e8cfd057ac188a7c6a21385fd23d97e76f4c38bc6efac08617304405cd0f2322cb1b5ea6286948534d48573296ae1889a73c14e4ac0ea72139ad6dec69e7194dd1bb1c5fc76277687e4a21981ffcdc9d633e1cad8cce25949012f3d1f39827aab0600cff0b196ec8bbb42499371e00e9c66c91719a20b783e5c66a4fbda06ee0af8b43bc8b1572c194b42c85ef59caaf1fd833fd769072ed7645f7672923048d48282333947662e3d368fd4a6ab922caff92bd01ca8b8c26893f3b03f17935a1f7a73a0ad98a86258f0477fbca311cdba103b7448a962e1e176fadff21ebcead6574eb140deff564f28971186f2fa0f1a06c7789ec07820fa9dc3e798d165af1cf5fd150c63560a0c3939e3bc0dbc8ff14832b223d8b5b21ffe3e04268eaae83307ab84b393f46e999d637ab30d63872d8f429209496a1119ed092f267d4348ff155937d5444e02fff6ce9dc62489c294c3dce841e8f13a7e48409fc104069bebf29fbd27a86614b0e23acd55ae37d2fe9f3d2f8541995eea838b0bc4b609a62ce946ade4032cb2529627eadcbacc2b16150715ea98715fbe4678cd9da81f220b7dd37fe6f742d222f07ddb53a402bdd8038348cf2a5ca546a0c6debd0037fae0f363b274ec7320d49c457755acebc19950f1d9e25fff2cc6422b6c3d990e564f57f6a1f7f39adaf64a5eb6efaca88792a8d674286a71ff8868cf1dc155a5e2f9165f534797f231049aa64a00da0805976c2feee663909b4c738538761d10dcebecfc829fe23dabf975104169829cab6cf335aad122c4cdf320a4393d0bb27fb404811967121638fad4cfd1110e93cf3c2ef516fc2f8b7a656fe5cb17920eaba7f8c90f9011e041952149dac001237a9700bb27ea55e3819994946763600c5dac5dc895b6afaba27df7c349ad3a029fb1f0aa5f9087c2bfbd267ddd739c2592e2414065b90bb899a4bff04b342f8588866290b38af098025faafd0dfb5f27771f0ceecfc0c9dbbd5eeacd9b85c92c2f18898c35e7f3b247d73fe09847e5596a745e54995c0006103bff9f6a8056b6b1a3d15a60595a916beb72e404e7e06c2a483343e64602e2a3743bd0748590b1634eed77dad1a0317b70227575df54a3030d0c521d006e6caa528b7f0ae4fcbdc9940156c5e4a7578f4ea742762289a369760be644909fcbdc70eac04d9f20496aff7098dbbea8fc9866eb36429ffd1e1243190aa28d42664c8e3a2417a33f0897ae1ef07fdf26a77959ffb472397a500b20abaefc1b70a52c935783d9f511e73dc1594402e3b521890c798040e8f239fcbd5d7a8eb6072ccf89a7dd54a1029ae408f28dc75b30dba243c12d07de868bbb0ae41777cc2d31fe9a32e72d7ceb00bc7ef43926aa5916a9c9bd530018a6a2af3512d44c6a7718fa0d58178ab23e4145382b17ea968ed03b6004758a32e1e68502dcc6f43c8fa007a827f875de8fc5d8e4dce0594f8ea1d12b3de9eac94cdc56446c15633acf7d0b659ba05af066a45f8ec5260c156557dbffb93917b04216f8b2089155c801b21589681b15d3accbfc2908bf6207ec6f175a27efa696a3a3f0a161580b7ca89c4c64af908d63ce9db865774a3866769ac62b847e13c77d63c7447c9193a743cbb1ffd70e25c165f84feb8b8990ba80c3759df0c714c2a289dee004d8cfcf28ab147f019ce8a61b4b527dd6cf3444b2ef3baa0c325e9206f144a56ef6af72de6b538a3d1e3ec76e864361274ed7959e7d70b90095347907a42d30bd31c02faa267f4fed855ddba85b3a81ebb71638d0d4bda90c4a97f6206384f3bd8d710bd808c3189ed6afb63d73f1c8ce2d03a23886d9b66d55cfb2aa16bb9d6ba52bfee7d2801c588c94264d057e4c17f8ce9ce08b1d011ba2c783c05f04facb7988c93ae01a7a03952e57a0a73117b52e82e9abc2e23d8986a3d6b1e998c6b02223792a7db956c38219aba333105249a7687b716584e6710eb7a917c735f6039483416309e9b4c204d9eb1717ec948ebe606df00413a04959ec41c15bff1f3419fca006c110e5c5c94b008e4c678819377a846cce514f92f8d78367e53113a77ef2bafe446ba7a51c9b12186f435bf926b6ecb715fdb95d8f9dc31ba68e4842fc11edefbda8f94ef1b0f24dd8a2ca746af9a5d8e99e4eca13dcf02cc451bc1a38cda13fe1280c778682cd1f809301101f975317b944b16f29fc0d1d401a3bb8dfee25ff85389c42958d8a393b3835a9f643c839852e33f2da80d3db972c6fbac7f5701e86f03ea6bbd8ba0318be4a6f37cba0d4573cdcd4b927e27406aaf165eea8a03611e825e488cb0aaae5af17392cc0cedc35c90a07cb2c1a1a4e698c12d712bce8c217efd48be76899e0039a78dadec35ae4f44cc57d7f735cd00543ce9b75b42367b696610c6f6472d86bff64d03fb18ef25f250ef740fb0ede621b8ed947b587ab3e3e29936667eeee65d3c2225421cc750710565404279ae6a185ed948dd91f8b000aac5f9165e60133fc86c5b442fb4f62976e9a96a892b73708080a0ec28b19a07756c2cd85cb3f9b1ae729ef519015666f68fb40af90b64e650869dae640b99f11bfbf5b7993157ae5ca6d5a0a5bd7586e55c96cc782cc4e585adab2340d9c6d98807d41473c123b3a1a90082ff452bfc04c43059d5e0f7ee30d04de7ee119873022607cc9129c126a47c77ba423a300a6f3230b3134850fe4e75c31f20a1b5313d0f15bcca6d4f99e681e1755918a2c556753470239dd6c1893f33914b0535ab62c94adbd4d2516fbeaddf50209f3c9065a162adb1f81a2ade9156a2cc82a404d4586b16108759d473c859f0a4a7aad4d8e7aa75596bb8a9a414274b9a586fafbcb5ab73578747b0056757464b8f5f9713d0a82a23131556864b36f2ea129e8f2b097ef0b45414b448383a1704f1d4d47968d339d065413b8d7daa62383be2c0345e47a79df157da157a4f13528a8920372cac73f93b61ce076ccc4e1075af11be23354c184ec0fe2930f03c992151d3987717b943651b970f5fab759341fa0cea76346435451396cd1dfbaf1c441adea1961d84a9d13e5067613352b7467f1100bbcec2c08a2e4287509bddf0825c2a090b9192f449b9d276dbb83ef7d8f58b9c44e1ef4014ea5886b35cfecef2d0eae1b70993ddb6fe2cc7ab4c5a547f1cb226df32962bd23c4ab2fb600be55c460b464bb8a333a46a337fe62e05d81a149fdf810f8785be0e1236af742f5519e8fb7f39b77e28210b535df734223a72998a39b7e243b696aec280a2de39d43ce3f99eacd33446deff431b7469b4c2402b5b447c6ee6cae2e113172c4c8e556d6b445b38013eea40421c41514413e7226956c3034bd8881bab4fffd658fe8e70619718620159c01c9b8885e427bc65082464cac1bdc78ee29f1c2f49afc26ef154ae296357109108e29ef7389962537e8774744d0f7265718802646160086bb95b7eef418cf4c59129ac9e9bf112fc1340bc0835ca1870a5bf67139f2af9c175bbdf16a6f444a2cd4411dc6544bb14307d1474fb3e18e70652d238d100e8e59deee7fe999f74502def9e54a96575924162089bf708fdff42439548f2ced819831899478b76f213baee2a46e5afb2c5ea1de0a49fcd0aed0f340d3e5e62b8c4a80c82ee8ba9d431766204b5bb1a7ff12a285d08e3ab2787cfba18e924881040c4fd6d499b6cb153ab7791bba6d99761093a52a07d60105cb1c30bfc888ac1cbc8faab6efb1347b2c615b58b11a4483224e138ade0bab88ba7caa0227dabc79249e08e3039e56527c0758e66cf7a815b353476dbc37256b6688e49d0d269afe9e23a599050f86f83194db248471bb8f1e7093ed024adec55378b2b9c9114bb9477bf069225325cb0187293631c660f271ec4f92e16995699a817862a4401ea0a2a65281fe3eacd40237d8079549bc5ec5e999396903896d494ee7c902a98ddb0f699e36c83fd86d2880338f576614ef254f639ee91f9fc43c0cee4fd24c0bf4b65de7e0253f9bab92cac056d55a4adc4d81c7fd9fe930685977340e402ca2b0bb3e74ab099111743f55f2814b9bfae5470a0b45166b5b3f8ef424ba6ff88f071b9d9a6182535e0c0dc5a81554b7e17bfc530d0bbcfc31c9bc264b8d4ee07d41a9ef61fd947779f85c1d339ffe2e1fd1a7c11fb2d619f8767de35a87e037d1ec59ca5bd71fb201177eb4c8dd3eef36859d4e59e5304c9baba4adff08743ee5bfcac1b45f0bee42d8f53f3b766efc186e6a8d465ca1d24e730e800e558c170298f9a6b0bb8b16b80b40cdb27f0b94fecf2a87fdbe287ba8518958a51417dd8ccb46434d72fc784a96eaa688e1a3b04b6eb0b0a5475d4d319a369761595675d61484ca2d7fcb15242d2788fb03d8fcc1e40bfcf8bdc0992493690bb16b73f5240a6fa6e89ee249c2771dcec87d26122f342a033ce99828a451ffda49255594d050bdffd38229ee72c487aca5100ae29cc34064bd349fffcc5ae0708545760fe030a1586a40973f2f6803d264cdf280710ac55f843ba8e7a9bce7b6223151c3326f8f4c0de2bcdef7a7304c0580a6736a6c66322fd12584c8076943e869259068477ee0c3d5c49fe271a4f56140e265c3e701c64fd7a2ffceb177943da4bfe67f55a4508f3cc6fd1cff15c844342420cb29cdda320414e2ed27dc9a77e3472bbadbfb69ab9abb35923368b0d86dfff9bb052898c49b966045524a610edf30d3a9430c0b4d284f82014c697b3fa77b038205dd0791bd2860d5cbac660c18ee848e0d1b0194fce0886527f52f6b92767c91193795c1f9d3645fedf44d1eec8d759e001bec83b9a9773ca9a7bf7e6c350916e583c8b0a9ab547017b227b506e160809fe9a71fa7c87021c133d47abcc415ec05b565cdc72469f4b32c6169103d5ceaf45d170f270da132b811f417b607d32d9466838128bab165af998163067b39036be40ba9bc6b5c2ddee5830d17843e40cf14a03c1c66ca15995e18a1a5e1cb965978babb912245d04399c0d02b068e9564d35e84be881078c22c0698000b5f8412dc8ca7c43f0b66feebb6f3b3b0d9574995949fc59c21577276e79ef45cab09af3f7245236de7a118f1e6b9883edf459dfa5f41a806624685786a15e135230001efff00998ded7d2c2ab33e907b815b43cb92f3ab784ee477888eefedfdff1180dd6c2c2c83c94f80ce1469d981903b97007890aa8e13632740a8dfd6e06bf8b1eda621011ff5e186fa2cc962be959866fd0b025eb899eb4461f390a805932ca9de950039c14f66be97614a52f355a42b784c3b3c5564b1a6c27abdf1e3311f74c2e34f29e5ac9826fb43c2e7f5cde65db10eef464ca9b938621dc2b4ec7d6a0c0ee83f73d3cc953144bd08d0297ad81759263dd94701fc642e5c5af57d25dfba863bb91bb11729e7910a7eef5fd972147900e539a3a82661caf97c4fd8e49516c8a4737e3eb687cbc0fb847db75b888c57912ad5764832583e7693d3dce156f9c46f8fd1233245798365330382693aa1b1c90f3dfba5704c5c0dea7bba1813f52dc370e9186aa3df8879c29e6f5857e22cd698db63490fd66dc9a8d569e13277245dd5b71dc6ca8d79d9d94dbdcb62ba8ce3ffc42d9866bd6959d34b92013f1329db45ac40267725987bf6f8e803e7ae204eaa7744fbc87bfa807db72673e52ed2e6ba45a8a8a11901e434b886d4054f9c2e32f2a8b9f0a6705c1569bb9c16fca284cdd45a4e7c1410bd91fcfd5d408f988992409086a2b1d76d9c539b52edaedbe7d1066fba3de64fb53e58951c8efcd35e1e57f47e9b6efb7d73f62a343a457afacfcaef537d7474149766588312c8a7b427982732d3a67a80031ef44ba2c76d546e73c4b00169a97ac4db3d8854ce7a58999f32fec3331d823d60e087e78b387f3bab832f1c327a4a6d4ce84e9c84915b2810b7f9eb4dbd64a197bdb6c8f2d42e7221d168f4ba618ad77dfeba9e99268d531057f6d0ae6d0b6f0faa2875694e85090d148f47d9a511a4f77ae25cc13d7f1c6ada2ef9b24c6a43daf85b8d279a0e187ab681516e7506831399a99aa6b0849c3f8f5ae09a834c466373f0b9b4f9dd52e7594ac8d1561b06adcdd437ca5f5f753c476a3908f421015d0d8f9342ca8fd030f15539a58c6ecf1d4a5a36d8e2b03d20cd15c69c8c301ce28767b46c50c1cf77888a1cfc559e57fac3c50e627959a461933381b5164aaace0d9bd09572aa7b75217166a15f86ff4a2fac0ad11e118dd166af7af9cc6bd4f241204d172052264532e9829410f67537237e860efaea8e62202f9e955d6bf82ff1a8608ede85d445b4c4114d5dd1804633e0bb6441295a23ce47cbedd28d37576c86270770bb74c65f76e5bd3b141f6a11129adb45643f8024413faa327e224a43759d37a213e5cc6d9b95c215ba926fd602101f8ccc680194adfde80e6fa9147f0d9c74470caa05e00fa32c4f4567d24726df7fc05f364234a6b32d998cdbc1a17b96c33e34b9ff24c9a5ce9afbb9c7bea0709a5be4ee7ea5e667b6dc3445aa09d67f0d374d4bdb0a79c32e9ad933cde3bec5d83f10761874fcb85a19179ac7927d668cc6dc215d531c8d69d2c238acc463c5664aba07adfeeea19c5287ea4365f78af99a1040790c4253b48de65baa2349dd354c4039be3a7b1ec1efb7519ad782aec97f9d41c861aba87e6c42cee94fa335091626a97e7b78a08e27ef89b7c1a428040a71f39d6822b36820c8972e520015a07ed15c93e8b504eee9a7d193d805346e7971ebcc4feef13cd05e90d05df809352a6a2e0b33d223903d5eb5225617c3967422141a99a61ff7be733480137a9eba1d98960a3c32f59fbe9ab2edce30f159f5549b03ecfc8c9e248426312c9687c51ad775ef349eea902d0ae5699478951d53ac305379266f845913c1a3e36c64b46e72c74741558460254b721cf1c966fc8bb89c181f173f8e620e0b588f72be3f8eaf74c631f1e32c071528206aa774dabbc685698b9b899f9e72073a893bd3faefba10a2e893cdb10d46a99603fa31228519e0dbba11ee6c18dcb2720fb7cc59c9474a53f264a1150cb1b4798e2adc5dbd1b4bf0827f32add537eca6f7709a13a9cc24615faaa8b28c8ee71412c70189f1e16d5130241afbc37e4cc9be35ac9fa68fef97f1a03c0ad12ea39c774bd6b3fe5ed34a348943e6c6fe6b598cf21e7a4e24877b834ab29023fa6f6afc2ff75f4428209681b1f6816db5568dd39377c5ef551d547c90d5614cd0ddfd606ee4324fe9f7a74cf665636ba7180200013a884c13930863006186e8cf6b64b1ca4d82a2f387eae4ba4330ce2a006ac43fe7ca7c065660327d9b07a0a12a73fbe12b06da07e02edd17d55d74c1e1784cd330bea56b6db422b31cac043d1b84825beb34cbccb7ac7955d363756762b6ffadaa3c80f00f12da290f997bb06e2f3b43dd725ba6567963044f6664541c4f9a457b5ff45ee4ea1bcb4a31fe7b0750471c6bda7525da230de357d0e47777dd84a1cc8dd56ba24e9b993185c3e7b79304a95433639d806e0ac7711f5e3ba9d98b719f9f26d638b4126d152823c2ce4d047b5d1a3c5929a46fd59973b2ca9c979e33fa72b3f1afe84f00e53dad4c59c5518d078f3db94482d4014e8edf1f19948e3f4f6b13fa93e15b605990653cb4fe878355012b144c1d653257e6db2227754409ffa08ab8b999cc32217eb979b96b79ed2f7cbb1733248b2e6f2db0cf3170eeb388ac2ae81becefe060d5ce5b184c3b3a4411011dd050a4184eb078b4717f917fea603c820f5cfb64a29eba8e243f032c235cfed34503e0720c360c4d15e12b8be823b27a7f33fc853d2e5ca22d17580c92d46286aeaa6c606307e28cc38632e5c27d5265f3d1e4343b12058cef3282a2d07cd9a5eb25e7dd06a959ac057b663b1cc1123cef158f2c8f4d31ab123627e43c02d1300b1452c4e0a1ae60c0053035e39690b793d54b9599612af6d9ae227486765f3fb0df9536a9a790ba9b1295a03049162144082a64e962b0bcc9eb7e01b4addfb2d6b2a22ea8111fa127e531aae02163e0edadff14313f7ac5079860a387dc3e6877446800d7efd9343b43986a3cc4773414c7ea7d4a3d141be8d2850899b20cb461f301ecfd5dda30ce8fd8436d4d7497176bf1f3507796bd8c772a50c71f9ec640539a581962a9a0f231ee0b4aef373ad8b5a97d0173893cf41334a9eb444a6a6e7b2377be28ec0a66fe47b033bd34a1ae9562038b397b9292ca4c2a414db97f94063693ee3e9b1594f2edb811e75abcd40e95bba2d496ee35d6716216a7457346c3650f30918c667cb3258d25cda8109dbca7afc6bb3face77e0aff69c7bf5dbdaf1eaffbe860ab18072487a4cfece52e87e76878fe3d44d672bf3907e324e2224c9b1f9c2c8cb732a4540c241159c131ed2fe4f69d1fbb3680d11babea3496c0ccbce8d31cdb4647ca24a982658f396a8fbdd8bc8b6aa76b7a7373c5666ace58f66e6afb46d5c3d40417812f434750417217a5a2e9338daf69c12357e23021b25133e265b996e460dee117935f697ea558fae25db57120c94f1ce87eb08f4ace4ff1739c5650867071d949d232b071a5bdee32424e99fdc28f04dfba28d9a07727b78895c9e1330cc9347ac0c3024edb9ec9446a6deb84131b243cf9da1afadba9cda3f991de8c7631d3766fb2ed230e57ca5e098581bbd8887a2b516970f4228fc034e3838dff5f70348f29d72b68cb9b30b0eb5e440c25ee5928a1fb02b45a3d8d9674f1406acb3ecd769e3bc9b0ac2dddb9b8f2cc10ee4f0cce3f282d62eeef2e524705858770b13c68121143333a95bd044060b8dfbca30731fc0d25b1d215688f2004c2404546e6510d7ca96604509926a950484549d03079364ce3fe07c946069e11a6d0a265e96d551ba4ca41d5b22503c443b36519b734d47b22b492f93308026ed608e59202b7deb0ca0436090a87b584bc204cf377c4c840086de90db08b1cd3e6fdfc3840f2602a71b6c87b825ab34f9b500e3c86ee10fc2440a6e94b0da80b17970fdd85ab41cd6416ce5ad8478d0e0635eb9ffd7735f9b2b725eb43c353bf0e8983b5fe61f8d4b795a1ae75dbf128c2c6ff215135aab7c08ef5c1a62a78c873ef7411457befc0880ec8b9df01da7a241c096d18f4a8caa431242b2c1f3c3456fdaf989c520db82f56410a0f863819cc1f704dcd72cd7d421821cf56191249338e790fcf195af154321d29619ff98762983c62dca4072af57b2cad3a062bde02ddbba7fe3489fa7571528f0a01dcb98a9fb26035235e29e5de95a93e346b3c1434a073fa9f0404f2a2d55c2c5abfca8534d052c6862e705c02af04984a8cea747cbe9d3f7c9a021c9601560599414f72e3282ec5a01fa39371bb36f0e6581bcb1175044ad6af9b5fd48bd041bbfa601f81d24a1b94374cf35b61f9ccd29e5753971edfed37e94ce4f5a3b81d7f5220524bafc5002123f2ebd8c5b9f56211f866894b7dc2029e34eda9488ba1a4914a06166a2ec32ab09a149ab3073b5f9883a4741ebdf52862c0639b43f96d4904cd9735cb99a9c137d7f5f5492cce49b9a38d4bde8814029ff28d58b6db98a7319ccce14db1f262b647b62b48c0e5a4f5ba974310f65ae9d4776654ed86124962c9949c061da02aceef5d982ca381a00356d3d32cdc623bd389bf5d868d4d517ab399907adde7b9dcb3192c6db15f5c62a97a42bb87d17d66d69997b0b8274bd661443eba0d7623949b5d33804354b1cc7113689a3af031e1bb8ad4c214ef518b5f38367ee4689c2d3adade24473156f7c6647fbb5f0a6905ac08fd08dceecaaae782d22eaaf83150df83a915d3e0e6501a47136fee6d506506b35e60deaade7796a9db00016fde60e6038fe2a950aba0fedc2d84ff736b8ec54dc6a1702e91b50b7a9e9d1fbee9cb21e23e5bdf06ab791a9a01d74d4eab77c6c36525cd832fe7b6fd8dd5c00de333548d3b65ec7057fb886756b7dd76ecb164a5650a873f3689bc37d970de7a6454fea162fa9e110e8820ec674aa00424afd8cc5e3895b7fd722a2e3c0b0df9873a4ded5b5356ebd8d19995feb458172e37a2b8a698e3de433c6958506104e61800fd2917453a42bb5932d2eb04621fb5ca76d8225a291975d1811ab5dd0bd9b104e6fd8cff79f6d5239146529dceb994d603de1c5cca347b1566828a07fe22bdc9db129145a9c9357c4d990a1d9697c3fbd424af0bceb57dcb3a626b77e52665bb9e0dd2261181cce9c4de42f2f6bb173f8c3e91b8e5316785121a2bba0def048056e1ee37a2eda7302e1fa5b0138cb65821f7c24f73f5fcedaa3c49076da21fe05608783b083d7f6c94dfdd69494c0a2e7da17a57673430c9bf111ab99fd43f9eb888e4e0fbd7c572ca1720a1ccc63424cf996350b9e252ca77d191511482e4b36a41193d948b6d9ea638c3ecf4130b372f96c909b8e804d3ee78d22ba5d33d4a40168fe793797f1991d63273ac1f67c630f3689889b49173f60fe88df2a4030df31c54e9067d64c829e61958213670409f6d49451d04a46d2f821dc4f8d3d56c0d8ecc7d18f3775ca388c4c1700a9ff1e5de6f2272fc575d841f3cf718c5053d717f7de906c05179c13937d5bf8b838dd900a73178eb5d8cbd309a4970eccbf3f8ca3a5aae0d09a0bb2d00bfbbc24fac1f3977ba6ea9ecd444e8c60da4143fbcdd6a6eb5631e6b81080fee3b2d446ddc5f85fd86266ff60b6213a44af97f502d1a8482941d98714bd370bc5842a304b4c624ccdacbeacbea5cb6f2b5fd47d8af26bbfd7ea10cc87264a0752bf4ff1542753b42190eab28029607bdf4d740df017b658601b8dfa6eb55b0d379ef47a0a4c7bc137ce4f9b44852b4b132697fc8ccf552e9a6613f218f41b8244bba70dbd5c6aabdefd9f6b0f691bdabe167205a46e344b67e3196da609d38b8fa5834f91d08ace561ce99fc5eef6124583976e5bd6bd50ba0f5920d00d1b9f7568764617997f0236560fc3122a1d249d1fc2702ff21916f430dd5a04265111b534a23e5be748ffb49e4ebda1c214974888b036f6e26b1c053d7394fe075f9853463ee6ab1d696b858693171248cf2c9fb013e1723e270e9a1a442ad9286bdcebb441a711584c3bf1757820fd0b831e3045d4f76c8d2a83f650a45bf5a8feaf35db08e649bf4ba33084fba5bd88b0b6b1de003aa3e2cf8779ea617e031c4595d7f7a80f7f07eeafaec500723e9dc94fc3ccb057af080b4da672f96bbdc881b87bbcd8fa8fb05db832d3bca80685529e92654b10ae44e423564d5db92e373840ef1c0812e7db17cc434419d79d3f8e6b3778c65e46cc1dbaf9fc8d98209b704f4f9c4ade9350682ddc156d539768fa671a70d31f50eedfed53829ebbb7e0da04718694696ee7ea38ac9421c55ab14423d5278080e267d6ca073c83c19264832d7fd984331608d63d75419bc7d0af3ccc99b1f2558a264cdf37f70536257e839e95fc3098032873ed8e804a0dfcacbd4734e8283d25caa9e90cae737002a4eae276ef736abc9338e43e5c7837ecffbb2ccbfd54c9719296117a1ef65a1016eb493ad35c95c1d78ff19111330da68dfb4362a9fd277b6d63c7cde767a1383ac5212744f9ed67bad8dc7747f5a335a5c442f4dec17578c4591ac2ed984b8e36c18d0600dea9f8944a16171abe3e6ff27ef06dee0f3909b005970713d36f93bfdbf44ba1241629a1bcf38bc4d110f9766b0fe53fdf1610cef9e41813a8e133474ca888cf5d173a7e89850c80d0ab089d70844669c9f6efd223f967ddac414240e0f103f9a4c6a313294d81d295c35a98ba3f1b907c4dac07b6502aacde7fe1cf67e8d840cc1e7aada709be6fe164156c419611d552a7a180031a7abd7539909bd999d90b48f25d75901e03bc386a868c180a17930a3aefc2a92e7cf85a5e0c1d511c4a70f834c5250a99858d6bd349c033ad2fc4e6b62e5b5b81218f660ca12f13eae1d2985336ebd281b514329fb563ea3d0fcb38c91dae35e8ed4aae923a8710b037a5cb246edbc631fadf99afcc256a12535613648e2c413d81375d9e92e84b8dec39d37e5cdaa2637660732d18802641138219257b9b3dcb9ce4b582050345150061f3278dfa41b906c1c190b74f48be066d4570b44c4feca67b9ecb9c2be5e64fdfe38aa52cf321abaaa0f9d40edce48a229289740da52d7c73b3f71af49b81e99fc293c526535a3fbef6bc28ca2d17feb5807dcde2afa8b9336846724787d470476e8e0c81de9ee82355c8c41ec1dfc672d8110ea6a709dcb7ff52fc48b7a7d53ffc71c0ab17b51f79ca4e74c0056406c0e456c85647701e6a9656e0e1b875b4b10fa31b686efea27cda89129fc270c5e733020cc351773f3c8f717c202ee0d5a2a8b110365cd67e0ab373581cf137fdee5418a2e0a5d2bfedc6850947ec471ce156f6eb2fb95a175d7f6f494cf3aa8a112f36797cbb3825c52997b30a1e1066981540f346c9615c209e6bbbc8530a154a3c9801d2a98fb9837d71ed1b4fc4ee0a30e8c447f61360627a72e44e1be250ee44c79ab8e0c67a74b793148e8c7c42dc46453045dd940dbf698d2fa9537e131ffc92ecae1d25d9983315c682179a7539c1ecdbe33ea186fdf2e89c0d9c2feea04b37a5866c96b7b1498cb19926b5ffeba634f54a8888444de12951b8052f15b55ad7e61a2e0972a64845905db5576e3c618504eab568d3811dd6afdc63ce191a9e90fc75646e3d0998b226e57d60fab76491ecdf4a7ef5dcd3e2bcbcd890f8b57683352d598a0af3ac9eb387668f3a4cda5f30e4f719e58658b4ca12577333244fd77fc57ef3076b0cbb6b82c6820f545cb20a6b36084f41547ea6c8425b00868ce25cba0aea28c9c48b4992fd8285b626ed6664eae85a7506d1d369ef863b2b01db880c4b9fe1e62ea6ef3d6469348609970bfa4a7327b95950ec5f9e2d262bfe5d2dc579873589b2a3f1be3109df74b90be210564a217940d9a87ad25079319a09b14429c314a1acd93a11e796f5056133e42d1bd2b800d7b888bf4c92656ed8e86ce84683fae082838ca2e889451a67d6bf2294f0067df5e4c438a1e347061affb5b26c1053de9c2180d132ed0e006f0589516b6563fe62189f4c2a618c5870645e698a994d4cf835a5db9b5499d3837d9fb18f4302bf102e6c41907e99117ff09d6b3a61c975b56a4ed3ca3910246347824322eea15d8bb063791482acdba321e83f72c930fee52d43a8f263344df0249d992c25642f686f075393b4ae1b840c5a4deb2fee314e152dc88962da7c0132fe7c4d166b462677607836e2e43c2ee8f41aa4544a65863e99dcf8de3aa1ffabe81e1303fe15c6d9167eaf84de11ca0f06d0397591fbeea530d8cc29d0160f2b87c6e06ee27e49c84e39b504bd14e95bd8e4d3b0edc5674154df566e670435d77005113bea84f00360208ee325ea70069b5807a67b244167dd76cb9bf8a3cbcec0608c8d2d457c95b7c41f00bbb5ea8b5acef8db4932354c6c2010b763314972cd9ff11e8bee2a84dccfb2fc2863b1f4253e5347eabe289861881f0fa974933b25ec9bda314c19f679b147823551f18901793f65c634f487f1b2fd6137e91d6eed1889f449167522b60229839575fefd15473c361887f9c5efae2012d6e42800b092ac2aa98d2d362d1f7743764ff272a5777d4b851a8e2303911b0e7ee5683868cc9dd6c6466fece81d5a9390aadccbc5f5c45ef790c68276be715d8884674ec35ff77ee317f2d303a2f176f5b2776ce1569b208a025a6a91593078f41d9a1e25037e9845fd1edd90074834c2b4d807f5c012e37d7f9abdb64fe9ab3d62a6d88d5af8d44fc415834274c78f9a1f90d74f88f4ae0dfc131a3dd5bd14b27d53c2a0d67e89e41ec399d0152769036d8bfe7d5427d86bd0f7aa19c4917d584d4d6d4c90a56a1bcc07ef6ecbe7a60b636c26c2c1d6071e8615600b4e5e0a23e6ccbecfffc2693691c09c12ddf5d97c0af9f676a9e5f776cdb3fa285dd91d18617f8e85176506b5f9bd1c0de29c6c3c1fa6c9b8873759115ed83d66f4a4c024f467b41e0b1fb81a40a537b5e2aa69406b8e6cbadb9c03411f6962f5e18c2dc003106ad41df32cedb1768d36f38459202ce327b43e515eaeba12cf3eca90d572666d985aa7b4a415a9ae8463b9fb2a34cfdf4fa82d1eb77e3e091350f2e7071f94731763dc3f6cf1fd4fcc45cd4338f00b91b497f62316d51439cde18988c9c253cfb16bbc3f31c5dada0e4506adda66809aead31b2161de428858a3cfb0bdd2890806310628b4c076708ba5d457adda5628fbbaa74a5b7042f6fadf2c7667bf57d9395dc4bc3c47100b6d1ab966ac8a8b45dc36d3b9a6f1aaccd22b5fc36a847737dac22649bfe724ceb6cadc03e7632ffb79dbf17a1509a93a68d5c028a28276dc170099b36c680a7b198674097993bde3690123379ef31e56b20c4c618a4641dbf812e44abd05170a744244f1956e7a15351d2f1a7acdd3f124f4e85168fd1fe6081b3bfbefe3be89711abbfc3f84380a387c3c08a8a280fcf707404667385e7a106abfb17faf95d9d316520fc5847363c503b91ac8372d356cc94199b8d03eb32402886a190d6d4d2501c514f5f03ddea31802c40f9ebe7d7853fc519d2dceb5d1a51e285e175ed010fe9d5c6a377dbefa8145b8110ce516fc29f4b1d904ef7cd6f2d5ead161be3e3b1c605d56b2ea978b7b6440d0fcd301b18e16c26ad0c00d14d97a6da34d3875fe7fc647bf07d32949954cd21c69e5e26aafbcd23f46026dffdced63fddc1e1f2e085b0d454ca717e2f47497b51de0a3d2bb9cceefa65ec907eac3432dc006c2489d29022a36be1b20fb0d119c091922365f0cca051f8e8f8404578ab064db65913b2b9ec703dff9fd3a9b9a93a2cf8d9d6ec3b08f0f36b138aaf6f079e19c4b7544b14c876fff2b4708bb53e081fb064316677dc75b466f9f83b189e41cebe7048a8cacc2fa207b175fc5dbb8c464bd9907ff9369298fd37c54908a896cc022c5920e0f22c4e442918559ee7b79475cc14a60e6c3553607ba97d9ac135429dbb0af1232047c66f7ef060d0b0b8209c377d25d39d8141812484c389f00656cad6cb9e56aa26582d187c84fc30ffbccc4290e0fb6173765b404c6aa436f0d6224394807ae88d2e0939edeb84f670f57ce9b5ef4efb7b33b07140ee565859339e70005e0b4a3a49fe9a536a45c75f7e3a40f3a74e1e67175f3de038ff2be281dd95631cdd328dcd9835c642b18750c14753d1358b656c3d501c7d363d11613b8dab3db04a63bede3a76922eb87ebfc3fd197884306dfe9400bd5eb117a4ac1ac4ca3437ee1e5c142d2c2564727ece5f82011f5f2ff2181e877e42f5b6f691d4b1a592fdb3e174618ecf7dc28afbaa1a22141906547f1dbde20e0ec69b619ec8431074fc34b91be8e66c3d63de716b7578593b86426a9dfb9f558b8a0db2f29736cf6977db601863dfa9e15ab407f97b037996daba40e9a76e93b5083399da06b992084257d0e922633b5c5903560c3c83e6f340a89674ed299c221da65a647b1df6129edd689f8032b64ca7a1464c38cb66d5f033e201a1b93e220e3a50dd90b7f42c2912348c1a4b5a78f454845884b952e2a56edd77c83d3c2f8ebaa9bcae052cc6436660c3bd3a8f49c7b2c9af9e36d0c1b622717c27380e7cd013dc2ca5c012aad8a364df951b53bee31b99f43b852b91f9f3e2ebd82067dbb0b43d0b04c7178146cf5bdf74f933b348c3e90cdd4b93f935b1373b7820299be422bfc440e669e6ea981d8580346b68b2e02238ae62e6dcfde80e69aa577a64bd3091ac954be4e7b269b8ba0c5e76d7508a34f97d0fd9dbd5f5412f359981120a552d2857fdc417fd654fa5773b0967c74be830b1cd1f9519622f82030bc2ca27cfa4df091e207602d4bdc0e83d7e85de761d8b19264adda8e307e6808a325092ee7cff0d5dc0a5094c0d85a8bed40ac9c218e03f60a4f4d925d2403cffecca05748a7b322bfa34e2128ff62a38a2fe8f31421e7998961d06010dcb16b1388930527268fb01c979a364e1788ea07cf8b02ea571007c4527062a07b910cca035cb81df03f08c404edbf213a00e896eced624d555cc463a869db85023183a01d5be2be07b6054d90f119943a44ff60de3a3b852c4a0b035ceb1fdd3e433a8c47eafe7fbbae53de2801ad116d938e3cc3745a5edd24c8568697e75c1b7eaef4ab0b191e723619d8125baa24721fdc9a4cc6e1413143c0b058548a38f0db820a8188457d64e7198fa1987eee072af74fd82e398f83277c73f62ded8ec0839a6cafd5709cd41345ae6b08eeb4a4f58e7b664b37a9873b8b20931990e133669da012b7b129d1e692eae8a971d8bf458d8c27317419194e870bef512d8eb011bdfc1b60788a411966c8bd590b3813429dfc6b9db4fed44e881f0764c9e96dd201f5d3d8ccfaf3fcf605a809a62b9c35296d549e5bfac5152561487c5657bffd3925492f34ef364cd2bea4e96ce795c65177b81b43194671eafcaae6176bca2ea0aaebadd0deda2494c4545039103e4b7d0570e2b40c51b61727b563009ff83c404c62b351863cb14e03f791b28261de8b3b374dd8a4637f3283e6d6e346ff6289d1d97ef5840aa87b7d15ab81f7e66d960776051f186f788fb42566c62bad4db6f7e6781ac11cce87c1ad39877c73c410c4ee7adb1c55276b8ad6cd5c2274fe86403494b446c323113f7968513f3c38aea0cb9380d6a2ecf81feaa00e50729ebdf5c6dc92a4b05f167737c0f392d4db388a54e38b3cd94dab4de5b4a4afa5a3cc180706d50b9533edf61a8d3ce4070cfeda0daa83f9b90db8c2dfd76021373be6a18b53b4d93caf6558cd9736f1fa9336bab45e90da96eed88889ce374427cf5841f8333d999b5c1eeb900a62df04051eb1725f06c6cb6ad98e710818edf055bb2710eef89ba4992ad7ee7b690b7ea364ff608e25cfb275575e05daa48bf756d6fcaa8cb9ff291ecaa543040f7936f509b10c818792b162b2685da08aab9aa6873f56c8270d3b683f00f5e2711a335f04426a1d8393d09587606c4b72f61aa378f414c7af5a9f36bff61bce421f41a9006cdc02939d2980936c494ecc3523ff1489b5da4a4a3074bd15d2fd2a19caca0df8ae8aaf35e1c34484f06f925f26f0209cde1af1bd56478d99ab8be25987786eb206aab1e975139cacfdf8507049f5ee73027f02261dfe6437134b703527651dd8af25b94a83fe9417f250b39880da7841c9bd8af5894f4d786e64315cae3771b82e54ac28796f0c3b6608f17f64c15e4f41451f3d74dbc964e1e5151bf1944456bd776988de4691d96110de421bf60ea48c2c75e93ccecf3ddd5da8a24806847265e1bba10eeb582c5900bf17488d4e01b45faadc3ab8e1c72df71ac8a21cf4c7afc3ca1fd7ac0458dce47badd40df908579bb0ab568b0ae692070c58b27d6e7a38faddc5508ef883243cb524dfac15839bdcddfc8c097af75ceb47e19daff9bbb6126e443daa8fb522132d36965b35228c91db5ac250d081f053320e76db0ed72888c282b1873d5357b7d867b4a103457a2cadf7ac7cd77be81cf93c19b4b72c451af95c36164e08c08f493dc9f988ab624b1ad9157aec3e32458bb9911c6fe0cba7cf5fe029625cc6a34413771b6cc7ec9c647e31701a2fb13a60a2ee1d92d7db6fda06b4ce91405f02513328994a5411cbeb6409c38de49d24e440ca8ade4fc24f99c463a51da5b45fdd461f29a4f5ab5cf05c46fbaec115a60bae9eb8fb0f62a90aeca2f6f1705f0cbadad79e2596a9d0d3c7811bce5011579c59b28c17ba81ac6a43f91f06e6f9d96de643ca94dd1cec119b4c459855cbc5a79982efc6a44309f27e750c94242138580daf45be1a4b161c8862243da963382db442fa427d34a1f96a5297b1c67645ed6a550997e2fe0f861e26d7e7ccb6505402b0a615fae521e5bec1bc5ed1f6f16c3ad36862cf924a8c1e889afed36864efa1ea1cb1689198b626098fa9286b360262657cfb5e7686212b534c57f3c04fe824c080b080fb192b726a80791ed170af1b55cc113334baddadc62be26b0ad5212c962615742dc363b2e774da93dd13a3ab789bab4c8add6ff171ac76ee7d049fe9e15ffb11c04e69ea3c0c65780c751450b2f98bb1b9e7c953bd60ce1188f9afc494518487921ae7b7f8ec2db4ffa311bf038d11acf1b57d065524b3d01a47ee7ec94c02c1d7f26a66f87de2db133acd0a1ae77f31e8aa0bfb8b7e071b6a0530120fd8c718208a7509a0a0c7fde028d021e7d152307ca17353c69cae9f65cc32496fd5da1258e9ec74bdc389560354da7ceed36ca8831153f66341be728503962dff539db0a3b3d54013e9ad3c19fb6ef493fb9f5104faff97bd7a118567db4ab3acd8f642ced97564702fae43ff2702702ec6aa56734b87fdd0fe01754d3600da47910c490b64dc4998b86c1ec377d3c10ee97354398b56825f2623d231264d8d2de341b953ed5bd32752f7e2005308b60a83f8b7dbeab3c374c5f6fa0af8f9886b3da9b1ea52e6fac9534f5ad3dea438ebdee1e557124e354b9db29b413cc568489aa57881cd146fcc7db8685eb387a8c44b8c10fe8884f706c727e71c06f46ec56de15e275e9200ff7b22a0ca5af4386911403f7da306aa91d3031e4e7a4deb4829ec52fcf10d130eda06eef87c097c0a7d5d9771def82bb16a790610c97d10bf7524f84c0c7101dd8f3d07037c8822e8965b5842347597c2993125c5f3faa0e4a7bb03102070d77c69d8406e63480a0fbbebd4d72935add878ca368fbb24a514f7774534d60938ae82bbcd5a034d282a139338a3d1dd5ee345205499ce06931d32bc66b54414c5e460c4978f1dfd93b6b720906b898878813272b47d7a35437adcfdf35642360b10c2b682c74f884a43020cec6ea7aeb3458f51426cfd4f5937189a839ed3538bb4b15164f34b33e94c9d53b24a0b7c2ad6f86939b79d3b6fb30e378ed364d05bf675ebe5081504068783a82b0e455fecd62555aeaa8b84ab87edeabebd2d09cbf59e65238194b993c98ac5617015ea7d62847b4bc9b91f6fb64e5548cc37c4a87a9d2903ac389974e53f6ea89390ccc8d643f80f52650918501205db9568b04ea3f622c4bf3f370c659ee6c6ecf8b537c30a32841f34ee5d17f7849ca72b0af21f1f1983c20b7de659ac9881055263555452cce7220c96ca5af87d7eb030f6350954dd1ef4e709d6ffd0b085e7bb91b08d44e1153e08a79d0237b4e03aa3e09b4b571f4e0dafaeac9f5fbf3615d177e09447a7022d395ab850b9acc6bff9cb2a5249951931363f3e4a752043c2f13e5b6f699251130bfe805ac6ef4a67634d2526c9622bbfa58a795e101632257cab5581240769c308dd6c3389a4bb1b4757444a0316d4a8c3c3c0debe6cac8937d34af65837242005f4f2747d59451bf6970a22d5540603559ef71c611c2b76947893de22cc0b2f98175bbefae71494d323c14aa0666c38f8ee1d8ddabf9223aebafdf58bcfc4c69cee57a4ecffdd9eff2fbd79b6c7a28ddd36f67a14334513e5a17e948a6a86c518a92320fda93b7dc9308f30885a96390f30f7d0b332a06147e0c56eb96367254a18429b37d8c128dcc4617bebe59691f175d391b162f01c9ce86f29efe1da2a8dcefaad9e355ef076c35f522dc213671d18ce9f811fa4909bbb8b38c5989527822c50e8720cc757a98051807cecc4b4e77b51223efc169ca2ea8ad61880fce72cac26f9407c1c7c65df949882d080e145150bbe95f3e805f9e224d33a80fabf12a7ffaba23d8540dc9d6104bd86875534c2ed5d1a8c8e9c0f1f92775e188527e988cbd3dea497ec053f0d9e1ba8f3708f8218cba5a5bc6f615200ca1be6188f1d73f26af479473a04403985cbf77d53c9691b5fd338ea89c965aa66eecf6e99da0087815e888feb1b6f0aae8d47ad59b8f7ab19c2aa3c625265d57edec8a33c7e77cbff5073a57706b70c8ecea4ad1e7e68f141a21b8e5148d9d3e60dfcf25366ce8f8bd103af7bf262f92689c48c476fc311ee11f29e7ad36ea37b10377f7bee4373252f65da9092f006534064b3456bcb7e974db38fd961fe804ca6da1e3e0888231a259986181d9db198e67c27b81e56d1fce94d9bfa96b979ae2aeb0f94fd855040a711fb6dce97afcd488d0a9f39330d5d307139522395d6fa19f248dbe2166502504abf8cd339ec8fec677bc0c56e6d2fa9015cc1bb473e1f981b0256674b90ec235f238addb19e34ce674c852e3760983fbce995eca8134d1f606cb7878e21654d32f195b9d3d7e708d234d9c15d52241442df65f013bfabe2d9e79620365a2cb6e9de108922b05deb4a42c7b14d7f5a46ae533332dd5952357418e4cfd0b6f33db336642c587e5c2d6a5b0f0118e60fcb2eb78d276a17fd6bdaccaf89d191cae2fb23fc353183312db0cacc5ef35d700c80e9c9291c59fa6de9f46aac729d08b6b1214802de7a5e7c915fbf48cc3db4cef9c8a6c0b293e075a5c78a7433052ab8e0daa09155cd4e77b2512ee8404448767b6e4bee4f89ef1d70c68ce57e62729f3e947dfdfb52a9dc4b10c4a83b4c91077239a8aa71d1ff6afa6681cad3277e298db540c22b3ec3134450edcc89aa7d1c87bfb070a44d2ccedb1c1a8eea884061598304a85867ef93961686ceae23ec917df0eef0fa44e04239c9cfa869f97981ac0a1c6157b2a6412ab62cf0a53caebf46e778588e8792fd514f340f214c0bb041e0a65f2289d963a427a31eae716f44965a522ddc703ec2739d4469505ba876e8bc641a37040e67f73a2deab1e204db095235d187b04c721a7d22219b4a1aae87a7d5a412576a1274d2879c84a631b035507b079615c8e4c76f7ee58da9d37c0fffe7f85db5bab026b10689ad503c43a409767528c4329414761b54559ac2da2eca464c370b5041f7a37c950bcee9db59647ef24b0d1bc6081ccdbe274c28cab57635f573975590a85bb5c212489baf853db0dd535c57eb53eb663abe8a1a23f178598ca5139d9fff5e5c7faa5a3432cff0e4570ba9680c88132b1ce690d8a71e68f7c3dd6ea44c724cd6541cf29664a613a687c54b8340a5e8e62fbcabce7221730c3ad3a639ce0daafafb57c8aec442bb7cf37e536fc561bc62ccaf23a6c53e5229abc8562d5b638810da6c0a47abe38225c977870983cbe9da4a53310a76cbb88bf317a242e61cd89a48b1416d9168e308bb6d95145a5125a565a885da79aa899c09ef4a84967977fdfbf1161e3e178321d784212634f0d5c5723ce2b5d0cdf27bd9416a3b695235685ca1c6c0cc65ed64d18854a9e4b9b0e2aa605f80bdbaf32cdb92649968debf8f7e84e31d5159ac6226353f17c97129c1842c2ad44e27985169c030c6c96cc2a4704929be519834c49dcb7edeeee98c1f15c896d93472c566d7fd9f558b711e181fea2f8ae0ee00f50da992e3e08734e28c83488d14e79c46c0887d3a8ed15fe6da9fd9456ca444b26c085d78f3ca794529b5f54ebce4f00a9fe670bbe1d45f429200040f6f64a54e3c5f96b57190bb309122472bad909704ef8049b60e000386ffaa2111b183d573c30f373fe20a35cfa5b9b36cde13ae551a2056b03add59b6934241427306d60adfc1c8e82ed4bdd8109dcd0c953dd89ddc7dd55a512c788d57941746ff879b3ecd10a83d2dd9a68be8d04932875473425e267a4592842b9d90cfe649d9be6ecfdd6f14fc4fb393a812d6c124a342960290ba29510c362f17526af5a03499fd369151eafb4027710ec821a038015eda866330cfe243e467ef5375061b273a660a280808b962b12185ed6eac8a76eb7f4d62df25d6a577cd1e885c6afb4423ecff8152b378a9c8d009936c6f632df56bfe6e80a640c528287a7eb742b7df410fe5b1adaf01e81bd4e737c86f010f4a362c0c9cafa104f2515aedf1982d34c6eb349a627988efe85e7e0b37dd91417d10ce147c6eb3433b851e0ce8e7153465c644095b8d8f749cfa378df45f4d2882bedad1eb06ae7ff59dc1a5b0f1b3c479d654954e2ac794f1bb1620b9179834fffdfa8e207196d94e53da3f5dc57d10c5df84a3395a924a47f5f9b6d06d9275e9004db09ff60df9381a06c29829de7f4f5c532d23f78c20676c75f0c61299226b812d7d830945c231c7bf018411350313d41b5d1571a457fc1d5d9fe88e17364788dad3d8089de29cb8919f54c5a66ebb9712eef649a2c02230223b616f7930c8ac37cb4c94a7754346b2185a3fb9124ebedbb70ba5eb770a2c742abf33b4a7ab497741d5afb35fc648f8ba3e6ace26703ed06c75a15034c4fb8d47828f484abf57683b9e98dc8218196b4a4fc6993fa1d019c74aa4bc4f60ccaa723421afc93c14a365513f1b8d2ecf07653ffd7b67f9b9befa56373bbf09c70555695a886b0c73f3877aa11a1aefcb5088a4df1fbac79aff53a568f209a3c797c3d4302c4b0cbb8ecbe3a72a80d063c790fc6487d44bc6d1d2ff08c9f3f56b7dc36e600d0d2ed77e468bc6b5c83942038f69f5856f35b6affa96bc312ff3040f95bd3c87584674d50549294732939c492ca27b82594faad88db8a4c887662e6d87e71d332bf85c2453abeb789d17e69da909d01300df3268d9fadbead522e3f5af45834ec89c33c9160ae0ecdfffe5df7aedb8e84c71fefc74bf5fad01e674619488321932529ab4f617feb08e2dca4c9d70f578febbdb4dacb7c9645735e973cc23210faded400a07174accefe153b566cd09f1676ca76482ba7829e2f03bc2d7ec15c65a96cdc5ce2aad67a739c7702e252ed418fb58877a2b5da510cbacc2f171ad023ea76e36d6d92692c1a705e1efc7eeca58aadd1208eadedd0928f758aff92736b49add59ad3b6d07009a91118821835666675da1b062a6ce0705579dbecf92eda62ce367df78856003e085da317c50309fbf869d6af1b2e0e3a8a7b5f3ddf372809250cff27eead44da20c724c67092efb57df3833d2ec0a72121f3f19add3e1f15d020c9567e524df081b660365b83725efd689ac28b61a735a52b129115f756b2bb518ff7abba4993d6f07af6947ca44f8de8ee30ca0084a732645890470125bf8434fdeff1ab04a7a3113a4e94ac18ec8f6c0c30680b3b3abbf01878008f3797af077529b765df04fb3376f96e5edc2bb25c8fc486bb0676e76bca6d9c824ff183ddf5bf9ba734c8713344abb5a92db9348b1b66b577c4e55eabd20217d743a63a966a18eb76fc03095addbd55eeb6b87b49e49e3722010783f4b480ccc17ff8fb3744f6608dfdd88849efb1245d055e0a5edf1f2826f3d55cf784679843f6972431c71cf2020c5a07596c373a75cb878a01492cd568e95ebeaf33e235c1ad50e102d85005bb7049410c17fd2ed3599f5fd80342ddb751bb9362bc443cb839a9cfdf31518d1114e04556f573937c83a902c1a4bda43dea11410261acc71951628b3f815175d48f0bda35c83d03321b6a86c3aeb4711ee16ba52f82ed451e7ecfdc82fadfb01e9ffd5de3205851b3e18e9a94e86e4e317b6549e063629df4a30be6817445db716c988f60beb1411e40e34efad9321824a368122d4b1549b572a43e611773edbd9661e9a7c217df7d326270f046883f4d6d8ce1b997d484071ceda68832277a1cd9be04591704a9304579987a5439956279a14059054b496da861bea7753ea7fec071084bfb35d5341875eaeffb45003b68ead55eb80a5685bbc1e5f547e7110adf1e231b93c09ecaff7b110242da0a79d94aba7448fe3f4c51d93737451e8c0ccb51ff4cfa8d826f9ded3ab4d2a3ea1d4280121572badb8586834d95a28c96532ac8fe31c005dc969f2ce627c6bc0e79675143d058b5937413427fbcdb4cfd6a03120d6510d5fcf367d83a0ee30eb4c0a9987fae96bcc43c5b2c5680f0b5671bca49e8a64acdb6d9ef26afdfd6d07a6063e09780fc73e34bcf78c30fae289a9cce26fc14cdfac69b39d64a99fcec877f79c25024ad2b54f2e537c1654c361e4051400f23d312cd35680e8705277f68759749ed134710000909dbc0714994cf676bfaccaf7bde6dfabb5ea901b1c173e39808cf3a8ff30c88b6e177b4ac9dddf9251bbdafac42c4e4f50a5376d0b20fb89a2b68fd1338709126889f9570d8c0db5b83e96d46cf5ee99121c89d37c1efb7296bdca2c2bc92cbb0dba100e3f7a14b894f96f37935cbc9760d07f3c6b64ba4c4d041c70230503c3e5962d9e4f80047bac3724e0bf2a0a25f8252ca72e07e308ee484ec1c59f6d3af0976e2afa6fcdc9c1b84848a43e0cdaf722854b62fa1bacf0d77158b1c8869b6141161e4cdbabd279e88d7f5805c6d8c5c0381c9607329a5a85b7154551f1d0a0efd312e8ca41a210fef44d88034d52ea902773cadd664327ff8db4b57516788f2a638b648dbd77df3b6a11ebe537d0cac02e0546b4801ec245e2f1d25fdbc2d6829f790737876184b858cb29cbd8b15f77ce5c8c3e7e467e7ae49bd4c98e421f859be4c48a76ab1523c8a93fcb46a8debd1dea46fee3ff505935d5e68fd98451db9c7f6c65722585e31095057212f29ee3f84697a75466c4fc02c51ecc1be0fa370636196047b7e48597f378cafd5377b36ae32c546ec0648f4f07db298b980074f8ea74b9d8bd654c7bd5eac88765ea395599205c0b44d715846dbbab4dc585acc59513da7f40df01f8d5e4e0ebfb68e2da04008694dedcb7b732e06d1c1c29c3900761f8ed94503a08bf3477ec646b73280ea0e1d5b34a49a33ec0645dc42e18540ae27f0b6ebdd26e74ee960c138b1f216e30d3c87c221e1ac9df851eddfdfa0162071d83ae25726de846ac5f2f391ed6af7f40b23fc72b084faddee56c2e5c3ee5a82695b30502b7183072c4fb0d71c12be180654b6cc83a14d5282267ee5ee7c7e63de23b030fd7007098a4819d4fe953c700f594d804681c2e1927ca84a6612c468810ceed81db81843aee17195b70bbf8c48513905825e4ef3ba7ae5fd27ad394e047864d2d9487538839883a0799ee42d4bd36102725bbd53e2707cc3c744a38b89693f75a8ce2e91eac835b630c71790251239fac6dc9c6f07969e87c2f71ca76395ee5e2ebc219a29e01c20e4ff260207748cd43f943d203862562a45807d29b995fa48c0e43ed4fcb37d688507e127f6790fe129ec82f3b0ee21a8a1329e78d165217454e7144043f2d8cdb6bde8fa24c124ce4cc95a308cfdfeaceb6578c58283a2175678e9debb3a2d6a1b0ca3ac94af2e9d9e84ada5d8aee6e77b474e4c7a41b16768570bdc4becc1d6a8b787466f3f45ec7ebb6eea5a029a5946a831d4a4cdac37d20ffa4fc66b850fe9377ed2a425590a8ee507d63a2d21391abf65e2d6c6c5f67842b50b07d273ec9a12402544ebbb03f237d3eb20e7ff9dd2b54c87c56a45c0d452babdbb81b9fd451752e37a6e7f19d20db27d57a510841914f8b4f8c9ac68caf2e3495974505178109028c3963f35039add104f0d7367bc30a0c14d18ee3a18f0d38c26be0190359456f245ba36777c15e4e95c24dbfe67ccb29535aadeda4ec6b79eadd999a3f8b75d75c349292cf4cf88e7494bbfa484c8d9f6bafca881077ee1dfa0587c35e6bf19ade56147093c4559b8b27d9d2febe6275f30efa99370773e3e3f8f0892ee9945bb19c6eea0abac50b72358e93b79334e98989d2e3bc86e8f3d4692c027360205bacbde8676c6477cc40b91d61119d002966be5ee1035d32d7121a7cad5667f282eb57be882616fbc7e7b5d3e6a940ee6fb27f9a5d77f5bbc1a7510a2ba28d6ebe4330e2767e2f377054e4b7ae814b17eb6b45c92882c469bcf2af08d4079bc34645719acf67023eca0a51bd5b92f2839387dd74047e6be3fa56a006b4136431489b785dcc715999332524ff0bc88a948929b638b9db6374043dcee29a55b541c8fc7cb51afb2b5cc24f1883f1f01726b279d39eb021c10d049176bb4006c3308071508a6affeb37c7a8e92ae92a6ebe4afc039e93088e30bdceb88fd98fd9bb09ff29422630e084f1403f6fd2acfb201505db90abfe417c871b6cb216dc0f189c7b331dcc99f7760a38c66b5f6c909766022173d68f87b63843db716d0de3b5a708354e3a82b1a9865f86daf6fcdef63f77f2241f3449937af5d13a5ce8040f7860f87f6afccf41ed6742683fc7b8057902002de20b91ffe98e109ee31c4198c2caed2d1607b2178cbf1d03c0b0c6e27e3594c5929d3d97155e3e2192cca03e3157fa6edce8a44f263e0c807b950e98e0dd6f0b0596a509a7de333c339feda1453ea3d6b73fe5a0cef19d955cddb54289e192af53a3d0f63d520acf8437602f4fe4242d88a948dc0c81ef103bdd7541eb5c2d9c60297bf9218bc6cb7285385b13bd1156b34df395e05691a9d7de7b11794fa98c0e0b0d9877d8632c7408f2e84702d5a6f40251d463716f5b7c7038c51e7628e29ba4e5be2c76d8db7f2dcda1fa835c00ae9d07172c4a85c1a750a5186069bf98f9019842b6c2fc0429fb22aeb7d5589b8c5135ea48b4ff15b11d46bb247e390efccb506ec76c9575089eec6d6ae32632b7a4d49915707441757c2c7d742291e55b024c4d0ee376a576e4060118299e870eac0258c02ae11cf40cd21961f4edb7bd69588ca287b7d536674d12acf89565a2e5a92dc41345bacf68cf236a34a8041a43a532fc4f659c87a9ebf7d3da8dbfad4dd08bbc7f3393ff5e0bf73bcc028b938640591748fbe791a4b349e34cbb0df239b2c9b6f404edddd7790223dc90f75b7598997a1af0fea13e139778a0842406407dc53ab64561685930145f08fb1fc8c3bbdcc0e1d7d3f3ea3cc8be9fc993f5092368592a0a1e1ff7c8b3bdf6c37481cf62fc2041ca221e153778bb734c8475795a2cdfa6ec8ed9bfffca70c29a2154c71ae07511847b0f15a591dfd498d492ecc71eb0b53c67ddc208e20d0f11e8b13cd288471eebbb15ec11c138ebc808db73e57f004111ef17782406f4c8ebb268e89c4acb876eb2d29440fd316d175bbff6d61709849530ed4e4dcef3047a30be2d8a21a60a3445ce6be688d3cab54d5e67d0811d6afc73b89cf1a135cc5ea954cb1f3c51c1bacccb72d9c51fb54cd5b1b438312e9e53a23222c4c14838a5145ac93581e2a7b13e88c83b83b16ad79ce7bb22cd50b151f030cd5d9693d2eee8f40aa4dc1036aafa206f2afca7d0ef9ae38b231575b071e133e9997cb83d2fb7063b9c19081160d5d6a1b752868be5db5ca10068a99695e1b5e779089d432f86e11ab1fc0712ab61d9b0fa1eca6e29678c93cb34b3a5917dfeedf23fc32b72f5317ee1a6c7d72d99ea9826a79eb0231452c314fe4855bf16c09386053584987f462c0b9bbc31c715114107cc6ff74954799f086407e1be3be7cb40d3f1733481ea8a699792e6840e270bb8706ec7c5287a82d7f265adaa887e10d3f0d8857cbadd0ec4859b620b4d016de288f328c8d2abbedf2730efa34751f58a9998f5ea194046c3f4d24af17e67da887d352fdc92b23c8084f71bc919e91a7347f6a839e0b6b5c74c05b2424ee2eea79b09844f2bd0845d971590aa1ba68c1b8bae35362d25ad95cdf09f5cbb07ab00e82522bd2ad1f3fe8e08cd9800998a2b82502447b9d1418ed2885ed5f64c43cfc6367342fea081e5618fda430b598327c210d6c118e4970d55d8be189ffdbfedc9b261c7b6868f1b0c7a2ce9f466f156b31e0db6650e9faeb96db0546f205c70a3cfbff51cd83f3621f9eedb356c0ddb4377df980a64fd0959ba07396b5b9e6a9c441b075852a061a26f9771611e7e2c111fb5e1a02a8b7321f8b4f769f2e8c9051236e5829f02067a8481618f69857b521eea660233996573ad351e8ccd299e9b05fb487508c080f58ea83eb174e991678fd0c2d7b41772ad720529813ad67939eba6f5555c788a3c405e743533c18925a1504fae06dc3e8276741d6b9531c809a7c8143545e8b8a5b6589fd68782cd82d21c5e095e693a6782ad3bf4db6b93eeab7c1839c6bae60aa28d1d39e903170bf1b7ddd050f99fac797c6a81a1e1c3bae7ca6eabcfb5ea5fbb02169be17119cd18709e44b278de153c356775e5dc07b953f12b4d9165ae1837851a48b61ec5ba314f5f18e40f9747b13a61c8fc58020ecb403256f6d63186cb8f04cf73b5e6d77873f72246d5a784ae41ab252b09a27b1b4a34dba86bdff43fc8851537e48eb34a6d59617155a7c44ca385384d8bdda49636bd984afa8d42c285aa949f032cb3d552a50f116e6686d67919f0619dc5ce44466da8c479da75c7d3db16413a51a096f22a34f67a0d2613f629ae74fd6e7ded816e68f4a273cbd052b87b78cd700b9c6dea2d3693a564f7dd07298d669c8d285e3832138d42b2d9491e0d8e5ad291cade4579093609a9239b0438ab6515e10e55ad647b9ebeae93aec95d34741e8c68832bc94991981e55530792d1d16f2f448f7a524a449ef62345020093036be948bcfa4d9cffd92d3edd708417a7db95851c84365b7f8c017339db7d94bec0a79599d22f24829b421e68a7bb2ab46f0e7018740735909fc9349cf7b6e4a3ede9086f0df03271289bae922e04ed2420c8d9aec00deb6dd68679689a1df451a093c55c8bdee3e46ceb23dd14382338189b25a53e460e55fe863c90d5deb4fec41025d1dba9ef5aa72d69b416b16f0649ca3b2cc19ad27cbde5c2ec0fc00215e9c149d3746faabf17edef894866c570fcd25c9c7f52e0e55ae738d2060881d4d6cf9615235c5e210d298cf2e795edc3cc6d0a6b53c27c80f1ccc02e6ca305d24c1e34f869fcef0f5975d959972d7e68fb49bdb516e91e6eec956fd5ba93208b4c4bae4af99148df7786e40fbee9d7f81b5e42d55c6b5bdd5175a75a13ebc1c0f055b2cd3b5a2f3cfeea5e6817fedc7f0d73339736218f13e955d7189ab3f0d2aadbf7701dfb2f937b9c782dd4644c617398eb4df237f23f9024aac202cf1954ab575e40e150e7d825edbd0139901aaf0af7592fa35d2b70144c61811ae751a5173ef47fb935506191c115ef07ee57193a2724c1a4dda7654a8e65298ffed202f3ec3ad1d81d1eef42e5dc8bdba12be001304254b1852c4bc00f2a271af755c5297b5a2ed08ef08dc88023a76e20893f8ff57eb6b897fe95035c7713f499ee2a29d3dc184ededfeeba734bdebda19ae4ce169081a8303350e16c03f1bf9f96ecf0a5b0af60e8bff8d75beef8d2fc7858c9e4d0d3293f72613331cec9919f7a71955045eedc092c4252eccfb269134bc0e5ae2d10d9808af3e659b72df337d024a0a555a22427277769609d1f2eeeca33fc625a9f17a5e8edfc1780f7c426b7e8ca7d66bcada0c365444256017be786efb6adbdc8e38a5bde294253b53ba59200b4fccbb17b28b5541fabb37d4c46c5253c0e678fc36d125742b08cb15cf0d97293c1371be775743234edfe3ef4244f44803a49808d44eaaa5013feb19b8c958dccfe52571d8bfd066a2b7a371fb456ee1b78563f5250747a77561eeb21197b013d0feac1f3c83cf21cd406fcf0a6d1a8c68715de14ad020ebfa47492f50b8df9144fb2b0d82dd8cd3905c1fe0b3064f104c6c02f289215d05862b789781a64e2edc06322d62c41f7326e197d16dc50000b403430e10de8c712c3c00427100c714989344e525f449a3d138882ee53431538210a10d131c5f0e3307bc5c987116207bf5b9513a6b59138591e95bf05312d3e843f88ead1fccdfa6a3e234aa80b937b249b18211e4d7f80ce54ba0718530af42a32b60f30c27ece309dd851bba0a34b9efcb398dc448ccf4d05e28591120258f7e20da1545eee019c9ba16bf57b92d818f927fbcdd40b89993b2d60cc2771e99c034a40882215e6e0eb0e35983501bf4a107f47f1d002321ce376f6998957356b91794855086c1ddf8084710097f0a372a7967669becf4107ec039694b541d26feeaf18cb2ccc9fb237f02adedfd5f8dad5e8ea650297df8414de790681d742d6419635c4b8292522f2877803e34dafb755bb68e2da5e6bdca8e9139c9020d93802a2336ead29a63ef418902be7577ce597f2edc36990f20b87916b37cff549ad1c451eabc614236dd9cecea62d4418768ed0bc20b9cbd1e58b1ec730a4ec24a899369104caa837089c22c2d27154f51cd5ec74899c31af890a3e9a7ad82bbf9f4baad69d5d51b8090f00462a03ebfb729473bc84b6d18c91e623f1a40540370bb57c977242b27f865fb09d87d60d1fd163798350fde9317fcd80c6f7f01d799c564440a33fec7b2bc2454d932afe17e0ca3ef6eddcf0e6dad7def38ec051b2bcef82247a2f5934b7c9a3dc587f2a7638754b2417d300e55e1fe3018bd82d0d08fcb68f199d329d266b76a6e8edee254bce074216fa277f5d3d355292c014a784bf588735ab3449736802224f6a56e80918338a8a04f825c9a8900228ce9ea31b4f4f61adda39b5004ae475e343f8bcaba1a4a66fd1e39937ba8882b23cffc44bafc3a8a358d036fe88aff653e6fae529da8af44b591831b9410efe7336dad684944636326d892e65808fb96db72b00913c6e7b476bba1689de47580513a042d0aa74b2f14c9ec24854ba78b0fb29c542139b71570abd0ba447fddf54560c097ed4f5a3d16f8920af20fce27439df90d9e6153f966c5721c47b0da9e34e78500c69bb537e2b44ad3e1027251d41c595a05d590b96d4362bfe30630f2a6ca2f8804315dbf70e4a82033f458aa76e66037b7db1cf2ef2b7f81e445f7e54d9377a8eb42c2d78b827f01511bca09021d36ef03fef91638a33ce016925655b463c22227c2f399fe96ad2811d067a3158e644fd28441c29b1a829ed04481ca8d344d59bbef1c5783753f609e3f374f6405760e54ce7fd70caf08f27820390b4cb8ca1bf0305b2f8adba422e2cee89fe095f17bde19ef76b7928feb3373f2651d29ae7bff7dfc0fbcc5c2ccc2d88e2e86bf28fab1474a5bb3a01eccd49d92e725bc2f1cf294e593bc677b3f6df919dbe194b09cb61a2d050498ecd5c694e319353c9df2656f7763799dcb655b83aa317b0109c867446d6f1122a4460d3504396fa6a4a00d14b1e8f636f51e73eae78e1cf9c87a7b3d9d7f981d6f908c5bbac86ab9b84ed64388def528f7be3cdde72ecee50734314b16ba92ffb2dfd1434169d07dbf65c3d4d5d092ab73b973997997ba8c37d8dd64b83d915d67ac27562f639ed5dbf89cbfb9f42cb8a5084f4230e39f13bc2db94affcf0d7691975947db61160c7d0b340c0b9677237d33729ecd65c82db5d65e745f70bf69921a71de2603356f06fd25987256ffd273bd307dfabe2b7b083840cc950567d74454250533a49a8202d91f1e4221fccb7ffa217bd4d308aa711f58b86eaf75b8eb707b36a2bea24c90bb6f9bab5aaebc5a7588734dd603cd7dbc54ee088a5e250c9b77b29841aec4a14888a452af5de01352aaf76bb1d0a31b89ad935d2c1a8a89869b38abbc576140851fae0cb1264ce934493ec5d082ea2ec94d85b07121900fc9390b5b62e73351f4bb16bcaa9c565165ff471721887ac7b9c7e80510306365e5fdf847c3a9b0976d55fb3f8fe38cc12f75794e54822a92a532482e5f226d5e25b7f3cff8c56f43ec121e231ecbdd044159d17d2249de208ceb98dae14c74d8fae59e0ce991ea590f15518f0278b92a3260e85cfb6525f09dab9fd3cfa39a31a915877212c9927628a689e5c48e24ec48bfe9a7b69cbb1168d99ab51ac9baf8a7c4f37172e525a84930faaceb94f91cf952ab77890988615e32fa854c489691b4385c2a669545c84174240a296c617a9b1d11557ea1bed7bf7415f74cc5f3d64248881e3728d0c9f4ab40ba32d5c915a1ca4cfa2f0e79eb4986888f0efd3314361a6199ab298b174367a4df661c1981659be52e176ffa3aed25de9aefa454b8d0f7df859a162630bfab154d25fbff8b40fed09b8d8edb1fbad3025b88fe1156bea515b9700bc978b3e92f2161f110ef717438dde80ab00f1b6e08254bcc0eaaa4a5e484684f43a971a3af37f0b1dcc5a11d54f9e09354eea3337ea3fb4081425889683df4c9b2fab1af57fe4bb2a57d7a6d3b839939d8b3d98cf9147cb1747d9b2ae336fdfeccbb5664e3f90b74e881d4df8d196c3394d4e74a027f4e8299ebc3b02a6ce259d0eb337eac77e65a9beb945553be0c763a605dfc5a0706fc4d7fa7efd0fd3b000eb6f2f14a2ba2abb5c8efc71e4afce6f5cdf24c2e6eba63f5480d3c688a69204472e8db4f8f6bfa8d8d2d36ac395529b28d5f046d0e10373cc9544404b1bea7b6554ae15db2a5f27bcda364b6ed500e0a96a9c6aa7fba8863a104a1f00c52378f38b5fe243ed30c41ccb03efbf6139cee41bde87cf5a3cc7708725a58f78f520c9dd8b3377a69b0c22e274e2dcce0434f5214d97b24de30fc9a1183e1ff227b805e4bb00dfbeb0866f5d302d1666f475976eb47b3815684c23e7f4e834c1865aee469d988fbcbcd5e52de5f074e902cf514c0e963a60e9348da2d5882bbcc62d961c90119d4cfa6e8ff58f3eb99c6acace92380d199e59b7c823bb18f4a2a8089ed1461753e8b2dda9fea0d8c42b1636ed2691e485398c4651ed5011f9ea40e083ddac2fa93b96706278c558cc55f2657ca5e451e0cfb046db51c645e1546499bde25a4469c8bfb44bf07fb1a76164b1d4aa4ee21f0a3c38d14256e6ba1d2f86f317ecfd914cfd5419e2ef58efa9322aabe56c0928ab6a1e9188339908d34cc8805c7088dfc8345f31f77e345acaff2e317685f30912b8ed5b7dd0007698445a44a2ee7fad3a6d12994b3b36e8f2b2bb11ffc8bd0f502ccf05e19cf56e33014a10e701706c9dd419f46208b276cfa7dddf9208479d0a4afcf0235c4ae2a6c3fcca25ef2d00892b2a278b588c128b9171a402fc4421467c999201b5f54ed34565c64380a4715d80c8c1dda440910f5fd242d066c964aaf82060fd5692cf8b9b4bfe06a96db268e76a9679bf7e46ce70fdab0891407ed7874bbaec071c36cdf7d29bbeb0919fad1b38676d68e978d145c2ac17f8e4b0738aa845f35691041e7adf56e25caad5507c886f8f0fbfcf713661ad2a9f542d8aec8b903c19a3928f22e0cb94577d75e350dddfec8dfa8b15944201e1a4c2b265f0fd012951994a85ab54804372aa29655bb6538576398fc1f1297c07299db3579a4a5104a12d6530fb10b1ba3868ad5160488e2f7c1aa28cae05c59babcc04780cf564f750018536b883cae73a60e7dfeb5724673a89df0716ad1184108b3f0281e09e4547e7de714ef35dbbeb0b9fb8f489a9a579725ecd47660260619d8e867f602cbc7741f6f380d181d4d42a9b03a0358862857cb9e8047f2ef5ba5d34e3d293cb8764c2979efb6ce059bbc066c2f00dea637205d80bd483eeda6c86c275af01fe7ada9326cffc3f3f818253c2d333cdd5b7f91d0eeff3407a0c2ef9b419d577b8650a183e9759f83575e2de362c391ae5c2f7d55fd9f4ecf3a5ebbf5b9a74646242d706f5a9c35c422e04ce16d968ce96ac9459fec23ac77cf26854d06a2a1c940b3b44cebbdfde488e1d699f23c81084f245673520f4eb0c835ae95f5f843c616d4ded6e29ec8009a99d224fb42c5081a7792fc25addb349535c5d1541a6e742664ae105b846db4942eceeb21327ffb2177201d16c33f15e8cca2e60b8c5c2e0bbb5cd6bd7164b892e34578a64386c7bf50986a0185366f20ebbf50e08e69cc760eab75b76656eb5850bb4802c5f1cbb5bbd7bed48fa47886abdb61d05c1613ccc8160fb920a5430cf328223df4ac4785a8d7d65e6eb29ae0640ad2e0f53793b7f91da2d0e14b7df6702d9aed6dc0a80c6a1e95d2235b8eb426ff7a6c9f472512d6d9cdf902a49827df80db7b160926860aad20da2f582382637eb799a621b41b0dc794e874ef1bcf00c1b8f23442ed25ba4df4d035f95e7b7c7dded244898b005834d24ab61f04928c0d828f82abe2abb94a26311afe4fae554bb28e89b7dbe59d4abac41aa02bfe12294c0dc8e5078903bcad1a49b42d4741b08f8fac38ef288aebb158688bce972668281132cd835f57b296ba2e7f9f104f0421cc0fadccd478caa30ab633470582396d846b246426fb2587c639c55cacc75d68cdc90a3a87414dc3d8d5569b0866af8043b2d69bcf62881ee8e59eb0f055ef5868ce0fa2ace7453c3734f8a398fe1e520120d4cc33a14de61d3638a9d10493ecfef66a1b8622bbbb8fcbb5440d3eea82c971f2aaf53243dd6f38cae9b0e9af99edb8b99f2c63cb93f57ee68bb06ae6937b0906fcd9e46023cb3bb71595515b58c9a7199eb0e5a5dc0f08fd1e2abe813eca7d617fec6bda82bbbb1c0b7b502b160005d0f0c7d6f0a0f43e589b258a0eb9ffe549fba039a35d6de9e369873a98afeb31994126ace222e7eb1201e567f7cafe302edbaf7fcada5f7dec9c060753540c6789e281b016349f2e9b8d8ebeae13c2f97ff0c0ad672a6d96c6b1919cf46711f590e76aae8df4da491fc3b9c9ce2a67ebffa71ee42c072de31defaaf1eedd5205f48af40d99eebab8da4f48e28f20de2193e66484fd5227bfa6d58c1d05d77e70c3fd252e663cb9ee3f2cf7c5abd2b05a66fcb2b90dd0dfc4ff83ffa99605f78419d3e6c9cc1c7bbf730d48cc9bbd9bb3fc1909910fbaa4f4f492d59b1276c0c257461cb48b5d27ffd7fff4958188edf3637d75e5ce9ba932f91472eb44294cd097c6aa450ad46b479a66a6c12179f22f87620f52280d80de0902d5d2c26c05573c5f2d8e8aa0bc384810c2706864e9493207e2711ce1a96cb2e66f4864e81ec65a6f17d67beb6886a0aeb256773e8e163c5bdcd1de5d8a98ca8a6251a4dd061aa9822b8c4f42f2fa836fc8208b51425330d63c3a0cc000686c3b17145da05275cf41408bb2fcdde89bfb9054f5d52212b35be8628bcf950f3743b2e5bed9530f27b31ef66cd97d556aeb02d25d22bd493e2804a3d80862f16d9a34b8564d266193e78b347fc4b3b485b8768035d8d216d2b10e0d7a0b9bfecb63145156488c7007dcf6ec2dd91182bd92f74b2300e78f78cef46b5598b3ea5db3b624252d113736540a8635a278807165689038b9f598ac22e1652039efb62b3a2c1246af0171e70073da383403717eb96b03cb70770adf753d9265879925128a035e7faecf9e7edb927481c1d01110d55075375bf8f53ccc0039385c7b8a9f01aa6cb41f743140179e45363934f79325ac5afc926e0e7bee244ccb63c951d577a8399463c345fee0b9cfd482a9ffb4b5d983d57e40b52cd9582951730bb0553d5be3654a1b58107813b46ff658655b9a132b0af30308ea5d14af4b27e1ebc133d2e4010b0fd6af1d693d090074d0e5ca838b80306880f93f90c25fde1be5b79ce822f301c4b22747e1c97494e5969fb1a3eaefe9e823d7f787729d47c822fb3209ee8a0435d59fb8d6c418e1f756beadc21b94a884ec105e45150cc8c5fdf790418f143030d09d041b85f7483b150c03616636dac87d85f74e2c0e906951e52b6661cfe9bc69324028850a0daabef8ada8fa061402113cb1f4ea52dc078b62898ca5d79f09a69b126dc7aed614d53bf17fefa7cdb20bc7e66843619c2b7d44397805b4b91840b43a007f4701c3e3563dd2eae31514f85923af2700e19bc1953840d0035ecaa18b4c4e318a836c9049af285c4e5c37f2b857d3717d3d4d7cd205885d0b760b5e24a5e3b9d098190016c205b3a6373aeeccf82801f8912eb10fbc2be3df354b8da2fcc86aab4202f9f0b99692b6f688b729a3f7a8260ea45b722fba766611a6dfb45458e1140f03523b1b58e1287b458a50fa1fa088de19b4709daad23fdc2d0dd6615b5013bdd250e60946111aa1cff910c4ebe52a8623f0d5abb557afde2ed713f468fcaa697ed8d85ed44d74557fcc71c18ea3566c2fc985f53e4fbb73c2fcf4ec703034bfa5b4b1207d9d9b34a48d9624ee3af3eb24b3c3a2c1437728616dba3ed2d564f87413073b907cfa4b32bd47af38a404f373ce25499d8b63f04ecf119f8544892b84a3b004e09bbbd61ffcfd36856d71524caf1da9809b28eb6664acc03298ae438a0e9ec1adb482d833406806710cac0ca4f5575a824bf1420d6d9d67374e5c6ed8e097285c61c93707bde1ff2f341a1a36256979dd67cacef774d1ccefee6d078dd01e86b536eda2421daf7b9b9c556639a1a245a80574caf3e9fac679061b795f7acc728b14230a20ab9a73f3b7b165740cc22076ce5ca03813236482ccafd2b239c0289b1739c89103cf54db706edc2c1a8c081b0331a1b063e9c3ec49ad9ffca5fd221ac960e547c72c010274ce959d0ca6179e004a838258b17acbb54cd157accab4b23733e454d388d6fddd014438cde77b35e5460d3f191a7aaa7cfc03a85df0d28c6237b6342f6eedc7d333cdae0517a69b33f91adbe1063696ca00e582d21771d203312a6e5e2d2f0f6bc08a1c71663781b13ee146b45a3e27814c3f8109dd22aa1c3464b851712f68a49225c3ea48e991fb9fb41e293972be91953bd1dc0796a52740cbd88929b3cc5b6b787eef78996fd2f7f14dec18b1fba39992e957c3b89e0e463492bbf1290af7108f98de299006721943db3ac601325f640eb685b0c14beca4c8718f873916e26fd11450aef47f7b8cd8e43c78dded78981797c26ce87fcfcc0b46461f9ee82d5e1afe2d13ffcb367749d4d20e581ee65f30e78c5adb1610509fcb84b3ec0f98d79c42276db21602f87d140cd3485e21493ddc4259ef9013aba0c20fc7339ab74464812ee72bf374274acb0446160a518cb91d9d4f1b99a87bc2cea0fe374d89fd72b3fb84da710407cef29c645306a891b59b5c83d97b8441374681c4ac2d6eacd4a88b1ff04672e54b495f236f0c272510c5fde26bc7f5649183f258d5d0da12fb3798b071baa352b39b68b821ed18a0ac1892667e3601799b17c98a668fc2105d0fdf2e81e67ec5f176f09af184deaaee97627352f2a923831f5692aa29aa878e7b8d9f6fcd45e631fefd14ef7e83b0a2e3c90c5481ff01e98a316b52138eac1e94d4f463e4e7c698e9ff9845f9b487c3ccd9c12b26de143e6427426ea952f3d1b7af962b653b0a208a2280efeec3d984d775605ed584abcec568f07e97e867d57305b83f82ccb90318b7375083d39a1cb992a0f458f8d3b1f239ddd0e57182c6907578937660d4c0e7c2ed0b59eda04de5ea3cac2eec2f6d0a3815e0387a212838e18ca7637a01a14ee3668d09cf28dfc8c55172375b39c516a1e0a720318437b6b4ccfc37c76dcf905058a38178e95df5d98f9ea50df937dcd80df71a05250a7bee98fb5608f8bd76e0042f3fcf68ba35db6c38dc16eda0a9d0621b22315506f31e107ada6eea91a3008f4efa54debcd1ea5bbfbf07b3a9f4186ef41f18b62f4b614ab58f67825a9f1659d342a251db55c0f423840f9d76f19faa1193a7d272c914cb2cc348562ee734564348787d313e91f54b97b6cdf2c2729e6db74c8963985d30fc27f1746082f7cdf0750f12670819470dee57aaa17f3df73865bb6c636d16f414554ed32a7967aa10be3597d982c974f83e4c91a6a416b4bbfef61cc78cd87b7b1f37320cef4afd899e83f9384f6680a0b8b5f776dab94d8bf14ff638b56b046ab5ff9e7cba3ea1b08973d59271332e5d3849957216d3ccf725558d1ec1c2097a96a4dc7dfbbf6b7b0b64225703b65542caaafdc02ed92a34ab1f83842e04476915b813b972a376e8ea14887f331d8b240037b5beeaae453ec4e35d9c4d461a15345281dea1dff3ba6936c4fb27b975241aaf6a28512187f204fc03115dde2117b25fd4cb31e7ec78008c8635199acb392554a27accf50e70deacd6306d6eeb8c9a73318834188cac7b33eb335347f92d62d2bd29afc993c5a6be1d13ebc2c1ddfb01c26a4286c964a927ef83e9c143e87507a2cf8e96760b39b9aa7aa739081144392ef2d5e5ee96f612af9b3aed10ef6135c52a37ed7b2e9e179352bacc198b3cf43469cc53f253b4e38a0b7534b71c6b3018cacb01c3e3f654cbb93f21eec0f7168769b48ecd4c18cbff88475d3ccd8dd0d51f072399c170d9133bef1f7614e491eb8bafb31431e50f3bcbd4b503e17b2ecc719f750f8ed8313af2ad6bd6c5447065501693fab1072069c2924cd5a1ef632fdd7156fd2e3756539a7cdedeecc011c114998fda5ffe765403a466b23af205f52d7ee65f37631874ce2b62a54af648948d53c8c2c34ef9aacd9e604984543b2b9102c318c2d3467db637c609ae2b3836ccf42912ed6b426a28d48418ea5e7d5e1994601b21973d2cceee41a8aec2a176f054f09b0d52b7bdac2f9172e8cc692992e8c0fc4335ccb5de235cc3d2e4af713d97f41ce407d6ec8945ac9bfbc05659233d2fda45634414217ec5fa3f89caaa9e4204858b9e65c5feae954fd8b2843763420fb4502a264dbc37e0079f057ee9833b5be56cb9bd0d5fecdc53e9294b08a372918f2c5db4db3f1ebe797359ac5ee296003ce77f53c6e9568c30326137900195b061927e9821fd45c69846f0a70701abd79efdd0e1bde6de1fe839ac494586654060fac4372ac61f773e3742226efc2e9da9d738c16140bb83b36f76cee6f2886f8cb4f3e42625ca606c34f2cf2efc0fbeaacfd81d0f2f23ee4bd7346735049e5690dfc58e25b72db41b522adb8bc7217ca74c047adb2899e967416981d3ed867237846a912f112ef996e2569d096a5e569ac42c4b26849101c83e84c61871fb96f1d7c12598c9a65789ae298cad808be339ec93edcc76d70cc35ab00b3da683261b879256ae477a1c56b8f23ea9baa7c1144e8aa6b3d91ce2b0ee5e3e4ea0c4f1a91b302ae343aba262d8f7d8d4ce44e650ee8f517e25926e3486690c85588ba5adb1dc20cfe4ee6b3f1242314291e2a3baf39abf57c4a543a196b102ac830e8c5d64fa8344ce86c450b17b543f4653b2817d3e2bae0619db09d55f399e250c0e8a85219f8f4641b1e4c084cc03bb2bd8abd5dce109873699d37091bdc9208cad14a5e1b0c7f134131dbd941faf167455aa37b50615bb036518d29e59f3e0aca9a633f8c54d456a09bb6c4bd57fd6a650e3503afb307c2de9c4e7b361d4b57cd0340b0d503b191322bf522e6a3eebd603d6d810e0eb4448739dc31803bb57d4041cbe28e12148eddddebf4ce714410be3c61f952f888ef490902dd2ad89e5d5f07732053a377532cbf45525c3b7de05a34aaf2b2b63f10b2d14ed7f43c0ca186dea490558d7d6af7072bd6320a8415130fbd90081c2ef892f02bfe0a6abe1c864b030d2c311952d7ffa84c2f6286ea277df0e351a42b32da2886db40f7aeae6f18dcbaefdfac3b1358757dcc91537e92c32512772f1b1423022ed7b58a3d7252363417f6a9a67a2f831080f06d8d56c4400a4757316cc3c20e7b8efe129eb9aa79d093d68bc7fdbf5a6e924f3517dab3c0d78985461a3eab7c8eb2acc32c2f26f5699e9d4f3228fa25f1bfcede237e893d36ac17c620ac48ce10852f500627431509dd2ae33c88dedca12812d98380fc11f9d71477f02611706532a0c6e52cbabe023830e2ec3cff21edfcca2ddce1178ccea7df349d30ac5c3279904a10ac3b7c22e2637eeec89e46178ff87d80a3b5215ecadbdc044264a91266b8466c21d8e355bbcf8e692f8040a724705b25cbfdee1d618a5db7ff1be77f0b43bc45e00a30cf138c6555486fe84f78e306341dc33c454b85341ccbd8dca9e6cb234ce2b2179c8dc02e0723d76d9f526cfbd59c8a411f03aa653c6267cc99c72315bf7fc585150616533ee1b4181523698825ad7d6ef117a68c0c61821b051b01644decb106ed097b8393531257e5a1771cb2bd4e60a1be507876574fa6c5182e9ea758111deafa11c4fc97426e542169d1452ff5b6147c169b8a0ac17b27dde734403a02e5f10761d2d3a35ebf9e6e1eefae4a5e63b5be425e631c8a1c58a29e1ef06e75f6d36d3060312331d3cbcaa298824185b9557e71cca00dcf3f8e8ec1ae21ad28d8d4afb350f40bce9a008aae739d653dd26b5b35888d4de808271be8e491872d42bade8b24e80b2f4431598357eb8ac5f547abab989b1fdbd4ddcacd6bacffbefe469bf85d83a3aa8e1777efd5090ee378ef2816fe463830687a01cf9df43ef43f34872a45e8aca90de0b81d916a4eca5ad8146a4e3674c7d09a7b03c4f18004544cb554bbdcdea9699df71207d7ce2cc2a967c8e82490ef4f15c12492ce1b78144736eda085f334d34f7b0a1fd485a830e63fdcbb525f6964800d5ce80517d3b92db1cca403906439d089c4489c4595efaf50eec56da91c3a91cedb288f9a210eed01a61f0fe00e6f7d8aea3118d19b1469aadec3057b2536e99daaa84ed0e96d6fc584015936227bb63d0fc9fe170765d8ff30c3005f3c8b2229ea8a561d98928ea1a14650c388becdb67b387f2c453db38f1b225c5e07a5bf838e50ba963c07d1b200a5b352b4dd25ac02971518e1c02dcb8ee8df7847a73fdee62c809847e7347692fd9f5fd154b4f199b36f07b557b89aef5471175826c6f954e0dc75532a7c08496d66b40db0b9f93cefc368829f43722242a1d026fc426c0d63016d6a78c7de5db14a1a3301e66a6f97f560b3d79f0c1b67ba69e1060e68921b2bf51a0033e400192c43ada3d70276f9641f971f611a289aa1c3b3d943fd18b1a624ae22a24c4fce41a0cea363710b09f64121f20e331cf9aae0ec967c95fdce3c2de64bfd27ef675c85bfa9bbe91185bcc03feb22a60c497e3c2c5651d3318ae4b261ad1c474f84e414999424369814765a0a12837d6ed088aeff80c5e31d00e7c335f97910e2629367e83f72324dedd3f10e9d9c4ba6bde3672a3bef888163967d3eb407f3762de6c1a56ee998533a8ef3a6432be29ea4457a40a69f4a9f6f809da9bf43421fe70e9db643310b1a343f49b05f9fc46afcdc0f7008adba5c520d5ac2604cf3a0a9cba7b87eed84db497b9fe60a610663b4e964485597e221d34d307db0273b517b13c990a1c811743105a8f472a5253bfb580e2ff9db62d0a9b289803307ea9273e9e7c9737349cbf5bad66252d307b39811a85f4767738bac8509f739818a5158329a219f7944ebce2491a0e1784d8c04b599f3526533e1374584f17c49dbf5b2e8c55608909be6c2b4519cc671cff6c51ef146f2b5bafc9dc231cf7196a8df2631fcb3cda91594116e9f676e5784f45a84bc8e63e310db806ac8a1b461d6775d53399503e6bbe750f6be400a192772cfa2a77204c40f314009908c1b461b2ce8aaae3a9698bcaff3e7630c9555168dfde060d6ba6ba353e99a5e9ff2bf6000634e41440571939cb789790b27279c6972935f97c013d7bc01aaa8002da9dae5781ba0777a12142ad702cb42ed7e6bda070e9a3e078e2cf4ce573e4aa05364cce47b8779fe3dc3d7ed16ac9c3c4b4de488d858b8faa3f9e33fcb6899583fcc8d90636339d97fd8ee7472de8f362424673936b439dc83e1cdae4afcd0138981be54c116a6eea6f841d2b36427b32d99ea846a494eed27c44b95caf23c26c22784a191fbbbf848ace24316999483483946fc33afee3c32f1cfbc09743b9136771abe2f553655618d40cbaa0e59f876ee45d732a7aa4412be236912983dc827a7a559e352f39be2e49851a52419ec503a83b9dc64deae39bdf53a1b3a3fc47c3cad14fdf0252c59a9d545e86a4b17f8e8fb74122601dd5be543d11cd4d79a4380f111269f5526762b8c452d104f72dec50236dc07961b811940581cd82506950e2f51d1568c9008d8376721797f798d7ac9e1c4922405097c828995f8e5d6ab26b32b24cd4f03e6063972dc9ddb89c2fc7c84f26a1807fa2ad0a2c5f4cfb37e83b539ebe7e8fdf7875a50a8e4a80b41b01f444443ff8fa7ef3ed4da8cf9319505385147ce06f5e6d1e67e79b467952b8989d201f0f9e4e6047851093f058a5d2ef971ff0a21ea3891c0ed0cfa09a66f686e7f9899e1dc31b1bfb4699115b419b39951da2bd4f27ed00b4b14dddb470bd4ce5e3530a296940774962266d6480e683164525b0c2a9a17a506c916d7d9883a024ca766e49faaa91e38587ddb49215d23fb475c1520ef2c5e59c026424802551fbd3c5c728f3d058667b9d51c8b983462aef8a7268c857da92c554394369122c2ccd310203df9bc6743d4f5bc735f6fc114785df3e21d073816ce7a4d7d1fb3fe7b92ccdd82d6edce169c2932cf41d683205e9287a4cfd4001e828ef365658a19e2ce20fe6213a643689bfa1536ee384ca1ff863ae5d9e1a799899041abafa69f01e963d18865af3033f1be1317ec37210b3efbe402b309c8f3e2a0feb091a3ae4ad1dd115ff70ccc2520977600829c48745be52d89c0cfb144fde0d9b95335326930bc7b99c27bb27f8d4db9d24736ff41154c56673dcc501044012a86248eb8a559e9b140885248783cc81954fe21bc192bcf2acce1a121e71e6815d4d34c0265e86326661d772094ce683600484882af010b03e9a0c78ca41fa4cadb2aec7e455ae512162c1816042d0776c29b6da9cbcd27a945a31c0d4592452dd5c6dcd4c383afcd9aaedb128358330f272c1b8b8456d44a941fb46a3bb516f2d800732c827618e0a16531f219ab3f08af853e4ce720ad7bb47894f2acc1dcf5a5fddfb23d48923646e4c816ac2ebd2dd521d76e7bc13bcdcceef599556536caddb297dea3e5f2f8c9c4e151bfae01ac50a0bc0cb61298ec66868b7430f70237af160c773b468cbfaed337d45bee3515d40c332b237f1edb84b13416113e754954ba5733862ca31561d7936e10b9a3fd08a9a64c9630bbb8599927f61dcf4f9e9535c8641943d6b63b4898299199be1d66f58f8ac68450c66ebd34dc3d6f3ab87c2c38ee06215bc77f9fe9e18b89f4714581190768f65e1db1ff88cbeb3c572ea4c9c73c9539e140085f6a186a58ebde40164dc67e977de7be6dd38e96ee70f8eff89e9b97d83f31f262bba6450acf7e854dc5852a26562bb198780b5cf5101175845089f54a168d80c96c0cba90eb04f11b98682e74fb1e98acb80829108e80908245ecd7f7ee33aefa748e70b37a754509190ab9d505ded3cdfd049010e4a20dea82385d09f5d5be6257f247eca2e1a638546b92a51145ed9f4702d6141c52c2a6ab8d63af300504a36d4d555a20561d398d48887e4f09f8eb50eb1a8af7ec6e3b9502fc3c3e042b6bd02999414df94e70d2ba99e0b5bb80e23e9d14d92a1f7d5e4f8e381c4f2ff356631fca488b3d1e5dd50859ef28b1e2d7b462ae6bb7412708ce3e04c2dc84b8c923802ceaa89ed97a2b9c554fd0c46ddf625adf4e9defee87c3fadcc96085dc572a9ab21950a3e087435edb27eedaa580e890dd388894c270c195669e08057428f0cf78bbcc70bf656581341ad3e11c323909bf248dbf65e7cb3aec1a1cb25ce288b95874e8672fb3cbfe339197ef8560c6a72252fd2c1bc9fb735915e2bcf4c04a0bb780bc279554d8ea2a351666d30b780b7cacccd3b17bed93c6f7eeb592fff6bc8fba859abee43f68cc20bea1e782379303545080145c953ccb4093c60ce659413733cc0b00f6d569c3e37fe7e11f5c6822ba3becd8d6b704a569ea9b167f4f286286285449fb1204df2f450b7e73a7fa96a96903ae73f911dacf5add58b168bf0a6f2250e288f3f86cfa85df191e3abaae043720db37f455f543e037a172e3cc9f6b90a1e31306cb4ba3bed29bc5f0c197c5c3942815757fc5391b717a007dde64163d1f7c864a34c8fc7a3916f5df3a5de5e393e66dd4f2507bcf40306d1d8769b877e5900f00b1ff036f30df88b8ac2c4c525a1c5a3cba9fbf26684b3df8e9dd2bbe5208c3c203b4bfbd0ae82ac495be67b8aa67d3369bc19ce4ddf951e866d9fcbeed34520ea5636d643b6916f56b1cfbf20b14555eca405ef16a6e6f06ab34a6abd6f8f077f6ed8a0f0d7ae1425f133ed980a2bd6bc8b9bd20e4b26e28c94e056013476598393ece83e76dd048d9cc8c5b1d5ec1832c517c1be8b116a46afaa427bdda7f4d799cfe40401e1ad652417df09e91a3bbc8cc67d588d1e2ac8345fc7d044866b02e850d32ca30073bd2a26ad18eaf076753415498c8bda4bd3bd778b8216f6428ecee3395c71a9d11e3cb17eeea820c41ab5b80a2b7958de42cf3545ebbee69346a7fdb633f24ec6fe784de65facdb5e30cfc274fd2ec0dd3690d20b82f2270b0fb9897e9b95e4cc48470d781fb058400ee21f05b1891acad1326358180be38001df36c94f1bbb33dab980c88cf5fbb201c1244c1f65b275b424ad5c8be4f6d2fbb8f14c096bb6c894ae0f5db0f1f18eccef8551e99e36cde831b72828840a0e4d85be4d82cefb4af0ae459104ba618853a52a23bb0ad7e06dfac4ca64575b7827ee74fa833b7158427eeb708b3da2b041434e8c627fe450bc0034df70ebe7e14d83540e1e985ce62c7807acbc024e0c3d1e31a0b31cb556f91c1a9dcbddd3c1f6fb06bd1bc291c984aa2de1c8a6e0e2a1b869f86ddfb4f1bbf09573a08d64c50d4ce9d1af89568158aec6c5f50b3ecfc5bdb46b1ad2d4276f419471b1ba94be1dc5fe0eafb318856e8016e6a4990af5bd8e3e6747b57ae31e43f9662e3ae7763ed46e527d936e2b5734a04cc0ee3d030deca7b7363544f1044c7118a49a4bd66b7c70c26bd7015215d89898d2ef018a079ba5d30910c3294ec43b5480942e4960b17a005771abad70afd665ac02a4857e457a85d539b9e52f0be381b1c5563c6336b1bbf59cec60385c024b6fce7e823d9660235f506e60aadfe39fc9842545675f4382040a7c9cb9187a8fc7ccb48457b45cf23987df8c89b9893af78f772f238e86a26673f91937543a372494bd2e760806bdb71df4ca223aa7d41879626cb0646a10114175233dc7e928de9f5bc35c751a1cf2ccd266d12bb0da742da7f9bf48aa35cb86956b73d6c9254f933b41204f4e09a07aa95da1d126de523f88f2766eb542f573eb87da5c8bb70f416a193f1247ba5d619cf5fcebbe1cc12cccdb1d16c80893f32070e37b194c4c529aae59d8b37eccef93444c87725dc6afd1db01b8fc9ab15139a864e6cc82a9c8a63805c86f5b76b15ebf54714ceaec3fceea09109d26c156e3ea75f15b05a137248969622da38a34fcb6c7037ab06ffa430c49472e64b1dcc8ecbfe8641136016c8ad44188f6e034986ba37aca03450f1ea190d3a2a2eee994d814b14eb4a75e605a3e7e840aa903bcec4405919e441c87bc61415e14c3dc5e0ae23e134048b9539af5a261bd6933da9ff869ca2be810a8e5a597c002c981c9862e873e601403221006bcb7bf1062d308fcf08c1fee83ba9330ca86e1c3b8f21fb39a8ab6076930629cefcb5ea88ca15cefb5a103804c157aeaf8bd9d23126817e71526d2b2cb5f27074e7de3142294c7d8e3ac1143cfac844b8fcb30b5baed0817145ada33ba8b96031223dda0719da7dac71c557649ca6712963ff7fe425410ada731d8e96a231a98df8b45549f04cede71a92a6a3e1aaa243745708cc4edaac46aea0ca0c4b6ac9b8930368191170390a917ab1db0e562ca1b09656d48a925596a197dea354041be1e977442602f3ec6dfed1a046ed43267057c63001a9e6b07df3671fc8c7b42a09547defdf18dcaa4b3e561109043ecf09b58626322d4eb1052d190ef747e553ec6feb629fcdb8a96d9fad1d7bd4773d93c897122040289f995d12091b02a9d2d761a7d5b1b6a221d25e4939f2b8d9c8557758979e91972e5b66ee20e55b71af187067c059325f22a87c4b878d5c0b06e818d2d431fc3def7eb0a0cb77f96c66e1325d82dfefbeb3b217fa1834dc7358520a1ff69569a1bba4e8221792c30561cf755d523bf2f444f0187a7714382bb24219f94530b23e4284e733ff42fb33697f4b532d4c97b8aba93576e37844082c223e31065c1e4e0b9ea2f36a7e08ec659ef900a41b3e24ef2bbbf7e16a7170f5e473ff4c085a9c960ed527b23defdc711f7fc7b7d7482df197769bc1af13ed2196c128588d7262a11e5a552942b9faeeea9eb588a50ed56b2f5aa81bd2959f2f6535c65f3eda15caa6d4fdf1225d1f163a5d3e4236b0634cc6c7458a05f56183b19ac1321b0117a7c16115825a6480046deaf12b3d75fb50a34d30439ff95ce2684b0842de0cc1f6ed4a41a5b3c295aa29168c8386ea423681936f9c56544bd68fd1df8b7841f773ec7735c00c94695a9a95343ebe2fe8d4f274f4f5de1f2a178702957135ad59c1b4ffbe67cf7ca9df2e6ca1ff796a8a8720a26dab2afff0b3360b130dd6effbae9a10b61c26ca73331b3e3e8c7e4dd9b4ee7299faa723c68943110a5a91bd6abb5aab5d658b4f72deacb4c9540735aa85f66e848b5cf525034da333edf3389ea4b6700c256c21296857cfef45e3120dc382a7f31fc48da85107f236fc2732ba15b7abdfc16a50cdc923b77cc760507d200617671e6acdd3d75abd239534567165d8f1271297a356e8d33c11309afe346e21c0fc56dbece73a054259d64e4a4157fc226ed63883ff3205f8f115469c72a9fef903fd2904fa63e9741ce9ba85a8d90ab8372a3014363a518c0244130c6c4229b2b0fe3707935257d2d68f39bcaaca378ef0559461bd88b2a40c7b65e30aa5460f211558f55849584d8074d6ea64328efbd6385761e7088c2d0f199accc15a16c62b682335d922da632d504518ff8ada2c15dd96ff8c897705ff5ea41ca20f9ec1210fac6fa177dae1df4eccdc62b72e52c5f904e723914abe82344067f4ac8129a6bf791a2b2f6e071565f3fc0461a84539bdda91afaa25f22b36efa875b009c2fd1e7e12ccfe1d39173a843cb9bc8cf53912909d58d821b91a92727f15238af9bb130073eb79cefdc8116c9b9f1cac8cd8eccae6695ef3907ba4b877a762e3a9080f5203605deecb6cddf747e193f4963801891be075c957fec907944b29b1cc1d5974218db800eab63949788396a273d4c562172148b5cfbe8aa0d8e5ba24138b739f6ed5d03337ed60a4506e68821d2bdbe2b7f0770307d159db44581dc82a9228ca5222d7cd07e5a2561c5b0078f545d1e5160b650645fa0aed50fe64060ef2e604a404e7cf394c0f465f22beed36e1de6f05e9a9a710ca413f310aef9e228fbab3ea6001f0e7c3c29e3e7c5552ce4be93827cb576c8540ab84fbc6d3a05fa6c050ed4af782203c3180e8b2700301948c112ce5edda0759cecffa862deb7afa845e40075bec9520b9ec2a1cf18ece71c395fa9382e3bb710532aa30376231999a915fa738060e3a715b3229ebb00ce1b6aaca863d4252fb927ee3b2d79ab42951ec56f778598aea826e19b6c06c3769b782535c36c143b728b44a92e33358a6bf5074e033e4f138b4958461da3bfd7610c097391739eec325820b621fa090ead3245dabd9303c94c50d1c7083e9029ce7ea8836cacf3c8c1912c971e912b1c5ee6dd1c9cb6791a4947be2acb5994a3b015133cb6e241c190fff68835b2e174e36c2be68c46bdec77d13b5e394fbb6223edb1868e3333f59f1b4a53590dee0a687718af3c363eed1478d38be971953a60ac678ec38f97f3f98a148b9b79c59ca7d580689f29f35330d9c5000a23cfe4a2b096a209b4ba83430d407521e6fab22d26ea6df8433bbd8d2d9213c8b53781b890437e19eb11cf8764b4f1d317c035602c799e75dbcd19a4b95897c9f2895abf1bf710139f9f9d39f41c79a03e0e4cdab08abcee38fd6ed5221e79a694338ec3670ed388838ed76ce948a38bfc6aae8257f4ce097e21310aac52411fb7c15df4567d43428dcf0ceecc54f6505b7dde7923ef8c7f023cc541b871df3bada32629482e46568d883141c2d901d376592787d5b22f0c1ac1d903bd4fa288637a8f55b8ca6cf5b51554012b09434bb3bf270f66249cd0175e1d88c9a2abb4b1f40596fca99ee91cfc4146a17bb8a8b97ee16d2dc2a30c4dbbbe9da72f5cb5fca709c5cc13ddb91a81a5c9b9a1cb6bdef14401e32dee9767e103c1411b9043045ee56a42e98d3a85d2092b8e1aa560e987324963db9b3ef354655f91a784e9eba92f0abf9ea9a2f343c0202120e2ecc3f34c2686c8335c47d8c46c81f4cea6e944ce05730e365c7296a7b09e30bafb34eb84bf63c815c5e3bc7dcece24a82a2a30bb75ee82f0c6f67047aec3f2067a9c1b2c7044fed13113de3a6d6d30e25e465e8ca70c68432ed6fadf6f9f08692753cbdd094fb187c81ac130a41cff181bd3a89429f9a1e927f008ec152a9e2ea826b17e5148bf1151166d2d335a30e7e02e579c22b16e2cb07aee332d9db3bc753b4268dc0f3a8ce64e83503f9bde85e238ad7fede54fbaa9d2b17d7326e9280e8275ee91a6d9e50672f9faa6569fe9f8e52029cfb031ad85ec4d2bbb724dd4c8a8815c5fa4d01c66f34a85b1c48a7d77e6a5c9bd6453192563818259ea4fd67f634ae40ec76b8075e0d92fd7d72032446ec237b185e9f40b6685ed6c0326bafe78c81047d793ffdd36208465493edca3ae067921e937a0b0560b41151b02e0cb8e2b215ffaa8c9983b2a9468d14dc6ab0b330795e9816924767e4e96a47d7b2f091487afcf22ef9356a12642b5db06c5a940337a53aeda452bd44522cb0e8efc9bbfedd645ddb2196cb621d9a48664a194c8e79fe53dd4447c85c845a9fb201b65483fa820634b3748e56833d750474b6371e3d267e941ae4d2a16b9a1c8b83f5192e037395a1386c1814a72024fd666280c554a452dcbd5537453086df9cf66d7877821d40a7a7a001bcf65eed5258d51bf2e2d24b038ff3814fc632c12ea297638b85f57129cddb1817e17ebe240a886a851e28de07e0a9b85d5f33c18c8d8fd12383d1b08e734380fb834468332a11fa493e65ff933d97614f7f4dbd37aaa0d6ff4c167f3b1911f8baf5d3786c159a0fd2790f5dfc2a42f4b7d42f05ee3ddbedee738a852ff883eb0ed2706fcb85998b0cdb1acc94a7a0396a180ca117eac66f2ead78a551ed86c0d7161740f5b3dc34d60bac9b27c459d9eba754866d3ff91eb76ff8e48d521bf29b43845f2bddc7ee06f3f058d3841a0627977533f2a1f8ba010d3d6ee9b7fb2256f877507da7485b202ae5a3036f157f06d5005d529fc8bb4d8140d0d8a1ad23b16434f9ee1a757be10dcd1da64e1f41bfea8e00909dd77ae57808aed33597ac3a5ad8da99c4c0c11bf5a20897ae7515fc4e11132f24e20f81b52392edf91409471fe5184ffb3290088dc221f1b1acf5fa24b5e51e3f25c31a4632e06e65d5b577ed7d8d2acd6c3ffc68c3a7cb5d218d54b7f9fd5a25b5b1768754588754b4373f0027f12f9b26c2b4f75b92361d2a43f9e7ac5a06f92d886693960c9081ef8dc2ad06b2b0374c05077f3ade90e091ded8c4f29135f4cf8619d7b9906704c640aac737b433354f7d83d5edc179b10c23599d49e78dfbf6793709a85196ed2c80d60f72a551ee91d2bb1389200a16af70e977711385a814dfcf52104970a25446f05bd2ec2e9c197019222e311005747f223268c46194d7e53077c869e3eb51b632e0af12d7d59bf1618d102c475f0a155efb913d79066c2584eefc0c1799baf99190890d3e846ead9862d13e0638667cee1f015cfa5f50e9ae4b2bc6de09f300bc4b1ac3164c486b9ebacb86d5fdc9b41cc03976cdfccf1c41d90f4145b1f2d89487e8a68692e4a2fa19a6524c063e25be1f230ae52f8856548dd53ad40f72f2e535f05a5d9984fe4b72b9f1bfc11f98363c2a4f7cd6abef218055caa51bfc5fdac53e4614f8e71d9cf959be033c8f018132e8b38781373e5358b2209f02247ff15bfdbf58db70ccda0acd1ca0f355abe18f02fe24b83ad5fe21431c6031f74c83339cc6da8673f36b2dfc9c4d880f67c218f91bc3c1f425000af646b5a31d49d255b83464147db73d16faba186bd4ee593941eeb45e2fce879894b69e040be0562afac006ee42e53413f21fffb6f617947a4fc9d82ae511368e415e085a95b9ec4bb1d685406d3f242f0ff4d32c73a675462494f0606e7c518d51b007451ed97348e06e7aa071b4e2cab272d8f21155b0d629db55d534989962bdc9d8dccf0f945b9bc15effa7e41fa70a44256d08bac0d42c55c07e45dd4648c81b398310897f4571892ff9d9dc5072f141d87f9c2f5fb588c2e9b1d62efa6d72b00292fb16b045fb9ff8d3c7cd7aecd510cf49d9da0c12c2e87d588f5610aa09b69cbf3a82e3a36a0f7f81b5267edbd8950f423de723e87566bf229eeeb03852d6349a37db8537a0832b1d695f67ab3f379d29091dd3c710278b952e66b7c0e4a96e7b58f250bebb3b61825d2c01e82a029a0dda3d3e3a1a530be1f518cda8a64c57e504c3f002edee46a00d034a875fb5e5cf49b3d7a21307679fd5742435c865be0072ab99429a8c3e62d32694c943f3c47cd9ed42863e1db6ec69b30a25e93caea9c45012092d07e163791543409b3739143fa4eb52a8b05b9fb3babbc1d94c91559baa3947f423d5a4778666036c91b8d323e0d281ef53ab6187a3da9b05c27a08e06d1c7c6c710317f1212e6d939e0443396cd312bdcb60f82117d73b114b273e418e7c5ffdcb4bb11eb90b5bd81169d754e41e178ca87dfc16bb3feddc82d85956c6a491edb26308ea0e239ed08c0d28162d216dd6b5bf73ec95be4d5b6bbb3f7a32749fade76c3972948f6cbaa02b75545099d3668967b583f75b273d087b9595735f1e5a8c0608051ae4e789478f37ab392502b228f1d7a74484b494af3bab2e6334d1b58562eef0e49ea0bd6c07de7919d4e19b9f25b08e17a1eee113926c1b1464154f9b3e5fec67505cb04e00182796285869c206bfe5f99aa7d91906bfda3cbb5a4c0c1ecdc03b397ce87438da94c711a1cd3d4e92d702432d20b44b1c91fc9ac4a2e53dfb75a05a4dc7ca2e10c6d1d7d868237106a05edde516373c4478c35d6053eea1fe903dd11e7ab1f89f4cb66c75d71fb89afdc84ece6f9650738d7bcb994e1b635b8beaf5bbaf37c8f0151244c46ecc97cd23b8e6b5197443f9a077d35abe99f33c7cc03398ebd48ec6132663167bf1efa7d414ef5f44e07a787d5ad001cb65c0d118a0fdd4e3a664e019f295683b2ca7ab19efb5dfa6b88e8a76e10abb7656526c4cfe2806c44baae5ba2acc9839aae279f3c2056d3bbb47bd18858855fcfc6c46c191ac909ac00a8133234c3ed61c7922c85fed7c3d238f24dd83b99fd9a90f06d80b83da71221f8da4720856787febff41b3427e948f0046ac6733ec00573188700f3a1c6754743adfc8fe6ccee1f77dc5abd405490b166619dd814c29325c9bf5ea6d451ed825d1e86c4d6579d213b140de79cd9be0ea3aa69bfa5c0ef371b78fbbab71252583ba8241224a5ad226b645fd9131730dc91df165be18dc1fccb8b4e6a6720231279d548815972041308b4a8c32d7734f7916047557180f2f9a7b14fb339d2d32935a3462ef18f7228f6de0bdfc936e66716e7c63dbf658a99830defbc764a867accf06c01e4c2e08c8c81faca82c0b859d342302725dcfc35dd9f5347ddc65d2a72f84c74a67f41cfa39b30d131099cbc6780808c44be36004010ca364a460358b6fb4f5790ba680e58050d25acd93a471321b8d6164c158580c773f1f4d56d0b13de0199c0c3eb16b621ecd4203fd1ca6fe2d2327b65036829743e3760006e33f34f83ed1d4fee527a8131d1f390fe3abfddf690b97aede62c00971c452be7a86e48b89f5d3fb050a11927d2a32442b6ccdfee7a4435b8a5fbb02b49f3a2177d7bf98df8612c568cdc3d74b4f0e4b1c3696f57309c774c54e0c612780b10e5506cb19fbe3a4b82e67f11452bbcc61ecb6236a241b63445976f969b115285af7e7261d89b4370c5622418c7d82e57262047000488901c5b40c06a1e7af5caec03d664c97eb1779ec793d494c8e7a2db0a8d01225b2ea50cdf7c38d1fe3ed3c1cc30dd18529d7c4706ff066e5abbddc45cba3a02037a6a0b1ba32d6e9216281fe73131ba0738b50cb12efc6ebf44fa54402f884ab0719d554e2298377886eab8bd90e39a83a868c8af6f7c5cdcb948e698a6d3f1a4668c54dd627dc3b7a319fa7086588c9c7ed2ef7a319e428a912c7556506cc3bebbf3c7e9ef92b1c7b1edecad8867beddbb5708f65a7bcc08770aa44b9b424f3e886155caa09bb47fbecd5753be9aa4f2a7486acc72ab85b83178b4ae58110e8642e80ca9fea7d264bd2acc14b522205a89b139e1ece39fed60494364baaf4df064a98a1678febee3751d6cc4413495b155ebbf56a615562876f20b9cbf83e1854b3d85871c8f4b330c35b91713691e1bbd4bb34c05d370a4910f547136fbcc2cfe827fd9019b15ecb3da1486508a9e488820cf154351b6a312c7a04eebea8251aec9fc44c527c186a909ceeca6628f19915332fc3ccff04009f5f095afd78f2909db483e8e77ac39ce1a97d485017195e76b91a1fdb1e5484d8a51965cb24e334240114777855371cd3fdc0e96fbe8b23c84bcda6d96567be1475cdf9e89551070bbd4f7858aedc30a4622e9f1ebd1c4c1a005554de6903a3bdb5c88ddcc61e746add8b9496dcdb5658945aa1534ec44d63e1d67a28d4d5cc2213bdb932dfe0a006f1d920994eeab3da0944f336eb1884ac280060e74e4a69c6d8d5a4720b74880539b80974f78cbdd6f10d744ee1b5c97dd72e9d61f54260634b26aa525e413887d908b97588a3439b4feada7b528cfac430056f025f46531b0d17692b949cce17775e08dbee4ca9e2cf78363d8c297c773959f1ff2ee043bdced97bd112aecd964fa7960663a841a13a142f1e31a897ba6d9483b72a8d12b187365358aea58580e7ac3b517d5f7589bb4e1c103002fd1e978e5a06bd988ff07eba72f6b69d3b4220f4434751f851db578e4003f2fed094ec5cfbf246b72ec089d7664f11bf3ca6ac83026024228256beecef24ae406a43a1a402e904c27522b77407f3656869169b579ceeacdd0226898244e9fe323f71f1c182c4e39cbac373ea9f9ad1708aaac74ad5ec437ca303690b51057fd0aae518626919727887b6a7bc0e8943e6cc42ff347da30568c52a15f01725899258fca1dcf0b37e38b126326676d7fc8af779430bbe6410cd054cb02d3476702fe46545f1248539b3e453c50621882b0ad1264a3b484f18248b71d11b4001a94328fa6a715a7c500983354fc5daebddfbec027092071aaef5bdd3d77639fc9d8ac6188ea3f221af952c2230d3d3ea7eaabfadf9e5b342d371c92592d6a9be713fce18eddafe1ac9a7a7929a17fdccff587e2d50b8841040b5d897e71bb7fc4e04072e7169a296234940d83a0eb06bd904d2d72c4e12d4f206a8748887638de88cc5ec133149831dc7c04355a02e32e0931aab6fb7b3c7685f3f1e7e91752f648be902a4d980eb6d4f20453c6fead492c0cf4068ebe8bb18ad91f9bd351765599090672f95c9df67ad39b802bed546c319bcbdc0f6be4864f0efd82ebf9430dfdea80db359514a3a4a7f621c7cdd4ece6e53e85b49012ac4b3208cb0f9d2fd6b0ef3300c4ac024e6899105dffcf452347a5e9999426a4a7693d3da6dc06c98c4aa0ae31cafbd4d444f407fc3ec654d1946b012888bb95a02851293f0c3ea0ee57a88165a41481eeb31d7281ea943837b7c9f8405ae0e8c683e28bf3c1a68eb869dd0deaaed857658907e08bb07d572751d880467cec6b09b916f80688ddeaa06124b94d4f428bd848a2c41c651b3420b39cc95e373636532ac35e9be8306eb33278f2fe06b30cd3ad2f49ba19cbfd4d9af6d9c5878ce4930b448fae66a6d09c0179cca1fb51be30e9f60532ab0a869a75711b8d2055faacee014221663bc8ed2c4753a3f6a871c1bf5b464f270e77a62f5f968d0fce29fa418dec6c9e962705870454548d3b9c829577612087a8b57726cabc86f3a9bcc787f2e3a87c74cef69b48466d74841fc9e4e0c0243c46d9c4e8ad453b0d8571412fe434972e27bac583b6b497c6996733197bccc0dcd9e9b73908d614036850f307ae11348dc28029d8555abad7d6ed83783007bae061d63ca93fd1ec64577c05cb0946f467397782bca7d6f037ffa4c3fe7dd1341440f21bfba723c29105ea04536e17d52dcf4105d6ef3de44bde8c0d46aaeb04c3e03bfe855b89e52127b54f1b14f4c3abef4a271b7595e1bac3d59b395e8f2566186b8f66840e84f70e2ee97c844f561fbc0385fc58899a4ead6c87e19285b5843452ec8831fd0cf2cca52be1383123c3d345f7a0b0faacd118ef9c0b08f83ffb260b9d067528f93cac790319e095e4c778cd46d9368a3ff627eea7786f45b2a5582fbfae94bb2053145ffdeca58d24c010ce5ff0ad3b719817fe1d7807f083be6c3170eeb8fdd421bdc0bca7e7a64730b6ba5975f9c8d67025199c3a1d16e90e199ade168904e1634d6755a5846887f261b9c5bb08f263d6b14c0cfabda9f9d453751ea8f1ed28fd7bb99f85564f32ce2c9ef6fc5846eb01c621966a0aec2e3431af52c363f6dc59bd2e898f6effc03f2ad989a7bdf8ecd61219e849c62bbd8d32d603c50dd5ecce527dbb2def4264074aae9075968e24857996c8d41bbf71f760d770e2644da428427376401f4d164a80fec9c58edeb9736a15a0a9fe24fa132554cc4b0ff68e233475955aa1b9be5f4248b09b73795be665476fa1c1c9d2921ba5a6591e29c1fbfb1f92b32bc888fbbe2ef8dce7fe8a83b195686852d507d708bc51e967d077957acdf6485db0d9dba1d5b617525a595783b6055a31f0e713060c948761343baca5bcb6be4310f7a0718447722fce2dfcef896aa4384427982e3047789f3946f7e496079ca1ba08b877f12983955154aadc4afcb65ec83e34adf3ab3897f6696eb25c2b63fe179d555fb7e53dee20f47b305725492aba62d3da8135df3f60373784cc15e63b17e48d509260e2ce9ea81925b306edfd737a3b76647e76fef8cafdbcb8f89b7e982a51c856e51c53c029cc0fc62f1218b9dddcb2f1db6b355a786bdf410ff6be1cc17e4f2c0c9d25f337b6a2e3f29364a621df098c390a0d69c69ba3479413fa38bff3cda853ab062cbc21e20098f206497584867c50d170d518bc61105df91907b53acef26652f51be6c53c1e10f1f004d61130995e16055d74977913a449d8754bc507e2e45a13b2e7a219b7d33b9ec351078cb39da382d913373376b9037b150dfd26f280b4f2b2050125558889e37cbf0d8377b4c27506d58011d3b961ad5d9056f55e8b6588f105083c571917640ddc31b34d843a924ae6cc888225fc45c0533bc8d9c8908c122cbb548c80eb32be418624beae54265194fad5f765745df34a08c15d0e262567e1cd84ab116a447130e11e3ff442c4fcce971ea4dbe69a3d1ba7ba2166b2b599f966981cdd66f395f25e2dcbb514e02fe0db63e288c83bd258b5954a2bc49366e7f0a2fd75e340441e61f9be38b014b2490dd6e6f5e221c892cfa32169b8ccb2f7f502bc2e2462f56bdd04a912863130c4d33283475e98795ddd8198cd5b73c5b672dfca37088c34f16c04e5dd34e429d09edeec8c0ec67019de3ac0c09f4d1033b24f2cf128dc3cd0a19f190c614ba35765dd1764118e27e2550726d84164ecbac786aae6c67f29aa9c331d97174b37fcbd63e7b2d80c37f944d81451179d2816849d62339f64fc1576c3369d470f8f18c53957f161cf1d64350d8e4db692cdb7b449f164bc05ae058ae4cd2810b3af88c272c0c7dfb53941d545e45d95ef83fb9dabafba98ddf17da5b62a2b45633148e1f1ac0bde31e76e8ba418dde21e665e32ddadc0efe2be43cc5b663261d34bf035c54e40d4434dce5a8a8c065391adac806c01eeb20afe881acf746152c3d54fcbb8983c30ef01c5ce61715bde67e6c828aac4c9c8dbf48b027dc642c0dca8537be007af1d0fabd1d8e59b35e8cd3bbc72fed0f3c90a3ec9d9d4f506862cc3163d83518c55c2b0b50154866bf218d3ef2d6b00585d6e1c6414bd359239ec94e315825a0c70dddafd2476ead619fa0e169aa0d86e6b35e78f2d807b6d4135954a9308ad0e5aee38074d0bf38d6e055334fe37e0c6efcbd44a4cd8032ec49c6420578015e14c48f58790264346e50227f6497b1d22fa0c9d62440f00eafeb397eb7116ddd4005f6b40874ab787f5134d27ea189868ed53b474e944a11989a597135ee58e455c9b5c5c4fc6b7dfc7a1a7521ba0b84dd881cd07229e5d15d4f3e79b730f38671a6408b65eb8dd9e7f8f1635619176327ac44dd0d9c50bd814cfabc7c12ffc4b82d29c6b3828b98d2de76009dff5f1388515b4f17f821348c2869babb57729caa4f4e073bad02b62ededde94db96c1342bbc25de9dfd4711f50081ae0847abb0121ef49580d8b4df4fda517a1a835b5fdbd19385af219de703bb73d2ec23f16524ddf55e4d9b568be4e77896c897025f0a0ebdc8f762174882bb88c0ab19ed846bb472a99d54041b88439d229572839a73f712f716cc0f325db7cb2084a2bf8b8b3e6acb677d2d99a1a83378c1e346e3b563c5590040734a01f96f86a2400e3e298dd7e22685213f80017ec2781d11b33a5bae3ad47a1795fe7366f4b1448fdc9a148104aa54270e42700a09e61cdfef0fbd70b2bb330943f90f2a9cebd4a7e41f072e0bd976c7378a9e0a12b4bbef5a386475b48cfeb84ed61872742bce93b20e4186584a1bdeae4d6200a9cb789349207b196f8346a4283ce8372578923921b773f6be78c22f2f6c465f2dc0f182350153e370f80c9bd252533bee8559026ef0ea059b8125a6bd89543e1f4c4a5052b1e777c32dd5cb23fb6348e6c1bdde543f5fd6d96804d4ecc5fe4220f4509077ee373faf8ec72df7069d42b02c8ba042dee3cdda1620e3d14669165e87d41283fee88e75cd1b3889b5421a5e099072df4533e644078a0d2aba9a3e6adfc4f3a29806432f3a72259c63d7532fc5598d8adcc4ae2be67a56e04c98ac478be3baaac2e11bb09d5cd54fa37804c2860b7cb33a4deaea38a690b1cb27aae6313c4b53526a7f79facf27f47c0092fce069fc26555dd03cdfbc6d4133f0e27ba7824c388951f39fbf1916ba98e583f20e97ce147b92c7cfc2d5727e0a76d4030e024558e2f37600e6fb298de9b81fdb77c589a36f3f5420ebd4f6af553f3d1034edb3f672ed4964f03cfe743882ee70f63726c2a67e17c31488f8bc23c4250fb4e3268a53d4f1e33ffd1426bb45ce0c3fc87059fed648c93514a18cef3163f88186674976bf56aa55b149743f8d47c244fdf26ce782ff0f29eafd5ae6d38a1188f88fa90a3197b7f1f009a40076552cc290877de1e545805ac38138a34d6ccf16cba0b8d1e509f4c3094dc374155aaf4f1bbcf1a5bc55018bc3534f4ed87924383064d6b04241bd6d4fe15855fbbb604d2480f2a1a23d09acba31227369ace53748c217e4f9ba345f74ce8cffa9d7daf72a0a54474c636ce99e9da6d0626f85cce30f96a9d5ab2bdbcc7e17a7361f31cccf290a32218c6dbbce1b2cd528318645181b6a2cfccc89c9907239ef45a8783e601640bde6d722894b292a12227db587c7ae107095cc68c9f2b0f005da7b7fdd297b0c0e15e670f20cabd46ce7fb7b29dfdf73e301e7e5e6d249983ca96d827939980279114fcd0a09f130a00d58530d56f252f9a219d44c9bd58e1f91db33a6386fae86ff87eac93ee9366f260f6497390fe8b325bb1abdfb3a1bc433347f9f204bc9a3fba917dd0c958b418f2ec9d7f0d9a0515accb784c65a766cd4af86032d6bd8dfee5604206bee6b023911f9e646b78dcfac80c97253d99f754b51ed7822dae3e5d03e1c1daf8c07ef0bba0727c699e81de3b07fefdc7992e714f5893176e423dd5bde4093e9b5c889518fff78e89dd9e647420d13ef1acc6cea27aca696cd34cc3599972c82042b3a20f90dcde2aa5e732ad251e4c1bb1aa5a4cfa03a849badf46a4f2f3b97bb6c56edd5796a6f0194abe90ca8fd3d5c7ba65d218f85d60ddba7293960b2c40ef3a60cb6ce3067b1d92d4bef0eae7d38ca457ce321a0f2fc2475bacea54a61630580b8a7641f0794b822731bfe1730c738f60ff56aaacc4a0999f4a2ff70357d9b3418f53c2eef2805df63ce16e2ee7177d2822fb78232b10f261e610418d82c4dde5155d578d9cbef41e9e0da601a7dae8c4b6ff7ab4b759eb00f1e21d915d4c6f9041498d2358dfb66fcda5e9a5572ee13fa4694b64cebae9cb15572f9a5d1cb3d4e2813551aa3f04b5ad868194d3fd86a7b78e949381696dbdadd413f3b3c9d0bf4fa97c12de8339e27ac2ff29219e1f41be7fffcba48b9000ced19ad0be8066372f115d423fca2360fdfd544687b01dfc475d546ff9712529062d6ec29f974fe8380de855d4bf0a571241ff12bc2cc317e305d1c661e8e2b3eb1e41aad81b0da48772a03fefdb5eec82bbbad738181784579d60c35e877a398307dd9658ee0dbcd3bb4e92a4384cf7f2e6bd960850adc20a7bc2ad66ad6d7b15b3a820425b5a0c997119e47f7c705d75f8581898bc5f286a2ca793d8f424ebbe76270ecf1f9e39a0f2f678674a52d9e63359683af5241eb5822797ac4bebb10ef0482a17a1f8ead03a3d8efb09134334fa3d333ac036d1ee401597eba7d44fb23ccedc722898c250d6fca0b6575ecfe2c7406b81a89eb7eb34c527d10171c3795993ac3f07dfe090e9f7123f345aa19c9392aff678b9e05d537fabecf725fa8977530ced9b627187c5b7ca034d1e5e7cd069656010e3f99a10c03b860cb10b275ee3df46307db936e59cee4b2127c9ee09be2143dc1b77f2c39125f8f31f70edc6bd777155fc33c0c3b84124d6f9e571b015af5c35f092f27bfed269b3c1379fe6c3037a4f295e3200eaea089ae488aa0c3ef075470ab6ded15ca04b41d536c947e1d0fb9088cd2dfe16b8b5ba228052f1b16f4ff45a984c30e00e31437d21e98ec70fbfd0a78a1251b118587e22f294f61567319cbd097f1785baa6a15c107e6ed26cc39f74a11637d7951f669a17791dd5a0a93283b20322741fe465d199766b03866d60edbc5d00ef1d52233708e97d8495afb51baf4622253749023be1c686a1494e4ba79a68a1c083e575b00053f947ea38a1561f5e61912c5f9111f71de57a0ed77ef0d80a7f1a46d8d2168e0ccdf70ca10ba87224e927df80db4aaf46f848e44dbfbc8c359cd7a8eeb931b739bea5776c9dd78bb04a3e474bea7c70b609cbed00cf705da638e5c659d7c3abc1ec8592e577a43c9d26e6c3ab8fdc07b44dd49f27665707d67adad23eec84243e33e35bfd087501c43b6db7aa074158c963bf065eed14d849a5110e0902bb43a7f770381c4973852d010a3ee06f5e44f1081591c32a33f58028c005c1b46ecba562d096c9d51e5f866101043638ecd2414d0f315a2b705f63eb9d53d794a54d16a5f2bddf36731d14a639bb579bc2e2a1b0ffdf5edd8b48cb679c6fb97de361e8b72cab039c095580037548409bb96fe31031344f3da66b350876b4e07f9ace7b446b8a49d62d631b3653d63b57386e6d2e2483d87c0deb9e19f9d9ebca0693c562550134546649f5f76c9fbce1543b85d7c909aa26f5816d14baab82f827ba12189715911ac5a6c42816eaf8c87d25cdf92717a1eaa432d63e9513ac5583b93c1fe01e01cb90fb5863f346c85151dd8d180663b8d3308b4fd0c15838b718a577b4e2e8596d8f93aa9cedeba02064384dd2076f20064c56821e1f17450acba344fb42721376581037e2a781686eef0d002ff2cc060abea98123223bca241ff6160f7234bc85f13176458cf51a636a39f19f1c1304242ce664df5277bc410b136acbf01b59defd1f61f7dadb6d4c7584d03aab6da6ad54d895d61b0af2390cbb998f96f0f1afb3576faa8d40a9112bbf446f04bcae2a516b27e33026e27e61289263efb7c830c263e20a72c2ba6f18a93481b314faa906ca809b6bc61a0dfc94e29c5e69f88c6d045cbb4d34f5f293ab3987fabd0ea85f56e89357131e2af579a14be5051aa0928e81d45eec6ac8448f00e7a9dd9b056097961dbaad989c12bb24e54154b1a0d4b443098f694984ac7c92e759659b0a8ca53c5ff3871d0ed6a3922097622f204bd3dc1fdb076081fe04789be130088db3ffc2eee28cb3cc68da8db12248fd21bcc7c5a0b8da452248f1d91d44412f8f2332705c579d140d7bd0cb0b49898251af16383185e616d9b218db878e56ef0fa97bb34a1f35e40e186bb7466990660e9d1721f0593066e074b29dbd14e0eb5754bb47947fa8c15cfb7fc21b485f5297a8991f59f0b78481c651da6d6471b24b3d71326d49c587de5c27a2039ef410e53f7c0ea674ea40c818f555809f88fb2b81d3f8965f498dc5f255201f9ca03789a508eadc14c1e36b277617b41931af95e6bcfcddad0b38cf94b16001a6afbc6baef547f10e640ed6c266d0a6bf9137b389bd71793b45851926bc27a1d5ae827f1649043d14b0044416527027618c6dda0f329aba8721ad84b3d236ca39962fb371d7c02c5d55b83aab71916964186bcd78fbe5518b1dcb241076e0cd08362cc3373f17e13422e21309a649ab174c54a3afff87cc14949ef45283444a24c5f40976dd20476d4b67366a0853d2421e2e2c5743e6d8bc7b633cf1536d60042da0e3c06c5b3918489f1049a47ec64ae099c2d95df735588d0206712af71692d9a742b75cd2f9af5a46e20176edd303e1d593a3fad50f1f606f1706cc3d422c0d84e37f89c443bcd3edb26eca40d4383eadf946c36f648dd26973a23168286aeae1e3198dc3a9f7cd4359aba7dd66b03dcfc3e1b011eb8086039be319295156fcd3f2e2bb3dd4d7477c31f77e07d7762352d88930195a32d1db5cc19f878a224f53611a729074ce50c21229884fcde399d85bd28f86966f59e61f2f99adf0c1c20cb5fe24a06140704d6af4fade56baa9d9c1b126c4567d26ebb62a116da62179c215d6b6690ccf8c451ba7150c3bec422b36a9de19025abb23d607697c2f8ecfa31bf69565fad87b2825a7ae96d1b14dd21636d9e725f75e6472ff50b1c2451258010511a6d9f5e86bf9e84b50b83e60ebad4e34812464d490333d98138a714346624150bb8b22451e6646e62c1d1f396b9143dd93b28e39f3a75ff3ea717f59a5abe3ae5f832e1d158747915acad51112bcc90a0659787601e43c172a00ec13159e8f08ce026b8964bbb40d7d4d6ca69ad1b5e56bbd65c2aa0d17596e7de0724d3cef9a674ef94ee1a96daa365b74e3f1707718dfd9dd266caa77df675d8b0489cd71eddd8c24a23db7d39e46b239d3ce1654b77a2b2a14a7f90e6755a1c750bad52919b5cd65b4d1a0ce9868cd92e45cb889f4859511da0cd4e49cebdaccd25845a3b41f2d3513696cf12afa0bac3a63e636473119de06596ebce5bc3ae0c996dae60cd8fbf33a85b54abd826f8fef1454dcda7dcd5cc9ae66784a6427a4b9a6faf10fac9922c6d488057464e3497b88be75394078c6780904d71ff6397890c5f160f8e6bcf9c922cfdba8369262e560681d693e64d46ad1a079208c1e479ef33cf1bd58bd68dec3b7c94e11551863fd49f7c65d476c7a35e4595f742b604deab324a73c036a520b6b6f7911180133cf93df4849c00f8ea62b7da5da7160d2c9232597c2145459b8e8ee6aec80781b9720f46c563044d25a7a4275f37746f6c4a0815815bbc7ea4183d914637804a699b0e4d1c69252e280f836577ae8f90ec7c3ffd71f267d824f68651deeaed70f9586310f13b22f736400a799bea6572ce9a1bebfbbc9bddc1fe5f0b39a02b59b8b34c33ed6a568b280e606dce2d803d656567700462e56588bb3f7c45301c48e69696a6ea79627084f70af0db1e3c999ae77f728c9581b12050e9dc1582d07bd7c19b04015bff909931dc3db9ae46ad65c531a95b504f96a1208b766ae5fe2b9a185c4a60a7fe9855a0e0188ba944b306ecc3292d3bcba21faf22f26323bdf2b7d01d8e6b2a9896f40d39f10a21ac38fb3cf8f09c57135cefe852107f03d9e61d228f0f9b9694c5d9ee5787f2d9f6ca4540e45ed4a96c2f26a42838906cd28ee38762eb88ac75ab5f2ccade3ae70862a70ca0e65dc25a9d3d9f1e9b81776347919a510be5ad7ecbebe5322b4b188a9240dc2cf106bc4eaeadae002eba737337adbe5718fb45acdf214635543c25f2cfee4fa630b619f4f6e7e55adafd88b30cd37ab77027f29fbb2f2d948f26029ae702bfce2d41142f22f45027fc6637720cd543dbef8f81b760dab232782f9aaac63743a2a8044851f69368665d3ec56249d5eff4f7f71dc2e566693f9e5bfaa6485f53356c993957d4da26c6d66301275a5f2d841c0a22af32665d0fe6db37b7450fe98f8642498e85782cfea24cff23fa0fa36e9fb73e12d0ee32f89f99641b4652146de8e5366e0a1f34144aa53aad02fa3ab7bc4368bcad15e53722117e09206fdc444b986b022693926daea6531ac49601c9a5540bd9790868fcc80ee8337132af90ee6e1b68b5650f0d0d9af9f5781ec48e847c3208e457eda0fcac961b8df3a114c8beb7c6bcc43dd4f4a5cd5194a2cb5d4a0ecb56baa3bce0fbd0a00e3624bec64649a445a3eb7bb594d49a4d90b9ef4d6396eb352476d3fb223b5c5b9c85f7c4d120d95391feaa5958ba8931478dd8c56ec3cfbc54a4d8f25da7e1505cc77cd75b184742f15cf76976f7d7f0725b33389e4a042c9ad84f91b1da60443569a6e6bd08baf9c6299a88b54ef0c1b9e9fe2d48d6229e5b823b6c5a5be831717e046aee2e345c03954096a9a27d86d543f066d6770ab8155c9b341ee035f8581805870e3f1d1bfbdfd91d0ddfe01313f5fe7a7879dc83e7cc2739f5f01160aa0981b942f26a9959197af7d35481b06e114dd4d0834a978b901baafdff200e53ae612bd0d2fcd44802325f2bb010d812e3b63ef357f9f954016207d4db1762c47d067271701058b774e3faaab2863b485a31d25d525c55dad4352547481101121ab9c5759af800d144882c4b950a78c3af10aa5755efed82e796e3ee69a78015d8cf1f6352749a1f4444a9c3a6e728b8b4f24f1ba783686f12697af48c5399308ae8f04e5f94684af4237b8fa6a86cfece7457e334cd9247a590b0c02bef78eea05980b0b4c320f942f21efdc872b9a0a23b8cd4609d60d71761acf5f6693f192ef9ff743f7ac7fd23c70e5c8b1c88a6d52b686c48beab0c1542318bd1eb8e0001e36fb1a7c07e33343d26db3c71d82086ae443c9aded136433486f116662b28943380070e7a0789a6948617a9669c5e3857124935605b68fdf6c98d8823172c4a1f66e728fed176fe45e7769afc68cd605d8af4331ce9068c7aae2af68d971e7fcbdedb27d91d025f7b9fce8a97cafa44719641bbf502dbae46bd26a282af92abb49a87e4290ff7f264c80cf6ebb979414dc332751c04844a6fc894ba0780ab616eb9989a7e35944a7ce319890f8afc6129a3d59053d634e91173d5c8d08b2081b6b3b720fe572b710d828762b0ae11eeeb766194d268edb50595309d7864e228a0c2cdd194901cc8051eb1f75a3bedbaee680df61e7725c6dc28413fb293a764ebc9138e40b67f2e402eafa45532a5331f55167e54b6ab600d38beac1e27c4f3f693edf281580fd5c8bafa0e89893585f369139518b2a88b9d428924184ae241daedb1cf387a3cf353bd89d742685c34dbb9d954921f59dc654338f3b23cbb322c1cefd33f1ee46a42e95128198b36a05ac8523b678193e3895972e38836772407fd60daf9fa2a2bd69761775b3fa21fed3c16e806a86e5f421c7dd785a82e582ed163eff2b3b36b8dd2ab81b1cd76ca4070add706063375f219128ba7c2d868a10c46a30e5e590b0cfe8ce3743f4fc8035095c4e209612327f07a073bea1d91d63ad1d0c0d6520443cb2fe833ae04aa8495098e8a2f673cbe64b338e9c9405d8f68fbe9192ad123cb7d26521f610bd3e865be6f8fab46f15e6b5ac8e8dc78e406c4f311a417ba9899f91be7e2a6060ed94c958b53f59f78e7fb5c5b3b9e0ae55841b3782021bcf674e757b9459bdfd435eab2f634c06946d9308a7983072ce9588ebaa5e307d2fb191944f70ed00c393905ceea7e15be42eb615611ce7c5382979b3caa99d652ff7dc1281c3e67d3d88119a572040716c3e982f5296f1a7c2334e7ce5b4f13d31e342e81527ea5f6f410fa322333e08fdabcf073952900ff893ae357b26183de8851158dcf1a0ae17fa2abc3a5cfca8e1edbc46e5c27c9d9e7e9930eab0f56b8ca33a1fa61752467d4fec7f601a49534bacc4e0b6de9e57a70071970672fbee148f114ecea0f65da68150c2042c0e372ce06b92fb8522122d729afc35c1ae2532d86f61e61723b4f4c1e4eed8359fe29acf746a32ee45506c5b44235a78e152f3be7d27f0c85d2a1a4fd0b4d0b2221e3ed7472979a11c812b68ab5a38ef58c60f332ebb24d97d82ffffb599ca9a198e2378d5850dfea555d802e440fc43ad4e856584a4919f7c56cb90f340e8b5e81ae0c1f46377f78241c0200ec138f71c812af03741781d093ddd248341ec2da40159ed016f6064d074c49f9301278fddbe9670b3e0307a2f95b599eb122ec3c22b18de6a48eb362274acd2cf3a14c61aac48ce23801b59f7d31c499c453773d72c8f357dd2c37edcb001da13902784c6eeb4269cfe6e419f51e886053831255e88a3b202721f2d186eb1f855717c26a64b0fc414c268d3406fb3da0600783f17292f2261b71e8e469946809e9d71327718851cb006d4d21a33426338d592e33616f2251f911682d1e458c1c4a5d04611c768136a7656ec8d0f961c3fe66aa7e48c84a37bab1f70b9e7cf73e20ffe386a4dfa65c999397780983ac847c91104ecc66898f748a8cd7206665585d29e0f284ff8590b33568303674bd20dc0eb1f8e544d3e894471adb92301f8bd70854f922f6bf026a76e7135451e3b5945613d4fb6b9900e79c4c17228710b7e0cc5858c88bbbb4dcbf278a08299deb783333a516b4615c460c40425b372ec079560a30a2f3f18017f548fba578c354365dc3b6e28114fc8783e24f5fad7b47d5ab2856b8cbb3ecdc40376a385a7b87b274a8401db28d49827553515d098954ab0818e1b8f12395e03af142fee18d73fa20539d2cd104bf12d32d8aa35fdbf0b0fd1b085e1bc20985eba7916fdb47e9131dc72e2e73345f0a24cd9e1b490d40aeedba6497294978c881545bba978f028c4d18a27047c1b2e87d7df87a9541cd93fbfe12fd4f120295853ea2c80fabc4c0027dfe35e5be9f2f41ab4dd1ffa017ddc2100a8aba673b7d94b46a133cec87f43ad8ed9fc6f8ee578472137a50ebb5945948fcfb559bbc953dca746bd8590e6f9cd2ef7e67d35897b517ef989b08a8c640f051298872939237abef7b77f40f1cf359492c3baff2d45708f0f4a68632537229ffdf887a22142583c880a626dbfc333a49c50c11c8c967803efdbb7298d6b2ae6945cacb3afe72edaa9c04d8e86d9b7cf0a78f5a6c8c2e172a5d68a703e364f164344b8e2f68bf685cd5915e071bfa3a55d4cf4d3f2ce3850c0bb1cfcdd5725d29a55ba0a0b0cf4bcfb7a831202bc073d3fcd0474226ce6bdaad5dfaa036d765652cbd2e6eff04bda63eafdfa181a6f7e6bdbb1628f0cad2857463937e50bde4a238eacf530c3cada37fab17858b3f13b06cee8066155a4b925aab8a935bb936091e62c5c6c6ab422b9d867fdd466f4552fb2b5129d18ff74e745335330a67cfc6124cf93a3c2247fc8a9acea4cc987d0192f47624233d111d9fd2c79bc54175e58ee7654b7e242b9a6d30d272914a2a19fbfb15e4ba06697589a5478a52939e8101ceddd7773b7f6bc656c3315febfb1dc15efd146d774051128231e8f80ee8a360000b1395267532b2b3322df1947e2c94b4331983ead7106eb528c83233b487d43e88cdba64a62e46c6ab082637fb278741467136b7f53a3c107d942594a12c0056bb185ea5cb14ac89ceb443cfb409b514fa5aa92ebe4b504d8e78521098b6d7fcd72fe48c5eeae71ec22d406d436b40d595c21ecb8a931765455c85e1e6382e04db55f67b0862bb8c4403c4954958a2b3c2dba6f2fcab9f2fae958079e44e713edf511861a7ae18d994847fb8d6669b36537a1170a376b05b02d7916c3988597e358ef7b949a6f3f2287b26b43528f24f08e9c21a4e766f3e991e34cd8b32beb42a66ef07cf21bb56155460f0d3a7f299d7197dcf36c281b3602548a352a51a09bf8183f74bb8cde783877985e01b06691f740f35e5c02e2f8664dd5757a6ca30f655a30695dae47d0b90e18e720b7d9f6aa87ba0ec5c5a9ad47867cc2f7d0a9b028e4619624e4f630f647605db4122fcb664bb5b27457807c413f711a1385ddd61a4f29968900bf591af39dea3c9b6dc5c4543ecf9fb083ab6f7995e3caa1e274e5177fc974e3c7ccac1de5c6081f85c9ff53dd4480e0b7384f3ac84d05fd0242fd22d6255cb3ba80c95097291761c2122e049c3fde048ff9249cd8100bed611c88123b53fc733983d272f36aadc1dd0b9f7a13f9200c3fc6b1c9b7c6e72fffa9861097ea9f7c27bea571df2505524d5ab73f8881a59f3b05c5b405f0f3694e28636ed8275466ca8cab71e20cb1252df78054c22009abe112656802f15d09c83b7bb25be5045f83a59bb045a236345a666211717bcf0280df74de58b3307c797189d53bf83bbb08bd38997a7ec43f58ebecd275b5aaac19a10731c8877810933da4cb48d727c290528ea85bc65db36c14ccba65d79c0fb5d4d8e9aaa1ea885ae6f878980bd6e0a942d1b873162fa211b0e562b74b87560954b556d95c2d427d815cd7c08bd9b8d83041abcacc4b50fe579065cb255c1ac29b20c486d7fce41eda9a71b6601b6995a4a07018339631be1a662176573d9cada2797790c2fe15791623c3b0c8605111e35e5c6a80e9d49471c69856e15d9bfedda70de9c4bf36c4e0275d36ca04b1489bedb3e88a471f0e9afe77b7016a2b3d435b15d38c1f2881114088664a229dc60053b429b5ac808743954e17b0d9707c1ee71ed55235ff74627b01127ede348c965118da1cd9f5954e45acbae0e1a98d23a7e5ae86cdb41038243f23c4f9304d15963e24ddd841cc62859bac04824227e9fe5e1c8c590c73af3db454e48e8e247832f030ab79ed6566d730e50d0c42297e2ef899f0a2461c773c6f0296eb7825f7b34f260faf28aa02eb2f34f3ca2461543497f9276d354fe95d6898818fdc4e3413ded6713d3fa8b9374fb8069f3dd3a3388ae1029664d85a94af9fe08f3594040161143426ce96675bebbd922465b453e99755c54823485bcb9fa51ba95fbc99fce002c3f2625ddeebee1e6211ce243d3bb9b1c691437adfcc7f89d32c1e730c5f7bb3e673e9f1310fb99ab404bbdca9fd1205a4d0365d18e4aac99374b73c39109c280112856648ecc7650bc4fc99f5d459df5d93f812ad016ecb647f8d502233a9da2c7235f505dcaf0b51ff0f1c75490ce681e40a3a81c6534bacc5e0b8190f1876d88589e237733fec7c31a619748f32e4a04519d203469125120ae0ce5b2493117a7f64d11276c4c9927617c111fddcbd83f9396b23c10dfbe4aa9c5d194928af09777b6323e07bb33706164312c730520a19fadea189d44f1c0e0d8bcc89a720cf55367d54075000f50330e2c5f69f3db8dc8414b1c9568d01fa2897cbdc1d43e041eeda32ca18e50f0e30139194fc42ec5cf408395f0951e35e9fcf7f872cf462f5849408ad3399d1bbea611542510b7a3442820cf6d5ca9f98ba29d859882ff492be54480980cbb4d1ef57afdd1c1b4b89b894ee5b0d563ea0f4611af8366f3aa985d645b3199961f7c4eb265b594c426b1b4ee9d4a03b2226002f97347ae6df597dd2aae448a40118b505cd42739a271384702e18f69466a151177c768076f19b0e96cb1a1a5d9ce319d72e73f20f655b94895e284ecc3a6af9cc20a8ce6afce01656e1461520d9615c7b46cb5a3cca4a3d4db14fb15bcb5cf135952d153bdd323b308df63be6094e9a544df4e94d94be50d2dd2cce45695f5fde5ddc3ddcde766380de9720a96c23c02b343c682d03387a180cd50ec4010534ae9a3d2ff96e8b58f69511223c51cab545caa56e68c43f0e1f1eb15d24b0d353078305831b56c6822391bbad3c405263d12e8f61ec8d2a4fcd029ea532fe4ad658d71b63c001bab32e2ae7c430d5cc118662b570b4f4b796e992fdbc09829a1b6d7f6ef291e2b567bd9c40566461e37f61f2d0f30950b90af2428c11f6ceacdf61de611b9dde4f581a71e620d06e42914211dc9bb2ca2c6b2d4f2d12600c74071854ad184472e981931f234bef280568bab7a317e19b986515603c1c4d14f124e68af97d20c8fed08ea6525e1a2699cdfbac15d8b6e564b53dd07e6e7c7fd0ac52dba025397ecbbe00078f1fb118b247c969cb426a437eaf46023325827e8e2e9d8c595840bc845f168975a830de5365bb92f9146286cf2eef23c8ceb408e478589e4620a699b9ae63a2a5881538931d5f814857eabd7cfc43d0ef60317282df4d9b352a1b60b7477ae65b46804fa28376eee6383305d29393e8715546236eb0a10c114f78c1e1197d4a2eeb070e616e5ab1e8c6ce1788565e5f654eafe224ef278f29f1207d7b664da0eec0f6703b9dc2492ac8626eeb038c01629a7d51c46688141d2a4254e3b32d66383fc36e2ebb230d528e72facf8ce763acce1f396b8d1f197c808f19a9b2c3d69e2248f4ce044a37679d3fd971e41f929c0429c26d3c350b6ece592465777196f577fde9c301bd666dc99d46228919b1745fa1fd2d444b0b4be0e3d5df468131219bcedf82f84755798ddafc8c7dd599a0e573b6ca56708aeb083309511db5aee3b18502c1dfe4cec54942af822544cc0d06ce3c46989f61a6f39611b56a4dccb528c5a06bfba3d5e2ff028c6a3b02ef3b849825453631a07a9534aaa3a2f339cd09a7f488d28ce594efb8ea68e4f68f055e4ca5728b41d844f4c17845fcecba507c5140c43f2d3751f53cce73d9167327fac15f7cefa9bc10aa345fa944c85c02f78b0b597b345e380b4a59de3f69082b15ff8826fd861fbaf222eb1aff57959fe2b10bd587adb092bb939901455bb78ebaee58a9da68a69b56b54faefa156d33048bcd51dfbab76fd9beba46ad9ca4da7aa80e82ef5bd03c1f7e6451fe8fef1314c5e2e67086b06bf755920a6e675e5a753f184b2280a53b6d9368f17c323d89a151edd2f4a69789e3fce49290be25f0a3badccc7eb0df82a4fcd47741c587e8879577d026feb6d1fffa166741f698467656c2965a23608cc8608072b2ea5b06b6566cbdccc84253be231a152022998561ea12d2e98db5bd9612d427abbc791d048a7ce37f516f280bddc78b6ca438eada86f79241f8dedb32975a81df63a992f1ba5047aceab2abfce57ddcebef406515b0ca92c977dc910b30a5ad6fc5ae0bd89b449406eae5faa1930444ae60552253b29d88e17cdd7728f0d3b1d338fc8c9d1915cc437f4dc25c00c48248d4864a689d159802e9761d44961d7ba0f2e59b848c69ce31e0cceb9cbe726f55519d64c46ed93ef04f57289a1abce6004b0386bd148d7cf5f77712a3a4981ba4a7673306e7cfd5588578b46a4cfb44614b422e0e13a6dc3dfc0449f9c1916e9eacb43a1cdf0c6532c79a0fbbdd9c1b627983c65699a4040205e63b7c21093e5d758db37d32ff5528f227252f2af6d01236a3045f0dedfdcfaec0e1a3b6eff3b4d59e45356acec4ec75e81e768c9b734ef05d7642c95417d3221a1f519712d9647df5fb53238518067c83670ca6371bf7afdac8a238fb90bc6311de900ae800edc5da1d1683de9631fe71bbf0ae00504e129889205864df431eb04818f470f515762365e342c4674a5f9bb9ae15bdfd3e55d430df9b578ea2b6ece76a55781b93d57594190409319f7e28ca1e3df3c8188196254717ee754c0d71844fe35d8d49c4be686ebe09453e7ad1dfcd31cacd5011ebddaabc6e97fe3aa3cb7a914acfc1fb81e7805077ecee7870b94a80b2814d260c571fa69f87ca171f749ac5575cdc9fb8481d2dea1ba108e103499cacebcd3ab2e5edc157b7a8ac969bbb6b8fd7e8e9536c21e8f1ba2c673bf94354e82ad4ba25f5dd336a0b9a7010e76bdeaf6c3ec21e1f2e8fe1d9143a17a94aa1498bff598768512c6724e1df8016d6f582d8b33736bbf34c173d4de0102966a20c2447fe83d07de852853865c13ffc83934f877f507ce128c9405675e21f204ea22034f89761c5fb8b108079d5f788463d458eedfb2e953e95f877524ffd1f3c16d05b612af22e9784a1b0065a1c78df76b5ef2017eebeceee7f2c9c14b3e91a33c6a7e6b06554e580dacfcc9541ce1f10cc5519c5c593c7c16c0348e838c7dadaaeb9e4ab51e24d8ea3b14ccea31b7a4fb60ad74e925b99d55bb05873c9617dd3feddeaf19f33ff087a44587dcdf213cb0fdef419415be14ebb65e82723af834d9f3b49405ab0bbf0fc3433de14c2e7ec9aaae0fe89e72bbaf15eae1998a4e2291e1626d05277aab5a859eade621c738ada998f216f4e90126ab6c9d7b4e8ac54935d7297dc5d60d49c5d570c01612935f5c13929fa730441038e1dd55b1b13aa310bb381a7d613a7d613d8f6de973cdb5ac8e2d87e25bcff01e76b04da336766ab3873111824c96ad87b0d226ca852ae61a92b782efda367dadf6c16fb9e48e410d90c6ac737eb549cb3e2efc27cb8b6495c65094c2b76264d0bb799f199e420d10bca94a6dc0d1bfa6a92976ad85bab4bc0906efc657f6f48a4e41b48dd9d843752e8642bcf4f2be9b8bebf827e7da4078b2e10cac0a66965df7fbf2fc247d3f104a1bb3ecf1f64a8e705c282da4746e6c1303bc811a77a5219876824e492d17b6b5ae57000d42e36d873a454ed53ad0f0a008a8faa2977cde73f390f73235979e748b2899c80de937741c149f4ba109c3ea91ceb0f197ce42ce792bc751fbc925c96ea1b36af19782a9a0bcb50a856064d65189f19b333e8b3fc6dc26fc5baa36845f39dcf68bfd47fb03ae70b06068d15f98dda5ec1021b9ef5162f63c650fdfe75de7906ef7840a870726f13f01fe6f6f7c5cb085f30e5c7a6ea46f450ae455562fd1b88de8600dcec2e54bdd16d702758aacfc7d4e8dea521194728306af64582f194766cc38b10fee8c0bc5f462ba9126509ae0802d144e4052d3d00415caa84842cf62aaa548ef3827eb1e4b5aaa5b64dedfaabf6c15d7a96535df661f47b52f1f2192886dcb041b4c4926f25171e163dae0c47acf96a02fa17c9169cb0ccd18f7c57e8614817ba1e3f0823d163c09d85f309b8f6209da6f697dcaa537410da44e6570d0700d5af159ba5fc1aa1325d3ab26add868bc5f118ddc58013b59336aa37d38865af598222365dec9a78c3dfa6e0232717bdfb9018aeb402ee9eaf3e340b561b9f48ec7525210695f8b9488174fb1b217d2919997543d22af42d7c91649cb219e11c01ce933c4f085242ed8f0a06b47b234cadec486b16ad1352b180d37069e71afab49cd9cd14afd77bc6723d8c9c22839e7fe70604296f067d68e0aecb54b6f94601d73479d34d002437ee86f32b369f73a403028f995cca77ca9374d4eeb18d05bb15fdbaf8d235ebea2281e251063d6b1ae38bd49668c1d2ea236e5e8fa60711a0e70afd587a15a2aa9383c6f0ae4e859ea8330a4934b94c7b9081403fce8151af03663c7cc18f3efb579f600bc91047f9f346fa1d803f1d5ecd2868651a59b6e8fe466260acc20120653ec34c3de84369c70ea4e531b1f645c44c93d3811192e089dad95529da368547111afb472dc21b8c1bdddbfd3d830fefa42d7888bc9477145f0304dce1d62615d14c1f4919d14a834ee8c16ad74f297792f919488d7387654f5eef4fe2175e588d1dcfd50979d85a222a403991ef5cd58431da124110a466ad1e416ab686dd725d041dcb40242482822d6a8f54d2a70f8d41fff542f2b22270dbc046f824c0d16544930abde30aaa98260a27373565b2f13270193666d5680a3800451efacd2fed54fdc583964af6d64ac81ee66eef930ed23be84628cbe119179567524d58329cbb845059b6755550a5036b924643ebe4ef0edca5402422cdb46f79099d184e860f373dc92ed7bc548f58e03df93ef15ff6f301fdfa2e8e0cecfe8cf582cdd682ff47a8f1ec176a45a2572e321c4df96631b3590fb796b2f952f54a6255448c2b5171485713b83d002958b48ddb6c1992f5dcfa18f9ac0d394a9e6b96088e6508c5f618dda00f84b326c090bf4a171e4bf364c54049338309f2edaffe6f638e1013822f9a43d459c8277b6e0e70bc91c3ed9286c2b5179c9f5cec455bbf9110e9d132c9efa0400e610363f025c3e44863e1ded6117070d869fab91bd1b223ec8a3edcb327f3aee86f546bc61a5dc358d0596fea4004a868e4ffefa9b18c1a546ac50dd518e83ddcf6fb75188b6dcc961376728194091ed3c558645bf783eefe5d96faca1f8aae55b0aa0f3cf670d92f4d833857e046b661a3e1982d68ed747ebb5a345adf18b906da470e3a19815942a7024cfe448c3e99af52029ab857a2df1a5c6bffe0678be1de82ae098272a2a3a45d5b31f816484f2598e035f52d76acbf7a9778e1e82ccafc977feebe9e0afb142d517c5e70dd8bac506eb1d8c54e3b271467d86291a8414f01d9eab6862763da7ede946104e27448b9e815b6b9f26a5492cc1bfd2b658fe8da3cd092187489ce3426b5d34526421e6a0d04864ff148731f61dce9de456b68b2368bc803d013b0ab31796af54cdd3f2e0ba1c6e63bf8308eb10b4c7bdd6dced3e3255e9de9c2f5a84a3c233027a09822e261fe21e05a9b9c6bbcfe17d80a0c908202b0bc999f602edf8885eb30577c380bbd43bc482229d95eb22a6d86b0b7e4577e866451b00a2908ee7f9016fc4738c76fcd0b23ac97eb0f67e801ac7d01db8b21ded3c969f6c771fd4b695bdf9ade1f71029f8a781eb238a99f2234e36dfe09dfec249bcfad1291a9fdeb0b6a045f39a41d90b631868fab2c40dd072a88cf2071a89ff2387ec09536aa3b862f4c1ad2a209ee37953732fd3d61b4bf3c76799db292fd02498955f1e4d752d6cd32b8fb8f872bc2e014794ab63119069b6c9bc1669a09cf4a4f63a27690bd7c7e8af245412062315b506769abf7ae10dc75ecef4746dc163c7b78a3323913f1d6851da29e0e8a3f7e6d1b5e94e71f926bb7ec75e79f37de1159e72a4def1e3d9ba2f61c31d229e04d6d80fe88338cdb8d6f17dd98f4c65145b61ff44862e2e2103cd41ad9d369c1ae6ce36aecced503a77f3de01cf2627c019178271ee507ff6978ef0f8906811f76b3bb4d2458908d00a5e04541e0dcc3dfd156a7ec15ec55255863081fa60543c44e3cfc914165cf2aa5543b39cfce382c0955a027257bddc8eabe55fc845028a1336431484dcb603b226494a42320172e9a698d2a0d8a7c2d45b407db1fafba1dc8d2630463623d96311d328244c50e7ad03ae3d036491f6441debc7f23b3a3d556f84cf2f50859498713bdebef5e697f17a06a99d999340b85548b35398d12f26fb07d87c66f5d716998e029b8f96f22b08bfe7961cd17e79adc5ff63ba797dcf141f13f4b8a6da2c1573e60b188c1d6aa287da9cf7d79dcf667ed7271adebc359df68aaf30c4c37c7cb683340290c683b8a19d127b3f727c67772a29147382afb7fb6525c22cf13deeeac23099c6c90db29cd2c435d7581ef80c982295a709cd0690cad531b059d5bed800ae7c6619db5ff346345fce671e88f4a4013fc73d9d6577579a34f3c85f1d37885f505c41c2f59cd8951088e6aae733e7a142389d2f8a154d2077a9b768bf69f8bde25dcd201213591fced3a31f958f6f20ad9cc471ebe2d75e5a48e87009d4e0a0393f385665c20c5c96a1e076456cd43031b6d7a1944d6aad9b6d0bc315cce0adde17e56019f8fc091e9b1b9a311b3c9b176b48d9e226085b4c1b57716ab859252dc356bdf2518b86c4ce064e4ce7776500d48ccd8cafee929b0a501d10ad3bc75c74821faef5a32724f92684e67dffc644f791c0d018d57e696f8a78944685bee56e64e3e8037ffce68d2934b08acd2fe51fbdd754a5ff8b244b9a9b58336e70384ce45ff6bfc52b78572d376a3a3d475905b4e936e5aa1fb48ac8d23a493ab98b5ad3b05405d374947be6191a70197b32b075862dd268511f819a4268884911dc6473ac6f75511c307bae7d2d30279cc1238db72d67050cde2948ec72dcb68418c7420aa9e1cedb9d4163662b25a0a84d64229b0b2374a1cc7808264002320811422dff79da565b6a415e529cde96569db43371de99e5ca5bf0e354b801141cbec5cac3c3b316147436590a0bdbc6bf54e1bd6c65b9be5986cede2bb78666a1666653aa012b280c5dbd6c9db597819b8f5e60a0c47c4b6e4be8ebcb60cf05627da7b0347a0efdccb45124190330b6f7709b17ff7c577a4c38dddfe9104b96aa4a0e39782f6bed9424e14bffdcb41f4ed2bc54ac507a3171230cb7658aed34bd964f7330c73348535750f8c75235e683288b4199fd61576de90a4565b3ed89de60c559aece0b4242740f3bf86cf974e2e6f86e017d9c928e94d7ae076c22929982985dc0c333e866d4308f8cf55151ecc4de8d5f2107fcf4506eb4601524378a9e9074b2b68688b637d6162c86585a15c439108003e59ccd6ef064f3d3b1558e9ebc78c1630f95098c84fff22477ee4eb1b0f11437e446eb087806ed123b349be034320841a103eaf2ea4e7ef6e5f4652efa9117acf901a82e1f68aef85754f47fab662fae871086e01c14e56c600a4e297420ed24e289082e3d7c175b33889432fc0e6010e3f30b548c0ca59344fce8e35b1395f7483fbbc7330418c8546005d377a0e1b8abb2c68b6a8e9fd738cb7ea08d17a0e87b1d30c740ddbfa746b4d966b6bebebf5fd5b18520a3cefcbd161d9ee7b58058f6fb721106553795b80b73a89d9eb453a2b954cc22561eb260cb01ad9c5c897257730902669c5d72bdc2fda35c2ee4159e7ca4f074d6e1c4d2235d754b8bbd1f31d3a36d5aa006274d532239fcc09f5fe78203ac2341e94bdd00e9a5db7e831b82e42da017461f961f8d5e45b42479d6d1d47ad5e59db31129f95b650eb2dd082974b889abf8d56bbf65ecfda2d851e7e0d269037388ddd9363487748e9fa30475f2c2d03d1a970626f62476a6bfae99e268880d4836a4b621d4ced0ab779cddf70a7f4ea40d5c41f0f34ae6570cf0fdda7ad49582c6e6730e746d7790b5d981493951f01457bb4bc1c73b8f8946add3549688384b3261770a8a5e6ef9d4c7321d674b5b4e4fb0eed36a54b481929537537c1ef28b0231e33c9691915878b302b34410d6da35a8f861179e42450bb382ba48b7bb162578ea6f1d9ac95684770ddfb93c6c6e1249250d3b72658b7a83ab01ff8b7eeb2150027ed59dd10e7dc24a986cf2f0e93cd98e6ab2e50f1be099bcd4eefa7dba8ae927e6b286f22722d121187fc26f871a7eb4d1120d70b979794656e173539c5c0389f9ebe4d677fab15990904b5f289b13d6fdcc9e797634ea2625331e5b922a6d59083d2135a418f8695d32929d78c12629a4e6f383642542f3d9e1d71811b6f9247c098068283b956b3e7c79dc4988270aa0588570cfedb7a16569656346f4ea3786a0bfc07083d5045e103f703c0f645928bc8a6cbb6940d6f98251a3419e72e861015f253fdf6f67d5f82f1d08bf7bfc8156755c5f11e56c6578297283a965c1da74106c99b2c45ac63df2c3e40eeb1e986709fa7f5021d01be12bfaab541b45f239ab4838e5b1c109dc7c16eb91932bb86d80f5d9514f7ca9457d04a401f06034230c0cd0912aac8ecaedc753654ada1a3f6aa8f353c6cacf623ff6f77a4bf7815466a0768ea5f6ce788e8e98ef8cc5c40bfcaf25a14e605ab18c7cb699d09bec391f688726be2a9c8780e7d3d86b3c5f6eb1b0d804fb55784ea7ed7ae8e8abc173b7a7fe35da8bf458a48a754701db09c9c25bc7bfeb5cc3f84383c4cdf13972a6578beebcd06f0c0e89e493f60539b44f81c788943b3d70fae6977fd8b36d76cb8f23d8fd86e85e91f6e305ba0f29511c7bd5b5323a6e2b00a165d222db5b0714a7e2892e98c36eb9f4abc886dc121a43f170f1dddd997f83fe89dd96dc05713a87df27f9798f5e514aed42f7ae5d00d8bf6e05999033dc6f5d25771087274397d04d3659f202630b15b865066915576a48bf0d1a6f896e65a2882089deb7e54bf0fdd485781f04e2dd5125c6e08e04030d1992aacb85d3775772c23a6dd59430528db649ba6be45d496769fb02761c536a23d8129e1fb24c6dc644e97ff25b44e07d2c6cc941df5c9947b30909461ab543bc58fd0b6504dc097ae1c7013c51ea7780225675968d25962fad0f37b3f815c3a1fe4800027e4807cee37669373153ac842ffd522391e7804abb3fb8791157d18c74168c0b3a5af02f51fd6cfa2cad9b8a96574f0b20bc3894f9214bfa0ac608992bd4925d1f9e4c4288fbc252ef5c39025d482ef7284237df265f3513dcf39e007a842a06da96f3d33dbbec0317145719ac88445139805a310e4d14c3c527cea4436cb34d89ebba6b005cec7bbe191fc2177fded9fe94481db3aeeaac1e89a0433c043aeef6e665c31f031bd916f351d8f365a0ac2c301754c91102ab1f421159f961c8577ceed6788167cbb2c363477360ea6cc0a02ef6ffcb6d37922ec4bd86b3effde2bac235733f162b5a77249f7f00af5310b51ad97f5070e0010cd1500d8d688deb2afba758c95da12fa204bc44d21a12abd63c8536939e60d1ceef610669af669b7ccc989518a62cead437e4287898b68cad8daad4abd9407a9c2bd5f1aad5b4a82cd1ec3b2d2ef82730ed92f4508a3a524e4a7d541907049833f901874b93098e42778cb98b68412044a33ae9292bec9a4d1d1a52e2316b16a4657339c1b5d964937c20ba0202e52ad0967b772529be2caf0dfdc098c6c482ff4d28cc38d10a2d268f2899c3b48484ccbe05ccb46436a7e0e62cee0e3d1b64f695c00eb4a0af7cca66bf86bf1760a819a06a612ac2b0e0c30d6beeefa34e53894428d3b3f8d116fb3ad03e9e4c2351f2f0aa5a37689aeebd0690e12770d725010af9aa554eed2b12cb0a426285caeadaa8200ddf3bdfc6d2634995c3c83c2b0ca012f43fab5137023e5b7a0806d73eba01b53025865324a2b41b34abb62153aace8059dcdf259dbbcc76b8c3afe47128bb9cf696c3f691885c350bf6bf0e430887604c4742f35cb7c9212c1b6f9d09fb74d6414e94fb4e7f9cc9dc0c50d27fce9e164289c0345e60ba28b70fc484bb3bf85ddc73f9eba26fdd84cc5349c9b393aef644d88903bcbb0731a0ef973622c047879fcb1097a6c55d02972936ae910320a6aad61a8237de326b04e889e7d7e592ab024ce6662d587570a33b80d27783a665d4bf92bae56f3a57abbfe584193d9e38cb0afdf27dd9d9288a236d43f6808d5894a62afb17d4f3302802c4460b67be11c9243870fc738f99e62c2cf4aade9336d1f74d9fbe1dcf80fb66c295012d27be42afb7e42ffd6b6a9067e4b412cd0d90be105c17739729af4b77c60a3cf42bab08ca339e084c89ed8577b257de958655ff2a088f97e21e6a4314a39b9aa8f0712c58cab3193398ec57903161b147afd65712b5fa9da2f142dd3028af53aad02990fa3089e025f402ed52b7582d97893519918b752d547839f354660a17e1aaf384c21c34055bc51fd573c85cf29f83ef6d0e667761adfa96faa816456a7dfcab59f2989082d4a32e25ed8992b7ae18fdea3f774a69acfc2756a001ea9c62ba87aa44c51b6b5ccf460ff75d9c44be8c3d05e68c814394ee74341f3dc8355881bfdfa2c7d83ef883100858f7f6dbc9d4a216ba6c489fee62d066e3b6ec4165b55662b307fb0a701fcaa1407614f116ed464b0e78a11031c3fb9c41fa38aeea3c6343072774e6b754887fd13208dc2763b3e8c665b83c28066a2140846b87bdbe8b10972982d7088922ca778ec9d5fe84c6dbb3e76db8be2ecea213dcfdf41d587d82ccfcfd14869ada597ff2284e40545b5b8320254c8defa37ebe3895c45ec2b99fef70ec2849ecd62d8f0d4f0407a297c53541f415d907b5adccc0936165683a6a63b6bebbd2ae78dbc9e7d6ae2cea1837540d5ff5b981df327a50a78d8d350784f710bb381c70fc8e6d84e6707e0ceaa34409365811dd617456b92136caf158743c8b6c0fc8370db24096339172e5fa70dedd88f3702b9689001b58d8354d2174ee55d76f8281c5c5212ad89cdcb10d2e18c58886060c3bb3e67b44d2f7812d4bb106198edf1d33a3cc1542825a6e54ebb2186c190b59b483824c05e9284f12ad59ed98186343b797a6f7076c3a0a05848ccd04c64b330e34204e16bfbda33c2c494242757d1f59c023c39163d8e706b0c34c4b2b1fe488d70b48cdb37f389ee13119ba398f3690a5b19f8b5e63a9468056f8bb7333c7afdfb2f123e52071af68900e8a591de0f463cd61f499e58814adf7c8d0aa67c9c94ab8bd98725c69356f4fd53ac9bd47b19904505ba0fc9b212c7c8f4faee4b8b71c1ed7cb5baf192d5a46b35c87ec29553980143bed69872ccc335ff9638868f5c19dd5fff6fcbe5fbf3356a28cfd51c5f45f3d53ddae4143ee89b30f852417c69b8e210671eb3f2cc24ab03d307234a0dc1f4ab3f0550718f0aaaad22a64a226daeef8357189caa0589719366fa03d06e942a885aa3f79dba7e7a16eaf1981a4906acb326e7f5f99017a36a6c69c4f6daf2ad2bd9414e03c4d326095f54a37ceb9cd409bd917bd14e130875a6c1962115596b4c65675c27a1547427b6ff937f53661d7af7717a39ff25313f59d20dfd6018c072ed2e98256c98cc712a0d1504b8f42a7c4741a96a04c1a3d606156bd0b75faa254b38dc0e36f33b444e17c1c582466bed34aa66cadaaab4d50d2018f75649fdbb8ece25b1e94db8d4595bf57331d9821391f6d0dd16bbdb8573b9d8f702746b83a62826e3631279c69a9a026ee441f3cabae625e54260e2b220fcbe049e813435537d8e3efd121549d4bdd3e00df1d90e7b78c9e51551450e56bb043d0ad6cd13f71eca32035a0ffdd0acc15d99677630de257a15094d1f493842594f5da0926357f8f758141636926ab642ddba5d07acd1f9e038ca535cb9b6df50c3d56059345b5098852895a3b4ab01d19707eed23150fd2b348a58f951b9ddd8eb2ac00744de169cc430348db728c66fd8390d7efa23225304234035c5bef418f6a373d8f2d1a975828703fc099f1eeafcda6bd66b946ab9154a831ec4048943c1005a5440392af88f60dc5628c03d41a9e87e9ff23cafd1f6a7f38f2acdda449d70f8a6e304f661a374009ebc0638b7f64e7accd679b2db18b52bf500a93a0a0a775d7cbd49764a89a5efbb6bd8536b0b37f0a38ec1a934d850412f489efc78181e85ea54372d8c21b3729cb4c9243bbd91f906754d65eb5271c3ab2105f4f379bd10d8f2229371a429b051339383296193b23571515ef1ba161adb9addc64354b0e7df3a29f61615823e5ff9d25aa3f03eeace13c570c21463c6abe90c62a7310218d073ed998c8c2350c75d69befa1d9c7f3ec537aa7fe5de56e0342a00e3200e90f669be26c0f10e9cef67bb65683115f2b9db6719291b29db14377b69d146a1fd0c71691ccc43eee624fe29ca071ded1acd0443735729b2d722e8b7219ecdfba76203d4dee5d26397a255864bb71a716818bc915ae2d5dfef5ee19483d12205adac8d4d66ecc26a627b3685740ba38f3215a5d9cd83e3d53f88b0856bb650ca864e86e4ddc6ae82748e5e35bd180936d74cbc15470f2e0698939f91f3cb245b66ae512085a0750c18b8e8edea0e6ba8bbf24033544ec3848d9420d405232e77ea49757d4532336d83f33f841cfbeabf2e1f1b006aa750e4060bb8080af641f1ecf2a4a2ab8ff431802ac49d84367c90a5bb8df83c59554e98553b6a72f101c70abb393e33d234c558287cc3b8433ee4552eb6f255412117fbc5caf2c069cc86d62a02bc6df670b09e01389afd562c0da7589558a992856b282150de7faa2a472f7ed1b095b51fa544b138e1de9527652d2f2117184b97d673f91a2441ee6abcb390d96da579b8b325a443ca9dcb887368d9e7d71f4d1ae011ff76b7dc788f1ea92a62c68e537b39361575fd764af49e6e54e3067c10f71693c1b1bdf4c271bce587cb6adf4ff3de54a3951c021eb7cc15d3a49e96be04840b07e68b0a860b64ce525aae5a35843a83813b05107df4381e2a6f65ef5b273ef3101bfa377bd9e3d999da5a54797f04f82526e752034d042bdca6bd7d89944a907269b272af185278625a489204d7188edf024b1296d5b9478567a4fc1392f6a9f0a1f0a9d8accc1acb5cc0b1b0272756fdd8d0c0218a8003f4ad469500dcf2dfde89f1f6bbb64dbebfdf3753e20ea11ca18450803bd4283578d66e6e97a2890dd876d60fdc86a81456503e237d523d0eaf8899a696d223f9964f4bd2006f1d2c0d723e2148c77dd7dd54423cd611b50d2c3c779bb4c824c615d32df56eb7c4470ed6475c21d234751945e823e9dedd1f267ec0054e090a40f16b92127134073bcef4d9cafc789f3da90245e8ceba963fbcdb704fa821a8da6f1c7711412521a2b16726b33aa40effe5dd98bb7d98eb650e02abe840586d4575eae0c90868edd1a584b53f1311ffc0fb1e688232146f7dd5174d6baeab551b425dc74a4d3fb2d69f9e8ff2c8ed3b77dd9934e4451da8ff95a79081da4e0d89d857cb03ccb87146a5a973c0cf33d18e10a0248a5b8a047cc09438346d5951f7002c69369e1ad3efa97178e9322e171871fbf5744f5294f58ffb35c7f01eff4a61b958f4ec2183eebe0ca7aaa9c393d17f4109331c57dc7fcdc2a6ea3108696a82ae81db585afaefa465d11a2b3b17386f5673871788642066adf1a83b233b9b7e519cfca543e0df702fdc02f5f409f36dbf413a7ad8ae20fd6fbecdc3dfe7b36a9b8c5a82ca42e61a84ef5fc75cc3ea97fc786ee0ff86424def2b8f19abe46bb9ca55e872f0f17831bbc25354f464a7abe21f4e3ea986522b9a0a7115d05b77171e67f6191f0bb50bc7839c9af53fbf306e9b50be26eaf3722a0ef6c9660c1e851703627ff442b5c0659eb6be239c41a74b422bd2524a8c6acca47fc96252860207d31555ab9837f323a3704b395383d106021bec326c3a1d8da5ca4cb5f1a3b2f419ffd75366a7b285e9c4660b02afb76cc2bf4a21677e7a9f2529de8a6e578f4027567fe05afe2f6f03b83d9f77a9b27d7a3c792bb85f0cf91e238d9e7cac4477e594eb2ea2e7698505ff1b0661f8f5b2a0ebf71c9ff141cc85d375732609bb95ae77f653b2cb6be0410f5710e46908ba3d52865b0d45d16172565a03eb436e670ad15ccb8946d52aea8d6ff2d88ae81f40c1f36ce9af87047e4b7a9347b46eb2e4ccb6be4da40549a3a6162bb3ea150b360780b85efed72eb3950a547143fa9816a8c3f83ad853891ac35548d00c02f701ddb5d7f4835efce45d96e581fa6581debd7a2210a38d3c8b1dcc383446f817402c019d1f64736248538d0c20124114076b9a7abf8cf67a1091d587988fb1c7acf67da79074190d7e24f0279ddc7c2fc05c12b3c7142b597be771d0a85604e1590de453de12cef3663a11e10a770f8415969fe8b8514284169f6e042e3b5b2c339c7d48f0c8b65d4d7cfb2eaa14fddd77741979782454050f99f6c53425a6d77fc9394971ede1c37a4145c70ee2a27dfb89d15a270f6b705a6fac914366e52a178b63b22b59446fa66fbc075e1c3208c5a2125a76a25dba43f4104cf7f525ae01681cd33a6f0736bc5e20897c4cd098937fde135334212fdcb19d6593523634ef39103a90944eb4a7fec694bdb1788e748775e95d6253b86e4536281de503e82712933f03126fb61f90430ee1d0b7f5ba66afa31ac2ddcc4e8f6563de8874bdfdf47ea96e352b69808571bdbed0baf26b1ffdc10a7f99645a92a550ce36eb42e09c5a955fd4db9333f7f0bab9a10b5f7d0dace9b6587d7adc7a0753dc13e4530aaa6c50b5a9fea4449a20d0dbc53d70ab486b92a6bcabb1e5a25eadd46b35416f69048d7c88c1cb04d45af07ac0ae528fa64ce1eb63253371c3ca6ad9b770f5f775d4178315ba11a60c47111ad079f3af4f9b261ecaadfc6b139a2fb22e7ff4ddde4151bdada34bb6926dcb5951711d9e85e922ea9c2ba572664c5c6504727923dc711c75e6b3548ea885f8d74e5ae6199b788bb3aea6f57b13a5a0423dbf40512a2c51bd82475cfe41037319817af27d398a74faf30ea76a6839f43d195c11de2c4592b23a2ac27010596cef8d4be62ccb5dfda1a46e26690d09ed9fb918bca17a6bce45dcf275b865304c9c5566da5558be8c9e354a97e46e57fd0d1e624205feacdafb516110752cd9f761f0d3900172ea4873c74296fc5f7a29edbaa0af22568da97aef4e82c382aec5d23400cad9ff798a7a1f89ddb7e5751bb24c82a47cb0858d0067e2bdf92bc4eb06a624f953c356664c218b82d775f25242d7687c93878d9bab437385dfc9fe1d450d4588f317ae1f266f4f2d358dbf87b9d05da4436df5833d8f3d6ca8502a7eaa962f00c87243b81c4673c167886885c5a7d28c800be3cffb90b441a793cb1e879c371eb65027a343d75959aad76c429c271eadc6a8d28b77cc53eb5d1e994f16bff6160260f85b786c1b56290c0e55ece244f124751d7600abeb199d36caa15e5c2301f7cf0f701ec3f69634547dae1d1d71042c334bda00c08c72dfdbbfdc77fba89ce1bb67ecf0b1b932b3c0071756b39422ed88fdaed1b8b66e5d708f5676282e7e93391cebb98f8210f5abd62db6a5ce901d8cad8211a999e5e38d86b7eab79eadefea3d78daeb754464fe8ec6070423830fc35ac9ad31ecd5579b76905d8695335c55de82397c4dc07454d2192ea3233e73ea5fe469edf8ee415704980a0a84e9283c4590c2378b3a2e0269a961b6e0b4e835d7707fef47b503819c376df3cf4fcba09676dee1d66e4a84c71c5041ab12e8b130c2b50ea6dbe691716e2fb4295deaaf8d5b1ab8d5a3cc9654f3603040f9253a7d3332e7fd87fed54ee4086de2eb58ed2a14665cbb9963ba9792195579c2373a10b8a28d3dde2249a15810e39cc8e64e4603490fd3b9290bc18e9163703ac8f3f78d2c847a12b5ec4263d0ad913931e3786b4c762cecd839c6dd04caa80813121fe5e5bceb649c60848a0687cd2ad3bdd5f92e824643e47f3d632df935d18d6bdced4238cbb3ae2ce4fd323b40e1d12fef24c9339061875be15af304fbafb7a67c4d201a7680ebcaf0ad5cbcd5a8b5bdac86b96f676ae11acc821483a360bb6a4970a7f732c421ae1b3209f104cd89fd66507e0f9916e3c8879d9074115b873596d50249a61fe578516b00205724f034ce03e95380f9e572868dbd45e7fc988af3f97f896837299ceafd9fe0fa993c2c3d810c1b64314fc436daad0911c087913a98e4b540c30c7791e9e51c7938e4bb753c47f775a93d0885ab0828d4890e11e7e02d5bfeada428f68998a42eace718d6096006b2c52952662cff8eb91edfbbb16767596ff8b609bb42929d03cd2f9606b7b8875f8e151cb63f1877aaa7bc1f3831d4aa6eaf61a2d4836be4ffcaa0982deb0b80a608d84e2cb0d79605bad41a9557286d4d78c10846007f8977b91bd8d0126ad58280f16a365095c1a1f5462d272de94859939404e0741c5cdce1eb077546d91d67d9bff5cc9f93654b1eedd5014dcf500bbf1ca97adecd2376f6c5fafb9128554cf6ecd887fa71c7cadea94ff11f63c859db242648baa504923702976c2ceab329f08491fb1be3299627078de164547fd7bf732f621b42ea041e3fedb3d4d888e0d3a3d4490f970ff90d6446335d5e46d82cf7e21f85d3f7f448dd489ee41d89db32d06e8ff8aa909977bfdb81ed8f32416db3e625ea70ba4860d8362587c3e81326aa36084facb7a9eec77f7af3385e56d1acfe395740b2089469935db77924fe353f7225cf20eb6e5c75b91c0fcf1496a729aaefac436ce9a531150be0fe78b2d879214b40f3bc0cccdc30ed49a98aa4b94ee04c9bb663230784f8688d450f579cf7169db51ef81320f1b824ebae834ee5db97d0e5994a8cf8df4ab4d5825f8a723a838ffaf09a6a16d0565bfbb3d4c5cd70c64b10b10963cf1413aa7854f008db285b74ec5de1d200f15fc39fd9ccc94566b1cfb3a7cc1145ada52d6fd02fe9aff0680235df1a2edd9a2db1608cb54859941d9e18bac6af5552e68817f77378e603485a25d1a2db7ee3e2aef0c6ffd750ba52c16888a3551c44f41826203113fbdb8e03ee837687d17502582821b48491e89de53334d1ae272c6b31101a6a4ccff79660ace3c8b1c4fb9750dab84342d416f24dfabf39150c974ccc9107a7c1b85e923c279e8c0b2a11e83f8d69a1169d95318047feba137d4c83abafe73b8f8d57e6cd932fc2c4987d4dfa44b896e8a61d6e5fed7a7abb781a88fab100648e16eac2c6f54eb8210dced627f0b93104e0c9832aeb5b491cb3ae758c9d6d282673f5cbf70675d351e26e72b51fc0708e7401443045ce6bf5f8e64caa8a1c3ed61a6afaedd8bc0d7af8da342280aa6b8db8c1de25332331e91ddc27095e83d4f896efa7d7de56d30be1b52c26f70540d220b1202386e6d445c293e62ae2aef9ea9c9c904428523e14a1fcb2ea25f54365cb7b562c8625101e6b0e73a098947e64813025ea0da1a1c6ea3f4c478f84f41867fc148b0d506c878fc14e20ce9949c713e366d008e85e3d0cc4fb197776a3bd139873f36ac5a3f23ebab13748cc89b53f691d2afad01830fb5bf3bffc48be1b8e81e78999d848399772500a049abca9512085ad4dd03b42342977db3ae9ef6b33235bc8833f7e0fda1fe478576492198dcafc00296b61679c8da6223a71f50573984754a2dded71d6c4aaddc56e2d30eb5bbe019e7d2ae27e35690cd835bb1601f12a2934630023e5ec20dcb5725f1f694607f77939a5c5045ade3df89a3ae1955105363f1bb4a4ddcb8a25fa3037110dd53550da740bb0f6d9122978d827448b841ae0f0bf0df675d63c6646386534cb832025f0900cfb832c3e552b19baf59bc24f73bccb89042cfcabcada8eeb4b0c451d71a5046458a8031171e7c719e9c46d2fc0ad6fed441561ea4fe36b993979659688fac12fdaa2353bf076869a14bdeed2f7f4494df28b4e5cbe1ba10e702cabf35f4c875fae51013bf7a42c43a5aea0de345f73eaab3571f8c8b0ac8198f720086f81185a88ae78862d7b9d3f6023845db13e7fc2fa477b8e39a065635a66bf9b11b9e5ece4133c515c9a3c9302b0854a065e0264a7995c7818d5e8a138bd5259ad1feac6d9f9c7fa93412826768efc386935985410a2de434cf1edf066300fc610cd635c215b2600864a4812a32f56da2f0faaa56bf414d36d24ea4e3f41c0709307b30735f551a213b4b062b3058b48493399a29748dcc3020c0d568e202ee74f96a3692fbc24418fb6b870a95d44860f9a0f2af38ab9546093c893cbdc2fef780e63c62a9c4b6874059c570580c787540e0154244ca2f6cac690dfd9437c5315e68bb279a9034f7c211ebf6ee11f433a4c2c011f2df9d32e67f235474e769967fdb520ebb5f08df0c8b07e0a47c0a6f1d2095aa406a7846c4f6846601ad39978fc903b147a9a3a32b6948f9511c287c3786025daa6df1d45545bca877f0f4f008d8c08d4860e27332761cc49566e01527a7447198c50967e862c5c6e2cdd5f619fb8931fc78442a3dfa5168d45993d9483f68ba6a8cba8a414e9b9966fde228835ae78b7348da0efb9c2cf85fcaeac94f7f0cdf6e505b307240581f1eaa73e584c995438ddc886036090aa9989b59d8c4b97502d757489f3f7990e926ae40a0787b9aab4265a25996f3958021dba1c418c9ea3cd134df8d2b87503f1c41d8c21e38e7e7f16522fc718877323f0af93470ae8f0af8f0bb0402554ef55a850a3835805e860dbf8ec9f0ef6f8eb9d34c73a847f5f987e6556bdfacbfe74b608bc3596c35cf23bd28835e8fb0a4584cccd8f11572630dee97844a165282cf340858b0ff30fb8e427c35a0c954464564cf3703cb347285e8ca3a56b2218871721934ad2d60af68a95f5f7226a71c2ea157483f3f51940be00485812cb121abafe9460a676df21e32a9d5016f3e55fe5526003f7396adcda71707fae40cbc8216d131e944b5129658f78377f83a1c37d3c621bc59473b678f7193b23503e241c1065a6c537fe1bc03be3e28b659f760f49d43d0f5678565bb570976bdccb0149af83e5729c4e33dce5b52124c996f05036b66efe2dd2520e802c17725fd00facd9e87c3afdcee6848919d5e9c14e167e5a88ed6021b57bcc43b37d1c2fc622fe3e2300b0b28738395cb05d93a484c3ddb5453eae731dbd38eadba748f009a6ab335d72c966b1647f374ce73b2f52da88798db6345db95fbe97c2ab08182971ec013ffa24f2712c2fbd1056e2c7b939b27057be702e5e12194852935c64c7cce81ffa3982c3ded881209c5f43281dd79288aa186c0af1553013712dbd15f962e3fb9b1efc7f79b8a2efc9132dd6b0cefbe5b5ef228a62af068982970c4c00a68bec9d153b84d79b4be5db090a0c6ed3625293bdd5f53f6f7de019fdf10a929936efa37138d5c715256cf92553c68cc45d9cd30536e4c5ba01114c42ce1b694bed5d90e7311faf0c6b040e03ede167d31b1ff2dc2bfc8cb9839053c50d1fb1bb66cc567fb4cef8b0eed0133d36ba26f2b5f5becaf7f5843b6a9ab943d0e20a6075116c78eac16cebb01094e3514202cc11cee264a8f5ef6ef8cb0bc3d13a4bf5703054db5af365502d51e3ba8ad2dbddbecfe57e6593b2ff75ebfd83b485347b576a09fe9bc835a8093669e8a018b54bf01729cfc1fd393a1dfc95555d0a8e4f479f6c6c139f623d06bd026bfd8910bbce27ba6b123edaed232b16b09a43b5608a8e9345fcdfdd2c8322caa3aae17a8c8840ffc09ab6c12119f0dfdc4d07db10a79e23cf8e6bed5550fa0c8544350e80228c687eb318368b7a2236a498fcfedf45efbe1f7102c9dfcd33debb1fe0467a07374a2bc879ed82f8d69c1e66e052eb7cdfa8412cbf23c5f1adab05cb78ab811e90f7598c7c35778d7f9624e1ecbc0fd6f5d1ab8af4c540dd7b3bda8715ac9e74185811e777c0e6bc5d7e0e23b568ae83152505b0d708e5b9330398a58c28b3b7d294a73e88506dca672d8f039f0f545dfafeb9ad21f166d26e1eda30d232d60160b5c6d3324df00262623538a241b781759917c961b814fc51b03bcd2c010223eb063fa09678c544e807cc5ce9acb2ce9b6a59fb3413122be66a6ba44618accff32a14e50fd88941339c7a37dddc134222a6035882d8294aae47ab445997c5e5ef818f7f06d8eebbe122cf2e46478bc63f0a8308ff864f8a5b7a21a22a81f6128ee4de2e60fdc98692978455a7f4896e6b82e6bcdfbea2cfc3e571c18b6c7d80dd6b12ae2f391734c9e950b9084b86d825798f82996e2c86090fd69489e1794f9ac017d41894eb16f19d135ca376af2804654efbe511ae2c39d35b4cf3f99a6e550402a6bfdf8a670e7fb660032c7d7c2b534f643f1356ecad4dabd5246895013a2f34bac7d7af32246f7b6196a3fa98dea4a24f378f5df66ced3a235c965772302fda3430070a5833f9820dc928aa6bed92c8e095203c00ec0509c3577c4c6c536ac98c16edd04334f49a8d7c982ecb6e4fd05ecfaa02550cb48f26df85ee46204774f80c801909ba467d1660da4e7639bdd41544092d8ce11c7d66bad47b9dce46f225383f9b4cb2f0f796645b3917359409a267435b76524eb633d2a4f6356002ae2170a1053d5b12e02a68defc4a15e1a8f902f93d5582924b232d810173b1ddb2423ccff310609ef62413ead120990b5f2c0394158ce8e05e517315c03cd70e523ae29eaa0681f25854d6cb17da225d5400a62c213aa29b240799a8585a5e3db1bd5bd9cdf8379be0b5c8dcd1898fc3d5db97e025e882c8c584f48392307ca8395387edb421b353f97196228c9414f158908b70f0214ae961733e3f9f38c6c01f2eeebb73626c064cc6091d2a1d3c3df42e3928f29d315fc5d26d24d94aba4b8a4f0eebb4d7c59235117cb625c34867b12448c68eb1166485081d9a2d7eff2070efd3426355760fc9b910fcf06685ba7e16698205140763987f2b7fa2d5836418e812d42fbcae356064e989e8842e7fd02e52c3eb91077f513362555854ceabfd2ebf07c2c0d8b8f28b2480cca27373b7fcb7c22aca220f9b562ab05e63aae34bdd6d903dfdca7b23e3a75975f46516e5a964b863c9f8c1f7f3bea8ee8ab4cdfaaa77c99652fc89e8270b7a0befb59000432304305826118582f38177d9a0f4882eb6b943ef18aaa01c2fd42f36bffcc5be6088ed8b829aa829772467bafb54961471416c6cfe1e2afb335820179dbc33c5a4fa6b26503770df898a289edd7c3abac16aa944d7f5f4684fa3578ae2653cf0cb5f6f310d0f7a50e6bc683d7be42a2d650b41b0b588917e566620bf67a143cac33682eb31e1ec7181a1e80e2a8734ba03a245dc7eb48cb422eff78aee2129b6e9b09a513fabc10db768da73ed1f180523723a27c99fbc27bfe05a4b6d664b34eb3ea17649ac63ecdc2240c9893fb8988c2900cab82be6f38c261b114487fe8af45a9f5bb6512ad3fa7aff59f112b18df9a2ffecac02e471bcb3d7861fa749e0e09dc2ac75024897c379cc4a7be4c5e698bea147029d6a4686e4d3813483b2e446a536ac97757c56e5ecdf33ab330d4e1d4cefb218f398fb08bfac566035dc1e3d167ba7990c86858a76a1a2024c05e96e5b0c42749616c6d868c2810827878cdb830a7641e6e47642a8bbb41f74e718fa833214b9ba16f3a56a2140c18e7eb8c103bf59d20429e8c9d904ec8e83972f9f3dbd64c55fa99758f6439a5cb14100f68d75cac6f035463e7bc953c73ec7afac617560073b87d4a56e4877f492e412c24679105e86f99a3518a1322311fdc8b5618766889292b5a53e5621a5d5dd9da3b52e1db81f70eaf695a36e9e4103320aa0876dd5f1622fbca5b0e7406492f146eaedff8ed0382c2ffccf15c1b7f947e14a638c44b603e9c015f156103da0cdd3d1767247bab284e4b65bdf18aa7b965610e62a2db112d50788ad351b81d2bb7726d91dcfe6c5564f27f1b15f5095fed31df01cdc4ba51209814d089612b36e05029c89559ede04d825c3ab0b902c8cfb2cc7d351fcbab9f9661a6c67efd5c721c53f6aefebf669ae456e4af0a3fd4b2413a06120bd17f2a1df6579b4b3bb7cdb4003634ac1e70c75b5c3c8a379c35ac594cbf80635b6046d778a04baeef3ec4b1280a67086cf8b7204711df59ab1e94cf4f5ff88b5c31e51d7bdd8fac369ea56fea742c8187f1eb4886642dd5aef68a63539a40fc03496cb4c2f6aee6d87baaf9433b2c8960fb30b80f7a7b40adc0c679d99b3425f52b95690e553e5f0e8ebbd05426ce24b36358f9bf536cead7b4677a0ce0678446fc87b017cfb01715fa2516fd404b13fc95687ac17a1550c1c4ced1bb8774a7c64421ad3939838b1c6e121dacee93361687738824d35b5f8cd5d86276e0ee08634ee1a664cb34b3aa204768a5968485ecd84dc93eca11d052b889098cde7e47b2b74cce1dd2ded98bbc583006f3775fc99e2ad6bbfe42958b701bde9456230becf6d47afed5d89080386aa0653ad60d7f8872ffdf2cceebdc95013d27856d286d60b8c81c7d4136fbd4d1081478e07d9c2cd46071f6272b265f280d697354b2ff82704c849fecf364715e7bc0481f2571855dbb6fa2c08b865ce04a3b10571df278492cf24cce615d6751561bb73eb13fd7bfd1afbc3d9b1b4ca13231d58cebcf906882eacd81163cf8565dfafcf7c0e44d7af08eb07ef3af5140396853262f126fc41a54ffc5df6515754d9de2700df140fa23f561cbfe52a4d8f7c0bbc02575aa48f9a4f33b0fbb14da71ade5de4a33c4c3cb4c15a57261b74a5aec3dfe7af9fa46276e4bb0f668df09a0c8738b194bbcdf2cdd8b368177b574fcf0474188e02214e8fcc24cdadb42b84fbfa39974c98065daf129757fceddd0c1870e45260fa5738b945b07ba369c5f158fc001e32a74d0c01dc4843c10b30019502d3e90d77a48662f5ccf7ffa48bcfe93c187fe70d9d16b13b199cba2c34e8df60376ee54fc8281756afa8d79f1c8798978c57b4f614269940f067c48e5d9f97df852a07f4ecfffefb87e244bb7a6353129ceb3598f5febe5420331bd5e24c7830c90c4d5db39f1ba8a71f937bf9dfc06e6301746c4a9f5b3285db589dab339f3d02f15d7a8eccc537f2f5581f6719f8d669268d27295aa0385489b84bda00fa2f79828ad6f76b1b966e58d62566a4aa7f9b7ddcc24b60ca499b62b17a052d83820818f43f635487babc68d00b4df1f6124e693af2dd926a753feec3877a47b20692525333cedb0247b899dfb3fdb98adf77fa92d7696732967e57c4aac57c61d15cbe8bf9c55f4c8faadb5611927c6cfb8afde87590a7ebb50410171abca80e9caa2361276182d5c82a274c9ee950a21b0b2ded7fa1366330f62626d4bf0fe1959e3b9f3e9e84c2531db41bab425cae61e5a8e33d4e0246486c516fcaeff8288a2ebcaa4a8db733e00cc27fec133e8e390f2ce7bede576a1781a136c470f84a8efbd3aa8f7366dcf6edd90d8e18fbfd60b8dd390fd7d93e3e2aaf052f1a605c4db63d874a30900d63991c4196a1a6bda331943b5a9e549924029c90ab7b891c4c53f254c2e4eaef1da0aead453250b784d80c6f61e7d3d1318954d05ac174b4929a7f220376436db913ec80db0f4ae5cd08f1a3881908f067fe6288abba83bd150c5fb634fa2afacc6849acd454fe6c375a3d20d2739d66cad16d8b387268312143e1225eadb5e3a1dd539e65f04137d8e43cc79685c5a89d4c027db768abec363f28318abc8763948abe19f233d79280b034cd441a16e88bae44b58a346dd270ce2272b4ed78d7a682c39b20577cc8adc8ad089abe8f6754003142afc9d49eb9490765acd8e0415d5b15d4b3e0aefa6a031f6e018b63e4ac9c44caab637e1c5ead51d3dc5dad26a7a7ca350d1f83b501d62dc8404961d311cfbaf3d0fce528b9b868a29442b644e6e416257be0a6c72826df06f04c097dc0b0b1c0abfbbaeb38f0b1298fb108b6d253c59f9b86d9c9de7d12a2a5a5a7204df978b10b2ee0c209207972d38ac1b413aca9bb2a9ff11eda61ffa96773ac77ba0931bf55a0601992b1fb66baa9398166d2995a553574162a40f6ff21d8e85b894059248f71139811c6feeeef5185a770133bbb06d39a2f4c0cb61b083eb5d4de923aa1778aeb2c877519a22bbb1884bb99c4c64ed3774cd01576b767cd1b35f7638a09cea39a44899e40552833313eaf339b020063d52bb6f7e9ac11d381ee8d2ff520efab607c7b8bda5fb6718d82ab68818ca6df4de2948fe5fe10b005d830da4937a25124cc81210daa57a70c0404e7db196f0c769cf7d64db0bd49f2650871c2c1a25125879f1bc04fd3de9c5d30485b68773190c26d4f99be53489af70df4dfb6efc2c2e82cd1b7262f6f2dfea78deef38d5121cc8eaa73688c58fcae46e4385dce79db5de35f70feb4a6111d35df758614b1e856b19dc8a9630c35d77716c28d60fa2bcb9abdce9f5c5b04519fa3e2137c59580602866e301e95564478024e283fd0344dea6099781e5be989bd50a674d160fb647c6c8e01c2214015d11ec6071d44b3c460b70223da920cddaaf8d885dc3af64f2cb93a7b1f73bf492c6a1f390fa3ec2c1e5b784b5a15d1dd17987285596e53a91810d0eae6869896c3c41f3d96146b2e165d6f891853b1d30446a08aeebb080235275576041685ccd32a4c33ff21f60ee8ca0272062afd25c5be347af7a2bb240df234e348561cb28f778f5a2ba555d6d1dc0e55ab160bc6de0aee0e79d0f40d6cc7f1ffdcb583acd3b0ad5aa153e0603aa03620eda99658364ed3248c5dfde23b369c26b5a78a37de62ffd21321ae447c1927aa08f16936ce7875310d8c625ebf42c8434af5a627c2ef19f2804399aa46a2135d2dc7481ceb200d26dbe40d53990b7456fde3ec510564d3dedb8e33ce9d67c4f8eba5988cb217c4d6f3346933570cbc28924aae546f320dd245ab556e76c49fb8d5cfc9a309e097de00a25e4d7bd3b0c7b0e2b1dfab7e413840ada3d6b1650b9674982ff3624bc67404e6ab7ee05bd533387c7e8960653cf9839710ba4cc04040f4793e9ca2e83394eac5127de19f7696bd40cc408fe5e0e6e44cde058479f7026239bf8dc6e6ead22663658a5166c395bfeafff50f4ec73ccf03fcd4bbd8fac462958d918425bf962eb3e910359600d24e1b003ef0d933c4d6b0b1b4e97200ffcd00eda731a7b42feee24d5df564ae4e50d37c4259694602f4b281484e2a8675ee55c90a87dbe16a382d49ccf69f0f0ef241f552c9cb55e6138c3d6e9747686461cd203a1e3f7e185defebd7b167ce5b9ca12977c7564f29b5c1a4d5199c43c985592b55441c2c657836b76a710ce5b684fd59044097a3dc10cd4cbffe7631f60bde3689cd51a68fb6d6d2c64dbfd5b909c7c9e460bd20e89af13199531cb2c6d7e979244197f6d762e6a0b59bdd99862bbf9cd959fdd8c2853dbc3389c8ea38ab9a459a8a4ad9c58416eab9c99612fa8ebf26f8b079e940376d56c48086e9b5582c1a90d909dd717ce8bd0cc58efb2e6c684ff8f64829e2a72a6847243b87c0a498f2e7754063bc66513d8b94ca9c7b9d5e223f98937719469b1af8fc4bf51c4736386a2b2989cf3707cbb8ee0cce906729a793106d70b7b67583bcc3bc789286c08767301fdaf7f34ae27e56a24e9d60e9f7095fdd8263a774ae53ff34006049c0ba4a9317e15b2060785edb5e59f5c2d1342c92ff5fdb99a07ced4ba5075690e70c11ac61c8004408392fd06d712284516212b283160e0d263921030f607163cc6c7f1e8baa185b3d6d8748eeefdafc913cbee852c6b269718c4e872451bd8d9d1c030e9d182ab706cabdc9534fdef3061d6a94af0915919880b80c812ca67bcd53a94ae27cbfb9b2ddb370685935129bf15b9ab30b1c6f275482fe268f980c86e61db000eaed66be5295427a08b09394fb52c121b97caee8c80976aeba637863a094ba6f575e3e86fbb38d81e048230dc61b86c4f7cdf0669d49641f0251b43a1aa4653d659275b06dbf5af33173064ea1cd7edd5f3cd945ead6e32fbab3726290fa55704663512197a46cf4a1eb1caf979c9eee87c3063162981d16a69e16bc98429724d61640078699172fbf6d47a6cf5df13af196b568f2dc82d4c23332cc668a4d07869d264143761aa31881d713147aa12bb8ca56c1b225288f47fce612114ea5756769f97e8b6cefe2b633bc561e44dece1a66a2c4d6065c6a4170694e3fe01fa2032406b5fe4bab9cea13d8215a851a2692eefe2056d5443321d0b999ae65be49bff7cf899fb253569d7a09118357ca2639317135715b4d06437a1cdcf7e0b3221508093db0fc8c06635055247ce5f2e643d96f57a21fa31a55ace223d60e1fb3ab041ca3b3c5d6506a35468c8002af5043ec35b17b115171e731a4c01b7ebe9a0ade3554c72085e1df144bb20945db74b6d707d15285dd3424634447bac31da3558a2072319de8a4d809cf17735aceef594b41ffb1036080e59225df1c05300ae59524649b57a214253577197204be0171adb6b80ff53497b9079bb113465171e69a5cb94b7f66a9babf2fbf982866e78199fede2c6dd9be828e23fc1cdd98d710ea2013ebe4780b9c7210417d33dafce76e4e5aad00d23b0a7de68a0a07a029f9f1e18cd62ec138f407603114ae4dc6097211277ea7d73de07b077868ad7176872551b69dc82f394db275add65d8f7998f3eb0a05fff37b985252a709607c09658be37f408b053d9dd22b8b56010955c0e3ebadc8223be8c78d9d4cee0bf19e66479b09f9b70d0235caedd59c9205674ada7701188c06efb14f504f3dbf82f1db252f99a89acd8d8a0015f2cf41a51bc652c7e3c93a2ffaa11524f79c69257869092b039325791e6b3affe372f2029daf53d8737e4cbb3397a00163bdcf992ef5c23cab729659b5fb1f8396123bed92984cd3127b278b049d6875e1b052df6e01257daa1fdfe4e5ffd99a7c7662bdb143c4f92bb85e662f68ac7044a533b2b4a9c6e82d18843c5e91d5e59eaa9c3e954d872804cb40edd1bf8f593365e6919be66e71d0a2f0266643799fc2142e4ba402c2dbd2fe8a8fa5976b3ac3aeb99abc71a8465c1bcdebd7fffa8ecb1ce4dbff352cda57a38dddc1e0c80e6fee8bb5494b17fa1f9c712b2eaf69f5140dd8ae824c6b6d47e74d5d688bc7662b651e7262710e97832c426ef5f65eaf20e25b25d02ed9a443e07eff5eb8ea0cd121d257886760de80ff5236c2f1c3dda9a7a628bc836d2e8020066a091af903d70ab90154f3a9c73e0cbc00056f1779278bfa409d6e5f2f8b6c800327686caca1887030b9b9ebe390665b820a5c552a0e9b9f712ed74cd3ac38104c6ff4dcc22dc6ca469175f408c0bcfe24d843aadcbbd7a7fa152b752ebc9adbcd1e6a971ac783690d5a0da6927c73f2cc5770aff4bd1db3f9e599fc56d1da7dcf74e952407cc8f62d5ecda5e8e7279eaa7b85522016a4ad04dc41e7931f181d01332d0837570394259d1a98d2d510e5252765d67d6541a0a1f9f7fbe77a3e8064b3c4873216946871f57188bec6374cd26b201727ab9da5e5f92d6306ba7b7daf6239685fab7b7ae381205cf6b03c26a56af8f35e6721603d32847baa061ce40ceea62b5a8eb4420abaafcba77cc942c695cc0fddde98456c6b8af4defd62bbfa658fd48df2633a322dd9c4e0eb3758cf968221143fbe7b2a1d9c3f8f90a21922dfd3ffb97b1e79aad5305382a022289a522a1c3cf15d2d9312da68471afa98f1977f55cc46029ad1f16871dd3abfa6dd7652d7f4685930eecbde6b6b9d3ac5bb60b2cd286c96039db4fef629bc31e91edac4f3ed40ea9ca8524f6afebec4bc54f25ff2273d6ca4d47bae8464a00661865b340fb0b4d9df61aeb486f13b8528ce2289fe504bafccd2b0a1b3c544f2c8679c5af0125274c782b5be2983d6d50c82c42c4b93799d3a9c30a28ac870047cc70e9909885677d482961824fcff4560993135f1a9bf36b13e8b72d741f9f45b23997b62adb6951f02b3e41f2f683b3d6952c778d6ca3debe1beda6efdd84f96ad1c84c01189aecec030b6db7ca51755f03165a820936d22ae73262c5fe83e8e17766ecd25fe644e80a9033b8d0f6fa36fd952a655ea82c425b058e2b7f3f6f5ed1100260ece0de1938d2f10e340c4d21dee05a9ca9ea72d6528106057d9bccd09cb6b69f6eb012c953d9f6400ea2e7d2a7be57ba6604b7aa2146c975dac2180ca827f9ff39ecc68967bf525b54e16fb20c7c65bd93aa4a12bc94a158f4923cc2f4a9334246ca46acc0f17e7773a910c559a032ad48d4da7e9246b51254383db87bf73c5f4cc60d20cbe335438a8dc6676c6a653b6b6343f8d4864e71a15709d113aae56fe3944c16eae44bfa54b2e903c09d27566cb6f88b8ca944e02972be46c147b25544fcad955c49f592c7a372138ae1fa4bec7029b9a6481a3d464960b2aba93194ef5c8db386503d3cf5f068cb60880c8b8d9d327727a1f74275b51ab3763901e1f8065f8a6a1c2d3e1d6585dda40bc911ebb4e8e41fa3f4030b14f5b3c7581def3e439e5ae8d53c0ba371a6a586e27ad0a13be9b1e6781eeaccc2dfb8089eed2f77e956ceebe46b570ef48545f62fdcdb5bde63d468a33538eb8d7fcb3e8981b73b14d68b8e7da3d546be869be22e0bdc97e97ea7b5b3f594c2799770450072475e89264e72e54ab3abafd54fb3c748fc376c1f0167e5bbc8f0b73c2a0d017e001aecb5b0694c81288afe184c202e80b4a3a240409d14507e45ae4707002d29e57e62f629ba43089e188418239cbfe8ba469da11abdb95c69df58a7192e5d51632e0c7109f300f6c5e6205dc9de515347f7420fefe873ec28b08e066db86d562d0698e4c1a2d5b0d8924d4294f0467945c9d8707aafafd1632ab9067aa15399b39d80f94ccbf2ccc37efeac765f26435994ab2d018ed1570649884681fffc9bf9e4416a897652dcacf720c64f21ce485f7627eeac593b9777ea11b86a6ae528a71afab789a70f320ee6302233342f273d680426d7622ab6aedcaf1afa92eca427771c5f1c1ff4daf989ae7a2a9968faf3488efda8fdab898072d5046eec3fb7ab32426897491423001327feb0bda3cd7a46d2a9cc33c36a3b15d4da19d6d298df1576bc38f24c76c5c7d7efe5e6f59cea2ad51b2be3da21019ba9829613d19df2aeddb23b3b0bb76bd9dc299ce8161545a81d8494cfc84811b4f27b5ceb9c3fb015fab06bd7acbb8b37e4e41e923f47762962229690cc2eb0f5cb57c3c6a1c5580164a888cbf0467ed0ba10a72dc5e0d909ba270790de9c16ee3a43da92393b1280ecbe4e2410f1cec2318217ed8712a9e5d2f3a7e246fbedf5dcff9b083a8791de656f0e28ef2f50184ed95dc3876c360da1480cc11cd4a8b0cac3a3c88683830c45f0497d45ea1fe7c1d8130433c5da3d455c52e5daf4b24dc0c65c90348d5c1ec1151b91b35457f761aeb5f6dc3bcd792cc23cf19114047d47b4d610af67029f12502b984fee839372050e1eb2d348c33f4203bc2d972b70d954c48676f16dcb04b99fa5c6a16020f0449d03638d3b48a88cce65d5b620cc500452ee6a68c0a19afc7b466fce85fc3b03ca2f4962846e3451550731842cd810fcb37a0cbd99b042958ccf02148824620c78860a965eda239eee7c8c25c26edaf2db7e1b8b5e99f7543dcc5534b986eae50c5900366f8322b3fa161a7b9b45c83b289567f3cdb5fce25e41142c8dfd7fa91e6dc745e8399ed0e818091702d5554f479dc4aa8482e080250124e7aeccf28a73542c3ac4c47d815d322fc9280db445ebf0d2c3e7c6db3e1bbef5b4bd2125edebec61c643acbd50925d2683bd96216c13826f95533b03cd69b18ae451cc8b07975e6ed53b7d048aefd0feef36c64755499b0fcfaca04f6fe37cc99e78048ee8ccc3f6fd2b0adb4d6134b26f5102057e2639c1407e92275090ef693f12ca53810ee8c26581137e8c23088a7c425b49f5fd64f78ad3877d0360de966e543dbd63d43b001830723383f3d559363aeefcbbca2d8e062b17cd6d2989aa381e845b8613e8f57c03942dd00f3e6315a147e386d8cfd9f1a8c1a27ad40b1a7c6be870e742ed6173ad078d8cbacda83874bc6e7f5d015517c8840f2df3cb200b83211cf63672f6d3b95b96ae9472e38d918ccf2529e964c8ee4be750ede7de08670379fb8819a21adf399a73e1b50cca36a49c772457b72bfd8836be60b0817f06ce834e555bc9fd7ce80f3a93861cd90227a5cda57d05c1462361bfd958498f2057cce9841919d2b28b482a4848209ee539013d1d84919f52eb9efd3527b14b6c818686e1f356f7927af9ba503a207a95b6eb60d97963a54a4f113ddd4370d3c71b493c6f61fa79f1199b3d874b6e2ab44b9ad3182d94180125f6479e302f610e6e49ae6c81e754b7b99215ac1268e6ce1726d73026dc64d9642d1c32d2cdb522a86fb76df0ec574b8588d3ca8931439c096a80bdac85fa4098960575dfefc14c7b083dc9a162da055e85be643b16e28e5f4f8c710a9108f17b517902c0cbcd456870ca6c30d6ab479508e8ef58c7ef3edcbd1952d13fd9b3b92b8c2584c4ebc288c67f3f6a55dfaacc916b010faee2e3ac7b0a014a9423ba6c10e5b19efec2be1d314161805813d28bb53169915610a7935687a02a72bb3766c8f0ada31e11199e66b36cec7f5a0d599c8a8a5e8e6d1c3d7089206cb5e82e8d96dcc8f2fa2d90c8fa3aeb2e4de6c7d3a158eeb7f98a309a42300e9919e39577b2dab7edabc3fdf259c13632f00aa626dde3d3ef6d8288603d78d7038cde371f3b416dedf2c065756b141701ea8f37ee3a45bcbfa58189796590f4e2f58598df10c4464bb2a7e8264424fe3697efe34793fedac0904af7438046b3cdebf0b1ee5ac57d4a8ffe1efd6dec9b9319e9aa3daf1b0c1d4d839a29da6ee45606c2fcb9c9a353a42cb13c8d1754cccded476107e239ca4d176b55962e2b234cb378dd1a7100662c5d1123bbda51ab586b108bb58c79d83f2f292b0118003b665c3a0e4f6e7ac8917acb9caffe603b240154ff4c267a34ebaeea3a749cee6c26748fb2d8672699090a063ac222b5e5a1e99b8d38ea05c8e41cbae7c61c287abf132332fc1c9a74e38bd9f5f1146c39419dcdecf45d0c5253f51a2ebda325e9979e332d15de7b784f7b10c0d66c44b055b8d348d955cbd6f3f87560e20af08186f750efd02d27541ee9bd5c1ed73a77b8f0964605ebe0273b648b38298476d9ae4cd3d7ca34ef226fc13c326147710f24cb09dc75ba24480b2f0a206656c01cc7442b3005b5ff32148a800310cc4e18f67f013945c3fbc2011f1fdd1a5856ee7dcbcdf0da238f6382638f93578bd306116de87f6a233fff09241d48c33529babd441eff8522f97870696816eac03883b07eebb8b0d389d239dd3012a2b5af14515ac1c1733de425fd2fb8983e56a2e0fad6c1c16b15e113de206fb7b782d29a22044d0c5dee7931f397b3ea4fb8960b25f1bdf7a53136cbe10e05e56570177d97392869564f83c8372298ea0bc3857286af59ad7b5f723b74d923066c8236546cac1af3b9f1449d071ff3aba5df1f0d49c8df084d7672c41bc06e9d51a44c2125033254b06b462d6e7d8f1a3c34597db405af11233a9c1f948d69136049ff97af366d3794289b70134e2ebaac3135c80476f98f5543a07f2da411fac1d7e7bae1e64804fca532bdce1a4c40192e013a7f60462a113f23ac50815599a3a809fd3d2c2c1cc4c443c28a61cdd036c4ae011384285bc57f4136d07f3ecdc087ba24c0354b0b5c94aa827c21f8ad3f4021fbb8c438dcd35c67661891e8549d2e49d181c3ba39dabcffd9cc57213b7ca4284f6fcbc593a72245f9b4fb2ed01f212add87eaaf1f6e6c754a2a67a15cc55ef2474952cf5fcdc4f75d0eda7b42b5800bac58f84b7e14fb3862d77d0e0feaa6fef1aa9b40b7299d1cbd620421fa2e5871e0668a82f28e83ecac6a2f114499d3c45ed2d8f47b4eb4e14617f1ec48b973cf99d5a23fdde5ecf17877bd03142ba424555ee781f71dd309729c883af8a7ce81b270203c16a78ff644184f1ea94da00f11997717b78080162a48960465db736ef2af3c7d40cfe9ad44d96673978dac6e5d94e13a0fb86a81c79d968cecf87ab5a1bc5a6603af733016f2b29ca30eb9ce63696d4048dc5df1fc366c4321c7efa58e7b20ac1f675d3ed6ad316e140fb0b50aabb47addeb474694eebed6a5964d34450f2ec024233d2be0983c93916130ed472137d531993f4c880c80bf6db2ff617b2dbac58c9737dab49d156e3dbe4816c2d75cf8c2fbf9b7b432da60be6d3b1c8dacf04f4b274ec2b5812efd889782108ad17b88e9172216cde5d849ea71f37f9d628a264d4f7fb7568118cab9a98fd50b6f723f5b1950a169d2c14154da1e49f289942e3cc2e4dd63ab2ffd194afca4de39de213f92869b42147c515ec74751de2955526886df7967c4bc6e4b755c9aeaf8f77ad37c6bdc75a37b03eeea9189a4eb3dd1a9062f9d878f6bf772de083bb56952b7dd2cc6a52cb2707b1031d27ac79293abcfcb0b6757496168cbdbed4d61fec87bb768dd09157f106ad76287955c7320eab2a7855ee051dcf5ee4f6d5404e625d73dc9b110901469ac515f831354241861665e5eccc2fb0f71565014c929f06e7830df3189c93b4d42f3ac44d00b494cb8f4515eb435cd343c481f571322999717813ae1462c7f72a61be6f4fc0b258c8fb6c8f4d69a3ac4c95838305a5523b6a9701a988ffdc46225bb82501d140d69cd54391d42115bcb75d25424df1006a5f087d45dcf5fd5868067a2d2b368e556c36f1e6d5dc46ce732ee0790803049e97a1b1f447090517f3896f11933c6f4ffe2643f4c010580b8e8ca985dc38ab092e75a8e80ed6ae046640f97b24a48b1b74b59cefa0061fd76569e2534bc863d1d6b33c26b1b0572f140cb3d462f686d2e5ddfe1899a7d2f9c9be1e82a3a8dcd7f03e39a33fa1a0102a8e243c6fb928d7cdad264ffc5059586c37c97da63dc32f7235f60c807637338383357e76d07f151eeaf2f6194e73d4eac174d690d3cee91a9537cdbe4e913dc8082e4e1ae647f3ffd4cadbd33a0620d5b4baa40b37d8e04346ebcbecf24734b9db5f74f6a99798247ee42bd98c7434e3959669f00f508f885fc5ca240cce97e0ad3d98293a3c8f5d5d00e5a6610ab741a3e3794bb304e8d54c7e713d2c1e53a4a0a194d74b3a744f3980d62b8a62e6222330f55c785f87c0df149aaf5918592533cb1f9d5c2c5ee5df893b8d65539466fb5f1c86a554ae42fdf307fb82011462898d9ea7f37113e943b159ab5fafbfec52c0c7a4f7246851b2d01ea388b9eacabb6e569f41ee1c9074ac313f7e4ecf42624d678ae022bdc3c5c698791de67a67564d4c8ac318be42a77f3ce73d4ba550631d023b0efd93449232d65b49ae6684f6db0e2f9c41c9faec5059f77ec370a7efe9f6e625a70e6465bf1f4b9554f7fc668c9eccb991400a4eb3ca2b4908e32dfe9daa37ccf4144ff06272dc08571a85ba3aee6af7805dcb5aed5620671b55551d406d892228e6d619bf4456efa726ac029e9a30e914949c6dec24b721bf4b688e48dbc3ba317db4c969d9de36b16e2f10731165ea30f23064eeb49d8a546f6e87ee43f0556048591ca0e95813ced7c25d63cace8e8de603e56b1b1d91cb28695adb29ddffa59b8e3e9ffee9709a6609d064e121d3f7681fa65d5206149b182e2e84db131870634a444de70f65ba6895d82eba457c4d3261f4af5deba3c82f92e7f981b2534c37aa72a07d5a48263278c74c9aef73419a61bcf67c3cce1df23e93c04ca1ea9199659c9f9f5ca11709dff8c99e37762a664464c786c97a9863caca21017c7f98da18af95bdf4636c8ceb881b834b3215c207f8037e179245cd01590d0fba91785fde7320abf6d1f90c7a3ca883bd8f96e598ec00161d66f30f8e74e2452ec284b6c1871046dbc495e84f302946f064a6dc4e093b8e8c1fcf3d7a20fc8ed0bc1762c0a2dda2f72b23b597054937f5b6541c172e89df085384c92b4832c262a78a6cb94d754befcd25a633e0fbbffa48375b16ec6ce9c01ccc9191356bdd530f3b1a60772b69808797373cdd2c72fad5705802b6db43c2d1d7b1454ada1cc917a57ef34d4459998f03350de377c6828e14fdd6a6466a3c5201ece31af7d060c62e1b5af672719cb1f651c6cade0592e8bd7b51acda39424c56dcc2d770b7ef5e4266e7813e36253822bdc44ea2fa2c28dc6f9faac0e80221dfaff3ae5c8f7e07515e6f8c93e89d51c794971cea94ba4918a52b085da3c118dcd31789a2a3a42b11345cde07cde5578822b2b77c48d0909a239bbf9aef467f7a9bd4b04ecf6cbc3296b4100b503fb641f764859791314be1afda85afc1aaf16e49a9be0b3e5ece5eb4a98a19c0bf887029e568c0a3a39874f931beaa8918f670e7e5728bc6bb33d6f2c7a8a5ae48def41475ecc3fd35e364ffe8ab43a0ee94b45d9eed49668f794753602acc48a33f4021413f4dcaf02c0a8747768c68be9c82a32a77a7cf9135fd8798b92b32d84b6495d01652896815e80497ca11a9c6cf1f5482804a0354d864ffd569a65799bc607625c7a120c3c6b4042087e230250972ecec607525cfe2b1d85881340c037c13a2b3d7f7cfdba5e552153849512a0c12c08696e12541a5f1a7509dc90bdc46a9390fe84e19a171cd15963e575a3c7e7a8acb9a042a9ba19df11ebf86c564bef1e18967af566060ba9b19452842a659bca4cb463af4c30ca1a327df5c61e46bfc0ed564189f62e7394f9a5fd904e9ef930a33e109adc6dccb2b200128bdecb64f81004c504cb06568cd4c333e8805602f8a13f2e15ad9c405f4a22987c59d70c0ca043a733306d4a222ef0d8cb6183e76c3ca66d4b03dee069e26b85c72db51fd0cfcffb6c40a1b7356d743f2694b037b868c21c3452b813a23ac094b6e9aded81068678ab32665a21266ae6d0c9ebaed8e139d478b68d57de08559614423301685f1aa2f5eea76c98adb346f10a47987703fe92109c29bb5aa85cc53416b2f6c9486c75559660f0127f644b21b71e71ee6922d1db24534cef4d6d40c254f01a47800bdef145680e23447d36176b70d01325226e041f276c915d962185db2e02ef882f2c67e3c134530a207633c91ea0d6015c7f7825be22400b82a785af527522bd5d8280aa13c1be24418d6b53885ee7cf96c73ff2578bd7cee5e7f9e5e58fc1c28b996669c639bff5c436391fbedfc2293006305537373ba298e7bb52ab1ac02a7d734c92c4007537562f3e46542f75c05cc9d1d5a17c92ed41e0830082b8c49458e0633b744b4f28f219316ed0d156d4eae78326a63709ee67ec2f541395ea75d4b16bd5410e0bee8e6d2987f80decc1f58ce5abb66d96d5b7f601b32339364f06ae8a2f57f605d19260dab88d23bbc2de8d30d910a71c98b95810c83125db50c47ab31639c3e8110d6b21e5713e1ba1f1dbf60a11f1c21fd8ecab3306e2c39ed598475878ad3889dd1b2d30ba2c5e1adf4a3ed8fa21642b36b804fa02db145ebc26e767ec45f5736070a7515cdb27bd1a9ed493feb2edb8ed96d20ec08a64582a9855f3dbeb16d02550669b11125a9637d4d190d90a9238c8eec29a6e1fb943133a537b54217e9e3644b09afe79241e7aac24f802eface93c5d82ede65047f1a8437385456f0e092c66d6ac821f055098067be8b1adb3c26a7c618715472a3f6a68005e28f4fa6f67f5fe8031c2a5a2d4c383bd643f57f5f7ff95cbef11562d446c31a01eff7ab20bbfe5beb1514075216df1c211d6813265461a63a3bc1956c688bf6aa287e999797c430c7d3b2f62cce893c4d66e0c81b5693ee1cd285463670e29e4f78e6459d5370e445da66a2fa4bba83ac7222466036adc01739c24dd611852376f35aeefe1f564d0c5a93c4bc4fbcb28a5ec8e1cd84f63c4a2662ab0d086e1d8ca3c131ca7661feee8ad169225b3f1aae2e3e977eaba4f3810402b805ee87eeba77c006a2c899f18eae6d5f5a0da0e0380b762cfe6cf83884680c180d5c4b2d129c3750e9b9f44a6e8e367efb0bdb0ca5306b2e7255d13b5fd240a7449c7f6377f6b23f3d519995e7a9611fc8bc0a55c4b405880cbbd22e2038bf19b2ea1a9c692f30c9ad9e0de92240d358db581536db126b342e42b8b655409541deb4b351475353c640d99964945083dba1b4078f0527e61513684266650bb3869574f707cd6233be7978777711bf44538d8bb50e04a0c453c254794dd9b5bff7a999cd0e2a3d9230b8cf7e01d2c8641cf025c4abbf60644355f7f6199119a6fbfbf572ddae78ba82054be88e84262aaec72895165c819e1711f240af78725458b8f81655f56653d065ba6e54286d1da7414e150b60b26da237043a7f44b57ef6a6e6d993ff3d983b7e5d19228c2ff16df3cf3e6b2272812cd251fd4a5efc82f07407e0b8691cacc7468f02516f17afcade2843cdb4042bdeb4db8344ca037869b07619e4a975bd8986aa135394fd243644a0f573b594e8a12a57b9449bfb6aa454188b0cf5b9e9940023358501a81c241a4f9e1372dd51fe01c5aaab8bdc3e2ebb3a3a58172a44a24a57e1724a24e4223de242fed7f118396e97031b2884dcdd8271771d1c1cf3f124b85df9b41f3b0c0e9ef030ab8901cf5c1e9778fbc704c1dca79207e663f0987230a0a1a9f76b659b28a88208b256141a7de4b4f86db8cd2c47d640a40c8ea0637632de2cb6343585144f8e5f68326ba364f97f14d4ce140438abb4c048a70006c29f68466481db37b7915d953eae31790f22739737f4f876fe2ad9ae52414ee746cc813542ee1f2250969085adbb68bd755eb92e44b60b9df2b0d5f67acd873a72c4f910421db4d036f42aedff4959c986d748a6e9e484f3f464ee04a3672dc0e4051b953ab273edd05b89facc3ce95b0e3bd814ef80e9c02fc8f8fa3c3bca757441329daf15a88283f8c48133c91db33de55f42e3ed58c34575b6c8c28213435d3650865d2940f1316b0351d1d96c4ec200ac4b74b034b76536605ad2a372a1ff844e020bad0ab72f7e5f7aa1a302f9399a9336ee54c95fc545064fdd2fb7a0b6095b109bd884da67207c9d4def667b30ab0843513e673f6c5df5148b913600f35100ac88c8718fd7e9074fb92113851a8bbc4895b48b72c8304745d68025d3dba56df0e9b0d8803581f9d83e285afef1df4f87ba03239d62ae08aeeceac0bb44aba04ce9fa5822c86de2c3d33b3b573330e7e384f0980ec34b1ea9a5bd1d812ea01e6cd6d87533dd6cbb87fb55410043285f7c74e9d90a4bd60751069ef9c5640bf5382a6159072b8fbe9f96ffc3d3b5c4705a7b1d24bfbd95fac912a1ac89298e2d473655c6b6777ab098e70b2eb11c1f9c68c61c03e3a3a48989d531f2d4ed0a952fdc99880dcb86ca34f70b26e6c9272731c0fac63b858bdd8a2a3a6e544d1b4f68109474eb66eafbaba0ca810b5d6406d3b0aaa14c4837eff15d96f8e080060f44025489a8adaef5a4a54f4876c04e4a420a37fde9cb9b8673263f933242557d263ff128dc0cf42cc03fc9c01b920ba9b18c3149eceb4119bc7fc388bc42344139543966ed89772df058ab00c38c67151ba67d471ad536dada6d4d334c3e4a4d8c25dfb9802fea534d0b8e9c082a5a24f47a64d7f4776ea2202539893df7f37ec8882444a2380ede95a4aac8c4fc7e7bf548613897e13488fa838c8509a225db4c1c1eef6282a16592b173859c23da2a5198de800afb4b3ec6a8e13b11334033978f2ebfd7b8daed2a77cf250bbfdcf2aca8ad70afb48e585f062eb24ee48d3ec550c83214fb0e8d45891708a0106a2b55f3774d7eaab5093e7f42ced916f9e0103800a1b83232a4951d63b1542afc08174c52579bf3d08789d803c3892ec439d01a2c9b20e1a0573890287dc8ca6edeab32a19737ef4770929acda3db7b3215253298125168042d754022c93498757e964b2519e063ccd8ae6194e1f59d3aaaf3d5f2cb45a566ca4e65f444926ad01fcb1e2010ae5ef801e062eb61fbcf299b476b6c9fe2df753d0796aff863c7636c4efea752d22ccdef15fb01852d19449849b2da5cc96fd99c2bdd6fc0aa32b73582f2f70a87a3300635ec7d6074b2d2b43f453857f9b8740e20e9d341bfef18f10c32a44c0d58cf169eb0ca0cb3584be24b9c2f65a3ddc2afa0e9d7a88adfe365de0674870320ab33277b5c2df28195388dd74854e935312978d68f4f56ec4260631598eba521406cdcfc6e6b3c5bd731c2b6fba0347efc83a722c3c264d6919f653ae5f6c79b7c9392cf479968e63aeba1ac69c2f7b24028e96f6e4b06f4d698ac7f8829dcfabaa19cb5477c73b666594c647e67ce28e5b8886526524665e0d35774e9cc84ee408a0973eda411548f8a2f3aeb84fc5ebff4d3978717791358bf6bf511adfb466f6e2969bf195f9a96a8c2f87cac8300dc94933bd6e43cfe6ea3a82f0e87912835df58b229bf70acf4b5775a7ec1dd649df83f9ad352d59728ceab1eb01b6616e3708e91e8362763222559b058dc7363b22784736f9e8691be172c84ce9bc1b6ab78bc74deb1c3adc85bd7971849653298b4d7f38ce701a0e60807b903888a308182e5b11ed9935625ba3c2b336be12e98bb93be85bbbebe6133b4e34fe0d6d880b9043c5b0a77a572386c964ac782f7555f86d9bfac407ccf7986e9d07921f22b4787cbf875fc7fa62f81cfb18e583f75c61f3a6cd0773836557803579ad7e3bbf0533e37db399429148756daf56c4d149153cae6bfbcd3cb2cded1607e8d87872cf7ecd544731f390aee03c512ef80bdc1dd89448952796246baf83343aa79bf9bf5b79a2abb6899bcde2125c574ddc6bf1f88623ce7116794dc77610392e3314400235b10007f2cb0dda61768ff0f51943b245ae1ee090fac7b7b4183514355a9c709bbe3bcf0b97cb99cf7dee480f77637fdc994866166747268ea519a79d176cf7d79decce9e3a6219fea79eeca1055b569507f1517ff7cb93aa4141564d0ac1af35ee6fa787dea6d31d0871c88a60c03d4928dc5fec78a12f28a8d7c78372cf156b393dfce3aa0d5b51385e097a821fd8a15421dbc13b64b854ecd0edee686e1642ffb5c776fa60ac45412db55d59f4a0998d73afe8f4332ec19234e796be4d156afdc7c528317ae8b672b512539b52b8ceb70fa04189e53b348d40bf0e08786ca60afb30578dffc33f91565076fa7a8307957ac1a3e370f85181ec5e4171d2fbc3bde97925e1905c8f53acc3217920ff52ad5a1e084e29f61ae594fe67f2ac2aed5fc5b8c8672b2af6bb0dc70c35045433949e74e46cd63c4f9b7ff63ad17326568f1d62e3ee401f7f05b0243d1a98ae7d0429ef2a053ab7ce75aec08de9d3c19c509cf26d08b9575df2c452b47f755c39baa09e0907b6373ea8a0b8dbbbee360c661ad262faa224ad0d2b377e2d4a09e213ba7c12bd915f5a158351077c8654ae8fd32ba99046dcfe2b66b930d0e245566e4d58a907a73d1fc51b725ae7d6efc4ddc3132e2b1cbfffcb908bbbedb9cac4eca461a5e4cb81809dcffe4b218d1918aa0302e41aa4aaf5de3bfd43bb4208451cd77605df1aea382c330cd1eb572f8379d790ca8ddc65a6846d497c3ba2d0914e57114841012569b828a0ea0597926d652c0db5740a58aaef9afe94fc0b1df6c174a010f3326011e1f9ffc5144794be8945d9d02203fdae034a82f4dab6264c784fbf248b0fa35bca7b896ba3fd173868d23efa6ea775238b63c6713fd6fea3d7d9ae85f190cecb5a042f0baf1ada21d8aebd508c9a6181dc94ad80e7831fb91a7e9a2bde3f10583f062b90df8eaeda7edcea410f182606318f99ed8451e69c3b080b7ad8f7151356711fc8889c535c276a184f159e466c5cfea85cf0f23987f1336e6c76e94a10bc1704a541656493053e47f8ff96764c7bc70deaddf1e5d7e77493217ecd9517d40e21a18f25a2267cb94eb46b1c380d47523b397a9fc0a384b2bd69c2860d3ac86bdcfc6b2a8afe0bed58caa4f76206eb436d18244cc7b9c8f9369045e1d602213e0a06410358a592eebcab41c036c8381e7adef73f21d4b6584d2826a833c285d03fa8636cf865faaabd45238290f9f30bc31c1ddfdb4836e871a30de4dfd28fe90ada7383d5eca6b66b1ffad475c3fbf1d8a3fa814e6c6f2ba020836ef60659a210372409510f27b83dc70a56c958681439f697e8b0051f52f695f6946fea4e291dc6980e36fcf029874a2aa57283cfe0db826bab3e62ca093b8e9af3f345fe1278c37676eab97dfb07a5c3447e6a64567464794f49dd442a9eb18f5b2386f08e3d92761870e8963204cd516e8235f5a1acda655c9048a7a53f61f966d9e6d5f2af2d14647af4f94c495e6071c35c1570bf16110583103facb86b4ea033860add1fb45e0a2e474b280f138d6a1f7f6c084af978b0ef62ba036c323dd3fe6b5b02499a27b67e6e0ba020d46e0da124d211fd60c132e5423a0b3d497435cbd0c7356127c1f0dfd70a031fdccf79b281cf6701c4cfef9a06d75eb68439154c62135326a1832e7727be0f277cceaf94d582f3ea5e61f0d10e166cb7b1662a5dcc56da86caf9f6c133415d63e4f932125900a084e5fbe366f7673929fd7f37d76b2dbbed93bf502997e13167e083c8564a7986dd51fde03b5bff9ee7284647d0dbeaef7d32ffe4898feb3c683167e07f0847c09a8ee695aed420c71a2f52969b703b4b1c2a3b85b361176b602f71bbc03b858a8e516ca48c0c439bb00512107fdccd37a8f22b70ec55668eb8007fc6e99242e3c064d72ce377c6eb6050fbe212065180573ccd08408d6c59c3370c007f621f1b29d24c098b845e0d5f533f5d537a36f73984d6cbc877f1325866e2c594024bcf71c898f98fa20c92f069793d1e72353811d552ccc522f25dabec26dbe2c28fe7e137e0fb9de9784bf99692ffee675ecc10214a32a9f98590a718c60596153eeb7b2263d1f291d67a772622c27716e8193b3e700329a6e15376376559330b75ec78e3714c318915c802b0399cd1616b91104a5e5b5a5ddfe85ceb06d5e6ae2de7b9ec14c1f3500c23b61180be6c33454a30e64c8075287ea4894e3ccd15087b58d7406c13a8477f93dee76a533db43d2f46848e857ba059ac8e565abaf46d1ee2da8dabd721e4b3cdef9354087ee1ae54138d060ece57648ebc6813bd7adbccdf7844980820653ba131e3ec049ce5861d78f0895197d9919ca8e4a36cbf6a0f4c53f2669274222bfc96c0003e3ad09ed30b5414fb4fd57f2a17310e3d2e6ec8fa2ad5f50b74b340402f21da96f1d53af5e36d12616faf6afb1e07c16bb2d9535c839d97ea286b6ef70b94c09aa511dc49adf34ab2cf81448e1f8ae8433df22af9a2dc2912aaf0c834a0b37cc5e5080347274483b9127ed59ba58b6a17da42a8ff2fa2324b271e46f3b0539ab552b6bb6054621ad80044db7ec9a8f06a5c09b7562ede19e6eab27e2c87ea8e889424fd5cc7e37c45f38e3fb2289e8c3b091c116b57dbb5a50760f43d0b257c6cf64e61149bbac6bc46e44427191ca3d3aa20164ae99ec4af7fed1bb8274d38a4ec9a0838842c23d08c83866639f7f0c03f2116847b0da15f4c430486e7adc47ad812e105d9d0ce8e0bb565d39fb3848b1214a3bba85108b30e58ac81928e7f7580d68768857053ba600cf3b6a92d4d43fea118c703bff6f1bb1499612352533834f67e3a937c922d8806ace00baf33e44b4c4d0ee2b7eebd4cde856fe748481f6a6e24343a97ace0eb63e687b6ea19f556c3d12bf970b93f276a8f66c71dd0b08080cfac028f13cf7a2ea002854671340c794713f21c339b2864475839791e08c89c18f6e3bcca812d84d4df4a796638139dcab2ef561487ebe023a03c80fc097212c08b1075751a91ba100570521a80b5cf9ce3c4ce3471ed97b3d26618088a17ce50562f9fe6ad2eb0c64fa00d4cdb0053d8995e5023e67b55b78afb09008e44b671dd8d380e7353adb8ab2486ef1417dce4f2a4105d97ed4018dbfce4afabdc60df0af939e3625b9e500b6fd21e1b9d807d2adea2590cf3f6ffb1c43fad4c018c1cb422db36abb4bf6c6422708ac8ae7b7da06a1456d0c9c8afa97350892e524e34f054817075026f481d59a3fe2b070eb2de59d29242b448688444664573b9027738223f073f8eec27acf9abb1e1ec0b94e30f52070259e61e24a04bc91e84a058664704cd49d6037c3e24782fd3e05f7d5c824a32833526b74c5286c82e2cf388885b7c7f130f77293738d9fe51e68a587332073e4ba604ddb7771b1d9c851f670d9833d0956f137b78743bff4d7b6c427a90fa705ae89a484b7dde003a162775370b00ebd963955171a242038c750dcf51f50df896f2ea6a4e824d6e0d23d09787f2b1ab35af7a143d4f7b95e792f6d3fdbcd5b8ec3bb2778255231330720cdd1d50c1b57b7d7ad03cd13c46097f9a10825a6ed0e674a49a450753ed8579a129101d79b804eaca5cc48e393c8e29f212e5a664ebccfc635ef038440270d7b51fc6c92ab703b2bc3ba90172d14a18c4fb807684a657ef8c80f7d9d5d9c70cc7681b90848614dcf82f65ac1ec318f4ca0be7282c37b487cd25ec54cfebac4ea57eaaeb5e36344fa81b6c9cb3a7ca4a9b562ee4ee8f02c3c7bc63d4d000f13b1b41a8f90d4266203873580203c49fccda306a325c4ac7d8475f32c916f31fbafcb29dc902399503eb59f82576c07159357e94240c22c1a100325540e771ff1cd354035172ce188fd98e43cfa392fd6edc1a5179ea6e20ee75f95d0a8a53113a870605fcd3a2031c879e6dc28886484df6340cd66f5233c0b7fa5bc101a573bd201b44f912ae987d2705ae78f72eedfacc03222d5df3a44ad6ffba37101b5b1bd7ddef2e69883f3acd4fb5736a1000e73b3081d6ecdac65ba256998ea5b448fba0d4171c118e44c1776347e7355b53eb1e3317471f0b0b6c5c18548070d811c3ce03d70ab99a34a6fceb6b7f4c882c7102143d7d7cf6d21e8f37313421424f2f7a9b5b7c9270535dfa40f7a2b4bd21eeff47bd45daf7ed6fd2ee2b9766fa0b34ada04ee85cb806ef8b53049c0fc52f741b5c40a18f12376ee62e373f4c98bcac9617b194e08432aca0d6f39bd422b926d9729edf469f8a02141f6892508f9296a22165b0367296d36878fbfa5328ce69eb31751b0eaf3ee0b0cf4b1a21a42735a9c7528bae4c7372f568a61ddcf3eaf8b183f4eaec912562a815ea62cf39a1a1f5c348dd51ebe351817f811396edff9fee307556ad22dc32dd3d08ca3f547792b02741651d0fe634390de4147b20465d96e67cd2c7952aa1be6b4fabc98d6b55e5d8cc9f8b60eea56c86b66afe6d975ef4f646b5369940303cd9cfa3b037b14df84af8391d28820ffc4847e64c40787aeca3abb1d42ae88ebaab87fec931cd10d1c642d1c47fdb9f89edabea17a917ddfdd60f0a17721a0d1fd34feed84e41ae2d56555a0947018df51d7520b72d4c6f8cc640389e7be35f54fc2dc73ead2b2805e5f0855f10b0492beb2f97b1cf7a9d87e5507a810efaa170045734237e4841dd784ee5e60594156e3729c2e2c2d1de4cad925ef77838fa5df9113d44ff12d46dd225cb8709b509d4741e118e55b79f87abbdcc668cad7cbb3548c360ad7205612212273fbd48fa677a977c341cc7d68275a2eeff565f9182c02902c036466027e93752e4b7c1c307282809bde05f36a0a70c98b7d585b8df7ca8baf31f4450bb33af1a951a5d9b4f0c709420b1f07bc43d575384cad90000c48639d30cc5b1dade298a635ab1a505fddc2a88e13458bfc3a9814a2f6340e8efe5315c215a959cbd30018d11ec90ee00fe705fc5fc1fb7ab0c65ffd78208f147031243d0c467c74f4060ea000735b2e6b0038f497b667a5cce12d73c1595682b45a64dc3bbaf355027b2caa89dee65893865e7108e72c63de1a2920ad877311b0802f995626c390ef2d4cd84a3a415d9947508362a8037731ac038efd5ea4423da1dce43549a823b15f15debbf458eba109a27f49b543b7c5cd0283e088c7650336d6edaeab63ab67cea073dd1a7ac5d59c71016f6f8099d28f9203f118feddcb6f46eaeaec6b4ffbebb42e89d6d68e25c7e2f015e83e8eb1a441344b0682866359722940f70d6752861e65552da91595cbdd764aa158c611035a2fc09ab4d212cfcb846da46bbc51c1031e1e4c488bc220dbd952e735c87bd181d79eb3076eab85f466ae9b430ceeb26842bf17521b78fee421cc1f3b8f32f009bf906edae043c63dc9502773f6e7347327977a80019ac59b4152252ab252a1e02f19a498816b384dd7208c38dd1771c2553197cc96f58130f53647b33f5ff487c343d523dc5c491bedd20fb238260a374fdf12dd8476d28a30f96478d87712d667cf5992668f44b518332c3126cb4c70528859d399693eabb4ce914ac7369c20ee1eed0d8ddad318fe43635fc44835d7a43e78c5a07f0ce03b03915d7a8fa5dde21133d1ef36cf64dd74e0cc9f2051af7f1c72841eb4dfbc9bdd96f95409ff7583411dda3f567e0ad5014b5a419dbfb5c37e85b360ec9653f51879de099285cb0c246a97686dce7f188cef384da9c6cbb43c0d9c4134c4126eab1be9e4a88be9d4eb48f2655940e2d710945c6c03d6bbb0d37dc4cf3be21d97da9a28dbb513af927287db73ee4c25663785e173a99d6e688d0b19ca07ebf0ab4f2c8aace90021fa0cdd92f3a37c985a472210052f00406af1380b1d6058e2a120c7296a0d4411ecbe9cbf8ee75c4c28a0a12792a2db6d0f00f6ba71cdb9220242b684fd54f049016759bdbc42f7a9b404db6168630c5969cf007f2359d1044a746aa1ca7020f9b770a38e3a0675f4d885760b147d44c1d8d92311e79087924f807a7f36153de6e1ead315356fa3b9c4112810f622ede85f88261a1c44af6b8e5a86c436c9e3745108bc61e390f45e71a5c130f679cc364155e436bc50577ca33cc9c66d289945fbb768675507bd7e3a98c2e749da6ee2fe24131171a55b5f34cb9ad4be4ebca667ffda1f016efa139d55ccf72c37608bd7b26658640760e02a40f5e4873eb644882418350880d3ddb53c98341b8a76e880fc8c4d80c813caa02fa9e0cc3c858aae0a44efcd80121b0d71839b2866dd43cf6c013c8f01070d2b906cfa8e747acb3287042ab24c0bc650f3452314c64743a50a905128e1e7994313ecaf01d8aae91b81da3ca8b616b33f22528d00c062be4f9706ccb98498589813f1a51ebcdf587f31298e638ce244d4f3d384ea59da93de5b656be2a3b0e201efd9502069f55c57a14c2379cb2e5873ae3d21b77b61c6a94a622a35c9cc9e0f5629cf52fceacb01188ce7a2d0509f5d2d0344edc911fdda5538ffd2481c1be10d7e8d1ead9f995a317708326421a99a552e76fc82ae7881c727f0850a85b0e0884cb7c96f93347bb6ce6e4d34d0ce6b295adff25e17a6ea2b0300ef380d7b20e6bb1789605124d354443f60948b77a497b07abe3e656130ab2d049045a5bf39150de0bf0792a9cc40c63d3e0bd0035ed8028b009466cfb08ef58850d67a5c1d252cbec466f19ce0fa0d58536e4dca6e1e02d9b4acf1091989597667473fd9060e4a05e91fd2f667ac34dc827f92885dd4e4d88611542cb20b54727d669b9970367726a40b33c606546ac0258df56fc58f30a0e1ee2e37c8caa75e56c2e69354d26db3ea74151a6bfc5e0f511f19836353f1ff46993c7abee69e9f90526dd619b1bc465ad39f6cf363385574e629165163e5919f9d6954de245bf5bbef02ccb681bf8f05e8105116280a6603fa6dd0f8f1d4d83aa10cafa50d22038ed7d98619ddc07f86d06bfa4acf9a7991517ed78d0a9ae03b92eb2b449df9709804c0388052772b41110dd9bbb8cabfff8a7a08ac93c37a7bbdadf9c56d7af759cf0aa16674fc77e38498b13e958b9e76c400a2611921202179be9716c87cff1fc0112bf95721f5f131aaefc0d0d8ea47572f7c79f856bec0133504bb923b3308abd1dc1286d6d0dcc485127e05a10bc37996a5a9e6df6482bb0e047fd3a4f0787b9feb8e5d86b42f378eb2347abf22d07aad1de2ed304be293fd452f60e6fdd7956a9814df462a072cbfcf048f7f6280eab9b9a1ffac1dc7d12272b9725cd70a6be7697864ed4b55d436857ba7ad988a417439248e9eb8d2ea185a0cb20c7e883425d2f5de42fc8a8fd19f6557386ce15d135ff013fda35a40500d895501ff49d1dc64c062b178a1dfb1de5329b061a330afa1a72456373288cbaa03994e8308acb694c2047c092962196617bae7ccc9852a4d1dc8f98fc2e362cbc1819a1aeca579538c3873a801523297856c9ff10b24d1cc1a0272c8f3b2e78175c24697c5781050d01484243f02592b80e0b1e30c831b9495cb92ab0d5f961e27612ae1a0b3899644a906d0afb2317dd28325bef2d5cd0478877c32aec64bbe701f35c24f7316fc842f89fb64b71052bdf7ae42a2da29a1c65ee74298d85803bb8671daf4ab6d6c58fb41b9d2ab716065e476ebfe24fb88a402f70c061bb3551bc6b5d1f4d2b49e387cb37e69b994b12e1708d056dc563b75f38e66d0d7fdd569e69ed400c4de7823cfa8f1d660beceb852a6936475fc8b79dd8f03c7c5b8d8bc8295eb4e565a1b321f0d8a2d591cd4574a9353c41ee5701524a16f8c999b4cf1172223342c076bd42ce9182e493bc9cfb8fd834a45a6a02e4a0905e6450565e6333f16a769b2187c2772c87edf2567ef132aa762855f8cfc8c838bf78d0cacc7107c43363ff9492c3411567ac3b6a6bf638bf7a3baad506c2d28662fad5d7695e044453d2cabb188d081a2edbd33eda67740d807562a708a8b4c0279a9514c3efcf44c4e81bf7b181c9f345cb13195a485d91e4b69a46c4c0d56b681f5034ab459032c54fed206b159002e1b272cff3d0d5c436275ca0a69385a2637367120e032b838984619fc0e17aa50faedf0910a521e1dbc36ea0ce68619cd0795a11576e232ef568ecb995097be6c34245d9ed89ae30475c0fb607abe078a6154020e646249da34573442241c01654d4198db618d1d589e23dd60da4c820a25ace9de6ac186f3cf1e9f732fdbad6099d1781b2fa6878400620df3485792c3adf07b436ed8e658214bdd102cd1af7685ca6774a2728f2c9dabef697b64ec90fbdac127d6291241c8d10bf74bd19807333e938093288a9e03b08f7f953732f5757b951ea167ea7e399daf1dd780314af05ce4b9074fc01a3d1f0e174bfb8c62da62237fe6e5e84fb317f9b42564d37c6e8510ff3f755174b501a0d0a9813b4482b005e67c3333080d1ebabcdeb3d4f8fb7edbe8578e594033989a53ff286795d91d989a9b2a1c4e95884690cb6d92ece0e04865321caba091163ca8816303936bc9f6eb32326ebeba57fffd2f04e4b9643ecf6381efb9db0d59a1ed297b420545c355e6dc5b3e7dcd28d5a3b8d25cd9daaeb55ccad9b27a211dcb60c2798bc1aed6bf91652adcaeeb9b0767593afea6ec4b8178c1f0f052b876aad36cbc6e78257311cadff2a154bf1ab61509e6297da300e91a36e53730bb39b7f6078f0bdb217dcceb74b70ab64f5db59d02fc4fac347b402dbda83ca994e4df7925c606f6742363b7ee2caa2e8dc0a2dd2441482bdaa7f99780ccbe209f49a17668214637d00c8d767f4e09908312d2248b0e95e2fad0590ce094bfcaf6e623fb60c3bcc7b903dc6e53bacb3e3d96e7071358b134e20727983d9a2d993d6250ab7a30cdeb5fbb3a1303433dfba7cc0795dac26acff933c9843e8ba00c272aadbd23883f2dddade56edc1bd6ee8975724d945dc8ba96f2a8f4ccf9516341f13b4c639c7c0d9adedb8e710e48b911d4e3806535569c430da1c9b214dbe0f54444958f63469c2c309081874dd6a193c6226bca60fd46c81106957c3ec04941a9e251a7e832337dec6471295e688997c010fb1b0061c526129eef950c79558ede41726215e6906bf469a74167666e43d1579bdf9bd813eca8d3b1681a7bc103fc2e18de7783f6b98088e80e767389f7485c990a008228c74cb155070144393f1b098ba0f3819d2b1819eba82772515fa24e4311256f106649f6fec8f155fe4ba85d3e4740c94b532c9637fcf62d79dcb4d00f8d79b87e7cc9df89c2f6c26354fc61abdc0ab48bbca20943d168cf1aba3ffc3682df0f92abdfbe72fd2dee0cf69acc6f6f64e7289c4d8c68791e58dcb1f59df62c8d8953076d489189b134dd9b97c6739dff31715e73326b089df65cf12f81d638d54c4b122332ae595166bdae3fca8185869625b46a8b15e82c0678ae4a1b747dddf124789bbd0bf1cdf7b157c472f18066744c824d91adec0702980ba6cd84185c3c5f4bb5b7fa6fc27560e2d1da5248384bbc60d7f614e83e4deb724d7bca2747d0652fd0aa080b296a4405872c1570c86054718e7f00cd7827464bbe5e2c8fe97dde3c63ec659091ee9163c252998cd5c505303ee3f9bd422fe62717b0364bb8d8648a7de10aace3a292d6cae88d3208026cec8548715bdb4aa6c2c1506c1381489ecf32aa7c06d4e6c19ad6ae40def0d306da6cae413da30ccd3d7f7446090ea5de34cb56965fa74d36c673adddd5db2d7c71700a6ccddb1ad46e6856c2fadc27f8909530a2ae5d87b97d72fffdec125b4cbaa799367f132077ec73d0c4d6943dac8a98ade91c0093208f04dda763faa21bb7738ba2de4dfed9b5617af1ef751599950ba6aa0bba2c985a495765e30e624ecf697e233ba265ce63a5de52e80068d500e7568d8dbe235cc27ea919f89f7f16f168fe5f2d87ccfdcdeddb20fbedf23d8a6956d218c17154cad076e30b4162fccf5170f99d604f9680db161763e2a46f8102ae36119b0426654a2d1d5d8a170d6953c511065313465082db0b18aad0801af39fbb67c0c6820e70b9ffa787b7ad940aa545bb698a4bc2f1c9c4cb52f8f3c3d71306353d8c110d6d334ce1c134eeaebb4da7dd8009ca71615811e64c2d68f695178745c273f2017890781190ffe3dacdfe0879495306c58adefa8782cd449c4fdfb270fcefe35350b249b073516ad021a07d6147362d99b807d6c108871eb4dd719798d6a4c592b5332e6edda4c6d304ef11dfec30dc957b7023bc3f05a295180738d2bed8182d15497bafd9d21e6b8f48e625c1af1be36e3ca0169d9e2bd31955d87f9c8366cdcff58281defe9e7024ca34b2c3ac551b9ab0c0a78c923e4a80d587db6d8b412d9f573e41ee7f91ff641c47bbbd02add67cefba2bd76321b5997ab9b3e20524e4e99bb179ef829f7ff7e0b5f819b6641ff72aa1641d4a4b7e480e1dd27b781c61023fd2aef5acf8fe6ede2ffbc5c9d23ceaaf0680d53ac9262c44086ea083dbf14b6855af54a68a35c668bec960da9ccead2b95de83f2e37cb1697779b501be1997ca001cb0b1efb54a7a2b741f933ade64655e04d290c1d23992a83e5ae836687264755971489439715068f7b35306f674e9dd2232d8df191e4898685cadec4bc20ec661c5262b7b1239b1c56235c4339505d081c566ef4bbacc2509b7e20a3fb0a4b434ad11993321bc18ddebd628fad0089523bebe68c02a679d39e5b8eebad54e3fab591ec9d25c969c9020152ea77071d173a2328cd165a87a6c29c481756997ee6c0999e14b7db0c810741ace9dda85b51a5837fe738bf9cdb5d76df0bbe626ccabef0f592a14e4c4963e3b927ea529179efb3bf605c05828f41c301aa92a4514da1f29d516c9f86a55daf871e6203e8c44ce4d7cc68ef90d780f20768bcbf5e29e39c0bdbb375a78db4a13936e00e6664e543dcff99347944b35e5216e1d13a6d714c6653b1e750c16c6f9b29ceacf3b47637e252db9a5fdff509569460b9d15c026d9720e70e099bdc9704de00ccb683061fb1ade09c704454a5bec0ced5bc89f384e5f2dee600f5078820aa2dbcc6b6ac036a1827395cdd7acc2d5311965c822f25d05cf69443d76ac80f7a10a0502e3312cecb3a19f6b31a089bd6064e7b48ebcf124a2f9fe568b3aa2b3f011a1fd4ffd58ac92de219cb6dd81e4b0d6c1e5f842560ed927b89fde1c5b62e3812b833456bdfef459bf3e5398d102f915d6f996b421731ba35ed5d9a5b8757f8c4f49374297b325076a6c858aab826948522eee98fec6b1695e3540165104248b23c7d5a86b99399ce7685a678a956c0dc5d1504ff7385a8e026819d29acfc6ce4d8f8e5ee42c891a27b2f0aa225c6d39f17bf2ee7ab577ab1948fac3a812cbbcc1583dbff1abc6a56c87f2cbc4d5e7f935dd37404c304c63a537b177f779a6ffbd8f5ef95e4971d9da263f8cc8954852808a91901128c89356cbf944d90cfd85b043c3ed942163b670be92635f92e00521bf12b8ec56b49115126f0d5f1addf38209717d513f1cca1eac8e08c5600cb600d438ac3320a27b174c74c8d69a4279fb9a15742277c6b33a069acbd1fd955d7b649c91eb769432e7c7ccd0f834823d287b1abc60800793bac64a4628dfc8cab4b8d21d35c8541b98d1b8143b0a585e5410f38b3cf3cc6aceb2d095e8c7c6b08dc5c26abebf43702f8b45826ed668ea5692515648851b9f61b21f8ecdaa1f9ea773b440bfbafa3291919332a7a2401e4616c710ed7850dba4600384d38d26c524c584dd58a70d3e83a349cba228668af222a60876b06dd7da305961accdcc9a11b5f64d64c064d9aa23ba8af5479ee365935c96b2d3e29223ce72dfc3d1f5e2c550e7e7e02b09bc87ceb83e1d5cac5e7209b6dd0018aff55752679ca7f49b671bb3fe246d74a68d5efa10f9bc48b811c22aa3ca9b64100445e7fec064d41bc31b1899785cd841b9766a8f8e7cbe9c37bde14ac43f1cc600fc6b650159597429e2e381a2c07e03040cce9421b6451aaa0f37304cafca8df88db9ea32d88b2f8f8efb2dec7474471d6224efe4943ef960e140100376020843f370a1bdfff940d77e63de1ca4a30344f784f71abac8e50a5b44a2e8407833c3993b11ecd4247b44cb4d98ffc166b93c67fb667108d2a4bbdf8db43f8a31456fed372e59e9e8cc7adbfd64777b59197d9add89ae448ae774fcce0b7d337c9bddbc1e47c1f866c133eca6331088d4ae7607d72412ea6e142cd4c5ccafa75c7114b8510188e15013aea5db65ad1ecc595ada0cacb2a0326436333858ae1afd2513f945f826e592a6b4adebd5873bb0e27b5b70e0ab09f3fd490cf9583040bb2ea9b8d0fb39aab770f2d85d870e0cd9ebbe167fb6fe2b5b54e6843f8533ce9d1908a4c8eb755baf1ec12156086bae4395c605aaeee86754bfea1fa23c9525c4da9aaf4063658e0e50987561f75cbdb705f552241ab218578ccbc52eb27c4d43f7dc7e8dcd329587e5518677d6257b8c0f4cd53549d2377eae49306618c2466e567c4a4ac54a95054ea6150b981ac2c756b83b73c2d69cb1a20f3db8317938c91a02cb80a429609e1311c14b2dc5348ac5657bc291ed60e3a70a73db24bb8620f6ecb08a25be0ddf87a18f458ce941391e7fee23a361726e056d17b2f8fa2b253e7126f1e030734f60481dd5a3208e502d0a3da152f7fe4c639e104be4860dcedea2a40cba44e9bb7da18f9db82b29f73568b981fe60f51107e0daf7a3af391e0235d6e0c3c97b9b62573c0a11710aafe9fa30990574f3b7cadcb743a4458f406c3ec3312d015701a711343e99204adf587ae30410134530c71382899faf6e37e6f56d0832a5c788f158e415b93f2d0abcedf2ce3a27db80c62ba9ecba86500d0c99103c0311aafef49fc12ae5340f4738f6d90cda9fffd77f56d4a79ccef3a0b031d0cb578518072fc7a7cb10c9dc7bfced9a1509b9354a39a9b2fad82856bcd5f5127ea7a12c1ea8edca5bd89f6a187e0d8a334f8611da2bbc7355905f895e18d47ee7873ba683b43741ba3eb69d07755334ad4b13003c118533447c818610dd7fef448b711536be62e977e34460911c1d2a880cec3555d52d1b80205af8761a7fced3ed353e2da4c7fe6f764c0e6bb7f451c917d9818b6596eccb04e9c71bd8f1cfa66e495ce8364b80e002816924eea83f5d0edcd00fb9aef15fb7802c85f3829e49d51bd71213f793b72971de4fd90298a4e3fbc57d293f448851c388c0522a94459bdcade4271d003cefa5a0ad488417ef2d3d3a4417b2e8b364fe86672e68de02a7d7034ec93de1643f90034fe0a23ae24cdfe89167e30ebc82c9abae7a107604e33d5b685566358a29b55dffcfaa88625df7b84b680aa2dac1ac4f79a0f1e0383b18e1136bb103a8436e3302b7cb6711426ab372ee627f19a41ba49a8ef2dc8e29ea3afba925e518a23784fbf9d549610f1b5f170e23315da72456d5c63056904f504d97aa22f5752f91ce56ec9d287f9885c960bd75c48ea6f2d62ea85e85861eccd2c876eddc616d32b44222f28d4dd2ea8e71733a9d1b0498b7393d451f6cdeaca4c7fde6f3bb1e0ab41877379a22bf9bf06066b3a27cc6c3f53028ab9f095e8a53f2a9c50422be0ae3103cb8793d66063f10a58d00b6d0c874a703e29ce58175353826fb9a05983a4b19f5fb3c7d9f61b6b63085890ce6a623c8929760e46ee0223ad4fe33680be2863e74b2ee280ccf9abbaa65cb2f75d8537c8f2c80da530b703ecc22babde6db2bb4294478b698265fc5cf89d120dc455822f89f85dfc021d3094f63bc483244b9844113488c2ee7b9bd5709e83d80e8118081510fda8d08dd06c866ebd2d7a1e3b6542eba2543b7102a6b3c0642773381bc25e810aedcdc5f50baaccf3a1d22475a6be239131391611e7e24dcf0b3a2dcfca982c3ed06b11f35bca2997c3aa603063016de7c278406d31c7144c220817727a997623fac44a165caf9cf1cb576e3410e3a94ec80a6f5118c3a4ae346c512bcea9cf6679a40670d3b1c1aa27f09e4920608ab48caf354c1d67e59bf7a8d6c8c7342702b441743adc72fac18e8f9f84d045569599e4d915af32caaac0172af35bea29a634ea00fbdd93557643c5ea284c4b2dc1d1d42f4fd48d55f26b131b0c61db73a294105ca5a2417c073f1b9c25ae7f9f16ba6c46ca930738c91b52c6805bd3c6c492fe4a8d18a4acc4a504da5a94b150b74f93993508c274c24d4bf4b27043ce86e735a1d69be5d192367b8d11c09f31400acb424f0ef58f9b1ec96ac3d843c67f11f0cb05b1834d8cacd84d9975309fa03fb09432ae108782870de5ba50f288a4d476a3be745ef18d98a1af01e714df166e7e82db509881355962df5489ce0683b0690c117f2302810f1573a0b48d7d9f741ba4c21d9ab73ac6163b95041d24581f72cbdd8988216a8aa708c841dc560ddffbf25267a86a12d8a8263263ec227c8a5b1b378720b65cf5ee27be4c54c02388a291d7d720e5e6557c1da119a97a47753b68d81963eec3f1b20e6841714faada93443508ec60e815942bdc221a7b01e7efc21bdc852392a44ea4f14a74e9dfa93fdafec9592810a3f4f44a977c2406a34977fa51a086b1fe1fdb8fc835c0112216e4f1477be31cf07d1b8a2452cf1d32ee852fecac8d2f9cf4c8fe50fc979535c5cd1b4435267c37de25cbd175fc98d4d6d054383e5599cd6811b814691c6168b807373ba71b740bbc316e55732d7c372b03ec7a52ce0562d434fb5186d72f388dbc7f071dedf9ea15734dffaa98240b67f14fef6686261c80e723afb17f4266b813d32813a5b1116032018b3b14c4a6a3300bb2fa5a013fe4f1c76046f4cb02da87130bae64e0fc2495d1e5abe7d81a7001ecf04ac42e730c29360e2b7523c255f386a5c6a8be53fc09cca476355d15f87d4c8c896a0df34e0958930db3fe1a6ce375ff8afb48888ac226d0b5929a64240a01d3c1b7e56917fb38f0ba82304216b3a42cf877ac346656ea3d2a7acf1f19c6a4ce35f5e6b940e0bebad755b9212c5fa7181fbb315a5694eaa09a42a014cbcb9e0a9716c6bb69fe5a0bb10e8c7f90b38df2b95b6f30a2dbf3ee2d659be0a92ae4de24f3edc70f12715d31852c0d7c4914d23298d6edf9f738cfbe7bc31bbefd5e6872cb05a1ff4814f78ea74a9da66b7501f52646d82ab4dc4cfe3d7021efd475f9f9a777e704b75711efc1d58d4e96005c9e2d2663063a2bb7a13372b270237f2d99816a11cc193a9c7a2b10decade6789f3406412151554177b8be6dbf0bb9529645c672827c7998b7cdcd0afd464c631d9d66ebe23da3d34cec5a03b1a7587340918a934aa191bd72bd430a70f863d3ef07ee461f0c5b5dbb0b8448c4ca9f1787c2244d44e19ad57ab5a830802d855e0f954b23a2ea32ad53dda121027f2e35c00043f8140206fda7666bc1700b91190cd38197260e4402ecb829d7a138650cb43a4216976f5274928eb6fd8bb16b7f8ef04716379c9317aaa528d5da75ed15a9f044783717ea8b1e9022b34e208fabc283198396c2c87d90041c69d32e4635566fbb5dd394cedf3dbe9b43ba9f59af324ad16aad78ba5eb3c11ec7dbf05932d8f2a9d9ede8bdac007914e15feb8fdfbf3346dcb169e90180722f070f98f0c478efe70cce151135c599e7b8ae755b427ad1a42706161c70a8da190f3aba0e83e19b8da67945d9451e43ad432e09b50d06cb70f810a68f0350b840ed167fc155be6c6069f7c60709e98628c8539a637802ce95e1c3ad7cffff62f2b1a130f0929011965e48c2857631b88c31ca2b4d19947925505f14987f9c648a691d61fcb2a240dff45cef62a9696c842475bd01472609d75adcbf867b16136d84360ce7d65713408f764d5a3398c3d1abc4247d23106a4de7ac9e97880eff36597face3e6b15aeb78553dec586a258a3bc7585a7b6da095609b1da78f5c425da1a9c61fdfaa2e9de17829bb9aea990a87eb876b3df898a1808c916cd7a14a05b7f08910dab7f8c9287e45587e7794290e44d910c9601672f7bf25d8efd6496bc8d030694c1cadc5d378cbc115450d73f8d1ac25eedbd1226026e028ea68118d0bdbcbbda11233dde88916cb1d3482b5c005cc981eb239a8dd27b4227d66e0d174cf3dce5e6c3665686b494d97ea29f7d9c46076379915ea370d717b16116528a3f18d4f5dc838e5a1f9dcadf1a551a819d6e1daf22d9b4cde8de871ec870c7ac5424e26aa33a0a68b1799b332d884e894b65970bf247c865bde8add9ca0632a6ff11cceaffc1d0cfb2dc0b338f52959f5eb7b0ef7440a3d19df4829438a388346205433cf3e729c5dea5e81761ecae415d11d04bb94bf951cad6c078f53034b586784cb7cc09af3f29daa55436223d2045eeb4cadd0fd0e0b55555ad218f8168d609f81ba55340de2de86ea42b74db951140265517d671ee611cf51bd0e1b20348a0d06777ac830f587fd06422b91c5547a2f8e3787fc5e71841d29887bbcd1f8e7ef077222cd95b09af92ff8680fad973b4c5fe0dfe1513c63117132162824994e612f78fb025481b61a0def8af77340909ca369f68875d26d6024ebd7dfc9f283df8a3c6a793cca8a029f8de90af968ce9d00b5b03416df2b5358d9c6b446e1b89ccb38b5db0e26041162801a199d004fc6edc88459cbb63bd5dff77e4ed512580c090b08d5421c7f4bff5bd2a9b699381c845eb4791b5503bd550b8052f9e82156269537b84c6bbd28bc0ad100bbb91ee6d244f3f3d7a38790a7b69dd70f267053305e3b881f88ef5f770448008c49cd56b3cdc82f682067809434d7a94ab093e30ba42d69894dcd62edd944632c304ab6dcca96a33c5c8c1a5aa511dc75782dee760e5acba60e1c94d11d443e07a3d5e93f2e3ced8043deeeb48e9f15a13568f14207e43737e31c5d408cd07702873e8c741199229a797d6d6dbad4577de571616544f6f3f755be7b71addd64d01e0ae544002a2339f29f1aea460488b044b4e95aed2f952473abf11124102c1b604dd05624790c7add851d422ab3cc0d9b1513f67673cf248b8616d9762ecb1428db53c973d0aa19b8aa8a483c5c8282105c7af8bbf2a6616a0795a6be7061fbd01e45f52b06f22e1c44d7c3908525b6a6b99705e647ac86a58e8637ca860df69ffe82f6c5d671d7193b71ef4089134cdb71946298597a7a7630195257044136c3965df2fb4a5b1eac8957543b4db6d3e1b67aeac4de28dadb9f59eff16f07afcd9bd1a9c8343bad850886e2433e24a20ec310aca8416d9140ee2c811aea1fe14b90e24bff73989ccc085c5d5c2638f4b41539e55eaadfd11282aa78aa5ee0a0d01f358545f32348f0df7085f284e069ed09ed82bbe07b0334ba23cf6826af2a23535744d2a4014110c3975d001d9f8f5bc7be553ed349c8fe7ff4156dca1ec89579cda56fa56fcc6108779b4831ace5f11d99fdfc9097ac78b938da541a2e04e763ce4a635f259869200ef80806b5b9b55999ec3c1071313ffab650241f904164ee08a051dc5f59a632eccf035bad3be0e89ae6e7688786996ee3ef0b771ceeec165af35ae2108263c022a0ee2f6eb1ded53ae5d0f8956cc774ee1139099df63187b965d0c9e6ecfa932e75cbc122655b56b26e214c60d079f2aa775d4d5c2760b70ea0443edfe0500c3a1d3784563952145f362a131dbea1fa9a740abefe49bec44e56d945a02576a8619a45cdd11ed96d2cd68b3562fae7863de2f7cba079e564a247eaf83bf926e33d4ca29c450e928f0b5d4d569639560b2ee44354063dc055a6ad2790798019ed7faf42accaa76f9b9f05ba5e7d46ef16c4133d829e52615dab0d4e4f92dd89f2b39b140457661d619534948a0e8706f55b52653357c3c8ed669133d1331220e1826b655c34e9e2350a07a43a54a391a05fd3f6cb021fdb0209099f517d68fdf2a684f19bb4d93509feb04446178c68034ee29d6bd763acd798815fc37d939c8512504e427e6e8239d55e70d1ed4d6530e4131f933a73c4275de4cdaa757186865404ba9f7f73300bf2a0aced76fc1fb3b20fcc501f91e107f166e621aebaa6e6652659aacea32e302018927a749e17f87f2c61604ce3407275407ce8b9be58fd46780b4325fe67002008648bf0a1cefc236f1d6471129adb96565e962c9e15598abcb0d1eedf977f9f47ef1084132f75cc603013035acf5583b27869cbe60fc2b364c7eca665ceab8fc9996189c55f6e45eba218c828f012e16accd0ac59bc061050450fa37ffc8cb2c96d915c63e129e47394c622b2cef65d0da989800d177431d9db46d3606aad1bd9e688c7ac86de36ba38a542040940c5347de7f52f3d8500af9328b2c1da5821613d4c8e3b6eb2fdcb15730b4f0649c9deb4f8a33b6f25932068b254ad36de48732d96e2336ecadc71e69dad495b8724d83c2cf3b1d97f670cfefa3307e21e050b02b2f3a46de018547d53dca492b9821b53a77c635825e4b06774fc6d1ebe9af0a27d44b5b1ea3a2c814f95f8d95045bda791ea30adf65bc30e5644461c9588a97a21a3825322e6348f39dfa63bca0c7dc0fe5f7fe8ea8fe52154d326d51abaf5c6df8f28dcbf0558245e9fd38dfcb944b1b9d511e8517f32f9c7b0e4ba9e1bb3a96de31e4991f7883e4a47888ec99ab69468849bf342894c43bb2b51ade5bea2bf2a878e2cd7fd0636a987261b5b3f848e61849980025e61014418c5335f2b0aa3149a9c14ed3883e36ae634407b5c7e5d13faebadd06cc494d88a0915b6a22f932ff90cd0bda1dae025b96ef63dc0b75084fa7f6e25d74e2de514ecde9d04a5330904362768b8512dad08513c32f9db63cdcad7d9010c49fb65c51c512fbcce0c208d80a4c62227d71c2664a729b30029bb3f3906b8f4d261c896b449031fce981783eb91c94e2946c3b8755f69547762f4fa59829f0f211bebf970df1b9664c41f3df2b54b50a839f8462d19762b32eda02862270ad9601d639d6e82b376084af786d8ffa0cb522fb52bcdc75205d7e23d703a79fbed9810131dc8b833a7291e77be56c3a6e58316e5af31383c882cca1644d0b57152928c2d104e39570061f782787a45af7a13a845c0f84ffa56c81419daaf73f6853290234bd5a468b5d6ebfe916a2172dcd9f3248b81524c75cff3ac5cadbc3a303d5afb92854700f1dbd360e298d43989b867e5b76fdba897962415f03ff60cc284da30bc082245f615d577355364eb74ec3e7cc97864d7fd748ed450d4d588836daea9696df8ecb95cfe026a78ce39e8d93acd4ea82761f7983ace4004eb7ea09c2b79421a6db10d27a11e687e5ea733f8aabd41a1f1804b52d0b83790d83174caefe9089d528b394e4b263daac8e2a70892128ca4fd4a539217d098314ec39259776a3637232bfe61bc6ae336cdb719e47d5ff6be3a067e3f6ca4547d4d2ac62be2b7d0e3ed530ff5775225dc197fbbdf940e14a93cdea796135e36e367d79d8004b1e99537cd9e70153460f052b42e5c623f5b674c4c8c10bbd7f4b28d094af1525448815657ea9526bdacf448c3493b09eba57eb34778ab663607da5ead75c2867ece68a2059b2511062a68bc0a97b89935f9a534907297fc013756a8d7afc5923ffa19a539e239635c3899dd589568032d09f1c945546dadd81970dba8b4cc820f0cbf319cc083bf552735e4b4d284175a9a80c49eb346b688373474a0c677802f5bedb96b412303362e5760fff0894ca331cb0cc8293518545a0a86d62b6472df97edb4a6509b84cec6ba60dcd8446e00e8f09fea030aa37f8473ce518bc9d61d8328f1b06bc7f6629c2784b555128018e8e5c5bd44dea7e918681b4553ad5a6f38d560969efc6912bc4bef294b0483beed238e6541ddc2f94dacaf6124337793ac927aa6d07b05ce1c9527815670f1570eda523c0a5ef3f7b7edb6d1f8218866b940b578d6079e0bc5129e6e374cf05a256a9f46542f7cfbf1b312ff9b257097a13ace42c90369524fbeedc9800fe313d79d0560ee329e0ca6aba118a0efe4e202785b91cf14fac3cf347cd11e4de319c2ed89eeb27ca1ab57c82bb62f2adb6bb854c23f88de78536f402b4a8ec784bd22b8915dbdc838ba261fe22890133e5c8ad8d5c9be014188be10d45f720c977f6623ae817cbb601ab5df60000275feff269a61ba100b6f1d54989d08fe5cb58e0fbd702dc92cf2c488d67cd92394b7a43ebbeb3a77c0643a32c8468f68173ca23bb2821a6f34cb99253cf85f424387308f534a950be0b1d15c74c72f1d4b577a35bcaa1bff611b47d49dfbd1b0d03830b98992460019540871fa22a32454e5457c939c2e5839b59f1f623c00c528d7dcccc4870fd826d319ee6ccd9db582f735ab32002f471dc91dcd1e843d4973fcacda6b4f5228abbf573cc92e5700b09020a20325281d1db210dde0ae0a45751cbd77e6828517ed11ac7beb151139a7537f0afda073aaa63815033cdcd35685b76ca768d76da7723f4062d0cf0ba81730d0f2d4f2fbe5bf8eb844c68d7d604d9d7b77857ce8fbc390dcc9a035e9158e855df0dbb64d5dc228bc13e1b78014c380d1310333136da818f437b17e7daf3f0611f0a0ea8823a1bfee44695570848656b1a5e02e7af214b76ba021ed44547930e38aca1784da64bafae815adf1822deffb57d41d61c0ff34ace9baab443245ba885fe126630877613104c70a31312ee8c6568f9ad6f2ccc781994e8b98ded7cffee917670373d93f92ff8ffc1f5a4597b344b185b4be71ff34c12f064750c9d328036667d752d1d051e60371477a4d38d58c39daed763e35a289afb770d4cea2b3c9afafed9fd76c83fb066dd09ae3ddd7e717491a2da1e8c73b56d953f985fb508035a0ef98a3c1e7a3e8d05a1a33cbcd57c3c79407ab7327e8b3c230065f4e7b92008e015bea4aae915a221e871771e08ea31a40a8920a268c26db93f915c63319ab080149780b6df83af6632d3836d59acd15998fe1806f296ba5215fd4d38b95c5661572b0f9c976cf914ba1e49f42244f5d86c67a5308b749e1e8310705ffd63589e012fcc9d6ca440d80d7c43f3166f4cbea2e63cf86761ff08259587df777087a04f34231f92605340b1a3a917cc61e5268f850d158f35f1a8253de7cd9bee5c8f7a1dd9051bc77baf97afac95b98eca920334c7ac7ebb013b7abc0f3cb4b6017029588879d7c56d687ff14c2bd997cea1c16fa7d95ce2645945b746f4d875fece9f288ba4c8aaf42f9deb464b7e147c4db37d056f7ca925735bab4bde8f84d6fb8cb36ee56ab094908c404d5cb24f332eb4f636742d174842f20eee3653ec703424f1083a93bc7a43f03afc8e6c1205d67b8722c23f61088cea1f8e8af2009e2839a2d9a339943929cd0690e238467bf338ce93667ef8881fbd700e9f34ccf599c5670d48b5f03ee8a4138b17b54ce6f003696ca7570ee03700dfcf8eb877d3d3c16bdbf1f53e5ecc160b50dbbde3d72e8dd1099bf41d4b88aa497eef734c38eebf5c350dc6167b4204f5a482a79cc1a164460958978d430ef2846718644a86e795f48a06d3af9341d7a96a3cf87bc80d9ec0a6820e539119f5ffc2c72e4ccb890bf2fc11661b10a768f852697ec28471bb6acfe4f77368d3600f93ed5be354683b685de78a95d9223e1b18ce3ee682e39d352821279e27e8944d792312fd4a1fd2ec749054990b8da4dddfb0025a53f802d187b18e834158558a169803ef27e3252436e165b44f6e35baa85119f0a32dc4c63e7830cfec0cb0fefd92ac22ab42c99cb5c0ae9ce76ebba5a0c9245a77b0f7abe0d82a419b9ea3177067ec8fa991750f1c229703e2937c5cb9ec4626cce7402529fe62949b3c12d8331470707924330d577fa0ed38dd6ed11b24db0c7968b6f0241b036e9907d0fccd0fb313c85f194f1526db6d8574cae78660c527fd39e76b23bac1e59f1824c19609824f5e2d0f7401177f194ce9b379dff8ee55c317abe2df33bb3a4aa175678622d96d31e914f3064b011421eddcaa4407af7decaf4fe4f0ca06fc4b3ea27c47fa44fa28e7c30228efebc9dc487f1072cdcafc5601d39c8f26080af65dd7be73d60bac195890dede5637a3beaf7b40f4eba877585aa6d4c81399e8f47c5e8c20c58988e0adf756dc5b8b70bf71e0d359e731f718120ad43700f993126e871dde95221ab23980b13152ba6fd39fe406b8a5ef9f4eeffdcccd19390998dfbf0bffe2b7d86dc770a03a05d0bcbf0c97404e470c872d184f5333d31fce1fdfc178d7317f6ba53687b54056c941d3cd657adc893eba4a50329d6dfba5c0e90da46e88b17e2c9a59618ac686e8ffc0a2acd8d19c89996e2ad667a16bfeed9be1a9727eda64dffc8943abec9e3698e40d9fb600898dfb771eb43a5a4bed9569ce57bf0e0df1b4294e8d2fa027b913e69b5a08bb113ca21430238ba45c0f44b5bb245900440d2cb2baf3c99800be688fd0ae68baa145c2c413e75c134b0b8629ce17865cf7334e1bf63c91a7598a6740dd49556f52b79eb11ad7046a1cdd5bfafdca72a9b29d5b0b14d9553ba0168bd9dab121a3db9a097b3e5b951775f46a23d4f5c8c5fb207cf110fcfc7e3544629f24e22e8df92c7dd531b3435700313d7963a040466f3b8576f47bec22b3d90ef51e14892162a350bf62dbf760c9ba145949a0d6ebf524ab9f15a0014adc996a6428f5b12232366595bd81b0ae58d604aa02b7c35c38c6c61b71bb5af5f31f976f8772f679d13fb43704d3d23edc5384af3b83ad42b22a1afdbea2d1f62f700051f10c77e8335bf75953de2a59198db8c3cf14b3c426e16b0046e93efab31f347079a8646a7cd259655de0321657506f06df4ad10c40d423f3c55c07739272941a7adcaf5c51052135b510a394ab5ef88a572fa655664c09e89a825910103d0d16901c25690c4b692f58c53595192b1e98988ebb3b0b912352764ac2c9906e692a6c3777a416cec039cce785bb9d99513748861ce5cb018b6ea0b876197f1ea3b30f85a126a62d03d2f4fc3b9b6b4880b4b40621971d82dfcc4ea946a0e85098fa58ffc67e139f8482a5ec18196e5136318704bd1abc3f334a69719b52589b71b70fb793f6e253775261fe18082f82c8992a4b4ed1f266e9045e1454339c676b258a6d4bfeb114a8a44705cb8426c71da9a21f91ed7c00e4faa7ee25e8d24d439fe9ccc99a503d2fe2bcae2b0194b59917e7afd62072f317fcb9a05df99b3491a0a45a7a2cacd3b62637ac17b7a16ccf3ca7c112f92c9ffec72a293b7a0f77e7eeab876747b206628fcaaad9a033a55255e6c1d2d42543e415968f1debba87f10a6d3503fc0e7533d829f5d9ddf6d242c3e1e69c9834de11ddd865db123d213ad578258e283e93872ce163d5f62ffd88206bd522f16e2bbd0f83c53f8df49d436b7bf36eed442cfaa8a837a1ad9055439e6da7d230cb5955325feb708fff9fd931fe3c2eb92980d3071bf7fba571226f70526273a5c3eab6fef3604a722d75883d28aac55c8a7ffac8acd47ef2d0ec1618832e7eb77fa0716d4795970a6a7d994f0f4510b55208a17ac9f1ac814ab903ba28f5b28c50bbc236417d8d1087f960eae1f26e3c4b1e7c2efc0d9e3d22e4307ea5d8249e81d6addef085b84bca1e29efaed38f6a1516ae15db954319bfb4dd7924f3a656f3a414c02522be6df5ca8b184a21f579b3700cf46300246e997e36da4c4b03f07128086caa8818146412fc10702261066568e1a363b9baabc63ded175b1a24431407ddbc903f197987fbabaa9c0fbb288ad78719f6ccd52de65550f3e4b50256a13c4c4afe81c2aac35023ca7937f6a6c7e5cbcb391436703116835dff9bd89fba134b06a72ebf6bec3fa318d146aeaf31e37402e941923240d3bf84e98cd2ab77af6f0c6fb0512d33e2334825d0ba0e690ed17f84fd57cf2c09df556ef6acb41dca207b9972bcd8c6b687fb2e5ee146fefb997c2e924d7b620632523114a42d3ad8771b3612b680b29f1d94cf88935b3f2cf34149c4333b4ad4a9f9650a7d62f884ccfa3f8aa5d7125b4ab5ff8abce0b33cb6d2ac3028182f25bbd1d836ed740ca378a96d869bc21702c6dc031aaac79401fecb6a556848d0420757371c942e9925ee27c016cabb6779f79fc7fb335900319c932b3c2f9cb4130603e5f858c792011b37e8f060dcc799b7f4d7dd8acf8c901701d0370c2cbaa6b7f68858bcb773ffed44553aad9e5cb006f20e5f9cb6f98c18a9693426b85bc63cd59ce028f40170f5b7dff6f6307866f40135db5632b7a10232cf7a4e00c3581ff24e13eb6fb076b81b9a3885d0913c7ad3257e666b6e4a93871769747bc5686ef2c7278b85577786e8956e3549d5602313350a8538419965e3532273e075b6e0b2773570778cc90e37b56983d2172bc2f467a79996d95b95c3592a91f1d29f8d2006cfc3bc19ce6262ae88c81d7b80573fda4cbfd9ec2708d44b907cbcc6ca3f940a0ff9c03d994a0db6f74fefe91513b191bb68614541da803bdde959d614be89ede6c061c1a4dae6a4c3a0bf026fdde8d326b2b210af4c65a06862cdeccc5643d880a672a959a6321d612a87fae95b98646334c592b6e8de4c6cdfbdc426fe5bfcca731e7a799ffa0e4dca9f722d00b036dbddf5ec37fd7e2a8d58be1c19ed6b45d5ad4d0807126319072c16fdf74111b4837882c82229a16e2ac526fe624813ddc3777324eb8f6a6bd66daec37d5adb1500b7e3644ea8db9606bbaa76d3aea13f0a6cd38ca9e976fc4f76d238b0ba8d06cdb8fed45936c6f35ee238187297172ae0f5d4d68298f309a2bb3b40927bbe3ee21f33199f75a23f59bd4dec0501cadb909268827e0d0893dadc0cadbdead59f834f393fe2c6ade434391f796e8eb2a2c184b94e094382ddef712b434f648182bb8726f229ea33fd7400e02b352ce8e4c9a7e632bcb450ce702a3e6e13f50d48c40ee171e95c543dfb318a33372ed389b0fca2eed6ec6e7747e7b6e20ce2d3356873369027034cb116930fad316d0e6a9d18f4b0c6b5d63d5d21853f716620e29508ef103133d21fd2e002d93b67501365f4e713b9d61fc8d8a1d10f31bec978be139e8f724d614fc6eff03454fb77406e150d8571ae574fd3b1f8d19d8e5d9f9d5ff34a81e0d50a65bb4b47e592ac0af28e0abc1fe31e2a6a40499fff2067f94058</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MLLM Papers Review</title>
      <link href="/2025/01/08/mllm-papers-review/"/>
      <url>/2025/01/08/mllm-papers-review/</url>
      
        <content type="html"><![CDATA[<h1 id="MLLM-Papers-Review"><a href="#MLLM-Papers-Review" class="headerlink" title="MLLM Papers Review"></a>MLLM Papers Review</h1><h2 id="视频理解"><a href="#视频理解" class="headerlink" title="视频理解"></a>视频理解</h2><h3 id="MVBench"><a href="#MVBench" class="headerlink" title="MVBench"></a>MVBench</h3><p><strong>[CVPR2024 Highlight] MVBench: A Comprehensive Multi-modal Video Understanding Benchmark</strong></p><ul><li>提出了<strong>MVBench</strong>，一个全新的多模态视频理解基准测试，由20项单帧无法有效解决的视频任务组成，用于全面评测现有多模态模型的视频理解能力。<ul><li>在时间任务定义的指导下，为每个任务收集和标注视频。</li><li>选择11个高质量视频annotation数据集，根据任务定义的约束，让GPT为视频<strong>自动生成3-5个问题</strong>并选择其一，答案设计策略分为（1）<strong>模板定义</strong>（如移动方向相关，只限制在前后左右等）；（2）让GPT自己根据任务+annotation<strong>生成</strong>答案。</li><li>GPT问答的生成设计了system prompt和answer prompt。</li></ul></li><li>提出了更强大的基线模型<strong>VideoChat2</strong>，其不仅在MVBench上取得<strong>15个</strong>任务的领先，更在流行的<strong>视频问答、对话、推理</strong>数据集上取得有竞争力的性能。</li></ul><img src="/2025/01/08/mllm-papers-review/image-20250108154042622.png" alt="image-20250108154042622" style="zoom: 67%;"><p><strong>VideoChat2渐进式跨模态训练范式</strong></p><p><strong>阶段1：视觉-语言对齐</strong></p><ul><li>视觉编码器：UMT-L，与BLIP2对比具有更强大的<strong>时空表示学习</strong>能力。</li><li>QFormer：BLIP2训练的三种损失函数：视觉文本对比学习（VTC）、视觉文本匹配（VTM）和基于视觉的文本生成（VTG）</li><li>数据集：CC3M和CC12M的15M图像字幕，WebVid-10M的10M视频字幕。</li><li>目的：对齐UMT-L和QFormer，对齐图像和对应caption，压缩视觉输入。</li></ul><p><strong>阶段2：视觉-语言连接</strong></p><ul><li>LLM：mistral/vicuna/phi</li><li>数据集：除了阶段1以外，进一步引入了2M图像caption（COCO、Visual Genome和SBU）和10M视频caption（InternVid）</li><li>目的：对齐UMT-L、QFormer和LLM，将投影的视觉标记与文本caption对齐。</li></ul><p><strong>阶段3：指令微调</strong></p><p>使用本文生成的指令微调数据进行微调。在冻结的LLM上进行lora低轶微调，通过VTG损失与视觉编码器和QFormer一起调整。此外，借鉴InstructBLIP，<strong>作者在QFormer中也插入了instruction</strong>，用于提取与指令相关的视觉token作为LLM的输入。</p><h3 id="TimeChat"><a href="#TimeChat" class="headerlink" title="TimeChat"></a>TimeChat</h3><p><strong>[CVPR2024] TimeChat: A Time-sensitive Multimodal Large Language Model for Long Video Understanding</strong></p><ul><li><p>一种时间敏感的MLLM，用于长视频理解和准确的<strong>时间定位</strong>。</p><ul><li>两个关键架构：（1）<strong>时间戳感知帧编码器</strong>，可以将视觉内容与每个帧的时间戳绑定；（2）<strong>滑动视频 Q-Former</strong>，生成不同长度的视频token序列，以适应不同时长的视频。</li></ul></li><li><p>指令微调数据集，涉及不同的<strong>时间戳相关的用户指令</strong>，包含 6 个任务和总共 125K 个实例。</p></li></ul><img src="/2025/01/08/mllm-papers-review/image-20250108165902854.png" alt="image-20250108165902854" style="zoom: 50%;"><p><strong>时间戳感知帧编码器</strong></p><ul><li>视觉编码器：ViT-G/14 from EVA-CLIP。</li><li>QFormer：对齐图像和文本标记。通过输入文本“This frame is sampled at 2s.”，把时间戳信息混合进去。压缩图像帧token。</li></ul><p><strong>滑动视频 Q-Former</strong></p><ul><li><p>帧编码器提取帧特征，各帧独立编码，没有建模<strong>帧间时间信息</strong>。–&gt;引入Q-Former滑窗，在<strong>时间维度上增强特征融合</strong>。</p></li><li><p>设计了一个长度为Lw的滑动窗口，并在每个窗口内<strong>利用视频Q-Former从Lw帧中提取Nv长度的视频token</strong>。（<strong>滑窗Lw，步长S，Q-former查询向量数Nv</strong>）最终可以将输入的视频表示为（T /S）×Nv的视频token。</p><ul><li>通俗来说，就是对所有独立的帧token，成组构成patch，然后对token组再做一次自注意力，把帧patch压缩到单一查询向量Nv。</li></ul></li><li><p>然后做线性映射使tokens的特征维度符合LLM的输入特征维度需求。</p></li></ul><p><strong>指令微调</strong></p><ul><li>TimeIT包含了6个与时间戳相关的视频任务，即：(1) 视频说明字幕生成，(2) 视频时间定位，(3) 步骤定位和文字生成，(4) 视频摘要，(5) 视频亮点检测，以及 (6) 转录语音生成。</li></ul><h3 id="ShareGPT4Video"><a href="#ShareGPT4Video" class="headerlink" title="ShareGPT4Video"></a>ShareGPT4Video</h3><p><strong>[NeurIPS 2024] ShareGPT4Video: Improving Video Understanding and Generation with Better Captions</strong></p><ul><li><p><strong>ShareGPT4Video</strong>，包含4万个GPT4V标注的密集视频字幕</p><ul><li>数据过滤：将两分钟内的视频作为候选。使用Panda学生模型生成单句caption，bert编码计算相似度，选择有差异的加入候选集。</li><li>关键帧抽取：clip抽取帧特征，计算相似度，差异大的加入候选集。</li><li>字幕生成：差分滑动窗口pipeline。每次输入到图像多模态模型的内容包括当前关键帧，前一关键帧及其差分字幕。</li></ul></li><li><p><strong>ShareCaptioner-Video</strong>，使用收集的视频字幕数据对<strong>IXC2-4KHD</strong> 进行微调得到的<strong>任意视频标注模型</strong>，由其标注了480万个高质量美学视频。</p></li><li><p><strong>ShareGPT4Video-8B</strong>，一个简单却卓越的LVLM，在三个前沿视频基准测试中达到了最先进（SOTA）性能。</p></li></ul><img src="/2025/01/08/mllm-papers-review/image-20250109151719552.png" alt="image-20250109151719552" style="zoom:67%;"><h3 id="MovieChat"><a href="#MovieChat" class="headerlink" title="MovieChat"></a>MovieChat</h3><p><strong>[CVPR2024] MovieChat: From Dense Token to Sparse Memory for Long Video Understanding</strong></p><ul><li><p>提出了一种有效的内存管理机制，以降低计算复杂度和内存成本，同时增强长期记忆。</p></li><li><p>发布了第一个带有手动注释的长视频理解基准MovieChat-1K。</p></li></ul><img src="/2025/01/08/mllm-papers-review/image-20250109152914961.png" alt="image-20250109152914961" style="zoom:67%;"><ul><li><p>视觉特征提取：EVA-CLIP + QFormer</p></li><li><p>滑动窗口将视频分割成多个片段，每个片段包含 C 帧</p></li><li><p><strong>短期记忆：</strong>将帧token组成的片段存储在临时固定长度缓冲区中。当固定长度的短期记忆达到其预设限制时，所有token将被弹出并合并到长期记忆中。清空并重新初始化短期存储池。（短期记忆窗口长度16）</p></li><li><p><strong>长期记忆：</strong>对弹出的短期帧两两比较相似度，找到整个S中相似度最大的两帧，加权平均合并，不断循环直到整个短期窗口压缩到仅剩2帧。添加到长期记忆池。</p></li><li><p>由于长期记忆中存储的 token 数量可能超过预训练模型的最大长度位置编码，因此需要对位置编码进行扩展。在 MovieChat 中，采用了 BERT 的扩展位置编码方法，使得位置编码能够适应更长的长期记忆。</p></li></ul><p>推理：全局模式（仅使用长期记忆），断点模式（使用长期记忆+指定的查询时间位置为止的短期记忆+指定位置帧Xi的聚合）</p><h2 id="视频时间定位"><a href="#视频时间定位" class="headerlink" title="视频时间定位"></a>视频时间定位</h2><h3 id="VTimeLLM"><a href="#VTimeLLM" class="headerlink" title="VTimeLLM"></a>VTimeLLM</h3><p><strong>[CVPR] VTimeLLM: Empower LLM to Grasp Video Moments</strong></p><p>挑战：1. 缺少一个<strong>有精确时间范围标注</strong>的大规模的视频数据集；2. 需要设计有效的<strong>时序相关的视频任务</strong>帮助LLM理解多个时刻的内容。</p><p>方案：1：一个视觉编码器和一个视觉适配器来处理输入视频；2. 一个特制的LLM通过三阶段训练策略来同时理解文本和视频内容。</p><img src="/2025/01/08/mllm-papers-review/image-20250109215253199.png" alt="image-20250109215253199" style="zoom:67%;"><ul><li><strong>阶段一：</strong>视觉特征通过图片-文本对训练与LLM在语义空间对齐。<ul><li>视觉编码器：CLIP ViT-L/14。每一帧有cls token的feature和每个patch的feature，直接采用cls token的作为图片特征。</li><li>视觉适配器：一个线性层，对每一帧的v_cls做变换，映射到LLM空间，最后视频由N*d的特征<strong>Z</strong>代表（N为帧数，d为LLM的隐层维度），这里均匀采样100帧。</li></ul></li><li><strong>阶段二：</strong>设计了单论（single-turn）和多轮（multi-turn）的QA任务来使得模型能够感知到时间边界并理解时间边界内事件内容。<ul><li>数据：InternVid-10M-FLT数据集，自动化对视频进行分割和标注。每个视频都包含多个事件及其粗略的时间注释和描述。</li><li>单轮QA（20%）是密集Video Caption，多轮QA（80%）包括片段描述&amp;时序grounding任务。</li><li>作用：让模型具有时序感知的能力，可以定位视频的segmentation。</li><li>训练：只训练LLM的LoRA，别的组件冻住，Prompt里告诉LLM有一百帧。</li></ul></li><li><strong>阶段三：</strong>创造了一个高质量的对话数据集来指令微调。</li></ul><h3 id="UniVTG"><a href="#UniVTG" class="headerlink" title="UniVTG"></a>UniVTG</h3><p>Video Temporal Grounding（VTG）任务目标是根据文本输入（query），在视频中检索一个或多个与文本相对应的片段。根据检索得到的片段长度及标签粒度不同，过往的VTG任务可以分为Moment Retrieval、Highlight Detection和Video Summarization三类。</p><ol><li>MR旨在通过文本查询定位视频中符合的片段；</li><li>HD旨在给视频各部分打分，越符合视频主题的分数越高；</li><li>VS旨在根据或者不根据文本，来得到视频中多个时间点，这些时间点的片段组合在一起能够较好总结视频内容。</li></ol><p>本文实现首个预训练VTG模型UniVTG，<strong>将不同层次的VTG任务标注及模型结构相统一，</strong>以增强模型在不同粒度的VTG任务上的泛化能力。</p><img src="/2025/01/08/mllm-papers-review/image-20250110171959943.png" alt="image-20250110171959943" style="zoom:67%;"><ul><li>从任务和标签的角度，定义了一种统一的范式。将视频分解为多个等长clips序列，每个clip分配3种基础的标签。从而能够进行统一的预训练。<ul><li>foreground indicator（Point-Level）：0/1二值标签，假如是前景则为1，反之为0。</li><li>boundary offsets（Interval-Level）：二维向量，将特定帧clip的时间戳转换到时间边界。**[a,b]对应当前点距离时间段边界的距离。a为距离起始点的距离，b为距离终止点的距离。**</li><li>saliency score（Curve-Level）：是一个[0,1]的连续值，表示当前clip与查询Q的相关性。</li></ul></li><li>数据收集方面，将帧视为视频的原子组成，VTG任务收集目标clip集合。<ul><li>使用CLIP构建具备Curve-Level标注能力的CLIP Teacher。CLIP Teacher标注根据以下步骤构造：（1）利用CLIP编码帧特征，计算预设语料库concept池文本特征与视频间相似度；（2）选取top-5 concept作为query，对应相似度曲线作为saliency score；（3）将相似度以0.05的间隔进行离散化，并取最大值作为interval。有了interval就能相应生成point。</li></ul></li><li>从模型的角度，提出了一个统一的框架。<ul><li>Cross-modal alignment路径用于输出saliency score，由于saliency代表query和视频之间的相关程度，模型在对query进行注意力池化得到句特征后，直接计算句-视频特征间相似度作为saliency score。该路径采用对比学习损失优化编码过程：同视频内，负样例为相对于正样例clip具有更低saliency的clip；不同视频，负样例为其他视频的query。</li><li>Cross-modal interaction路径用于输出foreground indicator和boundary offsets，其利用注意力建模连接后的query-视频特征，输入卷积层进行预测，损失为分类（indicator）及重叠区间（offsets）损失。</li></ul></li><li>从预训练的角度，利用统一任务和统一框架，进行了大规模的预训练。</li></ul><img src="/2025/01/08/mllm-papers-review/image-20250110180441782.png" alt="image-20250110180441782" style="zoom:67%;"><h3 id="TFVTG"><a href="#TFVTG" class="headerlink" title="TFVTG"></a>TFVTG</h3><p><strong>（ECCV2024）Training-free Video Temporal Grounding using Large-scale Pre-trained Models</strong></p><p>大多数现有的vlm都是通过图像-文本对或视频剪辑-文本对进行训练的，在这种训练范式中，模型的主要目标是将最具区别性的视觉线索与其相应的文本描述联系起来。这使得它很难做到：</p><ul><li>理解同一视频中多个事件的关系，区分<strong>时间界限</strong>；</li><li>对视频中<strong>事件的变换</strong>敏感（从一个事件到另一个事件的动态转变）。</li></ul><p>本文方案：</p><ul><li>基于prompt让LLM将原始查询分成若干子事件，并分析这些事件之间的时间顺序和关系。<ul><li>推理子事件，确定顺序及关系，为事件提供描述。</li></ul></li><li>将一个子事件分为动态过渡和静态状态部分，并提出了使用VLM的动态和静态评分函数，以更好地评估事件和描述之间的相关性。<ul><li>对于动态部分，测量相似度变化率；对于静态部分，测量内部和外部的比较相似度。</li></ul></li><li>对于LLM提供的子事件描述，利用VLM定位最相关的k个proposal。若子事件同时发生，取定位结果交集；若顺序发生，则取并集，得到最终预测。</li></ul><img src="/2025/01/08/mllm-papers-review/image-20250111212738890.png" alt="image-20250111212738890" style="zoom:67%;"><p>选用 BLIP - 2 Q - Former 作为 VLM 定位器。计算文本与视觉特征的余弦相似度来衡量子事件描述与视频帧的相关性</p><ul><li><strong>动态评分</strong>：考虑到视频的连续性，在目标片段的动态部分，视频内容从一个事件过渡到查询所描述的目标事件，<strong>视频帧与查询的相关性应快速提升。</strong>其特征是在静态段内具有较高的平均视频文本相似性，同时在其之外保持较低的平均相似性。</li><li>为消除视频抖动影响，先<strong>对相似度S应用高斯滤波</strong>$\S: \hat S = G(S)$ 再计算相似度差值。$\hat S: D_i = \hat S_i − \hat S_{i-1}$<br>  对于从第i帧开始到第k帧结束的proposal，<strong>当其中所有的差值超过特定阈值时，将该proposal内的差值求和得到动态分数</strong>。<ul><li>也就是先高斯滤波平滑一下余弦相似度，再找相似度变化陡峭的位置判定其可能是事件转换的开端。（可靠性存疑</li></ul></li></ul><img src="/2025/01/08/mllm-papers-review/image-20250111223418627.png" alt="image-20250111223418627" style="zoom:67%;"><ul><li><strong>静态评分</strong>：受 SPL 启发，在静态部分，要求给定查询的最相关事件需满足<strong>事件内视频与查询相关性高，事件外相关性低。</strong>对于从第k帧开始到第j帧结束的proposal，通过计算<strong>proposal内平均相似度与proposal外平均相似度的差值作为静态分数</strong>。</li></ul><img src="/2025/01/08/mllm-papers-review/image-20250111223733515.png" alt="image-20250111223733515" style="zoom:67%;"><ul><li><strong>定位结果选取</strong>：对于每个proposal (i, j)，考虑到不同事件过渡段长度不一，<strong>枚举所有可能的过渡结束时间戳k</strong>，将proposal划分为动态部分(i, k)和静态部分(k, j)，计算动态分数与静态分数之和，并选取最大值作为该proposal的分数。最终，选取分数最高的top-k个proposal作为 VLM 定位器的定位结果。</li></ul><p>预测过滤与整合：</p><ul><li><strong>枚举预测组合</strong>：VLM 定位器针对每个子事件描述返回前 k 个预测结果。假设有 m 个子事件，通过枚举每个子事件的一个预测结果，总共会产生$k^m$种组合。</li><li><strong>顺序约束过滤</strong>：依据 LLM 分析得到的子事件发生顺序，对上述组合进行过滤。若 LLM 判断子事件Pi应在Pj之前发生，但在某组合中Pi的开始时间晚于Pj的结束时间，则该组合不符合顺序逻辑，将被舍弃。</li><li><strong>分数计算与结果整合</strong>：过滤后，计算每个组合的总分，该分数为 VLM 定位器为该组合中各子事件预测返回的最终分数之和。然后，选取总分最高的组合。对于子事件关系，若 LLM 判定子事件同时发生，将该组合中各子事件的预测取交集作为最终预测；若子事件顺序发生，则取并集作为最终预测。</li></ul><h2 id="视频异常检测"><a href="#视频异常检测" class="headerlink" title="视频异常检测"></a>视频异常检测</h2><h3 id="Holmes-VAD"><a href="#Holmes-VAD" class="headerlink" title="Holmes-VAD"></a>Holmes-VAD</h3><h3 id="LAVAD"><a href="#LAVAD" class="headerlink" title="LAVAD"></a>LAVAD</h3><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h3 id="Surveillance-DB"><a href="#Surveillance-DB" class="headerlink" title="Surveillance DB"></a>Surveillance DB</h3><p><strong>Towards Surveillance Video-and-Language Understanding: New Dataset, Baselines, and Challenges</strong></p><p>监控视频对公共安全至关重要，但<strong>现有监控视频任务局限于预定义异常事件的检测与分类，缺乏语义理解能力</strong>。多模态视频数据集虽有发展，但面向监控视频的多模态学习研究不足，原因在于现有监控数据集缺少句子级语言注释，且监控视频特性增加学习难度。为此，文章提出拓展现有监控视频数据集至多模态场景，构建了 UCA 数据集。</p><img src="/2025/01/08/mllm-papers-review/fig-visual.jpg" alt="Abstract Image" style="zoom: 50%;"><ul><li><p>提出了监控视频与语言理解（VALU）这一新的研究方向，并构建了首个多模态监控视频数据集。</p><ul><li>新标注的数据集UCA（UCF-Crime注释）包含23,542个句子，平均长度为20个单词，标注的视频长达110.7小时。</li><li>包含细粒度的注释和事件描述；包含事件的时间戳和活动的描述。</li><li>UCA可以支持多种多模态理解任务，如时间定位(TSGV)，视频字幕(VC)，密集视频字幕生成(DVC)，多模态异常检测(MAD)。</li></ul></li><li><p>在数据集上对四个多模态任务的前沿模型进行了基准测试，这些结果为监控 VALU 提供了新的基线。</p></li><li><p>在MAD实验中提供基本的监控视频字幕模型作为即插即用模块。结果表明，多模态监控学习可以提高异常检测的性能。</p></li></ul><p><strong>数据集构造：</strong>从 UCF - Crime 中过滤低质量视频，得到 1854 个视频组成 UCA。<strong>标注时详细描述事件并记录起止时间，标注间隔 0.1 秒。</strong>完成 23542 条句子级标注。UCA 按视频长度和原始类别分为训练、验证和测试集，涵盖 13 种异常。标注视频总时长 110.7 小时，事件时长多在 5 - 10 秒，平均视频时长 236.8 秒，平均事件标注时长 16.9 秒。平均注释词数约 20 个，名词、动词、形容词比例约为 2:2:1。</p><h2 id="视频监控相关"><a href="#视频监控相关" class="headerlink" title="视频监控相关"></a>视频监控相关</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_63950428/article/details/144700425">【CVPR论文复现】VTimeLLM: Empower LLM to Grasp Video Moments-CSDN博客</a></p><p><a href="https://blog.kamino.link/2024/04/13/UniVTG/">论文笔记 UniVTG：Towards Unified Video-Language Temporal Grounding - Kamino’s Blog</a></p><p><a href="https://blog.csdn.net/wjjc1017/article/details/137606677">大语言模型在视频理解中的应用综述 Video Understanding with Large Language Models: A Survey_videoagent: long-form video understanding with lar-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MLLM </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MLLM Dataset&amp;Code</title>
      <link href="/2024/12/10/mllm-code/"/>
      <url>/2024/12/10/mllm-code/</url>
      
        <content type="html"><![CDATA[<h1 id="MLLM-Dataset-Code"><a href="#MLLM-Dataset-Code" class="headerlink" title="MLLM Dataset&amp;Code"></a>MLLM Dataset&amp;Code</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h3 id="CC3M"><a href="#CC3M" class="headerlink" title="CC3M"></a>CC3M</h3><p>图像caption数据集（共 3318333 张图像），每张图配一个单句字幕。</p><p>huggingface<strong>已处理的版本</strong>（<a href="https://huggingface.co/datasets/pixparse/cc3m-wds/tree/main">pixparse/cc3m-wds at main</a>），使用：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> datasets <span class="token keyword">import</span> load_datasetds <span class="token operator">=</span> load_dataset<span class="token punctuation">(</span><span class="token string">"pixparse/cc3m-wds"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>自行处理的版本</strong>（原始tsv文件：<a href="https://ai.google.com/research/ConceptualCaptions/download">Conceptual Captions</a>）</p><p>先为tsv添加列名<code>sed -i '1s/^/caption\turl\n/' cc3m.tsv</code></p><p>然后解析，脚本（<a href="https://github.com/rom1504/img2dataset/blob/main/dataset_examples/cc3m.md">img2dataset/dataset_examples/cc3m.md at main · rom1504/img2dataset</a>）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">img2dataset <span class="token parameter variable">--url_list</span> cc3m.tsv <span class="token parameter variable">--input_format</span> <span class="token string">"tsv"</span><span class="token punctuation">\</span>         <span class="token parameter variable">--url_col</span> <span class="token string">"url"</span> <span class="token parameter variable">--caption_col</span> <span class="token string">"caption"</span> <span class="token parameter variable">--output_format</span> webdataset<span class="token punctuation">\</span>           <span class="token parameter variable">--output_folder</span> cc3m <span class="token parameter variable">--processes_count</span> <span class="token number">16</span> <span class="token parameter variable">--thread_count</span> <span class="token number">64</span> <span class="token parameter variable">--image_size</span> <span class="token number">256</span><span class="token punctuation">\</span>             <span class="token parameter variable">--enable_wandb</span> True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>caption格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"hard rock artist of hard rock artist performs"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://media.gettyimages.com/photos/lead-singer-steve-perry-of-rock-band-journey-performs-at-the-rosemont-picture-id832243484?s=612x612"</span><span class="token punctuation">,</span>    <span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"000000001"</span><span class="token punctuation">,</span>    <span class="token property">"status"</span><span class="token operator">:</span> <span class="token string">"success"</span><span class="token punctuation">,</span>    <span class="token property">"error_message"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>    <span class="token property">"width"</span><span class="token operator">:</span> <span class="token number">415</span><span class="token punctuation">,</span>    <span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">612</span><span class="token punctuation">,</span>    <span class="token property">"exif"</span><span class="token operator">:</span> <span class="token string">"{\"Image ImageDescription\": \"Lead singer Steve Perry of rock band Journey performs at the Rosemont Horizon in Rosemont, Illinois, June 10, 1983. (Photo by Paul Natkin/Getty Images)\", \"Image Copyright\": \"2017 Paul Natkin\"}"</span><span class="token punctuation">,</span>    <span class="token property">"original_width"</span><span class="token operator">:</span> <span class="token number">415</span><span class="token punctuation">,</span>    <span class="token property">"original_height"</span><span class="token operator">:</span> <span class="token number">612</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据集目前放在<code>Ask-Anything/video_chat2/annotation/videos_images/cc3m</code>路径下。</p><h3 id="WebVid-10M"><a href="#WebVid-10M" class="headerlink" title="WebVid-10M"></a>WebVid-10M</h3><p>视频caption，缺点是<strong>有水印</strong>。论文使用基本都会做预处理。</p><p>CSV文件：</p><ul><li>huggingface：<a href="https://huggingface.co/datasets/TempoFunk/webvid-10M">TempoFunk/webvid-10M · Datasets at Hugging Face</a></li><li>HyperAI：<a href="https://hyper.ai/cn/datasets/17289">WebVid 大型短视频数据集 / 数据集 / HyperAI超神经 | HyperAI超神经</a></li></ul><p>视频数据下载（很多因为网络问题下不下来）：<a href="https://github.com/iejMac/video2dataset/blob/main/dataset_examples/WebVid.md">video2dataset/dataset_examples/WebVid.md at main · iejMac/video2dataset</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">wget</span> <span class="token parameter variable">-nc</span> http://www.robots.ox.ac.uk/~maxbain/webvid/results_10M_train.csvvideo2dataset <span class="token parameter variable">--url_list</span><span class="token operator">=</span><span class="token string">"results_10M_train.csv"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">--input_format</span><span class="token operator">=</span><span class="token string">"csv"</span> <span class="token punctuation">\</span>        --output-format<span class="token operator">=</span><span class="token string">"webdataset"</span> <span class="token punctuation">\</span><span class="token parameter variable">--output_folder</span><span class="token operator">=</span><span class="token string">"dataset"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">--url_col</span><span class="token operator">=</span><span class="token string">"contentUrl"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">--caption_col</span><span class="token operator">=</span><span class="token string">"name"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">--save_additional_columns</span><span class="token operator">=</span><span class="token string">'[videoid,page_idx,page_dir,duration]'</span> <span class="token punctuation">\</span>        <span class="token parameter variable">--enable_wandb</span><span class="token operator">=</span>True <span class="token punctuation">\</span><span class="token parameter variable">--config</span><span class="token operator">=</span><span class="token string">"path/to/config.yaml"</span> <span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>caption格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"videoid"</span><span class="token operator">:</span> <span class="token number">1051729318</span><span class="token punctuation">,</span>    <span class="token property">"page_dir"</span><span class="token operator">:</span> <span class="token string">"095551_095600"</span><span class="token punctuation">,</span>    <span class="token property">"duration"</span><span class="token operator">:</span> <span class="token string">"PT00H00M09S"</span><span class="token punctuation">,</span>    <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"Mount saint helens, washington - the stunning scenery of a rocky mountains during golden hours - wide shot"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://ak.picdn.net/shutterstock/videos/1051729318/preview/stock-footage-mount-saint-helens-washington-the-stunning-scenery-of-a-rocky-mountains-during-golden-hours.mp4"</span><span class="token punctuation">,</span>    <span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"00000034"</span><span class="token punctuation">,</span>    <span class="token property">"status"</span><span class="token operator">:</span> <span class="token string">"success"</span><span class="token punctuation">,</span>    <span class="token property">"error_message"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>    <span class="token property">"yt_meta_dict"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MSR-VTT"><a href="#MSR-VTT" class="headerlink" title="MSR-VTT"></a>MSR-VTT</h3><p>MSR-VTT是一个通用的视频字幕数据集，包括10000个视频片段，每个视频剪辑持续约15秒。标准情况下通常使用6153个片段进行训练，497个片段用于验证，2090个片段用于测试。（压缩包6g）</p><p>数据集：<a href="https://github.com/yangbang18/CARE/blob/master/README_DATA.md">CARE/README_DATA.md at master · yangbang18/CARE</a></p><p>下载： <a href="https://github.com/jpthu17/EMCL?tab=readme-ov-file">NeurIPS 2022 Spotlight] Expectation-Maximization Contrastive Learning for Compact Video-and-Language Representations</a>（这个版本提供了csv，但标注json是category不是caption，服务器的caption忘了从哪下载的了）</p><p>caption格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"video9770.mp4"</span><span class="token punctuation">,</span> <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"a person is connecting something to system"</span><span class="token punctuation">,</span> <span class="token property">"duration"</span><span class="token operator">:</span> <span class="token number">10.8</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"video9771.mp4"</span><span class="token punctuation">,</span> <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"a little girl does gymnastics"</span><span class="token punctuation">,</span> <span class="token property">"duration"</span><span class="token operator">:</span> <span class="token number">13.78</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="COCO"><a href="#COCO" class="headerlink" title="COCO"></a>COCO</h3><ul><li>COCO数据集包含20万个图像；</li><li>80个类别中有超过50万个目标标注,它是最广泛公开的目标检测数据库；</li></ul><p>下载：<a href="https://blog.csdn.net/qq_41847324/article/details/86224628">COCO数据集的下载、介绍及如何使用（数据载入及数据增广，含代码）_coco数据集下载-CSDN博客</a></p><p>数据路径：D:\东南\智慧城市\数据集</p><p>标注数据格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"info"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"COCO 2017 Dataset"</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://cocodataset.org"</span><span class="token punctuation">,</span><span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0"</span><span class="token punctuation">,</span><span class="token property">"year"</span><span class="token operator">:</span> <span class="token number">2017</span><span class="token punctuation">,</span><span class="token property">"contributor"</span><span class="token operator">:</span> <span class="token string">"COCO Consortium"</span><span class="token punctuation">,</span><span class="token property">"date_created"</span><span class="token operator">:</span> <span class="token string">"2017/09/01"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token property">"licenses"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://creativecommons.org/licenses/by-nc-sa/2.0/"</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Attribution-NonCommercial-ShareAlike License"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://creativecommons.org/licenses/by-nc/2.0/"</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Attribution-NonCommercial License"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>…………<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"images"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"license"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token property">"file_name"</span><span class="token operator">:</span> <span class="token string">"000000391895.jpg"</span><span class="token punctuation">,</span><span class="token property">"coco_url"</span><span class="token operator">:</span> <span class="token string">"http://images.cocodataset.org/train2017/000000391895.jpg"</span><span class="token punctuation">,</span><span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">360</span><span class="token punctuation">,</span><span class="token property">"width"</span><span class="token operator">:</span> <span class="token number">640</span><span class="token punctuation">,</span><span class="token property">"date_captured"</span><span class="token operator">:</span> <span class="token string">"2013-11-14 11:18:45"</span><span class="token punctuation">,</span><span class="token property">"flickr_url"</span><span class="token operator">:</span> <span class="token string">"http://farm9.staticflickr.com/8186/8119368305_4e622c8349_z.jpg"</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">391895</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token property">"license"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token property">"file_name"</span><span class="token operator">:</span> <span class="token string">"000000522418.jpg"</span><span class="token punctuation">,</span><span class="token property">"coco_url"</span><span class="token operator">:</span> <span class="token string">"http://images.cocodataset.org/train2017/000000522418.jpg"</span><span class="token punctuation">,</span><span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">480</span><span class="token punctuation">,</span><span class="token property">"width"</span><span class="token operator">:</span> <span class="token number">640</span><span class="token punctuation">,</span><span class="token property">"date_captured"</span><span class="token operator">:</span> <span class="token string">"2013-11-14 11:38:44"</span><span class="token punctuation">,</span><span class="token property">"flickr_url"</span><span class="token operator">:</span> <span class="token string">"http://farm1.staticflickr.com/1/127244861_ab0c0381e7_z.jpg"</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">522418</span><span class="token punctuation">}</span><span class="token punctuation">,</span>…………<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"annotations"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token number">203564</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">37</span><span class="token punctuation">,</span><span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"A bicycle replica with a clock as the front wheel."</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token number">322141</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">49</span><span class="token punctuation">,</span><span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"A room with blue walls and a white sink and door."</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token number">16977</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">89</span><span class="token punctuation">,</span><span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"A car that seems to be parked illegally behind a legally parked car"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>…………<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="InternVID"><a href="#InternVID" class="headerlink" title="InternVID"></a>InternVID</h3><p>github：<a href="https://github.com/OpenGVLab/InternVideo/blob/main/Data/InternVid/README_CN.md">InternVideo/Data/InternVid/README_CN.md at main · OpenGVLab/InternVideo</a></p><p>数据路径：<a href="https://opendatalab.com/shepshep/InternVid">数据集-OpenDataLab</a></p><p>InternVid是一个大规模的以视频为中心的多模态数据集，可用于学习强大且可迁移的视频-文本表示，用于多模态理解和生成。InternVid数据集包含超过700万个视频，总时长近76万小时，共有2.34亿个视频片段，伴随着总计41亿个单词的详细描述。</p><p>作为本次发布的一部分，我们提供了数据集的一个子集InternVid-10M-FLT，包含<a href="https://opendatalab.com/datasets/#">1000万个视频片段</a>。相关视频对应的Youtube ID和对应的文本描述详见caption.jsonl,对应的处理后的视频片段下载详见<a href="https://opendatalab.com/datasets/#">链接</a>,另外还包括了使用<a href="https://opendatalab.com/datasets/#">UMT</a>计算对应视频片段和文本的相关度UMT-SIM（已归一化*）和美学评分Aesthetic_Score（使用LAION<a href="https://opendatalab.com/datasets/#">美学评估模型</a>），其对应的示例如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"YoutubeID"</span><span class="token operator">:</span> <span class="token string">"HdYoyzCSWyw"</span><span class="token punctuation">,</span> <span class="token property">"Start_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:03:10.567"</span><span class="token punctuation">,</span> <span class="token property">"End_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:03:11.200"</span><span class="token punctuation">,</span> <span class="token property">"Caption"</span><span class="token operator">:</span> <span class="token string">"woman using a computer mouse and keyboard"</span><span class="token punctuation">,</span> <span class="token property">"Aesthetic_Score"</span><span class="token operator">:</span> <span class="token number">4.58984375</span><span class="token punctuation">,</span> <span class="token property">"UMT_Score"</span><span class="token operator">:</span> <span class="token number">0.39794921875</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"YoutubeID"</span><span class="token operator">:</span> <span class="token string">"qJrOyggIB-w"</span><span class="token punctuation">,</span> <span class="token property">"Start_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:07:33.689"</span><span class="token punctuation">,</span> <span class="token property">"End_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:07:51.085"</span><span class="token punctuation">,</span> <span class="token property">"Caption"</span><span class="token operator">:</span> <span class="token string">"a screen shot of heroes of the storm with people in action"</span><span class="token punctuation">,</span> <span class="token property">"Aesthetic_Score"</span><span class="token operator">:</span> <span class="token number">4.29296875</span><span class="token punctuation">,</span> <span class="token property">"UMT_Score"</span><span class="token operator">:</span> <span class="token number">0.4501953125</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"YoutubeID"</span><span class="token operator">:</span> <span class="token string">"pDq9UzfCtGw"</span><span class="token punctuation">,</span> <span class="token property">"Start_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:08:14.520"</span><span class="token punctuation">,</span> <span class="token property">"End_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:08:37.120"</span><span class="token punctuation">,</span> <span class="token property">"Caption"</span><span class="token operator">:</span> <span class="token string">"in october, 2019, in lviv, there was a conference about the legal information technology"</span><span class="token punctuation">,</span> <span class="token property">"Aesthetic_Score"</span><span class="token operator">:</span> <span class="token number">4.28515625</span><span class="token punctuation">,</span> <span class="token property">"UMT_Score"</span><span class="token operator">:</span> <span class="token number">0.375732421875</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：之前发布的UMT-SIM实际由OpenAI的CLIP-L计算得到。</p><p>pytube数据集下载：<a href="https://blog.csdn.net/qq_43854103/article/details/134884707">InternVid数据集的下载指南-CSDN博客</a></p><p>403 forbidden：<a href="https://github.com/pytube/pytube/issues/1570">it showing streaming data error · Issue #1570 · pytube/pytube</a></p><img src="/2024/12/10/mllm-code/image-20250107151235469.png" alt="image-20250107151235469" style="zoom:67%;"><p>400 bad request：<a href="https://stackoverflow.com/questions/78160027/how-to-solve-http-error-400-bad-request-in-pytube">python - How to solve HTTP Error 400: Bad Request in PyTube? - Stack Overflow</a></p><img src="/2024/12/10/mllm-code/image-20250107151321921.png" alt="image-20250107151321921" style="zoom:67%;"><h2 id="InternLM-XComposer2-4KHD"><a href="#InternLM-XComposer2-4KHD" class="headerlink" title="InternLM-XComposer2-4KHD"></a>InternLM-XComposer2-4KHD</h2><p>IXC2-4KHD结构</p><ul><li>视觉编码器：OpenAI CLIP ViT-L-14-336，添加动态分辨率方案</li><li>projector 层：MLP</li><li>LLM ：为最新的 InternLM2</li><li>预训练：训练Vit，MLP投影和LLM；</li><li>微调：Partial LoRA (P-LoRA)</li></ul><img src="/2024/12/10/mllm-code/image-20241211142115207.png" alt="image-20241211142115207" style="zoom: 67%;"><p>和 llava next 一样，模型输入包括两个视图，具体做法为：</p><ul><li>对于给定的任意一张图片，训练时候需要指定这张图片希望切分为最多为多少个 patch，例如论文说的 HD-9，HD-25 和 HD-55，HD-9 也就是说经过处理后这张图片，这种图片最多(<strong>可以少</strong>)可以切分为 9 个 patch，假设正好可以切分为 9 个 patch，那么可能输出分辨率为 1008×1008, 672×1344, 336×3024，至于到底选择的是那个分辨率则是依据图片宽高比来确定的，算法的目标是<strong>在接近 9 个 patch 情况下，图片后续 padding 的像素最少即可</strong></li><li>假设算出来是 672×1344，那么图片会在先进行保持宽高比情况下 resize，然后 padding 为 672×1344（下面函数到这里为止）</li><li>上述就得到高分辨率图了，将这个 672×1344 图片直接强制 resize 为 336x336 就得到了<strong>全局视图</strong></li><li>为了让模型更容易理解 patch，如上所示，作者在每一行后面加一个可学习的 \n 特殊 token，并且也加了一个可学习的 sp 特殊 token</li><li>由于在 HD 输入下，token 非常多，直接训练肯定会炸了，例如 HD-55，此时的 patch 一共 55+1=56 个，每个 patch 输出 576 个 token，那么就有 32256 个 image token，这就有点夸张了。所以作者简单的进行 token merge了，就是相邻的 4 个 token 合并，将信息转换到通道维度了，<strong>此时最多的 Image token 是 8064 了，虽然也很多，但是至少看起来还行。</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">HD_transform</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> hd_num<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># hd_num 期望切分的最大patch数</span>    width<span class="token punctuation">,</span> height <span class="token operator">=</span> img<span class="token punctuation">.</span>size    <span class="token keyword">if</span> width <span class="token operator">&lt;</span> height<span class="token punctuation">:</span>        width<span class="token punctuation">,</span> height <span class="token operator">=</span> img<span class="token punctuation">.</span>size    ratio <span class="token operator">=</span> <span class="token punctuation">(</span>width <span class="token operator">/</span> height<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ratio<span class="token punctuation">)</span>    <span class="token comment"># 假设某条边扩展为 n 个 patch，此时可以得到在宽高比不变情况下另一条边最多可以扩展为 n/ratio 个 patch</span>    <span class="token comment"># 如果总的 patch 数 (scale*np.ceil(scale/ratio) )接近 hd_num 但是不超过 hd_num，那么就选择这个</span>    scale <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># scale计算某条边扩展到多少patch数</span>    <span class="token keyword">while</span> scale<span class="token operator">*</span>np<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>scale<span class="token operator">/</span>ratio<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> hd_num<span class="token punctuation">:</span>        scale <span class="token operator">+=</span> <span class="token number">1</span>    scale <span class="token operator">-=</span> <span class="token number">1</span>        new_w <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>scale <span class="token operator">*</span> <span class="token number">336</span><span class="token punctuation">)</span><span class="token comment"># 每个patch 336*336</span>    new_h <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>new_w <span class="token operator">/</span> ratio<span class="token punctuation">)</span>    img <span class="token operator">=</span> transforms<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token punctuation">[</span>new_h<span class="token punctuation">,</span> new_w<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span>    <span class="token comment"># 确保能够被 336 整除，周围padding填充</span>    img <span class="token operator">=</span> padding_336<span class="token punctuation">(</span>img<span class="token punctuation">)</span>    <span class="token keyword">return</span> img<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="VideoChat2"><a href="#VideoChat2" class="headerlink" title="VideoChat2"></a>VideoChat2</h2><h2 id="配置记录"><a href="#配置记录" class="headerlink" title="配置记录"></a>配置记录</h2><h3 id="pycharm映射"><a href="#pycharm映射" class="headerlink" title="pycharm映射"></a>pycharm映射</h3><p><img src="/2024/12/10/mllm-code/image-20250103155952566.png" alt="image-20250103155952566" style="zoom: 50%;"><img src="/2024/12/10/mllm-code/image-20250103160038049.png" alt="image-20250103160038049" style="zoom: 67%;"></p><h3 id="依赖版本"><a href="#依赖版本" class="headerlink" title="依赖版本"></a>依赖版本</h3><p>cuda-runtime              12.1.0                        0    nvidia<br>cuda-version              12.4                 hbda6634_3    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>ffmpeg                    6.1.1                h4c62175_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>ffmpeg-python             0.2.0                    pypi_0    pypi<br>fontconfig                2.14.1               h4c34cd2_2    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>freetype                  2.12.1               h4a9f257_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>numpy                     1.23.5           py39hf6e8229_1    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>numpy-base                1.23.5           py39h060ed82_1    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>pandas                    2.0.3            py39h1128e8f_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>peft                      0.4.0                    pypi_0    pypi<br>pillow                    10.0.0                   pypi_0    pypi<br>pip                       24.2             py39h06a4308_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>python                    3.9.20               he870216_1    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>pytorch-cuda              12.1                 ha16c6d3_6    pytorch<br>scipy                     1.13.0                   pypi_0    pypi<br>sentencepiece             0.1.99                   pypi_0    pypi<br>tokenizers                0.15.2                   pypi_0    pypi<br>torch                     1.13.1+cu117             pypi_0    pypi<br>torchaudio                0.13.1+cu117             pypi_0    pypi<br>torchvision               0.14.1+cu117             pypi_0    pypi<br>tqdm                      4.66.1             pyhd8ed1ab_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a><br>transformers              4.37.1                   pypi_0    pypi<br>urllib3                   2.2.3            py39h06a4308_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>wandb                     0.16.6             pyhd8ed1ab_1    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a><br>wheel                     0.44.0           py39h06a4308_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>CC3M数据集：<a href="https://huggingface.co/datasets/pixparse/cc3m-wds/tree/main">pixparse/cc3m-wds at main</a></p><p>WebVid数据集：<a href="https://huggingface.co/datasets/TempoFunk/webvid-10M">TempoFunk/webvid-10M · Datasets at Hugging Face</a></p><p>MSR-VTT数据集：<a href="https://mmaction2.readthedocs.io/zh-cn/dev-1.x/dataset_zoo/msrvtt.html">准备 MSR-VTT 检索/视频问答数据集 — MMAction2 1.2.0 文档</a></p><ul><li><p>下载：<a href="https://github.com/jpthu17/EMCL?tab=readme-ov-file">NeurIPS 2022 Spotlight] Expectation-Maximization Contrastive Learning for Compact Video-and-Language Representations</a></p></li><li><p>对应google云：<a href="https://drive.google.com/drive/folders/1LYVUCPRxpKMRjCSfB_Gz-ugQa88FqDu_">MSRVTT - Google Drive</a></p></li><li><p>这个版本不是服务器用的版本，标注json只有category没有caption</p></li></ul><p>COCO数据集：<a href="https://blog.csdn.net/qq_41185868/article/details/82939959">Dataset之COCO数据集：COCO数据集的简介、下载、使用方法之详细攻略-CSDN博客</a></p><p>InternVID数据集：<a href="https://opendatalab.com/shepshep/InternVid">数据集-OpenDataLab</a></p><p>Video-LLaVA训练：<a href="https://github.com/PKU-YuanGroup/Video-LLaVA/blob/main/TRAIN_AND_VALIDATE.md">Video-LLaVA/TRAIN_AND_VALIDATE.md at main · PKU-YuanGroup/Video-LLaVA</a></p><p>IXC2-4KHD：<a href="https://zhuanlan.zhihu.com/p/692049805">MLLM-算法推荐-2024.4.12] InternLM-XComposer2-4KHD 处理高分辨率有一手 - 知乎</a></p><p>pycharm连接服务器（核心是deployment ssh配置+mapping填对）：<a href="https://blog.csdn.net/qq_42730750/article/details/119249193">Pycharm远程连接服务器进行代码的运行与调试_remote sdk is saved in idesetting-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MLLM </tag>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShareGPT4Video</title>
      <link href="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/"/>
      <url>/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/</url>
      
        <content type="html"><![CDATA[<h1 id="ShareGPT4Video"><a href="#ShareGPT4Video" class="headerlink" title="ShareGPT4Video"></a>ShareGPT4Video</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>论文推出了ShareGPT4Video系列，旨在通过<strong>密集且精确的标注</strong>促进大型视频语言模型（large video-language models, LVLMs）的<strong>视频理解</strong>和文本到视频模型（text-to-video models, T2VMs）的<strong>视频生成</strong>。该系列包括：</p><p>1）<strong>ShareGPT4Video</strong>，包含4万个GPT4V标注的密集视频字幕，这些视频具有不同长度和来源，通过精心设计的数据过滤和标注策略开发。</p><p>2）<strong>ShareCaptioner-Video</strong>，一个高效且能力强大的<strong>任意视频标注模型</strong>，由其标注了480万个高质量美学视频。</p><p>3）<strong>ShareGPT4Video-8B</strong>，一个简单却卓越的LVLM，在三个前沿视频基准测试中达到了最先进（SOTA）性能。</p><p>为了达成上述目标，不考虑不可扩展且成本高昂的人工标注，作者发现使用GPT4V对视频进行标注，采用简单的多帧或帧连接输入策略，会导致<strong>细节不足，生成的字幕不够详细且会出现时间混淆</strong>的结果。针对这一问题，作者认为设计高质量视频标注策略的挑战在于三个方面：<strong>1) 帧间精确的时间变化识别。2) 帧内详细内容描述。3) 任意长度视频的帧数可扩展性。</strong></p><p>为此，论文精心设计了一种<strong>差分视频标注策略</strong>，该策略稳定、可扩展且高效，适用于生成<strong>任意分辨率、宽高比和长度的视频标注</strong>。基于此，论文构建了ShareGPT4Video，包含4万个高质量视频，涵盖广泛类别，其标注涵盖丰富的<strong>世界知识、物体属性、摄像机运动</strong>，以及关键的、详细且精确的<strong>事件时间描述</strong>。基于ShareGPT4Video，论文进一步开发了ShareCaptioner-Video，一个<strong>能够高效生成任意视频高质量标注的优秀标注器。</strong>本文通过它标注了480万个具有美学吸引力的视频，并在<strong>10秒文本到视频生成任务</strong>中验证了其有效性。对于视频理解，论文验证了ShareGPT4Video在几种当前LVLM架构上的有效性，并展示了论文卓越的新大型视频语言模型 ShareGPT4Video-8B。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241203171739454.png" alt="image-20241203171739454" style="zoom:67%;"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>LLM的驱动下，多模态学习中<strong>图文对话</strong>（image-text dialogue）和<strong>文生图</strong>任务（text-to-image generation tasks）已经取得了最新进展。这也激发了向<strong>视频理解</strong>和<strong>生成任务</strong>的转变，允许用户跨视频和语言模式的交互。因此，详细和高保真的视频字幕，连接上述模态，有助于推动该领域的进展。</p><p>尽管视频内容具有丰富的语义和时间信息，但现有数据中视频通常<strong>只配有简短的描述</strong>。这些简短的描述<strong>限制了对视频的深入理解以及视频生成的可控性</strong>。虽然图像-文本对话和文本到图像生成任务中已认识到详细描述的重要性，但在视频理解和生成方面类似的努力仍然不足。</p><p>然而，创建大规模、高质量的视频描述是一项挑战性任务。即使是人类，为长视频生成详细的描述也是<strong>复杂且耗时</strong>的，这阻碍了大规模的标注工作。<strong>当前的开源大规模视觉语言模型（LVLMs）缺乏这种能力，而闭源API尚不支持视频输入。</strong></p><p>另一方面，如果将视频输入<strong>简化为多个帧</strong>，即使是GPT4V也难以提供满意质量的描述。例如，一个直观的想法是向GPT4V提供带有时间戳的多帧视频，并生成描述，但论文发现GPT4V在描述时表现不稳定，有时会<strong>误解帧之间的时间关系</strong>，且<strong>随着视频帧数的增加，其性能进一步下降</strong>。其他解决方案，如将所有帧拼接成一张大图，<strong>对于解决时间问题并无帮助</strong>，且随着帧数的增加，描述的细节会丢失。论文在图11-12中展示了这些问题。</p><p>论文认为，制定有效的视频描述策略的挑战源于三个基本方面：1) <strong>帧间精确的时间变化理解</strong>：时间维度将视频与图像区分开来。不精确的时间描述会显著降低视频描述的质量，并在训练模型时引起混淆。2) <strong>帧内详细内容的描述</strong>：详细描述对于图像与文本模态之间的对齐至关重要，对于视频-文本对齐也同样重要。3) <strong>任意长度视频的帧数可扩展性</strong>：在实际应用中，视频的长度差异很大。理想的描述策略应能适应这种变化，并为任何长度的视频生成适当的描述。</p><p>为此，论文提出了<strong>差分滑动窗口</strong>标注策略 <strong>Differential Sliding-Window Captioning strategy</strong> (DiffSW)，该策略稳定、可扩展且高效，适用于为任意视频生成描述。DiffSW的核心理念是<strong>将  所有帧到描述（all-frames-to-caption）  的任务转化为差分描述任务</strong>。具体而言，本文<strong>为第一帧生成详细字幕</strong>，然后按时间顺序对后续帧应用长度为二的滑动窗口。GPT4V负责基于三个输入（前一帧、其差分字幕和当前帧）识别帧间变化。这包括了照相机运动、对象运动、角色动作和场景转换。获取所有差分字幕后，这些字幕将输入到GPT4生成<strong>整个视频的综合描述</strong>。差分概念使DiffSW能够<strong>集中于帧间的变化</strong>，即<strong>时序变化</strong>。滑动设计确保<strong>了时间顺序的正确性和帧数的不变性</strong>，保证GPT4V不遗漏细节并高效利用API，从而实现稳定、可扩展和高效的字幕质量。此外，差分设计允许通过重用其差分字幕来重新标注带字幕视频的任何子剪辑。</p><p>基于DiffSW，本文构建了<strong>ShareGPT4Video</strong>，包含4万组高质量的视频-字幕对，涵盖广泛类别，由此产生的字幕包含了丰富的世界知识、对象属性、相机运动，以及对事件的详细和精确的时间描述。ShareGPT4Video的视频来自不同来源，采用<strong>基于语义的数据过滤</strong>策略来减轻这些视频之间的内容同质性。然后对视频采用<strong>语义感知的关键帧提取</strong>策略，以减少时间冗余。将DiffSW应用于关键帧，生成高质量的字幕，并通过<strong>层次提示设计</strong>进一步提高了其稳定性和质量。采用<strong>人工质量检查</strong>，以确保视频字幕的质量。</p><p>基于ShareGPT4Video，本文提供了<strong>ShareCaptionor-Video</strong>,，一种特殊的<strong>视频标注器</strong>，能够有效地为广泛的<strong>分辨率、纵横比和持续时间</strong>的视频<strong>生成高质量的字幕</strong>。它能够以较低的成本和令人满意的质量，进一步<strong>扩展高质量的视频字幕数据</strong>，本文作者为480万个视频（总计约3000小时）生成高质量的字幕。</p><p>作者<strong>在视频理解和生成任务中进行了广泛的实验</strong>，以证明高质量的视频字幕数据集和优越的视频标注器的价值。在视频生成方面，在4.8M视频-字幕对上训练的基于DiT的文本到视频模型在生成10秒高分辨率视频-字幕对内容生成的细粒度控制方面表现良好。为了理解视频，ShareGPT4Video通过替换一小部分训练数据，在多个基准测试上为多个当前lvlm带来了一致的性能提高。本文进一步提出了ShareGPT4Video-8B，一个简单而出色的LVLM，在三个先进而全面的视频基准上达到了SOTA的性能。</p><h2 id="ShareGPT4Video数据集"><a href="#ShareGPT4Video数据集" class="headerlink" title="ShareGPT4Video数据集"></a>ShareGPT4Video数据集</h2><p>图2展示了ShareGPT4Video数据集构建的完整pipeline。首先要基于<strong>感官质量与内容复杂性</strong>选择多种不同的视频数据源。随后，使用<strong>基于语义的数据过滤</strong>来防止内容的同质化。然后，应用<strong>语义感知的关键帧提取</strong>来进行<strong>稀疏采样</strong>，以保持显著的语义变化。最后，实现了一个<strong>差分滑动窗口标注策略</strong>，利用GPT-4V来生成<strong>详细</strong>的和<strong>时间上丰富</strong>的描述。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241203225514426.png" alt="image-20241203225514426" style="zoom: 67%;"><h3 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h3><p><strong>数据源选择</strong>：为了服务于视频理解和视频生成任务，论文在收集过程中考虑视频的美学质量和内容复杂性：</p><ul><li>论文首先考虑<strong>Panda-70M</strong>，这是一个从YouTube获取的<strong>高分辨率视频数据集</strong>，包含时长约<strong>一分钟</strong>的片段。这个开放领域来源覆盖了<strong>野生动物、烹饪、体育、新闻与电视节目、游戏与3D渲染</strong>等多样领域。它通常包含<strong>复杂的内容和过渡</strong>，为理解各种现实世界场景提供了坚实基础。</li><li>然而，这些内容和过渡的复杂性<strong>对视频生成领域提出了重大挑战</strong>。为了解决这一问题，论文还从一些用户上传视频网站获取了大量美学上吸引人的视频。这些视频主要由<strong>风景和美学上令人愉悦的人类活动</strong>组成，涉及<strong>较少的过渡和更简单的事件</strong>。</li><li>最后，论文通过选择来自<strong>Ego4D 和BDD100K</strong> 的视频来补充数据集，填补自我中心人类活动和自动驾驶场景中的空白，确保论文的视频来源尽可能多地涵盖现实世界场景。</li></ul><p><strong>基于语义的数据过滤</strong>。尽管论文的字幕生成方法能够支持较长时间的视频，但由于<strong>视频时长与数量之间的权衡</strong>，数据采集主要集中在<strong>短于两分钟</strong>的视频上。</p><ul><li>论文首先从选定的数据源中<strong>过滤掉超过两分钟的视频</strong>，将两分钟内的视频作为候选。随后，论文引入了一种<strong>基于语义的数据过滤</strong>策略，以减少这些候选视频之间的内容同质性，并保持最终视频数据集的多样性。该方法旨在<strong>从候选视频池中选择具有显著主题差异的视频</strong>，以构成论文的最终视频集合。</li><li>具体而言，论文首先使用<strong>Panda-Student</strong> 模型为每个候选视频<strong>生成一个简短的单句字幕</strong>，然后维护一个最终的视频候选池。每当处理一个新的视频V时，使用<strong>Bert-Base-Uncased</strong>语言模型对其相应的<strong>短字幕S进行编码</strong>，以获得CLS标记Pn+1∈R^1×D，它<strong>捕获高级语义表达</strong>。然后我们计算这个CLS标记P^n+1和候选池中的视频CLS标记{P1，P2，…Pn}的<strong>相似度</strong>。只有当一个新视频的<strong>最大相似度低于预定义的阈值时</strong>，该新视频才会被添加到池中。</li><li>论文提供了伪代码，如图14所示。</li></ul><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204115240634.png" alt="image-20241204115240634" style="zoom: 50%;"><h3 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h3><p>视频在时间维度上通常是冗余的，而<strong>关键帧采样</strong>是<strong>紧凑地表示视频</strong>的一般思想。然而，传统的<strong>关键帧提取方法（key-frame extraction methods）</strong>通常难以<strong>确保语义的连贯性</strong>，导致缺少<strong>覆盖关键变化和过渡</strong>的关键帧。因此，本文开发了一种语义感知的关键帧提取方法，它可以在减少时间冗余和保持语义连贯性之间取得平衡。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204151350827.png" alt="image-20241204151350827" style="zoom:67%;"><h4 id="语义感知的关键帧提取"><a href="#语义感知的关键帧提取" class="headerlink" title="语义感知的关键帧提取"></a>语义感知的关键帧提取</h4><p>将V表示为从固定2秒间隔的视频中采样的T帧集，计算关键帧集合V’，<strong>该集合足够稀疏但能全面覆盖视频内事件的演变</strong>。论文将CLIP-Large图像编码器的输出CLS token视为<strong>每个帧的全局语义</strong>，并<strong>移除具有高语义相似性的相邻帧</strong>。在实践中，论文<strong>初始化</strong>关键帧集合V’为<strong>V的第一帧</strong>。对于V中的每个帧，论文<strong>计算其与V’中最新关键帧的语义相似度d</strong> 。如果d低于预定义的阈值，论文将该帧视为关键帧并将其添加到V’中。如果不是，则该帧被作为冗余帧跳过。为了完整性，<strong>V的最后一帧总是被添加到V’中</strong>。论文提供了伪代码，如图15所示。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204152438461.png" alt="image-20241204152438461" style="zoom: 50%;"><h3 id="字幕生成pipeline"><a href="#字幕生成pipeline" class="headerlink" title="字幕生成pipeline"></a>字幕生成pipeline</h3><p>正如第一节引言中提到的，本文发现如果直接将所有帧输入GPT4V，GPT4V难以稳定生成具有正确时序关系的字幕，并且随着帧数的增加，其性能进一步恶化。另一方面，如果论文将所有帧合并成一张大图，随着帧数的增加，GPT4V会丢失更多细节，如图11-12所示。</p><p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204153952314.png" alt="image-20241204153952314" style="zoom:50%;"><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204154030747.png" alt="image-20241204154030747" style="zoom:50%;"></p><h4 id="差分滑动窗口字幕生成"><a href="#差分滑动窗口字幕生成" class="headerlink" title="差分滑动窗口字幕生成"></a>差分滑动窗口字幕生成</h4><p>为此，论文开发了一种差分滑动窗口字幕生成pipeline，用于为各种视频生成高质量的字幕，<strong>并附带详细的时序描述</strong>。</p><p>具体而言，每次输入到图像多模态模型的内容包括<strong>当前关键帧，前一关键帧及其差分字幕</strong>。接着，论文引入了差分prompt，引导GPT4V<strong>关注当前帧与前一帧之间的变化</strong>，如<strong>姿态、位置、摄像机角度</strong>等。此外，将前一帧的差分字幕作为<strong>补充上下文</strong>融入，提高了响应质量并减少了幻觉现象。这是因为<strong>图像嵌入和文本字幕分别提供了图像的显式和隐式表示</strong>。差分字幕不仅增加了额外的上下文，还<strong>整合了来自两帧之前的时序信息</strong>，进一步增强了模型的<strong>时序理解</strong>能力。需要注意的是，对于第一帧，它的差分字幕直接由标准字幕替换。</p><p>最后，论文将所有差分字幕及其相应的时间戳输入到GPT4中。设计了一个特定的<strong>总结prompt</strong>，指导大型语言模型生成具有<strong>精确时序动态和详细空间信息</strong>的高质量视频字幕。在实践中，论文使用<strong>GPT-4-Turbo-04-09</strong>进行所有标注。</p><p>在提示的设计中，作者发现<strong>显式的层次提示设计</strong>有助于GPT4V理解其角色、预期格式和操作边界。这种方法有助于稳定输出的格式，并提高结果的整体质量。</p><h4 id="分层提示设计"><a href="#分层提示设计" class="headerlink" title="分层提示设计"></a>分层提示设计</h4><p>分层提示设计（Hierarchical Prompt Design）帮助多模态模型和语言模型在captioning过程中有效地执行它们的角色。</p><p>图7和图8分别阐述了<strong>差分字幕提示（differential-caption prompt）</strong>和<strong>摘要（总结）提示（summary prompt）</strong>。</p><p>层次化prompt主要由四个组件组成。<strong>角色</strong>（character）部分为模型提供了对它所扮演的角色和它所面临的工作环境的整体感知。<strong>技能</strong>（skills）部分指定了模型需要拥有的技能，确保精确地符合多个要求，而不存在遗漏或混淆。<strong>约束</strong>（constraints）部分澄清了用户<strong>不希望执行的行为，以及在构建输出时要遵循的规则</strong>。<strong>结构化输入</strong>（Structured Input）部分要求用户<strong>根据他们的特定场景进行设置</strong>。</p><p>例如，当指导模型生成差分字幕时，角色部分通知模型它是分析视频帧的专家。技能部分要求模型来描述帧间的目标动作和行为、环境和背景的变化、目标外观属性的变化，以及反映时间变化的摄像机运动。约束部分要求精确的描述，而不是逐项列出它们。在“结构化输入”部分中，输入由帧索引、时间戳、前一帧和它的差分字幕组成。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204170526404.png" alt="image-20241204170526404" style="zoom: 50%;"><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204170617540.png" alt="image-20241204170617540" style="zoom:50%;"><h2 id="ShareCaptioner-Video"><a href="#ShareCaptioner-Video" class="headerlink" title="ShareCaptioner-Video"></a>ShareCaptioner-Video</h2><h3 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h3><p>论文使用收集的视频字幕数据对<strong>IXC2-4KHD</strong> 进行微调，从而得到论文的ShareCaptioner-Video。为了灵活使用，论文对数据进行了重新组织，以支持以下功能：</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204172727478.png" alt="image-20241204172727478" style="zoom:67%;"><ol><li><strong>快速字幕生成</strong>：该模型采用图像网格格式（image-grid format）进行直接字幕生成（direct video captioning），提供了<strong>适用于短视频的快速生成速度</strong>。在实践中，论文<strong>将视频的所有关键帧连接成一个垂直拉长的图像</strong>，并在字幕任务上对模型进行训练。</li><li><strong>滑动字幕生成</strong>：该模型支持以差分滑动窗口格式（differential sliding-window format）进行流式字幕生成，生成<strong>适用于长视频</strong>的高质量字幕。与第2.3节中使用的字幕流程类似，将两个相邻关键帧及前面的字幕作为输入，并训练模型描述它们之间发生的事件。</li><li><strong>片段摘要</strong>：该模型可以快速总结来自ShareGPT4Video或经历了差分滑动窗口字幕生成过程的视频的任何片段，无需重新处理帧。论文将所有差分描述作为输入，输出为视频字幕。</li><li><strong>prompt重述</strong>：模型可以根据用户输入的特定视频生成领域的提示进行重述，确保基于高质量视频字幕数据训练的T2VM<strong>在推理过程中与其训练中保持格式对齐</strong>。在实践中，论文使用GPT-4生成Sora风格的提示，用于论文的密集字幕，并以相反的方式训练re-captioning任务，即  使用生成的prompt作为输入，密集字幕作为训练目标。（这个没懂</li></ol><p>在实践中，作者在一个epoch内对模型进行端到端微调。遵循默认的高分辨率策略，使用“HD-55”用于快速字幕任务，其他的则使用“HD-25”。所有模型组件的学习速率都是一致的，并在前1%的step内从0升温到2.5×10−5。批处理大小设置为1024，且对数据进行统一采样。</p><h3 id="规模化caption"><a href="#规模化caption" class="headerlink" title="规模化caption"></a>规模化caption</h3><p>为了验证论文的ShareCaptioner-Video在视频字幕生成任务中的有效性，并进一步支持视频生成领域的发展，论文利用它对大量审美吸引人的视频进行了注释。具体来说，论文从三个来源精心收集和处理了480万个视频剪辑，总计约3000个小时，分别是： MixKit，Pexels 和Pixabay。随后，采用ShareCaptioner-Video的滑动字幕生成模式，为这些视频生成高质量的字幕。整个字幕生成过程需要大约4000个H100 GPU小时。图8中提供了一些关于生成的字幕的统计信息。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204212139827.png" alt="image-20241204212139827" style="zoom: 50%;"><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="视频理解"><a href="#视频理解" class="headerlink" title="视频理解"></a>视频理解</h3><h4 id="数据集和基准"><a href="#数据集和基准" class="headerlink" title="数据集和基准"></a>数据集和基准</h4><p>为了全面探索高质量视频字幕数据给LVLMs带来的益处，论文在三个多模态视频基准上对模型进行了全面评估。VideoBench从13个现有数据源（如MSVD-QA，MSRVTT-QA，Activitynet-QA等）中策划了约<strong>15,000个跨10个评估维度的QA对。</strong>MVBench 旨在挑战LVLMs处理视频任务，这些任务不能通过单帧依赖有效解决，其包含了<strong>从11个公共视频测试中派生出的4,000个QA对基准</strong>。TempCompass 特别评估了LVLMs在各种时间方面的微妙性能，如速度、方向和属性变化。它包含<strong>410个视频和7,540个精心收集的指令</strong>，强调时间理解和交互。</p><h4 id="ShareGPT4Video-1"><a href="#ShareGPT4Video-1" class="headerlink" title="ShareGPT4Video"></a>ShareGPT4Video</h4><p><strong>通过ShareGPT4Video提升当前LVLM的性能</strong>。论文验证了ShareGPT4Video收集的高质量视频字幕数据对于提升当前LVLM性能的有效性。为了公平和简化，论文将ShareGPT4Video中与复杂场景相关的28K高质量视频字幕数据（包括Panda-70M 、Ego4D和BDD100K ）整合，<strong>以同等数量替换VideoChatGPT-100K 对话数据中的字幕数据</strong>。然后，论文使用默认的训练设置和超参数训练VideoLLaVA 和LLaMA-VID。如<strong>表1</strong>所示，ShareGPT4Video在不同的LVLM架构和规模上<strong>持续提高了视频与语言模态之间的对齐</strong>。具体而言，集成高质量字幕后，VideoLLaVA-7B在三个全面的多模态视频基准测试上<strong>平均性能提升了1.1</strong>，而LLaMA-VID-7B和LLaMA-VID-13B分别实现了平均2.0和2.3的提升。论文证明高质量的视频字幕数据特别<strong>有助于LVLM在需要复杂时间理解的基准测试上实现显著的性能提升</strong>，例如TempCompass 。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204215938456.png" alt="image-20241204215938456" style="zoom:67%;"><h4 id="ShareGPT4Video-8B"><a href="#ShareGPT4Video-8B" class="headerlink" title="ShareGPT4Video-8B"></a>ShareGPT4Video-8B</h4><p>为了获得最终的ShareGPT4Video-8B模型，论文从LLaVA-Next-8B图像多模态模型开始。与之前的LVLM方法一致，论文遵循lG-VLM策略，<strong>从每个视频中均匀采样16帧，并将这些帧排列成4x4的图像网格，以形成训练和推理的输入</strong>。对于训练数据，论文首先从各种<strong>视频到文本数据集</strong>中收集153K的VQA数据来构建论文的基准。这一收集包括来自VideoChatGPT的13K对话数据和140K问答对，其中45K数据点来自CLEVRER ，8K来自EGO-QA ，34K来自NextQA ，53K来自TGIF-Transition 。然后，这些VQA数据与28K视频字幕数据结合，形成一个包含181K样本的综合训练数据集。</p><blockquote><p>在训练期间，本文使用了128的批处理大小和AdamW优化器。本文选择对整个模型进行微调，将视觉编码器的学习速率设置为2e-6，将MLP投影层的学习率设置为2e-5，对于使用LoRA的LLM，将学习速率设置为2e-4。这样的训练策略使作者能够在大约5小时8A100gpu内获得一个特殊的LVLM，ShareGPT4Video-8B。</p></blockquote><p>表3、4、5展示了ShareGPT4Video-8B模型（由论文的ShareGPT4Video数据集增强）与现有最先进的LVLMs之间的定量比较。值得注意的是，与之前的LVLMs相比，论文的ShareGPT4Video-8B在所有三个综合基准测试中均取得了最优性能。具体而言，得益于ShareGPT4Video提供的<strong>丰富时间信息</strong>，本文模型在TempCompass基准上实现了平均准确率61.59%。这比之前表现最佳的LVLM，VideoLLaVA-7B提高了11.6%。此外，尽管VideoBench和MVBench基准从各种现有视频数据集中收集了多样化的QA数据，论文在这两个基准上均取得了稳健的性能，平均准确率分别超过之前的最先进水平2.7%和8.2%。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204215525840.png" alt="image-20241204215525840" style="zoom: 50%;"><h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p><strong>关于字幕质量和ViT的消融研究</strong>。基于ShareGPT4Video-8B，论文研究了字幕质量和可学习的视觉编码器如何影响模态对齐。如表2所示，在VQA数据之上<strong>引入简短的字幕可能不会带来显著的性能提升</strong>。由于模态对齐不佳，<strong>它甚至可能在某些基准上降低性能</strong>。比较表2中的第一、第二和第四行，得益于论文高质量字幕数据，理解时间序列的性能提升是显而易见的。此外，在训练时<strong>使用详细字幕解锁视觉编码器有助于更好地实现LVLMs的模态对齐。</strong></p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204220004727.png" alt="image-20241204220004727" style="zoom:67%;"><h3 id="视频字幕生成"><a href="#视频字幕生成" class="headerlink" title="视频字幕生成"></a>视频字幕生成</h3><p>为了验证ShareCapitoner-Video的能力，论文通过人类偏好投票定量比较了ShareCapitoner-Video与GPT4V之间的视频字幕质量。如表7显示，其性能与GPT4V相当。打分标准：邀请10名志愿者从三个方面对字幕进行评估。这些方面包括：(1)<strong>遗漏和虚构</strong> - 检查字幕中有没有缺少的关键元素，或识别到视频中不存在的图像元素；(2)<strong>失真</strong> - 评估元素属性，如颜色和大小的准确性；(3)<strong>时间不匹配</strong> - 评估描述是否准确地反映了视频中时间事件的演变。每对最多可以获得3分，每个标准1分。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204220203143.png" alt="image-20241204220203143" style="zoom:67%;"><p>表6比较了ShareCapitoner-Video与GPT4V生成的字幕的词汇成分，结果表明二者有相当的信息级别。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204221121407.png" alt="image-20241204221121407" style="zoom: 67%;"><p>图9给出了不同来源的视频字幕质量的定性比较。</p><ul><li><strong>Panda-Student</strong>：为视频生成一句话的描述。虽然这种方法最大限度地减少了错误，但它没有为信息密集的视频提供足够的文本信息，阻碍了视频和语言模式的对齐。</li><li><strong>Video ChatCaptioner</strong>：使用ChatGPT构建问题，使用BLIP2做VQA，然后再次使用ChatGPT基于QA总结一个完整的字幕。虽然这种方法产生的字幕比Panda-Student更长，但ChatGPT的广泛参与往往会导致<strong>过度想象和幻觉</strong>，对视频和语言模式之间的一致性产生负面影响。</li><li><strong>GPT-4V</strong>：展现了杰出的字幕生成能力。</li><li><strong>ShareCapitoner-Video</strong>：在ShareGPT4Video数据集上进行微调后，同样展现了优秀的字幕生成能力。</li></ul><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204220319092.png" alt="image-20241204220319092" style="zoom: 50%;"><h3 id="视频生成"><a href="#视频生成" class="headerlink" title="视频生成"></a>视频生成</h3><h4 id="模型设置"><a href="#模型设置" class="headerlink" title="模型设置"></a>模型设置</h4><p>为了验证高质量字幕在T2VMs领域的有效性，论文使用ShareCaptioner-Video和Panda-Student 分别为450万个65帧视频和30万个221帧视频生成高质量且简短的视频字幕。遵循Open-Sora-Plan中概述的流程，论文对预训练的T2VM进行了微调，以生成高保真度10秒视频。作为比较，论文对具有相同数量视频-简短字幕对的基线模型进行了微调。</p><p>实现细节：利用Latte-XL模型和一个来自T5-XXL的文本编码器。第一阶段，在较少的帧数上进行预训练，并实现联合图像-视频训练，图像批处理大小是视频的4倍。这个阶段包括5万训练steps。在第二阶段，视频和图像的批量大小都减少到2。对于所有的训练阶段，使用了固定的学习速率为2e-5的AdamW优化器，图像和视频的分辨率均设置为512×512。为了训练精度，使用Bf16，因为fp16导致损失成为NaN。第一阶段需要大约6K H100 GPU小时，而第二阶段需要大约36K Ascend GPU小时。</p><h4 id="定性分析"><a href="#定性分析" class="headerlink" title="定性分析"></a>定性分析</h4><p>如图5所示，T2VM在ShareCaptioner-Video生成的高质量详细字幕辅助下，<strong>能够准确遵循详细prompt，并在语义内容和相机运动控制方面表现出卓越的控制能力。</strong>生成的视频展示了复杂而生动的画面。相比之下，当提供简短字幕时，T2VM难以遵循复杂的生成prompt，导致结果不佳。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204225717589.png" alt="image-20241204225717589" style="zoom:67%;"><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204225840397.png" alt="image-20241204225840397" style="zoom:67%;"><h2 id="局限和影响"><a href="#局限和影响" class="headerlink" title="局限和影响"></a>局限和影响</h2><p>局限：虽然本文目前生成高质量视频字幕的pipeline充分利用了视觉和文本信息，但由于GPT4V无法同时合并音频信息，它受到了限制。音频信息在涉及日常人类活动的对话场景中是有益的，一旦GPT4o支持音频输入，作者计划在未来的工作中引入音频信息，以进一步提高字幕的质量。</p><p>社会影响：1)由于大型语言模型涉及到大规模字幕的生成过程，作者没有手动验证每个字幕的社会偏见内容；2)虽然作者利用了来自现有公共数据集的视频数据，但作者不能确保所选的视频不包含人脸。因此，虽然对本文生成的字幕的使用没有限制，但用户在使用视频时必须遵守原始视频源的许可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本研究中，作者的目的是解决大型视频语言模型（LVLMs）和文本到视频模型（T2VMs）<strong>缺乏高质量的视频字幕数据</strong>的挑战。作者开发了ShareGPT4Video，一个高质量的<strong>视频字幕数据集</strong>，和ShareCaptioner-Video，一个在<strong>视频语言多模态</strong>领域的先进和多功能的<strong>模型</strong>。通过采用一系列的策略和设计，本文从高级的图像多模态模型、GPT4V和4.8M字幕数据（由ShareGPT4Video生成）得到了40K详细字幕。这些字幕包括丰富的世界知识、对象属性、相机运动和对事件的详细时间描述。本文广泛的实验验证了提出的数据集和标注器在增强视频理解和生成任务方面的有效性。</p><h2 id="架构相关"><a href="#架构相关" class="headerlink" title="架构相关"></a>架构相关</h2><h3 id="关键帧采样"><a href="#关键帧采样" class="headerlink" title="关键帧采样"></a>关键帧采样</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> functional <span class="token keyword">as</span> F<span class="token keyword">import</span> cv2<span class="token keyword">import</span> math<span class="token keyword">from</span> transformers <span class="token keyword">import</span> CLIPFeatureExtractor<span class="token punctuation">,</span>CLIPVisionModel<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npmodel_path <span class="token operator">=</span> <span class="token string">'openai/clip-vit-large-patch14-336'</span>feature_extractor <span class="token operator">=</span> CLIPFeatureExtractor<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model_path<span class="token punctuation">)</span>vision_tower <span class="token operator">=</span> CLIPVisionModel<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model_path<span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>vision_tower<span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">calculate_clip_feature_sim_2</span><span class="token punctuation">(</span>image_1<span class="token punctuation">,</span> image_2<span class="token punctuation">)</span><span class="token punctuation">:</span>    input_1 <span class="token operator">=</span> feature_extractor<span class="token punctuation">(</span>images<span class="token operator">=</span>image_1<span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    input_2 <span class="token operator">=</span> feature_extractor<span class="token punctuation">(</span>images<span class="token operator">=</span>image_2<span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    image_feature_1 <span class="token operator">=</span> vision_tower<span class="token punctuation">(</span><span class="token operator">**</span>input_1<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span>vision_tower<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> output_hidden_states<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hidden_states<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    image_feature_2 <span class="token operator">=</span> vision_tower<span class="token punctuation">(</span><span class="token operator">**</span>input_2<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span>vision_tower<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> output_hidden_states<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hidden_states<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    similarity <span class="token operator">=</span> F<span class="token punctuation">.</span>cosine_similarity<span class="token punctuation">(</span>image_feature_1<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">'cpu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> image_feature_2<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">'cpu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Sim: </span><span class="token interpolation"><span class="token punctuation">{</span>similarity<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> similarity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CLIPVisionModel</code> 是 <strong>OpenAI CLIP 模型的视觉部分，用于从图像中提取特征。</strong>它是基于 <strong>Vision Transformer (ViT)</strong> 或其他卷积神经网络架构（例如 ResNet）构建的模型。CLIP 的主要目标是通过视觉和语言的对比学习来使模型同时理解这两种模态。</p><p>在 CLIP 的视觉模型中，图像通过一个深度神经网络进行处理，该网络的目的是将图像嵌入到一个高维空间中，在这个空间里，视觉特征可以与文本特征对齐，从而使得图像和文本可以相互比较。</p><p><code>CLIPVisionModel</code> 内部结构主要由以下几个组件组成：</p><ol><li><strong>输入层</strong>：<ul><li>图像首先会被输入到一个预处理的特征提取器（如 <code>CLIPFeatureExtractor</code>），它会对图像进行缩放、裁剪和标准化等操作，确保图像符合模型的输入要求。</li></ul></li><li><strong>视觉模型（通常是 Vision Transformer）</strong>：<ul><li>CLIP 使用的是 <strong>Vision Transformer (ViT)</strong> 架构。ViT 是一种基于 Transformer 的视觉模型，使用自注意力机制来捕捉图像中的局部和全局信息。</li><li>具体来说，图像首先被分割成固定大小的补丁（patches），每个补丁被视为一个 token，类似于文本中的单词。然后这些补丁经过嵌入、线性变换，形成与文本输入类似的高维特征表示。</li><li>CLIP 中的 Vision Transformer 通常采用 <strong>ViT-B/16</strong>（Base model，16x16 图像补丁）或其他类似的架构。</li></ul></li><li><strong>图像嵌入（Image Embeddings）</strong>：<ul><li>通过 Vision Transformer 处理后，最后的隐藏状态（通常是 <code>[CLS]</code> token 对应的输出）被用作图像的特征向量（embedding）。</li><li>这个特征向量是一个高维的表示，它捕捉了图像的语义信息，并与文本嵌入对齐，可以用来进行图像与文本的匹配和相似度计算。</li></ul></li><li><strong>Transformer 层和多头自注意力机制</strong>：<ul><li>Vision Transformer 通过多层的自注意力机制对图像中的补丁进行建模，能够捕捉图像中复杂的关系和语义信息。每一层的输出会提供一个更加丰富的图像表示。</li></ul></li></ol><h3 id="IG-VLM策略"><a href="#IG-VLM策略" class="headerlink" title="IG-VLM策略"></a>IG-VLM策略</h3><p><strong>An Image Grid Can Be Worth a Video: Zero-shot Video Question Answering Using a VLM</strong></p><blockquote><p>标题:一个图像网格可以抵得上一段视频使用 VLM 进行零镜头视频答题<br>author:Wonkyun Kim, Changin Choi, Wonseok Lee, Wonjong Rhee<br>paper:<a href="https://arxiv.org/html/2403.18406v1">An Image Grid Can Be Worth a Video: Zero-shot Video Question Answering Using a VLM</a><br>publish:Our code is available at <a href="https://link.zhihu.com/?target=https://github.com/imagegridworth/IG-VLM">https://github.com/imagegridworth/IG-VLM</a><br>date Time:2024-03-27</p></blockquote><p>在最近的大型语言模型（LLM）的复杂推理能力的刺激下，人们设计出了多种连接视频模式的策略。视频语言模型（VideoLMs）是其中一个突出的策略，它利用视频数据训练可学习的界面，将高级视觉编码器与 LLMs 连接起来。最近，出现了另一种策略，即利用视频语言模型（VideoLMs）和 LLMs 等现成的基础模型，在多个阶段实现模态桥接。在本研究中，我们介绍了一种简单而新颖的策略，即<strong>只使用一个视觉语言模型（VLM）</strong>。我们的出发点是一个朴素的观点，即<strong>视频由一系列图像或帧组成，并与时间信息交织在一起</strong>。视频理解的精髓在于<strong>对每一帧图像的时间信息和空间信息进行有效管理</strong>。起初，我们<strong>通过将多个帧按网格布局排列，将视频转换成单一的合成图像。由此产生的单一图像被称为图像网格。这种格式在保持单幅图像外观的同时，有效保留了网格结构中的时间信息。因此，图像网格方法可以直接应用单一的高性能 VLM，而无需任何视频数据训练。</strong>我们对 10 个零样本视频问题解答基准（包括 5 个开放式基准和 5 个多项选择基准）进行了广泛的实验分析，结果表明所提出的图像网格视觉语言模型（IG-VLM）在 10 个基准中的 9 个基准中超越了现有方法。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241209191753822.png" alt="image-20241209191753822" style="zoom:67%;"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[<a href="https://arxiv.org/abs/2406.04325">2406.04325] ShareGPT4Video: Improving Video Understanding and Generation with Better Captions</a></p><p>[ShareGPT4Omni/ShareGPT4Video: <a href="https://github.com/ShareGPT4Omni/ShareGPT4Video">NeurIPS 2024] An official implementation of ShareGPT4Video: Improving Video Understanding and Generation with Better Captions</a></p><p><a href="https://zhuanlan.zhihu.com/p/702413750">【LLM】ShareGPT4Video：借助更优质的标题提升视频理解和生成能力 - 知乎</a></p><p><a href="https://www.jiqizhixin.com/articles/2024-06-20-4">ShareGPT4V作者团队又一力作！百万高质量视频-字幕数据助力社区提升多模态大模型视频理解及生成能力 | 机器之心</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MLLM </tag>
            
            <tag> 视频理解 </tag>
            
            <tag> 字幕生成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多模态架构相关</title>
      <link href="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/"/>
      <url>/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h1 id="多模态架构相关"><a href="#多模态架构相关" class="headerlink" title="多模态架构相关"></a>多模态架构相关</h1><p>MLLM通常包含以下几个组件：</p><ul><li>一个预训练的<strong>模态编码器</strong>：用于接收视觉/听觉输入等不同模态的输入并编码为模态特征。</li><li>一个输入投影器（<strong>模态接口</strong>）：用于将多模态的特征对齐到文本特征空间，并且和文本特征一起输入到llm。</li><li>一个预训练的<strong>大模型</strong>backbone：利用LLM对对齐后的特征做语义理解、推理和决策，并输出统一的信号。</li><li>可选的<strong>输出投影器</strong>：将语言模型输出的信号进一步转换为其他模态的特征，或者是投影到任务需要的输出范式中。</li><li>可选的<strong>模态生成器</strong>：负责生成其他模态的输出。</li></ul><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203105912970.png?lastModify=1733205528" alt="image-20241203105912970" style="zoom: 80%;"><h2 id="视觉编码器"><a href="#视觉编码器" class="headerlink" title="视觉编码器"></a>视觉编码器</h2><h3 id="CLIP-VIT"><a href="#CLIP-VIT" class="headerlink" title="CLIP VIT"></a>CLIP VIT</h3><p>CLIP的的核心思想是通过<strong>海量</strong>的<strong>弱监督文本对</strong>对比学习，将图片和文本通过各自的<strong>预训练</strong>模型获得的编码向量在向量空间上<strong>对齐</strong>。不足：clip可以实现图文匹配，但不具有文本生成能力。</p><blockquote><p>这里对提取的文本特征和图像特征进行对比学习。对于一个包含N个文本-图像对的训练batch，将N个文本特征和N个图像特征两两组合，CLIP模型会预测出N^2个可能的文本-图像对的相似度，这里的相似度直接<strong>计算文本特征和图像特征的余弦相似性（cosine similarity）</strong>，即上图所示的矩阵。这里共有N个正样本，即真正属于一对的文本和图像（矩阵中的对角线元素），而剩余的N^2−N个文本-图像对为负样本，那么CLIP的训练目标就是最大化N个正样本的相似度，同时最小化N^2−N个负样本的相似度</p></blockquote><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241021110850956.png" alt="image-20241021110850956" style="zoom: 67%;"><p>CLIP VIT是在大名鼎鼎的CLIP这项工作中，作者团队使用约<strong>4亿个图像-文本对数据</strong>训练得到的VIT权重，可以说是当前最强的VIT模型之一，<strong>Clip VIT已经成为目前多数多模态模型的首选。</strong></p><h3 id="EVA-CLIP"><a href="#EVA-CLIP" class="headerlink" title="EVA-CLIP"></a>EVA-CLIP</h3><blockquote><p>蒸馏版CLIP，训练消耗更小，速度更快，效果更好。</p></blockquote><p>EVA-CLIP，这是一种基于对比语言图像预训练(CLIP)技术改进的模型，通过引入新的<strong>表示学习、优化和增强技术</strong>，显著<strong>提高了CLIP的训练效率和效果</strong>。EVA-CLIP系列模型在<strong>保持较低训练成本</strong>的同时，实现了与先前具有相似参数数量的CLIP模型相比更高的性能。特别地，文中提到的EVA-02-CLIP-E/14+模型，使用90亿数据样本和5.0B(50亿)参数，在ImageNet-1K的val数据集上取得了82.0%的零样本准确率，而较小的EVA-02-CLIP-L14+模型，尽管仅使用了4.3亿参数和60亿数据样本，也达到了80.4%的准确率。这些结果表明，EVA-CLIP在图像分类任务中，特别是在零样本学习场景下，展现出了卓越的性能。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241202183416207.png" alt="image-20241202183416207" style="zoom: 67%;"><h3 id="SigLip"><a href="#SigLip" class="headerlink" title="SigLip"></a>SigLip</h3><p>CLIP 面临<strong>两个技术挑战：</strong>（1）它需要较大的批大小。例如，CLIP使用了 <strong>32K 的批量大小</strong>，这需要大量 GPU;（2）它需要这些 GPU 之间进行大量通信。</p><p>SigLip方法<strong>减少 了CLIP 的批量大小要求</strong>， 是<strong>Sig</strong>moid <strong>Language</strong> Image <strong>Pre</strong> -training 的缩写。SigLIP 的核心思想是使用 Sigmoid运算而不是Softmax<strong>运算</strong>。CLIP 使用 Softmax 函数，因此，给定正对（图像-文本）的损失取决于批量内的每个负对。相比之下，SigLIP 既不对称，也不需要全局归一化因子。因此，每对（正数和负数）的损失都与小批量内的其他对无关。</p><img src="https://i-blog.csdnimg.cn/blog_migrate/b2c95131902ea195a844a5ae763f9153.png" alt="img" style="zoom: 50%;"><h3 id="NFNet"><a href="#NFNet" class="headerlink" title="NFNet"></a>NFNet</h3><p><a href="https://arxiv.org/pdf/2102.06171"><strong>High-Performance Large-Scale Image Recognition Without Normalization (ICML 2021)</strong></a></p><p>NFNet（Normalizer-Free ResNets）是DeepMind提出的一种<strong>不需要Batch Normalization的基于ResNet的网络结构</strong>，其核心为一种AGC（adaptive gradient clipping technique，自适应梯度裁剪）技术。最小的NFNet版本达到了EfficientNet-B7的准确率，并且训练速度快了8.7倍，最大版本的模型实现了新的SOTA效果。</p><p><strong>NFNet 视觉大模型：匹敌 ViT 性能的大规模预训练</strong>：</p><blockquote><p>结论：<strong>当能够访问足够大的数据集时，CNN实际上可以与 ViT 竞争。</strong>决定一个视觉骨干模型性能的最重要因素是用于训练的<strong>计算预算</strong> 和<strong>训练的数据量</strong> 。尽管 ViT 在视觉任务上的成功让人印象深刻，但是在本文看来，没有强有力的证据表明预训练的视觉 Transformer 模型的性能在计算预算相当的条件下优于预训练的 ConvNet 模型。</p><p>但不可否认的是，Transformer 模型在特定的上下文中具有实际优势，比如能够在多种模态中使用相似的组件的能力。</p></blockquote><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241202224849112.png" alt="image-20241202224849112" style="zoom:80%;"><h2 id="视觉token压缩"><a href="#视觉token压缩" class="headerlink" title="视觉token压缩"></a>视觉token压缩</h2><p>为提升MLLM对图像、视频的理解能力，最有效的方式就是提升visual token的个数，随之而来的则是训练、推理耗时的增加。因此，<strong>对视觉token进行压缩以提取最有用的信息</strong>至关重要。</p><p>目前的视觉映射器分以下几种：</p><ol><li><p><strong>Resampler or Q-former</strong>：该方法通过引入可学习的 query 来自适应地来学习相关视觉表示，通过控制可学习 query 的个数来控制视觉 token 产生的数目。</p></li><li><p><strong>基于卷积的视觉映射器</strong>：典型的工作有 C-abstractor、LDPv1/v2， 通过引入卷积操作来<strong>建模局部视觉信息</strong>之间的关系，同时采用<strong>下采样</strong>减少视觉表示的长度。</p></li><li><p><strong>维度变换</strong>：将产生的视觉表示在 sequence 的维度<strong>变换到 channel 维度</strong>，如 PixelShuffle，虽然视觉信息没有减少但结构信息可能会被破坏。在 InternLM-XComposer2-4KHD 与 InternVL 1.5 的研究工作均采用了类似的操作。此外，在研究工作 MM1 中，也对常用的几种 Visual Projector 进行实验验证与性能分析。</p></li></ol><h3 id="Q-Former"><a href="#Q-Former" class="headerlink" title="Q-Former"></a>Q-Former</h3><p>Q-Former由两个transfomer子模块组成，左边为(learnable) query encoder，右边为text encoder &amp; decoder。记视觉模型的image encoder的输出为I。左边网络的(learnable) query为Q，右边网络的输入text为T。注意Q是一个向量集，非单个向量。它可以视为Q-Former的参数。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241022195840325.png" alt="image-20241022195840325" style="zoom:80%;"><h3 id="Perceiver-Resampler"><a href="#Perceiver-Resampler" class="headerlink" title="Perceiver Resampler"></a>Perceiver Resampler</h3><p>感知重采样技术（Perceiver Resampler）首次被引入 MLLM 是2022 年 4 月DeepMind 在论文 Flamingo 中提出的，Flamingo采用了感知重采样（<em>Perceiver Resampler</em>）技术和门控交叉注意力技术（Gated Cross-<em>Attention</em>）进行视觉多模态信息和LLM的融合，代表模型：Flamingo、Qwen-VL、MiniCPM-V、LLaVA-UHD</p><ul><li><strong>数据压缩与选择：</strong>图像通常具有很高的维度（例如，像素级别的数据），直接将这些高维数据输入到Transformer中会导致计算负担过重。Perceiver Resampler的主要目标是将这些高维视觉数据压缩到固定数量的紧凑表示，以适应后续的Transformer处理。</li><li><strong>模态对齐：</strong>在多模态任务中（如视觉语言任务），图像和文本往往具有不同的模态特性。Perceiver Resampler通过学习跨模态的映射，将图像数据转换为与文本表示形式相匹配的低维向量。这种转换可以使Transformer更容易处理和对齐不同模态的信息。</li><li><strong>自适应表征学习：</strong>Perceiver Resampler不是简单地对图像进行下采样，而是通过可学习的参数自适应地从输入中提取重要信息。这使得模型能够动态地选择与任务相关的视觉特征。</li></ul><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203024555554.png?lastModify=1733207896" alt="image-20241203024555554" style="zoom: 50%;"><h3 id="Linear-Projector"><a href="#Linear-Projector" class="headerlink" title="Linear Projector"></a><strong>Linear Projector</strong></h3><p><strong>Linear Projector（线性投影器</strong>）首次被引入 MLLM 是2023年4月 LLaVA1.0 的发布，论文中提出了一种更简单的投影方法，通过线性变换将Modality Encoder编码的特征映射到LLM的表示空间中。代表模型主要有：LLaVA、MiniGPT-4、NEXT-GPT。</p><img src="https://pic3.zhimg.com/v2-f1931fee783c332648242287ccdb39b4_1440w.jpg" alt="img" style="zoom:50%;"><p>Linear Projector结构比较简单，比Q-Former简单的多，非常易于实现和训练，但是效果上却一点也不弱于Q-Former。</p><h3 id="Multi-Layer-Perception"><a href="#Multi-Layer-Perception" class="headerlink" title="Multi-Layer Perception"></a>Multi-Layer Perception</h3><p><strong>多层感知机（Multi-Layer Perception， MLP）</strong>首次被引入 MLLM 是在2023 年 10 月 LLaVA1.5 中提出的，LLaVA1.5 在对比LLaVA1.0结构上，将视觉特征从线性映射（单个神经元），改进为多层感知机（MLP)。代表模型包括：LLaVA1.5/NeXT、CogVLM、DeepSeek-VL、Yi-VL。</p><img src="https://pic4.zhimg.com/v2-249d50464838d5f6a8340e9a2e567401_1440w.jpg" alt="img" style="zoom:50%;"><p>多层感知器由多层线性变换和非线性激活函数组成，能够捕捉输入数据的复杂非线性关系。</p><p>最近MLP结构成为了MLLM中模态对齐的主流结构，LLAVA 系列的技术路线被大家更认可，主要原因是：MLP用最简洁的结构在效果上碾压其他一众复杂结构，并且具有更快的收敛速度，对数据量的依赖也少。</p><h2 id="音频编码器"><a href="#音频编码器" class="headerlink" title="音频编码器"></a>音频编码器</h2><h3 id="Whisper"><a href="#Whisper" class="headerlink" title="Whisper"></a>Whisper</h3><p>Whisper是 OpenAI于 2022 年09月开放的一个超大规模的语音识别预训练模型，它使用端到端的方式进行多语言的预训练，在开放域的英语ASR （语音识别）能力上已经实现了与人类相对的水平。</p><p>Whisper 使用标准的 <strong>Transfomer 编码器-解码器架构</strong>对模型进行训练。每条语音数据输入长度为 30 秒，通过 25ms 的汉明窗和 10ms 的步移，在 16000 的采样帧率下，转化为 3000 帧长，80维度的对数梅尔频谱图。并使用两层1维的卷积神经网络和 GELU 激活函数对原始对数梅尔频谱图进行初始的特征提取。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203152120772.png" alt="image-20241203152120772" style="zoom:67%;"><h3 id="CLAP"><a href="#CLAP" class="headerlink" title="CLAP"></a>CLAP</h3><p>CLAP（Contrastive Language-Audio Pretraining）是在2023年提出的一种<strong>基于对比学习的预训练方法</strong>，旨在通过结合<strong>音频数据</strong>和相应的<strong>自然语言描述</strong>来学习音频的表示。这种方法的核心思想是利用对比学习范式，将音频和文本映射到一个共享的潜在空间中，并通过训练使得相关的音频-文本对在该空间中更接近，而不相关的对更远离。简单来说，CLAP是参考了CLIP的思路，将图像-文本对迁移至音频-文本对，并完成音频数据预训练的工作。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203153009849.png" alt="image-20241203153009849" style="zoom: 50%;"><h3 id="HuBERT"><a href="#HuBERT" class="headerlink" title="HuBERT"></a>HuBERT</h3><p>HuBERT 是 Meta 在 2021 年发表的模型，模型结构类似 Wav2vec 2.0，不同的是训练方法。Wav2vec 2.0 是在训练时将语音特征离散化作为自监督目标，而 HuBERT 则通过在 MFCC 特征或 HuBERT 特征上做 K-means 聚类，得到训练目标。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203154103891.png" alt="image-20241203154103891" style="zoom:67%;"><h2 id="早期图文匹配记录"><a href="#早期图文匹配记录" class="headerlink" title="早期图文匹配记录"></a>早期图文匹配记录</h2><ul><li><p>为了与配对文本的embedding序列对齐，图像V也将被表示为embedding向量的序列。将输入表示统一为两种模态的embedding序列。</p></li><li><p>早期做法：图片提取出来的区域特征，最好和文本的token特征在同一个level上。</p></li><li><p>为了生成图像的描述，模型被期望于推断图像中各种对象之间的复杂关系。</p><ul><li><p>因此，许多工作设计了不同的视觉编码器来对这些关系和对象的属性进行建模。</p></li><li><p>ViLBERT[Lu et al.，2019]和LXMERT[Tan和Bansal，2019]等早期工作首先利用Faster RCNN[Ren et al.，2015]从图像中检测对象区域序列，然后将其编码为感兴趣区域（ROI）特征序列。使用ROI feature作为内容信息，将bounding box作为位置信息</p></li><li><p>此外，一些VL-PTM去掉了边界框（bounding box），并将图像编码为像素级网格特征（pixel-level grid features）。例如，pixel-BERT[huang等人，2020]和SOHO[huang等人，2021]放弃了更快的R-CNN，转而支持ResNet，这样视觉编码器就可以将图像作为一个整体来查看，避免了忽略一些关键区域的风险。</p></li><li><p>除了这些方法之外，许多工作都试图遵循ViT的成功[多索维茨基等人，2020年]利用transformer来提取视觉特征。在这个场景中，vl-ptm中的transformer的任务是建模图像中的对象关系。首先将一个图像分割成几个flattened 2D patches。然后将图像patch的embedding按顺序排列，以表示原始图像。</p><ul><li>ALBEF [Li等人，2021a]和SimVLM [Wang等人，2021b]将patch提供给ViT编码器，以提取视觉特征，从而导致了full-transformer VL-PTM的产生。</li></ul></li></ul></li></ul><h3 id="文本embedding-图片ROI-embedding"><a href="#文本embedding-图片ROI-embedding" class="headerlink" title="文本embedding + 图片ROI embedding"></a>文本embedding + 图片ROI embedding</h3><ul><li><p>文本序列首先分为tokens，并与“[CLS]”和“[SEP]”token串联，表示为W = &lt;[CLS]，w1，…，wn，[SEP]&gt;。每个令牌wj都将映射到一个词嵌入。</p></li><li><p>此外，在嵌入一词中添加表示位置的 pos embbding 和 嵌入模态类型的seg embbding，以获得wj的最终嵌入。</p></li></ul><p><strong>视觉部分：如何设计一个比较好的视觉embedding，去适应一个语言方面的预训练模型？</strong></p><h4 id="OSCAR"><a href="#OSCAR" class="headerlink" title="OSCAR"></a>OSCAR</h4><p>OSCAR将object tag作为信息进行输入，object是将信息转化为一个文本标签，构建了视觉信息和文本信息之间的桥梁，达到了视觉和文本的一致性。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203142613732.png" alt="image-20241203142613732" style="zoom:67%;"><p>问题：</p><p>1.需要额外训练一个roi提取模型，模型准确性影响预训练模型准确性</p><p>2.不同图片roi个数是不确定的，预训练模型需要相对固定roi个数导致信息丢失</p><p>3.roi数据集准备复杂，<strong>目标检测模型得到的都是矩形的目标，其不适合于不规则的物体，导致得到的bounding box中存在噪声。另外，除了bounding box以外，一些背景信息是无法提取出来的，相当于即存在噪声，也存在损失</strong>。对效果产生一些影响。</p><p>4.下游任务不一定适配用roi粒度特征，比如在一个domain预训练的目标检测模型，将其转换到另外的domain中，效果可能有相当大的gap，影响模型的效果。</p><h3 id="文本embedding-图片Grid-embedding"><a href="#文本embedding-图片Grid-embedding" class="headerlink" title="文本embedding + 图片Grid embedding"></a>文本embedding + 图片Grid embedding</h3><p>为了解决region特征表示问题，提出Grid embedding方式表示图像数据。放弃ROI，<strong>转而使用cnn或者resnet抽取Grid Embedding，以便图像编码器可以将图像作为一个整体查看</strong>，避免忽视一些关键区域的风险。</p><h4 id="Pixel-BERT"><a href="#Pixel-BERT" class="headerlink" title="Pixel-BERT"></a>Pixel-BERT</h4><p>Pixel-Bert用cnn抽取图像Grid embbeding</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203142642035.png" alt="image-20241203142642035" style="zoom:67%;"><h4 id="SOHO"><a href="#SOHO" class="headerlink" title="SOHO"></a>SOHO</h4><p>SOHO用resnet抽取Grid embedding</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203142829471.png" alt="image-20241203142829471" style="zoom: 50%;"><h3 id="文本embedding-图片Patch-embedding"><a href="#文本embedding-图片Patch-embedding" class="headerlink" title="文本embedding + 图片Patch embedding"></a>文本embedding + 图片Patch embedding</h3><p>随着VIT的兴起，出现了patch based的特征提取，将一张图片分为若干patch，并且使用线性变化的方式对其进行编码。</p><p>图像首先被拆分为拍平为2D patch，然后序列化embdding图像的patch，来表示原始图像特征。模型是端到端表示且用的transformer架构可以并行化计算，所以VIT做patch推理速度会快很多</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203143210158.png" alt="image-20241203143210158" style="zoom:67%;"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://waytoagi.feishu.cn/wiki/DPjOwD19iiAcMYkryZicYJMWnTf">‍⁠⁠﻿‍‬‌⁠‌⁠⁠‬⁠﻿⁠‬‍⁠﻿‍‌⁠‍‍﻿﻿‌⁠多模态大模型入门指南-长文慎入【持续更新】 - 飞书云文档</a></p><p><a href="https://blog.csdn.net/AIGCmagic/article/details/138287524">AI多模态模型架构之模态编码器：图像编码、音频编码、视频编码_多模态编码器-CSDN博客</a></p><p><a href="https://blog.csdn.net/AIBigModel/article/details/144150131">多模态视觉token压缩方法详解-CSDN博客</a></p><p><a href="https://arxiv.org/abs/2303.15389">EVA-CLIP: Improved Training Techniques for CLIP at Scale</a></p><p><a href="https://l12k1v7ghxm.feishu.cn/wiki/KeVmwU8W2iyWfZkb6iBcbcr6nEg">‍‬‬‌‌‍﻿‬‌⁠⁠‍‍⁠‌‌‌‌‌‌‌﻿‍‌‌‍‍‬‬‌‌3. 多模态架构 - 飞书云文档</a></p><p><a href="https://arxiv.org/pdf/2212.04356">arxiv.org/pdf/2212.04356</a></p><p><a href="https://arxiv.org/pdf/2004.06165">2004.06165</a></p><p>[<a href="https://arxiv.org/abs/2206.04769">2206.04769] CLAP: Learning Audio Concepts From Natural Language Supervision</a></p><p>[<a href="https://arxiv.org/abs/2106.07447">2106.07447] HuBERT: Self-Supervised Speech Representation Learning by Masked Prediction of Hidden Units</a></p><p>[<a href="https://arxiv.org/abs/2004.00849">2004.00849] Pixel-BERT: Aligning Image Pixels with Text by Deep Multi-Modal Transformers</a></p><p><a href="https://openaccess.thecvf.com/content/CVPR2021/html/Huang_Seeing_Out_of_the_Box_End-to-End_Pre-Training_for_Vision-Language_Representation_CVPR_2021_paper.html">CVPR 2021 Open Access Repository</a></p><p>[<a href="https://arxiv.org/abs/2108.10904">2108.10904] SimVLM: Simple Visual Language Model Pretraining with Weak Supervision</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 多模态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2024/11/18/vue/"/>
      <url>/2024/11/18/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li>web里的网页里 有 三门基础的语言 HTML CSS JavaScript/js</li><li>HTML用于定义网页的基本内容</li><li>CSS样式用于调整网页内容的样式(外观相关的)</li><li>js 用于给网页内容 添加 功能</li></ul><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML（超文本标记语言）是一种用于创建网页标记语言。HTML使用标签来定义网页中的元素，如标题、段落、链接、图像等。它是一种静态语言，主要负责网页的结构和语义化。</p><h4 id="网页基本信息"><a href="#网页基本信息" class="headerlink" title="网页基本信息"></a>网页基本信息</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- DOCTYPE 文本类型，告诉浏览器使用的是什么规范--&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- head 网页头部 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- meta 描述性标签，可描述一些网站信息：比如编码、关键字、间接叙述--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>keywords<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>前端开始<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>这是三件套的开始<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- title 打开网站后看到的网站名称   --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>First HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 主体 内部是可在网页页面上显示的内容--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        Hello，HTML    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--标题标签--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--段落标签，每个标签自成一段--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--换行标签，只是换行，多行成一段--&gt;</span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--水平线标签--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--字体样式标签--&gt;</span>粗体：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">&gt;</span></span>斜体：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--特殊格式--&gt;</span>空<span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span>格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>块级标签,简称块</strong>：默认在页面布局里,自己独占一行。</p><ul><li><p>CSS盒子模型属性里的 宽高,内填充,外边框,边框 都可以单独控制且有效果</p></li><li><p>常用的块级元素有 h1~h6 p ul li ol table form div…</p></li></ul><p><strong>行级标签/元素</strong>：默认的在页面布局里,自己会跟其他行级标签挤在一行,除非这一行挤不下,才会换行</p><ul><li>CSS盒子模型属性里的 宽高,内填充,外边框,边框 有一部分是可以控制且有效果的</li><li>常用的行级元素有 a b span font img input select label…</li></ul><h4 id="特殊标签"><a href="#特殊标签" class="headerlink" title="特殊标签"></a>特殊标签</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--1.图片标签--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../resources/image/图片一.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>风景<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>落日<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>前端复习<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>alt图片加载失败时显式的文字，title鼠标悬停到图片显示的文字<span class="token comment">&lt;!--2.链接标签--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HelloHTML.html<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击跳转，文字跳转<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HelloHTML.html<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../resources/image/图片二.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>风景<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>前端复习<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>300<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>300<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--锚链接，定义一个锚标记，然后跳转到锚标记--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>顶部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#top<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>回到顶部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--邮件链接--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mailto:2869861273@qq.com<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击发送邮件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--3.列表标签--&gt;</span><span class="token comment">&lt;!--有序列表--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--无序列表，不是顺序杂乱，而是没有序号标明顺序--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--自定义列表,dt标题，dd内容--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">&gt;</span></span>前端复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">&gt;</span></span>前端复习1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">&gt;</span></span>前端复习1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">&gt;</span></span>前端复习1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--4.表格标签，tr表格里的行，td表格里的列--&gt;</span>table 表格 默认不显示边框 border属性可以调整边框th 表头单元格 比普通单元格 多了 加粗字体,默认居中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1px<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 跨列合并，保留最左单元格，添加属性 colspan --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 跨行合并，保留最上单元格，添加属性 rowspan --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">rowspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>前端复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>前端复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 当设置了跨行和跨列时，后面所被影响的表格需要去掉从而对齐  --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>前端复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>前端复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--5.音视频标签,controls显示进度条 autoplay设置自动播放--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">controls</span> <span class="token attr-name">autoplay</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>audio</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">controls</span> <span class="token attr-name">autoplay</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>audio</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--6.iframe内联标签，即在一个网页里还有一个内联框,内联框里是另一个网址--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://www.baidu.com<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h4><ul><li>表单是用来收集用户的不同输入的数据,然后发送给”服务器程序”</li><li>表单form标签,内部可以定义很多不同形式的”表单组件”.</li><li>表单组件有的表现为单行文本框,密码框,按钮,复选框,下拉菜单</li><li>form标签有method属性,设置 本表单的提交方式,默认值为get 可以设置为post</li><li>form标签有action属性,设置 本表单提交到的路径,通常是”服务器程序”的路径</li><li>form标签有enctype属性,设置 当表单里有文件上传时,表单的特殊编码形式</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--7.表单 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HelloHTML.html<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>get<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- name的值就是提交的时候的键 组件里用户输入的数据,就是提交的时候 键对应的值 --&gt;</span>    <span class="token comment">&lt;!-- value 可以设置默认值 --&gt;</span>    <span class="token comment">&lt;!-- placeholder 占位符,不输入的时候一个提示 --&gt;</span>    <span class="token comment">&lt;!-- size 输入框的长度 --&gt;</span>    <span class="token comment">&lt;!-- maxlength 能输入的字符的最大个数 --&gt;</span>    <span class="token comment">&lt;!-- required 表示必须填写,否则表单无法提交,属性名和值相同的,这样的属性 可以直接写属性 --&gt;</span>    <span class="token comment">&lt;!-- pattern 设置 正则表达式 --&gt;</span>    <span class="token comment">&lt;!-- 提交按钮 HTML中已经定义好的 可以提交表单的按钮,把表单里的数据发送出去 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>输入用户名<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30<span class="token punctuation">"</span></span>           <span class="token attr-name">required</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>required<span class="token punctuation">"</span></span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>^[a-zA-Z]\w{3,7}$<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 单选按钮 必须提供相同的name属性 才能成为互斥的一组    &lt;label&gt;Gender:&lt;/label&gt;    &lt;input type="radio" name="gender" value="1" checked/&gt;&lt;label&gt;Female&lt;/label&gt;&lt;img src="img/logo.png"/&gt;    &lt;input type="radio" name="gender" value="2"/&gt;&lt;label&gt;Male&lt;/label&gt;&lt;img src="img/logo.png"/&gt;    &lt;br/&gt;    input 单标签 它的值需要使用value来定义.后面的label/文本/图片 仅仅和它是排版上一起    单选按钮 默认选择的属性 checked --&gt;</span>        <span class="token comment">&lt;!-- 图片形式的提交按钮 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>image<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img/logo.png<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50px<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50px<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>普通按钮<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- js添加功能 --&gt;</span>    <span class="token comment">&lt;!-- 按钮这里 还有一个特殊的button双标签 根据type属性的不同 有不同的效果 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>普通按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>提交按钮:有功能<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>重置按钮:有功能<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--单选框 name表示组，只有在同一组的才能选择其一   --&gt;</span>    男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>girl<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>boy<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--多选框 checked默认选中 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>爱好：        游戏<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>play<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token punctuation">&gt;</span></span>        舞蹈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dance<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        吃<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>eat<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>secret<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>秘密数据<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- 隐藏域 用户看不到,但是可以跟随表单一起提交的数据,一般是程序员设置在此的一个数据 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>birthdayInput<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Birthday:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 日期，邮件等 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>date<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>birthdayInput<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emailInput<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Email:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emailInput<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>week<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>week<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>time<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>time<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 有文件上传时,必须将form的enctype 属性 改为enctype="multipart/form-data"(多组件表单数据)      并且 method 必须改为post,这里没有改 因为 并不能进行真正的上传     --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>photoChoose<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Photo:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>photo<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>photoChoose<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--8.下拉框 selected默认选择--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>下拉框：        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>列表名称<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>china<span class="token punctuation">"</span></span> <span class="token attr-name">selected</span> <span class="token attr-name">disabled</span><span class="token punctuation">&gt;</span></span>中国<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>us<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>英国<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ufo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>美国<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--9.文本域，cols，rows行列长度--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>文本域：        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>textarea<span class="token punctuation">"</span></span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30<span class="token punctuation">"</span></span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>文本框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS（层叠样式表）是一种用于描述网页样式和布局的样式表语言。它与HTML配合使用，负责网页的外观和样式。通过使用CSS，可以控制元素的大小、颜色、字体、布局，实现网页的美观效果和排版。</p><h4 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 1.内部样式--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">h1</span><span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 2.外部样式：链接外部样式表是指通过HTML的link链接标签，建立样式文件和网页的关联。--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css/style.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 3.行内样式--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span> <span class="token property">font-size</span><span class="token punctuation">:</span>30px<span class="token punctuation">;</span> <span class="token property">font-family</span><span class="token punctuation">:</span>黑体<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--     1.标签选择器，选择所有同一标签     --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token selector">标签名</span> <span class="token punctuation">{</span>属性1：属性值1<span class="token punctuation">;</span>属性2：属性值2<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token selector">h1</span> <span class="token punctuation">{</span>         <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>     <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--    2.类选择器，需先在标签里定义一个任意类属性，可多个标签定义同一个类名，然后在css中.类名--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">.类名</span> <span class="token punctuation">{</span>        属性1：属性值1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">.liy</span><span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--    使用类样式    --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标签名</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>类名<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> 标签内容 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>标签名</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>liy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>类选择器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>liy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>类选择器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--  3.id选择器，同样先定义一个id，再在css中#id选择，但一个id只能定义一个标签  --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token selector">#ID标识名</span> <span class="token punctuation">{</span>属性1：属性值1<span class="token punctuation">;</span>属性2：属性值2<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token selector">#gu</span><span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gu<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>id选择器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--  4.通配符选择器，查找页面所有标签，设置相同样式  --&gt;</span>* {  color: red;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="高级选择器"><a href="#高级选择器" class="headerlink" title="高级选择器"></a>高级选择器</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">body p</span><span class="token punctuation">{</span>   选中的是body下面的所有p标签 -- 后代选择器        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">body &gt; p</span><span class="token punctuation">{</span>   选中的是body下面的一代p标签 -- 子代选择器        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">p,.red,#header</span> <span class="token punctuation">{</span>   组合（并集）选择器，逗号分隔<span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span>12px<span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">.active+p</span> <span class="token punctuation">{</span>   选的是active标签之后的一个p标签  --  相邻兄弟选择器        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">.active~p</span> <span class="token punctuation">{</span>   选的是激活标签之后的所有p类型标签        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token comment">/* ：hover 鼠标悬浮时  :active 鼠标点击但未松开时  :focus 获取光标焦点时*/</span>    <span class="token selector">h1:hover,p:hover</span><span class="token punctuation">{</span>    伪类选择器：伪类表示元素状态，选中元素的某个状态设置样式。        <span class="token property">background-color</span><span class="token punctuation">:</span> azure<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">h1:active</span><span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> cornflowerblue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">/* :first-child 选择作为第一个子元素的 */</span>    <span class="token selector">tr:first-child:hover</span><span class="token punctuation">{</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/*    这里是对tr进行 筛选, 选出所有tr中 作为别人的第一个子元素的tr    并不是选取 tr内部的第一个孩子     */</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 首先搭建标签并设置标签的格式 */</span><span class="token selector">&lt;p class="demo"&gt; &lt;a href="www.baidu.com" class="links item first" id="first"&gt;1&lt;/a&gt; &lt;a href="" class="links item active" target="_blank" title="test"&gt;2&lt;/a&gt; &lt;a href="resources/image/图片一.jpg" class="links item" &gt;3&lt;/a&gt; &lt;a href="abc" class="links item"&gt;4&lt;/a&gt; &lt;a href="/a.pdf" class="links item"&gt;5&lt;/a&gt; &lt;a href="/abc.pdf" class="links item"&gt;6&lt;/a&gt; &lt;a href="abcd.docx" class="links item"&gt;7&lt;/a&gt; &lt;a href="abc.docx" class="links item"&gt;8&lt;/a&gt; &lt;/p&gt; &lt;style&gt;     .demo a</span><span class="token punctuation">{</span>         <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>         <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>         <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>         <span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>         <span class="token property">border-radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>         <span class="token property">background</span><span class="token punctuation">:</span> #2700ff<span class="token punctuation">;</span>         <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>         <span class="token property">color</span><span class="token punctuation">:</span> gainsboro<span class="token punctuation">;</span>         <span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>         <span class="token property">margin-right</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>         <span class="token property">font</span><span class="token punctuation">:</span> bold 20px/50px Arial<span class="token punctuation">;</span>     <span class="token punctuation">}</span> &lt;/style&gt;<span class="token comment">/*  在style中进行选择，属性选择器格式就是标签+[属性]  */</span><span class="token comment">/*    1.选择存在id的元素*/</span> <span class="token selector">a[id]</span> <span class="token punctuation">{</span>     <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">/*    2.选择id为first的标签*/</span> <span class="token selector">a[id="first"]</span> <span class="token punctuation">{</span>     <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">/*    3.选中class里有links的标签*/</span> <span class="token selector">a[class*="links"]</span> <span class="token punctuation">{</span>     <span class="token property">background</span><span class="token punctuation">:</span> bisque<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">/*    4.特定的开头和结尾  */</span> <span class="token selector">a[href^=w]</span> <span class="token punctuation">{</span>     <span class="token property">background</span><span class="token punctuation">:</span> cornflowerblue<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token selector">a[href$=x]</span> <span class="token punctuation">{</span>     <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="文字控制"><a href="#文字控制" class="headerlink" title="文字控制"></a>文字控制</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p</span><span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> 华文行楷<span class="token punctuation">;</span>   <span class="token comment">/* 字体类型  */</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span><span class="token comment">/* 字体大小  */</span>    <span class="token property">font-style</span><span class="token punctuation">:</span> oblique<span class="token punctuation">;</span><span class="token comment">/* 字体样式：italic斜体字，oblique倾斜的文字 */</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> 900<span class="token punctuation">;</span><span class="token comment">/* 字体粗细  */</span><span class="token punctuation">}</span><span class="token selector">span</span><span class="token punctuation">{</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> 2rem<span class="token punctuation">;</span>    <span class="token property">line-height</span><span class="token punctuation">:</span>25px<span class="token punctuation">;</span>  <span class="token comment">/* 设置行高（即行间距），常用取值为 25px、28px */</span>    <span class="token comment">/* 设置元素中文本的水平对齐方式，继承给子级 */</span>    <span class="token property">text-align</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token selector">&lt;style type="text/css"&gt;    #p1</span> <span class="token punctuation">{</span>        <span class="token property">text-indent</span><span class="token punctuation">:</span> 2em<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">#p1 &gt; a</span> <span class="token punctuation">{</span>        <span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token comment">/* 设置文本修饰， 常用的取值为underline（下划线）、none  */</span>        <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>        <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">#p1 &gt; a:hover</span> <span class="token punctuation">{</span>        <span class="token property">text-decoration</span><span class="token punctuation">:</span> underline<span class="token punctuation">;</span>        <span class="token property">color</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">.pp2</span> <span class="token punctuation">{</span>        <span class="token property">text-transform</span><span class="token punctuation">:</span> capitalize<span class="token punctuation">;</span>        <span class="token property">word-spacing</span><span class="token punctuation">:</span> 2em<span class="token punctuation">;</span>        <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token comment">/*  设置对齐方式，常用的取值为left、right 以及 center  */</span>    <span class="token punctuation">}</span>    <span class="token selector">.pp3</span> <span class="token punctuation">{</span>        <span class="token property">letter-spacing</span><span class="token punctuation">:</span> 1em<span class="token punctuation">;</span><span class="token comment">/* 设置字符间距，常用的取值为3px、8px */</span>    <span class="token punctuation">}</span>    <span class="token selector">ul</span> <span class="token punctuation">{</span>        <span class="token comment">/*list-style-position: inside;*/</span>        <span class="token comment">/*list-style-type: decimal;*/</span>        <span class="token comment">/*list-style-type: none;*/</span>        <span class="token comment">/*list-style-image: url("img/logo.png");*/</span>        <span class="token comment">/* 列表在设置时,一般会直接把列表项标志设置为none */</span>    <span class="token punctuation">}</span>    <span class="token selector">table</span> <span class="token punctuation">{</span>        <span class="token property">border-collapse</span><span class="token punctuation">:</span> collapse<span class="token punctuation">;</span>        <span class="token comment">/*border-spacing: 10px 15px;*/</span>        <span class="token comment">/*caption-side: bottom;*/</span>       <span class="token comment">/* empty-cells: hide;*/</span>        <span class="token comment">/* 列宽度算法 */</span>        <span class="token comment">/*table-layout: fixed;*/</span>    <span class="token punctuation">}</span>    <span class="token selector">button</span><span class="token punctuation">{</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token comment">/*background-color: transparent;*/</span><span class="token comment">/* 透明 */</span>    <span class="token punctuation">}</span>    <span class="token selector">button:hover</span><span class="token punctuation">{</span>        <span class="token comment">/*outline-style: solid;        outline-width: 2px;        outline-color: red;*/</span>        <span class="token property">outline</span><span class="token punctuation">:</span> green double 3px<span class="token punctuation">;</span>    <span class="token punctuation">}</span>&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="CSS特性"><a href="#CSS特性" class="headerlink" title="CSS特性"></a>CSS特性</h4><p>CSS特性：化简代码 / 定位问题，并解决问题</p><ul><li>继承性：子级默认继承父级的<strong>文字控制属性</strong>。 如果标签有默认文字样式会继承失败。</li><li>层叠性：相同属性后面的覆盖前面的，不同属性叠加。</li><li>优先级：当一个标签<strong>使用了多种选择器时</strong>，基于不同种类的选择器的<strong>匹配规则</strong>。</li></ul><p><strong>基础选择器</strong></p><p>规则：选择器<strong>优先级高的样式生效</strong>。</p><p>公式：<strong>通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内样式 &lt; !important</strong></p><p>​           <strong>（选中标签的范围越大，优先级越低）</strong></p><p><strong>复合选择器-叠加</strong></p><p>叠加计算：如果是复合选择器，则需要<strong>权重叠加</strong>计算。</p><p>公式：（每一级之间不存在进位）</p><img src="/2024/11/18/vue/1680319646205-1732170256083.png" alt="1680319646205" style="zoom:67%;"><p>规则：</p><ul><li>从左向右依次比较选个数，同一级个数多的优先级高，如果个数相同，则向后比较</li><li><strong>!important 权重最高</strong></li><li>继承权重最低</li></ul><h4 id="显示设置"><a href="#显示设置" class="headerlink" title="显示设置"></a>显示设置</h4><p>display 用于设置行内元素的排列。display方向不可以控制。</p><p>float浮动起来的话会脱离标准文档流，所以要解决父级边框塌陷的问题</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span><span class="token comment">/* 块级 */</span><span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span> <span class="token comment">/* 行内块 一行可以显示多个 */</span><span class="token property">display</span><span class="token punctuation">:</span> inline<span class="token punctuation">;</span> <span class="token comment">/* 行内 */</span><span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span> <span class="token comment">/* 独立于底层，设置浮动 */</span><span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span><span class="token property">clear</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span> <span class="token comment">/* 右侧不允许有浮动元素 */</span><span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span> <span class="token comment">/* 两侧都不允许有浮动元素 */</span><span class="token property">clear</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span><span class="token property">clear</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token selector">#d1</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> 2px solid dimgray<span class="token punctuation">;</span>    <span class="token comment">/* overflow 调整内容溢出 */</span>    <span class="token comment">/*overflow: hidden; */</span><span class="token comment">/*隐藏 */</span>    <span class="token comment">/*overflow: scroll;*/</span><span class="token comment">/* 滚动条*/</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token comment">/* 自动添加滚动条 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>盒子模型：即边距margin，边框border，填充padding，和实际内容。</p><p>外边距设置居中：margin: auto;（前提该标签需要在一个块元素内，即要有边界）</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">    <span class="token selector">&lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style type="text/css"&gt;        .div01</span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span><span class="token comment">/* width,height仅仅设置内容区域 */</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 2em 4em<span class="token punctuation">;</span><span class="token comment">/* padding是简写,简写了四个方向 */</span>            <span class="token comment">/* 如果是给1个值 那就是 4个方向都设置 */</span>            <span class="token comment">/* 如果给2个值 第一个值是 上下 第二个值是 左右 */</span>            <span class="token comment">/* 如果给3个值 第一个值是 上 第二个值 左右 第三个值 下 */</span>            <span class="token comment">/* 如果给4个值 分别是 上 右 下 左 顺时针 */</span>            <span class="token property">border</span><span class="token punctuation">:</span> 2px solid red<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector">span</span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token comment">/* 行级元素的 宽高属性 无效,根据内容的大小自动调整的 */</span>        <span class="token punctuation">}</span>        <span class="token selector">#span2</span><span class="token punctuation">{</span>            <span class="token comment">/*border: 10px solid red;*/</span><span class="token comment">/* 边框可以调整左右,上下不建议调整 */</span>            <span class="token comment">/*padding: 20px;*/</span><span class="token comment">/* 内填充可以调整左右,上下不建议调整 */</span>            <span class="token comment">/*margin: 20px;*/</span><span class="token comment">/* 外边距可以调整左右,上下不建议调整 */</span>            <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 2px solid purple<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector">.div01:first-child</span><span class="token punctuation">{</span>            <span class="token property">border</span><span class="token punctuation">:</span>2px solid blue<span class="token punctuation">;</span>            <span class="token property">margin</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span>            <span class="token comment">/* padding margin border 都可以写 xxx-方向 */</span>        <span class="token punctuation">}</span>    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;   &lt;!-- div 块级标签 没有任何显示效果<span class="token punctuation">,</span>需要结合css盒子模型属性的调整 --&gt;   &lt;div class=<span class="token string">"div01"</span> style=<span class="token string">"display: none"</span>&gt;       这是内容!   &lt;/div&gt;   &lt;div class=<span class="token string">"div01"</span> style=<span class="token string">"display: inline"</span>&gt;       这是内容!   &lt;/div&gt;   &lt;!-- 盒子模型/框模型 在 行级元素里的部分 不建议调整 --&gt;   &lt;span id=<span class="token string">"span1"</span>&gt;span1&lt;/span&gt;&lt;span id=<span class="token string">"span2"</span>&gt;span2&lt;/span&gt;&lt;span id=<span class="token string">"span3"</span>&gt;span3&lt;/span&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>文档流：默认的摆放形式，行级和行级在一行，实在放不下就换行，块级独占一行</p><ul><li>相对定位relative：相对于 自身加载的原始位置 的 定位 原来的位置是被保留的</li><li>绝对定位absolute：相对于 已经定位的父元素 的 定位 原来的位置不被保留.</li><li>固定定位fixed：相对于 视窗(浏览器窗口) 原来的位置不被保留.</li></ul><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">#move</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>    <span class="token comment">/* 固定定位 */</span>    <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> -1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#outer</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token comment">/* 相对定位 */</span>    <span class="token property">left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> <span class="token comment">/* 定位之后的位置 左边 100px 是原来的位置 */</span>    <span class="token property">top</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> <span class="token comment">/* 定位之后的位置 上边100px 是原来的位置 */</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> -1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#outer2</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span><span class="token comment">/* 绝对定位 父亲是body */</span>    <span class="token property">left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> -2<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript是一种基于<strong>对象和事件驱动</strong>的脚本语言，作用是给网页添加交互功能和动态效果。它可以操作网页元素、响应用户操作、发送网络请求、处理数据等。JavaScript使得网页具有更高级的交互性和动态性，可以实现表单验证、页面动画、实时数据更新等。</p><p>html中使用js有三种,标签内,内部,外部 使用js一般是两种,也就是内部和外部</p><p>标签内：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>javascript:alert('这是js的信息弹框!这样的用法几乎不使用')<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点我弹出一个信息框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内部：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>...  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">        <span class="token comment">/* 脚本 */</span>       <span class="token comment">/* alert("js的弹框000");*/</span>        <span class="token comment">//js 里函数 就是 java里的方法</span>        <span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'show方法里的弹框!'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>    通过在标签上的 事件动作 on在click点击 的时候 执行 js函数 show()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>外部：</p><p>把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。外部 JavaScript 文件的文件扩展名是 .js。如需使用外部文件，请在 &lt;script&gt; 标签的 “src” 属性中设置该 .js 文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myScript.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="JS输出"><a href="#JS输出" class="headerlink" title="JS输出"></a>JS输出</h4><p>JavaScript 可以通过不同的方式来输出数据：</p><ul><li>使用 <strong>window.alert()</strong> 弹出警告框。</li><li>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中。</li><li>使用 <strong>innerHTML</strong> 写入到 HTML 元素：如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(<em>id</em>) 方法。请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容</li><li>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>在编程语言中，一般固定值称为字面量，如 3.14。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">3.14</span>  <span class="token number">1001</span>  <span class="token number">123e5</span><span class="token string">"John Doe"</span>  <span class="token string">'John Doe'</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token literal-property property">firstName</span><span class="token operator">:</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token literal-property property">lastName</span><span class="token operator">:</span><span class="token string">"Doe"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token literal-property property">eyeColor</span><span class="token operator">:</span><span class="token string">"blue"</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 对象寻址方式</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">firstName</span><span class="token operator">:</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token literal-property property">lastName</span><span class="token operator">:</span><span class="token string">"Doe"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token literal-property property">eyeColor</span><span class="token operator">:</span><span class="token string">"blue"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>name <span class="token operator">=</span> person<span class="token punctuation">.</span>lastname<span class="token punctuation">;</span>name <span class="token operator">=</span> person<span class="token punctuation">[</span><span class="token string">"lastname"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript 使用关键字 <strong>var</strong> 来定义变量， 使用等号来为变量赋值。变量可以通过变量名访问。在指令式语言中，变量通常是可变的。字面量是一个恒定的值。</p><ul><li>js里语句最后的分号可加可不加</li><li>使用关键字 var let 可以声明变量,const声明常量<ul><li>var声明的变量 为 js顶级对象window的属性,为全局变量</li><li>let声明的变量 为 局部变量</li></ul></li></ul><p>**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。</p><p><strong>引用数据类型（对象类型）</strong>：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。</p><p>流程控制</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//遍历</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'============='</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//iter</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'============'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//forin</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'-------------'</span><span class="token punctuation">)</span><span class="token comment">//对象</span><span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'jacky'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    <span class="token literal-property property">gender</span><span class="token operator">:</span> <span class="token string">'男'</span><span class="token punctuation">,</span>    <span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token string">"长大"</span><span class="token punctuation">,</span>    <span class="token function-variable function">study</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"学习学习"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//for-in可以去遍历对象,遍历对象的时候,对象类似一个Map集合  let变量 是 键</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> stuKey <span class="token keyword">in</span> stu<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">[</span>stuKey<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 错误处理</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name <span class="token operator">+</span> person<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里有错误</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Map，Set：ES6新特性  Map,同java里的Map  js里只有这两个数组和集合</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"tom"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"okk"</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token number">10</span>map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"ggz"</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token parameter"><span class="token number">4</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token string">'tom'</span> <span class="token operator">=&gt;</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'jack'</span> <span class="token operator">=&gt;</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">'okk'</span> <span class="token operator">=&gt;</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">'ggz'</span> <span class="token operator">=&gt;</span> <span class="token number">8</span><span class="token punctuation">}</span>idea书写<span class="token keyword">var</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"tom"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"okk"</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">var</span> age1 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"qqz"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  是一个无序集合set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  添加set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  是否包含元素set<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  删除set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>array</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"lucy"</span><span class="token punctuation">,</span><span class="token string">"jacky"</span><span class="token punctuation">,</span><span class="token string">"candy"</span><span class="token punctuation">,</span><span class="token string">"joe"</span><span class="token punctuation">,</span><span class="token string">"tom"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">len3</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span>length<span class="token operator">&gt;=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span>len3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对数组的每一个数据 调用 len3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span>length<span class="token operator">&gt;=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对数组的每一个数据 调用 判断 长度是否&gt;=3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span>length<span class="token operator">===</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//过滤 得到 数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查找 只返回 第一个de 下标</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"^_^"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数组类的工具方法,从某个数组,经过某个计算,得到新数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"~"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用连接符把数组里的每个数据连接起来返回字符串</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"-_-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数组里的每个数据 进行映射 映射为新数组</span><span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">,</span><span class="token string">"show"</span><span class="token punctuation">,</span><span class="token string">"say"</span><span class="token punctuation">,</span><span class="token string">"setColor"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//弹栈,从数组末尾删除 并得到数据</span><span class="token punctuation">}</span><span class="token keyword">let</span> stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>stack2<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"="</span><span class="token operator">+</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//压栈,将数据添加到数组的末尾</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//total默认是第一个值 name是后面的每一个值,初始化total要放在reduce()中,不能放在log()中</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span>name</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token keyword">return</span> total<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"名字大联合:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span>name</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token keyword">return</span> total<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">,</span><span class="token string">"小妹"</span><span class="token punctuation">,</span><span class="token string">"小梅"</span><span class="token punctuation">,</span><span class="token string">"黎明"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"买饭要排队:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从数组开头删除 并 返回数据</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"部分人员名单:"</span><span class="token operator">+</span>names<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从倒数第二个开始 直到最后</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"部分人员名单:"</span><span class="token operator">+</span>names<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开始的下标 结束的下标(不包括)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"j"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查找有没有一个数组的数据 符合 开头是j</span><span class="token comment">//let names = ["lucy","jacky","candy","joe","tom"];</span><span class="token comment">//splice 先删除 后添加</span><span class="token comment">/*names.splice(1,1,"小李","桃子")console.log(names);*/</span><span class="token operator">/</span><span class="token operator">/</span>在<span class="token number">1</span>下标处删除数据<span class="token punctuation">,</span>添加 后面的两个数据<span class="token punctuation">,</span>此方法会得到 删除的数据names<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"小小船"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在1小标出删除0个数据,添加后面1个数据</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//['lucy', '小小船', 'jacky', 'candy', 'joe', 'tom']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>    函数的定义方式一    <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>        <span class="token comment">//执行到retuen代表函数结束，返回结果，</span>        <span class="token comment">//如果没有执行return，函数执行完也会返回结果，结果为undefined</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>    函数的定义方式二    <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token comment">//这种形式就是把function (x)当成匿名内部类，但是可以把该类赋值给一个变量，通过变量调用函数</span><span class="token keyword">var</span> <span class="token function-variable function">abs2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>    规避参数不存在和多个参数问题    <span class="token operator">--</span><span class="token operator">&gt;</span>参数不存在时可设置抛出异常  ，<span class="token keyword">typeof</span>可判断变量类型<span class="token keyword">var</span> <span class="token function-variable function">abs3</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">!=</span><span class="token string">"number"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token string">"Not a Number"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>对于参数过长<span class="token comment">// es5所用方法，arguments关键子，代表一个数组，会把所有传进来的参数都放到里面</span><span class="token keyword">var</span> <span class="token function-variable function">abs4</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//e6所用方法，rest关键子，剩余的，会把除定义的参数外其他所有传进来的参数都放到里面。...在java代表可变参数</span><span class="token keyword">var</span> <span class="token function-variable function">abs5</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token operator">...</span>rest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>HTML 事件是发生在 HTML 元素上的事情。当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。HTML 元素中可以添加事件属性，使用 JavaScript 代码来添加 HTML 元素。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'demo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>现在的时间是?<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>现在的时间是?<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th align="left">事件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">onchange</td><td align="left">HTML 元素改变</td></tr><tr><td align="left">onclick</td><td align="left">用户点击 HTML 元素</td></tr><tr><td align="left">onmouseover</td><td align="left">鼠标指针移动到指定的元素上时发生</td></tr><tr><td align="left">onmouseout</td><td align="left">用户从一个 HTML 元素上移开鼠标时发生</td></tr><tr><td align="left">onkeydown</td><td align="left">用户按下键盘按键</td></tr><tr><td align="left">onload</td><td align="left">浏览器已完成页面的加载</td></tr></tbody></table><p>更多事件：<a href="https://www.runoob.com/jsref/dom-obj-event.html">HTML DOM 事件对象 | 菜鸟教程</a></p><p>事件可以用于处理表单验证，用户输入，用户行为及浏览器动作:</p><ul><li>页面加载时触发事件</li><li>页面关闭时触发事件</li><li>用户点击按钮执行动作</li><li>验证用户输入内容的合法性……</li></ul><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p>HTML 表单验证可以通过 JavaScript 来完成。</p><p>以下实例代码用于判断表单字段(fname)值是否存在， 如果不存在，就弹出信息，阻止表单提交：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">validateForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x <span class="token operator">=</span> document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token string">"myForm"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"fname"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> x <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"需要输入名字。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myForm<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo_form.php<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onsubmit</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token keyword">return</span> <span class="token function">validateForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    名字: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fname<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>提交<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>数据验证用于确保用户输入的数据是有效的。典型的数据验证有：</p><ul><li>必需字段是否有输入?</li><li>用户是否输入了合法的数据?</li><li>在数字字段是否输入了文本?</li></ul><p>大多数情况下，数据验证用于确保用户正确输入数据。数据验证可以使用不同方法来定义，并通过多种方式来调用。</p><p><strong>服务端数据验证</strong>是在数据提交到服务器上后再验证。<strong>客户端数据验证</strong>是在数据发送到服务器前，在浏览器上完成验证。</p><p>HTML5 新增了 HTML 表单的验证方式：约束验证（constraint validation）。约束验证是表单被提交时浏览器用来实现验证的一种算法。</p><p>HTML 约束验证基于：</p><ul><li><strong>HTML 输入属性</strong></li><li><strong>CSS 伪类选择器</strong></li><li><strong>DOM 属性和方法</strong></li></ul><p>约束验证 HTML 输入属性</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">disabled</td><td align="left">规定输入的元素不可用</td></tr><tr><td align="left">max</td><td align="left">规定输入元素的最大值</td></tr><tr><td align="left">min</td><td align="left">规定输入元素的最小值</td></tr><tr><td align="left">pattern</td><td align="left">规定输入元素值的模式</td></tr><tr><td align="left">required</td><td align="left">规定输入元素字段是必需的</td></tr><tr><td align="left">type</td><td align="left">规定输入元素的类型</td></tr></tbody></table><p>约束验证DOM方法：</p><ul><li>checkValidity()：如果 input 元素中的数据是合法的返回 true，否则返回 false。</li><li>setCustomValidity()：设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。</li></ul><p>input 元素的 <strong>validity 属性</strong>包含一系列关于 validity 数据属性:</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">customError</td><td align="left">设置为 true, 如果设置了自定义的 validity 信息。</td></tr><tr><td align="left">patternMismatch</td><td align="left">设置为 true, 如果元素的值不匹配它的模式属性。</td></tr><tr><td align="left">rangeOverflow</td><td align="left">设置为 true, 如果元素的值大于设置的最大值。</td></tr><tr><td align="left">rangeUnderflow</td><td align="left">设置为 true, 如果元素的值小于它的最小值。</td></tr><tr><td align="left">stepMismatch</td><td align="left">设置为 true, 如果元素的值不是按照规定的 step 属性设置。</td></tr><tr><td align="left">tooLong</td><td align="left">设置为 true, 如果元素的值超过了 maxLength 属性设置的长度。</td></tr><tr><td align="left">typeMismatch</td><td align="left">设置为 true, 如果元素的值不是预期相匹配的类型。</td></tr><tr><td align="left">valueMissing</td><td align="left">设置为 true，如果元素 (required 属性) 没有值。</td></tr><tr><td align="left">valid</td><td align="left">设置为 true，如果元素的值是合法的。</td></tr></tbody></table><p>例如：如果输入的值大于 100，显示一个信息</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"id1"</span> type<span class="token operator">=</span><span class="token string">"number"</span> max<span class="token operator">=</span><span class="token string">"100"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>button onclick<span class="token operator">=</span><span class="token string">"myFunction()"</span><span class="token operator">&gt;</span>验证<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">"demo"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> txt <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"id1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>validity<span class="token punctuation">.</span>rangeOverflow<span class="token punctuation">)</span> <span class="token punctuation">{</span>       txt <span class="token operator">=</span> <span class="token string">"输入的值太大了"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> txt<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>文档对象，每个网页都是一个DOM树形结构（HTML 文档中的所有内容都是节点），可以对它进行增删改查操作</p><p>增删改查：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//获取各个节点</span>document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'p2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取父节点</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'f1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取父节点下所有子节点</span>f1<span class="token punctuation">.</span>children<span class="token comment">// 删除dom</span><span class="token comment">//删除父节点下的一个子节点，需要先获取父节点，再删除子节点</span><span class="token keyword">var</span> son <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> father <span class="token operator">=</span> p1<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>father<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 更新dom</span><span class="token comment">//首先获取到一个节点</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'dom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//操作文本节点,需要全部使用冒号</span>dom<span class="token punctuation">.</span>innerText<span class="token operator">=</span><span class="token string">'123'</span><span class="token punctuation">;</span><span class="token comment">//操作html节点</span>dom<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">'888nbsp;999'</span><span class="token comment">//操作js节点</span>dom<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">;</span>dom<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize<span class="token operator">=</span><span class="token string">'100px'</span><span class="token punctuation">;</span><span class="token comment">// 插入dom</span><span class="token keyword">var</span> s1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'s1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> s2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'s2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//append插入一个已存在的节点</span>s2<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//插入一个新的节点</span><span class="token keyword">var</span> s5 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//新建一个空的p标签，这个标签叫s5，&lt;p&gt;</span>s5<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'s5'</span><span class="token punctuation">;</span> <span class="token comment">//给s5这个标签设置id为s5</span>s5<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'这是新建的一个p标签'</span><span class="token punctuation">;</span> <span class="token comment">//给s5设置内容</span>s2<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>s5<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span>   <span class="token comment">// 1 dom 获取 name属性是hobby 的4个input对象 组合的数组 的长度  把他弹出!</span>   <span class="token comment">// 2 修改 .hh2 的h2 标题 的 文本内容为   "我的标题2"</span>   <span class="token comment">// 3 将 #zstd 单元格 所在行 文本居中.</span>   <span class="token comment">// 4 鼠标悬浮到表格上时  #myjava 被选择!</span>   <span class="token comment">//文档加载完毕,才去执行,这样就能获得html内容了</span>   window<span class="token punctuation">.</span><span class="token function-variable function">onload</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">"hobby"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"hh2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">"我的标题2"</span><span class="token punctuation">;</span><span class="token comment">//这里也可以写innerHTML(标签,文本)</span>      <span class="token comment">//原生的css里是text-align js里变为驼峰了</span>      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"zstd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>textAlign <span class="token operator">=</span> <span class="token string">"center"</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"table"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onmouseover</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"myjava"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>checked<span class="token operator">=</span><span class="token string">"checked"</span><span class="token punctuation">;</span><span class="token comment">//true 修改浏览器内存里的对象属性 及时的反应在浏览效果上</span>         <span class="token comment">//document.getElementById("myjava").setAttribute("checked","checked");//修改源码里的对象的属性</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span class="token comment">// 事件</span><span class="token comment">//move是js里 封装的 事件对象,有很多属性可以调用,有阻止默认行为的方法</span><span class="token keyword">function</span> <span class="token function">momo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//circle跟随鼠标移动而移动!</span>   <span class="token comment">//鼠标指针的坐标</span>   <span class="token keyword">let</span> x <span class="token operator">=</span> event<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span><span class="token comment">//event为内置对象</span>   <span class="token keyword">let</span> y <span class="token operator">=</span> event<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"circle"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">50</span><span class="token operator">+</span><span class="token string">"px"</span><span class="token punctuation">;</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"circle"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> y <span class="token operator">-</span> <span class="token number">50</span><span class="token operator">+</span><span class="token string">"px"</span><span class="token punctuation">;</span><span class="token comment">//?????????????????????????</span><span class="token punctuation">}</span><span class="token comment">//演示 event对象 的 阻止默认行为的 方法</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"a1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">"确定要打开百度吗?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">===</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"province"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onchange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"你选择的省份: "</span><span class="token operator">+</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"province"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onfocus</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">"red"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onblur</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 导入 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../../lib/jquery-3.7.1.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 使用 --&gt;</span><span class="token comment">&lt;!-- 1.先创建一个标签--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jquery<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击事件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token number">2.</span>通过jquery进行操作   <span class="token operator">--</span><span class="token operator">&gt;</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#jquery'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//先选择这个id标签，再操作一个事件，这里操作的是点击事件click，事件里面有个函数</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'hello,jquery'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>u1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>u2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>ggz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>u3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>xmm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>u4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>qqz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token comment">// jquery获取值和设置值,都要加''</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#u1 li[id=u2]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">'jjz999'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'u3'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#u1 li[name=u4]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 操作css</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#u1 li[class=u3]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string-property property">"color"</span><span class="token operator">:</span><span class="token string">"red"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string-property property">"background"</span><span class="token operator">:</span><span class="token string">"blue"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#u2'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string-property property">"fontSize"</span><span class="token operator">:</span><span class="token string">"50px"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment">// 文档的显示与隐藏，先设置display: none;，再对某标签进行隐藏和显示</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#ul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#ul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Vue-1"><a href="#Vue-1" class="headerlink" title="Vue"></a>Vue</h2><p>Vue是一个构建用户界面UI的<strong>渐进式javascript框架</strong>，渐进式的框架是指可以一步一步的由浅入深的去使用这个框架，该框架可以逐步引入项目。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><p>Vue2官网（已停止维护）：<a href="https://v2.cn.vuejs.org/">https://v2.cn.vuejs.org/</a>。Vue2教程：<a href="https://v2.cn.vuejs.org/v2/guide/">介绍 — Vue.js</a></p><h3 id="创建Vue实例"><a href="#创建Vue实例" class="headerlink" title="创建Vue实例"></a>创建Vue实例</h3><ol><li>准备容器</li><li>引包（官网） — 开发版本/生产版本</li><li>创建Vue实例  new Vue()</li><li>指定配置项，渲染数据<ol><li>el：指定挂载点，即Vue所管理的容器</li><li>data：提供数据，使用插值表达式可以渲染出Vue提供的数据</li></ol></li></ol><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--   创建Vue实例，初始化渲染  1. 准备容器 (Vue所管理的范围)  2. 引包 (开发版本包 / 生产版本包) 官网  3. 创建实例  4. 添加配置项 =&gt; 完成渲染--&gt; &lt;!-- 不是Vue管理的范围 --&gt;&lt;div class="box2"&gt;  box2 -- {{ count }}&lt;/div&gt;&lt;div class="box"&gt;  box -- {{ msg }}&lt;/div&gt;-----------------------------------------------------&lt;!-- Vue所管理的范围 --&gt;&lt;div id="app"&gt;  &lt;!-- 插值表达式{{data}}，渲染data中的数据 --&gt;  &lt;h1&gt;{{ msg }}&lt;/h1&gt;  &lt;a href="#"&gt;{{ count }}&lt;/a&gt;&lt;/div&gt; &lt;!-- 引入的是开发版本包 - 包含完整的注释和警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"&gt;&lt;/script&gt; &lt;script&gt;  // 一旦引入 VueJS核心包，在全局环境，就有了 Vue 构造函数  const app = new Vue({    // 通过 el 配置选择器，指定 Vue 管理的是哪个盒子（这里app对应上面div id=app）    el: '#app',    // 通过 data 提供数据    data: {      msg: 'Hello 传智播客',      count: 666    }  }) &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="响应式特性"><a href="#响应式特性" class="headerlink" title="响应式特性"></a>响应式特性</h3><p>Vue 核心特性：响应式：<strong>数据变化，视图自动更新</strong>，数据驱动视图</p><img src="/2024/11/18/vue/1681888539340.png?lastModify=1733991844" alt="68188853934" style="zoom:67%;"><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><strong>概念：</strong>指令（Directives）是 Vue 提供的带有 <strong>v- 前缀</strong> 的 特殊 标签<strong>属性</strong>。Vue 会根据不同的指令，针对标签实现不同的功能</p><p>vue 中的指令按照不同的用途可以分为如下 6 大类：</p><ul><li>内容渲染指令（v-html、v-text）</li><li>条件渲染指令（v-show、v-if、v-else、v-else-if）</li><li>事件绑定指令（v-on）</li><li>属性绑定指令 （v-bind）</li><li>双向绑定指令（v-model）</li><li>列表渲染指令（v-for）</li></ul><h4 id="v-text-内容渲染"><a href="#v-text-内容渲染" class="headerlink" title="v-text 内容渲染"></a>v-text 内容渲染</h4><p>内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下2 个：</p><ul><li><p>v-text（类似innerText）</p></li><li><ul><li>使用语法：<code>&lt;p v-text="uname"&gt;hello&lt;/p&gt;</code>，意思是将 uame 值渲染到 p 标签中</li><li>类似 innerText，使用该语法，会覆盖 p 标签原有内容</li></ul></li><li><p>v-html（类似 innerHTML）</p></li><li><ul><li>使用语法：<code>&lt;p v-html="intro"&gt;hello&lt;/p&gt;</code>，意思是将 intro 值渲染到 p 标签中</li><li>类似 innerHTML，使用该语法，会覆盖 p 标签原有内容</li><li>类似 innerHTML，使用该语法，能够将HTML标签的样式呈现出来。</li></ul></li></ul><p>代码演示：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>个人信息<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span><span class="token comment">// 既然指令是vue提供的特殊的html属性，所以咱们写的时候就当成属性来用即可</span><span class="token operator">&lt;</span>p v<span class="token operator">-</span>text<span class="token operator">=</span><span class="token string">"uname"</span><span class="token operator">&gt;</span>姓名：<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>p v<span class="token operator">-</span>html<span class="token operator">=</span><span class="token string">"intro"</span><span class="token operator">&gt;</span>简介：<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>        <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">{</span>            <span class="token literal-property property">uname</span><span class="token operator">:</span><span class="token string">'张三'</span><span class="token punctuation">,</span>            <span class="token literal-property property">intro</span><span class="token operator">:</span><span class="token string">'&lt;h2&gt;这是一个&lt;strong&gt;非常优秀&lt;/strong&gt;的boy&lt;h2&gt;'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="v-if-条件渲染"><a href="#v-if-条件渲染" class="headerlink" title="v-if 条件渲染"></a>v-if 条件渲染</h4><ol><li><p><code>v-show</code> 原理是切换 <code>display:none</code> 控制元素显示隐藏。适合频繁切换显示隐藏的场景 </p><p>（v-show = “表达式”   表达式值为 true 显示， false 隐藏）</p></li><li><p><code>v-if</code>  基于条件判断，是否创建 或 移除元素节点。要么显示，要么隐藏，适合不频繁切换的场景</p></li></ol><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;h3 v-if="age &lt; 18"&gt;young&lt;/h3&gt;&lt;h3 v-else-if="age &lt; 40"&gt;mid&lt;/h3&gt;&lt;h3 v-else&gt;old&lt;/h3&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="v-on-事件绑定"><a href="#v-on-事件绑定" class="headerlink" title="v-on 事件绑定"></a>v-on 事件绑定</h4><ul><li>&lt;button v-on:事件名=”内联语句”&gt;按钮</li><li>&lt;button v-on:事件名=”处理函数”&gt;按钮</li><li>&lt;button v-on:事件名=”处理函数(实参)”&gt;按钮</li><li><code>v-on:</code> 简写为 <strong>@</strong></li></ul><p>双击事件：@dblclick</p><p>失去焦点事件：@blur</p><p>输入框内容改变、下拉列表改变：@change</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;button v-on:click="count++"&gt;按钮&lt;/button&gt; &lt;button @click="fn"&gt;按钮&lt;/button&gt;&lt;button @click="fn(a,b)"&gt;按钮&lt;/button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>v-on配置methods函数</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;body&gt;  &lt;div id="app"&gt;    &lt;button @click="fn"&gt;切换显示隐藏&lt;/button&gt;    &lt;h1 v-show="isShow"&gt;黑马程序员&lt;/h1&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    const app4 = new Vue({      el: '#app',      data: {        isShow: true      },      methods: {        fn () {          // 让提供的所有methods中的函数，this都指向当前实例          // console.log('执行了fn', app.isShow)          // console.log(app3 === this)          this.isShow = !this.isShow        }      }    })  &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数传递</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;body&gt;   &lt;div id="app"&gt;    &lt;div class="box"&gt;      &lt;h3&gt;小黑自动售货机&lt;/h3&gt;      &lt;button @click="buy(5)"&gt;可乐5元&lt;/button&gt;      &lt;button @click="buy(10)"&gt;咖啡10元&lt;/button&gt;      &lt;button @click="buy(8)"&gt;牛奶8元&lt;/button&gt;    &lt;/div&gt;    &lt;p&gt;银行卡余额：{{ money }}元&lt;/p&gt;  &lt;/div&gt;   &lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue({      el: '#app',      data: {        money: 100      },      methods: {        buy (price) {          this.money -= price        }      }    })  &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="v-bind-属性绑定"><a href="#v-bind-属性绑定" class="headerlink" title="v-bind 属性绑定"></a>v-bind 属性绑定</h4><p>**v-bind:**属性名=“表达式”。动态设置html的标签属性 比如：src、url、title</p><ol><li>**v-bind:**可以简写成 =&gt;   <strong>:</strong></li></ol><p>比如，有一个图片，它的 <code>src</code> 属性值，是一个图片地址。这个地址在数据 data 中存储。</p><p>则可以这样设置属性值：</p><ul><li><code>&lt;img v-bind:src="url" /&gt;</code></li><li><code>&lt;img :src="url" /&gt;</code>   （v-bind可以省略）</li></ul><h5 id="v-bind增强"><a href="#v-bind增强" class="headerlink" title="v-bind增强"></a>v-bind增强</h5><p>为了方便开发者进行样式控制， Vue 扩展了 v-bind 的语法，可以针对 <strong>class 类名</strong> 和 <strong>style 行内样式</strong> 进行控制 。</p><p>当class<strong>动态绑定</strong>的是<strong>对象</strong>时，<strong>键就是类名，值就是布尔值</strong>，如果值是<strong>true</strong>，就有这个类，否则没有这个类</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{ 类名1: 布尔值, 类名2: 布尔值 }<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    适用场景：一个类名，来回切换</p><p>当class动态绑定的是<strong>数组</strong>时 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>[ 类名1, 类名2, 类名3 ]<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   使用场景：批量添加或删除类</p><p>操作style</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;div class="box" :style="{ CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 }"&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="v-for-列表渲染"><a href="#v-for-列表渲染" class="headerlink" title="v-for 列表渲染"></a>v-for 列表渲染</h4><p>v-for 基于数据循环，多次渲染整个元素</p><p>v-for 指令需要使用 <code>(item, index) in arr</code> 形式的特殊语法，其中：</p><ul><li>item 是数组中的每一项</li><li>index 是每一项的索引，不需要可以省略</li><li>arr 是被遍历的数组</li></ul><p>此语法也可以遍历<strong>对象和数字</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;ul&gt;  // key作用：给元素添加的唯一标识，便于Vue进行列表项的正确排序复用  &lt;li v-for="(item,index) in booksList" :key="item.id"&gt;     &lt;span&gt;{{ item.name }}&lt;/span&gt;    &lt;span&gt;{{ item.author }}&lt;/span&gt;  &lt;/li&gt;&lt;/ul&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="v-model-双向绑定"><a href="#v-model-双向绑定" class="headerlink" title="v-model 双向绑定"></a>v-model 双向绑定</h4><p>v-model 用于表单元素。所谓双向绑定就是：</p><ol><li>数据改变后，呈现的页面结果会更新</li><li>页面结果更新后，数据也会随之而变</li></ol><p><strong>作用：</strong> 给<strong>表单元素</strong>（input、radio、select）使用，双向绑定数据，可以快速 <strong>获取</strong> 或 <strong>设置</strong> 表单元素内容</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    账户：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    密码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>login<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>重置<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>      <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>        <span class="token literal-property property">password</span><span class="token operator">:</span> <span class="token string">''</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token function">login</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>username<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>password<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">reset</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> <span class="token string">''</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> <span class="token string">''</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="v-model增强"><a href="#v-model增强" class="headerlink" title="v-model增强"></a>v-model增强</h5><p>常见的表单元素都可以用 <code>V-model</code> 绑定关联  →  快速 <strong>获取</strong> 或 <strong>设置</strong> 表单元素的值</p><p>会根据控件类型自动选取正确的方法来更新元素</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;input type="checkbox" v-model="isSingle"&gt; &lt;input v-model="gender" type="radio" name="gender" value="1"&gt;男&lt;input v-model="gender" type="radio" name="gender" value="2"&gt;女&lt;select v-model="cityId"&gt;&lt;option value="101"&gt;北京&lt;/option&gt;&lt;option value="102"&gt;上海&lt;/option&gt;&lt;/select&gt;const app = new Vue({  el: '#app',  data: {    isSingle: false,    gender: "1",    cityId: '101',  }})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指令修饰符"><a href="#指令修饰符" class="headerlink" title="指令修饰符"></a>指令修饰符</h4><p>所谓指令修饰符就是通过“.”指明一些指令<strong>后缀</strong> 不同的<strong>后缀</strong>封装了不同的处理操作  —&gt; 简化代码</p><p><code>@keyup.enter</code> 键盘回车enter键监听</p><p><code>v-model.trim</code> 去除首尾空格</p><p><code>v-model.number</code> 转数字</p><p><code>@click.stop</code> 阻止冒泡</p><h4 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h4><p>基于<strong>现有的数据</strong>，计算出来的<strong>新属性</strong>。 <strong>依赖</strong>的数据变化，<strong>自动</strong>重新计算。</p><ol><li>声明在 <strong>computed 配置项</strong>中，一个计算属性对应一个函数</li><li>使用起来和普通属性一样使用  </li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token function">计算属性名</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>基于现有数据，编写求值逻辑<span class="token keyword">return</span> 结果<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;body&gt;  &lt;div id="app"&gt;    &lt;h3&gt;小黑的礼物清单&lt;/h3&gt;    &lt;table&gt;      &lt;tr&gt;        &lt;th&gt;名字&lt;/th&gt;        &lt;th&gt;数量&lt;/th&gt;      &lt;/tr&gt;      &lt;tr v-for="(item, index) in list" :key="item.id"&gt;        &lt;td&gt;{{ item.name }}&lt;/td&gt;        &lt;td&gt;{{ item.num }}个&lt;/td&gt;      &lt;/tr&gt;    &lt;/table&gt;    &lt;!-- 目标：统计求和，求得礼物总数 --&gt;    &lt;p&gt;礼物总数：{{ totalCount }} 个&lt;/p&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue({      el: '#app',      data: {        // 现有的数据        list: [          { id: 1, name: '篮球', num: 1 },          { id: 2, name: '玩具', num: 2 },          { id: 3, name: '铅笔', num: 5 },        ]      },      computed:{        //注意是属性不是函数        totalCount(){          //0表示求和起始值，reduce遍历list，将每个item的值加上后返回给sum          let total= this.list.reduce((sum, item) =&gt; sum + item.num, 0)          return total        }      }    })  &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>computed计算属性</strong><br>作用：封装了一段对于<strong>数据</strong>的处理，求得一个<strong>结果</strong><br>缓存特性：计算属性会对计算出来的<strong>结果缓存</strong>，再次使用直接读取缓存，依赖项变化了，会<strong>自动</strong>重新计算 -&gt; 并<strong>再次缓存</strong></li><li><strong>methods方法：</strong><br>作用：给实例提供一个<strong>方法</strong>，调用以处理<strong>业务逻辑</strong></li></ul><h4 id="watch侦听器（监视器）"><a href="#watch侦听器（监视器）" class="headerlink" title="watch侦听器（监视器）"></a>watch侦听器（监视器）</h4><p><strong>监视数据变化</strong>，执行一些业务逻辑或异步操作</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>   words<span class="token operator">:</span> <span class="token string">'苹果'</span><span class="token punctuation">,</span>  obj<span class="token operator">:</span> <span class="token punctuation">{</span>    words<span class="token operator">:</span> <span class="token string">'苹果'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 该方法会在数据变化时，触发执行</span>  <span class="token function">数据属性名</span> <span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    一些业务逻辑 或 异步操作。   <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">'对象.属性名'</span> <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    一些业务逻辑 或 异步操作。   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;body&gt;    &lt;div id="app"&gt;        &lt;!-- 条件选择框 --&gt;        &lt;div class="query"&gt;            &lt;span&gt;翻译成的语言：&lt;/span&gt;            &lt;select&gt;                &lt;option value="italy"&gt;意大利&lt;/option&gt;                &lt;option value="english"&gt;英语&lt;/option&gt;                &lt;option value="german"&gt;德语&lt;/option&gt;            &lt;/select&gt;        &lt;/div&gt;        &lt;!-- 翻译框 --&gt;        &lt;div class="box"&gt;            &lt;div class="input-wrap"&gt;                &lt;textarea v-model="obj.words"&gt;&lt;/textarea&gt;                &lt;span&gt;&lt;i&gt;⌨️&lt;/i&gt;文档翻译&lt;/span&gt;            &lt;/div&gt;            &lt;div class="output-wrap"&gt;                &lt;div class="transbox"&gt;{{ result }}&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"&gt;&lt;/script&gt;    &lt;script&gt;        // 接口地址：https://applet-base-api-t.itheima.net/api/translate        // 请求方式：get        // 请求参数：        // （1）words：需要被翻译的文本（必传）        // （2）lang： 需要被翻译成的语言（可选）默认值-意大利        // -----------------------------------------------        const app = new Vue({            el: '#app',            data: {                // words: ''                obj: {                    words: ''                },                result:'',//翻译结果                timer: null            },            // 具体讲解：(1) watch语法 (2) 具体业务实现            watch: {                // 该方法会在数据变化时调用执行                // newValue新值, oldValue老值（一般不用）                // words (newValue) {                //   console.log('变化了', newValue)                // }                'obj.words' (newValue) {                    //console.log('变化了', newValue)                    //防抖：延迟执行 -&gt; 干啥事先等一等，延迟一会，一段时间内没有再次触发，才执行                    clearTimeout(this.timer)                    this.timer = setTimeout(async () =&gt; {                        //这里是ajax的内容                        const res = await axios({                            url: 'https://applet-base-api-t.itheima.net/api/translate',                            params:{                                words:newValue                            }                        })                        this.result = res.data.data                         console.log(res.data.data)                    }, 300)                }            }        })    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整写法<br>添加额外<strong>配置项</strong><br>（1）deep:true 对复杂类型深度监视<br>（2）immediate:true 初始化立刻执行一次handler方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 具体讲解：(1) watch语法 (2) 具体业务实现</span><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token literal-property property">obj</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//深度监视</span>            <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//立刻执行，一进入页面handler立刻执行</span>                <span class="token function">handler</span><span class="token punctuation">(</span> <span class="token parameter">newValue</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//  防抖：延迟执行 -&gt; 干啥事先等一等，延迟一会，一段时间内没有再次触发，才执行</span>                <span class="token function">clearTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer<span class="token punctuation">)</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>                      <span class="token comment">//这里是ajax的内容</span>                    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                        <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'https://applet-base-api-t.itheima.net/api/translate'</span><span class="token punctuation">,</span>                        <span class="token literal-property property">params</span><span class="token operator">:</span>newValue                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data                     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><ol><li>创建阶段：创建响应式数据  发送初始化渲染请求</li><li>挂载阶段：渲染模版   操作dom</li><li>更新阶段：修改数据、更新视图</li><li>销毁阶段：销毁实例</li></ol><img src="/2024/11/18/vue/1682065937815.png?lastModify=1734012561" alt="68206593781" style="zoom:67%;"><p>Vue生命周期过程中，会自动运行一些函数（created&amp;mounted），被称为生命周期钩子，让开发者可以在特定阶段运行<strong>自己的代码</strong></p><img src="/2024/11/18/vue/1682066040295.png?lastModify=1734057859" alt="68206604029" style="zoom:67%;"><h3 id="工程化开发"><a href="#工程化开发" class="headerlink" title="工程化开发"></a>工程化开发</h3><p>vue开发的两种方式：</p><ul><li>核心包传统开发模式：基于html / css / js 文件，直接引入核心包，开发 Vue。</li><li><strong>工程化开发模式：基于构建工具（例如：webpack）的环境中开发Vue。</strong></li></ul><p>Vue CLI 是 Vue 官方提供的一个<strong>全局命令工具</strong>  安装：<code>npm i @vue/cli -g</code><br>可以帮助我们<strong>快速创建</strong>一个开发Vue项目的<strong>标准化基础架子</strong>【集成 webpack 配置】</p><img src="/2024/11/18/vue/1682092148521.png?lastModify=1734058353" alt="68209214852" style="zoom:67%;"><ul><li>组件化：一个页面可以拆分成一个个组件，每个组件有着自己独立的结构、样式、行为<br>好处：便于维护，利于复用，有利于提升开发效率<br>组件分类：普通组件、根组件</li><li>根组件：整个应用最上层的组件，包括所有普通小组件</li></ul><h4 id="App-vue文件"><a href="#App-vue文件" class="headerlink" title="App.vue文件"></a>App.vue文件</h4><ul><li>template：结构（Vue2中有且只能一个元素）</li><li>script：js逻辑</li><li>style:样式（可支持less，需要装包）</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;!-- Vue2中只能有一个根元素 --&gt;&lt;div class="app" @click="fn()"&gt;    我是结构    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default{        methods:{            fn(){                alert("hello")            }        }    }&lt;/script&gt;&lt;style lang="less"&gt;    .app {        width: 400px;        height: 400px;        background-color: pink;    }&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><p><strong>局部注册</strong></p><ul><li>创建.vue文件（三个组成部分：Header,Main,Footer）</li><li>在<strong>使用的组件内</strong>（例如app.vue根组件）导入并注册</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- App.vue文件 --&gt;&lt;script&gt;import HmHeader from './components/HmHeader.vue'import HmMain from './components/HmMain.vue'import HmFooter from './components/HmFooter.vue'export default {  components:{    HmHeader:HmHeader,    HmMain,    HmFooter  }}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>全局注册</strong></p><ul><li>创建.vue文件（三个组成部分）</li><li><strong>main.js中进行全局注册</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//导入需要全局注册的组件</span><span class="token keyword">import</span> HmButton <span class="token keyword">from</span> <span class="token string">'./components/HmButton'</span><span class="token comment">//调用Vue.component进行全局注册</span><span class="token comment">//Vue.component('组件名',组件对象)</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'HmButton'</span><span class="token punctuation">,</span> HmButton<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="组件组成与通信"><a href="#组件组成与通信" class="headerlink" title="组件组成与通信"></a>组件组成与通信</h4><p>写在组件中的样式会 <strong>全局生效</strong> →  因此很容易造成多个组件之间的样式冲突问题。</p><ol><li><p><strong>全局样式</strong>: 默认组件中的样式会作用到全局，任何一个组件中都会受到此样式的影响</p></li><li><p><strong>局部样式</strong>: 可以给组件加上<strong>scoped</strong> 属性,可以<strong>让样式只作用于当前组件</strong></p></li></ol><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;style lang="less" scoped&gt;.el-menu-vertical-demo:not(.el-menu--collapse) {  width: 200px;  min-height: 400px;}.el-menu {  height: 100%;  border: none;  h4 {    color: #fff;    text-align: center;    line-height: 10px;  }}.router-link-active {  text-decoration: none;  color: #fff;  font-style: normal;}i {  text-decoration: none;  color: white;  font-style: normal;}&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个组件的 <strong>data</strong> 选项必须<strong>是一个函数</strong>。目的是为了：保证每个组件实例，维护<strong>独立</strong>的一份<strong>数据</strong>对象。</p><p>每次创建新的组件实例，都会新<strong>执行一次data 函数</strong>，得到一个新对象。</p><p><strong>组件通信</strong></p><p>组件通信，就是指<strong>组件与组件</strong>之间的<strong>数据传递</strong></p><ul><li>组件的数据是独立的，无法直接访问其他组件的数据。</li><li>想使用其他组件的数据，就需要组件通信</li></ul><p>两种组件关系分类 和 对应的组件通信方案</p><ul><li>父子关系 → props &amp; $emit<ul><li>props：组件上 注册的一些  自定义属性，用于父组件向子组件传递数据</li><li>可以 传递 <strong>任意数量/任意类型</strong> 的prop</li></ul></li><li>非父子关系 → provide &amp; inject 或 eventbys</li><li>通用方案 → vuex</li></ul><h5 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h5><p>父-&gt;子</p><img src="/2024/11/18/vue/1682318711785.png?lastModify=1734060490" alt="68231871178" style="zoom: 50%;"><p>子-&gt;父</p><img src="/2024/11/18/vue/1682318965635.png?lastModify=1734060558" alt="68231896563" style="zoom: 50%;"><h5 id="props校验"><a href="#props校验" class="headerlink" title="props校验"></a>props校验</h5><p> 为prop指定验证要求，不符合要求，控制台就会有错误提示→帮助开发者，快速发现错误</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>  校验的属性名<span class="token operator">:</span> <span class="token punctuation">{</span>    type<span class="token operator">:</span> 类型<span class="token punctuation">,</span>  <span class="token comment">// Number String Boolean ...</span>    required<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 是否必填</span>    <span class="token keyword">default</span><span class="token operator">:</span> 默认值<span class="token punctuation">,</span> <span class="token comment">// 默认值</span>    <span class="token function">validator</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 自定义校验逻辑</span>      <span class="token keyword">return</span> 是否通过校验    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token comment">// 完整写法（类型、默认值、非空、自定义校验）</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token literal-property property">w</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token literal-property property">type</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>      <span class="token comment">//required: true,</span>      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token function">validator</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// console.log(val)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&gt;=</span> <span class="token number">100</span> <span class="token operator">||</span> val <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'传入的范围必须是0-100之间'</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="props-data"><a href="#props-data" class="headerlink" title="props&amp;data"></a>props&amp;data</h5><p>共同点：都可以给组件提供数据<br>区别：</p><ul><li>data的数据是<strong>自己的</strong> → 随便改</li><li>props的数据是<strong>外部的</strong> → 不能直接改，要遵循单向数据流<br><strong>单向数据流</strong>：父级prop的数据更新，会向下流动，影响子组件。这个数据流动是单向的。</li></ul><h5 id="非父子通信"><a href="#非父子通信" class="headerlink" title="非父子通信"></a>非父子通信</h5><h5 id="event-bus-事件总线"><a href="#event-bus-事件总线" class="headerlink" title="event bus 事件总线"></a>event bus 事件总线</h5><ol><li><p>创建一个都能访问的事件总线 （空Vue实例）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">const</span> Bus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> Bus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>A组件（接受方），监听Bus的 $on事件</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">created () {&nbsp; Bus.$on('sendMsg', (msg) =&gt; {&nbsp; &nbsp; this.msg = msg&nbsp; })}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>B组件（发送方），触发Bus的$emit事件</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">Bus.$emit('sendMsg', '这是一个消息')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h5 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide&amp;inject"></a>provide&amp;inject</h5><p>跨层级数据共享</p><ol><li>父组件 provide提供数据</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">provide</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>       <span class="token comment">// 普通类型【非响应式】</span>       <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">,</span>        <span class="token comment">// 复杂类型【响应式】</span>       <span class="token literal-property property">userInfo</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userInfo<span class="token punctuation">,</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.子/孙组件 inject获取数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  inject<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'color'</span><span class="token punctuation">,</span><span class="token string">'userInfo'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userInfo<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>provide提供的简单类型的数据不是响应式的，复杂类型数据是响应式。（推荐提供复杂类型数据）</li><li>子/孙组件通过inject获取的数据，不能在自身组件内修改</li></ul><h4 id="组件双向绑定"><a href="#组件双向绑定" class="headerlink" title="组件双向绑定"></a>组件双向绑定</h4><p>表单类组件封装 → 实现子组件和父组件数据的双向绑定<br>①父传子：数据应该是父组件props传递过来的，v-model拆解绑定数据<br>②子传父：监听输入，子传父传值给父组件修改<br>本质：<strong>实现了子组件和父组件数据的双向绑定</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!--1.父组件给子组件传递属性cityId        4.父组件监听到'事件名'，更新selectID--&gt;&lt;BaseSelect :cityId="selectId" @事件名="selectId = $event"&gt;&lt;/BaseSelect&gt;&lt;!--3.子组件BaseSelect.vue触发事件handlechange--&gt;&lt;select :value="cityId" @change="handleChange"&gt;...&lt;/select&gt;&lt;script&gt;    // 2.子组件props接收父组件传值    props: {        cityId:String      },    methods: {      // 对应3.触发事件handlechange，给父组件发送消息通知      handleChange (e) {        this.$emit('事件名', e.target.value)       }     }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="v-model简化双向绑定"><a href="#v-model简化双向绑定" class="headerlink" title="v-model简化双向绑定"></a>v-model简化双向绑定</h5><p>父组件v-model简化代码，实现子组件和父组件数据双向绑定<br>①子组件中：props通过value接受，事件触发input<br>②父组件中：v-model给组件直接绑数据</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!--父组件--&gt;&lt;BaseSelect v-model="selectId"&gt;&lt;/BaseSelect&gt;&lt;!--子组件--&gt;&lt;select :value="value" @change="handleChange"&gt;...&lt;/select&gt;&lt;script&gt;    //子组件    props: {        value:String    },        methods: {            handleChange (e) {                this.$emit('input', e.target.value)            }        }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h5><p>作用：可以实现子组件和父组件数据的双向绑定，简化代码<br>特点：prop属性名，可以自定义，非固定为value<br>场景：<strong>封装弹框类的基础组件</strong>，visible属性 true显示 false隐藏<br>本质：就是 :属性名 和 @update:属性名 合写</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!--父组件--&gt;&lt;BaseDialog :visible.sync="isShow"&gt;&lt;/BaseDialog&gt;&lt;script&gt;    //子组件    props:{        visible:Boolean      },      methods:{         // 关闭弹窗，触发父组件属性隐藏        close () {          this.$emit('update:visible', false)        }      }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ref-和-refs"><a href="#ref-和-refs" class="headerlink" title="ref 和 $refs"></a>ref 和 $refs</h5><p>作用：利用 ref 和 $refs 可以用于 获取 dom 元素，或 组件实例<br>特点：查找范围 → 当前组件内（更精确稳定）<br>① 获取dom：</p><p>目标标签 - 添加 ref 属性</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>chartRef<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>我是渲染图标的容器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取时，通过 this.$refs.xxx,获取目标标签</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;    mounted() {        console.log(this.$refs.chartRef)    },&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：之前只用document.querySelect(‘.box’) 获取的是整个页面中的盒子</p><h5 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h5><ol><li>Vue是异步更新DOM的</li><li>想要在DOM更新完成之后做某件事，可以使用$nextTick</li></ol><p><strong>语法:</strong> this.$nextTick(函数体)</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>inp<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>$nextTick 内的函数体 一定是<strong>箭头函数</strong>，这样才能让函数内部的this指向Vue实例</p><h3 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h3><p>单页应用程序：SPA【Single Page Application】是指所有的功能都在<strong>一个html页面</strong>上实现</p><p>单页应用网站： 网易云音乐  <a href="https://music.163.com/">https://music.163.com/</a></p><p>多页应用网站：京东  <a href="https://jd.com/">https://jd.com/</a></p><img src="/2024/11/18/vue/1682441912977.png" alt="68244191297" style="zoom:67%;"><p>单页应用类网站：系统类网站 / 内部网站 / 文档类网站 / 移动端站点</p><p>多页应用类网站：公司官网 / 电商类网站 </p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>单页面应用程序，之所以开发效率高，性能好，用户体验好</p><p>最大的原因就是：<strong>页面按需更新</strong>。比如当点击【发现音乐】和【关注】时，<strong>只是更新下面部分内容</strong>，对于头部是不更新的</p><img src="/2024/11/18/vue/1682442699775.png?lastModify=1734415679" alt="68244269977" style="zoom: 80%;"><p>Vue中的路由：<strong>路径和组件</strong>的<strong>映射</strong>关系</p><ol><li><p>下载 VueRouter 模块到当前工程，版本3.6.5</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">yarn</span> <span class="token function">add</span> vue-router@3.6.5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>main.js中引入VueRouter</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">import VueRouter from 'vue-router'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装注册</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">Vue.use(VueRouter)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建路由对象</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">const router = new VueRouter({routes:[...]})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>注入，将路由对象注入到new Vue实例中，建立关联</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">new Vue({&nbsp; render: h =&gt; h(App),&nbsp; router:router}).$mount('#app')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>当我们配置完以上5步之后 就可以看到浏览器地址栏中的路由 变成了 /#/的形式。表示项目的路由已经被Vue-Router管理了</p><img src="/2024/11/18/vue/1682479207453-1734415794558.png" alt="68247920745" style="zoom:67%;"><p>配置导航，配置路由出口(路径匹配的组件显示的位置)</p><p>App.vue</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;div class="footer_wrap"&gt;&nbsp; &lt;a href="#/find"&gt;发现音乐&lt;/a&gt;&nbsp; &lt;a href="#/my"&gt;我的音乐&lt;/a&gt;&nbsp; &lt;a href="#/friend"&gt;朋友&lt;/a&gt;&lt;/div&gt;&lt;div class="top"&gt;&nbsp; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h2><p>经典（以此为准）：<a href="https://github.com/PanJiaChen/vue-element-admin">PanJiaChen/vue-element-admin: <span class="github-emoji"><span>🎉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> A magical vue admin https://panjiachen.github.io/vue-element-admin</a></p><p>文档：<a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/#%E5%8A%9F%E8%83%BD">介绍 | vue-element-admin</a></p><p>新：<a href="https://github.com/vbenjs/vue-vben-admin">vbenjs/vue-vben-admin: A modern vue admin panel built with Vue3, Shadcn UI, Vite, TypeScript, and Monorepo. It’s fast!</a></p><p>文档：<a href="https://doc.vben.pro/guide/introduction/vben.html#%E9%A1%B5%E9%9D%A2%E5%8E%86%E5%8F%B2">关于 Vben Admin | Vben Admin</a></p><h3 id="启动解析"><a href="#启动解析" class="headerlink" title="启动解析"></a>启动解析</h3><h4 id="1-main-js入口"><a href="#1-main-js入口" class="headerlink" title="1.main.js入口"></a>1.main.js入口</h4><p>示例结构：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>        <span class="token comment">// 引入 Vue</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token punctuation">;</span>   <span class="token comment">// 引入根组件</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token punctuation">;</span> <span class="token comment">// 引入路由（如果有）</span>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 禁用生产模式下的提示</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>   <span class="token comment">// 将 Vue 实例挂载到 id 为 'app' 的 DOM 元素上</span>  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 渲染根组件 App</span>  router<span class="token punctuation">,</span>               <span class="token comment">// 路由配置（如果有）</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-App-vue"><a href="#2-App-vue" class="headerlink" title="2.App.vue"></a>2.App.vue</h4><p>在 Vue 项目中，<code>App.vue</code> 是根组件。它通过 <code>&lt;router-view /&gt;</code> 渲染页面内容。</p><blockquote><p>Vue Router 是 Vue 官方的客户端路由解决方案。</p><p>客户端路由的作用是在单页应用 (SPA) 中将浏览器的 URL 和用户看到的内容绑定起来。当用户在应用中浏览不同页面时，URL 会随之更新，但页面不需要从服务器重新加载。</p><p>Vue Router 基于 Vue 的组件系统构建，你可以通过配置<strong>路由</strong>来告诉 Vue Router <strong>为每个 URL 路径显示哪些组件</strong>。</p></blockquote><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div id="app"&gt;    &lt;router-view /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: 'App'}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-router"><a href="#3-router" class="headerlink" title="3.router"></a>3.router</h4><p>Vue Router 管理应用中的路由和页面导航。路由配置文件<code>router/index.js</code>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'@/views/Home.vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">'@/views/About.vue'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Router<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Home'</span><span class="token punctuation">,</span>      <span class="token literal-property property">component</span><span class="token operator">:</span> Home    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/about'</span><span class="token punctuation">,</span>      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'About'</span><span class="token punctuation">,</span>      <span class="token literal-property property">component</span><span class="token operator">:</span> About    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实际页面内容的渲染</strong></p><ol><li><strong>加载根组件（<code>App.vue</code>）</strong>：<ul><li>当 Vue 应用启动时，<code>App.vue</code> 会被加载并渲染，其中包含了 <code>&lt;router-view /&gt;</code>。</li></ul></li><li><strong>匹配路由</strong>：<ul><li>根据 URL 路径，Vue Router 会匹配到相应的路由。</li><li>比如，当用户访问 <code>http://localhost:8080/</code> 时，Vue Router 会匹配到 <code>/</code> 路径，并加载 <code>Home.vue</code> 组件。</li></ul></li><li><strong>渲染对应的组件</strong>：<ul><li>Vue Router 会将匹配到的组件（例如 <code>Home.vue</code> 或 <code>About.vue</code>）插入到 <code>App.vue</code> 中的 <code>&lt;router-view /&gt;</code> 部分。</li><li>最终，用户在页面上看到的就是 <code>Home.vue</code> 或 <code>About.vue</code> 组件的内容。</li></ul></li></ol><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><p>页面整体布局是一个产品最外层的框架结构，往往会包含导航、侧边栏、面包屑以及内容等。 </p><p><strong>vue-router 路由嵌套</strong>：Vue Router 的路由嵌套机制允许在一个路由组件中嵌套显示另一个路由组件。通常在布局（如 <code>Layout</code>）中，使用嵌套路由来组织子页面或功能模块。这种嵌套机制通过 <code>&lt;router-view /&gt;</code> 占位符来渲染子路由组件。</p><p> <strong>一般情况下，你增加或者修改页面只会影响 <code>app-main</code>这个主体区域。其它配置在 <code>layout</code> 中的内容如：侧边栏或者导航栏都是不会随着你主体页面变化而变化的。</strong></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">/foo                                  /bar+------------------+                  +-----------------+| layout           |                  | layout          || +--------------+ |                  | +-------------+ || | foo.vue      | |  +------------&gt;  | | bar.vue     | || |              | |                  | |             | || +--------------+ |                  | +-------------+ |+------------------+                  +-----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然你也可以一个项目里面使用多个不同的 <code>layout</code>，只要在你想作用的路由父级上引用它就可以了。</p><p><strong>父路由和子路由</strong>：</p><ul><li><strong>父路由</strong>：是定义在路由配置中，包含子路由的路由。通常，父路由配置会有一个 <code>&lt;router-view /&gt;</code> 占位符，用于渲染子路由。</li><li><strong>子路由</strong>：是嵌套在父路由下的路由，子路由通过 <code>children</code> 属性来定义。</li></ul><p><strong>路由渲染顺序</strong>：</p><ul><li><p>当用户访问某个路径时，Vue Router 会根据路径匹配到父路由，再匹配到子路由。</p></li><li><p>父路由组件渲染时，会渲染一个 <code>&lt;router-view /&gt;</code> 作为占位符，子路由组件会被插入到这个占位符中。</p></li></ul><p><strong>1. 路由配置 (<code>router/index.js</code>)</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">javascript复制代码<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Layout <span class="token keyword">from</span> <span class="token string">'@/layouts/Layout'</span><span class="token punctuation">;</span>    <span class="token comment">// 引入 Layout 布局组件</span><span class="token keyword">import</span> Dashboard <span class="token keyword">from</span> <span class="token string">'@/views/dashboard/index'</span><span class="token punctuation">;</span>  <span class="token comment">// 引入 Dashboard 子页面</span><span class="token keyword">import</span> Profile <span class="token keyword">from</span> <span class="token string">'@/views/profile/index'</span><span class="token punctuation">;</span>      <span class="token comment">// 引入 Profile 子页面</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Router<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>      <span class="token literal-property property">component</span><span class="token operator">:</span> Layout<span class="token punctuation">,</span>  <span class="token comment">// 父路由使用 Layout 布局组件</span>      <span class="token literal-property property">redirect</span><span class="token operator">:</span> <span class="token string">'/dashboard'</span><span class="token punctuation">,</span>  <span class="token comment">// 默认重定向到 /dashboard</span>      <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'dashboard'</span><span class="token punctuation">,</span>  <span class="token comment">// 子路由的路径为 'dashboard'</span>          <span class="token literal-property property">component</span><span class="token operator">:</span> Dashboard<span class="token punctuation">,</span>  <span class="token comment">// 子路由渲染 Dashboard 组件</span>          <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Dashboard'</span><span class="token punctuation">,</span>  <span class="token comment">// 子路由的名称</span>          <span class="token literal-property property">meta</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'Dashboard'</span><span class="token punctuation">,</span> <span class="token literal-property property">icon</span><span class="token operator">:</span> <span class="token string">'dashboard'</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>          <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'profile'</span><span class="token punctuation">,</span>  <span class="token comment">// 另一个子路由的路径为 'profile'</span>          <span class="token literal-property property">component</span><span class="token operator">:</span> Profile<span class="token punctuation">,</span>  <span class="token comment">// 子路由渲染 Profile 组件</span>          <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Profile'</span><span class="token punctuation">,</span>          <span class="token literal-property property">meta</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'Profile'</span><span class="token punctuation">,</span> <span class="token literal-property property">icon</span><span class="token operator">:</span> <span class="token string">'user'</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 父路由布局组件 (<code>Layout.vue</code>)</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">vue复制代码&lt;template&gt;  &lt;div class="layout"&gt;    &lt;!-- 侧边栏组件 --&gt;    &lt;Sidebar /&gt;    &lt;!-- 主体内容区域 --&gt;    &lt;div class="main-content"&gt;      &lt;!-- 导航栏组件 --&gt;      &lt;Navbar /&gt;      &lt;!-- 子路由渲染区 --&gt;      &lt;router-view /&gt;  &lt;!-- 这个 &lt;router-view /&gt; 会渲染子路由组件 (如 Dashboard 或 Profile) --&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Sidebar from '@/components/Sidebar';import Navbar from '@/components/Navbar';export default {  name: 'Layout',  components: {    Sidebar,    Navbar  }}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 子路由组件 (<code>Dashboard.vue</code> 和 <code>Profile.vue</code>)</strong></p><p><strong>Dashboard.vue</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">vue复制代码&lt;template&gt;  &lt;div class="dashboard"&gt;    &lt;h1&gt;Dashboard&lt;/h1&gt;    &lt;p&gt;欢迎来到 Dashboard 页面&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: 'Dashboard'}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Profile.vue</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">vue复制代码&lt;template&gt;  &lt;div class="profile"&gt;    &lt;h1&gt;Profile&lt;/h1&gt;    &lt;p&gt;这是用户的个人资料页面&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: 'Profile'}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="实际layout代码"><a href="#实际layout代码" class="headerlink" title="实际layout代码"></a>实际layout代码</h5><p><a href="https://github.com/PanJiaChen/vue-element-admin/tree/master/src/layout">@/layout</a>  layout下index.vue</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div :class="classObj" class="app-wrapper"&gt;    &lt;div v-if="device==='mobile'&amp;&amp;sidebar.opened" class="drawer-bg" @click="handleClickOutside" /&gt;    &lt;sidebar class="sidebar-container" /&gt;    &lt;div :class="{hasTagsView:needTagsView}" class="main-container"&gt;      &lt;div :class="{'fixed-header':fixedHeader}"&gt;        &lt;navbar /&gt;        &lt;tags-view v-if="needTagsView" /&gt;      &lt;/div&gt;      &lt;!-- 子组件app-main里面定义了子路由router-view  -- 子路由渲染区 --&gt;      &lt;app-main /&gt;      &lt;right-panel v-if="showSettings"&gt;        &lt;settings /&gt;      &lt;/right-panel&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import RightPanel from '@/components/RightPanel'import { AppMain, Navbar, Settings, Sidebar, TagsView } from './components'import ResizeMixin from './mixin/ResizeHandler'import { mapState } from 'vuex'export default {  name: 'Layout',  // 引入并注册子组件，作为layout的一部分进行渲染  components: {    AppMain,    Navbar,    RightPanel,    Settings,    Sidebar,    TagsView  },  // 使用的 mixins，提供了组件间复用的功能  mixins: [ResizeMixin],  // 计算属性  computed: {    // 使用 mapState 辅助函数映射 Vuex store 中的状态到当前组件的计算属性    ...mapState({      // 获取 Vuex store 中的 sidebar 状态，表示侧边栏的开关      sidebar: state =&gt; state.app.sidebar,      device: state =&gt; state.app.device,      showSettings: state =&gt; state.settings.showSettings,      needTagsView: state =&gt; state.settings.tagsView,      fixedHeader: state =&gt; state.settings.fixedHeader    }),    // 计算类名对象，返回一个动态的 class 对象    classObj() {      return {        // 根据 sidebar 的状态动态切换类名        hideSidebar: !this.sidebar.opened, // 侧边栏关闭时，应用 'hideSidebar' 类        openSidebar: this.sidebar.opened, // 侧边栏打开时，应用 'openSidebar' 类        withoutAnimation: this.sidebar.withoutAnimation, // 判断是否禁用动画        mobile: this.device === 'mobile'      }    }  },  methods: {    // 处理点击外部区域的事件，用来关闭侧边栏    handleClickOutside() {      // 使用 Vuex 的 action 来关闭侧边栏      this.$store.dispatch('app/closeSideBar', { withoutAnimation: false })    }  }}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>**<code>&lt;router-view /&gt;</code>**：<code>Layout</code> 组件本身并不直接渲染内容，而是作为页面的框架，提供固定的布局部分（如侧边栏、导航栏等）。它通过 <code>&lt;router-view /&gt;</code> 来渲染子路由的内容。此处没有直接放置 <code>&lt;router-view /&gt;</code>，而是放置了 <code>AppMain</code> 组件，<code>AppMain</code> 组件会在其中继续嵌套一个 <code>&lt;router-view /&gt;</code>，从而实现多层嵌套。</p></li><li><p><strong><code>AppMain</code> 组件</strong>：<code>Layout</code> 渲染了 <code>AppMain</code> 组件，<code>AppMain</code> 内部还通过 <code>&lt;router-view /&gt;</code> 渲染子路由内容（例如 <code>Dashboard</code> 或 <code>Profile</code>）。</p></li></ul><h4 id="app-main"><a href="#app-main" class="headerlink" title="app-main"></a>app-main</h4><p><a href="https://github.com/PanJiaChen/vue-element-admin/blob/master/src/layout/components/AppMain.vue">@/layout/components/AppMain</a></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;!-- 主内容区域 --&gt;  &lt;section class="app-main"&gt;    &lt;!-- 过渡动画：fade-transform --&gt;    &lt;transition name="fade-transform" mode="out-in"&gt;      &lt;!-- keep-alive 用于缓存视图，以避免重新加载组件 --&gt;      &lt;keep-alive :include="cachedViews"&gt;        &lt;!-- 渲染路由的子组件，key 用于控制视图的缓存和刷新 --&gt;        &lt;router-view :key="key" /&gt;      &lt;/keep-alive&gt;    &lt;/transition&gt;  &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default {  name: 'AppMain',  computed: {    // 计算属性：获取要缓存的视图列表    cachedViews() {      // 从 Vuex 存储中获取缓存视图的列表      return this.$store.state.tagsView.cachedViews    },    // 计算属性：返回当前路由的路径    key() {      // 使用当前路由的路径作为唯一的 key 来控制视图缓存和刷新      return this.$route.path    }  }}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>transition</code>：使用 Vue 的过渡系统，为路由切换添加过渡动画。</p></li><li><p><code>&lt;keep-alive&gt;</code>标签：Vue 的内置组件，用于缓存页面组件，以避免频繁的销毁和重新创建。</p><ul><li><code>:include="cachedViews"</code>：指定要缓存的组件列表。<code>cachedViews</code> 是一个计算属性，从 Vuex 获取已缓存的视图。</li><li>这样配置后，只有在 <code>cachedViews</code> 中列出的视图才会被缓存，从而提升性能，避免频繁地销毁和创建页面组件。</li></ul></li><li><p><code>key</code>计算属性：返回当前路由的路径。</p><ul><li>这个 <code>key</code> 属性用于在每次路由切换时更新 <code>&lt;router-view&gt;</code>，确保组件在路由变化时重新渲染。</li><li>通过使用路由的 <code>path</code> 作为 <code>key</code>，可以让 Vue 在切换路由时正确地处理组件的缓存与更新。</li></ul></li></ul><h3 id="Vuex-store"><a href="#Vuex-store" class="headerlink" title="Vuex store"></a>Vuex store</h3><p><strong>Vuex store</strong> 是 Vue.js 官方提供的一个状态管理库，用于管理应用中的<strong>共享状态</strong>。在 Vue.js 中，状态通常指的是数据（如<strong>用户信息、产品列表、界面设置</strong>等），而这些状态需要在应用的多个组件之间共享和管理。Vuex 通过<strong>集中式的存储和管理这些状态</strong>，使得不同组件之间的数据流变得更加清晰和可维护。</p><p>Vuex store 中的状态是<strong>响应式</strong>的，任何使用到这些状态的组件都会在<strong>状态变化时自动更新</strong>。</p><p>Vuex store 基于以下几个核心概念：</p><ul><li><strong>State（状态）</strong>：用于存储应用的共享数据，Vuex 中的状态就类似于一个全局的数据源。</li><li><strong>Getters（获取器）</strong>：类似于计算属性（computed），用于从 Vuex store 中派生出数据。Getters 用来获取或过滤状态中的数据。</li><li><strong>Mutations（突变）</strong>：用来同步修改 Vuex store 中的状态。所有对状态的改变必须通过 mutation 来进行。</li><li><strong>Actions（动作）</strong>：用于处理异步操作和业务逻辑，它们会提交 mutations 来改变状态。</li><li><strong>Modules（模块）</strong>：Vuex 支持将 store 分割成多个模块，每个模块拥有自己的 state、mutations、actions 和 getters，以便组织大型应用的状态。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// store.js</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token punctuation">;</span><span class="token comment">// 安装 Vuex 插件</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment">// 状态 (store 中的数据)</span>  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 获取器 (计算属性，派生数据)</span>  <span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function-variable function">counterDouble</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>counter <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token function-variable function">userName</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>user <span class="token operator">?</span> state<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name <span class="token operator">:</span> <span class="token string">'Guest'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 突变 (同步修改状态)</span>  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">setUser</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>user <span class="token operator">=</span> user<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 动作 (可以进行异步操作)</span>  <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function">fetchUser</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 模拟异步获取用户数据</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'John Doe'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'setUser'</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 提交 mutation</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 模块 (支持模块化管理状态)</span>  <span class="token literal-property property">modules</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token comment">// 可以定义多个子模块来管理不同的 state</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> store<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置store：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./store'</span><span class="token punctuation">;</span>  <span class="token comment">// 引入 Vuex store</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>  store<span class="token punctuation">,</span>  <span class="token comment">// 将 Vuex store 注入到 Vue 实例</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>w3school：<a href="https://www.w3school.com.cn/html/index.asp">HTML 教程</a></p><p><a href="https://blog.csdn.net/qq_58667485/article/details/133761371">前端三件套复习笔记_js前端三件套-CSDN博客</a></p><p><a href="https://blog.csdn.net/kiddkid/article/details/136520569">前端三件套简要笔记_后端转前端 html js css怎么学习-CSDN博客</a></p><p><a href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程</a></p><p>vue：<a href="https://www.bilibili.com/video/BV1HV4y1a7n4/?spm_id_from=333.1007.top_right_bar_window_history.content.click">https://www.bilibili.com/video/BV1HV4y1a7n4/?spm_id_from=333.1007.top_right_bar_window_history.content.click</a></p><p><a href="https://blog.csdn.net/qq_55666248/article/details/143028853">黑马Vue2+Vue3笔记_vue学习笔记黑马-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_70675152/article/details/135439211?spm=1001.2014.3001.5502">VUE学习笔记（黑马2023版 第四天）_vue 黑马2023版 源码-CSDN博客</a></p><p><a href="https://github.com/PanJiaChen/vue-element-admin">PanJiaChen/vue-element-admin: <span class="github-emoji"><span>🎉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> A magical vue admin https://panjiachen.github.io/vue-element-admin</a></p><p><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/#%E5%8A%9F%E8%83%BD">介绍 | vue-element-admin</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVBench</title>
      <link href="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/"/>
      <url>/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/</url>
      
        <content type="html"><![CDATA[<h1 id="MVBench-A-Comprehensive-Multi-modal-Video-Understanding-Benchmark"><a href="#MVBench-A-Comprehensive-Multi-modal-Video-Understanding-Benchmark" class="headerlink" title="MVBench: A Comprehensive Multi-modal Video Understanding Benchmark"></a>MVBench: A Comprehensive Multi-modal Video Understanding Benchmark</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>论文介绍了MVBench，这是一个全新的多模态视频理解基准测试，旨在评估多模态大型语言模型（MLLMs）在视频理解方面的能力。</p><ul><li>目前许多基准测试主要集中在<strong>静态图像任务的空间理解</strong>上，而<strong>忽视了动态视频任务中的时间理解</strong>。MVBench通过20个具有挑战性的<strong>视频任务</strong>来填补这一空白，这些任务无法通过单帧图像有效解决。</li><li>论文提出了一种新颖的<strong>静态到动态方法</strong>来定义与时间相关的任务，并将各种静态任务转化为动态任务，从而系统地生成各种视频任务，无需人工参与。</li><li>通过任务定义，研究者们自动<strong>将视频注释转换为多项选择的问答（QA）</strong>，以评估每个任务。</li><li>MVBench的构建高效且公平，避免了对LLMs的评分偏见。论文开发了一个强大的视频MLLM基线VideoChat2，并通过多样化的指令调整数据进行逐步多模态训练。</li><li>在MVBench上表明，现有的MLLMs在时间理解方面远未达到令人满意的水平，而VideoChat2在MVBench上的准确率超过了这些领先模型15%以上。</li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>多模态大模型（MLLM）通过在各种预先训练的LLM中嵌入视觉编码器，推动了视觉-语言学习任务的发展。一个很自然的问题是如何评估这些模型的视觉理解能力，<strong>这种评估对于确认其设计有效性和进一步改进它们以更广泛地理解开放世界的多种模态至关重要。</strong></p><p>为了满足这一需求，一些基准测试已经被提出。其主要方法是在各种感知任务上构造QA式以评估MLLM性能。然而，这些基准主要集中在基于图像的理解上，所有的问题都是为静态图像的空间感知设计的（如图一spatial understanding所示）。<strong>因此他们难以评估动态视频中的时间演化，而这对于现实世界中的程式化活动的理解是十分重要的。</strong></p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241113183819734.png" alt="image-20241113183819734" style="zoom: 80%;"><p>尽管最近已经有一些基准来评估视频中的时间感知任务，但它们要么只聚焦于非常基本的视频任务（如SEED-Bench中的行为识别和预测），要么聚焦特定领域（如FunQA）或受限的场景（如Perception Test中的室内场景）。因此，利用这些基准来对mllm的时间理解技能进行全面的评估是有限的。此外，它们通过劳动密集型标注收集，导致昂贵的人工成本。为了解决这些问题，<strong>本文提出了一个多模态视频理解基准（MVBench），它旨在全面评估开放世界中mllm的时间感知能力。</strong>与上面现有的基准相比，MVBench有两种不同的设计：</p><ol><li><p><strong>引入了从静态到动态的方法（a novel static-to-dynamic method）：</strong></p><p>为静态图像任务增加动态演化的时间上下文，得到了20个视频理解任务，这些任务需要对视频的时间维度有深入理解，涵盖了从感知到认知的广泛的时间理解技能。具体来说，作者在之前的多模态基准测试中使用静态图像任务作为定义参考。然后，<strong>用视频中的时间上下文来扩大这些静态任务的问题</strong>，例如，图像中的位置任务可以灵活地转换为视频中的移动方向任务(“男人在舞台上吗？”→“这个人的方向是什么？”)</p></li><li><p><strong>引入自动标注范式，实现自动问答生成（Automatic QA Generation）：</strong></p><p>利用现有的视频基准测试和大型语言模型(LLMs)，<strong>自动将视频注释转换为多项选择的问答对</strong>，用于评估MLLMs的性能。<br>选择了11个公共视频基准测试，并根据任务定义自动生成问题和答案选项。大大降低人工标注成本，涵盖了各种复杂的领域和不同的场景，从第一人称到第三人称的视角，以及从室内到室外的环境。这些基准为MVBench提供了基本事实，保证了评估的公平性和准确性，避免了LLM的有偏评分。</p></li></ol><p>最后，在MVBench上对多个著名的MLLM进行全面评估，结果表明这些图像和视频MLLM在各项任务上还远不能让人满意。因此，作者还开发了一个视频MLLM基线模型，即VideoChat2。该模型桥接了大模型和一个强大的视频基础模型。随后，<strong>引入了一个具有广泛的多模态指令的渐进式训练范式，允许视频和语言之间的有效对齐。</strong>评估表明，VideoChat2在MVBench上显著领先表现最好的VideoChat15%，并且在视频对话和零样本QA基准上（video conversation and zero-shot QA benchmarks）取得了最先进的结果。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="MLLM"><a href="#MLLM" class="headerlink" title="MLLM"></a>MLLM</h3><ul><li>多模态LLM（MLLM）旨在增强多种模式的理解和生成能力。开创性模型如Flamingo和PaLM-E无缝地融合了文本和视觉，在一系列多模态任务中展现出优越性。</li><li>近期开源的LLM进一步加速了公共MLLM的出现。LLaVA，MiniGPT-4，InstructBLIP提出了一系列视觉指令微调数据。</li><li>除了文本和静态图像，一些研究开始挖掘LLM在视频模态中的潜力。VideoChat，VideoChat-GPT和Valley利用LLM生成视频指令微调数据以增强指令遵循能力。</li><li>VideoChat2检验MLLM的基本的时间理解能力，为更优的MLLM提供有价值的设计理念。</li></ul><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><ul><li><p>传统的视觉语言（VL）benchmark集中在多模态检索和视觉QA。MLLM的发展催化了评估集成视觉语言任务的benchmark。</p></li><li><p>LVLM-eHub通过与图像相关的查询提供了一个交互式的模型比较平台。其他基准如OwlEval [94], MME [17], SEED-Bench [37],</p><p>MM-Vet [97], and MMBench 强调全面的VL能力，引入仅超越模型结构的评估指标。</p></li><li><p>视频领域有Perception Test，测试了<strong>多模态视频感知和推理</strong>；VideoChatGPT量化了<strong>从视频输入中生成对话的能力</strong>；FunQA通过反直觉和幽默的内容来限制视频推理。</p></li><li><p>与现有的视频基准相比，MVBench涵盖了广泛的时间任务，强调了<strong>对时间敏感的视频和</strong>对<strong>公共注释的有效使用</strong>，并对mllm的时间理解进行了全面的评估。</p></li></ul><h2 id="MVBench"><a href="#MVBench" class="headerlink" title="MVBench"></a>MVBench</h2><h3 id="时间任务定义"><a href="#时间任务定义" class="headerlink" title="时间任务定义"></a>时间任务定义</h3><p>静态到动态方法，使静态任务适应动态目标。使用静态图像的空间理解任务作为系统地设计从感知到认知的时间任务的参考。从图像benchmark里总结了上述9项空间理解任务，再思考延伸出20项时间理解任务如下：</p><ul><li><p><strong>Action.</strong> (1) <em>Action Sequence:</em> 检索在特定操作之前或之后发生的事件。 (2) <em>Action Prediction:</em> 根据当前操作推断后续事件。(3) <em>Action Antonym:</em> 将正确的操作与两个错误的操作区分开来。 (4) <em>Fine-grained Action:</em> 从一系列类似选项中确定准确的操作。 (5) <em>Unexpected Action:</em> 检测以幽默、创意或magic为特征的视频中的surprising actions。</p></li><li><p><strong>Object.</strong> (6) <em>Object Existence:</em> <strong>确定特定事件期间是否存在特定对象。</strong> (7) <em>Object Interaction:</em> 标识参与特定事件的对象。 (8) <em>Object Shuffle:</em> 在遮挡游戏中定位对象的最终位置。</p></li><li><p><strong>Position.</strong> (9) <em>Moving Direction:</em> 确定特定对象移动的轨迹。 (10) <em>Action Localization:</em> <strong>确定发生特定操作的时间段。</strong></p></li><li><p><strong>Scene.</strong> (11) <em>Scene transition:</em> 确定视频中场景的过渡方式。</p></li><li><p><strong>Count.</strong> (12) <em>Action Count:</em> 计算特定操作已执行的次数。(13) <em>Moving Count:</em> 计算执行了特定操作的对象数。</p></li><li><p><strong>Attribute.</strong> (14) <em>Moving Attribute:</em> 确定特定移动对象在给定时刻的表现/外观。 (15) <em>State Change:</em> <strong>确定某个对象的状态在整个视频中是否发生变化。</strong></p></li><li><p><strong>Pose.</strong> (16) <em>Fine-grained Pose:</em> 从一系列类似选项中确定准确的姿态类别。</p></li><li><p><strong>Character.</strong> (17) <em>Character Order:</em> 确定字母的显示顺序。</p></li><li><p><strong>Cognition.</strong> (18) <em>Egocentric Navigation:</em> Forecast the subsequent action, based on an agent’s current navigation instructions. 根据agent的当前指令预测后续操作。(19) <em>Episodic Reasoning:</em> 对电视连续剧一集中的人物、事件和对象进行推理。 (20) <em>Counterfactual Inference:</em> 思考如果发生某个事件会发生什么。</p></li></ul><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241115113421996.png" alt="image-20241115113421996" style="zoom:80%;"><h3 id="自动QA生成"><a href="#自动QA生成" class="headerlink" title="自动QA生成"></a>自动QA生成</h3><p>在时间任务定义的指导下，为每个任务收集和标注视频。具体来说，图2中设计了一个自动QA生成范式，它有效地将开源视频数据标注转换为评估mllm的多项选择QA。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241115162755492.png" alt="image-20241115162755492" style="zoom:80%;"><p><strong>数据过滤</strong></p><ul><li>考虑到<strong>视频多样性</strong>，仔细选择了11个视频数据集，覆盖广泛的领域和场景，尽可能地对不同的视频设计独立的问题；</li><li>考虑到<strong>时序敏感性</strong>，采取每个数据集中合适的视频长度（5~35秒），过短的视频往往动作幅度较小，而过长的视频包含过于复杂的上下文，问题过难会导致无法区分不同模型的能力；</li><li>考虑到<strong>问题复杂度</strong>，采取难度适中的问题，如在CLEVRER中，采取<strong>适当条件限制</strong>（排除需要超过10个条件的问题）的问题；如对于时间定位问题，不采用精细的秒级别定位任务，而采用粗略的时间段定位，如发生在视频的开始、中间还是结束。</li></ul><p><strong>QA生成</strong></p><p>之后便来到生成多选题的问题及选项，对于已有多选QA的数据，可以直接采用。但对于没有多选QA的数据，利用ChatGPT来自动生成多选QA格式。</p><ul><li>对于<strong>问题</strong>，根据任务定义，让ChatGPT生成3-5个对应的问题随机选其一；</li><li>对于<strong>选项</strong>，设计两种策略：(a)<strong>基于模版的构造</strong>，设计固定的选项模版，从ground truth annotations中构建候选集（例如，针对<em>Action Antonym</em>任务，包含正确选项，相反选项，不确定选项；在<em>Moving Direction</em>任务中，包含<em>up</em>, <em>down</em>, <em>left</em>, <em>right</em>四个方向以及固定状态），结合GPT匹配生成；(b)<strong>基于LLM的生成</strong>，针对类似<em>Unexpected Action</em>任务，将原始QA输入ChatGPT，并让ChatGPT生成新的问题以及选项。使用多选格式而不是开放格式，保证评估的正确性和公平性（如果引入开放答案，可能导致评估偏差或人工干预）。最终，本文为每个时间理解任务产生了<strong>200对多项选择QA对。</strong></li></ul><p><strong>问题选项处理</strong></p><p>对于每个问题，从可用的候选集中随机抽样三到五个答案选项，调整选项顺序以加强评估的稳健性。为了防止答案泄露，进一步使用LLM保证一个问题的所有答案选项具有相似和合理的长度。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241116140912529.png" alt="image-20241116140912529" style="zoom:80%;"><h3 id="evaluation的prompt设计"><a href="#evaluation的prompt设计" class="headerlink" title="evaluation的prompt设计"></a>evaluation的prompt设计</h3><p>对于具体的评测，作者设计了合理的system prompt和高效的answer prompt，其中<strong>system prompt</strong>用于<strong>激发模型的时间理解能力</strong>（见图2右下角），这一提示鼓励mllm仔细检查视频内容来回答问题，通过注意诸如人的动作和姿势，以及物体运动的细节和动作等因素。</p><blockquote><p><em>Carefully watch the video and pay attention to the <strong>cause and sequence of events, the detail and movement of objects and the action and pose of persons.</strong> Based on your observations, select the best option that accurately addresses the question.</em></p></blockquote><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241117103651589.png" alt="image-20241117103651589" style="zoom:80%;"><p>由于对话模型的输出倾向于输出完整的句子，难以直接输出选项，如何<strong>从对话的输出中抽取选项</strong>也成了一个难题。MMBench中使用多个模版匹配选项，对于无法匹配的选项，使用ChatGPT进行抽取。然而这种抽取效率低下， 和人类相比，只取得了87%的对齐率。SEED-Bench则比较不同选项的似然，选择最大似然对应的选项作为最终答案，这种方式仍不够直接，并且需要人为修改不同模型的forward函数。本文采取一种更简单直接的方式，通过<strong>构造带括号”()”的选项</strong>，接着显著地通过控制对话模型输出的起始字符”<strong>Best Option: (</strong>“，即<strong>answer prompt</strong>来指导mllm的选项生成，在本文实验里，这种方式不仅可以100%地保证不同模型输出选项，同时能够提高答案的准确率。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241117103831488.png" alt="image-20241117103831488" style="zoom:80%;"><h2 id="VideoChat2"><a href="#VideoChat2" class="headerlink" title="VideoChat2"></a>VideoChat2</h2><p>作者在MVBench上评估了现有的图像和视频对话模型（见实验部分表2），结果发现即便是最佳的视频对话模型VideoChat，性能与随机猜测相比也相差无几。分析原因可以发现，目前的视频对话模型存在两大缺陷：</p><ul><li><strong>缺乏多样的指令微调数据</strong>：由于视频数据难以标注，开源的指令微调数据仍规模较小；</li><li><strong>缺乏强视频编码器</strong>：目前主流的视频编码方法仍是选强多模态图像编码器CLIP-ViT，在上面进行时序改良，这难以本质地处理时序上的理解。</li></ul><p>为了弥补这些差距，本文开发了一个健壮的视频mllm基线模型VideoChat2。</p><h3 id="指令微调数据"><a href="#指令微调数据" class="headerlink" title="指令微调数据"></a>指令微调数据</h3><p>为了解决缺乏多样指令调优数据的问题，引入了如图3所示的丰富数据，其中包含了来自34个不同来源的2M个样本。效仿VideoChat和VideoLlama，在指令集中包含了图像和视频数据，以改进训练。</p><p>受M3IT的启发，本文以统一的格式重新组织了所有的数据样本，如图3的右下角所示。涉及两个key分别是{“image” or “video”}及{“QA”}。QA中包含instruction，question和answer。M3IT中要求研究人员为每一个数据集设计10组instruction，本文使用ChatGPT来生成指令（根据dataset_description，task_description，instruction_example）来生成。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241117105738621.png" alt="image-20241117105738621" style="zoom:80%;"><p>整个指令调优数据集可以粗略地分为6类：</p><ul><li>conversation：提高多轮对话能力。从LLaVA和VideoChat中收集对话数据；从VideoChatGPT中集成caption数据转为对话格式。</li><li>simple caption：提供基本的视觉描述能力。使用广泛使用的COCO和WebVid，以及来自YouCook2的一级视频字幕。</li><li>detailed caption：丰富视频细节的全面理解能力。利用MiniGPT-4, LLaVA和VideoChat的详细caption数据。</li><li>VQA：提高视觉问答能力。</li><li>reasoning：提高不同的推理能力。</li><li>classification：提高对目标识别和动作识别的鲁棒性。</li></ul><h3 id="渐进式跨模态训练范式"><a href="#渐进式跨模态训练范式" class="headerlink" title="渐进式跨模态训练范式"></a>渐进式跨模态训练范式</h3><p>促进mllm的另一个关键因素是如何有效地弥合视觉和语言表征之间的语义差距。为了解决这个问题，作者采用了如图4所示的渐进式多模态训练范式。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241117170157954.png" alt="image-20241117170157954" style="zoom:80%;"><p><strong>阶段1：视觉-语言对齐</strong></p><p>为了平衡效率和有效性，冻结视觉编码器，<strong>训练灵活的QFormer</strong>。它将冗余的视觉令牌（visual tokens）压缩为更少的查询令牌（query tokens），并<strong>通过多模态损失</strong>（即BLIP2训练的三种损失：视觉文本对比学习（VTC）、视觉文本匹配（VTM）和基于视觉的文本生成（VTG））<strong>将这些查询与文本令牌对齐。</strong>与BLIP2不同，本文选择了预训练过的<strong>UMT-L</strong>作为视觉编码器，因为它具有强大的时空表示学习能力。此外，训练CC3M和CC12M的15M图像字幕，WebVid-10M的10M视频字幕，以增强视频语言建模。</p><p><strong>阶段2：视觉-语言连接</strong></p><p>在初始对齐之后，将视觉编码器与预先训练过的llm连接起来，以构建视觉-语言理解能力。和BLIP2类似，作者应<strong>用一个线性投影来进一步转换查询标记，并将投影的标记与文本标记连接到LLM中</strong>，用于基于视觉的标题生成（即VTG）。与BLIP2不同的是，视觉编码器在这个阶段是非冻结的，以便更好地与LLM对齐。除了上述第一阶段的训练数据外，这一阶段进一步引入了2M图像caption（COCO、Visual Genome和SBU）和10M视频caption（InternVid），以丰富caption的多样性。</p><p><strong>阶段3：指令微调</strong></p><p>使用前面所述的指令微调数据进行微调。在冻结的LLM上进行lora低轶微调，通过VTG损失与视觉编码器和QFormer一起调整。此外，借鉴InstructBLIP，<strong>作者在QFormer中也插入了instruction</strong>，用于提取与指令相关的视觉token作为LLM的输入。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul><li>视觉编码器：UMT-L</li><li>大模型：Vicuna-7B</li><li>借鉴BLIP2，使用带有预训练Bert_base的QFormer，阶段1：32个query，阶段2和3：64个query</li><li>训练时：每个视频4帧，阶段1有10个epoch，阶段2有1个epoch；第3阶段转为8帧视频的3个epoch。</li><li>评估时：输入了16帧的视频，并提供了详细的prompt，以获得更好的结果。</li></ul><h3 id="MVBench整体评估"><a href="#MVBench整体评估" class="headerlink" title="MVBench整体评估"></a>MVBench整体评估</h3><p>表2展示了在MVBench上的评估结果，现有的图像和视频MLLM表现不佳。VideoChat2在15个任务上取得最佳性能，特别是在动作、物体、场景、属性和姿势识别（action, object, scene, attribute, and pose recognition）等方面表现出色。但也能看到，它在处理移动方向、动作定位、计数等任务上仍有不足。最近的一些图像对话模型，已经开始引入grouding数据增强相关能力，这也是后续视频对话模型可以突破的方向。</p><blockquote><p>值得一提的是，这里的VideoChat2_text，输入为空白视频，即QFormer输出噪声embedding，模型仅靠文本上下文进行输出，结果居然与前述最强模型接近。这个结果也揭示了<strong>目前对话模型，在时序理解任务上，仍有很大的不足</strong>。</p></blockquote><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241117104639154.png" alt="image-20241117104639154" style="zoom:80%;"><p>此外，作者还评估了功能强大的GPT-4V。结果表明，GPT-4V取得了令人满意的性能，证明了其时间理解能力，而VideoChat2超过了它，准确率提高了16.9%。这进一步强调了模型在处理更广泛的任务方面的优越性。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127143347889.png" alt="image-20241127143347889" style="zoom:80%;"><h3 id="更多比较"><a href="#更多比较" class="headerlink" title="更多比较"></a>更多比较</h3><p>仿照Video-chatgpt，本文使用ChatGPT在视频mllm之间进行定量比较。</p><p>（1）<strong>视频对话</strong>：表3显示了在Video-chatgpt中的基准上的结果。与VideoChatGPT相比，我VideoChat2在所有指标上都表现出了卓越的性能，在信息正确性、上下文和时间理解方面都取得了明显的进步。这表明，VideoChat2更<strong>擅长理解空间和时间细节，并提供一致和可靠的反应。</strong></p><p>（2）<strong>零样本视频QA</strong>：表4列出了视频QA数据集（Video question answering via gradually refined attention over appearance and motion. 及 Activitynet-qa: A dataset for understanding complex web videos via question answering.）上的结果，VideoChat2超过了所有其他方法，特别是在理解ActivityNet中的长视频方面。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127114104593.png" alt="image-20241127114104593" style="zoom:80%;"><p>图5中进一步进行了定性比较，其中VideoChat2提供了一个精确而彻底的响应。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127114508886.png" alt="image-20241127114508886" style="zoom:80%;"><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><ul><li><strong>指令微调数据</strong>：随着数据多样性和数量的增加，性能显著提高，其中<strong>视频数据的贡献大于图像数据</strong>（50.5% vs. 42.1%）。考虑到COCO和WebVid的简单caption数据中潜在的冗余性，对它们进行了随机压缩。这只对性能产生很小的影响（50.7% vs. 51.1%），但加速了微调1.7×。</li><li><strong>架构</strong>：（1）<strong>视觉编码器</strong>：表6中，使用本文构建的指令数据集+EVA-CLIP-g获得与原始VideoChat中模型相比6.9%的性能提升（42.4% vs 35.5%）。用UMT-L进行的进一步替换额外提高了6.2%的性能；（2）<strong>LLM</strong>：合并更大和更新的llm在结果中提供了一个最低限度的改进，这表明<strong>MVBench主要依赖于视觉编码器</strong>。值得注意的是，<strong>LoRA不断提高结果，可能是由于它增强了模型指令遵循的能力。</strong></li><li><strong>训练方法</strong>：只微调线性投影层，冻结视觉编码器和QFormer（参考MiniGPT-4），结果不佳（见表7，38.5%）。解冻Qformer，获得额外8.5%的性能提升；解冻视觉编码器获得更多的提升。</li><li><strong>提示设计</strong>：system prompt揭示了任务需求，增强任务完成能力。提取选项时，不同于不稳定的ChatGPT-extracting methods，和更耗时的log-likelihood comparisons，本文使用一种简单有效的answer prompt。表9证明了它能够准确地捕获选项，并提高了跨各种mllm的响应精度。VideoChat2即使没有提示，也能更好地按照指令返回选项。</li></ul><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127113600397.png" alt="image-20241127113600397" style="zoom:80%;"><p>对于QFormer，在第二第三阶段引入了额外可学习的token，用于和LLM对齐，结果显示<strong>额外引入64个token效果最佳</strong>。并且<strong>在QFormer中插入instruction引导，结果提升明显</strong>，而继续插入question则有副作用。过长的上下文（“指令+问题”）可能很难实现QFormer的信息提取。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127155131928.png" alt="image-20241127155131928" style="zoom:80%;"><p>对于训练和测试输入，实验表明训练使用8帧，测试使用16帧效果较好，训练开销也较小。但<strong>使用大分辨率，在MVBench上并没有提升，即增加分辨率并不能提高性能；然而，增加帧数可以提高，侧面验证了MVBench更依赖于模型的时序理解能力</strong>。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127161900211.png" alt="image-20241127161900211" style="zoom:80%;"><h3 id="定性结果"><a href="#定性结果" class="headerlink" title="定性结果"></a>定性结果</h3><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127162102966.png" alt="image-20241127162102966" style="zoom:80%;"><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127162127244.png" alt="image-20241127162127244" style="zoom:80%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了MVBench，一个评估mllm的时间理解能力的综合基准。此外，本文针对现有视频对话模型的缺陷，构造了更丰富的指令微调数据，提出了一个健壮的视频MLLM基线模型，VideoChat2，在MVBench上比领先的模型表现超过15%。我们广泛的分析进一步指导了MLLM的时间理解的设计。</p><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="==项目配置=="></a>==项目配置==</h2><h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>以JSON格式提供了一个包含2M数据注释的综合数据集。annotation示例如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"image"</span><span class="token operator">:</span> <span class="token string">"two_col_103562.png"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"i"</span><span class="token operator">:</span> <span class="token string">"Examine the chart's visual features and the underlying data table closely to provide an accurate answer to the question."</span><span class="token punctuation">,</span> <span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"As of 2021, how many championship titles had Ferrari won?"</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"The answer is 16."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token punctuation">{</span><span class="token property">"image"</span><span class="token operator">:</span> <span class="token string">"two_col_2954.png"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"i"</span><span class="token operator">:</span> <span class="token string">"Analyze the visual and data components of the chart carefully and answer the question based on both the graphical representation and numerical data provided."</span><span class="token punctuation">,</span> <span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"What game topped the charts with 512.3 million hours watched on Twitch in the first half of 2019?"</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"The answer is League of Legends."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span> .....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>视频分类：</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241129145657121.png" alt="image-20241129145657121" style="zoom:80%;"><p>视频caption生成：</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241129145746658.png" alt="image-20241129145746658" style="zoom:80%;"><h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p><strong>图像数据源</strong>：</p><p>M3IT（<a href="https://huggingface.co/datasets/MMInstruction/M3IT%EF%BC%89%EF%BC%8C%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8B%E6%96%B9%E5%BC%8F%E8%BF%87%E6%BB%A4%E5%87%BA%E8%B4%A8%E9%87%8F%E8%BE%83%E4%BD%8E%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A">https://huggingface.co/datasets/MMInstruction/M3IT），通过以下方式过滤出质量较低的数据：</a></p><ul><li>纠正拼写错误：大多数标点符号使用不正确的句子都得到了纠正。</li><li>改写错误答案：ChatGPT生成的一些回复，如“对不起，…”，是不正确的。这些用GPT-4重新表述。</li></ul><p><strong>视频数据源：</strong></p><ul><li>VideoChat（<a href="https://github.com/OpenGVLab/InternVideo/tree/main/Data/instruction_data%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EInternVid%E5%88%9B%E5%BB%BA%E4%BA%86%E9%A2%9D%E5%A4%96%E7%9A%84%E6%8C%87%E4%BB%A4%E6%95%B0%E6%8D%AEinstruction%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8GPT-4%E5%8E%8B%E7%BC%A9%E7%8E%B0%E6%9C%89%E6%95%B0%E6%8D%AE%E3%80%82">https://github.com/OpenGVLab/InternVideo/tree/main/Data/instruction_data）：基于InternVid创建了额外的指令数据instruction，并使用GPT-4压缩现有数据。</a></li><li>VideoChatGPT（<a href="https://github.com/mbzuai-oryx/Video-ChatGPT/tree/main/data%EF%BC%89%EF%BC%9A%E5%8E%9F%E5%A7%8Bcaption%E6%95%B0%E6%8D%AE%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%90%8C%E7%9A%84VideoID%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E3%80%82">https://github.com/mbzuai-oryx/Video-ChatGPT/tree/main/data）：原始caption数据基于相同的VideoID转换为对话数据。</a></li><li>Kinetics-710（<a href="https://github.com/OpenGVLab/UniFormerV2/blob/main/DATASET.md%EF%BC%89%E5%92%8CSthSthV2%EF%BC%88[Datasets](https://www.qualcomm.com/developer/artificial-intelligence/datasets)%EF%BC%89%EF%BC%9A%E9%80%89%E9%A1%B9%E5%80%99%E9%80%89%E6%98%AF%E6%A0%B9%E6%8D%AEUMT%E5%89%8D20%E5%90%8D%E7%9A%84%E9%A2%84%E6%B5%8B%E7%94%9F%E6%88%90%E7%9A%84%E3%80%82">https://github.com/OpenGVLab/UniFormerV2/blob/main/DATASET.md）和SthSthV2（[Datasets](https://www.qualcomm.com/developer/artificial-intelligence/datasets)）：选项候选是根据UMT前20名的预测生成的。</a></li><li>NExTQA（<a href="https://github.com/doc-doc/NExT-QA%EF%BC%89%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%8B%BC%E5%86%99%E9%94%99%E8%AF%AF%E5%B7%B2%E8%A2%AB%E7%BA%A0%E6%AD%A3%E3%80%82">https://github.com/doc-doc/NExT-QA）：原始句子中的拼写错误已被纠正。</a></li><li>CLEVRER（<a href="https://clevrer.csail.mit.edu/%EF%BC%89%EF%BC%9A%E5%AF%B9%E4%BA%8E%E5%8D%95%E9%A1%B9%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%8C%E5%8F%AA%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%8E%E9%A2%9C%E8%89%B2/%E6%9D%90%E6%96%99/%E5%BD%A2%E7%8A%B6%E6%9C%89%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82%E5%A4%9A%E9%A1%B9%E9%80%89%E6%8B%A9%E9%A2%98%E5%88%99%E5%88%A9%E7%94%A8%E4%BA%86%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E3%80%82">https://clevrer.csail.mit.edu/）：对于单项选择题，只使用了与颜色/材料/形状有关的问题。多项选择题则利用了所有数据。</a></li><li>WebVid（<a href="https://maxbain.com/webvid-dataset/%EF%BC%89%EF%BC%9A%E9%80%89%E6%8B%A9%E9%9D%9E%E9%87%8D%E5%8F%A0%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%AD%97%E5%B9%95%E5%92%8CQA%E3%80%82">https://maxbain.com/webvid-dataset/）：选择非重叠数据进行字幕和QA。</a></li><li>YouCook2（<a href="https://youcook2.eecs.umich.edu/%EF%BC%89%EF%BC%9A%E6%A0%B9%E6%8D%AE%E5%AE%98%E6%96%B9%E7%9A%84%E5%AF%86%E9%9B%86caption%EF%BC%8C%E5%8E%9F%E5%A7%8B%E8%A7%86%E9%A2%91%E8%A2%AB%E6%88%AA%E6%96%AD%E3%80%82">https://youcook2.eecs.umich.edu/）：根据官方的密集caption，原始视频被截断。</a></li><li>TextVR（[callsys/TextVR: <a href="https://github.com/callsys/textvr">PR 2024] A large Cross-Modal Video Retrieval Dataset with Reading Comprehension</a>）：所有数据均未经修改。</li><li>TGIF（<a href="https://github.com/YunseokJANG/tgif-qa">YunseokJANG/tgif-qa: Repository for our CVPR 2017 and IJCV: TGIF-QA</a>）：只使用了TGIF${frame}$和TGIF${Transition}$子集。</li><li>EgoQA（<a href="https://ego4d-data.org/">Egocentric 4D Perception (EGO4D)</a>）：一些以自我为中心的QA是从Ego4D数据中生成的。</li></ul><p>对于所有数据集，任务指令都是使用GPT-4自动生成的。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h3 id="conda配置"><a href="#conda配置" class="headerlink" title="conda配置"></a>conda配置</h3><ul><li>git clone拷贝远程仓库超时：设置全局代理，clash打开允许局域网接入。注意代理ip是本机电脑ip，不是服务器ip。</li></ul><p><strong>准备训练环境：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> videochat2 <span class="token assign-left variable">python</span><span class="token operator">=</span><span class="token number">3.9</span>conda activate videochat2pip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>注意这里pip install可能是系统的pip，而不是环境的pip，会导致当前虚拟环境并没有相应依赖</strong>：<a href="https://blog.csdn.net/qq_44856695/article/details/131378398">如何在conda环境中正确地使用pip_在conda构建的虚拟环境下可以进行pip操作吗-CSDN博客</a></p></li><li><p>CondaHTTPError: HTTP 000 CONNECTION FAILED</p><ul><li>conda换清华源：</li></ul></li></ul> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda config <span class="token parameter variable">--add</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config <span class="token parameter variable">--add</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config <span class="token parameter variable">--add</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config <span class="token parameter variable">--append</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/fastai/conda config <span class="token parameter variable">--append</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config <span class="token parameter variable">--append</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ conda config <span class="token parameter variable">--set</span> show_channel_urls <span class="token function">yes</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>修改conda配置信息：<code>vim ~/.condarc</code>，<strong>删除 - defaults（重要！！）</strong> 增加 ssl_verify: false。保存后重新创建环境</p></li><li><p>ModuleNotFoundError: No module named ‘torch’</p><ul><li>离线下载对应版本：<a href="https://download.pytorch.org/whl/torchvision/">download.pytorch.org/whl/torchvision/</a></li></ul></li></ul><h3 id="阶段1训练"><a href="#阶段1训练" class="headerlink" title="阶段1训练"></a>阶段1训练</h3><p> Download <a href="https://huggingface.co/OpenGVLab/videochat2/resolve/main/l16_25m.pth">UMT-L/16</a> model and set <code>pretrained</code> in <a href="https://github.com/wolf-ll/Ask-Anything/blob/main/video_chat2/scripts/videochat_vicuna/config_7b_stage1.py">stage1_config</a></p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> scripts/videochat_vicuna/run_7b_stage1.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>AttributeError: module ‘numpy’ has no attribute ‘float’.</p><ul><li>重新安装<code>numpy</code>。出现这个问题是因为np.float从1.24起被删除。所用的代码是依赖于旧版本的Numpy。您可以将你的Numpy版本降级到1.23.5.</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> <span class="token assign-left variable">numpy</span><span class="token operator">==</span><span class="token number">1.23</span>.5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>linux环境下 python import不了自定义的包，即无法找到项目路径。</p><ul><li>手动导入项目根路径：</li></ul></li></ul> <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys <span class="token punctuation">,</span> osbase_dir <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>__file__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>base_dir<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>衍生报错：</strong>Traceback (most recent call last):  File “/home/bailey/Code/wyf/Ask-Anything/video_chat2/tasks/train_qformer.py”, line 298, in &lt;module&gt;。。。 File “/home/bailey/Code/wyf/Ask-Anything/video_chat2/utils/config_utils.py”, line 180, in setup_main    Config.dump(config, os.path.join(config.output_dir, “config.json”))。。。。**TypeError: Object of type module is not JSON serializable Traceback (most recent call last):**。。。<ul><li>本质是<strong>在<code>config</code>对象当中包含了对 Python 模块对象的引用，而这些引用与正在执行的操作（JSON 序列化和深拷贝）不兼容。</strong>因此需要<strong>去掉config对象中的sys和os这两个key对应的元素</strong>（这俩key的value都是module）</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">filter_module_refs</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token builtin">dict</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 对于字典类型，遍历每个键值对，对值进行递归处理</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>k<span class="token punctuation">:</span> filter_module_refs<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> obj<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> types<span class="token punctuation">.</span>ModuleType<span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token keyword">elif</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 对于列表类型，遍历每个元素，对元素进行递归处理</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>filter_module_refs<span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token keyword">for</span> element <span class="token keyword">in</span> obj <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> types<span class="token punctuation">.</span>ModuleType<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token comment"># 如果不是字典也不是列表，直接返回该元素（非模块类型的都返回）</span>        <span class="token keyword">return</span> obj <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> types<span class="token punctuation">.</span>ModuleType<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>衍生报错</strong>：在train_former197行set up model内部进行deepcopy时，报错 y[deepcopy(key, memo)] = deepcopy(value, memo)<br>  File “/home/bailey/anaconda3/envs/videochat2/lib/python3.9/copy.py”, line 161, in deepcopy<br>rv = reductor(4)<br>TypeError: <strong>cannot pickle ‘module’ object</strong>。。。</p><ul><li>本质还是因为python 试图序列化一个模块对象，但模块对象是不可序列化的。</li><li>解决思路：在train_former.py下改了很多次config对象都没有用，最后在utils/config_utils.py的<strong>Config.dump()前去掉config对象中的模块对象</strong>就解决了。</li><li>且这样改了以后，Found module object under key的提示会出现两次，也就是两个子线程分别去掉了模块对象，之后才在主线程中dump</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 这个判断module object的操作放在判断main进程前面</span>   <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> config<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>       <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> types<span class="token punctuation">.</span>ModuleType<span class="token punctuation">)</span><span class="token punctuation">:</span>           <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Found module object under key: </span><span class="token interpolation"><span class="token punctuation">{</span>key<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>           config<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span>   <span class="token keyword">if</span> is_main_process<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>       setup_output_dir<span class="token punctuation">(</span>config<span class="token punctuation">.</span>output_dir<span class="token punctuation">,</span> excludes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"code"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       setup_logger<span class="token punctuation">(</span>output<span class="token operator">=</span>config<span class="token punctuation">.</span>output_dir<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"vindlu"</span><span class="token punctuation">)</span>       <span class="token comment"># logger.info(f"config: {Config.pretty_text(config)}")</span>       Config<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>config<span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>config<span class="token punctuation">.</span>output_dir<span class="token punctuation">,</span> <span class="token string">"config.json"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>apt-get install报错文件尺寸不符：apt-get换国内镜像源</p><ul><li><a href="https://blog.csdn.net/qq_40765537/article/details/105936653">Ubuntu中apt-get命令以及修改apt-get镜像源-CSDN博客</a></li></ul></li><li><p>libcusparse.so.11: cannot open shared object file: No such file or dir报错：<a href="https://blog.csdn.net/qq_42727728/article/details/123857908">【最快解决方案】安装torch-geometric报错 libcusparse.so.11: cannot open shared object file: No such file or dir_oserror: libcusparse.so.11: cannot open shared obj-CSDN博客</a></p><ul><li>先<code>locate libcusparse.so.11</code>找一下服务器有没有对应文件，有的话直接复制到这个博客中说的路径下（发现bailey机器上libcusparse.so.11只有20kb，有一个libcusparse.so.11.7.4.91文件200+mb，把这俩一起复制过去也不行，最后用的llama项目虚拟环境下200+m的后缀11的文件替换就行了</li></ul></li><li><p>Failed to load image Python extension: libtorch_cuda_cu.so</p><ul><li>pytorch和torchvision的版本问题</li></ul></li><li><p><strong>ERROR:torch.distributed.elastic.multiprocessing.api:failed (exitcode: 1) local_rank: 0 (pid: 3938937) of binary:</strong> </p><ul><li>本来以为是PyTorch 的 CUDA 版本与系统上的 CUDA 版本不兼容的问题。从原来的<code>torch==1.13.1+cu117</code>换成<code>torch==1.12.0+cu113</code>，但问题依然存在。（系统cuda为11.5）</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token assign-left variable">torch</span><span class="token operator">==</span><span class="token number">1.12</span>.0+cu113 <span class="token assign-left variable">torchvision</span><span class="token operator">==</span><span class="token number">0.13</span>.0+cu113 <span class="token assign-left variable">torchaudio</span><span class="token operator">==</span><span class="token number">0.12</span>.0 --extra-index-url https://download.pytorch.org/whl/cu113<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>而且torch降低为1.12以后，与peft冲突（peft 0.4.0 requires torch&gt;=1.13.0），且bitsandbytes和cuda版本又会不匹配</li><li>最后torch又装回1.13.1了，cuda11.7（各种版本下载对应：<a href="https://pytorch.org/get-started/previous-versions/">Previous PyTorch Versions | PyTorch</a>）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token assign-left variable">torch</span><span class="token operator">==</span><span class="token number">1.13</span>.1+cu117 <span class="token assign-left variable">torchvision</span><span class="token operator">==</span><span class="token number">0.14</span>.1+cu117 <span class="token assign-left variable">torchaudio</span><span class="token operator">==</span><span class="token number">0.13</span>.1 --extra-index-url https://download.pytorch.org/whl/cu117<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>wandb：命令行输入<code>wandb login</code>在官网登录，并将api key复制回命令行</li></ul><h4 id="bert相关"><a href="#bert相关" class="headerlink" title="bert相关"></a>bert相关</h4><ul><li><p>在shared_utils_qformer中setup_model时，BertTokenizer.from_pretrained(config.model.text_encoder.pretrained, local_files_only=True)报错   <strong>OSError: Can’t load tokenizer for ‘bert-base-uncased’.</strong> If you were trying to load it from ‘<a href="https://huggingface.co/models">https://huggingface.co/models</a>‘, make sure you don’t have a local directory with the same name. Otherwise, make sure ‘bert-base-uncased’ is the correct path to a directory containing all relevant files for a BertTokenizer tokenizer.</p><ul><li><p>原因：主机<strong>或服务器</strong>不能访问<a href="https://huggingface.co/%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%BA%94%E7%9A%84%E6%9D%83%E9%87%8D%E3%80%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%AC%E5%9C%B0%E3%80%82">https://huggingface.co/页面，因此不能下载相应的权重。解决方法：手动下载文件到本地。</a></p></li><li><p><a href="https://blog.csdn.net/weixin_47187147/article/details/140004137">OSError: Can‘t load tokenizer for ‘bert-base-uncased‘. If you were trying to load it from_oserror: can’t load tokenizer for ‘bert-base-uncas-CSDN博客</a></p></li><li><p>下载后放到tasks/bert-base-uncased路径，修改configs/model.py</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">TextEncoders<span class="token punctuation">[</span><span class="token string">"bert"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>    name<span class="token operator">=</span><span class="token string">"bert_base"</span><span class="token punctuation">,</span>    pretrained<span class="token operator">=</span><span class="token string">"/home/…………/tasks/bert-base-uncased/"</span><span class="token punctuation">,</span>    ………………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>**’BertTokenizer’ object has no attribute ‘vocab’**：修改models/bert/tokenization_bert.py文件，将self.vocab = load_vocab(vocab_file)从init方法后移到前面去（参考：<a href="https://blog.csdn.net/bitttiolkk/article/details/136612497">Debug：AttributeError: ‘BertTokenizer‘ object has no attribute ‘vocab‘_attributeerror: ‘berttokenizer’ object has no attr-CSDN博客</a>）</p></li><li><p>OSError: We couldn’t connect to ‘<a href="https://huggingface.co/">https://huggingface.co</a>‘ to load this file, couldn’t find it in the cached files and it looks like bert-base-uncased is not the path to a directory containing a file named config.json.</p></li></ul><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20250103205905009.png" alt="image-20250103205905009" style="zoom:67%;"><blockquote><p>使用 .from_pretrained(“xxxxx”)方法加载，本地加载bert需要修改两个地方，一是tokenizer部分，二是model部分：<br>step1、导包： from transformers import BertModel，BertTokenizer<br>step2、载入词表： tokenizer = BertTokenizer.from_pretrained(“./bert_localpath/“) 这里要注意！！除了你自己建的文件夹名外，后面一定要加个/，才能保证该方法找到咱的vocab.txt<br>step3、载入模型： bert = BertModel.from_pretrained(“./bert_localpath”) 然后，这个地方又不需要加上/</p></blockquote><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><p><a href="https://github.com/salesforce/LAVIS/blob/main/lavis/datasets/download_scripts/DownloadConceptualCaptions/download_data_cc3m.py">LAVIS/lavis/datasets/download_scripts/DownloadConceptualCaptions/download_data_cc3m.py at main · salesforce/LAVIS</a></p><p>—- 最好别用这个下，开了多线程电脑会卡，内存可能不够</p><p><a href="https://opensource.salesforce.com/LAVIS//latest/getting_started.html#auto-downloading-and-loading-datasets">Dataset Zoo — LAVIS documentation</a></p><p><a href="https://github.com/rom1504/img2dataset/blob/main/dataset_examples/cc3m.md">img2dataset/dataset_examples/cc3m.md at main · rom1504/img2dataset</a></p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>dataset/init.py</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_media_type</span><span class="token punctuation">(</span>dataset_config<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>dataset_config<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">3</span> <span class="token keyword">and</span> dataset_config<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"video"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"video"</span><span class="token comment"># 视频数据集，由标注+源数据+类型标记video构成</span>    <span class="token keyword">elif</span> <span class="token builtin">len</span><span class="token punctuation">(</span>dataset_config<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">3</span> <span class="token keyword">and</span> dataset_config<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"text"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"text"</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"image"</span><span class="token comment"># 图像数据，list里只有标注+源数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dataset config.json</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"train_file"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span>      <span class="token string">"annotation/anno_pretrain/webvid_10m_train.json"</span><span class="token punctuation">,</span>      <span class="token string">"annotation/videos_images/webvid_10m"</span><span class="token punctuation">,</span>      <span class="token string">"video"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span>      <span class="token string">"annotation/anno_pretrain/cc3m_train.json"</span><span class="token punctuation">,</span>      <span class="token string">"annotation/videos_images/cc3m"</span>    <span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"test_file"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"msrvtt_1k_test"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token string">"annotation/anno_pretrain/msrvtt_test1k.json"</span><span class="token punctuation">,</span>      <span class="token string">"annotation/videos_images/MSRVTT_Videos"</span><span class="token punctuation">,</span>      <span class="token string">"video"</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"test_types"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"msrvtt_1k_test"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pt_dataset.py</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PTImgTrainDataset</span><span class="token punctuation">(</span>ImageVideoBaseDataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    media_type <span class="token operator">=</span> <span class="token string">"image"</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ann_file<span class="token punctuation">,</span> transform<span class="token punctuation">,</span> pre_text<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ann_file<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token keyword">and</span> ann_file<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"video"</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>media_type <span class="token operator">=</span> <span class="token string">"video"</span>              self<span class="token punctuation">.</span>media_name <span class="token operator">=</span> <span class="token string">"key"</span><span class="token comment"># 自己做的数据集，json文件里面对应图名称的是key</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>media_type <span class="token operator">=</span> <span class="token string">"image"</span>            self<span class="token punctuation">.</span>media_name <span class="token operator">=</span> <span class="token string">"key"</span>        self<span class="token punctuation">.</span>label_file<span class="token punctuation">,</span> self<span class="token punctuation">.</span>data_root <span class="token operator">=</span> ann_file<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>        logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"=========label file : </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>label_file<span class="token punctuation">}</span></span><span class="token string">, data root : </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>data_root<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>        <span class="token comment"># 对于第一阶段训练， =========label file : annotation/anno_pretrain/cc3m_train.json, data root : annotation/videos_images/cc3m     =========label file : annotation/anno_pretrain/webvid_10m_train.json, data root : annotation/videos_images/webvid_10m</span>        logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'Load json file'</span><span class="token punctuation">)</span>        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>label_file<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>anno <span class="token operator">=</span> json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>num_examples <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>anno<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>transform <span class="token operator">=</span> transform        self<span class="token punctuation">.</span>pre_text <span class="token operator">=</span> pre_text        logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Pre-process text: </span><span class="token interpolation"><span class="token punctuation">{</span>pre_text<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_anno</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 针对自己做的数据集做一些特定处理</span>        <span class="token keyword">if</span> <span class="token string">"cc3m"</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>label_file<span class="token punctuation">:</span>            filename <span class="token operator">=</span> self<span class="token punctuation">.</span>anno<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>media_name<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">".jpg"</span>        <span class="token keyword">elif</span> <span class="token string">"webvid"</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>label_file<span class="token punctuation">:</span>            filename <span class="token operator">=</span> self<span class="token punctuation">.</span>anno<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>media_name<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">".mp4"</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            filename <span class="token operator">=</span> self<span class="token punctuation">.</span>anno<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>media_name<span class="token punctuation">]</span>        caption <span class="token operator">=</span> self<span class="token punctuation">.</span>anno<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"caption"</span><span class="token punctuation">]</span>        anno <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"image"</span><span class="token punctuation">:</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>data_root<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"caption"</span><span class="token punctuation">:</span> caption<span class="token punctuation">}</span>        <span class="token keyword">return</span> anno<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>evaluate text-encoder修改（原来是None）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># tasks/retrieval_utils</span>text_encoder <span class="token operator">=</span> model<span class="token punctuation">.</span>get_text_encoder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># models/videochat2_qformer.py</span><span class="token keyword">def</span> <span class="token function">get_text_encoder</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> build_bert<span class="token punctuation">(</span>self<span class="token punctuation">.</span>config<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># models/bert/builder.py</span><span class="token keyword">def</span> <span class="token function">build_bert</span><span class="token punctuation">(</span>model_config<span class="token punctuation">,</span> pretrain<span class="token punctuation">,</span> checkpoint<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""build text encoder.    Args:        model_config (dict): model config.        pretrain (bool): Whether to do pretrain or finetuning.        checkpoint (bool): whether to do gradient_checkpointing.    Returns: TODO    """</span>    bert_config <span class="token operator">=</span> BertConfig<span class="token punctuation">.</span>from_json_file<span class="token punctuation">(</span>model_config<span class="token punctuation">.</span>text_encoder<span class="token punctuation">.</span>config<span class="token punctuation">)</span>    bert_config<span class="token punctuation">.</span>encoder_width <span class="token operator">=</span> model_config<span class="token punctuation">.</span>vision_encoder<span class="token punctuation">.</span>d_model    bert_config<span class="token punctuation">.</span>gradient_checkpointing <span class="token operator">=</span> checkpoint    bert_config<span class="token punctuation">.</span>fusion_layer <span class="token operator">=</span> model_config<span class="token punctuation">.</span>text_encoder<span class="token punctuation">.</span>fusion_layer    <span class="token keyword">if</span> <span class="token keyword">not</span> model_config<span class="token punctuation">.</span>multimodal<span class="token punctuation">.</span>enable<span class="token punctuation">:</span>        bert_config<span class="token punctuation">.</span>fusion_layer <span class="token operator">=</span> bert_config<span class="token punctuation">.</span>num_hidden_layers    <span class="token keyword">if</span> pretrain<span class="token punctuation">:</span>        text_encoder<span class="token punctuation">,</span> loading_info <span class="token operator">=</span> BertForMaskedLM<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>            model_config<span class="token punctuation">.</span>text_encoder<span class="token punctuation">.</span>pretrained<span class="token punctuation">,</span>            config<span class="token operator">=</span>bert_config<span class="token punctuation">,</span>            output_loading_info<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        text_encoder<span class="token punctuation">,</span> loading_info <span class="token operator">=</span> BertModel<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>            model_config<span class="token punctuation">.</span>text_encoder<span class="token punctuation">.</span>pretrained<span class="token punctuation">,</span>            config<span class="token operator">=</span>bert_config<span class="token punctuation">,</span>            add_pooling_layer<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>            output_loading_info<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>    <span class="token keyword">return</span> text_encoder<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="张量设备"><a href="#张量设备" class="headerlink" title="张量设备"></a>张量设备</h5><p><strong>训练时</strong></p><p>output = text_encoder( …………)  执行这个操作时报错  Expected all tensors to be on the same device, but found at least two devices, cpu and cuda:1! (when checking argument for argument mat1 in method wrapper_addmm)</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20250105172608783.png" alt="image-20250105172608783" style="zoom: 50%;"><p><strong>evaluate时</strong></p><p>RuntimeError: indices should be either on cpu or on the same device as the indexed tensor (cpu)</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20250106130038364.png" alt="image-20250106130038364" style="zoom:50%;"><h5 id="数据维度"><a href="#数据维度" class="headerlink" title="数据维度"></a>数据维度</h5><p>clip计算相似分数时报错：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">Traceback (most recent call last):  File "/home/bailey/Code/wyf/Ask-Anything/video_chat2/tasks/train_qformer.py", line 302, in &lt;module&gt;    main(cfg)  File "/home/bailey/Code/wyf/Ask-Anything/video_chat2/tasks/train_qformer.py", line 232, in main    res = evaluation_wrapper(  File "/home/bailey/anaconda3/envs/videochat2/lib/python3.9/site-packages/torch/autograd/grad_mode.py", line 27, in decorate_context    return func(*args, **kwargs)  File "/home/bailey/Code/wyf/Ask-Anything/video_chat2/tasks/retrieval_utils.py", line 75, in evaluation_wrapper    i2t_x, t2i_x, i2t_emb, t2i_emb = evaluation(  File "/home/bailey/anaconda3/envs/videochat2/lib/python3.9/site-packages/torch/autograd/grad_mode.py", line 27, in decorate_context    return func(*args, **kwargs)  File "/home/bailey/Code/wyf/Ask-Anything/video_chat2/tasks/retrieval_utils.py", line 258, in evaluation    score = model.itm_head(itm_embeds)[:, 1]  File "/home/bailey/anaconda3/envs/videochat2/lib/python3.9/site-packages/torch/nn/modules/module.py", line 1194, in _call_impl    return forward_call(*input, **kwargs)  File "/home/bailey/anaconda3/envs/videochat2/lib/python3.9/site-packages/torch/nn/modules/linear.py", line 114, in forward    return F.linear(input, self.weight, self.bias)RuntimeError: mat1 and mat2 shapes cannot be multiplied (128x768 and 1536x2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体来说，**<code>itm_embeds</code>** 的形状为 <code>(128, 768)</code>，而 <strong><code>itm_head</code></strong> 的权重矩阵的形状为 <code>(1536, 2)</code>，这两者的维度不匹配，无法进行矩阵乘法。</p><p>在videochat2_qformer里面可以看到，配置vtm_cat_text_cls=true，会使得矩阵形状变成2倍。因此在配置文件里把这个改成false即可。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20250106002754122.png" alt="image-20250106002754122" style="zoom:50%;"><h4 id="阶段一训练结果"><a href="#阶段一训练结果" class="headerlink" title="阶段一训练结果"></a>阶段一训练结果</h4><p>原始数据量：（本机路径D:\AMLLM-Video\annotation）</p><ul><li><p>图像cc3m  20184张</p></li><li><p>视频MSRVTT 10000个</p></li><li><p>视频webvid  1809个</p></li></ul><p>训练用cc3m和webvid，测试用了MSRVTT中的1000条数据。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20250106150125960.png" alt="image-20250106150125960" style="zoom:67%;"><h3 id="阶段2训练"><a href="#阶段2训练" class="headerlink" title="阶段2训练"></a>阶段2训练</h3><p>新增数据集InternVID，见MLLM-Code。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yang_daxia/article/details/139950072">论文阅读MVBench: A Comprehensive Multi-modal Video Understanding Benchmark-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/669658267">CVPR2024 Highlight] MVBench多模态视频理解能力的全面评测 - 知乎</a></p><p>代码： <a href="https://github.com/OpenGVLab/Ask-Anything/tree/main/video_chat2">Ask-Anything/video_chat2 at main · OpenGVLab/Ask-Anything</a></p><p><a href="https://zhuanlan.zhihu.com/p/260034241">『技术随手学』解决CondaHTTPError: HTTP 000 CONNECTION 问题 - 知乎</a></p><p><a href="https://blog.csdn.net/kekechengxiao/article/details/134491661">import torchModuleNotFoundError: No module named ‘torch‘_import torch 找不到模块-CSDN博客</a></p><p>conda中使用pip的问题：<a href="https://blog.csdn.net/qq_44856695/article/details/131378398">如何在conda环境中正确地使用pip_在conda构建的虚拟环境下可以进行pip操作吗-CSDN博客</a></p><p><a href="https://pytorch.org/get-started/previous-versions/">Previous PyTorch Versions | PyTorch</a></p><p>wandb使用：<a href="https://blog.csdn.net/qq_40507857/article/details/112791111">wandb: 深度学习轻量级可视化工具入门教程_wandb教程-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_42730750/article/details/119249193">Pycharm远程连接服务器进行代码的运行与调试_remote sdk is saved in idesetting-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_47187147/article/details/140004137">OSError: Can‘t load tokenizer for ‘bert-base-uncased‘. If you were trying to load it from_oserror: can’t load tokenizer for ‘bert-base-uncas-CSDN博客</a></p><p><a href="https://huggingface.co/google-bert/bert-base-uncased/tree/main">google-bert/bert-base-uncased at main</a></p><p>[<a href="https://blog.csdn.net/weixin_57972634/article/details/143758599">实验日志·已解决] 如何下载 + 加载本地的BERT预训练模型 （OSError: Can‘t load tokenizer for ‘bert-base-uncased‘.）_本地加载bert-base包-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_56438555/article/details/144110166">（超全方法）尝试解决问题：torch.cuda.OutOfMemoryError: CUDA out of memory._torch.outofmemoryerror: cuda out of memory.-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_41185868/article/details/137062748">LLMs之Mistral：Mistral 7B v0.2的简介、安装和使用方法、案例应用之详细攻略_mistral-7b-instruct-v0.2-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MLLM </tag>
            
            <tag> 视频理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TimeChat</title>
      <link href="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/"/>
      <url>/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/</url>
      
        <content type="html"><![CDATA[<h1 id="TimeChat-A-Time-sensitive-Multimodal-Large-Language-Model"><a href="#TimeChat-A-Time-sensitive-Multimodal-Large-Language-Model" class="headerlink" title="TimeChat: A Time-sensitive Multimodal Large Language Model"></a>TimeChat: A Time-sensitive Multimodal Large Language Model</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本研究提出的 TimeChat 是一种时间敏感的多模态大型语言模型，专为长视频理解而设计。模型包含两个关键的架构贡献：（1）<strong>时间戳感知帧编码器</strong>，可以将视觉内容与每个帧的时间戳绑定；（2）<strong>滑动视频 Q-Former</strong>，生成不同长度的视频token序列，以适应不同时长的视频。此外，本文还构建了一个<strong>指令微调（instruction-tuning）数据集，包含 6 个任务和总共 125K 个实例</strong>，以进一步提高 TimeChat 的instruction-following性能。各种视频理解任务（如dense captioning, temporal grounding, and highlight detection）的实验结果都证明了 TimeChat 强大的<strong>零样本时间定位和推理</strong>能力。例如，与最先进的视频大语言模型相比，TimeChat 在 YouCook2 上获得了 +9.2 的 F1  score和 +2.8 的 CIDEr 分数，在 QVHighlights 上获得了 +5.8 的 HIT@1 分数，在 Charades-STA 上获得了 +27.5 的 R@1 分数（IoU=0.5），有望成为<strong>长视频理解任务的多功能视频助手</strong>，满足用户的实际需求。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241013105855336.png" alt="image-20241013105855336" style="zoom:80%;"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>背景</strong></p><ul><li>从教育教程到故事电影，长格式的视频已经成为我们日常生活中的一个重要媒介。但筛选冗长的视频是相当耗时且无趣的工作。</li><li>人类的注意力总是被有意义的或突出的视觉片段所吸引，比如烹饪教程中的基本步骤或体育赛事中的精彩时刻。</li><li>一个智能的时间敏感视频助手，为用户分析长视频，包括<strong>时间定位、时间戳检测和关键时刻总结</strong>，是社会的长期需求。</li><li>大模型拥有强大的<strong>指令遵循</strong>能力，可以用于长视频理解任务，满足用户的现实需求。</li></ul><p><strong>现状</strong></p><ul><li>已经进行了一些初步探索以集成视觉编码器和LLM来实现基本的视频理解（说明字幕、问答）。</li><li>然而，现有的视频LLM（VidLLM）只能<strong>捕获短片段的全局视觉语义</strong>，而不能<strong>将重要的视频内容与准确的时间戳关联</strong>起来。<ul><li>例如，VideoLLaMA和VideoChat努力定位和描述未经修剪的视频中的有意义的事件，导致在Tab2中验证的准确性较低。</li><li>个人理解：上述两种模型侧重识别特定事件发生，本文模型侧重时间戳定位。<strong>在社区事件定位场景中需要取二者均衡。</strong></li></ul></li></ul><p>现有的VidLLM有两个问题：（1）刚性压缩将视频token转换为固定数字不适合长视频输入–它忽略了视频的持续时间，在处理长视频的大量帧时，导致严重的<strong>时空语义退化。</strong>（2）它们分别处理视频和时间戳信息，而不考虑显式的<strong>时间-视觉关联</strong>，因此无法准确地定位时间戳。</p><p><strong>本文贡献</strong></p><ul><li><p>提出TimeChat，一种时间敏感的多模态大语言模型，用于长视频理解和准确的时间定位。</p></li><li><p>为了处理长视频输入，提出了一种<strong>滑动视频Q-Former</strong>来适应视频特征提取和压缩过程中的自适应视频标记长度。视频Q-Former将滑窗内的帧压缩为视频token。移动窗口可以动态创建不同长度的视频token序列。它保留了<strong>长视频的重要视觉语义</strong>，并得到了更具表现力和可伸缩的视频表示。（<strong>捕获帧间时间信息</strong>）</p></li><li><p>为了增强<strong>视觉-时间戳的关联</strong>，提出了一个具有时间感知能力的<strong>帧编码器</strong>，它显式地将视觉上下文与每个帧的时间戳描述绑定起来。（<strong>绑定帧+时间戳信息</strong>）</p></li><li><p>为了提高TimeChat固有的时间戳定位能力，增强它的指令遵循能力，构建了一个新的指<strong>令调优数据集TimeIT</strong>，涉及不同的<strong>时间戳相关的用户指令</strong>。该数据集是由各种与时间戳相关的长视频数据集编译而来的，平均视频长度为<strong>190.8s</strong>。它由6个不同的任务、12个广泛使用的学术基准和总共125K实例组成。（<strong>增强时间-视觉关联能力</strong>）</p></li></ul><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>许多研究都在努力将llm与视频编码器集成起来，从而利用llm的强大理解和生成能力来进行视频任务。这些研究通常使用开源的llm，如Vicuna和LLaMA。它们的关键区别在于它们<strong>如何将视频编码为与llm兼容的视觉token</strong>。有代表性的工作，如VideoChat利用一个video transformer来编码视频features，随后实现一个Query Transformer（Q-Former）来压缩video tokens。VideoLLaMA首先使用vision transformer（ViT）和图像Q-Former对独立帧进行编码，然后使用视频Q-Former进行时间建模。然而，这些方法将视频token压缩到一个固定的数字，导致在处理长视频时视觉语义退化。相比之下，本文模型为视觉标记提供了可调的压缩率，增加了对不同视频长度的适应性。此外，模型明确地建立了一个帧级的视觉-时间戳关系，以提高时间定位能力。</p><p>视觉-语言指令微调需要使用人工指令生成高质量的数据，这可以分为两个技术分支。（1）合并可用的多模态基准数据集，将它们转化为指令格式；（2）利用GPT生成更多样化的对话式数据。</p><p>时间定位是视频理解任务的一个基本能力，特别是对于未修剪的长视频。有各种时间敏感的视频任务，包括视频时间定位、视频说明字幕、视频摘要、视频亮点检测、步长定位等。这些任务需要在视频语义和相应的时间戳之间进行显式的关联。以前的研究倾向于在专门的下游数据集上单独处理每个任务。尽管最近的工作对弥合一些任务进行了初步的尝试，但基于llm的通用范式仍在探索中。本文在语言建模上统一了一些时间敏感的视频任务，迈出了充分利用llm的通用能力的第一步。</p><h2 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h2><p>模型组件主要由三部分构成：1）时间感知帧编码器，2）视频滑窗Q-Former，3）LLM</p><p>给定一个输入视频，帧编码器首先<strong>独立地提取每个帧的视觉和时间戳特征</strong>。接下来，视频Q-Former建模<strong>滑动窗口内帧的时间关系</strong>，以生成视频token。最后，将这些视频token与可选的转录语音和用户指令连接起来，然后将这些指令输入LLM以生成响应。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241013153746315.png" alt="image-20241013153746315" style="zoom:80%;"><h3 id="Timestamp-aware-Frame-Encoder"><a href="#Timestamp-aware-Frame-Encoder" class="headerlink" title="Timestamp-aware Frame Encoder"></a>Timestamp-aware Frame Encoder</h3><p>以前的研究通常将视觉语义的建模和输入帧各自的时间戳信息分开。该方法不能直接捕获视觉事件发生时的时间。一些方法为视觉标记了可学习的位置（时间）嵌入。然而，<strong>这只能使模型能够识别帧的顺序，在确定精确的时间矩时缺乏精度。</strong></p><p>为了解决这些问题，引入受 InstructBLIP启发的时间戳感知帧编码器。给定一个视频输入V，首先使用一个<strong>预训练好的图像编码器</strong>即ViT对 每一帧进行编码获得<strong>帧特征（n*n*d）</strong>，随后，一个图像Q-Former进一步压缩帧token。如图2所示，Q-Former以Dq维的可学习查询作为输入。这些查询通过交叉注意力与frame feature进行交互，并将初始查询更新到维度Dq中的Ni视觉标记。值得注意的是，在视觉标记抽取过程中，添加了帧的时间戳例如“This frame is sampled at 2s.”作为Q-Former融合视觉和时间戳信息的一个条件。</p><blockquote><p>借鉴了InstructBLIP的Q-Former。首先通过ViT-G/14 from EVA-CLIP来抽取图片特征（n*n*d），再通过Q-Former来对feature做提取，并通过输入文本“This frame is sampled at 2s.”，来把时间戳信息也混合进去。一帧图像出来的特征是Ni*D的，Ni就是query向量的个数。这里的Q-Former是用InstructBLIP权重初始化的。</p></blockquote><h3 id="Sliding-Video-Q-Former"><a href="#Sliding-Video-Q-Former" class="headerlink" title="Sliding Video Q-Former"></a>Sliding Video Q-Former</h3><p>对于T帧的视频输入，使用时间戳感知帧编码器后，获取到T*Ni*D的视觉token。此时各帧独立编码，没有建模<strong>帧间时间信息</strong>。为此，引入Q-Former滑窗，在时间维度上增强特征融合。设计了一个长度为Lw的滑动窗口，并在每个窗口内<strong>利用视频Q-Former从Lw帧中提取Nv长度的视频token</strong>。（<strong>滑窗Lw，步长S，Q-former查询向量数Nv</strong>）最终可以将输入的视频表示为（T /S）×Nv的视频token。（上图黄色部分）</p><p>由于视频的三维特性，有大量冗余时空信息，原始视觉token会非常长（原始帧中的所有patch），需要压缩信息以降低LLM计算量。<strong>之前的工作一般都设置固定的视觉token数Nv比如32，当输入帧数T很大时，会造成严重的视觉语义退化。</strong></p><p><strong>本文采用固定的步长来保证长视频不会被过度压缩，即最终送入LLM的tokens数量会根据视频的长度变化而变化。在送入LLM之前还会</strong>经过一个线性映射层来使tokens的特征维度符合LLM的输入特征维度需求。</p><p>将压缩率R定义为<strong>原始视觉标记的数量与最终视频标记的数量之比</strong>。则以前Video-LLaMA的压缩率是：<br>$$<br>R=（T<em>N_P）/N_V<br>$$<br>其中，<strong>Np为每一帧的patch数</strong>。这个比率随着输入帧数T的增加而增加，并会导致长视频的过度压缩。使用滑动视频Q-Former，压缩率R’变成一个常数值：<br>$$<br>R’=\frac{T</em>N_P}{(T/S)<em>N_V}=\frac{S</em>N_P}{N_V}<br>$$<br>为长视频保留更丰富的语义。通过调整步幅S，可以根据计算预算来控制视频token的最终数量。最后，利用线性层对视频标记的维数DQ进行变换，以匹配LLM嵌入空间的维数DLLM。</p><h3 id="Large-Language-Model"><a href="#Large-Language-Model" class="headerlink" title="Large Language Model"></a>Large Language Model</h3><p>将多种模态的输入连接起来，包括视频token Xv，文本查询向量Xq（包括可选的转录语音和用户指令），并将其输入一个大型语言模型，以生成合理和连贯的响应Xa。在这里，Xv、Xq和Xa具有相同的标记embedding维数DLLM。</p><p>VidLLM的训练通常采用<strong>两阶段训练框架。</strong>第一阶段使用大规模图像/视频-文本对进行预训练，以实现<strong>视觉-语言对齐</strong>。第二阶段使用指令数据对模型进行微调，以实现<strong>指令遵循</strong>。考虑到计算效率，本文重用了在第一阶段训练后现有开源模型的检查点（模型用的是LLaMA-2 (7B)），<strong>仅进行指令微调</strong>。采用LoRA微调的方式来对LLM模型进行微调。在训练过程中，利用<strong>语言建模损失</strong>生成长度为LT的目标答案Xa：</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241014144753535.png" alt="image-20241014144753535" style="zoom:80%;"><h3 id="数据集TimeIT"><a href="#数据集TimeIT" class="headerlink" title="数据集TimeIT"></a>数据集TimeIT</h3><p>为了提高TimeChat对时间敏感的人类指令的理解能力，提出TimeIT，一个涉及时间戳的以视频为中心的指令调优数据集。该数据集集成了广泛的与时间戳相关的视频数据集，并以长篇视频为特征。</p><p>TimeIT包含了6个与时间戳相关的视频任务，即：**(1) 视频说明字幕生成，(2) 视频时间定位，(3) 步骤定位和文字生成，(4) 视频摘要，(5) 视频亮点检测，以及 (6) 转录语音生成**。它还整合了来自不同领域的12个特定数据集。数据集适应了在现实世界应用中与AI助手交互时涉及视频时间戳的普遍用户请求。</p><p>数据集构建方式分两步：1）Instruction Writing  和  2) Answer Formatting。</p><p><strong>指令构造</strong>：先通过人工进行构造，然后利用GPT-4进行扩写来产生更多样化的表达，最后通过人工检查和refine来形成最终的版本。对于<strong>每个task会产生6个高质量的指令</strong>（instructions）。</p><p><strong>答案模板</strong>：根据编写的指令，我们进一步将任务输出重新表述为用户友好的自然语言响应范式。考虑到所涉及的视频数据集是人工收集的，TimeIT数据的整体质量得到了保证。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241014164810146.png" alt="image-20241014164810146" style="zoom:80%;"><p>表1将TimeIT数据与现有的视频指令调优数据进行了比较，揭示了本文数据集在数据规模、任务多样性和视频长度方面的显著优势。附录C提供了每个任务对模型性能的贡献分析。总的来说，所有6个任务都是有益的。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241014165334936.png" alt="image-20241014165334936" style="zoom:80%;"><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>以EVA-CLIP中的ViT-G/14作为图像编码器，以LLaMA-2（7B）作为语言基础模型。图像Q-Former的参数从InstructBLIP的检查点初始化，而视频Q-Former从Video-LLaMA的检查点初始化。在TimeIT和Valley上调整了3个epoch，使用32的批处理大小，使用一台8-V100（32G）机器。如图2所示，ViT和LLM的参数被冻结，而图像Q-Former、视频Q-Former和线性层的参数被调整。窗口大小Lw、步幅S和每个窗口的视频token Nv数为32。输入帧数为96。其他超参数请参阅附录D。</p><ul><li><p>模型在三个任务上进行零样本长视频理解评估，即字幕（说明性文字）生成，时间定位，和亮点检测。评估数据集包括YouCook2、 Charades-STA和 QVHighlights。评价指标的细节详见附录E。</p></li><li><p>用于解析LLM输出的启发式规则：由llm生成的输出可能包括口语化表达式，从而导致较大的响应变化。因此，作者设计了大量的启发式规则，以保证能够准确地从模型的响应中提取预测的答案，以计算最终的度量。</p></li><li><p>方法比较：将模型与两个基线对比。（1）<strong>多模态pipeline</strong>： VideoChat-Text，InstructBLIP+ChatGPT。这些pipeline将专用的视觉模型与GPT集成，首先将视觉语义转换为文本描述，然后利用ChatGPT来处理所有输入来解决目标任务。（2）<strong>端到端模型</strong>：Valley，VideoChat-Embed，Video-LLaMA with 7B LLMs。这些模型直接将视频作为输入，并以端到端的方式生成响应。</p></li></ul><h3 id="零样本性能"><a href="#零样本性能" class="headerlink" title="零样本性能"></a>零样本性能</h3><p>表2显示了TimeChat(7B)的零样本性能，它在所有任务中都优于以前的VidLLM(7B/13B)。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241014173705687.png" alt="image-20241014173705687" style="zoom:80%;"><p><strong>密集字幕/说明文字生成</strong>：该任务在YouCook2上训练。模型需要在平均320秒的视频持续时间内，准确地识别出大约8个基本的烹饪步骤，并提供与视觉内容相匹配的忠实描述。烹饪的特殊性也提高了任务的复杂性，挑战了模型的通用性。现有的端到端VidLLM难以实现精确的moment定位，性能最好的VideoChat-Embed模型获得的低F1分数3.4就证明了这一点。<strong>这种momen定位的不精确显著影响了说明文字的评估，使得SODA_c和CIDEr指标都接近于零。</strong>与之相比，本文模型通过+1.0 SODA_c、+2.8 CIDEr和+9.2 F1评分获得了显著的SOTA。这表明TimeChat能够有效地处理长时间的视频，拥有精确的时间定位能力。此外，本文模型性能也显著超过了由ChatGPT提供的多模态pipeline（F1评分从8.4到12.6）。</p><p><strong>视频亮点检测</strong>：dense video captioning任务集中于在clip级别定位事件，而亮点检测任务需要在帧级别进行更细粒度的视频理解。对于输入视频，其目标是输出亮点帧的时间和突出分数。整体来看，本文模型在QVHhemict上达到了14.5 mAP和23.9 HIT@1，比之前的vidllm分别获得了+1.4和+5.8分。这突出了<strong>时间戳感知帧编码器在识别每个帧的显著语义方面</strong>的贡献。此外，该任务是TimeIT的held-out任务，表明了模型对新任务的泛化能力。<strong>多模态pipeline方法获得了更好的性能</strong>，作者推测，这是由于高亮检测的格式与他们的方法更兼容，鉴于模型接收到一系列的输入帧的联合的时间戳-视觉描述。这使得LLM能够逐帧进行评估，从而促进更准确的判断。</p><p><strong>时间定位</strong>：此任务旨在<strong>识别查询语句所描述的对应时间戳。</strong>TimeChat在Charades-STA数据集的“R@1，IoU=0.5”上达到32.2分，大大超过了之前的SOTA端到端VidLLM，即Valley（+27.5）。这表明，本文模型能够准确地定位给定文本查询的视频时刻。值得注意的是，TimeChat在时间定位任务上取得了最大的进步，作者认为该任务主要强调了<strong>长视频的时间定位能力</strong>，而这正是TimeChat的最佳优势。</p><h3 id="定性评估"><a href="#定性评估" class="headerlink" title="定性评估"></a>定性评估</h3><p>图4显示了在零样本设置下，TimeChat和其他VidLLM之间的定性比较。Video-LLaMA没有完全理解用户的指令，因为它只描述了步骤，而没有给出相应时间戳。VideoChat生成了符合请求格式的说明，但错位了所有步骤的时间。此外，VideoChat生成的描述包含一些幻觉。与之相比，TimeChat显示了改进的时间定位和总结功能。它成功地匹配了几乎所有提取的剪辑的视频内容。此外，幻觉的发生也明显减少了。然而，在增强模型生成的摘要的丰富性和细节方面仍有改进的空间。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241015171454792.png" alt="image-20241015171454792" style="zoom:80%;"><p><strong>领域推广</strong>：在附录G中，展示了新领域的定性结果，如movie和egocentric videos，展示了TimeChat对新场景的泛化。这种泛化是一个实用的视频助手的一个关键特征，它代表了基于LLM的TimeChat和当前为特定的下游数据集量身定制的专用模型之间的根本区别。</p><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><p>当<strong>删除滑动视频Q-Former</strong>时，最终视觉token的数量从96减少到32，导致信息压缩率为3倍。语义信息的减少导致了生成的描述和视频内容之间的对齐性的降低。具体来说，SODA_c度量减少了1.0，而CIDEr度量减少了2.8。此外，时间戳的准确性（以F1分数衡量）降低了3.0。在<strong>去除时间戳感知帧编码器</strong>的情况下，模型对时间基础描述的能力显著下降，F1分数下降了2.3。这些结果突出了模型中两个新模块的有效性。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241015173335537.png" alt="image-20241015173335537" style="zoom:80%;"><h3 id="其他分析"><a href="#其他分析" class="headerlink" title="其他分析"></a>其他分析</h3><p>为了证明模型的性能提高不仅归因于新的TimeIT数据集，而且还归因于模型架构的改进，<strong>只使用YouCook2数据集进行微调和评估</strong>。在这个设置中，使用现有的开源检查点初始化模型（参见4.1）。对于所有的模型，应用LoRA 并微调Q-Former。Tab.4给出了结果，显示模型在所有指标上都始终优于以前的模型。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241015174655078.png" alt="image-20241015174655078" style="zoom:80%;"><p>在图5中，作者检查了模型关于输入帧数的性能测量。如3.1.3中提到的，以前的模型如Video-LLaMA和VideoChat压缩了长视频的过多信息，当输入帧数从32增加到96时，性能表现最差。相比之下，本文模型使用滑动视频Q-Former解耦帧数T和压缩率R‘。随着帧数的增加，曲线表现出线性提高，显示出优越的可伸缩性。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241015175208335.png" alt="image-20241015175208335" style="zoom:80%;"><h3 id="与专用模型的比较"><a href="#与专用模型的比较" class="headerlink" title="与专用模型的比较"></a>与专用模型的比较</h3><p>比较TimeChat与在三个任务上分别拥有最先进性能的专用模型。鉴于所有专用模型都在特定数据集上做了微调，作者对自己的模型也做了微调以进行公平比较。如表5所示，微调后TimeChat进一步提升了性能（+6.9 F1 score on YouCook2, +16.9 HIT@1 on</p><p>QVHighlights, and +16.4 R@1 (IoU=0.5) on Charades-STA）。专用模型的优越性来自特定任务的设计，例如Vid2Seq在YT-Temporal-1B上做预训练，这个数据集具有更多高质量的长视频；QD-DETR采用一种特殊的显著性token进行显著性预测，并引入了4个损失函数用于训练，而本文模型纯粹通过语言建模进行训练。此外，这些模型还使用了更多的微调步骤，以更好地适应下游数据集。</p><p>而作为一个通用模型，TimeChat在零样本场景、多任务和多领域设置中表现出很强的泛化能力，而这在这些专家模型中是不存在的。在每项任务上实现最先进的性能并不是本文的主要目标。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241015190311946.png" alt="image-20241015190311946" style="zoom:80%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提出了TimeChat，一个用于长视频理解的时间敏感的VidLLM。得益于新的时间感知帧编码器、滑动视频Q-Former和TimeIT上的指令调优，本文模型显示了强大的时间定位能力，这是在以前的VidLLM中所没有的。通过在冗长的视频中识别重大事件，确定事件的开始和结束时间，并生成简明的总结，TimeChat向智能视频助手迈出了关键的一步。在未来，将进一步取得架构上的进步，以提高视频语义密度，同时减少时空冗余。作者还将收集更多样化和高质量的指令调优数据，以扩大与时间相关的应用。</p><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="==项目配置=="></a>==项目配置==</h2><h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><h3 id="video-annotations"><a href="#video-annotations" class="headerlink" title="video&amp;annotations"></a>video&amp;annotations</h3><ul><li>YouCook2: <a href="http://youcook2.eecs.umich.edu/download">http://youcook2.eecs.umich.edu/download</a></li><li>Charades-STA: <a href="https://github.com/jiyanggao/TALL#charades-sta-anno-download">https://github.com/jiyanggao/TALL#charades-sta-anno-download</a></li><li>QVHighlight: <a href="https://github.com/jayleicn/moment_detr/blob/main/data/README.md">https://github.com/jayleicn/moment_detr/blob/main/data/README.md</a></li><li>ActivityNet Captions: <a href="http://activity-net.org/download.html">http://activity-net.org/download.html</a></li><li>ViTT: <a href="https://github.com/google-research-datasets/Video-Timeline-Tags-ViTT">https://github.com/google-research-datasets/Video-Timeline-Tags-ViTT</a></li><li>DiDeMo: <a href="https://github.com/LisaAnne/LocalizingMoments?tab=readme-ov-file#dataset">https://github.com/LisaAnne/LocalizingMoments?tab=readme-ov-file#dataset</a></li><li>QuerYD: <a href="https://www.robots.ox.ac.uk/~vgg/data/queryd/">https://www.robots.ox.ac.uk/~vgg/data/queryd/</a></li><li>HiREST: <a href="https://github.com/j-min/HiREST">https://github.com/j-min/HiREST</a></li><li>TVSum: <a href="https://github.com/yalesong/tvsum">https://github.com/yalesong/tvsum</a></li><li>SumMe: <a href="http://classif.ai/dataset/ethz-cvl-video-summe/">http://classif.ai/dataset/ethz-cvl-video-summe/</a></li><li>COIN: <a href="https://github.com/coin-dataset/annotations">https://github.com/coin-dataset/annotations</a></li><li>YT-Temporal: <a href="https://rowanzellers.com/merlot/#data">https://rowanzellers.com/merlot/#data</a></li></ul><p>对视频进行预处理，降低 FPS 和维度，以减少存储空间并改进数据加载。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ls <span class="token operator">-</span>U <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>raw<span class="token operator">/</span>video <span class="token operator">&gt;&gt;</span> <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>video_names<span class="token punctuation">.</span>txt<span class="token comment"># for YouCook2</span>python utils<span class="token operator">/</span>compress_video_data<span class="token punctuation">.</span>py \<span class="token operator">-</span><span class="token operator">-</span>input_root<span class="token operator">=</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>raw<span class="token operator">/</span>videos<span class="token operator">/</span> \<span class="token operator">-</span><span class="token operator">-</span>output_root<span class="token operator">=</span>data<span class="token operator">/</span>YouCook2<span class="token operator">-</span>BB<span class="token operator">/</span>YouCook2_asr_denseCap<span class="token operator">/</span>youcook2_6fps_224<span class="token operator">/</span> \<span class="token operator">-</span><span class="token operator">-</span>input_file_list_path<span class="token operator">=</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>video_names<span class="token punctuation">.</span>txt \<span class="token operator">-</span><span class="token operator">-</span>fps<span class="token operator">=</span><span class="token number">6</span> <span class="token operator">-</span><span class="token operator">-</span>size<span class="token operator">=</span><span class="token number">224</span> <span class="token operator">-</span><span class="token operator">-</span>file_type<span class="token operator">=</span>video <span class="token operator">-</span><span class="token operator">-</span>num_workers <span class="token number">24</span><span class="token comment"># for ActivityNet Captions</span>python utils<span class="token operator">/</span>compress_video_data<span class="token punctuation">.</span>py \<span class="token operator">-</span><span class="token operator">-</span>input_root<span class="token operator">=</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>raw<span class="token operator">/</span>videos<span class="token operator">/</span> \<span class="token operator">-</span><span class="token operator">-</span>output_root<span class="token operator">=</span>data<span class="token operator">/</span>Activitynet_Captions<span class="token operator">/</span>anet_6fps_224 \<span class="token operator">-</span><span class="token operator">-</span>input_file_list_path<span class="token operator">=</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>video_names<span class="token punctuation">.</span>txt \<span class="token operator">-</span><span class="token operator">-</span>fps<span class="token operator">=</span><span class="token number">6</span> <span class="token operator">-</span><span class="token operator">-</span>size<span class="token operator">=</span><span class="token number">224</span> <span class="token operator">-</span><span class="token operator">-</span>file_type<span class="token operator">=</span>video <span class="token operator">-</span><span class="token operator">-</span>num_workers <span class="token number">24</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HiREST_STEP&amp;VALLEY：run <code>python utils/process_valley.py</code>及<code>python utils/process_hirest.py</code></p><h3 id="Automatic-speech-transcription"><a href="#Automatic-speech-transcription" class="headerlink" title="Automatic speech transcription"></a>Automatic speech transcription</h3><p>从视频中提取音频：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python utils<span class="token operator">/</span>extract_audio<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">dir</span> <span class="token operator">/</span>home<span class="token operator">/</span>v<span class="token operator">-</span>shuhuairen<span class="token operator">/</span>mycontainer<span class="token operator">/</span>data<span class="token operator">/</span>DiDeMo<span class="token operator">/</span> <span class="token operator">-</span><span class="token operator">-</span>video_folder videos<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">0.</span><span class="token number">.179</span><span class="token punctuation">}</span><span class="token punctuation">;</span> do python utils<span class="token operator">/</span>extract_audio<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">dir</span> <span class="token operator">/</span>home<span class="token operator">/</span>v<span class="token operator">-</span>shuhuairen<span class="token operator">/</span>mycontainer<span class="token operator">/</span>data<span class="token operator">/</span>COIN<span class="token operator">/</span> <span class="token operator">-</span><span class="token operator">-</span>video_folder videos_ali<span class="token operator">/</span>$<span class="token punctuation">{</span>i<span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">-</span>audio_folder audio_files<span class="token operator">/</span>$<span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token punctuation">;</span> done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用whisper：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python utils<span class="token operator">/</span>asr<span class="token operator">/</span>asr<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span>audio_dir audio_files <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">dir</span> <span class="token operator">/</span>home<span class="token operator">/</span>v<span class="token operator">-</span>shuhuairen<span class="token operator">/</span>mycontainer<span class="token operator">/</span>data<span class="token operator">/</span>DiDeMo<span class="token operator">/</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">0.</span><span class="token number">.179</span><span class="token punctuation">}</span><span class="token punctuation">;</span> do python utils<span class="token operator">/</span>asr<span class="token operator">/</span>asr<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">dir</span> <span class="token operator">/</span>home<span class="token operator">/</span>v<span class="token operator">-</span>shuhuairen<span class="token operator">/</span>mycontainer<span class="token operator">/</span>data<span class="token operator">/</span>COIN<span class="token operator">/</span> <span class="token operator">-</span><span class="token operator">-</span>audio_dir audio_files<span class="token operator">/</span>$<span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token punctuation">;</span> done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>清除ASR结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python utils<span class="token operator">/</span>clean_asr<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">dir</span> <span class="token operator">/</span>home<span class="token operator">/</span>v<span class="token operator">-</span>shuhuairen<span class="token operator">/</span>mycontainer<span class="token operator">/</span>data<span class="token operator">/</span>DiDeMo<span class="token operator">/</span>whisper_outputs_with_time<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将ASR结果纳入instruction中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Incorporate the ASR results into the instructions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="指令数据集"><a href="#指令数据集" class="headerlink" title="指令数据集"></a>指令数据集</h3><ul><li>TimeIT: <a href="https://huggingface.co/datasets/ShuhuaiRen/TimeIT">https://huggingface.co/datasets/ShuhuaiRen/TimeIT</a></li><li>Valley: <a href="https://huggingface.co/datasets/luoruipu1/Valley-Instruct-65k">https://huggingface.co/datasets/luoruipu1/Valley-Instruct-65k</a></li></ul><p>数据格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"ActivityNet_asr_denseCap/anet_6fps_224/v_MinmayCk2Nk.mp4"</span><span class="token punctuation">,</span>   <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Capture and describe the activity events in the given video, specifying their respective time intervals, and outputting the time intervals in the 'start - end seconds format'."</span><span class="token punctuation">,</span>       <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"0.0 - 9.1 seconds, We see a male gymnast prepare to use the pommel horse.  9.1 - 10.8 seconds, The man mounts the pommel horse and spins his legs around it.  29.9 - 35.2 seconds, The man does a handstand and dismounts.  35.7 - 38.6 seconds, The man takes a bow and starts walking away."</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token property">"source"</span><span class="token operator">:</span> <span class="token string">"Activitynet_Captions"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字幕（说明文本）生成：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"vitt/raw_videos/--L2yxB3CUg.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Detect and report the start timestamp of activity events in the video, along with descriptions."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"2.7 seconds, Introduction.  8.5 seconds, Ingredients needed.  38.4 seconds, Measuring cornstarch.  54.1 seconds, Adding water.  62.0 seconds, Mixing mixture.  106.3 seconds, Explaining quicksand.  189.0 seconds, Closure."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"YouCook2_asr_denseCap/youcook2_6fps_224/GLd3aX16zBg.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Localize a series of activity events in the video, output the start and end timestamp for each event, and describe each event with sentences. The output format of each predicted event should be like: start - end seconds, event description. An specific example is : 90.0 - 102.0 seconds, spread margarine on two slices of white bread in the video."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"90.0 - 102.0 seconds, spread margarine on two slices of white bread.  114.0 - 127.0 seconds, place a slice of cheese on the bread.  132.0 - 138.0 seconds, place the bread slices on top of each other and place in a hot pan.  139.0 - 145.0 seconds, flip the sandwich over and press down.  173.0 - 174.0 seconds, cut the sandwich in half diagonally. "</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>步骤定位：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"COIN/videos_ali/116/NLy71UrHElw.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Identify and mark the video segments corresponding to a series of actions or steps, specifying the timestamps and describing the steps."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"21.0 - 22.0 seconds, begin to run up.  23.0 - 24.0 seconds, begin to jump up.  25.0 - 26.0 seconds, fall to the ground."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"HiREST/clips/_7urSjT6sQY_35_79.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Find, identify, and determine the temporal boundaries of a series of distinct actions or steps occurring throughout the video. For each action, output the corresponding start and end timestamps, accompanied by a concise description."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"0.0 - 13.0 seconds, clean out the face.  13.0 - 25.0 seconds, apply tissue using water on face.  25.0 - 37.0 seconds, apply it for full face.  37.0 - 42.0 seconds, put it under the neck .  42.0 - 44.0 seconds, dry it out."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基于查询文本的视频切片定位：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"0"</span><span class="token operator">:</span> <span class="token string">"Localize the visual content described by the given textual query &lt;query_placeholder&gt; in the video, and output the start and end timestamps in seconds."</span><span class="token punctuation">,</span>    <span class="token property">"1"</span><span class="token operator">:</span> <span class="token string">"Detect and report the start and end timestamps of the video segment that semantically matches the given textual query &lt;query_placeholder&gt;."</span><span class="token punctuation">,</span>    <span class="token property">"2"</span><span class="token operator">:</span> <span class="token string">"Give you a textual query: &lt;query_placeholder&gt; When does the described content occur in the video? Please return the timestamp in seconds."</span><span class="token punctuation">,</span>    <span class="token property">"3"</span><span class="token operator">:</span> <span class="token string">"Locate and describe the visual content mentioned in the text query &lt;query_placeholder&gt; within the video, including timestamps."</span><span class="token punctuation">,</span>    <span class="token property">"4"</span><span class="token operator">:</span> <span class="token string">"The given natural language query &lt;query_placeholder&gt; is semantically  aligned with a video moment, please give the start time and end time of the video moment."</span><span class="token punctuation">,</span>    <span class="token property">"5"</span><span class="token operator">:</span> <span class="token string">"Find the video segment that corresponds to the given textual query &lt;query_placeholder&gt; and determine its start and end seconds."</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"Charades/videos/AO8RW.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"The given natural language query 'a person is putting a book on a shelf' is semantically  aligned with a video moment, please give the start time and end time of the video moment."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"The given query happens in 0.0 - 6.9 seconds."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>语音转录：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"0"</span><span class="token operator">:</span> <span class="token string">"After watching the video from the YTTemporal dataset, transcribe the spoken content into text and document the start and end time for each segment. The format should be: 'start time - end time, transcribed speech'."</span><span class="token punctuation">,</span>    <span class="token property">"1"</span><span class="token operator">:</span> <span class="token string">"Observe the video thoroughly and transcribe the speech in a maximum of 20 segments. Make sure to include the starting and ending times for each segment in the following format: 'start time - end time, transcribed speech'."</span><span class="token punctuation">,</span>    <span class="token property">"2"</span><span class="token operator">:</span> <span class="token string">"Watch the provided video and transcribe the audio content. For each transcribed speech segment, note down its duration in the format: 'start time - end time, transcribed speech'."</span><span class="token punctuation">,</span>    <span class="token property">"3"</span><span class="token operator">:</span> <span class="token string">"Review the video from the YTTemporal dataset. Identify segments where speech occurs and transcribe those into text. Record the start and end time for each segment in this format: 'start time - end time, transcribed speech'."</span><span class="token punctuation">,</span>    <span class="token property">"4"</span><span class="token operator">:</span> <span class="token string">"Transcribe the spoken words in the video and note down the timestamps for each segment. Your output should look like this: 'start time - end time, transcribed speech'."</span><span class="token punctuation">,</span>    <span class="token property">"5"</span><span class="token operator">:</span> <span class="token string">"Watch the video, transcribe the speech, and indicate when each segment starts and ends. Follow this format: 'start time - end time, transcribed speech'."</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>视频亮点检测：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"0"</span><span class="token operator">:</span> <span class="token string">"You are given a video from the QVHighlights dataset. Please find the highlight contents in the video described by a sentence query, determining the highlight timestamps and its saliency score on a scale from 1 to 5. The output format should be like: 'The highlight timestamps are in the 82, 84, 86, 88, 90, 92, 94, 96, 98, 100 seconds. Their saliency scores are 1.3, 1.7, 1.7, 1.7, 1.7, 1.3, 1.7, 2.3, 2.3, 2.3'. Now I will give you the sentence query: &lt;query_placeholder&gt;. Please return the query-based highlight timestamps and salient scores."</span><span class="token punctuation">,</span>    <span class="token property">"1"</span><span class="token operator">:</span> <span class="token string">"Watch the provided video and mark out the scenes that stand out based on the description: &lt;query_placeholder&gt;. Document the timestamps of these highlights and evaluate their saliency scores."</span><span class="token punctuation">,</span>    <span class="token property">"2"</span><span class="token operator">:</span> <span class="token string">"Perform a thorough review of the video content, extracting key highlight moments that align with &lt;query_placeholder&gt;. It is essential to record the times of these moments and assign a distinct saliency value to each."</span><span class="token punctuation">,</span>    <span class="token property">"3"</span><span class="token operator">:</span> <span class="token string">"Examine the video and, in accordance with query &lt;query_placeholder&gt;, highlight the standout moments. You're required to provide the exact timing alongside a saliency rating for each segment."</span><span class="token punctuation">,</span>    <span class="token property">"4"</span><span class="token operator">:</span> <span class="token string">"In the video presented, seek moments that are a perfect match with &lt;query_placeholder&gt;. It's vital to notate their timestamps and to score each based on their level of saliency."</span><span class="token punctuation">,</span>    <span class="token property">"5"</span><span class="token operator">:</span> <span class="token string">"Go through the video content, and upon identifying highlight moments that resonate with &lt;query_placeholder&gt;, list their timestamps. Subsequently, provide a saliency score for each identified highlight."</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"QVhighlights/videos/train/v_j7rJstUseKg_360.0_510.0.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Watch the provided video and mark out the scenes that stand out based on the description: 'some military patriots takes us through their safety procedures and measures.'. Document the timestamps of these highlights and evaluate their saliency scores."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"There are 29 highlight moments in the 72.0, 74.0, 76.0, 78.0, 80.0, 84.0, 86.0, 88.0, 90.0, 92.0, 96.0, 98.0, 100.0, 102.0, 104.0, 108.0, 110.0, 112.0, 114.0, 116.0, 120.0, 122.0, 124.0, 126.0, 128.0, 136.0, 138.0, 140.0, 144.0 second. Their saliency scores are 3.0, 2.7, 3.7, 2.3, 2.7, 2.7, 2.7, 2.7, 2.3, 2.7, 3.7, 3.3, 3.3, 3.7, 3.0, 2.3, 3.0, 2.3, 2.3, 2.3, 2.3, 3.0, 3.7, 2.7, 2.3, 2.3, 2.3, 2.3, 2.3."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>视频摘要：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"0"</span><span class="token operator">:</span> <span class="token string">"From the &lt;dataset_placeholder&gt; dataset, generate a summarized version of the video, focusing on extracting key frames that best represent the overall narrative. The output should be a list of timestamps in seconds and their corresponding salient scores"</span><span class="token punctuation">,</span>    <span class="token property">"1"</span><span class="token operator">:</span> <span class="token string">"You are given a video from the &lt;dataset_placeholder&gt; dataset. Please find the highlight contents in the video, determining the highlight timestamps and its saliency score on a scale from 1 to 5. The output format should be like: 'The highlight timestamps are in the 82, 84, 86, 88, 90, 92, 94, 96, 98, 100 second. Their saliency scores are 1.3, 1.7, 1.7, 1.7, 1.7, 1.3, 1.7, 2.3, 2.3, 2.3'. "</span><span class="token punctuation">,</span>    <span class="token property">"2"</span><span class="token operator">:</span> <span class="token string">"Identify and extract the most emotionally impactful moments from the video provided by &lt;dataset_placeholder&gt; dataset, rating their intensity on a scale from 1 to 5."</span><span class="token punctuation">,</span>    <span class="token property">"3"</span><span class="token operator">:</span> <span class="token string">"Watch the provided video from the &lt;dataset_placeholder&gt; dataset and mark out the timestamps with stand-out visual content. Document the timestamps of these highlights and evaluate their saliency scores."</span><span class="token punctuation">,</span>    <span class="token property">"4"</span><span class="token operator">:</span> <span class="token string">"In the video presented from &lt;dataset_placeholder&gt; dataset, seek moments that could serve as an executive summary for a busy stakeholder. It's vital to notate their timestamps and to score each based on their level of saliency."</span><span class="token punctuation">,</span>    <span class="token property">"5"</span><span class="token operator">:</span> <span class="token string">"Go through the video content from &lt;dataset_placeholder&gt; dataset, and upon identifying highlight moments, list their timestamps. Subsequently, provide a saliency score for each identified highlight."</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"SumMe/videos/Air_Force_One.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"From the summe dataset, generate a summarized version of the video, focusing on extracting key frames that best represent the overall narrative. The output should be a list of timestamps in seconds and their corresponding salient scores"</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"The highlight timestamps are in the 57.0, 62.4, 68.4, 73.2, 78.0, 79.2, 80.4, 84.6, 155.4, 156.6, 157.8, 159.6, 160.8, 161.4, 162.6, 164.4, 165.6, 167.4, 169.2, 171.0, 172.2 seconds. Their saliency scores are 2.1, 1.8, 2.1, 2.9, 4.2, 3.9, 3.7, 3.1, 1.8, 2.3, 2.9, 3.1, 3.4, 3.4, 3.7, 3.1, 3.1, 2.6, 2.1, 2.1, 1.8."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="评估数据集"><a href="#评估数据集" class="headerlink" title="评估数据集"></a>评估数据集</h3><p>数据格式–对于字幕（说明文本）生成：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"annotations"</span><span class="token operator">:</span>     <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token string">"3MSZA.mp4"</span><span class="token punctuation">,</span>            <span class="token property">"duration"</span><span class="token operator">:</span> <span class="token number">206.86</span><span class="token punctuation">,</span>            <span class="token property">"segments"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">91</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">137</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">153</span><span class="token punctuation">,</span> <span class="token number">162</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">163</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"pick the ends off the verdalago. ..."</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        ...        eg<span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token string">"v_QOlSCBRmfWY.mp4"</span><span class="token punctuation">,</span> <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"A young woman is seen standing in a room and leads into her dancing. The girl dances around the room while the camera captures her movements. She continues dancing around the room and ends by laying on the floor."</span><span class="token punctuation">,</span> <span class="token property">"segments"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.83</span><span class="token punctuation">,</span> <span class="token number">19.86</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">17.37</span><span class="token punctuation">,</span> <span class="token number">60.81</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">56.26</span><span class="token punctuation">,</span> <span class="token number">79.42</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"duration"</span><span class="token operator">:</span> <span class="token number">82.73</span><span class="token punctuation">,</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据格式–对于视频切片定位：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"annotations"</span><span class="token operator">:</span>     <span class="token punctuation">[</span>      <span class="token punctuation">{</span>               <span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token string">"3MSZA.mp4"</span><span class="token punctuation">,</span>             <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"person turn a light on."</span><span class="token punctuation">,</span>            <span class="token property">"timestamp"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">24.3</span><span class="token punctuation">,</span> <span class="token number">30.4</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      ...      eg<span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token string">"AO8RW.mp4"</span><span class="token punctuation">,</span> <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"a person is putting a book on a shelf."</span><span class="token punctuation">,</span> <span class="token property">"timestamp"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">6.9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token string">"Y6R7T.mp4"</span><span class="token punctuation">,</span> <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"person begins to play on a phone."</span><span class="token punctuation">,</span> <span class="token property">"timestamp"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">20.8</span><span class="token punctuation">,</span> <span class="token number">30.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模型相关"><a href="#模型相关" class="headerlink" title="模型相关"></a>模型相关</h2><p>以下checkpoint存储可学习的参数（位置嵌入层、时间感知帧编码器、滑动视频Q-Former、线性投影层和lora）</p><table><thead><tr><th>Checkpoint</th><th>LLM backbone</th><th>Link</th><th>Note</th></tr></thead><tbody><tr><td>TimeChat-2-7B-Finetuned</td><td>LLaMA-2 7B</td><td><a href="https://huggingface.co/ShuhuaiRen/TimeChat-7b/blob/main/timechat_7b.pth">link</a></td><td>Fine-tuned on the instruction-tuning data from <a href="https://huggingface.co/datasets/ShuhuaiRen/TimeIT">TimeIT-104K</a> (asr version) and <a href="https://huggingface.co/datasets/ShuhuaiRen/TimeIT/blob/main/data/valley/Valley_instruct_73k.json">Valley-73K</a> (previous version of current Valley-65K)</td></tr></tbody></table><h3 id="ViT-g-from-EVA-CLIP"><a href="#ViT-g-from-EVA-CLIP" class="headerlink" title="ViT-g from EVA-CLIP"></a>ViT-g from EVA-CLIP</h3><p><strong>预训练的图编码器</strong><code>wget https://storage.googleapis.com/sfr-vision-language-research/LAVIS/models/BLIP2/eva_vit_g.pth</code></p><p>《EVA-CLIP: Improved Training Techniques for CLIP at Scale》</p><p>EVA-CLIP是一系列改进的CLIP模型，通过结合新表示学习、优化和增强技术，降低训练成本，提高训练效率和零次学习性能。最大模型EVA-02-CLIP-E/14+在ImageNet-1K上实现82.0%的零次学习准确率，而较小的EVA-02-CLIP-L/14+模型也有80.4%的准确率，但参数和样本量更少。</p><h4 id="CLIP"><a href="#CLIP" class="headerlink" title="CLIP"></a>CLIP</h4><blockquote><p>CLIP（Contrastive Language-Image Pre-Training）模型是一种<strong>多模态预训练神经网络</strong>，由OpenAI在2021年发布，是从自然语言监督中学习的一种有效且可扩展的方法。CLIP在预训练期间学习执行广泛的任务，包括OCR，地理定位，动作识别。</p><p>该模型的核心思想是<strong>使用大量图像和文本的配对数据进行预训练，以学习图像和文本之间的对齐关系。</strong>CLIP模型有两个模态，一个是<strong>文本模态</strong>，一个是<strong>视觉模态</strong>，包括两个主要部分：</p><p>i. Text Encoder：用于将文本转换为低维向量表示-Embeding。</p><p>ii. Image Encoder：用于将图像转换为类似的向量表示-Embedding。</p><p>在预测阶段，CLIP模型通过计算文本和图像向量之间的<strong>余弦相似度</strong>来生成预测。这种模型特别适用于<strong>零样本学习</strong>任务，即模型不需要看到新的图像或文本的训练示例就能进行预测。CLIP模型在多个领域表现出色，如图像文本检索、图文生成等。</p></blockquote><p>CLIP的的核心思想是通过<strong>海量</strong>的<strong>弱监督</strong>文本对通过<strong>对比学习</strong>，将图片和文本通过各自的<strong>预训练</strong>模型获得的编码向量在向量空间上<strong>对齐</strong>。<strong>不足：clip可以实现图文匹配，但不具有文本生成能力。</strong></p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241021110850956.png" alt="image-20241021110850956" style="zoom:80%;"><p><strong>流程解读：</strong></p><ul><li><p>主要分为两个分支，一个图像encoder、一个文本encoder。<strong>图像分支是ResNet50或是VIT，文本分支和bert的结构类似，采用12层transformer</strong>，8个head，词表大小是49,152。最大sequence长度76。并且添加[SOS]和[EOS]标识token，并且[EOS]对应位置的特征就是最后的文本特征。</p></li><li><p>通过encoder特征提取以后，图像分支获得的特征是[batch, embed_dim]，文本分支获得的特征是[batch, embed_dim]。其中对应位置上的embedding是匹配的，来自同一组图像-文本对。<strong>对于优化任务，一种自然的想法，就是拉近同一对embedding之间的距离，推远不同对的embedding之间的距离。作者采用了InfoNCE loss。</strong>特征间进行两两计算，[batch, embed_dim] * [embed_dim, batch] = [batch, batch]，获取到batch*batch对样本之间的距离。</p><ul><li>这里对提取的文本特征和图像特征进行对比学习。对于一个包含N个文本-图像对的训练batch，将N个文本特征和N个图像特征两两组合，CLIP模型会预测出N^2个可能的文本-图像对的相似度，这里的相似度直接<strong>计算文本特征和图像特征的余弦相似性（cosine similarity）</strong>，即上图所示的矩阵。这里共有N个正样本，即真正属于一对的文本和图像（矩阵中的对角线元素），而剩余的N^2−N个文本-图像对为负样本，那么CLIP的训练目标就是最大化N个正样本的相似度，同时最小化N^2−N个负样本的相似度</li></ul></li><li><p>作者采用的对称loss。针对每一个image特征，将text batch中对应的那个text特征拉近，而推远其余未配对的text特征。同样，针对每一个text特征，将image batch中对应的那个image特征拉进，而推远其余未配对的image特征。<strong>站在loss对称的角度，模型优化中图像、文本的地位是相同的。因此，论文标题想表达利用文本监督去学习视觉特征，但是这未尝不是利用图像监督去学习文本特征。</strong>对比纯图像领域的自监督学习方法，其实和上面的方法是类似的，只是将文本分支替换为图像分支，两个分支同时输入同一张图的图像增强版本。</p></li><li><p>CLIP之所以经典，在于其出色的zero-shot能力。</p></li><li><p>上面我们介绍了CLIP的原理，可以看到训练后的CLIP其实是两个模型，除了视觉模型外还有一个文本模型，那么如何对预训练好的视觉模型进行迁移呢？<strong>与CV中常用的先预训练然后微调不同，CLIP可以直接实现zero-shot的图像分类，即不需要任何训练数据，就能在某个具体下游任务上实现分类，</strong>这也是CLIP亮点和强大之处。用CLIP实现zero-shot分类很简单，只需要简单的两步：</p></li></ul><ol><li>根据任务的分类标签构建每个类别的描述文本：<code>A photo of {label}</code>，然后将这些文本送入Text Encoder得到对应的文本特征，如果类别数目为N，那么将得到N个文本特征；</li><li>将要预测的图像送入Image Encoder得到图像特征，然后与N个文本特征计算缩放的余弦相似度（和训练过程一致），然后选择相似度最大的文本对应的类别作为图像分类预测结果，进一步地，可以将这些相似度看成logits，送入softmax后可以到每个类别的预测概率。</li></ol><ul><li><p><strong>流程解读：</strong></p></li><li><p>输入单张图像，通过Image Encoder提取对应的embedding。然后设定想要查找的标签集合，如”plane”, “car”, “dog”等。然后<strong>利用prompt语句 “a photo of a {}”，分别构成”a photo of a plane”, “a photo of a dog”等文本</strong>。<strong>然后利用Text Encoder分别提取对应的文本embedding。最后利用文本embedding和图像embedding计算对应的相似度，然后对相似度进行softmax，获得最大的概率值，即为对应的label。</strong>实验结果显示CLIP在zero-shot上面具有较高的精度，表明CLIP的泛化性很好。</p></li><li><p>这里需要注意两点：<strong>一是标签集合是自行定义的</strong>，如果我们定义为imagenet的类别标签，那么这时zero-shot就相当于完成imagenet分类任务；<strong>二是prompt语句的改变，可能会影响最后的分类效果</strong>，论文指出不同的数据集，有自己最优的prompt语句，并且多个prompt语句的结果取平均，可能最终的效果更好。</p></li></ul><h4 id="VIT"><a href="#VIT" class="headerlink" title="VIT"></a>VIT</h4><p>ViT（vision transformer）是Google在2020年提出的<strong>直接将transformer应用在图像分类的模型</strong>，后面很多的工作都是基于ViT进行改进的。ViT的思路很简单：</p><ul><li><p>直接把图像分成固定大小的patchs，然后通过线性变换得到<strong>patch embedding</strong>，这就类比NLP的words和word embedding</p></li><li><p>由于transformer的输入就是a sequence of token embeddings，所以将图像的patch embeddings送入transformer后就能够进行特征提取从而分类了。</p></li><li><p>ViT模型原理如下图所示，其实<strong>ViT模型只是用了transformer的Encoder来提取特征</strong>（原始的transformer还有decoder部分，用于实现sequence to sequence，比如机器翻译）。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241021112226815.png" alt="image-20241021112226815" style="zoom:80%;"></li></ul><h3 id="InstructBLIP-Q-Former"><a href="#InstructBLIP-Q-Former" class="headerlink" title="InstructBLIP Q-Former"></a>InstructBLIP Q-Former</h3><p>图片Q-Former <code>wget https://storage.googleapis.com/sfr-vision-language-research/LAVIS/models/InstructBLIP/instruct_blip_vicuna7b_trimmed.pth</code></p><p><strong>BLIP-2：使用冻结图像编码器和大型语言模型进行语言图像预训练</strong></p><blockquote><p>InstructBLIP 是 BLIP 作者团队在多模态领域的又一续作。现代的大语言模型在无监督预训练之后会经过进一步的指令微调 (Instruction-Tuning) 过程，但是这种范式在视觉语言模型上面探索得还比较少。InstructBLIP 这个工作介绍了<strong>如何把指令微调的范式做在 BLIP-2 模型上面</strong>。用指令微调方法的时候会额外有一条 instruction，如何<strong>借助这个 instruction 提取更有用的视觉特征</strong>是本文的亮点之一。InstructBLIP 的架构和 BLIP-2 相似，<strong>从预训练好的 BLIP-2 模型初始化，由图像编码器、LLM 和 Q-Former 组成。</strong>在指令微调期间<strong>只训练 Q-Former</strong>，冻结图像编码器和 LLM 的参数。作者将26个数据集转化成指令微调的格式，把它们分成13个 held-in 数据集用于指令微调，和13个 held-out 数据集用于 Zero-Shot 能力的评估。</p></blockquote><p>Q-Former是一种轻量级transformer结构，采用一组可学习的查询向量来提取和压缩视觉特征。</p><p>Q-Former 的输入还包括<strong>可学习的 Queries (BLIP-2 的做法)</strong> 和 <strong>Instruction</strong>。Q-Former 的内部结构如图3黄色部分所示，其中可学习的 Queries 通过 Self-Attention 和 Instruction 交互，可学习的 Queries 通过 Cross-Attention 和输入图片的特征交互，鼓励提取与任务相关的图像特征。</p><p>Q-Former 的输出通过一个 FC 层送入 LLM，Q-Former 的预训练过程遵循 BLIP-2 的两步：1) 不用 LLM，固定视觉编码器的参数预训练 Q-Former 的参数，训练目标是视觉语言建模。2) 固定 LLM 的参数，训练 Q-Former 的参数，训练目标是文本生成。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241022105848543.png" alt="image-20241022105848543" style="zoom:80%;"><h3 id="LLaMA-2-7B-Video-Q-Former-of-Video-LLaMA"><a href="#LLaMA-2-7B-Video-Q-Former-of-Video-LLaMA" class="headerlink" title="LLaMA-2-7B &amp; Video Q-Former of Video-LLaMA"></a>LLaMA-2-7B &amp; Video Q-Former of Video-LLaMA</h3><p>预训练的LLM及对应的视频编码器</p><p>Video-LLaMA：指令微调的用于视频理解的视听语言模型</p><p><code>git lfs install git clone https://huggingface.co/DAMO-NLP-SG/Video-LLaMA-2-7B-Finetuned</code></p><h2 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h2><h3 id="Q-Former"><a href="#Q-Former" class="headerlink" title="Q-Former"></a>Q-Former</h3><ul><li>Q-Former的实现基于BERT（BertModel），并包含自注意力和交叉注意力层。</li><li>交叉注意力机制在模型的不同层插入，用于处理视觉和语言特征之间的结合，这使得模型可以在多模态任务中有效地执行跨模态对齐。</li><li>模型包括输入embedding、编码器层和输出层，整体架构与BERT类似，但针对多模态任务进行了适配。</li></ul><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241022195840325.png" alt="image-20241022195840325" style="zoom:80%;"><p>Q-Former由两个transfomer子模块组成，左边为(learnable) query encoder，右边为text encoder &amp; decoder。记视觉模型的image encoder的输出为I。左边网络的(learnable) query为Q，右边网络的输入text为T。注意Q是一个向量集，非单个向量。它可以视为Q-Former的参数。</p><ul><li>左边的transformer和视觉模型image encoder交互，提取视觉表征，右边的transformer同时作为text encoder和decoder。</li><li>左边的query encoder和右边的text encoder共享self-attention layer。</li><li>通过self attention layer，实现Q向量之间的交互。</li><li>通过cross attention layer，实现Q向量和I的交互。</li><li>Q和T之间的交互，也是通过共享的self attention layer实现的，不过根据训练目标的不同，通过不同的attention mask来实现不同的交互。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">BertSelfAttention</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> config<span class="token punctuation">,</span> is_cross_attention<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>config <span class="token operator">=</span> config        <span class="token keyword">if</span> config<span class="token punctuation">.</span>hidden_size <span class="token operator">%</span> config<span class="token punctuation">.</span>num_attention_heads <span class="token operator">!=</span> <span class="token number">0</span> <span class="token keyword">and</span> <span class="token keyword">not</span> <span class="token builtin">hasattr</span><span class="token punctuation">(</span>            config<span class="token punctuation">,</span> <span class="token string">"embedding_size"</span>        <span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span>                <span class="token string">"The hidden size (%d) is not a multiple of the number of attention "</span>                <span class="token string">"heads (%d)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span> config<span class="token punctuation">.</span>num_attention_heads<span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token comment"># 初始化--设置注意力头的数量和每个头的维度</span>        self<span class="token punctuation">.</span>num_attention_heads <span class="token operator">=</span> config<span class="token punctuation">.</span>num_attention_heads        self<span class="token punctuation">.</span>attention_head_size <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>hidden_size <span class="token operator">/</span> config<span class="token punctuation">.</span>num_attention_heads<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>all_head_size <span class="token operator">=</span> self<span class="token punctuation">.</span>num_attention_heads <span class="token operator">*</span> self<span class="token punctuation">.</span>attention_head_size        <span class="token comment"># 初始化查询query、键和值的线性变换</span>        self<span class="token punctuation">.</span>query <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">)</span>        <span class="token comment"># ===如果是交叉注意力（cross-attention），键和值从编码器获取，否则从隐层获取===</span>        <span class="token keyword">if</span> is_cross_attention<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>key <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>config<span class="token punctuation">.</span>encoder_width<span class="token punctuation">,</span> self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>value <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>config<span class="token punctuation">.</span>encoder_width<span class="token punctuation">,</span> self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>key <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>value <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">)</span>        <span class="token comment"># 注意力得分的dropout</span>        self<span class="token punctuation">.</span>dropout <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>config<span class="token punctuation">.</span>attention_probs_dropout_prob<span class="token punctuation">)</span>        <span class="token comment"># 获取位置嵌入类型，如果是相对位置嵌入，则初始化相关嵌入层</span>        self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>            config<span class="token punctuation">,</span> <span class="token string">"position_embedding_type"</span><span class="token punctuation">,</span> <span class="token string">"absolute"</span>        <span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>            self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key"</span>            <span class="token keyword">or</span> self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key_query"</span>        <span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>max_position_embeddings <span class="token operator">=</span> config<span class="token punctuation">.</span>max_position_embeddings            self<span class="token punctuation">.</span>distance_embedding <span class="token operator">=</span> nn<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span>                <span class="token number">2</span> <span class="token operator">*</span> config<span class="token punctuation">.</span>max_position_embeddings <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>attention_head_size            <span class="token punctuation">)</span>        <span class="token comment"># 是否保存注意力图（用于可视化或调试）</span>        self<span class="token punctuation">.</span>save_attention <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">save_attn_gradients</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> attn_gradients<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>attn_gradients <span class="token operator">=</span> attn_gradients    <span class="token comment"># 注意力梯度</span>    <span class="token keyword">def</span> <span class="token function">get_attn_gradients</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>attn_gradients    <span class="token keyword">def</span> <span class="token function">save_attention_map</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> attention_map<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>attention_map <span class="token operator">=</span> attention_map  <span class="token comment"># 注意力图</span>    <span class="token keyword">def</span> <span class="token function">get_attention_map</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>attention_map    <span class="token keyword">def</span> <span class="token function">transpose_for_scores</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 将输入的张量x转置为(num_attention_heads, attention_head_size)格式</span>        new_x_shape <span class="token operator">=</span> x<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>            self<span class="token punctuation">.</span>num_attention_heads<span class="token punctuation">,</span>            self<span class="token punctuation">.</span>attention_head_size<span class="token punctuation">,</span>        <span class="token punctuation">)</span>        x <span class="token operator">=</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">*</span>new_x_shape<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        hidden_states<span class="token punctuation">,</span>        attention_mask<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>    <span class="token comment"># 注意力掩码</span>        head_mask<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>     <span class="token comment"># 注意力头掩码</span>        encoder_hidden_states<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>        encoder_attention_mask<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>    <span class="token comment"># 编码器注意力掩码</span>        past_key_value<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>    <span class="token comment"># 前一个时间步的键值对</span>        output_attentions<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 如果是交叉注意力，键和值来自编码器，否则从当前隐藏状态获取</span>        is_cross_attention <span class="token operator">=</span> encoder_hidden_states <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span>        <span class="token keyword">if</span> is_cross_attention<span class="token punctuation">:</span>            <span class="token comment"># 计算交叉注意力的键和值</span>            key_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">(</span>encoder_hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>            value_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">(</span>encoder_hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>            attention_mask <span class="token operator">=</span> encoder_attention_mask     <span class="token comment"># 使用编码器的注意力掩码</span>        <span class="token keyword">elif</span> past_key_value <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 如果存在之前的键/值缓存，则将当前计算结果与缓存进行拼接</span>            key_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>            value_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>            key_layer <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>past_key_value<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key_layer<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>            value_layer <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>past_key_value<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> value_layer<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 计算自注意力的键和值</span>            key_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>            value_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 计算查询向量</span>        mixed_query_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>query<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span>        query_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>mixed_query_layer<span class="token punctuation">)</span>        <span class="token comment"># 保存当前的键/值对，用于后续步骤</span>        past_key_value <span class="token operator">=</span> <span class="token punctuation">(</span>key_layer<span class="token punctuation">,</span> value_layer<span class="token punctuation">)</span>        <span class="token comment"># Take the dot product between "query" and "key" to get the raw attention scores.</span>        <span class="token comment"># 计算查询和键的点积，得到注意力得分</span>        attention_scores <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>query_layer<span class="token punctuation">,</span> key_layer<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 处理相对位置嵌入的情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>            self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key"</span>            <span class="token keyword">or</span> self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key_query"</span>        <span class="token punctuation">)</span><span class="token punctuation">:</span>            seq_length <span class="token operator">=</span> hidden_states<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            position_ids_l <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>                seq_length<span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">,</span> device<span class="token operator">=</span>hidden_states<span class="token punctuation">.</span>device            <span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            position_ids_r <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>                seq_length<span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">,</span> device<span class="token operator">=</span>hidden_states<span class="token punctuation">.</span>device            <span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment"># 计算位置差</span>            distance <span class="token operator">=</span> position_ids_l <span class="token operator">-</span> position_ids_r            positional_embedding <span class="token operator">=</span> self<span class="token punctuation">.</span>distance_embedding<span class="token punctuation">(</span>                distance <span class="token operator">+</span> self<span class="token punctuation">.</span>max_position_embeddings <span class="token operator">-</span> <span class="token number">1</span>            <span class="token punctuation">)</span>            positional_embedding <span class="token operator">=</span> positional_embedding<span class="token punctuation">.</span>to<span class="token punctuation">(</span>                dtype<span class="token operator">=</span>query_layer<span class="token punctuation">.</span>dtype            <span class="token punctuation">)</span>  <span class="token comment"># fp16 compatibility</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key"</span><span class="token punctuation">:</span>                <span class="token comment"># 计算相对位置得分并加到注意力得分中</span>                relative_position_scores <span class="token operator">=</span> torch<span class="token punctuation">.</span>einsum<span class="token punctuation">(</span>                    <span class="token string">"bhld,lrd-&gt;bhlr"</span><span class="token punctuation">,</span> query_layer<span class="token punctuation">,</span> positional_embedding                <span class="token punctuation">)</span>                attention_scores <span class="token operator">=</span> attention_scores <span class="token operator">+</span> relative_position_scores            <span class="token keyword">elif</span> self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key_query"</span><span class="token punctuation">:</span>                <span class="token comment"># 计算查询和键的相对位置得分，并加到注意力得分中</span>                relative_position_scores_query <span class="token operator">=</span> torch<span class="token punctuation">.</span>einsum<span class="token punctuation">(</span>                    <span class="token string">"bhld,lrd-&gt;bhlr"</span><span class="token punctuation">,</span> query_layer<span class="token punctuation">,</span> positional_embedding                <span class="token punctuation">)</span>                relative_position_scores_key <span class="token operator">=</span> torch<span class="token punctuation">.</span>einsum<span class="token punctuation">(</span>                    <span class="token string">"bhrd,lrd-&gt;bhlr"</span><span class="token punctuation">,</span> key_layer<span class="token punctuation">,</span> positional_embedding                <span class="token punctuation">)</span>                attention_scores <span class="token operator">=</span> <span class="token punctuation">(</span>                    attention_scores                    <span class="token operator">+</span> relative_position_scores_query                    <span class="token operator">+</span> relative_position_scores_key                <span class="token punctuation">)</span>        attention_scores <span class="token operator">=</span> attention_scores <span class="token operator">/</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>self<span class="token punctuation">.</span>attention_head_size<span class="token punctuation">)</span>        <span class="token keyword">if</span> attention_mask <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 添加注意力掩码（在BertModel前向传播中预计算）</span>            <span class="token comment"># Apply the attention mask is (precomputed for all layers in BertModel forward() function)</span>            attention_scores <span class="token operator">=</span> attention_scores <span class="token operator">+</span> attention_mask        <span class="token comment"># Normalize the attention scores to probabilities.</span>        <span class="token comment"># 归一化注意力得分为概率分布</span>        attention_probs <span class="token operator">=</span> nn<span class="token punctuation">.</span>Softmax<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span>attention_scores<span class="token punctuation">)</span>        <span class="token keyword">if</span> is_cross_attention <span class="token keyword">and</span> self<span class="token punctuation">.</span>save_attention<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>save_attention_map<span class="token punctuation">(</span>attention_probs<span class="token punctuation">)</span>            attention_probs<span class="token punctuation">.</span>register_hook<span class="token punctuation">(</span>self<span class="token punctuation">.</span>save_attn_gradients<span class="token punctuation">)</span>        <span class="token comment"># This is actually dropping out entire tokens to attend to, which might</span>        <span class="token comment"># seem a bit unusual, but is taken from the original Transformer paper.</span>        attention_probs_dropped <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>attention_probs<span class="token punctuation">)</span>        <span class="token comment"># Mask heads if we want to</span>        <span class="token comment"># 如果需要掩盖特定的注意力头</span>        <span class="token keyword">if</span> head_mask <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            attention_probs_dropped <span class="token operator">=</span> attention_probs_dropped <span class="token operator">*</span> head_mask        <span class="token comment"># 计算上下文向量（注意力概率与值的乘积）</span>        context_layer <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>attention_probs_dropped<span class="token punctuation">,</span> value_layer<span class="token punctuation">)</span>        <span class="token comment"># 调整上下文向量形状</span>        context_layer <span class="token operator">=</span> context_layer<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span>        new_context_layer_shape <span class="token operator">=</span> context_layer<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">,</span><span class="token punctuation">)</span>        context_layer <span class="token operator">=</span> context_layer<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">*</span>new_context_layer_shape<span class="token punctuation">)</span>        outputs <span class="token operator">=</span> <span class="token punctuation">(</span>            <span class="token punctuation">(</span>context_layer<span class="token punctuation">,</span> attention_probs<span class="token punctuation">)</span> <span class="token keyword">if</span> output_attentions <span class="token keyword">else</span> <span class="token punctuation">(</span>context_layer<span class="token punctuation">,</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        outputs <span class="token operator">=</span> outputs <span class="token operator">+</span> <span class="token punctuation">(</span>past_key_value<span class="token punctuation">,</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> outputs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/672514787">TimeChat：基于Q-Former的时序感知VideoLLM - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/AIGCer/article/details/142799336">从秒级到小时级：TikTok等发布首篇面向长视频理解的多模态大语言模型全面综述_tiktok 语音大模型-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/650519771">https://zhuanlan.zhihu.com/p/650519771</a></p><p><a href="https://zhuanlan.zhihu.com/p/638103950">多模态超详细解读 (八)：InstructBLIP: 指令微调训练通用视觉语言模型 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/mieshizhishou/article/details/140719063">【有啥问啥】多模态大模型应用中的Q-Former是什么？_qformer-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MLLM </tag>
            
            <tag> 视频理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2024/10/08/springcloud/"/>
      <url>/2024/10/08/springcloud/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker 是一个开源的容器化平台，它使开发者能够自动化应用程序的部署、管理、扩展和运行。Docker 利用容器技术，允许在一个隔离的环境中运行应用程序，并确保不同环境（如开发、测试、生产环境）之间的一致性。这种技术使得应用程序可以在各种不同的操作系统和基础设施上运行，而不必担心兼容性问题。</p><ul><li><strong>镜像：</strong>在Docker中，镜像是一个轻量级、独立的<strong>可执行软件包</strong>，包含运行应用程序所需的所有内容，包括代码、运行时库、环境变量和配置文件。镜像是容器的基石，容器实际上是在镜像的基础上创建的运行实例。</li><li><strong>容器：</strong>容器是镜像的<strong>运行实例</strong>。它包含了应用程序及其所有依赖项，以隔离应用程序及其环境，确保它在任何环境中都能一致运行。容器是可移植和可部署的，可以在任何支持Docker的系统上运行。</li><li><strong>仓库：</strong>Docker仓库是用于存储和组织镜像的地方。仓库可以是公共的（如Docker Hub）或私有的，用户可以通过仓库来分享和获取镜像。</li></ul><img src="/2024/10/08/springcloud/image-20241031111502848.png" alt="image-20241031111502848" style="zoom:67%;"><p>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用。Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。</p><p>ubuntu18安装docker：<a href="https://blog.csdn.net/x7536987/article/details/124808845">Ubuntu18.04安装Docker完整教程_ubuntu 18 安装 docker-CSDN博客</a></p><p><strong>启动docker</strong></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 启动dockersudo systemctl enable dockersudo systemctl start docker# 设置docker开机自启动sudo systemctl enable docker.servicesudo systemctl enable containerd.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>建立docker用户组</strong></p><p>默认情况下，docker命令会使用Unix socket与Docker引擎通讯。而只有root用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">sudo groupadd docker# 将当前用户加入dockersudo usermod -aG docker $USER<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>部署应用的步骤：<br>1、搜索镜像<br>2、拉取镜像<br>3、创建容器<br>4、操作容器中的应用</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">docker run -d \  --name mysql \  -p 3306:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=123 \  mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li><li><code>--name mysql </code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射到容器内端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul><p>镜像的名称不是随意的，而是要到DockerRegistry中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在DockerHub网站或者软件的官方网站中都能找到。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><img src="/2024/10/08/springcloud/image-20241031111225467.png" alt="image-20241031111225467" style="zoom: 67%;"><h3 id="容器迁移"><a href="#容器迁移" class="headerlink" title="容器迁移"></a>容器迁移</h3><p>当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p>docker commit 的语法格式为：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker commit [options] &lt;container_ID或container_name&gt; [&lt;new_image_name&gt;[:&lt;label&gt;]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以用下面的命令将容器保存为镜像：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker commit \    --author "XX" \    --message "XX" \    container_name \    new_image_name:label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 –author 是指定修改的作者，而 –message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。我们可以在 docker image ls 中看到这个新定制的镜像。我们还可以用 docker history image_name[:label] 具体查看镜像内的历史记录。</p><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>docker的问题：docker容器删除后，在容器中产生的数据也会随之销毁；docker容器和外部机器不能直接交换文件（只能与宿主机进行）；容器之间不能进行数据交互。</p><p>容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机目录</strong>之间映射的桥梁。 </p><p>数据卷的作用：<br>1、容器数据持久化<br>2、外部机器与容器间接通信<br>3、容器之间数据交换</p><img src="/2024/10/08/springcloud/image-20241031143605424.png" alt="image-20241031143605424" style="zoom:67%;"><p>在上图中：</p><ul><li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p><blockquote><p><code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code>。</p><p><strong>为什么不让容器目录直接指向宿主机目录呢</strong>？</p><ul><li>因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变了。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了。</li><li>但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与宿主机目录之间的映射关系即可。</li></ul><p>不过，我们通过由于数据卷目录比较深，不好寻找，通常我们也<strong>允许让容器直接与宿主机目录挂载而不使用数据卷</strong></p></blockquote><p>数据卷的相关命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><h4 id="nginx的html目录挂载"><a href="#nginx的html目录挂载" class="headerlink" title="nginx的html目录挂载"></a>nginx的html目录挂载</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx# 2.然后查看数据卷docker volume ls# 结果DRIVER    VOLUME NAMElocal     44c23cc5778160c799ff3cc24c64f456e65c0442058cbcbf78a277ab8ff73623local     html# 3.查看数据卷详情docker volume inspect html# 结果[    {        "CreatedAt": "2024-10-31T14:48:10+08:00",        "Driver": "local",        "Labels": null,        "Mountpoint": "/var/lib/docker/volumes/html/_data",        "Name": "html",        "Options": null,        "Scope": "local"    }]# 4.查看/var/lib/docker/volumes/html/_data目录ll /var/lib/docker/volumes/html/_data# 结果total 8.0K-rw-r--r-- 1 root root 497 10月  2 23:13 50x.html-rw-r--r-- 1 root root 615 10月  2 23:13 index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="匿名卷"><a href="#匿名卷" class="headerlink" title="匿名卷"></a>匿名卷</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 1.查看MySQL容器详细信息docker inspect mysql# 关注其中.Config.Volumes部分和.Mounts部分        "Config": {            "Volumes": {                "/var/lib/mysql": {}# 容器声明了一个本地目录，需要挂载数据卷，但是数据卷未定义。这就是匿名卷            },            .......            "Mounts": [            {                "Type": "volume",                "Name": "44c23cc5778160c799ff3cc24c64f456e65c0442058cbcbf78a277ab8ff73623",                "Source": "/var/lib/docker/volumes/44c23cc5778160c799ff3cc24c64f456e65c0442058cbcbf78a277ab8ff73623/_data",                "Destination": "/var/lib/mysql",                "Driver": "local",                "Mode": "",                "RW": true,                "Propagation": ""            }        ],<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Mounts中的关键属性：</p><ul><li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。</li><li>Source：宿主机目录</li><li>Destination : 容器内的目录</li></ul><p>上述配置是将容器内的<code>/var/lib/mysql</code>这个目录，与数据卷<code>44c23cc5778160c799ff3cc24c64f456e65c0442058cbcbf78a277ab8ff73623</code>挂载。于是在宿主机中就有了<code>/var/lib/docker/volumes/44c23cc5778160c799ff3cc24c64f456e65c0442058cbcbf78a277ab8ff73623/_data</code>这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。</p><h4 id="挂载本地目录"><a href="#挂载本地目录" class="headerlink" title="挂载本地目录"></a>挂载本地目录</h4><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 挂载本地目录-v 本地目录:容器内目录# 挂载本地文件-v 本地文件:容器内文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"> # 删除原来的MySQL容器docker rm -f mysql# 创建并运行新mysql容器，挂载本地目录docker run -d \--name mysql \-p 3306:3306 \-e TZ=Asia/Shanghai \-e MYSQL_ROOT_PASSWORD=123 \-v /home/yf/mysql/data:/var/lib/mysql \-v /home/yf/mysql/conf:/etc/mysql/conf.d \-v /home/yf/mysql/init:/docker-entrypoint-initdb.d \--privileged=true  mysql  # 守护者模式进入容器，操作MySQL docker exec -it mysql mysql -uroot -p123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为<strong>镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</strong>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td></tr></tbody></table><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token comment"># 在jdk环境基础上制作java镜像</span><span class="token comment"># 基础镜像</span><span class="token instruction"><span class="token keyword">FROM</span> openjdk:11.0-jre-buster</span><span class="token comment"># 设定时区</span><span class="token instruction"><span class="token keyword">ENV</span> TZ=Asia/Shanghai</span><span class="token instruction"><span class="token keyword">RUN</span> ln -snf /usr/share/zoneinfo/<span class="token variable">$TZ</span> /etc/localtime &amp;&amp; echo <span class="token variable">$TZ</span> &gt; /etc/timezone</span><span class="token comment"># 拷贝jar包</span><span class="token instruction"><span class="token keyword">COPY</span> docker-demo.jar /app.jar</span><span class="token comment"># 入口</span><span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">"java"</span>, <span class="token string">"-jar"</span>, <span class="token string">"/app.jar"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了。</p><p>首先，将课前资料提供的<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录：</p><img src="/2024/10/08/springcloud/image-20241102184713448.png" alt="image-20241102184713448" style="zoom:67%;"><p>然后，执行命令，构建镜像：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 进入镜像目录cd /root/demo# 开始构建docker build -t docker-demo:1.0 .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>命令说明：</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：<pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 直接指定Dockerfile目录docker build -t docker-demo:1.0 /root/demo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>Nginx (engine x) 是一个<strong>高性能的HTTP和反向代理web服务器</strong>，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。</li><li>其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</li><li>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。</li><li>Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>正向代理</strong>： 平时需要访问国外的浏览器很慢，比如我们要看推特，看GitHub等等。我们直接用国内的服务器无法访问国外的服务器，或者是访问很慢。所以我们需要在本地搭建一个服务器来帮助我们去访问。这种就是正向代理。（<strong>浏览器中配置代理服务器</strong>）</p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudy46bdad36-d3e0-43b0-a223-43360b7e8fc7.png" alt="img" style="zoom:67%;"><p><strong>反向代理</strong>： 我们访问淘宝的时候，淘宝内部肯定不是只有一台服务器，它的内部有很多台服务器，那我们进行访问的时候，因为服务器中间session不共享，那我们是不是在服务器之间访问需要频繁登录，这个时候淘宝搭建一个过渡服务器，对我们是没有任何影响的，我们是登录一次，但是访问所有，这种情况就是反向代理。对我们来说，<strong>客户端对代理是无感知的，客户端不需要任何配置就可以访问，我们只需要把请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端</strong>，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器的地址。（<strong>在服务器中配置代理服务器</strong>）</p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudy62a15097-6e2a-4dbe-bcf5-f0d7cab81089.png" alt="img" style="zoom:67%;"><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。<br>负载均衡（Load Balance）其意思就是分<strong>摊到多个操作单元上进行执行</strong>，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。<br>Nginx给出来三种关于负载均衡的方式。</p><h4 id="轮询法（默认方法）"><a href="#轮询法（默认方法）" class="headerlink" title="轮询法（默认方法）"></a>轮询法（默认方法）</h4><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>适合服务器配置相当，无状态且短平快的服务使用。也适用于图片服务器集群和纯静态页面服务器集群。</p><h4 id="weight权重模式（加权轮询）"><a href="#weight权重模式（加权轮询）" class="headerlink" title="weight权重模式（加权轮询）"></a>weight权重模式（加权轮询）</h4><p>指定<strong>轮询几率</strong>，weight和访问比率成正比，用于后端服务器性能不均的情况。<br>这种方式比较灵活，当后端服务器性能存在差异的时候，通过配置权重，可以让服务器的性能得到充分发挥，有效利用资源。weight和访问比率成正比，用于后端服务器性能不均的情况。权重越高，在被访问的概率越大</p><h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>上述方式存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。<br>我们可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求<strong>通过哈希算法，自动定位到该服务器。</strong>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。<strong>让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来</strong>，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p><p>Nginx的静态处理能力很强，但是动态处理能力不足，因此，在企业中常用动静分离技术。动静分离技术其实是采用代理的方式，在server{}段中加入带正则匹配的location来指定匹配项针对PHP的动静分离：<strong>静态页面交给Nginx处理，动态页面交给PHP-FPM模块或Apache处理。</strong>在Nginx的配置中，是通过location配置段配合正则匹配实现静态与动态页面的不同处理方式。</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">cd /usr/local/nginx/sbin/./nginx  启动./nginx -s stop  停止./nginx -s quit  安全退出./nginx -s reload  重新加载配置文件  如果我们修改了配置文件，就需要重新加载。ps aux|grep nginx  查看nginx进程==防火墙相关==# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all# 查询端口是否开放firewall-cmd --query-port=8080/tcp# 开放80端口firewall-cmd --permanent --add-port=80/tcp# 移除端口firewall-cmd --permanent --remove-port=8080/tcp#重启防火墙(修改配置后要重启防火墙)firewall-cmd --reload# 参数解释1、firwall-cmd：是Linux提供的操作firewall的一个工具；2、--permanent：表示设置为持久；3、--add-port：标识添加的端口；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>单体架构（monolithic structure）</strong>：顾名思义，整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；项目的架构设计、开发模式都非常简单。（优点：架构简单、部署成本低）</p><p>当项目规模较小时，这种模式上手快，部署、运维也都很方便，因此早期很多小型项目都采用这种模式。但随着项目的业务规模越来越大，团队开发人员也不断增加，单体架构就呈现出越来越多的问题：</p><ul><li><strong>团队协作成本高</strong>：试想一下，你们团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊。最终要把功能合并到一个分支，你绝对会陷入到解决冲突的泥潭之中。</li><li><strong>系统发布效率低</strong>：任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时。</li><li><strong>系统可用性差</strong>：单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用。</li></ul><p>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。（优点：降低服务的耦合度，有利于服务的升级拓展）同时要满足下面的一些特点：</p><ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块。</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模不超过10人（2张披萨能喂饱）</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li></ul><p>微服务的特征：</p><p>1、单一职责：拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责<br>2、面向服务：微服务对外暴露业务接口<br>3、自治：团队独立、技术独立、数据独立、部署独立<br>4、隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</p><p><strong>缺点</strong>：不同的功能都做成了服务集群，方法之间不再那么方便互相调用了，因此我们需要进行服务的治理。</p><p>微服务架构解决了单体架构存在的问题，特别适合大型互联网项目的开发，因此被各大互联网公司普遍采用。大家以前可能听说过分布式架构，分布式就是服务拆分的过程，其实微服务架构正是分布式架构的一种最佳实践的方案。</p><h3 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h3><img src="/2024/10/08/springcloud/2310d1c901b6a9822ecdad5f634da19a.png" alt="img" style="zoom:67%;"><ul><li><strong>注册中心</strong>： 维护微服务中每个结点的信息，并且监控结点的状态。</li><li><strong>配置中心</strong>： 它可以统一去管理整个服务群体成千上百的这些配置。如果以后有些配置需要变更，只需要去找到配置中心便可。它可以去通知相关的微服务，实现配置的“热更新”。</li><li><strong>服务网关</strong>： 由网关将用户请求路由到微服务群，在路由过程中可以做负载均衡。<br>路由或者服务之间调用时做好服务的容错处理，避免因服务故障带来的级联失败。还要做好服务保护，隔离等措施。</li></ul><h3 id="SpringCloud-1"><a href="#SpringCloud-1" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><p>微服务拆分以后碰到的各种问题都有对应的解决方案和微服务组件，而SpringCloud框架可以说是目前Java领域最全面的微服务组件的集合了。</p><ul><li>SpringCloud是目前国内使用最广泛的微服务框架。<a href="https://spring.io/projects/spring-cloud">官网地址</a></li><li>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:</li></ul><table><thead><tr><th align="left"><strong>SpringCloud版本</strong></th><th align="left"><strong>SpringBoot版本</strong></th></tr></thead><tbody><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes">2022.0.x</a> aka Kilburn</td><td align="left">3.0.x</td></tr><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes">2021.0.x</a> aka Jubilee</td><td align="left">2.6.x, 2.7.x (Starting with 2021.0.3)</td></tr><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes">2020.0.x</a> aka Ilford</td><td align="left">2.4.x, 2.5.x (Starting with 2020.0.3)</td></tr><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td align="left">2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td align="left">2.1.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td align="left">2.0.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td align="left">1.5.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td align="left">1.5.x</td></tr></tbody></table><h3 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h3><p>目标：</p><blockquote><p>1、单一职责：不同微服务，不要重复开发相同业务，要保证微服务内部业务的完整性<br>2、数据独立：不要访问其它微服务的数据，否则会导致数据耦合<br>3、面向服务：将自己的业务暴露为接口，尽量保证接口外观不变，供其它微服务调用</p></blockquote><p>方式：</p><ul><li><strong>纵向拆分</strong>：按照项目的功能模块来拆分一个个服务。尽可能提高服务的内聚性。</li><li><strong>横向拆分</strong>：各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。</li></ul><p>一般微服务项目有两种不同的<strong>工程结构</strong>：</p><ul><li><strong>完全解耦</strong>：每一个微服务都创建为一个独立的工程，甚至可以使用不同的开发语言来开发，项目完全解耦。<ul><li>优点：服务之间耦合度低</li><li>缺点：每个项目都有自己的独立仓库，管理起来比较麻烦</li></ul></li><li><strong>Maven聚合</strong>：整个项目为一个Project，然后<strong>每个微服务是其中的一个Module</strong><ul><li>优点：项目代码集中，管理和运维方便（授课也方便）</li><li>缺点：服务之间耦合，编译时间较长</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><img src="/2024/10/08/springcloud/image-20241104102557229.png" alt="image-20241104102557229" style="zoom:67%;"><ul><li>将原始单体架构中的依赖项、配置信息、属于该服务的controller，service，mapper等复制到当前module</li><li>根据当前业务需要删除或新增（修改）依赖项/配置项</li><li>注意修改代码中引入的包的路径，包括sql语句引用的mapper路径</li><li><strong>特别注意：不同业务间有数据或服务调用的，不能再通过依赖注入的方式调用，需要做远程服务调用（见下方子标题）</strong></li></ul><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><img src="/2024/10/08/springcloud/image-20241104103234051.png" alt="image-20241104103234051" style="zoom:67%;"><p>就是购物车业务中需要查询商品信息，但商品信息查询的逻辑全部迁移到了<code>item-service</code>服务，导致我们无法查询。</p><p>最终结果就是查询到的购物车数据不完整，因此要想解决这个问题，我们就必须改造其中的代码，<strong>把原本本地方法调用，改造成跨微服务的远程调用</strong>（RPC，即<strong>R</strong>emote <strong>P</strong>roduce <strong>C</strong>all）。</p><p>回顾一下http请求原理，简单来说无非就是浏览器发出http请求信息，而服务中利用@GetMapping去接受请求，查询数据库后返还相应的信息给前端。因此，应该思考如何使得java代码发出http请求。</p><h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><p>Spring提供了一个工具叫做<strong>RestTemplate</strong>，专门用于在java代码中发起http请求。</p><ul><li>spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接，我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。</li><li>RestTemplate默认依赖JDK提供http连接的能力（HttpURLConnection），如果有需要的话也可以通过setRequestFactory方法替换为例如Apache HttpComponents、Netty或OkHttp等其它HTTP library。</li><li>其实spring并没有真正的去实现底层的http请求（3次握手），而是集成了别的http请求，spring只是在原有的各种http请求进行了规范标准，让开发者更加简单易用，底层默认用的是jdk的http请求。</li></ul><p>优点：连接池、超时时间设置、支持异步、请求和响应的编解码</p><p>缺点：依赖别的spring版块、参数传递不灵活</p><p><strong>使用–主要方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 在特定的<span class="token constant">URL</span>上对资源执行<span class="token constant">HTTP</span> <span class="token constant">DELETE</span>操作<span class="token function">exchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 在<span class="token constant">URL</span>上执行特定的<span class="token constant">HTTP</span>方法，返回包含对象的<span class="token class-name">ResponseEntity</span>，这个对象是从响应体中 映射得到的<span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 在<span class="token constant">URL</span>上执行特定的<span class="token constant">HTTP</span>方法，返回一个从响应体映射得到的对象<span class="token function">getForEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 发送一个<span class="token constant">HTTP</span> <span class="token constant">GET</span>请求，返回的<span class="token class-name">ResponseEntity</span>包含了响应体所映射成的对象<span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 发送一个<span class="token constant">HTTP</span> <span class="token constant">GET</span>请求，返回的请求体将映射为一个对象<span class="token function">postForEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token constant">POST</span> 数据到一个<span class="token constant">URL</span>，返回包含一个对象的<span class="token class-name">ResponseEntity</span>，这个对象是从响应体中映射得到的<span class="token function">postForObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token constant">POST</span> 数据到一个<span class="token constant">URL</span>，返回根据响应体匹配形成的对象<span class="token function">headForHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 发送<span class="token constant">HTTP</span> <span class="token constant">HEAD</span>请求，返回包含特定资源<span class="token constant">URL</span>的<span class="token constant">HTTP</span>头<span class="token function">optionsForAllow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 发送<span class="token constant">HTTP</span> <span class="token constant">OPTIONS</span>请求，返回对特定<span class="token constant">URL</span>的<span class="token class-name">Allow</span>头信息<span class="token function">postForLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token constant">POST</span> 数据到一个<span class="token constant">URL</span>，返回新创建资源的<span class="token class-name">URL</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token constant">PUT</span> 资源到特定的<span class="token constant">URL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.将RestTemplate注入到spring容器中。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">ClientHttpRequestFactory</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">SimpleClientHttpRequestFactory</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">RestTemplate</span></span><span class="token punctuation">;</span><span class="token comment">/** * RestTemplate配置类 */</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RestTemplateConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token class-name">ClientHttpRequestFactory</span> factory<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">ClientHttpRequestFactory</span> <span class="token function">simpleClientHttpRequestFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">SimpleClientHttpRequestFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleClientHttpRequestFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setReadTimeout</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//单位为ms</span>        factory<span class="token punctuation">.</span><span class="token function">setConnectTimeout</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//单位为ms</span>        <span class="token keyword">return</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.远程调用</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleCartItems</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CartVO</span><span class="token punctuation">&gt;</span></span> vos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// TODO 1.获取商品id</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> itemIds <span class="token operator">=</span> vos<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">CartVO</span><span class="token operator">::</span><span class="token function">getItemId</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.查询商品</span>    <span class="token comment">// List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);</span>    <span class="token comment">// 2.1.利用RestTemplate发起http请求，得到http的响应</span>    <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> response <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>            <span class="token string">"http://localhost:8081/items?ids={ids}"</span><span class="token punctuation">,</span><span class="token comment">// 请求路径</span>            <span class="token class-name">HttpMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span><span class="token comment">// 请求方式</span>            <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token comment">// 请求实体</span>            <span class="token keyword">new</span> <span class="token class-name">ParameterizedTypeReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">// 返回值类型</span>            <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"ids"</span><span class="token punctuation">,</span> <span class="token class-name">CollUtil</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>itemIds<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 请求参数</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.2.解析响应</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>response<span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">is2xxSuccessful</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 查询失败，直接结束</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span></span> items <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">CollUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 3.转为 id 到 item的map</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span></span> itemMap <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token class-name">ItemDTO</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.写入vo</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">CartVO</span> v <span class="token operator">:</span> vos<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ItemDTO</span> item <span class="token operator">=</span> itemMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">getItemId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        v<span class="token punctuation">.</span><span class="token function">setNewPrice</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v<span class="token punctuation">.</span><span class="token function">setStock</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个过程中，<code>item-service</code>提供了查询接口，<code>cart-service</code>利用Http请求调用该接口。因此<code>item-service</code>可以称为服务的提供者，而<code>cart-service</code>则称为服务的消费者或服务调用者。</p><h3 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h3><p>上一节内容中服务调用存在问题，服务调用使用http请求，网址直接定死了，<strong>如果我们有多个服务集群（多实例部署），亦或是网址在后续开发过程中出现变更，就会产生不方便。</strong></p><blockquote><p>服务提供者：一次业务中，被其它微服务调用的服务（提供接口给其他微服务）<br>服务消费者：一次业务中，调用其它微服务的服务（调用其它微服务提供的接口）</p><p>提供者与消费者的概念是相对的，<strong>一个服务既可以是提供者也可以是消费者</strong>。</p><p>服务消费者该如何获取服务提供者的地址信息？<br>如果有多个服务提供者，消费者该如何选择？<br>消费者如何得知服务提供者的健康状态？<br>新增的服务提供者如何被消费者感知？</p></blockquote><img src="/2024/10/08/springcloud/image-20241104113255813.png" alt="image-20241104113255813" style="zoom: 50%;"><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><img src="/2024/10/08/springcloud/image-20241104113924738.png" alt="image-20241104113924738" style="zoom: 50%;"><p>流程如下：</p><ul><li>服务启动时就会<strong>注册自己的服务信息</strong>（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心<strong>订阅</strong>想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表<strong>负载均衡</strong>，挑选一个实例</li><li>调用者向该实例发起<strong>远程调用</strong></li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会<strong>定期向注册中心发送请求，报告自己的健康状态</strong>（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中<strong>剔除</strong></li><li>当服务有新实例启动时，会<strong>发送注册服务请求</strong>，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心<strong>服务列表变更时，会主动通知微服务</strong>，更新本地服务列表<ul><li>微服务通常会维护一个<strong>本地缓存的服务列表</strong>，用于优化服务调用的性能（避免每次调用时都从注册中心获取）。当注册中心通知微服务服务列表变更时，微服务会根据收到的增量更新，及时刷新它们本地缓存的服务列表。这样，在下一次进行跨服务调用时，微服务可以确保使用的是最新的服务实例信息。</li></ul></li></ul><h4 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h4><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</li><li>Consul：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</li></ul><p>以上几种注册中心都遵循SpringCloud中的API规范，因此在业务开发使用上没有太大差异。由于Nacos是国内产品，中文文档比较丰富，而且同时具备<strong>配置管理</strong>功能（后面会学习），因此在国内使用较多。</p><p><strong>Nacos部署</strong>：</p><p><a href="https://b11et3un53m.feishu.cn/wiki/R4Sdwvo8Si4kilkSKfscgQX0niB">‌﻿⁠﻿﻿‬‌⁠‬﻿﻿‍﻿﻿﻿⁠‌‍‌‬‬﻿⁠﻿‌⁠day03-微服务01 - 飞书云文档</a></p><p><a href="https://blog.csdn.net/u013737132/article/details/132592040">Linux 通过 Docker 部署 Nacos 2.2.3 服务发现与配置中心_nacos2.2.3虚拟机安装详情-CSDN博客</a></p><img src="/2024/10/08/springcloud/image-20241104161640633.png" alt="image-20241104161640633" style="zoom:67%;"><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>将特定service注册到nacos：1.引入依赖；2.配置Nacos地址；3.重启实例</p><p><code>pom.xml</code>中添加依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--nacos 服务注册发现--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>application.yml</code>中添加nacos地址配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> item<span class="token punctuation">-</span>service <span class="token comment"># 服务名称</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment"># nacos地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：1.引入依赖；2.配置Nacos地址；3.发现并调用服务</p><ul><li>服务发现除了要引入nacos依赖（和服务注册的依赖一样）以外，由于还需要<strong>负载均衡</strong>，因此要引入SpringCloud提供的LoadBalancer依赖。</li><li>配置nacos地址–和服务注册的配置一样。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。所以依赖和配置都是一样的。</li><li>服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：随机，轮询，IP的hash，最近最少访问等。服务发现需要用到一个工具，DiscoveryClient，SpringCloud已经帮我们自动装配，我们可以直接注入使用：</li></ul><img src="/2024/10/08/springcloud/image-20241104174127926.png" alt="image-20241104174127926" style="zoom:67%;"><h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p>RestTemplate的问题：</p><blockquote><p>1、代码可读性差，方法调用不统一（一会远程调用，一会本地接口调用）<br>2、url参数比较复杂，难以维护</p></blockquote><p>因此，我们必须想办法改变远程调用的开发模式，让<strong>远程调用像本地方法调用一样简单</strong>。而这就要用到OpenFeign组件了。</p><p>Feign是一个声明式的http客户端，我们只需要把发http请求所需要的信息声明出来即可，剩下的东西都交给Feign来实现。</p><p>1.引入feign依赖和负载均衡器：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--openFeign--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--负载均衡器--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-loadbalancer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.在微服务的Application启动类添加开启Feign的功能：加注解@EnableFeignClients</p><p>3.编写feign客户端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">"userservice"</span><span class="token punctuation">)</span> <span class="token comment">//声明出服务名称</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/{id}"</span><span class="token punctuation">)</span>    <span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要是基于SpringMVC的注解来声明远程调用的信息</p><ul><li><code>@FeignClient("item-service")</code> ：声明服务名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping("/items")</code> ：声明请求路径</li><li><code>@RequestParam("ids") Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul><p>4.使用feign客户端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">OrderMapper</span> orderMapper<span class="token punctuation">;</span><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">UserClient</span> userClient<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//查询订单</span>    <span class="token class-name">Order</span> order <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//根据用户id来查询用户，用Feign实现远程调用</span>    <span class="token class-name">User</span> user <span class="token operator">=</span> userClient<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将用户注入到order中</span>    order<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.返回</span>    <span class="token keyword">return</span> order<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>网关的作用：<strong>身份认证和权限校验</strong>：通过才能去访问微服务；<strong>服务路由</strong>：当通过网关后，还需要根据请求的类型，将请求转发到对应的微服务中；<strong>负载均衡</strong>：确定了转发的微服务之后，微服务中的多个实例之间还应该做负载均衡；<strong>请求限流</strong>：限制访问的请求量</p><ul><li>统一配置管理，解决微服务的配置文件重复和配置热更新问题。</li></ul><p>在SpringCloud当中，提供了两种网关实现方案：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li></ul><h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><blockquote><p>网关路由，解决前端请求不同数据时要访问不同的入口，需要维护多个入口地址的问题。</p></blockquote><p>1.创建网关微服务</p><p>2.引入SpringCloudGateway、NacosDiscovery依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--网关--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--nacos discovery--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--负载均衡--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-loadbalancer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.编写启动类</p><p>4.编写网关的路由配置及Nacos地址（application.yaml）</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8848</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> item <span class="token comment"># 路由规则id，自定义，唯一</span>          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//item<span class="token punctuation">-</span>service <span class="token comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span>          <span class="token key atrule">predicates</span><span class="token punctuation">:</span> <span class="token comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span>            <span class="token punctuation">-</span> Path=/items/<span class="token important">**</span><span class="token punctuation">,</span>/search/<span class="token important">**</span> <span class="token comment"># 这里是以请求路径作为判断规则</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> cart          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//cart<span class="token punctuation">-</span>service          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> Path=/carts/<span class="token important">**</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//user<span class="token punctuation">-</span>service          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> Path=/users/<span class="token important">**</span><span class="token punctuation">,</span>/addresses/<span class="token important">**</span><span class="token comment"># 路径满足/user/开头的就符合要求，托管给userservice服务</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> trade          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//trade<span class="token punctuation">-</span>service          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> Path=/orders/<span class="token important">**</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> pay          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//pay<span class="token punctuation">-</span>service          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> Path=/pay<span class="token punctuation">-</span>orders/<span class="token important">**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>网关本身并没有做什么操作，但是可以访问到相应信息，也就是说网关只是把请求转发给微服务。</p><img src="/2024/10/08/springcloud/image-20241106103631894.png" alt="image-20241106103631894" style="zoom: 50%;"><h4 id="路由断言"><a href="#路由断言" class="headerlink" title="路由断言"></a>路由断言</h4><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被断言工厂（Predicate Factory）读取并处理，转变为路由判断的条件。</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie=chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header=X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">- Host=**.somehost.org,**.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method=GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path=/red/{segment},/blue/**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query=name, Jack或者- Query=name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr=192.168.1.1/24</td></tr><tr><td align="left">weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table><h3 id="网关登录校验"><a href="#网关登录校验" class="headerlink" title="网关登录校验"></a>网关登录校验</h3><blockquote><p>网关鉴权，解决统一登录校验和用户信息获取的问题。</p></blockquote><p>我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：</p><ul><li>每个微服务都需要知道JWT的秘钥，不安全</li><li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li></ul><p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：只需要在网关和用户服务保存秘钥；只需要在网关开发登录校验功能。</p><img src="/2024/10/08/springcloud/image-20241106104942057.png" alt="image-20241106104942057" style="zoom: 50%;"><h4 id="网关过滤器"><a href="#网关过滤器" class="headerlink" title="网关过滤器"></a>网关过滤器</h4><p>Gateway内部工作流程：</p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的<strong>路由规则</strong>（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理。</li><li><code>WebHandler</code>则会加载当前路由下需要执行的<strong>过滤器链</strong>（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）。</li><li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li><strong>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</strong></li><li>最终把响应结果返回。</li></ol><p>最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。<strong>如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<code>NettyRoutingFilter</code>之前</strong>，这就符合我们的需求了</p><p>网关过滤器链中的过滤器有两种：</p><ul><li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code>. </li><li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由，不可配置。</li></ul><blockquote><p>过滤器链之外还有一种过滤器，HttpHeadersFilter，用来处理传递到下游微服务的请求头。例如org.springframework.cloud.gateway.filter.headers.XForwardedHeadersFilter可以传递代理请求原本的host头到下游微服务。</p></blockquote><p><strong>使用</strong></p><p><code>Gateway</code>中内置了很多的<code>GatewayFilter</code>，详情可以参考官方文档：</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories</a></p><p><code>Gateway</code>内置的<code>GatewayFilter</code>过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个<code>Route</code>下，就作用于哪个<code>Route</code>.</p><p>例如，有一个过滤器叫做<code>AddRequestHeaderGatewayFilterFacotry</code>，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。</p><p>实际的使用只需要在application.yaml中这样配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> test_route        <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//test<span class="token punctuation">-</span>service        <span class="token key atrule">predicates</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span>Path=/test/<span class="token important">**</span>        <span class="token key atrule">filters</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> AddRequestHeader=key<span class="token punctuation">,</span> value <span class="token comment"># 逗号之前是请求头的key，逗号之后是value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证是否增加了该请求头，在test服务中获取并打印：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">,</span> <span class="token annotation punctuation">@RequestHeader</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"Truth"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token class-name">String</span> truth<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"truth = "</span> <span class="token operator">+</span> truth<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而如果我们希望全局都可以增加这个过滤器，也就是全局都会增加这个请求头，只需要：</p><img src="/2024/10/08/springcloud/image-20241106111049279.png" alt="image-20241106111049279" style="zoom: 80%;"><h4 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h4><blockquote><p>无论是<code>GatewayFilter</code>还是<code>GlobalFilter</code>都支持自定义，只不过<strong>编码</strong>方式、<strong>使用</strong>方式略有差别。</p></blockquote><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code>。(<strong>该类的名称一定要以<code>GatewayFilterFactory</code>为后缀</strong>)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintAnyGatewayFilterFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractGatewayFilterFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">GatewayFilter</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Object</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">GatewayFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 获取请求</span>                <span class="token class-name">ServerHttpRequest</span> request <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 编写过滤器逻辑</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"过滤器执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 放行</span>                <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">default-filters</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> PrintAny <span class="token comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>动态配置参数：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintAnyGatewayFilterFactory</span> <span class="token comment">// 父类泛型是内部类的Config类型</span>                <span class="token keyword">extends</span> <span class="token class-name">AbstractGatewayFilterFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PrintAnyGatewayFilterFactory<span class="token punctuation">.</span>Config</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">GatewayFilter</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Config</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span>        <span class="token comment">// - GatewayFilter：过滤器</span>        <span class="token comment">// - int order值：值越小，过滤器执行优先级越高</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrderedGatewayFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GatewayFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 获取config值</span>                <span class="token class-name">String</span> a <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> b <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> c <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 编写过滤器逻辑</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b = "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"c = "</span> <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 放行</span>                <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// ==========自定义配置属性，成员变量名称很重要，下面会用到===========</span>    <span class="token annotation punctuation">@Data</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Config</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> a<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> b<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">shortcutFieldOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 返回当前配置类的类型，也就是内部的Config</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Config</span><span class="token punctuation">&gt;</span></span> <span class="token function">getConfigClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Config</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>yaml中配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">default-filters</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> PrintAny=1<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token comment"># 注意，这里多个参数以","隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义GlobalFilter：直接实现GlobalFilter即可，而且也无法设置动态参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintAnyGlobalFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span><span class="token punctuation">,</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 编写过滤器逻辑</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未登录，无法访问"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 放行</span>        <span class="token comment">// return chain.filter(exchange);</span>        <span class="token comment">// 拦截</span>        <span class="token class-name">ServerHttpResponse</span> response <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setRawStatusCode</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 过滤器执行顺序，值越小，优先级越高</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过滤器链执行顺序"><a href="#过滤器链执行顺序" class="headerlink" title="过滤器链执行顺序"></a>过滤器链执行顺序</h4><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter。<br>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter合并到一个过滤器链中，排序后依次执行每个过滤器。</p><p>排序的规则：</p><blockquote><p>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前：<br>（1）GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由自己决定<br>（2）路由过滤器和defaultFilter的order是由Spring指定的，是按照配置文件中的声明顺序来递增的<br>当过滤器的order值一样时，会按照defaultFilter＞路由过滤器＞GlobalFilter的顺序执行</p></blockquote><h4 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">AuthProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthGlobalFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span><span class="token punctuation">,</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">JwtTool</span> jwtTool<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AuthProperties</span> authProperties<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AntPathMatcher</span> antPathMatcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AntPathMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1.获取Request</span>        <span class="token class-name">ServerHttpRequest</span> request <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.判断是否不需要拦截</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isExclude</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 无需拦截，直接放行</span>            <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 3.获取请求头中的token</span>        <span class="token class-name">String</span> token <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> headers <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">CollUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            token <span class="token operator">=</span> headers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 4.校验并解析token</span>        <span class="token class-name">Long</span> userId <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            userId <span class="token operator">=</span> jwtTool<span class="token punctuation">.</span><span class="token function">parseToken</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnauthorizedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 如果无效，拦截</span>            <span class="token class-name">ServerHttpResponse</span> response <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            response<span class="token punctuation">.</span><span class="token function">setRawStatusCode</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// ==================== TODO 5.如果有效，传递用户信息 ==============================</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"userId = "</span> <span class="token operator">+</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 6.放行</span>        <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isExclude</span><span class="token punctuation">(</span><span class="token class-name">String</span> antPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> pathPattern <span class="token operator">:</span> authProperties<span class="token punctuation">.</span><span class="token function">getExcludePaths</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>antPathMatcher<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>pathPattern<span class="token punctuation">,</span> antPath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="用户信息传递"><a href="#用户信息传递" class="headerlink" title="用户信息传递"></a>用户信息传递</h4><blockquote><p>由于网关发送请求到微服务依然采用的是<code>Http</code>请求，因此我们可以<strong>将用户信息以请求头的方式传递到下游微服务</strong>。然后微服务可以<strong>从请求头中获取登录用户信息</strong>。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。</p></blockquote><p>1.保存用户信息到请求头</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 发送给前端新token</span>response<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 暴露头</span>response<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Expose-Headers"</span><span class="token punctuation">,</span> <span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将当前请求头中已经过期的token替换成新的token</span><span class="token comment">// 将新的token转发给微服务</span><span class="token class-name">ServerHttpRequest<span class="token punctuation">.</span>Builder</span> requestBuilder <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 先删除，后新增</span>requestBuilder<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span>k <span class="token operator">-&gt;</span> k<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"Authorization"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>requestBuilder<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Authorization"</span><span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ServerHttpRequest</span> requestNew <span class="token operator">=</span> requestBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>exchange<span class="token punctuation">.</span><span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>requestNew<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.拦截器获取用户</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>hmall<span class="token punctuation">.</span>common<span class="token punctuation">.</span>interceptor</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">cn<span class="token punctuation">.</span>hutool<span class="token punctuation">.</span>core<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">StrUtil</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>hmall<span class="token punctuation">.</span>common<span class="token punctuation">.</span>utils<span class="token punctuation">.</span></span><span class="token class-name">UserContext</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">HandlerInterceptor</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletRequest</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletResponse</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserInfoInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 1.获取请求头中的用户信息</span>        <span class="token class-name">String</span> userInfo <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"user-info"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.判断是否为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 不为空，保存到ThreadLocal</span>                <span class="token class-name">UserContext</span><span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 3.放行</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 移除用户</span>        <span class="token class-name">UserContext</span><span class="token punctuation">.</span><span class="token function">removeUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>黑马SpringCloud：<a href="https://www.bilibili.com/video/BV1S142197x7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">2024最新SpringCloud微服务开发与实战，java黑马商城项目微服务实战开发（涵盖MybatisPlus、Docker、MQ、ES、Redis高级等）_哔哩哔哩_bilibili</a></p><p>配套文档：<a href="https://b11et3un53m.feishu.cn/wiki/space/7229522334074372099?ccm_open_type=lark_wiki_spaceLink&amp;open_tab_from=wiki_home">https://b11et3un53m.feishu.cn/wiki/space/7229522334074372099?ccm_open_type=lark_wiki_spaceLink&amp;open_tab_from=wiki_home</a></p><p>docker：<a href="https://blog.csdn.net/qq_41196612/article/details/131083964">docker全流程使用指南_docker工作流程-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_52380556/article/details/135483179?spm=1001.2014.3001.5502">一文快速学会Docker软件部署-CSDN博客</a></p><p>狂神说Nginx：<a href="https://www.kuangstudy.com/bbs/1353634800149213186">Nginx快速入门-KuangStudy-文章</a></p><p><a href="https://blog.csdn.net/hyfsbxg/article/details/122322125">Nginx详解（一文带你搞懂Nginx）-CSDN博客</a></p><p>微服务：<a href="https://blog.csdn.net/Eumenides_Suki/article/details/128487022">【1.2】认识微服务–微服务技术对比&amp;SpringCloud_springclould 和其他微服务框架比较-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_52380556/article/details/135583389?spm=1001.2014.3001.5502">详解SpringCloud微服务技术栈：认识微服务、服务拆分与远程调用_spring微服务之间调用-CSDN博客</a></p><p>docker部署minio：<a href="https://blog.csdn.net/Darling_qi/article/details/124743303">SpringBoot整合MinIO 「看这一篇就够了」_minio getpresignedobjecturl 预览图片-CSDN博客</a></p><p><a href="https://blog.csdn.net/BThinker/article/details/125412751">Docker 搭建 Minio 容器 (完整详细版)_docker minio-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多模态信息处理</title>
      <link href="/2024/09/09/duo-mo-tai-xin-xi-chu-li/"/>
      <url>/2024/09/09/duo-mo-tai-xin-xi-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="多模态信息处理"><a href="#多模态信息处理" class="headerlink" title="多模态信息处理"></a>多模态信息处理</h1><h2 id="综述（2022）"><a href="#综述（2022）" class="headerlink" title="==综述（2022）=="></a>==综述（2022）==</h2><p>《多模态信息处理前沿综述：应用、融合和预训练》 2022</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>人工智能研究经过70多年的探索，在视觉、语音与声学、语言理解与生成等单模态人工智能领域已取得了巨大的突破。</li><li>近些年，如何让计算机拥有更接近人类的理解和处理多模态信息的能力，进而实现高鲁棒性的推理决策成为热点问题。</li><li>各种应用的涌现，对多模态信息处理技术在用户理解、内容理解和场景理解上提出了更高的要求，同时也给多模态技术提供了海量的数据和丰富的应用场景。</li><li>多模态核心技术又分为：<strong>多模态表示（Representation）、多模态融合（Fusion）、多模态转换（Translation）、多模态对齐（Alignment）和模态协同学习（Co-learning）</strong></li><li>本文从自然语言处理的视角出发，介绍多模态信息处理技术的最新进展，组织结构如下：第１节介绍NLP领域关注度较高的多模态应用和相关的数据集。多模态融合是多模态信息处理的核心问题。第２节从单模态信息的表示方法、多模态信息的融合阶段、融合模型的网络结构、未对齐模态和模态缺失情况下的多模态融合等角度介绍主流的多模态融合方法。第３节介绍多模态预训练技术，并从模型的网络结构、模型的输入、预训练目标、预训练语料和下游任务等维度对比最新提出的多模态预训练模型。第４节介绍多模态技术在工业界的应用。最后一节是总结和对未来工作的展望。</li></ul><h2 id="多模态应用"><a href="#多模态应用" class="headerlink" title="多模态应用"></a>多模态应用</h2><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909145625058.png" alt="image-20240909145625058" style="zoom: 33%;"><h3 id="多模态情感识别"><a href="#多模态情感识别" class="headerlink" title="多模态情感识别"></a>多模态情感识别</h3><ul><li>在交互场景下，多模态情感识别研究如何从<strong>人的表情和动作手势、语音音调、语言</strong>等多模态信息中理解用户细颗粒度的情感表达，进而指导人机交互策略。</li><li>其主要研究内容有：<strong>①基于多模态信息互补性和异步性的动态融合；</strong>②高噪声环境下对于<strong>模态模糊或模态缺失问题</strong>的鲁棒性融合；③客服和营销等<strong>自然交互情境</strong>下的情感识别等。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909151102370.png" alt="image-20240909151102370" style="zoom:67%;"><h3 id="视觉-语言生成"><a href="#视觉-语言生成" class="headerlink" title="视觉-语言生成"></a>视觉-语言生成</h3><ul><li>视觉（图像或视频）到语言的生成和语言到视觉（图像或视频）的生成打破了计算机视觉和自然语言处理两个领域的边界</li><li>2021年初，OpenAI推出的基于GPT-3的语言到视觉的生成模型DALL-E可以根据自然语言的描述生成逼真的图像</li></ul><h4 id="图像描述"><a href="#图像描述" class="headerlink" title="图像描述"></a>图像描述</h4><ul><li>图像描述（Image Captioning）是<strong>对给定的一幅自然图像生成一句自然语言描述的任务。</strong></li><li>2015以前：基于模板–监测图像物体、动作，填充到模板主谓宾结构</li><li>2015以后：通过从视觉图像中解析出属性、关系和结构（hierarchy）等高层语义信息，并将这些语义信息融入<strong>视觉编码和语言解码</strong>中，提高了图像描述的生成效果。</li></ul><h4 id="视频描述"><a href="#视频描述" class="headerlink" title="**视频描述"></a>**视频描述</h4><ul><li>视频描述（Video Captioning）是对给定的一段视频（通常是几十秒的短视频）生成一句准确、细致描述的任务。</li><li>包含<strong>图像、声音、时序</strong>等信息。视频描述可提取的特征更多，技术挑战也更大。</li><li>ACTIONS是首个无需人工标注、从数以亿计的网页内容中自动提炼“视频，描述”对的视频描述数据集，总共包含了163183个GIF视频。</li></ul><h4 id="视觉叙事"><a href="#视觉叙事" class="headerlink" title="视觉叙事"></a>视觉叙事</h4><ul><li>视觉叙事（Visual Story Telling）要求模型对于给定的图像序列，在深度理解图像序列的基础上<strong>生成连贯的叙事故事</strong>。</li><li>视觉叙事的输入是<strong>有时序关联的图像序列</strong>，需要模型具备<strong>根据历史视觉事件推测当前的视觉事件</strong>的能力。</li><li>对比图像描述和视频描述中的客观文字描述，视觉叙事的输出由更多评价性、会话性和抽象性语言组成。</li></ul><h3 id="视觉问答和多模态对话"><a href="#视觉问答和多模态对话" class="headerlink" title="视觉问答和多模态对话"></a>视觉问答和多模态对话</h3><h4 id="视觉问答（VQA）"><a href="#视觉问答（VQA）" class="headerlink" title="视觉问答（VQA）"></a>视觉问答（VQA）</h4><ul><li>给定一幅图像和一个关于该图像的开放式自然语言问题，要求模型准确回答该问题</li><li>视觉问答是一个典型的多模态问题，需要模型具备<strong>物体定位、属性检测、事件分类、场景理解和推理及数学计算</strong>等能力。</li><li>根据图片类型不同，VQA又分为自然图像理解VQA、合成图像推理VQA和自然图像推理VQA</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909151819273.png" alt="image-20240909151819273" style="zoom:67%;"><h4 id="视觉对话"><a href="#视觉对话" class="headerlink" title="**视觉对话"></a>**视觉对话</h4><ul><li>视觉对话（Visual DIalog）是给定一幅图像（或视频等视觉内容）和一个上下文相关的问题，要求模型根据图片（或视频）内容回答该问题。</li><li>与视觉问答相比，视觉对话还要解决对话中特有的挑战，如共指（Co-references）和省略（Ellipsis）等。</li><li>视觉对话中的用户问题只与单个图像（视频）相关，且用户问题和模型回答都是文字的。</li></ul><h4 id="多模态对话"><a href="#多模态对话" class="headerlink" title="多模态对话"></a>多模态对话</h4><ul><li>多模态对话（Multi-model Dialog）关注更接近人类自然对话的多模态人机对话技术研究。它与上一节介绍视觉对话的主要差异有：<ul><li>①多模态对话给定的输入图像可能是多幅的；</li><li>② 随着对话的推进，<strong>图像是不断更新的；</strong></li><li>③用户问题和模型的回答可以是<strong>文本的、图像的或者图文结合的；</strong></li><li>④模型可能需要查询外部领域知识库才能回答用户的问题（如购物者希望看到更多与特定商品相似的商品，或者要求提供满足某些特征的商品，或者查询特定商品的属性等）；</li><li>⑤模型可能需要通过反问等对话策略澄清用户需求。</li></ul></li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909151958971.png" alt="image-20240909151958971" style="zoom:67%;"><h3 id="多模态摘要"><a href="#多模态摘要" class="headerlink" title="多模态摘要"></a>多模态摘要</h3><ul><li><p>多模态摘要是基于对多模态输入（文本、语音、图像和视频等）的理解，归纳并生成单模态或者多模态的概括性总结（摘要）任务。</p></li><li><p>根据具体任务类型，多模态摘要又可细分为<strong>视频会议摘要、教学视频摘要、多模态新闻摘要 和多模态商品摘要</strong></p></li></ul><h3 id="多模态对齐"><a href="#多模态对齐" class="headerlink" title="**多模态对齐"></a>**多模态对齐</h3><ul><li>多模态对齐研究多个模态不同颗粒度元素间的对齐关系，具体又分为显式对齐和隐式对齐。</li><li>视觉－语言跨模态的显式对齐任务研究<strong>图像和句子、图像和词、图像中的目标和句子中的短语间的</strong>对齐关系。</li><li>多模态对齐方法可直接应用于<strong>多模态检索</strong>等应用，也可作为<strong>图像描述、VQA、多模态预训练</strong>的训练语料，尤其是在缺乏大规模多模态人工标注语料的场景。</li><li>Tan等人提出了 Vokenization技术（图３），其通过给文本中的每一个词打上一幅图像的标签，实现在大规模文本语料上自动构建多模态对齐语料库。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909152259522.png" alt="image-20240909152259522" style="zoom: 33%;"><h4 id="图像短语定位"><a href="#图像短语定位" class="headerlink" title="图像短语定位"></a>图像短语定位</h4><ul><li>图像中的目标和文本中的短语对齐也被称为<strong>图像短语定位</strong>（Phrase Grounding），可用于提高图像描述、VQA、视觉导航等视觉-语言下游任务的性能。</li><li>Plummer等人发布了一个大规模的短语定位数据集Flickr30kEntities，如图4所示。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909152343325.png" alt="image-20240909152343325" style="zoom:67%;"><h4 id="视频定位"><a href="#视频定位" class="headerlink" title="**视频定位"></a>**视频定位</h4><ul><li>视频定位（Video Grounding）是多模态对齐中另一项重要且具有挑战性的任务。给定一个查询（Query），它要求模型从视频中定位出与查询语言对应的一个目标视频片段。该技术可应用<strong>于视频理解、视频检索和人机交互</strong>等场景。</li></ul><h3 id="多模态翻译"><a href="#多模态翻译" class="headerlink" title="多模态翻译"></a>多模态翻译</h3><ul><li>多模态翻译是将多模态输入（文本、图像或视频等）中的源语言文本转换为目标语言文本的过程。</li><li>Elliott等人将多模态机器翻译分解为两个子任务：<strong>文本翻译 和 基于视觉的文本表示</strong></li><li>Wu等人的研究表明，视觉特征对多模态翻译的帮助来自于正则化，视觉特征的合理选取对模型性能至关重要。</li></ul><h3 id="多模态信息抽取"><a href="#多模态信息抽取" class="headerlink" title="多模态信息抽取"></a>多模态信息抽取</h3><ul><li>命名实体识别（NER）是指识别自由文本中的具体特定意义的实体（如人名、地名和组织机构名等）。</li><li>多模态命名实体识别（ＭＮER）通过引入视觉、语音等其他模态作为文本模态的补充，识别社交媒体中高噪声短文本中的实体。</li><li>模型方面，Moon等人首次提出了融合图像和文本模态信息的通用多模态注意力模型。</li><li>Yu等人首次将 Transformer应用于多模态NER任务中，并提出了实体片段检测辅助任务，进一步消除视觉偏差，提升了模型效果</li></ul><h2 id="多模态融合"><a href="#多模态融合" class="headerlink" title="多模态融合"></a>多模态融合</h2><ul><li>多模态融合将多个单模态表征整合成为一个多模态信息表征，它是多模态信息处理的核心问题。</li><li>多模态融合的研究方向有：基于多模态互补性的全模态融合问题、模态模糊或者模态缺失下的鲁棒性融合问题、非对齐的多模态融合问题等。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909154906558.png" alt="image-20240909154906558" style="zoom: 80%;"><h3 id="根据单模态表示分类"><a href="#根据单模态表示分类" class="headerlink" title="根据单模态表示分类"></a>根据单模态表示分类</h3><ul><li>单模态的特征表示是多模态融合的基石。这一类方法重点研究如何在多模态融合之前提取更好的单模态特征表示。</li><li>以视觉－语言－音频多模态应用为例，如何从<strong>视觉内容中解析出高层语义信息</strong>以增强视觉特征表达是这一类方法的主要研究内容。</li><li>语言表示通常使用词的独热编码表示、词的上下文表示 、句子表示、句法依存关系表示、场景图表示等。</li><li>音频表示可使用基于VOVAREP提取底层声学特征表示、基于预训练模型wav2vec提取低维特征向量表示等。</li></ul><h4 id="视觉全局表示"><a href="#视觉全局表示" class="headerlink" title="视觉全局表示"></a>视觉全局表示</h4><ul><li>视觉全局表示（Global Representation）是从<strong>图像编码器的高层网络提取一个D维静态向量v</strong>表示一幅图像。</li><li>相关工作通常<strong>使用预训练的ResNet对图像编码</strong>，再提取ResNet的最后一个池化层作为视觉全局表示（ResNet152池化层输出是1*2048维向量，即D=2048）。</li><li>视觉全局表示可用来<strong>初始化多模态自动摘要模型的解码器</strong>，或作为一个<strong>特殊的字符与文本字符拼接</strong>，再用递归神经网络对拼接的字符序列编码，或通过注意力机制学习与其他模态特征的<strong>联合表示</strong>等。</li><li>由于视觉全局表示将图像信息压缩到一个静态的向量中，<strong>这可能会导致大量图像细节信息的丢失。</strong></li></ul><h4 id="视觉区域表示"><a href="#视觉区域表示" class="headerlink" title="视觉区域表示"></a>视觉区域表示</h4><ul><li>视觉区域表示（Regional Representation）是从图像编码器的高层网络中提取一组 Ｄ 维向量表示一幅图像。每个 Ｄ 维向量表示图像中特定的大小相同的区域</li><li>视觉区域表示与注意力机制相结合，通过在每一步解码过程中关注不同的图像区域可生成内容丰富的图像描述</li><li>视觉区域表示实现了图像的细颗粒度表示，但是每个特征的感受野大小和形状相同，<strong>同一个目标可能被切分到多个区域中，它无法表达视觉上完整的语义信息。</strong></li></ul><h4 id="视觉目标表示"><a href="#视觉目标表示" class="headerlink" title="视觉目标表示"></a>视觉目标表示</h4><ul><li>视觉目标表示也是用一组Ｄ 维向量表示一幅图像，但每个 Ｄ 维向量表示图像中的一个目标。</li><li>预训练Faster Ｒ-CNN 通常被用来检测目标所在的区域，再使用目标所在区域的视觉特征和边界框（Bounding-box）特征作为该视觉目标表示。</li><li>视觉目标表示通过目标定位与分类实现视觉图像的浅层语义理解，但<strong>它无法刻画图像中多个目标间的语义关系</strong></li></ul><h4 id="视觉场景图表示"><a href="#视觉场景图表示" class="headerlink" title="视觉场景图表示"></a>视觉场景图表示</h4><ul><li>视觉场景图表示（scene graph representation）是用场景图Ｇ=（V，R）表示一幅图像。</li><li>场景图中的节点V={v1, v2…vk}是图像中的目标集合，关系R={r1, r2…rk}是图像中目标和目标间的显式语义关系（如 wearing、eating）、空间位置关系（如 cover、intersect、in）和隐式语义关系的集合。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909155741554.png" alt="image-20240909155741554" style="zoom:67%;"><h3 id="根据融合阶段进行分类"><a href="#根据融合阶段进行分类" class="headerlink" title="根据融合阶段进行分类"></a>根据融合阶段进行分类</h3><ul><li>早期融合的特点是单模态表示学习简单，而多模态融合部分的模型深度大，融合策略复杂。例如，词的独热编码表示和视觉区域表示直接参与多模态融合</li><li>晚期融合的特点是单模态表示学习模型复杂，多模态融合一般采用拼接、按位乘／求平均等简单策略</li><li>在第３节介绍的多模态预训练模型中，基于单流架构（single stream）的预训练模型把融合操作放在早期阶段。</li><li>基于双流架构（two stream）的预训练模型则把融合操作放置在深层模型的中期阶段的多个层中</li></ul><h3 id="根据融合方式进行分类"><a href="#根据融合方式进行分类" class="headerlink" title="根据融合方式进行分类"></a>根据融合方式进行分类</h3><h4 id="门控融合"><a href="#门控融合" class="headerlink" title="门控融合"></a>门控融合</h4><ul><li>基于自编码和自回归的大规模预训练语言模型和在下游任务上的微调相结合是自然语言处理研究和应用的新方法</li><li>Rahman提出了一种多模态适应门（Multi-model Adaptation Gate，MAG）的网络结构将非语言特征（视觉和声学特征）与文本预训练语言模型融合，MAG与BERT结 合 （MAG-BERT）以 及MAG与XLNET结合（ＭＡＧ－ＸＬＮＥＴ）都可以有效融合三 个 模 态 信 息，并在多模态情感识别数据 集CMU-MOSI和CMU-MOSEI上获得当时最优性能。</li></ul><h4 id="注意力融合"><a href="#注意力融合" class="headerlink" title="注意力融合"></a>注意力融合</h4><ul><li>Bahdanau等人在2015年提出的注意力机制是为了让神经机器翻译模型中的<strong>解码器</strong>在每一步解码过程中，有针对性地选择源语言中<strong>“对齐”的词</strong>来指导目标语言的解码，包括全局注意力和局部注意力两种方法。</li><li>Yang等人提出了stacked attention networks（SANs），通过多层视觉注意力机制逐步过滤掉图像中的噪声区域，定位到与答案高度相关的图像区域，从而提高 ＶＱＡ 准确率。</li><li>Anderson等人提出一种“自底向上”和“自顶向下”相结合的注意力机制。具体的，基于Faster R-CNN的“自底向上”的注意力机制提取图像中的兴趣区域，“自顶向下”的注意力机制确定兴趣区域的权重。</li><li>Yu 等人提出了一种类 Transformer 结构的协同注意力机制，可实现文本中的任一词与图像中的任一区域间的完全交互。</li></ul><h4 id="Transformer融合"><a href="#Transformer融合" class="headerlink" title="Transformer融合"></a>Transformer融合</h4><ul><li>BERT凭借着 transformer强大的特征学习能力和掩码语言模型（Masked Language Model）实现双向编码，刷新了多个 NLP任务的最优性能。</li><li>基 于transformer的多模态融合又分为单流模型和双流模模型两大类。 单流模型使用一个transformer在一开始便对多模态信息进行充分的交互。双流模型则对不同的模态使用独立的transformer编码，再通过协同注意力机制实现不同模态间的融合，如图７所示。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909155859453.png" alt="image-20240909155859453" style="zoom: 80%;"><h4 id="图模型融合"><a href="#图模型融合" class="headerlink" title="图模型融合"></a>图模型融合</h4><p>图模型融合方法将不同模态数据建模为图结构，并利用图神经网络（Graph Neural Networks）等方法进行图结构的表示和学习，从而实现对多模态信息的融合和推理。Yin 等人将基于图的多模态融合编码器应用到多模态神经机器翻译模型中，把源语言中的词和图像中的物体放到了同一个图中，再堆叠多个基于图神经网络的多模态融合层（在每一层顺序执行模态内融合和模态间融合）。</p><h2 id="多模态预训练"><a href="#多模态预训练" class="headerlink" title="多模态预训练"></a>多模态预训练</h2><ul><li>通过预训练语言模型从海量无标注数据中学习通用知识，再在下游任务上用少量的标注数据进行微调，已经成为自然语言处理领域成熟的新范式。</li><li>相对于文本预训练语言模型，多模态预训练模型可以更好地对细颗粒度的多模态语义单元（词或者目标）间的相关性进行建模。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909160214538.png" alt="image-20240909160214538" style="zoom: 67%;"><ul><li><p>从表５中的１１个图像－语言跨模态预训练模型的对比，我们发现的跨模态预训练模型的特点如下</p><ul><li><p>①单流模型和双流模型均被广泛采用。</p></li><li><p>②多模态预训练模型从应用于多模态理解任务或多模态生成任务发展到可兼顾多模态理解和生成两大任务的统一模型。</p></li><li><p>③相对动辄上百 Ｇ 甚至 Ｔ 级别的单模态数据，多模态对齐数据的规模有限。</p><p>最新的多模态预训练模型可以利用互联网上的大规模非对齐的文本数据、图像数据、以及文本－图像对齐数据学习更通用的文本和视觉表示，以提高模型在视觉和语言的理解和生成能力，如 M3P和UNIMO。</p></li><li><p>④多模态预训练模型从仅应用于多模态下游任务发展到可同时应用于单模态下游任务 和 多模态下游任务。</p></li></ul></li></ul><h2 id="多模态大模型"><a href="#多模态大模型" class="headerlink" title="==多模态大模型=="></a>==多模态大模型==</h2><p>多模态大语言模型（MLLM）是近年来以强大的大语言模型（LLM）作为大脑任务的多模态研究热点。MLLM令人惊讶的涌现能力，比如基于图像写故事和无ocr的数学推理，在传统方法中是罕见的，这表明了一条通往人工通用智能的潜在道路。本文旨在对MLLM的最新研究进展进行跟踪和总结。首先，我们提出了MLLM的公式，并描述了它的相关概念。然后，我们讨论了关键的技术和应用，包括多模态指令调整（M-IT）、多模态上下文学习（M-ICL）、多模态思维链（M-CoT）和llm辅助视觉推理（LAVR）。最后，我们讨论了现有的挑战，并指出了很有前景的研究方向。鉴于MLLM的时代才刚刚开始，我们将继续更新这项调查，并希望它能激发更多的研究。</p><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><p>LMM在上下文学习In-Context Learning (ICL)，指令遵循instruction following，以及思维链Chain of Thought (CoT) 等方面都表现良好。但是仅限于理解离散文本，对视觉不敏感。 作为对比，大视觉模型Large Vision Models (LVMs）可以捕获视觉特征，但是推理落后。</p><p>鉴于此，多模态大模型Multimodal Large Language Model (MLLM)应运而生。在形式上，它指的是基于llm的具有接收、推理和输出多模态信息的能力的模型。在MLLM之前，有很多关于多模态的研究，可以分为判别的，生成的。CLIP，作为前者的代表，将视觉和文本信息投射到一个统一的表示空间中，为下游的多模态任务建立了一个桥梁。相比之下，OFA 是后者的代表，它以序列到序列的方式统一了多模态任务。</p><p>MLLM与传统模型相比，有两个具有代表性的特征： (1) MLLM是基于具有十亿尺度参数的LLM，这在以往的模型中是没有的。(2) MLLM使用新的训练范式来充分释放其全部潜力，例如使用多模态指令调优来鼓励模型遵循新的指令。有了这两个特性，MLLM展示了新的功能，比如基于图像编写网站代码，理解模因的深层含义，以及无ocr的数学推理。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>MLLM通常包含以下三个组件：</p><ul><li>A pre-trained modality encoder  一个预训练的<strong>模态编码器</strong>（接收和处理视觉/听觉等信号）</li><li>A pre-trained LLM 一个预训练的<strong>大模型</strong>（理解和推理信号）</li><li>A modality interface to connect them 一个连接他们的<strong>模态接口</strong>（对齐不同的模态）</li><li>一些mllm还包括一个生成器，用于输出除文本之外的其他模式。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240912200539075.png" alt="image-20240912200539075" style="zoom:80%;"><h3 id="模态编码器"><a href="#模态编码器" class="headerlink" title="模态编码器"></a>模态编码器</h3><p>编码器将原始信息，如图像或音频，压缩成一个更紧凑的表示形式。一种常见的方法是，使用一个<strong>预先训练过的编码器</strong>，而不是从头开始进行训练。例如，CLIP通过对图像-文本对的大规模预训练，集成了一个在语义上与文本对齐的视觉编码器。通过对齐预训练，使用这种最初预对齐的编码器与llm对齐更容易。</p><p>表1总结了一系列常用的图像编码器的使用情况。</p><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240912203228022.png" alt="image-20240912203228022" style="zoom:80%;"><p>MiniGPT-4采用了EVA-CLIP编码器，在参数相同的情况下，相比CLIP性能更出色，需要的训练成本更低。而EVA-CLIP的改进主要基于三点：</p><ul><li>EVA-CLIP通过借用EVA模型的预训练权重来初始化EVA-CLIP的图像编码器。</li><li>使用LAMB优化器。LAMB优化器专门为大批量训练而设计，其自适应元素级更新和层级学习率提高了训练效率并加速了收敛速度。</li><li>我们利用FLIP来提高CLIP模型训练的时间效率。在训练过程中随机遮蔽50%的图像标记，显著地将时间复杂度减少了一半。这种方法还允许将批量大小增加2倍，而不需要额外的内存开销。</li></ul><blockquote><p>EVA模型是在更大数据集上利用Mask Image Modeling任务，以CLIP 模型输入为完整的图像，而 EVA 模型的输入为有遮盖的图像，训练过程是让 EVA 模型遮盖部分的输出去重构 CLIP 模型对应位置的输出，从而以简单高效的方式让 EVA 模型同时拥有了语义学习 CLIP 的能力和几何结构学习 MIM 的能力。EVA 证明了这种训练方式可以帮助模型将参数扩展到十亿量级，并且在这个参数量级下在广泛下游任务中取得出色的性能。</p></blockquote><p>Osprey引入了<strong>基于卷积的ConvNext-L编码器，以利用更高分辨率和多层次特征。</strong>在原文的Convolutional CLIP Vision Encoder篇章中，因为Osprey是基于在像素级别的任务，如果直接用VIT类型的模型作为encoder，图片大小仅支持224或336，而增加输入图像分辨率受到了与ViT架构中全局注意力相关的计算负担的限制。在开放词汇分割任务中，基于CNN的编码器允许高效训练和快速推理，而不牺牲性能。此外，CNN基础的CLIP视觉编码器生成的多尺度特征图可以直接用于后续每个目标区域的特征提取，总之就是在细颗粒度任务中CNN表现更好。</p><p>一些研究也探索了无编码器架构。Fuyu-8b是一款<strong>纯解码器转换器</strong>，<strong>图像块被线性投影到转换器的第一层</strong>，绕过嵌入查找，只是将普通Transformer解码器视为图像转换器（尽管没有池化和因果注意力）。这意味着对于灵活输入的分辨率图片，Fuyu-8b有很强适应性。</p><blockquote><p>在架构方面，其他多模态模型因为涉及单独的图像编码器，其输出往往通过交叉注意或某种直接输入到 LLM 嵌入空间的适配器连接到现有的在推理时，所有分辨率高于此的图像都必须进行下采样，并且所有长宽比不匹配的图像都必须进行填充或扭曲。</p></blockquote><p>在选择编码器时，通常会考虑<strong>分辨率、参数大小和预训练语料库</strong>等因素。许多工作已经验证，使用更高的分辨率可以实现显著的性能提高。放大输入分辨率的方法可以分为直接缩放和patch分割方法。</p><p>不同架构对于处理不同分辨率的图片有着不同的策略。</p><ul><li><strong>使用不同编码器编码后进行特征融合</strong>：CogAgent使用了两个vision encoders去分别对高分辨率图片和低分辩率图片去进行编码，在得到高分辨率特征和低分辨率特征后，使用cross- attention进行高低分辨率特征融合。</li><li><strong>图片切片方法</strong>（patch-division method）：将高分辨率图像分割成多个小块，再利用低分辨率编码器去执行。其中图片切片方法可能需要positional embedding去提示每个小块在原始图片中的相对位置。</li></ul><p>在众多因素当中，图片分辨率的重要性要大于模型参数量和和训练数据组成。</p><h3 id="预训练LLM"><a href="#预训练LLM" class="headerlink" title="预训练LLM"></a>预训练LLM</h3><p>与从头开始训练LLM相比，从预先训练好的LLM开始更有效和实用。通过对web语料库进行大量的预训练，llm嵌入了丰富的世界知识，并展示了很强的泛化和推理能力。表2中总结了常用的和公开使用的llm。大多数llm在GPT-3之后，属于因果解码器类别</p><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240912205411017.png" alt="image-20240912205411017" style="zoom:80%;"><p>近年来，对混合专家模型（MoE）体系结构的探索越来越引起了[65]、[66]、[67]的关注。与密集模型相比，稀疏体系结构通过选择性地激活参数，可以在不增加计算成本的情况下放大总参数的大小。根据经验，MM1和MoE-LLaVA发现，MoE实现在几乎所有的基准测试上都比密集的实现获得了更好的性能。</p><h3 id="模态接口"><a href="#模态接口" class="headerlink" title="模态接口"></a>模态接口</h3><p>由于llm只能感知文本，因此弥合自然语言和其他模式之间的差距是必要的。然而，以端到端方式训练一个大型多模态模型将是昂贵的。一种更实用的方法是在预先训练过的视觉编码器和LLM之间引入一个可学习的连接器。另一种方法是在专家模型的帮助下将图像翻译成语言，然后将该语言发送到LLM。</p><h4 id="可学习的连接器"><a href="#可学习的连接器" class="headerlink" title="可学习的连接器"></a>可学习的连接器</h4><p>它负责弥合不同模式之间的差距。具体来说，该模块将信息投射到LLM能够有效理解的空间中。基于多模态信息的融合方式，大致有两种实现这种接口的方法，即token级融合和feature级融合。</p><h5 id="token级融合"><a href="#token级融合" class="headerlink" title="token级融合"></a>token级融合</h5><p>对于在token层面的融合，modality encoder输出的特征会被转化成与LLM输入等价的token表示，通过将text token representation和其他模态转化后的token representation进行拼接，可以作为“可以被理解”的LLM输入。</p><ul><li><p><strong>BLIP-2方案</strong>：利用一组可学习的查询token，以基于查询的方式提取信息。这种q-formers方法将视觉token压缩为更少的表示向量（在BLIP-2中，由256个visual-token压缩为32个query-token）。</p><blockquote><p>Q-Former初始化自一个BERT-Base模型，使用交叉注意力，其中KV的输入来自图像编码器，Q的输入由文本和可学习的查询标记拼接而来，目的是使用可学习标记和文本作为键，在视觉编码器输出的视觉标记中查询出与可学标记和文本相关的信息，作为后续输入给LLM的标记序列。</p></blockquote></li><li><p><strong>LLaVA方案：</strong>与之相对的，一些方法简单的使用基于MLP的接口来弥合模态差异。例如，LLaVA系列采用一两个线性MLP，将视觉token投影并将特征空间与词嵌入对齐。</p></li></ul><p>MM1已经通过消融实验验证了，对于token级融合，模态适配器的类型远不如<strong>视觉token的数量和输入分辨率</strong>重要。然而，在【What Matters in Training a GPT4-Style Language Model with Multimodal Inputs?】通过比较了token级和特征级融合的性能，并通过实证研究揭示，在视觉问答（VQA）基准测试方面，token级融合变体表现更好。关于这种性能差距，作者们认为，交叉注意力模型可能需要更复杂的超参数搜索过程才能达到相当的性能。</p><h5 id="feature级融合"><a href="#feature级融合" class="headerlink" title="feature级融合"></a>feature级融合</h5><p>特性级融合插入了额外的模块，支持文本特征和视觉特征之间的深度交互和融合。</p><ul><li>Flamingo在LLM的冻结 Transformer 层之间插入额外的交叉注意力层，从而用外部视觉线索增强语言特征。</li><li>CogVLM在每个 Transformer 层中插入视觉专家模块，实现视觉和语言特征之间的双向交互和融合。为了获得更好的性能，引入模块的 QKV 权重矩阵使用预训练 LLM 进行初始化。</li><li>LLaMA-Adapter在 Transformer 层中引入可学习的提示。这些提示首先嵌入视觉知识，然后作为前缀与文本特征连接。</li></ul><p>就参数规模而言，可学习接口通常与编码器和 LLM 相比只占很小的一部分。以 Qwen-VL为例，Q-Former 的参数规模约为 0.08B，占总参数的不到 1%，而编码器和 LLM 分别占约 19.8%（1.9B）和 80.2%（7.7B）。</p><h4 id="专家模型"><a href="#专家模型" class="headerlink" title="专家模型"></a>专家模型</h4><p>利用Expert modes，比如图生字幕的模型来弥合模态之间的gap，如Woodpecker，ChatCaptioner（Chatgpt问好问题，由BLIP2来回答问题），Caption Anything，Img2LLM。他们的核心思想，都是希望在不训练的情况下，能够将多模态的输入转换为语言，再输入LLM，相当于绕过了复杂的多模态建模和模态对齐的过程。</p><p>比如VideoChat-Text就是使用了一个<strong>预训练的视觉模型，来获取图像中的信息（如动作）</strong>，并通过一个Speech recognition model来丰富这些对图片的描述。</p><p>虽然使用专家模型很简单，但它可能不如采用可学习的interface那样灵活。将外部模态转换为文本会导致信息丢失。例如，将视频转换为文本描述会损失时空关系。</p><h2 id="训练策略与数据"><a href="#训练策略与数据" class="headerlink" title="训练策略与数据"></a>训练策略与数据</h2><p>完整的MLLM需要经过三个阶段的训练，包括预训练，指令微调和对齐微调。每个训练阶段需要不同类型的数据来实现不同的目标。在本章中，我们将讨论每个训练阶段的训练目标、数据采集和特点。</p><h3 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h3><p>作为第一个训练阶段，预训练旨在对齐不同模态以及学习多模态世界知识。预训练阶段通常需要大规模的文本对数据，一般都是一段描述性文本，对应其描述的图片/音频/视频。例如标题数据。</p><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20241012104042145.png" alt="image-20241012104042145" style="zoom:80%;"><p>在此，我们考虑一个常见的场景，训练一个MLLM用于<strong>对齐视觉和文本</strong>。如表3所示，给定一张图像，训练模型以标准的交叉熵损失自回归得预测图像的标题。通常做法有两种：冻结LLMs和visual encoders，只训练模态接口，这样不会对模型已有的预训练知识造成影响，代表有LLaVA、LLaVA-med、Detgpt；或者开放visual encoder的参数，这样可以在alignment的过程中有更多的参数可以训练，代表有Qwen-VL、mPLUG-Owl、VisionLLM。</p><p>值得注意的是，训练方案与数据质量密切相关。对于短而有噪声的标题数据，可以采用较低分辨率（比如224）来加速训练过程，而对于更长和更干净的数据，最好利用更高分辨率（如448或者更高）来减轻大模型幻觉。此外，ShareGPT4V发现<strong>在预训练阶段如果给予高质量的标题数据，解冻视觉编码器能获得更好的对齐效果。</strong></p><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20241012110008801.png" alt="image-20241012110008801" style="zoom:80%;"><p>用于预训练的数据集基本都是文本+X的pairs的形式，主要服务于两个目的，（1）对齐不同模态（2）提供世界知识。这些预训练语料库可以根据颗粒度分为coarse-grained和fine-grained。</p><ul><li>对于coarse-grained，数据集一般都是从互联网上爬取，caption一般都<strong>短而noisy</strong>，因为一般这些数据都是以Alt-text的形式来描述图片的（Alt-text是HTML中用于描述图像的属性，这些属性可能不够完整或准确）。因此都需要<strong>进行数据清洗，比如用CLIP过滤那些相似度低的图像文本对。</strong></li><li>对于fine-grained，近期更多的研究工作，如Sharegpt4、LVIS-INSTRUCT4V、Allava已经开始探索<strong>通过提示强大的多模态大语言模型（如GPT-4V）来生成高质量的细粒度数据。</strong>与粗粒度数据相比，这些数据通常包含更长且更准确的图像描述，从而实现图像和文本模态之间更精细的对齐。然而，由于这种方法通常需要调用商业用途的多模态大语言模型，成本较高，且数据量相对较小。值得注意的是，ShareGPT4V在这方面取得了平衡：首先使用GPT-4V生成的10万条数据训练一个图像描述生成器，然后使用这个预训练的生成器将数据量扩大到120万。</li></ul><h3 id="指令微调"><a href="#指令微调" class="headerlink" title="指令微调"></a>指令微调</h3><p>指令指的是任务的描述。直观的说，指令微调目的在<strong>于教会模型更好的理解用户的指令</strong>并完成所要求的任务。通过这种方式进行微调，LLMs可以通过遵循新的指令泛化到未曾见过的任务，以此来<strong>增强零样本能力</strong>。这种简单而有效的理念助推了后续NLP工作的成功，例如 ChatGPT、InstructGPT、FLAN和 OPT-IML。</p><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20241012142412742.png" alt="image-20241012142412742" style="zoom:80%;"><ul><li>监督微调方法通常需要大量特定任务的数据来<strong>训练特定任务的模型</strong>。</li><li>提示方法减少了对大规模数据的依赖，可以通过<strong>提示工程来完成特定任务</strong>。在这种情况下，虽然少样本性能有所提高，但零样本性能仍然相当平均。</li><li>与之不同，指令调优学习如何<strong>泛化到未见过的任务</strong>，而不是像另外两种方法那样适应特定任务。此外，指令调优与多任务提示高度相关。</li></ul><p>在这一节，我们会描述指令样本的格式、训练目标、收集指令数据的典型方法以及相应的常用数据集。</p><p><strong>数据格式</strong></p><p>多模态指令样本通常包括可选的指令和输入-输出对。其中指令通常是描述任务的自然语言句子，比如，“详细地描述这张图片”。输入可以是VQA任务中的图像-文本对，也可以是图像描述任务中的只有图片。输出则是以输入为条件的面向指令的答案。指令模版灵活，可以人为设计，正如表5中所示。注意，指令模版也可以推广到多轮对话的情况。</p><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20241012142750875.png" alt="image-20241012142750875" style="zoom:67%;"><p><strong>数据收集</strong></p><p>由于指令数据在格式上更加灵活，任务表述也更加多样化，收集数据样本通常更加棘手和昂贵。目前给出了三种大规模获取指令数据集的典型方法</p><ul><li><p><strong>Data Adaptation</strong></p><ul><li>总结来说，就是利用现有的高质量任务特定数据集，并将这些数据集转换为指令格式的数据集。如VQA类数据集，原始的格式是（图像+问题）——&gt;答案，可以转换为（指令+图像+问题）——&gt;答案。</li><li>有些工作如Minigpt-4、LLaVA-med、InstructBLIP、X-LLM、Multi-instruct、M3it，通过手工制作一个候选指令池，并在训练时从中采样。有些工作则是手动设计一些种子指令，并用这些来提示GPT生成更多指令，如Videochat、Visionllm、Multimodal-gpt。</li></ul></li><li><p><strong>Self-Instruction</strong></p><ul><li>尽管现有的多任务数据集可以提供丰富的数据来源，但它们通常<strong>无法很好地满足真实场景中的人类需求</strong>，比如多轮对话。为解决这个问题，一些研究采用了Self-Insruction方法收集样本，该方法利用大语言模型（LLMs）<strong>基于少量手工标注的样本生成文本指令数据</strong>。具体来说，一些指令样本被手工制作作为示范，然后<strong>提示ChatGPT/GPT-4根据这些示范指导生成更多的指令样本</strong>。</li><li>LLaVA将这种方法扩展到多模态领域，它通过<strong>将图像转换为文本描述和边界框信息</strong>，然后提示纯文本的GPT-4在需求和示范的指导下生成新数据。通过这种方式，构建了一个名为LLaVA-Instruct-150k的多模态指令数据集。</li><li>遵循这一思路，后续的工作如MiniGPT-4、ChatBridge、GPT4Tools 和DetGPT开发了满足不同需求的不同数据集。最近，随着更强大的多模态模型GPT-4V的发布，许多工作采用GPT-4V生成更高质量的数据，如LVIS-Instruct4V和ALLaVA。</li></ul></li><li><p><strong>Data Mixture</strong></p><ul><li>除了多模态指令数据之外，<strong>纯语言的user-assistant</strong>这种对话数据也可以用来提高对话能力和遵循指令的能力（mPLUG-Owl，Multimodal-gpt，LaVIN，Llama-adapter v2）。LaVIN直接通过从纯语言和多模态数据中随机采样来构建小批量（minibatch）。MultiInstruct探索了<strong>使用单模态和多模态数据融合进行训练</strong>的不同策略，包括混合指令调优（结合两种类型的数据并随机打乱）和顺序指令调优（先使用文本数据，然后是多模态数据）。</li></ul></li></ul><p><strong>数据质量</strong></p><p>最近的研究已经表明，在一个高质量的小型微调指令集（smaller but cleaner）上训练的模型，其效果要好于在一个大规模nosiy的image-pairs上训练的模型。在Lynx等研究中已经揭示，一个高质量的数据集应该包含更丰富多样的Prompt、且难度上应该涉及多一些的reasoning。比如用更多的视觉reasoning task，而不是captioning或QA任务，即要为大模型上难度。</p><h3 id="对齐微调"><a href="#对齐微调" class="headerlink" title="对齐微调"></a>对齐微调</h3><p>对齐微调通常用于模型需要与特定的人类偏好对齐的场景，例如幻觉较少的回答。目前，Reinforcement Learning with Human Feedback (RLHF) 和 Direct Preference Optimization (DPO) 是两种主要的对齐微调手段。</p><p>RLHF。该技术旨在利用强化学习算法将LLM与人类偏好对齐，该过程中使用了人工标注作为训练循环中的监督。如 InstructGPT 所示，RLHF 包含三个关键步骤：1）监督微调。2）奖励建模。3）强化学习。</p><p>DPO是通过使用简单的二元分类损失来从人类偏好标签中学习。与基于PPO的RLHF算法相比，DPO不需要学习显式的奖励模型，因此将整个流程简化为两个步骤：人类偏好数据收集和偏好学习。</p><p>除了以上两个耳熟能详的，还有RLHF-V通过纠正模型中的幻觉来收集细粒度（段落级别）的偏好数据对。Silkie则通过提示GPT-4V来收集偏好数据，并通过DPO将偏好监督蒸馏到一个经过指令微调的模型中。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>吴友政,李浩然,姚霆,等.多模态信息处理前沿综述：应用、融合和预训练[J].中文信息学报,2022,36(05):1-20.</p><p>A Survey on Multimodal Large Language Models</p><p><a href="https://github.com/BradyFU/Awesome-Multimodal-Large-Language-Models">BradyFU/Awesome-Multimodal-Large-Language-Models: <span class="github-emoji"><span>✨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>✨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Latest Advances on Multimodal Large Language Models (github.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/713777861">2024 多模态大模型综述总结 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 多模态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2024/06/15/java/"/>
      <url>/2024/06/15/java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>Java特点</strong>：面向对象（封装，继承，多态）；平台无关（基于JVM）；可靠安全（异常处理，自动内存管理，多重安全防护）；编译与解释并存-&gt;一次编译，到处运行；Java生态</p><p>Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><blockquote><p>编译型：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有C、C++、Go、Rust等等。<br>解释型：释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。<br>Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，这些字节码可以在任何安装了Java虚拟机的平台上运行，由解释器逐条将字节码解释为机器码来执行。这种方式使得Java程序具有了跨平台性，同一份Java代码可以在各种操作系统和硬件平台上运行，而不需要针对不同平台进行重新编译。</p></blockquote><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，<strong>在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</strong>。</p><p>JVM引入 <strong>JIT（Just in Time Compilation）</strong> 编译器， 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p><strong>Java和C++：</strong></p><ul><li>Java <strong>不提供指针</strong>来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有**自动内存管理垃圾回收机制(GC)**，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java <strong>只支持方法重载（</strong>操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h3 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h3><p>JDK（Java Development Kit）是一个功能齐全的 Java 开发工具包，供开发者使用，用于创建和编译 Java 程序。它包含了 JRE（Java Runtime Environment），以及编译器 javac 和其他工具，如 javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等。</p><p>JRE （Java运行时环境）是运行已编译 Java 程序所需的环境，主要包含以下两个部分：<strong>JVM</strong> : Java 虚拟机。<strong>Java 基础类库（Class Library）</strong>：一组标准的类库，提供常用的功能和 API（如 I/O 操作、网络通信、数据结构等）。</p><p>JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE，还包括用于开发和调试 Java 程序的工具。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><img src="/2024/06/15/java/image-20240615094911702.png" alt="image-20240615094911702" style="zoom:80%;"><h3 id="基本类型和包装类型"><a href="#基本类型和包装类型" class="headerlink" title="基本类型和包装类型"></a>基本类型和包装类型</h3><ul><li><strong>用途</strong>：基本类型用于定义一些<strong>常量和局部变量</strong>。方法参数/对象属性等多用包装类型。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本类型的<strong>局部变量</strong>存放在 Java 虚拟机<strong>栈</strong>中的局部变量表中，基本数据类型的<strong>成员变量</strong>（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的<strong>堆</strong>中。包装类型属于对象类型，存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， <strong>基本数据类型占用的空间往往非常小。</strong></li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code>，而<strong>成员变量基本类型有默认值</strong>且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说<strong>，<code>==</code> 比较的是对象的内存地址。</strong>所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p><strong>包装类型缓存机制：</strong>包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><p>自动拆装箱：</p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// 装箱 调用包装类的.valueOf方法 -- 等价于 Integer i = Integer.valueOf(10)</span><span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>   <span class="token comment">// 拆箱 调用包装类的xxxValue方法 -- 等价于int n = i.intValue();</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><ul><li><p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p></li><li><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p></li><li><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p></li><li><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p></li></ul><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><ul><li>重载（overload）是在一个类（或父类与子类）里面，方法名字相同，而<strong>参数不同</strong>。返回类型可以相同也可以不同。</li><li>重写（override）发生在<strong>运行期</strong>，是指子类定义了一个与其父类中具有<strong>相同名称和参数列表</strong>的方法，并且子类方法的实现覆盖了父类方法的实现。</li></ul><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">发生范围</td><td align="left">同一个类</td><td align="left">子类</td></tr><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可修改</td><td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td align="left">异常</td><td align="left">可修改</td><td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td align="left">访问修饰符</td><td align="left">可修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr><tr><td align="left">发生阶段</td><td align="left">编译期</td><td align="left">运行期</td></tr></tbody></table><p><strong>方法的重写要遵循“两同两小一大”</strong>：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：<code>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改</code>。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><p>另：类的构造方法<strong>不能被重写（override）</strong>，但<strong>可以被重载（overload）</strong>。因此，一个类中可以有多个构造方法，这些构造方法可以具有不同的参数列表，以提供不同的对象初始化方式。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指把一个对象的<strong>状态信息（也就是属性）隐藏在对象内部</strong>，不允许外部对象直接访问对象的内部信息。但是可以<strong>提供一些可以被外界访问的方法</strong>来操作属性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在<strong>程序运行期间才能确定</strong>；</li><li><strong>多态不能调用“只在子类存在但在父类不存在”的方法；</strong></li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul><p>另：<strong>静态方法不支持多态。</strong>多态是面向对象编程中的一个核心概念，它允许子类通过重写父类的方法来提供特定的实现。然而，由于静态方法不依赖于对象实例，它们不适用于多态。<strong>静态方法的调用在编译时就已经确定</strong>，这种机制被称为静态绑定或早期绑定。</p><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p><strong>抽象类</strong>：包含抽象方法的类。通过abstract关键字来创建抽象类，以及定义抽象方法。抽象类的存在就是为了被继承，所以抽象类中的抽象方法不能被private、static、final修饰，否则无法被继承。抽象类虽然不能被实例化，<strong>但是它可以有构造方法，供子类创建对象时，初始化父类成员。</strong></p><p><strong>接口</strong>：接口是一种引用数据类型，可以看成是多个类的公共规范。定义接口需要借助interface关键字，定义方式与定义类的方式相似</p><p><strong>共同点</strong>：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。<strong>每个抽象方法前都隐藏着public abstract修饰。</strong></li><li><strong>都可以有默认实现的方法</strong>（Java 8 开始可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li><strong>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为</strong>。抽象类主要用于代码复用，强调的是<strong>所属关系</strong>。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而<strong>抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</strong></li><li>接口中<strong>不能有</strong>静态代码块（<strong>可以有静态成员方法</strong>）、实例代码块以及构造方法；而<strong>抽象类可以有构造方法</strong>，供子类创建对象时，初始化父类成员。</li></ul><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说<strong>拷贝对象和原对象共用同一个内部对象。</strong></p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><img src="/2024/06/15/java/shallow&amp;deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图" style="zoom:80%;"><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>线程安全性：</strong><code>String</code> 中的对象是不可变的，也就可以理解为<strong>常量，线程安全</strong>。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了<strong>同步锁</strong>或者对调用的方法加了同步锁，所以是<strong>线程安全的</strong>。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能：</strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="String不可变"><a href="#String不可变" class="headerlink" title="String不可变"></a>String不可变</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为<strong>这个数组保存的字符串是可变的</strong>（<code>final</code> 修饰引用类型变量的情况）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为<strong>私有</strong>的，并且**<code>String</code> 类没有提供/暴露修改这个字符串的方法。**</li><li><code>String</code> 类被 <code>final</code> 修饰导致其<strong>不能被继承</strong>，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><p>在 Java 9 之后，<code>String</code>、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>    <span class="token comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span>    <span class="token annotation punctuation">@Stable</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，用于存储字符串常量，主要目的是为了避免字符串的重复创建。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 在字符串常量池中创建字符串对象 ab</span><span class="token comment">// 将字符串对象 ab 的引用赋值给 aa -- aa是在栈上存储的ab对象的引用</span><span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span><span class="token comment">// 直接返回字符串常量池中字符串对象 ab，赋值给引用 bb -- 此时不创建任何对象</span><span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa<span class="token operator">==</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了使用双引号创建字符串会自动放入常量池外，还可以使用 <code>String</code> 类的 <code>intern()</code> 方法手动将字符串添加到常量池中。<code>intern()</code> 方法会先检查常量池中是否已经存在该字符串，如果存在则返回常量池中的引用；如果不存在，则将该字符串添加到常量池中，并返回其引用<strong>。intern() 方法的主要作用是确保字符串引用在常量池中的唯一性。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InternExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true，因为 str2 和 str3 都引用常量池中的 "hello"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>位置变化：</p><ol><li><p>在JDK1.7前，运行时常量池+字符串常量池是存放在<strong>方法区</strong>中，HotSpot VM对方法区的实现称为<strong>永久代</strong>。</p><ul><li>方法区是<strong>各个线程共享的内存区域</strong>，是用于存储已经被<strong>JVM加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</li><li>很多人会把方法区称为<code>永久代</code>，其实本质上是不等价的，只不过HotSpot虚拟机设计团队是选择把GC分代收集扩展到了方法区，使用永久代来代替实现方法区。其实，在方法区中的垃圾收集行为还是比较少的，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，但是这个区域的回收总是不尽如人意的，如果该区域回收不完全就会出现内存泄露。</li></ul></li><li><p>在JDK1.7中，字符串常量池从方法区<strong>移到堆中</strong>，运行时常量池保留在方法区中。</p><ul><li><p>需要注意的是，永久代的大小是有限的，并且很难准确地确定一个应用程序需要多少永久代空间。如果我们在应用程序中使用了大量的类、方法、常量等静态数据，就有可能导致永久代空间不足。这种情况下，JVM 就会抛出 OutOfMemoryError 错误。</p></li><li><p>因此，从 Java 7 开始，为了解决永久代空间不足的问题，将字符串常量池从永久代中移动到堆中。这个改变也是为了更好地支持动态语言的运行时特性。</p></li></ul></li><li><p>在JDK1.8中，HotSpot<strong>移除永久代</strong>，使用<strong>元空间</strong>代替（也就是元空间成为了对“方法区”概念的实现），此时字符串常量池依然保留在堆中，运行时常量池保留在方法区（元空间）中，<strong>JVM内存变成了直接内存。</strong></p></li></ol><p>常量折叠：常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p><p>对于 <code>String str3 = "str" + "ing";</code> 编译器会给你优化成 <code>String str3 = "string";</code> 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><img src="/2024/06/15/java/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图" style="zoom:80%;"><p><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p><ul><li><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p></li><li><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(<strong>参数错误比如方法入参类型错误</strong>)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li></ul></li></ul><p>**<code>Error</code>**：<code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型，即“<strong>参数化类型</strong>”。在方法定义时，将方法签名中的<code>形参的数据类型</code>也设置为参数（也可称之为类型参数），在调用该方法时再从外部传入一个具体的数据类型和变量。<strong>泛型的本质是为了将类型参数化</strong>， 也就是说在泛型使用过程中，<strong>数据类型被设置为一个参数，在使用时再从外部传入一个数据类型</strong>；而一旦传入了具体的数据类型后，传入变量（实参）的数据类型如果不匹配，编译器就会直接报错。这种参数化类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><ul><li>泛型提供了一种<strong>扩展</strong>能力，更符合面向对象开发的软件编程宗旨。</li><li>泛型提高了程序代码的<strong>可读性</strong>。在定义泛型阶段（类、接口、方法）或者对象实例化阶段，由于 &lt; 类型参数 &gt; 需要在代码中显式地编写，所以程序员能够快速猜测出代码所要操作的数据类型，提高了代码可读性。</li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类型参数用于类的定义中，则该类被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>     <span class="token comment">// key 这个成员变量的数据类型为 T, T 的类型由外部传入  </span>    <span class="token keyword">private</span> <span class="token class-name">T</span> key<span class="token punctuation">;</span><span class="token comment">// 泛型构造方法形参 key 的类型也为 T，T 的类型由外部传入</span>    <span class="token keyword">public</span> <span class="token class-name">Generic</span><span class="token punctuation">(</span><span class="token class-name">T</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 泛型方法 getKey 的返回值类型为 T，T 的类型由外部指定</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>泛型类中的静态方法和静态变量不可以使用泛型类所声明的类型参数</strong></p><ul><li>泛型类中的<strong>类型参数的确定是在创建泛型类对象</strong>的时候（例如 ArrayList&lt; Integer &gt;）。</li><li>而静态变量和静态方法在类加载时已经初始化，直接使用类名调用；在泛型类的类型参数未确定时，静态成员有可能被调用，因此泛型类的类型参数是不能在静态成员中使用的。</li><li>静态泛型方法中可以使用自身的方法签名中<strong>新定义的类型参数</strong>（即泛型方法），而不能使用泛型类中定义的类型参数。</li></ul><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Inter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>泛型接口中的类型参数，在该接口被继承或者被实现时确定。</strong></p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>当在一个方法签名中的<strong>返回值前面声明了一个 &lt; T &gt; 时</strong>，该方法就被声明为一个<code>泛型方法</code>。&lt; T &gt;表明该方法声明了一个类型参数 T，并且这个类型参数 T 只能在该方法中使用。当然，泛型方法中也可以使用<code>泛型类中定义的泛型参数</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token comment">// 该方法只是使用了泛型类定义的类型参数，不是泛型方法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token class-name">U</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// &lt;T&gt; 真正声明了下面的方法是一个泛型方法</span><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">testMethod1</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>泛型类中定义的类型参数和泛型方法中定义的类型参数是相互独立的，它们一点关系都没有。<strong>也就是说，泛型方法始终以自己声明的类型参数为准。</strong></p><p>为了避免混淆，如果在一个泛型类中存在泛型方法，那么两者的类型参数最好不要同名。</p><p><strong>在静态成员中不能使用泛型类定义的类型参数，但我们可以将静态成员方法定义为一个泛型方法。</strong></p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>泛型的本质是将<code>数据类型参数化</code>，它通过<strong>擦除</strong>的方式来实现，即编译器会在编译期间<code>擦除</code>代码中的所有泛型语法并相应的做出一些类型转换动作。</p><p>换而言之，<strong>泛型信息只存在于代码编译阶段</strong>，在代码编译结束后，与泛型相关的信息会被擦除掉，专业术语叫做<code>类型擦除</code>。也就是说，<strong>成功编译过后的 class 文件中不包含任何泛型信息</strong>，泛型信息不会进入到<code>运行时阶段</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">T</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 将这个泛型类反编译, 结果如下</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 默认构造器，不用管</span><span class="token keyword">private</span> <span class="token class-name">Object</span> num<span class="token punctuation">;</span><span class="token comment">// T 被替换为 Object 类型</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以发现编译器<code>擦除</code>了 Caculate 类后面的泛型标识 &lt; T &gt;，并且将 num 的数据类型替换为 Object 类型，而替换了 T 的数据类型我们称之为<code>原始数据类型</code>。</li></ul><p><strong>那么是不是所有的类型参数被擦除后都以 Object 类进行替换呢？</strong></p><ul><li>答案是否定的，大部分情况下，类型参数 T 被擦除后都会以 Object 类进行替换；而有一种情况则不是，那就是使用到了 extends 和 super 语法的<code>有界类型参数</code>（即<code>泛型通配符</code>）。</li></ul><p>在现实编码中，确实有这样的需求，希望泛型能够处理<code>某一类型范围内</code>的类型参数，比如某个泛型类和它的子类，为此 Java 引入了<code>泛型通配符</code>这个概念。</p><blockquote><ol><li><!--?--> ：被称作无限定的通配符。**代表了任何一种数据类型。**</li><li><!--? extends T--> ：被称作有上界的通配符。 **逻辑上表示类型参数的范围是 T 和 T 的子类。**</li><li><!--? super T--> ：被称作有下界的通配符。 **逻辑上表示类型参数的范围是 T 和 T 的超类。**</li></ol></blockquote><ul><li><p>Object 本身也算是一种数据类型，但却不能代表任何一种数据类型，所以 ArrayList&lt; Object &gt; 和 ArrayList&lt;?&gt;的含义是不同的，前者类型是 Object，也就是继承树的最高父类，而后者的类型完全是未知的；ArrayList&lt;?&gt; 是 ArrayList&lt; Object &gt; 逻辑上的父类。</p></li><li><p>ArrayList&lt; Integer &gt; 和 ArrayList&lt; Number &gt; 之间不存在继承关系。而引入上界通配符的概念后，我们便可以在逻辑上将 ArrayList&lt;? extends Number&gt; 看做是 ArrayList&lt; Integer &gt; 的父类，<strong>但实质上它们之间没有继承关系。</strong></p></li><li><p>ArrayList&lt;? super Integer&gt; 在逻辑上表示为 Integer 类以及 Integer 类的所有父类，它可以代表 ArrayList&lt; Integer&gt;、ArrayList&lt; Number &gt;、 ArrayList&lt; Object &gt;中的某一个集合，但实质上它们之间没有继承关系。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">T</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 默认构造器，不用管</span><span class="token keyword">private</span> <span class="token class-name">Number</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用到了 extends 语法的类型参数 T 被擦除后会替换为 Number 而不再是 Object。</li><li>extends 和 super 是一个<strong>限定类型参数边界的</strong>语法，extends 限定 T 只能是 Number 或者是 Number 的<strong>子类</strong>。 也就是说，在创建 Caculate 类对象的时候，尖括号 &lt;&gt; 中只能传入 Number 类或者 Number 的子类的数据类型，所以在创建 Caculate 类对象时无论传入什么数据类型，Number 都是其父类，于是可以使用 Number 类作为 T 的原始数据类型，进行类型擦除并替换。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>泛型信息被擦除了，如何保证我们在集合中只添加指定的数据类型的对象呢？</p><ul><li>其实在创建一个泛型类的对象时， Java 编译器是先检查代码中传入 &lt; T &gt; 的<strong>数据类型，并记录下来</strong>，然后再对代码进行编译，<code>编译的同时进行类型擦除</code>；如果需要对被擦除了泛型信息的对象进行操作，<strong>编译器会自动将对象进行类型转换。</strong></li></ul><blockquote><p>可以把泛型的类型安全检查机制和类型擦除想象成演唱会的验票机制：以 ArrayList&lt; Integer&gt; 泛型集合为例。</p><p>当我们在创建一个 ArrayList&lt; Integer &gt; 泛型集合的时候，ArrayList 可以看作是演唱会场馆，而&lt; T &gt;就是场馆的验票系统，Integer 是验票系统设置的门票类型；<br>当验票系统设置好为&lt; Integer &gt;后，只有持有 Integer 门票的人才可以通过验票系统，进入演唱会场馆（集合）中；若是未持有 Integer 门票的人想进场，则验票系统会发出警告（编译器报错）。<br>在通过验票系统时，门票会被收掉（类型擦除），但场馆后台（JVM）会记录下观众信息（泛型信息）。<br>进场后的观众变成了没有门票的普通人（原始数据类型）。但是，在需要查看观众的信息时（操作对象），场馆后台可以找到记录的观众信息（编译器会自动将对象进行类型转换）。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericType</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> arrayInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置验票系统   </span>        arrayInteger<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 观众进场，验票系统验票，门票会被收走（类型擦除）</span>        <span class="token class-name">Integer</span> n <span class="token operator">=</span> arrayInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取观众信息，编译器会进行强制类型转换</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>擦除 ArrayList&lt; Integer &gt; 的泛型信息后，get() 方法的返回值将返回 Object 类型，但编译器会自动插入 Integer 的强制类型转换。也就是说，编译器把 get() 方法调用翻译为两条字节码指令：</p><ul><li>对原始方法 get() 的调用，返回的是 Object 类型；</li><li>将返回的 Object 类型强制转换为 Integer 类型；</li></ul><p><strong>项目中哪里用到了泛型</strong></p><ul><li><strong>自定义接口通用返回结果</strong> <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li><li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li><li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射 (Reflection) 是 Java 的特征之一，它允许<strong>运行中的 Java 程序获取自身的信息</strong>，并且可以操作类或对象的内部属性。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p><p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。</p><p><strong>使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码），一切反射的操作都是从Class对象开始</strong></p><p>反射就是把java类中的各种成分映射成一个个的Java对象：在 Java 中，当程序启动时，类加载器会将 <code>.class</code> 文件加载到内存中，并创建对应的 <code>Class</code> 对象。每个类在 JVM 中都有且仅有一个对应的 <code>Class</code> 对象，它包含了该类的所有信息，如类的名称、父类、接口、字段、方法等。</p><p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把各个组成部分映射成一个个对象。</p><img src="/2024/06/15/java/20170513133210763" alt="img" style="zoom:80%;"><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>运行时动态获取类的信息</strong>：在编写代码时，对于类的信息是必须在编译时确定的，但在运行时，有时需要根据某些条件，动态获取某个类的信息，这时就可以使用Java中的反射机制。</li><li>动态生成对象：反射机制可以在<strong>运行时生成对象</strong>，这样就可以根据参数的不同，动态的创建不同的类的实例对象。</li><li>动态调用方法：通过反射机制可以调用类中的方法，不论这些方法是否是公共的，也不论这些方法的参数个数和类型是什么，反射机制都具有这样的能力。</li><li>动态修改属性：利用反射机制可以获取到类中的所有成员变量，并可以对其进行修改。</li><li><strong>实现动态代理：</strong>利用反射机制可以实现代理模式，<strong>通过代理对象完成原对象对某些方法的调用</strong>，同时也可以在这些方法的调用前后做一些额外的处理。</li></ul><p>Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。<strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p><h3 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h3><p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种<strong>特殊的注释</strong>，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。注解的引入主要是为了简化某些编程模式和减轻开发者的负担。例如，它们可以用来自动生成代码、序列化/反序列化数据、配置框架和处理权限。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口。基本语法：定义一个注解类似于定义一个接口，但是在关键字 <strong>interface</strong> 前加上 <strong>@</strong> 符号。例如定义一个简单的注解 <strong>@MyAnnotation</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">MyAnnotation</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注解本身只是一种标记，它不会自动执行任何操作。要使注解发挥作用，需要在运行时通过反射机制来读取和处理注解信息。具体步骤如下：</p><ul><li><strong>获取 <code>Class</code> 对象</strong>：通过类名、对象实例等方式获取目标类的 <code>Class</code> 对象。</li><li><strong>获取注解信息</strong>：使用 <code>Class</code> 对象、<code>Method</code> 对象、<code>Field</code> 对象等的方法来检查是否存在特定的注解，并获取注解的实例。</li><li><strong>处理注解信息</strong>：根据注解的属性值和类型，执行相应的逻辑。</li></ul><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的</li></ul><p><strong>反射机制使得注解可以在运行时动态地应用于不同的类、方法和字段，而不需要在编译时就确定具体的使用位置</strong>。这大大增强了注解的灵活性和可扩展性。例如，在 Spring 框架中，通过反射和注解的结合，可以实现依赖注入、面向切面编程等功能，使得代码更加简洁和易于维护。</p><p><strong>注解可以为反射操作提供额外的元数据信息，使得反射在处理类和对象时能够更加智能和灵活。</strong>例如，通过注解可以指定方法的执行顺序、字段的验证规则等，反射可以根据这些注解信息来执行相应的操作。</p><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span></span><span class="token punctuation">;</span><span class="token comment">// 定义注解</span><span class="token annotation punctuation">@interface</span> <span class="token class-name">MyAnnotation</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 使用注解</span><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@MyAnnotation</span><span class="token punctuation">(</span><span class="token string">"Hello, Annotation!"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This is my method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 处理注解</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationProcessor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchMethodException</span> <span class="token punctuation">{</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token class-name">Method</span> method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"myMethod"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 根据反射获取类方法，判断方法是否带有MyAnnotation注解</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">MyAnnotation</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">MyAnnotation</span> annotation <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">MyAnnotation</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取注解实例，读取属性</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotation<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token comment">// 调用类方法</span>                method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中，通过反射获取 <code>MyClass</code> 类的 <code>myMethod</code> 方法，检查该方法是否带有 <code>MyAnnotation</code> 注解。如果有，则获取注解的实例并读取其属性值，同时调用该方法。</p><h3 id="获取class对象"><a href="#获取class对象" class="headerlink" title="获取class对象"></a>获取class对象</h3><p>Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//  知道具体类的情况下可以使用 -- 类名.class</span><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">TargetObject</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment">//  通过 Class.forName()传入类的全路径获取</span><span class="token class-name">Class</span> clazz1 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.javaguide.TargetObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  通过对象实例instance.getClass()获取</span><span class="token class-name">TargetObject</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TargetObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Class</span> clazz2 <span class="token operator">=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  通过类加载器xxxClassLoader.loadClass()传入类路径获取</span><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"cn.javaguide.TargetObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 可以使用 Class 对象的 newInstance() 方法（在 Java 9 及以后版本已被弃用）或 Constructor 对象的 newInstance() 方法来创建对象</span><span class="token comment">// 反射实例化 -- 对象.newInstance()</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.javaguide.TargetObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TargetObject</span> targetObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TargetObject</span><span class="token punctuation">)</span> targetClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用无参构造函数创建对象</span><span class="token class-name">Person</span> person1 <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用有参构造函数创建对象</span><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> person2 <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>获得类中属性相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getField(String name)</td><td align="left">获得某个公有的属性对象</td></tr><tr><td align="left">getFields()</td><td align="left">获得所有公有的属性对象</td></tr><tr><td align="left">getDeclaredField(String name)</td><td align="left">获得某个属性对象</td></tr><tr><td align="left">getDeclaredFields()</td><td align="left">获得所有属性对象</td></tr></tbody></table><ul><li><strong>获得类中注解相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getAnnotation(Class annotationClass)</td><td align="left">返回该类中与参数类型匹配的公有注解对象</td></tr><tr><td align="left">getAnnotations()</td><td align="left">返回该类所有的公有注解对象</td></tr><tr><td align="left">getDeclaredAnnotation(Class annotationClass)</td><td align="left">返回该类中与参数类型匹配的所有注解对象</td></tr><tr><td align="left">getDeclaredAnnotations()</td><td align="left">返回该类所有的注解对象</td></tr></tbody></table><ul><li><strong>获得类中构造器相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getConstructor(Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类中与参数类型匹配的公有构造方法</td></tr><tr><td align="left">getConstructors()</td><td align="left">获得该类的所有公有构造方法</td></tr><tr><td align="left">getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类中与参数类型匹配的构造方法</td></tr><tr><td align="left">getDeclaredConstructors()</td><td align="left">获得该类所有构造方法</td></tr></tbody></table><ul><li><strong>获得类中方法相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类某个公有的方法</td></tr><tr><td align="left">getMethods()</td><td align="left">获得该类所有公有的方法</td></tr><tr><td align="left">getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类某个方法</td></tr><tr><td align="left">getDeclaredMethods()</td><td align="left">获得该类所有方法</td></tr></tbody></table><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><ul><li><strong>序列化</strong>：将数据结构或对象转换成<strong>二进制字节流</strong>（或JSON、XML等存储格式）的过程。这些字节序列可以被存储到文件、数据库中，也可以通过网络传输到其他地方。序列化的主要目的是实现<strong>对象的持久化和远程通信。</strong></li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成原始数据结构或者对象的过程</li></ul><p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><blockquote><p>Java 序列化机制基于<strong>对象的类信息和对象的状态（即对象的字段值）</strong>来实现。在序列化过程中，Java 会将对象的类信息（包括类名、字段类型等）和对象的字段值按照一定的格式转换为字节序列。在反序列化过程中，Java 会根据字节序列中的类信息加载相应的类，并根据字段值恢复对象的状态。</p></blockquote><p><strong>应用场景</strong></p><ul><li><strong>对象持久化</strong>：将对象保存到文件或数据库中，以便在程序下次启动时可以恢复对象的状态。</li><li><strong>远程通信</strong>：在分布式系统中，通过网络传输对象时，需要将对象序列化后发送到远程节点，然后在远程节点进行反序列化。</li><li><strong>缓存</strong>：将对象序列化后存储在缓存中，如 Redis 等，以提高系统的性能。</li></ul><h3 id="JDK序列化"><a href="#JDK序列化" class="headerlink" title="JDK序列化"></a>JDK序列化</h3><ul><li>被序列化的类必须实现 <code>java.io.Serializable</code> 接口，该接口是一个标记接口，没有任何方法，只是用于标识该类的对象可以被序列化。</li><li>提供一个 <code>private static final long serialVersionUID</code> 字段，用于标识类的版本号，确保序列化和反序列化时使用的是同一个版本的类。如果不提供，Java 会根据类的结构自动生成一个 <code>serialVersionUID</code>，但在类结构发生变化时可能会导致反序列化失败。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Builder</span><span class="token annotation punctuation">@ToString</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcRequest</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1905122041950251207L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> requestId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> interfaceName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> methodName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameters<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> paramTypes<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">RpcMessageTypeEnum</span> rpcMessageTypeEnum<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列化号 <code>serialVersionUID</code> 属于版本控制的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。</p><blockquote><p><code>static</code> 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而，<code>serialVersionUID</code> 是一个特例，<code>serialVersionUID</code> 的序列化做了特殊处理。当一个对象被序列化时，<code>serialVersionUID</code> 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。</p></blockquote><p><strong>如果有些字段不想进行序列化怎么办？</strong></p><p>对于不想进行序列化的变量，可以使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：<strong>阻止实例中那些用此关键字修饰的的变量序列化</strong>；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，<strong>在反序列化后变量值将会被置成类型的默认值</strong>。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h3><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p><p>Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language * * @author shuang.kou * @createTime 2020年05月13日 19:29:00 */</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KryoSerializer</span> <span class="token keyword">implements</span> <span class="token class-name">Serializer</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Kryo</span><span class="token punctuation">&gt;</span></span> kryoThreadLocal <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">Kryo</span> kryo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Kryo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kryo<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">RpcResponse</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kryo<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> kryo<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ByteArrayOutputStream</span> byteArrayOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Output</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Output</span><span class="token punctuation">(</span>byteArrayOutputStream<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Kryo</span> kryo <span class="token operator">=</span> kryoThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Object-&gt;byte:将对象序列化为byte数组</span>            kryo<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>            kryoThreadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> output<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SerializeException</span><span class="token punctuation">(</span><span class="token string">"Serialization failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ByteArrayInputStream</span> byteArrayInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token class-name">Input</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Input</span><span class="token punctuation">(</span>byteArrayInputStream<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Kryo</span> kryo <span class="token operator">=</span> kryoThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// byte-&gt;Object:从byte数组中反序列化出对象</span>            <span class="token class-name">Object</span> o <span class="token operator">=</span> kryo<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>            kryoThreadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> clazz<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SerializeException</span><span class="token punctuation">(</span><span class="token string">"Deserialization failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据<strong>输入到计算机内存</strong>的过程即输入，反之<strong>输出到外部存储（比如数据库，文件，远程主机）</strong>的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">InputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Number of remaining bytes:"</span>            <span class="token operator">+</span> fis<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回输入流中可以读取的字节数。</span>    <span class="token keyword">int</span> content<span class="token punctuation">;</span>    <span class="token keyword">long</span> skip <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The actual number of bytes skipped:"</span> <span class="token operator">+</span> skip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The content read from file:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>content <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。</span>        <span class="token comment">// 如果未读取任何字节，则代码返回 -1 ，表示文件结束</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将ascii码转为读到的字符</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>输出：    <span class="token class-name">Number</span> of remaining bytes<span class="token operator">:</span><span class="token number">11</span><span class="token class-name">The</span> actual number of bytes skipped<span class="token operator">:</span><span class="token number">2</span><span class="token class-name">The</span> content read from file<span class="token operator">:</span><span class="token class-name">JavaGuide</span><span class="token comment">// 新建一个 BufferedInputStream 对象</span><span class="token class-name">BufferedInputStream</span> bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取文件的内容并复制到 String 对象中            读取输入流所有字节</span><span class="token class-name">String</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bufferedInputStream<span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileInputStream</span> fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//必须将fileInputStream作为构造参数才能使用</span><span class="token class-name">DataInputStream</span> dataInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span>fileInputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以读取任意具体的类型数据</span>dataInputStream<span class="token punctuation">.</span><span class="token function">readBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataInputStream<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataInputStream<span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ObjectInputStream 用于从输入流中读取 Java 对象（反序列化），ObjectOutputStream 用于将对象写入到输出流(序列化)。</span><span class="token class-name">ObjectInputStream</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"object.data"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">MyClass</span> object <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyClass</span><span class="token punctuation">)</span> input<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileOutputStream</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token string">"JavaGuide"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    output<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将数组写入到输出流，等价于 write(b, 0, b.length)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 字节缓冲输出流</span><span class="token class-name">FileOutputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span>fileOutputStream<span class="token punctuation">)</span><span class="token comment">// 输出流</span><span class="token class-name">FileOutputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">DataOutputStream</span> dataOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span>fileOutputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出任意数据类型</span>dataOutputStream<span class="token punctuation">.</span><span class="token function">writeBoolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataOutputStream<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 序列化，将对象写入到输出流</span><span class="token class-name">ObjectOutputStream</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Guide哥"</span><span class="token punctuation">,</span> <span class="token string">"JavaGuide作者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>output<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程比较耗时；</li><li><strong>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</strong></li><li>所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</li></ul><p>例如，如果你想从<code>InputStream</code>中读取字符，你需要考虑字符的编码方式。<strong>如果字符使用UTF-8编码，一个字符可能由一个或多个字节组成。因此，直接使用<code>InputStream</code>的<code>read()</code>方法可能无法完整地读取一个字符，因为它一次只读取一个字节。</strong></p><p>要正确地从<code>InputStream</code>中读取字符，你可以使用<code>Reader</code>类及其子类，如<code>InputStreamReader</code>。<code>Reader</code>是字符输入流，专门用于读取字符。<code>InputStreamReader</code>是一个桥接类，它可以将字节流转换为字符流，同时指定字符编码。</p><blockquote><p>1，ASCII码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。</p><p>2，UTF-8编码：一个英文字符等于一个字节，<strong>一个中文（含繁体）等于三个字节</strong>。中文标点占三个字节，英文标点占一个字节</p><p>3，Unicode编码：<strong>一个英文等于两个字节</strong>，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节</p><p>4，GBK：英文占 1 字节，中文占 2 字节。</p></blockquote><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 字节流转换为字符流的桥梁</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InputStreamReader</span> <span class="token keyword">extends</span> <span class="token class-name">Reader</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 用于读取字符文件</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileReader</span> <span class="token keyword">extends</span> <span class="token class-name">InputStreamReader</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileReader</span> fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> content<span class="token punctuation">;</span>    <span class="token keyword">long</span> skip <span class="token operator">=</span> fileReader<span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The actual number of bytes skipped:"</span> <span class="token operator">+</span> skip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The content read from file:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>content <span class="token operator">=</span> fileReader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 字符流转换为字节流的桥梁</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutputStreamWriter</span> <span class="token keyword">extends</span> <span class="token class-name">Writer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 用于写入字符到文件</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileWriter</span> <span class="token keyword">extends</span> <span class="token class-name">OutputStreamWriter</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Writer</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    output<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"你好，我是Guide。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>IO 操作是很消耗性能的，<strong>缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作</strong>，提高流的传输效率。</p><p>字节缓冲流这里采用了<strong>装饰器模式</strong>来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 新建一个 BufferedInputStream 对象</span><span class="token class-name">BufferedInputStream</span> bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，<strong>字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</strong></p><p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span><span class="token keyword">class</span> <span class="token class-name">BufferedInputStream</span> <span class="token keyword">extends</span> <span class="token class-name">FilterInputStream</span> <span class="token punctuation">{</span>    <span class="token comment">// 内部缓冲区数组</span>    <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token keyword">byte</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 缓冲区的默认大小</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_BUFFER_SIZE</span> <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">;</span>    <span class="token comment">// 使用默认的缓冲区大小</span>    <span class="token keyword">public</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> in<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> <span class="token constant">DEFAULT_BUFFER_SIZE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 自定义缓冲区大小</span>    <span class="token keyword">public</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> in<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Buffer size &lt;= 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字节缓冲输出流</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token string">"JavaGuide"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p><code>System.out</code> 实际是用于获取一个 <code>PrintStream</code> 对象，<code>print</code>方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。</p><p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p><h3 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h3><p>这里要介绍的随机访问流指的是<strong>支持随意跳转到文件的任意位置进行读写</strong>的 <code>RandomAccessFile</code> 。</p><p><code>RandomAccessFile</code> 的构造方法如下，我们可以指定 <code>mode</code>（读写模式）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span><span class="token keyword">public</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">,</span> <span class="token class-name">String</span> mode<span class="token punctuation">)</span>    <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 私有方法</span><span class="token keyword">private</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">,</span> <span class="token class-name">String</span> mode<span class="token punctuation">,</span> <span class="token keyword">boolean</span> openAndDelete<span class="token punctuation">)</span>  <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">{</span>  <span class="token comment">// 省略大部分代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">RandomAccessFile</span> randomAccessFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 内容ABCDEFG</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取之前的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">",当前读取到的字符"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，读取之后的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><span class="token comment">// 指针当前偏移量为 6</span>randomAccessFile<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取之前的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">",当前读取到的字符"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，读取之后的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7</span><span class="token comment">// 从偏移量 7 的位置开始往后写入字节数据</span>randomAccessFile<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'H'</span><span class="token punctuation">,</span> <span class="token char">'I'</span><span class="token punctuation">,</span> <span class="token char">'J'</span><span class="token punctuation">,</span> <span class="token char">'K'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 文件内容变为 ABCDEFGHIJK</span><span class="token comment">// 指针当前偏移量为 0，回到起始位置</span>randomAccessFile<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取之前的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">",当前读取到的字符"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，读取之后的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间。</p><p><strong>我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间</li></ol><p>Java 的 I/O 模型主要有三种：BIO（Blocking I/O，阻塞 I/O）、NIO（Non-blocking I/O，非阻塞 I/O）和 AIO（Asynchronous I/O，异步 I/O）。</p><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会<strong>一直阻塞，直到内核把数据拷贝到用户空间</strong>。</p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h2 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h2><p>Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 <strong>对于高负载、高并发的（网络）应用，应使用 NIO</strong> 。Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过<strong>轮询</strong>操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，<strong>等内核把数据准备好了，用户线程再发起 read 调用。</strong>read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。<strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><blockquote><p>NIO采用了多路复用器（Selector）来实现非阻塞 I/O。一个线程可以管理多个连接，当某个连接有数据可读或可写时，Selector 会通知线程进行相应的处理。</p></blockquote><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png" alt="Buffer、Channel和Selector三者之间的关系" style="zoom:50%;"><ul><li><strong>Channel（通道）</strong>：类似于传统 I/O 中的流，但 Channel 是双向的，可以同时进行读写操作。常见的 Channel 有 <code>FileChannel</code>、<code>SocketChannel</code>、<code>ServerSocketChannel</code> 等。</li><li><strong>Buffer（缓冲区）</strong>：用于存储数据，所有的数据都必须先读到 Buffer 中，或者从 Buffer 中写入。常见的 Buffer 有 <code>ByteBuffer</code>、<code>CharBuffer</code> 等。</li><li><strong>Selector（选择器）</strong>：用于监听多个 Channel 的事件（如连接、读、写等），当某个 Channel 有事件发生时，Selector 会将其选中。</li></ul><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是<strong>基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</strong></p><table><thead><tr><th>I/O 模型</th><th>阻塞特性</th><th>线程管理</th><th>适用场景</th></tr></thead><tbody><tr><td>BIO</td><td>阻塞直到处理完成</td><td>每个连接一个线程</td><td>连接数少且固定</td></tr><tr><td>NIO</td><td>非阻塞，selector监听多个channel</td><td>一个线程管理多个连接</td><td>连接数多且连接时间短</td></tr><tr><td>AIO</td><td>异步，通知回调</td><td>异步回调，无需线程等待</td><td>连接数多且连接时间长</td></tr></tbody></table><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法<strong>，这种语法对编程语言的功能并没有影响</strong>。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要<strong>先通过编译器进行解糖</strong>，也就是在程序<strong>编译阶段将其转换成 JVM 认识的基本语法</strong>。这也侧面说明，Java 中<strong>真正支持语法糖的是 Java 编译器</strong>而不是 JVM。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。</p><p>Java 中最常用的语法糖主要有<strong>泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式</strong>等。</p><p>增强for循环：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Student</span> stu <span class="token operator">:</span> students<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stu<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        students<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>会抛出<code>ConcurrentModificationException</code>异常。</p><p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个<strong>指向原来对象的单链索引表</strong>，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p><p>所以 <strong><code>Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。</strong>但你可以使用 <code>Iterator</code> 本身的方法<code>remove()</code>来删除对象，<code>**Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。**</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java 集合，也叫作<strong>容器</strong>，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。</p><img src="/2024/06/15/java/java-collection-hierarchy.png" alt="Java 集合框架概览" style="zoom:80%;"><ul><li><code>List</code>: 存储的元素是有序的、可重复的。</li><li><code>Set</code>: 存储的元素不可重复的。</li><li><code>Queue</code>: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h3><table><thead><tr><th>接口</th><th>集合类</th><th>底层数据结构</th><th>线程安全性</th><th>元素顺序</th><th>允许 null 值</th><th>查找效率</th><th>插入 / 删除效率</th><th>适用场景</th></tr></thead><tbody><tr><td><code>List</code></td><td><code>ArrayList</code></td><td>动态数组</td><td>否</td><td>有序（插入顺序）</td><td>允许</td><td>快，（通过索引）</td><td>尾部插入快；中间或头部插入慢，</td><td>需要频繁随机访问元素，插入 / 删除操作主要在尾部的场景</td></tr><tr><td></td><td><code>LinkedList</code></td><td>双向链表</td><td>否</td><td>有序（插入顺序）</td><td>允许</td><td>慢</td><td>头部、尾部插入删除快；中间插入删除需遍历</td><td>需要频繁在列表头部、尾部进行插入 / 删除操作的场景</td></tr><tr><td></td><td><code>Vector</code></td><td><strong>动态数组</strong></td><td><strong>是</strong></td><td>有序（插入顺序）</td><td>允许</td><td>快，（通过索引）</td><td>尾部插入快；中间或头部插入慢</td><td>线程安全，get、set、add 这些方法都加了 <code>synchronized</code> 关键字，执行效率比较低，所以现在已经很少用了</td></tr><tr><td></td><td><code>Stack</code></td><td><strong>动态数组</strong></td><td><strong>是</strong></td><td>有序，后进先出</td><td></td><td></td><td></td><td>Stack 执行效率比较低（方法上同样加了 synchronized 关键字）</td></tr><tr><td><code>Set</code></td><td><code>HashSet</code></td><td><code>HashMap</code>（键存储元素，值为固定对象）</td><td>否</td><td>无序</td><td>允许一个</td><td>快，平均</td><td>快，平均</td><td>需要存储不重复元素，不关心元素顺序的场景</td></tr><tr><td></td><td><code>LinkedHashSet</code></td><td>哈希表 + 双向链表</td><td>否</td><td>有序（插入顺序）</td><td>允许一个</td><td>快，平均</td><td>快，平均</td><td>需要存储不重复元素，且希望保持插入顺序的场景</td></tr><tr><td></td><td><code>TreeSet</code></td><td><strong>红黑树</strong></td><td>否</td><td>有序（自然顺序或指定比较器顺序）</td><td>不允许</td><td>中</td><td>中</td><td>需要存储不重复元素，且需要元素按自然顺序或自定义顺序排序的场景</td></tr><tr><td><code>Queue</code></td><td><code>ArrayDeque</code></td><td>循环数组</td><td>否</td><td>先进先出（FIFO）</td><td>不允许</td><td>-</td><td>头部、尾部插入删除快</td><td>作为栈或队列使用，需要高效的双端操作场景</td></tr><tr><td></td><td><code>PriorityQueue</code></td><td><strong>堆（二叉堆）</strong></td><td>否</td><td>按元素优先级排序</td><td>不允许</td><td>-</td><td>插入 ，删除头部元素快</td><td>需要根据元素优先级进行排序和处理的场景</td></tr><tr><td><code>Map</code></td><td><code>HashMap</code></td><td>哈希表（数组 + 链表 / 红黑树）</td><td>否</td><td>无序</td><td>键允许一个 null，值允许多个 null</td><td>快，平均</td><td>快，平均</td><td>存储键值对，不关心键的顺序，需要快速查找的场景</td></tr><tr><td></td><td><code>LinkedHashMap</code></td><td>哈希表 + 双向链表</td><td>否</td><td>有序（插入顺序或访问顺序）</td><td>键允许一个 null，值允许多个 null</td><td>快，平均</td><td>快，平均</td><td>存储键值对，需要保持键的插入顺序或访问顺序的场景</td></tr><tr><td></td><td><code>TreeMap</code></td><td><strong>红黑树</strong></td><td>否</td><td>有序（<strong>键的自然顺序或指定比较器顺序</strong>）</td><td>键不允许 null，值允许多个 null</td><td>中</td><td>中</td><td>存储键值对，需要键按自然顺序或自定义顺序排序的场景</td></tr><tr><td></td><td><code>Hashtable</code></td><td>哈希表</td><td>是</td><td>无序</td><td>键和值都不允许 null</td><td>快，平均</td><td>快，平均</td><td>需要线程安全且对性能要求不高的存储键值对场景</td></tr><tr><td></td><td><code>ConcurrentHashMap</code></td><td>分段锁（JDK 7）/ CAS + synchronized（JDK 8）</td><td>是</td><td>无序</td><td>键和值都不允许 null</td><td>快，平均</td><td>快，平均</td><td>高并发场景下存储键值对的场景</td></tr></tbody></table><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><code>ArrayList</code> 的底层是<strong>数组队列</strong>，相当于<strong>动态数组</strong>。与 Java 中的数组相比，它的<strong>容量能动态增长</strong>。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以<strong>减少递增式再分配的数量</strong>。</p><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>List</code> : 表明它是一个列表，支持<strong>添加、删除、查找</strong>等操作，并且可以<strong>通过下标进行访问</strong>。</p></li><li><p><code>RandomAccess</code> ：这是一个<strong>标志接口</strong>，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p></li><li><p><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</p></li><li><p><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</p></li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>JDK1.8</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 默认初始容量为10</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_CAPACITY</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">// 若初始化时传入参数new ArrayList(0)，则创建空数组EMPTY_ELEMENTDATA</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 用于默认大小空实例的共享空数组实例。即无参构造函数，初始为空数组，添加第一个元素时容量变为DEFAULT_CAPACITY = 10</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 实际保存arraylist数据的数组</span><span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment">// arraylist包含元素的个数</span><span class="token comment">// 有参构造函数如下。无参函数 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//如果传入的参数等于0，创建空数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//其他情况，抛出异常</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span> <span class="token operator">+</span>                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p><code>ensureCapacity</code> 这个方法 <code>ArrayList</code> 内部没有被调用过，是给用户调用的。</p><p>理论上来说，最好在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p><p>public void ensureCapacity(int minCapacity)</p><ul><li>函数内部判断elementdata数据数组是否是DEFAULTCAPACITY_EMPTY_ELEMENTDATA，如果是的话赋值minExpand=10，表示已有的最大容量是10，否则为0，表示在初始化传参的情况下，动态数组可以扩容为任意大小。</li><li>若minCapacity &gt; minExpand，调用<strong>ensureExplicitCapacity(minCapacity);</strong> 以保证最小需求容量能够达到。</li><li>在ensureExplicitCapacity(minCapacity)内，<strong>若minCapacity&gt;当前elementdata元素数组的大小，则调用grow(minCapacity)方法进行扩容。</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/***  扩容：新容量扩大为Max(minCapacity, 1.5倍oldCapacity)，若超出了预定义的最大array大小，则一次性扩容为MAX_VALUE*/</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// oldCapacity为旧容量，newCapacity为新容量</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>    <span class="token comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span>    <span class="token comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>    <span class="token comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入删除时用到的扩容判断函数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 确保内部容量达到指定的最小容量。</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 否则直接返回最小容量</span>    <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="插入删除"><a href="#插入删除" class="headerlink" title="插入删除"></a>插入删除</h5><p>对于插入：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要<strong>扩容时，则需要执行一次 O(n) 的操作</strong>将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 尾部插入</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>    <span class="token comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 指定位置插入先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><span class="token comment">// 在容量判断方法内，若容量不足会进行扩容。若数组为空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，在第一次插入时扩容到10</span><span class="token comment">// 否则传入ensureExplicitCapacity的扩容参数是size+1，即当前数组大小+1。而在执行时实际newCapacity是原始1.5倍</span><span class="token comment">// 将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>    <span class="token comment">// arraycopy(Object src源数组, int srcPos起始位置, Object dest目标, int destPos目标位置, int length复制长度)</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                     size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于删除：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。</li></ul><h5 id="机制总结"><a href="#机制总结" class="headerlink" title="机制总结"></a>机制总结</h5><p>初始化时，默认无参构造函数给<code>elementData</code>（保存ArrayList数据的数组）赋值<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA={}</code>，也就是一个默认大小0的空实例。在第一次添加数据的时候才会真正分配容量<code>DEFAULT_CAPACITY = 10</code>。此后添加第2，3，，，一直到10个元素，<code>minCapacity - elementData.length &gt; 0</code>都不成立，也就是现有的Object数组的长度都大于需要的最小数组长度，所以不会扩容。到第11个元素时，进入<code>grow</code>方法扩容，新的容量<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>也就是原始大小的1.5倍。</p><p>此外，外部方法<code> ensureCapacity</code>可以供调用者手动传入<code> minCapacity</code>，这个值会在<code>grow</code>方法中与<code>newCapacity</code>比较， 如果1.5倍的<code>old </code>仍然小于需要的<code>minCapacity</code>，则更新<code>newCapacity</code>为<code>minCapacity</code>。</p><p>如果新容量大于 <code>MAX_ARRAY_SIZE</code>,进入(执行) <code>hugeCapacity()</code> 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p><h4 id="LinkeadList"><a href="#LinkeadList" class="headerlink" title="LinkeadList"></a>LinkeadList</h4><p><code>LinkedList</code> 是一个基于<strong>双向链表</strong>实现的集合类，经常被拿来和 <code>ArrayList</code> 做比较。</p><img src="/2024/06/15/java/bidirectional-linkedlist.png" alt="双向链表" style="zoom:80%;"><p>不过，我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好。</p><p><strong>LinkedList 为什么不能实现 RandomAccess 接口？</strong></p><p><code>RandomAccess</code> 是一个<strong>标记</strong>接口，用来表明<strong>实现该接口的类支持随机访问</strong>（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，<strong>内存地址不连续，只能通过指针来定位，不支持随机快速访问</strong>，所以不能实现 <code>RandomAccess</code> 接口。</p><p><code>LinkedList</code> 的类定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>  <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</p><p>阅读过 <code>ArrayList</code> 的源码我们就知道，<code>ArrayList</code> 同样继承了 <code>AbstractList</code> ， 所以 <code>LinkedList</code> 会有大部分方法和 <code>ArrayList</code> 相似。</p><p><code>LinkedList</code> 实现了以下接口：</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有<strong>双端队列</strong>的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li></ul><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p><code>LinkedList</code> 中的元素是通过 <code>Node</code> 定义的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">E</span> item<span class="token punctuation">;</span><span class="token comment">// 节点值</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span> <span class="token comment">// 指向的下一个节点（后继节点）</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span> <span class="token comment">// 指向的前一个节点（前驱结点）</span>    <span class="token comment">// 初始化参数顺序分别是：前驱结点、本身节点值、后继节点</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LinkedList</code> 中有一个无参构造函数和一个有参构造函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建一个空的链表对象</span><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="插入删除-1"><a href="#插入删除-1" class="headerlink" title="插入删除"></a>插入删除</h5><ul><li><code>add(E e)</code>：尾部插入，复杂度O(1)。调用<code>linkLast(E e)</code>方法。维护last引用为最后一个节点，创建新节点，新节点prev为last，next为null。如果是第一个节点，还要将其赋值给first。如果不是，则让原始的last的next指向新节点。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 将元素节点插入到链表尾部</span><span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 将最后一个元素赋值（引用传递）给节点 l</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>    <span class="token comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 last 引用指向新节点</span>    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token comment">// 判断尾节点是否为空</span>    <span class="token comment">// 如果 l 是null 意味着这是第一次添加元素</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token comment">// 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next</span>        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>add(int index, E element)</code>：指定位置插入，需要移动平均 n/4 个元素，时间复杂度为 O(n)。调用<code>linkBefore(element, node(index))</code>，先移动指针，再修改指针</p><ul><li>先判断index是否是尾部，如果是则调用linkLast进行尾部插入（尾部插入要更新last指针，所以单独处理</li><li><strong>node（int index）函数会遍历找到要插入位置的元素。根据index位置从前往后或从尾向前找。</strong></li><li>linkBefore中将定位到的node的prev指向新节点，新节点prev指向node的prev，next指向node。如果node之前的前驱为空，则插入的新节点为第一个节点，赋值first，否则node的前驱的后继指向新节点。</li></ul></li></ul><p>删除：</p><ul><li><code>removeFirst()</code>：删除并返回链表的第一个元素。内部调用unlinkFirst(first)方法：取出头节点用于返回。头节点item及next置空，帮助GC回收。first引用更新为next元素，如果next是空需要把last更新为null；否则将next的prev置null。</li><li><code>removeLast()</code>：删除并返回链表的最后一个元素。内部调用unlinkLast(last)方法：取出尾节点。尾节点item及prev置空，上一个节点赋值last，如果上一个节点为null说明原来只有last一个元素，设置first为null；否则让上一节点的next更新为null。</li></ul><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">private E unlinkLast(Node&lt;E&gt; l) {    // assert l == last &amp;&amp; l != null;    final E element = l.item;    final Node&lt;E&gt; prev = l.prev;    l.item = null;    l.prev = null; // help GC    last = prev;    if (prev == null)        first = null;    else        prev.next = null;    size--;    modCount++;    return element;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。通过遍历链表来找要删除的元素位置，然后调用unlink(node)方法。</li><li><code>remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。先检查下标是否越界，然后调用unlink(node(idx))。<ul><li>node(idx)是通过下标找到元素并返回Node元素。unlink(node)方法删除对应元素。</li></ul></li><li><code>void clear()</code>：移除此链表中的所有元素。</li></ul><h5 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h5><p>在定位第idx个元素时，调用node(index)方法，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。</p><p><code>unlink(x)</code> 方法的逻辑如下：</p><ol><li>首先获取待删除节点 x 的前驱和后继节点；</li><li>判断待删除节点是否为头节点或尾节点： <ul><li>如果 x 是头节点（x的prev为null），则直接将 first 指向 x 的后继节点 next</li><li>如果 x 是尾节点（x的next为null），则将 last 指向 x 的前驱节点 prev</li><li>如果 x 不是头节点也不是尾节点，执行345断开链接并清除元素</li></ul></li><li>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</li><li>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</li><li>将待删除节点 x 的元素置空（方便GC回收），修改链表长度。</li></ol><h4 id="ArrayList-vs-LinkedList"><a href="#ArrayList-vs-LinkedList" class="headerlink" title="ArrayList vs LinkedList"></a>ArrayList vs LinkedList</h4><ul><li><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是<strong>不同步的</strong>，也就是<strong>不保证线程安全；</strong></p><ul><li>当多个线程同时对ArrayList进行修改操作时，可能会导致数据不一致或者出现异常。这是因为ArrayList的内部结构不是线程安全的，它<strong>没有提供对并发修改的支持</strong>。例如，当一个线程正在向ArrayList中添加元素，而另一个线程同时在删除元素，就有可能导致<strong>索引越界或者元素丢失</strong>的问题。</li><li>推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</li></ul></li><li><p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）</p></li><li><p><strong>插入和删除是否受元素位置的影响：</strong></p><ul><li><code>ArrayList</code> 采用<strong>数组</strong>存储，所以插入和删除元素的时间复杂度<strong>受元素位置的影响</strong>。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li><code>LinkedList</code> 采用<strong>链表</strong>存储，所以在头尾插入或者删除元素<strong>不受元素位置的影响</strong>（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要<strong>先移动到指定位置</strong>再插入和删除。</li><li>总结：ArrayList查询O(1)，开头或指定位置插入删除O(n)。LinkedList查询O(n)，插入删除自身操作O(1)，所以在中间特定位置插入删除整体O(n)</li></ul></li><li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><ul><li>LinkedList是双向链表，不能根据下标直接取元素；ArrayList是动态数组，所以支持快速随机访问。</li></ul></li><li><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 <strong>list 列表的结尾会预留一定的容量空间</strong>，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为<strong>要存放直接后继和直接前驱</strong>以及数据）。</p></li></ul><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>在 JDK1.5 之前，如果想要使用<strong>并发安全</strong>的 <code>List</code> 只能选择 <code>Vector</code>。而 <code>Vector</code> 是一种老旧的集合，已经被淘汰。<code>Vector</code> 对于增删改查等方法基本都加了 <strong><code>synchronized</code><strong>，这种方式虽然能够保证同步，但这相当于对整个 <code>Vector</code> 加上了一把大锁，使得</strong>每个方法执行的时候都要去获得锁，导致性能非常低下</strong>。</p><p>JDK1.5 引入了 <code>Java.util.concurrent</code>（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 <code>List</code> 实现就是 <code>CopyOnWriteArrayList</code> 。</p><blockquote><p>对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该<strong>允许多个线程同时访问 <code>List</code> 的内部数据</strong>，毕竟对于读取操作来说是安全的。</p></blockquote><p>为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的<strong>读取操作是完全无需加锁的</strong>。<strong>写入操作也不会阻塞读取操作</strong>，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。</p><p><code>CopyOnWriteArrayList</code>名字中的“Copy-On-Write”即<strong>写时复制</strong>，简称 COW，是线程安全的核心。</p><blockquote><p>写入时复制（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同<strong>获取相同的指针指向相同的资源</strong>，直到某个调用者试图<strong>修改资源</strong>的内容时，<strong>系统才会真正复制一份专用副本（private copy）给该调用者</strong>，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p></blockquote><p>当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，不会直接修改原数组，而是会<strong>先创建底层数组的副本，对副本数组进行修改</strong>，修改完之后再将修改后的数组赋值给底层数组的引用，替换掉旧的数组，这样就可以保证写操作不会影响读操作了。写时复制机制非常<strong>适合读多写少</strong>的并发场景，能够极大地提高系统的并发性能。</p><p><strong>缺点：</strong></p><ul><li>内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。</li><li>写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以<strong>写操作的开销相对较大</strong>，在写入比较频繁的场景下，性能可能会受到影响。</li><li>数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。</li></ul><h5 id="核心机制-1"><a href="#核心机制-1" class="headerlink" title="核心机制"></a>核心机制</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token keyword">extends</span> <span class="token class-name">Object</span><span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span><span class="token punctuation">{</span>  <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现list，randomaccess，cloneable，serializable，和arraylist一样</p><p><code>CopyOnWriteArrayList</code> 的 <code>add()</code>方法有三个版本：</p><ul><li><code>add(E e)</code>：在 <code>CopyOnWriteArrayList</code> 的尾部插入元素。</li><li><code>add(int index, E element)</code>：在 <code>CopyOnWriteArrayList</code> 的指定位置插入元素。</li><li><code>addIfAbsent(E e)</code>：如果指定元素不存在，那么添加该元素。如果成功添加元素则返回 true。</li></ul><p>这里以<code>add(E e)</code>为例进行介绍：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    <span class="token comment">// 加锁</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取原来的数组</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 原来数组的长度</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 元素放在新数组末尾</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token comment">// array指向新数组</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment">// 解锁</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>add</code>方法内部用到了 <code>ReentrantLock</code> 加锁，保证了同步，<strong>避免了多线程写的时候会复制出多个副本出来。</strong>锁被<code>final</code>修饰保证了<strong>锁的内存地址肯定不会被修改</strong>，并且，释放锁的逻辑放在 <code>finally</code> 中，可以保证锁能被释放。</li><li>每次写操作都需要通过 <code>Arrays.copyOf</code> 复制底层数组，<strong>时间复杂度是 O(n) 的</strong>，且会占用额外的内存空间。因此，<code>CopyOnWriteArrayList</code> 适用于读多写少的场景，在写操作不频繁且内存资源充足的情况下，可以提升系统的性能表现。</li></ul><ul><li><code>CopyOnWriteArrayList</code> 中并没有类似于 <code>ArrayList</code> 的 <code>grow()</code> 方法扩容的操作。</li></ul><p><strong>读取元素</strong>：<code>CopyOnWriteArrayList</code> 的读取操作是基于内部数组 <code>array</code> 并没有发生实际的修改，因此在读取操作时不需要进行同步控制和锁操作，可以保证数据的安全性。这种机制下，多个线程可以同时读取列表中的元素。不过，<code>get</code>方法是弱一致性的，<strong>在某些情况下可能读到旧的元素值。</strong>（比如，线程1读数据，线程2写数据，线程1取值，此时取值就是旧的值）</p><p>删除元素：</p><p><code>CopyOnWriteArrayList</code>删除元素相关的方法一共有 4 个：</p><ol><li><code>remove(int index)</code>：移除此列表中指定位置上的元素。将任何后续元素向左移动（从它们的索引中减去 1）。</li><li><code>boolean remove(Object o)</code>：删除此列表中首次出现的指定元素，如果不存在该元素则返回 false。</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>：从此列表中删除指定集合中包含的所有元素。</li><li><code>void clear()</code>：移除此列表中的所有元素。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取可重入锁</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    <span class="token comment">// 加锁</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取当前array数组</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取当前array长度</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//获取指定索引的元素(旧值)</span>        <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> len <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 判断删除的是否是最后一个元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token comment">// 如果删除的是最后一个元素，直接复制该元素前的所有元素到新的数组</span>            <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 分段复制，将index前的元素和index+1后的元素复制到新数组</span>            <span class="token comment">// 新数组长度为旧数组长度-1</span>            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 将新数组赋值给array引用</span>            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>         <span class="token comment">// 解锁</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ArrayList-vs-Array"><a href="#ArrayList-vs-Array" class="headerlink" title="ArrayList vs Array"></a>ArrayList vs Array</h4><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><strong>无序性和不可重复性：</strong></p><ul><li>无序性不等于随机性 ，无序性是指<strong>存储的数据在底层数组中</strong>并非按照数组索引的顺序添加 ，而是根<strong>据数据的哈希值决定</strong>的。<ul><li>所以HashSet/HashMap是无序的，而LinkedHashSet通过链表维护了插入和取出的顺序，是有序的</li></ul></li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><code>HashSet</code> 内部使用一个 <code>HashMap</code> 来存储元素。<code>HashSet</code> 中的元素被存储为 <code>HashMap</code> 的键，而 <code>HashMap</code> 的值则统一使用一个静态的 <code>PRESENT</code> 对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// HashMap用于存储操作，HashSet底层封装类对象</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span><span class="token comment">// HashSet是将元素存放在HashMap的key中，因此使用一个静态常量来充当HashMap的value值</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回集合中是否包含指定元素o</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 添加指定元素e</span><span class="token comment">// 将e作为HashMap的key 常量PRESENT作为所有元素的value</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 移出指定元素o</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token operator">==</span><span class="token constant">PRESENT</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="HashSet、LinkedHashSet-vs-TreeSet"><a href="#HashSet、LinkedHashSet-vs-TreeSet" class="headerlink" title="HashSet、LinkedHashSet vs TreeSet"></a>HashSet、LinkedHashSet vs TreeSet</h4><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，<strong>都能保证元素唯一</strong>，并且<strong>都不是线程安全的。</strong><ul><li>不安全的原因是因为HashMap不是线程安全的。在HashSet中，底层源码，其实就是一个HashMap，HashMap的key为HashSet中的值，而value为一个Object对象常量。</li></ul></li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，<strong>元素的插入和取出顺序满足 FIFO</strong>。<code>TreeSet</code> 底层数据结构是<strong>红黑树</strong>，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于<strong>不需要保证元素插入和取出顺序的场景</strong>，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><p><strong>HashSet如何检查重复</strong></p><blockquote><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p></blockquote><p>在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Returns: true if this set did not already contain the specified element</span><span class="token comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><p><code>ArrayDeque</code> 允许在队列的两端（头部和尾部）进行快速的插入、删除和访问操作，底层数据结构为<strong>循环数组</strong>。既可以当作栈使用（后进先出，LIFO），也可以当作队列使用（先进先出，FIFO）。它不允许存储 <code>null</code> 元素，并且线程不安全，在单线程环境下使用。</p><p>当需要使用栈时，Java 已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>（双端队列），因为Stack的核心方法上都加了 <code>synchronized</code> 关键字以确保线程安全，当我们不需要线程安全（比如说单线程环境下）性能就会比较差。</p><p>ArrayDeque 又实现了 Deque 接口（Deque 又实现了 Queue 接口），因此，当我们需要使用队列的时候，也可以选择 ArrayDeque。</p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/arraydeque-1e7086a3-3d31-4553-aa16-5eaf2193649e.png" alt="img" style="zoom:67%;"><p><strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于 0，<code>tail</code>也不一定总是比<code>head</code>大。</p><ul><li><strong>插入和删除操作</strong>：在队列的头部和尾部进行插入和删除操作的时间复杂度都是 O(1)，因为只需要移动指针，不需要像链表那样修改节点的引用。</li><li><strong>随机访问操作</strong>：支持随机访问，通过索引可以直接访问数组中的元素，时间复杂度为 。</li><li><strong>扩容操作</strong>：当队列中的元素数量达到数组容量时，会触发扩容操作，新容量是原容量的两倍。扩容操作需要创建新数组并复制元素，会带来一定的性能开销，但平均情况下插入和删除操作的性能仍然较好。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//不允许放入null</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    elements<span class="token punctuation">[</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//2.下标是否越界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span><span class="token comment">//1.空间是否够用</span>        <span class="token function">doubleCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//扩容</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doubleCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> head <span class="token operator">==</span> tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> n <span class="token operator">-</span> p<span class="token punctuation">;</span> <span class="token comment">// head右边元素的个数</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//原空间的2倍</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Sorry, deque too big"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> p<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复制右半部分，对应上图中绿色部分</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> r<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复制左半部分，对应上图中灰色部分</span>    elements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    tail <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以<strong>插入元素的时候不用考虑空间问题。</strong></p><p>下标越界处理：<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。</p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/arraydeque-f1386b63-10be-4998-bb6d-bf6560cca7ee.png" alt="img" style="zoom:50%;"><h4 id="ArrayDeque-与-LinkedList"><a href="#ArrayDeque-与-LinkedList" class="headerlink" title="ArrayDeque 与 LinkedList"></a>ArrayDeque 与 LinkedList</h4><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于<strong>可变长的数组和双指针</strong>来实现，而 <code>LinkedList</code> 则通过<strong>双向链表</strong>来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，<strong>但 <code>LinkedList</code> 支持。</strong></li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过**均摊后的插入操作依然为 O(1)**。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li><li>从性能的角度上，<strong>选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。</strong>此外，<code>ArrayDeque</code> 也可以用于实现栈。</li><li><code>ArrayDeque</code> 和 <code>LinkedList</code> 都不是线程安全的。如果在多线程环境下使用，需要进行额外的同步操作，或者使用线程安全的替代类，如 <code>ConcurrentLinkedDeque</code>。</li></ul><h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><p>因为ArrayDeque 的底层实现是数组，而 LinkedList 的底层实现是链表。<strong>数组是一段连续的内存空间</strong>，而链表是由多个节点组成的，每个节点存储数据和指向下一个节点的指针。因此，<strong>在使用 LinkedList 时，需要频繁进行内存分配和释放</strong>，而 ArrayDeque 在创建时就一次性分配了连续的内存空间，不需要频繁进行内存分配和释放，这样可以更好地利用 CPU 缓存，提高访问效率。</p><p>现代计算机CPU对于<strong>数据的局部性</strong>有很强的依赖，如果需要访问的数据在内存中是连续存储的，那么就可以利用CPU的缓存机制，提高访问效率。而当数据存储在不同的内存块里时，每次访问都需要从内存中读取，效率会受到影响。</p><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于<strong>元素出队顺序是与优先级相关的</strong>，即总是<strong>优先级最高的元素先出队</strong>。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了<strong>二叉堆</strong>的数据结构来实现的，底层使用<strong>可变长的数组</strong>来存储数据。<ul><li>小顶堆是一个<strong>完全二叉树</strong>，任何一个非叶子节点的权值，都不大于其左右子节点的权值。</li><li>完全二叉树：除了最后一层，其他层的节点数都是满的，最后一层的节点都靠左对齐。</li><li>完全二叉树的结构比较规则，可以使用数组存储。对于数组中索引为 <code>i</code> 的元素，其左子节点的索引为 <code>2 * i + 1</code>，右子节点的索引为 <code>2 * i + 2</code>，父节点的索引为 <code>(i - 1) / 2</code>。</li></ul></li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 <strong>O(logn)</strong> 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是<strong>非线程安全</strong>的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><pre class="line-numbers language-none"><code class="language-none">     10                ------  0     /  \   20    15             ------ 1和2 = 2i+1和2i+2  /  \30   40                 ------ 3和4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 存储元素的数组</span><span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> queue<span class="token punctuation">;</span><span class="token comment">// 队列中元素的数量</span><span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 比较器，用于定义元素的排序规则</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">;</span><span class="token comment">// 修改次数，用于快速失败机制</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">// 不允许放入null元素</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 自动扩容</span>    size <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 队列原来为空，这是插入的第一个元素</span>        queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">siftUp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调整，维持堆的性质</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 将元素x插入到位置k，上浮操作维护堆的性质</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">// 如果指定了比较器，则使用带有比较器的上浮方法</span>        <span class="token function">siftUpUsingComparator</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> queue<span class="token punctuation">,</span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token comment">// 否则，使用基于元素自然顺序的上浮方法</span>        <span class="token function">siftUpComparable</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">siftUpComparable</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">T</span> x<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> es<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 将元素 x 转换为 Comparable 类型，以便进行比较</span>    <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 从插入位置 k 开始，不断向上比较并交换，直到满足堆的性质</span>        <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// parentNo = (nodeNo-1)/2</span>        <span class="token class-name">Object</span> e <span class="token operator">=</span> es<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 如果插入元素 x 大于或等于父节点的值，说明已经找到了合适的位置（满足小顶堆），停止上浮</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        es<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">// 否则，将父节点的值下移到当前位置 k（满足x作为根，比原父节点e及其子节点小）</span>        k <span class="token operator">=</span> parent<span class="token punctuation">;</span> <span class="token comment">// 更新当前位置 k 为父节点的位置，继续向上比较</span>    <span class="token punctuation">}</span>    es<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">siftUpUsingComparator</span><span class="token punctuation">(</span>    <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">T</span> x<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> es<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> cmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> e <span class="token operator">=</span> es<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 使用指定的比较器比较插入元素 x 和父节点的值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        es<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        k <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    es<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>将元素x插入到位置k，实际使用时poll弹出堆顶权值最小的元素，然后siftDown(0,  queue最后一个元素x)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> half <span class="token operator">=</span> size <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> half<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span>        <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//leftNo = parentNo*2+1</span>        <span class="token class-name">Object</span> c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span>            comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child <span class="token operator">=</span> right<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// x已经比孩子节点小了</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token comment">//然后用c取代原来的值</span>        k <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理如果是remove(object o)：</p><ol><li>删除的是最后一个元素。直接删除即可，不需要调整。</li><li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。</li></ol><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/PriorityQueue-e25ba931-2e6f-4c17-84b8-9b959733d541.png" alt="PriorityQueue_poll.png" style="zoom:50%;"><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><code>BlockingQueue</code> （阻塞队列）是一个<strong>接口</strong>，继承自 <code>Queue</code>。<code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><p><strong>实现类：</strong></p><p>Java 中常用的阻塞队列实现类有以下几种：</p><ol><li><code>ArrayBlockingQueue</code>：使用<strong>数组</strong>实现的有界阻塞队列。<strong>在创建时需要指定容量大小</strong>，并支持公平和非公平两种方式的锁访问机制。</li><li><code>LinkedBlockingQueue</code>：使用<strong>单向链表</strong>实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code>Integer.MAX_VALUE</code>。和<code>ArrayBlockingQueue</code>不同的是， 它仅支持<strong>非公平</strong>的锁访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的<strong>无界</strong>阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</li><li><code>SynchronousQueue</code>：<strong>同步队列</strong>，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：<strong>延迟队列</strong>，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li></ol><h4 id="ArrayBlockingQueue-和-LinkedBlockingQueue"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue"></a>ArrayBlockingQueue 和 LinkedBlockingQueue</h4><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 是 Java 并发包中常用的两种阻塞队列实现，它们都是<strong>线程安全</strong>的。它们之间存在下面这些区别：</p><ul><li><strong>底层实现</strong>：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li><li><strong>是否有界</strong>：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也<strong>可以指定</strong>队列大小，从而成为有界的。</li><li><strong>锁是否分离</strong>： <code>ArrayBlockingQueue</code>中的锁是没有分离的，即<strong>生产和消费用的是同一个锁</strong>；<code>LinkedBlockingQueue</code>中的锁是分离的，即**生产用的是<code>putLock</code>，消费是<code>takeLock</code>**，这样可以防止生产者和消费者线程之间的锁争夺。</li><li><strong>内存占用</strong>：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。这意味着，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是<strong>非线程安全</strong>的。</p><p><strong>JDK1.8 之前</strong></p><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 <strong>hash 值以及 key</strong> 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><p><strong>JDK1.8 之后</strong></p><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64，那么会选择先进行数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><img src="/2024/06/15/java/jdk1.8_hashmap.png" alt="jdk1.8之后的内部结构-HashMap" style="zoom:80%;"><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><p><strong><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token comment">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">362498820763181265L</span><span class="token punctuation">;</span>    <span class="token comment">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">// 最大容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token comment">// 默认的负载因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment">// 桶中结构转化为红黑树对应的table的最小容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment">// =====存储元素的数组，总是2的幂次倍=====</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token comment">// 一个包含了映射中所有键值对的集合视图</span>    <span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entrySet<span class="token punctuation">;</span>    <span class="token comment">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment">// 负载因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Node节点类，继承自 Map.Entry&lt;K,V&gt;</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span><span class="token comment">//键</span>       <span class="token class-name">V</span> value<span class="token punctuation">;</span><span class="token comment">//值</span>       <span class="token comment">// 指向下一个节点-&gt;链式结构</span>       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>       <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 树节点类 -- 红黑树</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">;</span>  <span class="token comment">// 父</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> left<span class="token punctuation">;</span>    <span class="token comment">// 左</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> right<span class="token punctuation">;</span>   <span class="token comment">// 右</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span>    <span class="token comment">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>           <span class="token comment">// 判断颜色</span>        <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> val<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 返回根节点</span>        <span class="token keyword">final</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>loadFactor 负载因子</strong><ul><li>loadFactor 负载因子是控制<strong>数组存放数据的疏密程度</strong>，loadFactor 越趋近于 1，那么 数组中能存放的数据(entry)也就越多（要达到临界值<strong>threshold = capacity * loadFactor</strong>的时候才会扩容），也就越密，也就是会让链表的长度增加（因为要很久才扩容，这段数组本身很密，冲突的数据也多，链表就长），loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</li><li><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</li><li>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li></ul></li></ul><h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><p>构造方法都初始化了负载因子 loadFactor，由于 HashMap 中没有 capacity 这样的字段，即使指定了初始化容量 initialCapacity ，也只是通过 tableSizeFor 将其<strong>扩容到与 initialCapacity 最接近的 2 的幂次方大小</strong>，然后暂时赋值给 threshold ，后续通过 resize 方法将 threshold 赋值给 newCap 进行 table 的初始化。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 默认构造函数。</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span> <span class="token comment">// all   other fields defaulted</span><span class="token punctuation">}</span><span class="token comment">// 包含另一个“Map”的构造函数</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span>    <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//下面会分析到这个方法</span><span class="token punctuation">}</span><span class="token comment">// 指定“容量大小”的构造函数</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 指定“容量大小”和“负载因子”的构造函数</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>        initialCapacity <span class="token operator">=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment">// 初始容量暂时存放到 threshold ，在resize函数中再赋值给 newCap 进行table初始化</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>putMapEntries 方法：</strong></p><p>final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</p><ul><li>先判断table是否已经初始化，如果没有，计算承载传入的m所有元素需要的最小容量 <code>ft = m的长度s / loadFactor + 1</code></li><li>如果计算出来的容量t大于初始化阈值容量threshold，执行tableSizeFor(t)，将阈值更新为邻近的2的幂次</li><li>如果table已经初始化，并且元素个人大于初始阈值，进行扩容</li><li>容量更新后，将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容</li></ul><h5 id="核心机制-2"><a href="#核心机制-2" class="headerlink" title="核心机制"></a>核心机制</h5><p>put方法插入元素：</p><ul><li><p>如果定位到的数组位置没有元素 就直接插入，对应<code>tab[i] = new Node(hash, key, value, null)</code>。</p></li><li><p>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖（将 数组位置元素p赋值给插入节点e）。</p></li><li><p>如果 key 不相同，遍历树/链表找插入位置：判断 桶内第一个元素p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>找到元素添加位置；如果不是就遍历链表插入（尾插法）</p></li></ul><p>只要数组铀元素，就是进行了hash冲突处理。通过判断首节点，或遍历树（链表），要插入的位置为e。e不为空就说明在现有元素中找到了key和hash相等的节点，此时直接将新值赋值给旧节点，返回旧值。e为空则为插入新节点，返回null表示没有旧值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token comment">// 对应桶的第一个节点赋值给p</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 桶中已经存在元素（处理hash冲突）</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>        <span class="token comment">// 快速判断第一个节点table[i]的key是否与插入的key一样</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">// 判断插入的是否是红黑树节点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 不是红黑树节点则说明为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span>                    <span class="token comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span>                    <span class="token comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 记录e的value</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="resize扩容"><a href="#resize扩容" class="headerlink" title="resize扩容"></a>resize扩容</h5><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><p><code>resize()</code> 方法的主要作用是调整 <code>HashMap</code> 的容量，具体包括以下几个方面：</p><ol><li><strong>扩容</strong>：将哈希表的容量扩大为原来的两倍。</li><li><strong>重新哈希</strong>：将原哈希表中的所有键值对重新计算哈希值，并放入新的哈希表中。</li><li><strong>更新阈值</strong>：根据新的容量更新阈值 <code>threshold</code>。</li></ol><p>过程：</p><p><strong>计算新容量和新阈值</strong></p><ul><li><p>如果旧容量已经达到最大容量（2^30），则无法再扩容，通过链表或红黑树添加元素。如果没超过最大值，新容量和新阈值扩充为原来的2倍。</p></li><li><p>如果旧容量为 0，但旧阈值大于 0，说明是通过构造函数指定了初始容量。此时新容量=设置的旧阈值。</p></li><li><p>如果旧容量和旧阈值都为 0，说明是使用默认构造函数创建的 HashMap。此时新容量=DEFAULT_INITIAL_CAPACITY;新阈值=(int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 阈值=Integer.MAX_VALUE,返回oldTab</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">&gt;=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>        newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 初始化容量</span><span class="token punctuation">}</span> <span class="token keyword">else</span>  <span class="token punctuation">{</span>    <span class="token comment">// 无参构造函数初始化容量</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 根据新容量和负载因子计算新阈值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建新的哈希表数组</strong>：根据新容量创建一个新的哈希表数组，并将其赋值给 <code>table</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 创建新的哈希表数组</span>table <span class="token operator">=</span> newTab<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 迁移元素</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>迁移元素</strong></p><ul><li>遍历旧的哈希表数组，对于每个位置的元素：<ul><li>如果该位置只有一个元素，直接重新计算哈希值并放入新表。</li><li>如果是树节点，调用树的拆分方法。<code>split()</code> 方法会根据元素在新哈希表中的位置将树拆分为两个部分，可能会将部分节点转换为链表，也可能会继续保持树结构。</li><li>如果是链表节点，将链表拆分为两个链表：<strong>一个链表中的元素在新表中的位置不变，另一个链表中的元素在新表中的位置为原位置加上旧容量。</strong>然后将这两个链表分别放入新表的相应位置。</li></ul></li></ul><blockquote><p>在 <code>HashMap</code> 中，<strong>元素存储位置的索引是通过 <code>hash &amp; (capacity - 1)</code> 计算得到的，</strong>其中 <code>hash</code> 是键的哈希值，<code>capacity</code> 是哈希表的容量。<strong>这种计算方式等价于对 <code>capacity</code> 取模运算</strong>，但由于位运算的效率更高，所以采用了按位与运算。</p><ul><li>例如，当 <code>capacity = 4</code> 时，<code>capacity - 1 = 3</code>，二进制表示为 <code>0011</code>。假设某个元素的哈希值 <code>hash = 5</code>，二进制表示为 <code>0101</code>，则 <code>hash &amp; (capacity - 1) = 0101 &amp; 0011 = 0001</code>，所以该元素在容量为 4 的哈希表中存储在索引为 1 的位置。</li></ul><p><code>HashMap</code> 的扩容规则是将容量扩大为原来的两倍，即 <code>newCap = oldCap * 2</code>。在二进制表示中，**<code>newCap</code> 相当于 <code>oldCap</code> 左移一位。<strong>在二进制层面，</strong><code>newCap - 1</code> 相比于 <code>oldCap - 1</code> 只是多了一位高位。**举例如下：假设旧容量 <code>oldCap = 4</code>（二进制 <code>0100</code>），那么 <code>oldCap - 1 = 3</code>（二进制 <code>0011</code>）；新容量 <code>newCap = 8</code>（二进制 <code>1000</code>），<code>newCap - 1 = 7</code>（二进制 <code>0111</code>）。</p><p>对于一个元素的哈希值 <code>hash</code>，在旧哈希表中的索引是 <code>hash &amp; (oldCap - 1)</code>，在新哈希表中的索引是 <code>hash &amp; (newCap - 1)</code>。而 <code>(e.hash &amp; oldCap) == 0</code> 这个判断，本质上就是在检查 <code>hash</code> 的二进制表示中对应 <code>oldCap</code> 为 1 的那一位是否为 0。</p><ul><li>如果 <code>(e.hash &amp; oldCap) == 0</code>，说明 <code>hash</code> 在这一位是 0，那么 <code>hash &amp; (newCap - 1)</code> 的结果和 <code>hash &amp; (oldCap - 1)</code> 的结果是一样的，也就是元素在新哈希表中的位置和旧哈希表中相同。</li><li>如果 <code>(e.hash &amp; oldCap) != 0</code>，说明 <code>hash</code> 在这一位是 1，那么 <code>hash &amp; (newCap - 1)</code> 的结果就等于 <code>hash &amp; (oldCap - 1)</code> 再加上 <code>oldCap</code>，即元素在新哈希表中的位置是旧位置加上 <code>oldCap</code>。</li></ul><p>所以，通过 <code>(e.hash &amp; oldCap) == 0</code> 判断得到的元素在新哈希表中的位置和重新计算 <code>hash &amp; (newCap - 1)</code> 得到的位置是完全一致的。这种设计的主要依据是为了在扩容时能够高效地将元素分配到新的哈希表中，避免对每个元素都重新计算完整的哈希值和索引。通过简单的按位与运算，可以快速判断元素在新哈希表中的位置是保持不变还是需要移动到新的位置（原位置 + <code>oldCap</code>），从而减少了计算开销，提高了扩容的效率。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 遍历旧的哈希表数组</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 释放旧表的引用，帮助垃圾回收</span>        oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 如果该位置只有一个元素，直接重新计算哈希值并放入新表</span>            newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment">// 如果是树节点，调用树的拆分方法</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>             <span class="token comment">// 链表节点处理</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment">// 将位置不变的链表放入新表的原位置</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 将位置变化的链表放入新表的新位置（原位置 + 旧容量）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="长度问题"><a href="#长度问题" class="headerlink" title="长度问题"></a>长度问题</h5><p>总结一下 <code>HashMap</code> 的长度是 2 的幂次方的原因：</p><ol><li>位运算效率更高：位运算(&amp;)比取余运算(%)更高效。当长度为 2 的幂次方时，<code>hash % length</code> 等价于 <code>hash &amp; (length - 1)</code>。</li><li>可以更好地保证哈希值的均匀分布：扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。</li><li>扩容机制变得简单和高效：扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。</li></ol><h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><p><code>HashMap</code> 线程不安全主要体现在多线程环境下进行并发操作时可能会出现数据不一致、死循环等问题</p><p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有<strong>数据覆盖</strong>的风险。</p><p>举个例子：</p><ul><li>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</li><li>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</li><li>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</li></ul><p>JDK1.7及以前： 多线程下的 resize 操作可能导致死循环。在 JDK 7 及以前，<code>HashMap</code> 的 <code>resize</code> 方法在扩容时采用头插法将原链表中的元素插入到新链表中。在多线程环境下，当多个线程同时触发 <code>resize</code> 操作时，可能会导致链表形成环形结构，从而造成死循环。</p><p>综上所述，由于 <code>HashMap</code> 在多线程环境下的 <code>put</code>、<code>resize</code> 和 <code>size</code> 等操作没有进行有效的同步控制，所以它是线程不安全的。在多线程环境中，如果需要使用线程安全的哈希表，可以考虑使用 <code>ConcurrentHashMap</code> 或 <code>Hashtable</code>。</p><h4 id="HashMap-vs-HashTable"><a href="#HashMap-vs-HashTable" class="headerlink" title="HashMap vs HashTable"></a>HashMap vs HashTable</h4><ul><li><p><strong>线程是否安全：</strong> <strong><code>HashMap</code> 是非线程安全的</strong>，<code>Hashtable</code> 是线程安全的，因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p></li><li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>对 Null key 和 Null value 的支持：</strong> <strong><code>HashMap</code> 可以存储 null 的 key 和 value</strong>，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。（ConcurrentHashMap也不支持存储null）</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。**<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。<strong>② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其</strong>扩充为 2 的幂次方大小**（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，上面给出了源代码）。也就是说=== <strong><code>HashMap</code> 总是使用 2 的幂作为哈希表的大小</strong>==。</p><ul><li>Hash函数的算法设计：<strong>取余</strong>(%)操作中如果除数是 2 的幂次则<strong>等价于</strong>与其除数减一的与(&amp;)操作（也就是说 <code>hash%length==hash&amp;(length-1)</code>的前提是 length 是 2 的 n 次方）。并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</li></ul></li><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树</strong>（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</strong>），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</p></li></ul><h4 id="HashMap-vs-TreeMap"><a href="#HashMap-vs-TreeMap" class="headerlink" title="HashMap vs TreeMap"></a>HashMap vs TreeMap</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p><code>NavigableMap</code> 接口提供了丰富的方法来探索和操作键值对，可以对集合元素进行<strong>搜索</strong>:</p><ol><li><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位<strong>大于、小于、大于等于、小于等于给定键</strong>的最接近的键值对。</li><li><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</li><li><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</li><li><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素。</li></ol><p>这些方法都是基于<strong>红黑树</strong>数据结构的属性实现的，红黑树保持平衡状态，从而保证了<strong>搜索操作的时间复杂度为 O(log n)<strong>，这让 <code>TreeMap</code> 成为了处理</strong>有序集合搜索问题</strong>的强大工具。</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><p><strong>综上，相比于<code>HashMap</code>来说， <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</strong></p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="1-7版本"><a href="#1-7版本" class="headerlink" title="1.7版本"></a>1.7版本</h5><p>1.7版本：Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code> 组合，而每一个 <code>Segment</code> 是一个类似于 <code>HashMap</code> 的结构，所以<strong>每一个 <code>HashMap</code> 的内部可以进行扩容</strong>。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> <strong>默认支持最多 16 个线程并发。</strong></p><img src="/2024/06/15/java/java7_concurrenthashmap.png" alt="Java 7 ConcurrentHashMap 存储结构" style="zoom:80%;"><p>在 Java 7 中 ConcurrentHashMap 的<strong>初始化</strong>逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 <code>concurrencyLevel</code> 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li><li>寻找并发级别 <code>concurrencyLevel</code> 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 <code>segmentShift</code> 偏移量，这个值为【容量 = 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li><li>记录 <code>segmentMask</code>，默认是 ssize - 1 = 16 -1 = 15.</li><li><strong>初始化 <code>segments[0]</code><strong>，</strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩容。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// 创建 Segment 数组，设置 segments[0]</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> s0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cap <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token punctuation">[</span>ssize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> <span class="token constant">SBASE</span><span class="token punctuation">,</span> s0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ordered write of segments[0]</span><span class="token keyword">this</span><span class="token punctuation">.</span>segments <span class="token operator">=</span> ss<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>========put========</strong></p><p><code>ConcurrentHashMap</code> 在**put **一个数据时的处理流程：</p><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 <code>Segment</code>。</p></li><li><p>如果指定位置的 <code>Segment</code> 为空，则初始化这个 <code>Segment</code>.</p><p><strong>初始化 Segment 流程：</strong></p><ol><li>检查计算得到的位置的 <code>Segment</code> 是否为 null.</li><li>为 null 继续初始化，使用 <code>Segment[0]</code> 的容量和负载因子创建一个 <code>HashEntry</code> 数组。</li><li>再次检查计算得到的指定位置的 <code>Segment</code> 是否为 null。<strong>因为这时可能有其他线程进行了操作</strong></li><li>使用创建的 <code>HashEntry</code> 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 <code>Segment</code> 是否为 null，使用 CAS 在这个位置赋值为 <code>Segment</code></li></ol></li><li><p><strong><code>Segment.put</code> 插入 key,value 值。</strong></p><p><strong>由于 <code>Segment</code> 继承了 <code>ReentrantLock</code>，</strong>所以 <code>Segment</code> 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p><code>tryLock()</code> 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p></li><li><p>CAS计算 put 的数据要放入的 index 位置，然后获取这个位置上的 <code>HashEntry</code> 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 <code>HashEntry</code> 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p><p>如果这个位置上的 <strong><code>HashEntry</code> 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接头插法插入。</li></ol><p>如果这个位置上的 <strong><code>HashEntry</code> 存在</strong>：</p><ol><li>判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li><li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表遍历完毕没有相同的。 <ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表头插法插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p></li></ol></li></ol><p><strong>========扩容rehash========</strong></p><p><code>ConcurrentHashMap</code> 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 <code>index+ oldSize</code>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><p><strong>===========get=========</strong></p><ol><li>计算得到 key 的存放的segment的对应HashEntry数组位置。</li><li>遍历指定位置的链表查找相同 key 的 value 值。</li></ol><h5 id="1-8版本"><a href="#1-8版本" class="headerlink" title="1.8版本"></a>1.8版本</h5><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><img src="/2024/06/15/java/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）" style="zoom: 80%;"><p><strong>==========初始化==========</strong></p><p><code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> （sizeControl 的缩写），它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化，其他线程需要<strong>自旋等待</strong></li><li>-N 说明 table 正在进行扩容，高 16 位表示扩容的标识戳，低 16 位减 1 为正在进行扩容的线程数</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Initializes table, using the size recorded in sizeCtl. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment">// 让出 CPU 使用权，自旋等待</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lost initialization race; just spin</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">;</span>                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>==========put===========</strong></p><ol><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足(桶里有数据，数组不需要扩容），则利用 synchronized 锁写入数据，写入时判断结构是链表还是红黑树，执行对应的插入操作。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</li></ol><p><strong>==========get===========</strong></p><ol><li>根据 hash 值计算node数组位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，使用find查找。</li><li>如果是链表，遍历查找之。</li></ol><h5 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h5><ul><li><p>JDK1.8之前：首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。<code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。**<code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁**，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p></li><li><p>JDK1.8之后：<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <strong><code>Node + CAS + synchronized</code></strong> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p><p>Java 8 中，锁粒度更细，<code>synchronized</code> <strong>只锁定当前链表或红黑二叉树的首节点</strong>，这样<strong>只要 hash 不冲突，就不会产生并发</strong>，就不会影响其他 Node 的读写，效率大幅提升。</p></li></ul><p>总结：1.7中使用segment分段锁，锁范围较大，最大并发数为segment数量，默认是16。1.8中使用Node+CAS+synchronized，只锁定链表或红黑树的头节点，锁粒度更细，最大并发数是node数组的大小。</p><h4 id="ConcurrentHashMap-vs-Hashtable"><a href="#ConcurrentHashMap-vs-Hashtable" class="headerlink" title="ConcurrentHashMap vs Hashtable"></a>ConcurrentHashMap vs Hashtable</h4><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+HashEntry</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，<strong>数组+链表/红黑二叉树</strong>。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p></li><li><p><strong>实现线程安全的方式</strong>（重要）：</p></li><li><p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割<strong>分段</strong>(<code>Segment</code>，分段锁)，<strong>每一把锁只锁容器其中一部分数据</strong>，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p></li><li><p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是<strong>直接用 <code>Node</code> 数组+链表+红黑树</strong>的数据结构来实现，并发控制使用 <strong><code>synchronized</code> 和 CAS</strong> 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是**优化过且线程安全的 <code>HashMap</code>**，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p></li><li><p><strong>Hashtable(同一把锁) <strong>:使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入</strong>阻塞或轮询</strong>状态，如使用 put 添加元素，<strong>另一个线程不能使用 put 添加元素，也不能使用 get</strong>，竞争会越来越激烈效率越低。</p></li></ul><img src="/2024/06/15/java/image-20240619175017147.png" alt="image-20240619175017147" style="zoom:80%;"><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p><code>LinkedHashMap</code> 是 Java 提供的一个集合类，它继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条<strong>双向链表</strong>，使得具备如下特性:</p><ol><li>支持遍历时会<strong>按照插入顺序</strong>有序进行迭代。–<code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序。因此，当使用迭代器迭代元素时，元素的顺序与它们最初插入的顺序相同。</li><li>支持按照元素<strong>访问</strong>顺序<strong>排序</strong>，用于<strong>封装 LRU 缓存</strong>工具。–<code>LinkedHashMap</code> 可以通过构造函数中的 <code>accessOrder</code> 参数<strong>指定按照访问顺序迭代元素</strong>。当 <code>accessOrder</code> 为 true 时，每次访问一个元素时，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</li><li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。</li></ol><p><code>LinkedHashMap</code> 逻辑结构如下图所示，它是在 <code>HashMap</code> 基础上<strong>在各个节点之间维护一条双向链表</strong>，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。</p><img src="/2024/06/15/java/linkhashmap-structure-overview.png" alt="LinkedHashMap 逻辑结构" style="zoom:67%;"><h5 id="核心机制-3"><a href="#核心机制-3" class="headerlink" title="核心机制"></a>核心机制</h5><ul><li><p><code>LinkedHashMap</code> 的<strong>节点内部类 <code>Entry</code></strong> 基于 <code>HashMap</code> 的基础上，增加 <code>before</code> 和 <code>after</code> 指针使节点具备双向链表的特性。</p></li><li><p><code>HashMap</code> 的树节点 <code>TreeNode</code> 继承了具备双向链表特性的 <code>LinkedHashMap</code> 的 <code>Entry</code>。</p></li></ul><p>总结：Entry类是LinkedHashMap中的节点类，充当HashMap中Node类的作用。</p><p>HashMap 的节点集合 Node则仅包含kv对和下一个元素指针，避免使用HashMap的时候也出现无关的双向链表元素。</p><p>TreeNode用于在内部链表转化为红黑树的时候使用，继承enry类来获取双向链表指针。但是这样做，也使得使用 <code>HashMap</code> 时的 <code>TreeNode</code> 多了两个没有必要的引用。对于这个问题,引用作者的一段注释，作者们认为<strong>在良好的 <code>hashCode</code> 算法时，<code>HashMap</code> 转红黑树的概率不大。就算转为红黑树变为树节点，也可能会因为移除或者扩容将 <code>TreeNode</code> 变为 <code>Node</code>，所以 <code>TreeNode</code> 的使用概率不算很大，对于这一点资源空间的浪费是可以接受的。</strong></p><img src="/2024/06/15/java/map-hashmap-linkedhashmap.png" alt="LinkedHashMap 和 HashMap 之间的关系" style="zoom: 50%;"><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><p><strong><code>get</code> 方法是 <code>LinkedHashMap</code> 增删改查操作中唯一一个重写的方法。</strong><code>accessOrder</code> 为 true 的情况下， 它会在元素查询完成之后，将当前访问的元素移到链表的末尾。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>     <span class="token comment">//获取key的键值对,若为空直接返回</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>     <span class="token comment">//若accessOrder为true，则调用afterNodeAccess将当前元素移到链表末尾</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>         <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//返回键值对的值</span>     <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// move node to last</span>    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>    <span class="token comment">//如果accessOrder 且当前节点不为链表尾节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//获取当前节点、以及前驱节点和后继节点</span>        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>            <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> <span class="token punctuation">)</span> e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        <span class="token comment">//将当前节点的后继节点指针指向空，使其和后继节点断开联系（清除p-&gt;p.after）</span>        p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">//如果前驱节点为空，则说明当前节点是链表的首节点，故将后继节点设置为首节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            head <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">//如果前驱节点不为空，则让前驱节点指向后继节点(清除p.before-&gt;p)</span>            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token comment">//如果后继节点不为空，则让后继节点指向前驱节点(清除p.after-&gt;p)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">//如果后继节点为空，则说明当前节点在链表最末尾，直接让last 指向前驱节点,这个 else其实 没有意义，因为最开头if已经确保了p不是尾结点了，自然after不会是null</span>            last <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token comment">//如果last为空，则说明当前链表只有一个节点p，则将head指向p</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            head <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//反之让p的前驱指针指向尾节点，再让尾节点的前驱指针指向p(构建last&lt;-p &amp; last-&gt;p)</span>            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//tail指向p，自此将节点p移动到链表末尾（更新last为p）</span>        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>remove 方法后置操作——afterNodeRemoval</strong>：<code>LinkedHashMap</code> 并没有对 <code>remove</code> 方法进行重写，而是直接继承 <code>HashMap</code> 的 <code>remove</code> 方法，为了保证键值对移除后双向链表中的节点也会同步被移除，<code>LinkedHashMap</code> 重写了 <code>HashMap</code> 的空实现方法 <code>afterNodeRemoval</code>。<code>afterNodeRemoval</code> 方法的整体操作就是让当前节点 p 和前驱节点、后继节点断开联系，等待 gc 回收</p></li><li><p><strong>put 方法后置操作——afterNodeInsertion</strong>：同样的 <code>LinkedHashMap</code> 并没有实现插入方法，而是直接继承 <code>HashMap</code> 的所有插入方法交由用户使用，但为了维护双向链表访问的有序性，它做了这样两件事:</p><ol><li><p>重写 <code>afterNodeAccess</code>(上文提到过),如果当前被插入的 key 已存在与 <code>map</code> 中，因为 <code>LinkedHashMap</code> 的插入操作会将新节点追加至链表末尾，所以对于存在的 key 则调用 <code>afterNodeAccess</code> 将其放到链表末端。</p></li><li><p>重写了 <code>HashMap</code> 的 <code>afterNodeInsertion</code> 方法，<strong>当 <code>removeEldestEntry</code> 返回 true 时，会将链表首节点移除。</strong></p></li></ol></li></ul><h5 id="实现LRU缓存"><a href="#实现LRU缓存" class="headerlink" title="实现LRU缓存"></a>实现LRU缓存</h5><ul><li>继承 <code>LinkedHashMap</code>;</li><li>构造方法中指定 <code>accessOrder</code> 为 true（遍历时，需要访问顺序则为 true，需要插入顺序则为 false） ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；</li><li>重写<code>removeEldestEntry</code> 方法，该方法会返回一个 boolean 值，告知 <code>LinkedHashMap</code> 是否需要移除链表首元素（缓存容量有限）。</li></ul><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {    private final int capacity;    public LRUCache(int capacity) {        super(capacity, 0.75f, true);        this.capacity = capacity;    }    /**     * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)     */    @Override    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {        return size() &gt; capacity;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LinkedHashMap-vs-HashMap"><a href="#LinkedHashMap-vs-HashMap" class="headerlink" title="LinkedHashMap vs HashMap"></a>LinkedHashMap vs HashMap</h4><p><code>LinkedHashMap</code> 和 <code>HashMap</code> 都是 Java 集合框架中的 Map 接口的实现类。它们的最大区别在于<strong>迭代元素的顺序</strong>。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照<strong>插入顺序或访问顺序</strong>迭代元素的功能。此外，<code>LinkedHashMap</code> 内部维护了一个<strong>双向链表，</strong>用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 的插入性能可能会比 <code>HashMap</code> 略低，但它提供了更多的功能并且<strong>迭代效率相较于 <code>HashMap</code> 更加高效</strong>。</p><blockquote><p><code>LinkedHashMap</code> 维护了一个双向链表来记录数据插入的顺序，因此在迭代遍历生成的迭代器的时候，是按照双向链表的路径进行遍历的。这一点相比于 <code>HashMap</code> 那种遍历整个 bucket 的方式来说，高效许多。</p></blockquote><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 由红黑树实现，可以保持key元素的自然顺序，或者实现了 Comparator 接口的自定义顺序。</p><blockquote><p>红黑树（英语：Red–black tree）是一种自平衡的二叉查找树（Binary Search Tree），结构复杂，但却有着良好的性能，完成查找、插入和删除的时间复杂度均为 log(n)。</p><p>常见的平衡二叉树包括AVL树、红黑树等等，它们都是通过旋转操作来调整树的平衡，使得左子树和右子树的高度尽可能接近。</p></blockquote><p>AVL树是一种高度平衡的二叉查找树，它要求左子树和右子树的高度差不超过1。由于AVL树的平衡度比较高，因此在进行插入和删除操作时需要进行更多的旋转操作来保持平衡，但是在查找操作时效率较高。AVL树适用于读操作比较多的场景。</p><p>红黑树，顾名思义，就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持二叉树的平衡：</p><ul><li>1）每个节点都只能是红色或者黑色</li><li>2）<strong>根节点是黑色</strong></li><li>3）<strong>每个叶节点（NIL 节点，空节点）是黑色的。</strong></li><li>4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说<strong>在一条路径上不能出现相邻的两个红色节点。</strong></li><li>5）从任一节点到其每个叶子的<strong>所有路径都包含相同数目的黑色节点。</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">implements</span> <span class="token class-name">NavigableMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>    <span class="token comment">// 自定义比较器</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"serial"</span><span class="token punctuation">)</span> <span class="token comment">// Conditionally serializable</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">;</span>    <span class="token comment">// 元素根节点</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> root<span class="token punctuation">;</span>    <span class="token comment">// entry数量</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 修改记录</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token class-name">K</span> key<span class="token punctuation">;</span>        <span class="token class-name">V</span> value<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> left<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> right<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> color <span class="token operator">=</span> <span class="token constant">BLACK</span><span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// 将根节点赋值给变量t</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果根节点为null，说明TreeMap为空</span>        <span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// type (and possibly null) check，检查key的类型是否合法</span>        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个新节点作为根节点</span>        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// size设置为1</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 返回null，表示插入成功</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> cmp<span class="token punctuation">;</span>    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">;</span>    <span class="token comment">// split comparator and comparable paths，根据使用的比较方法进行查找</span>    <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> cpr <span class="token operator">=</span> comparator<span class="token punctuation">;</span> <span class="token comment">// 获取比较器</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cpr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果使用了Comparator</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">// 将当前节点赋值给parent</span>            cmp <span class="token operator">=</span> cpr<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> t<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用Comparator比较key和t的键的大小</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果key小于t的键</span>                t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">// 在t的左子树中查找</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果key大于t的键</span>                t <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">// 在t的右子树中查找</span>            <span class="token keyword">else</span> <span class="token comment">// 如果key等于t的键</span>                <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接更新t的值</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果没有使用Comparator</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果key为null</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 抛出NullPointerException异常</span>            <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> key<span class="token punctuation">;</span> <span class="token comment">// 将key强制转换为Comparable类型</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">// 将当前节点赋值给parent</span>            cmp <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用Comparable比较key和t的键的大小</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果key小于t的键</span>                t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">// 在t的左子树中查找</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果key大于t的键</span>                t <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">// 在t的右子树中查找</span>            <span class="token keyword">else</span> <span class="token comment">// 如果key等于t的键</span>                <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接更新t的值</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果没有找到相同的键，需要创建一个新节点插入到TreeMap中</span>    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个新节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果key小于parent的键</span>        parent<span class="token punctuation">.</span>left <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 将e作为parent的左子节点</span>    <span class="token keyword">else</span>        parent<span class="token punctuation">.</span>right <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 将e作为parent的右子节点</span>    <span class="token function">fixAfterInsertion</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  ======== 注意这里，插入节点后需要进行平衡操作</span>    size<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// size加1</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 返回null，表示插入成功</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="fail-fast-fail-safe"><a href="#fail-fast-fail-safe" class="headerlink" title="fail-fast / fail-safe"></a>fail-fast / fail-safe</h3><blockquote><p>快速失败的思想即针对可能发生的异常进行提前表明故障并停止运行，通过尽早的发现和停止错误，降低故障系统级联的风险。</p></blockquote><p><code>fail-fast</code> 是 Java 集合（如 <code>ArrayList</code>、<code>HashMap</code> 等）中一种错误检测机制。当一个线程正在迭代集合时，<strong>如果其他线程对该集合的结构进行了修改（例如添加、删除元素等），迭代器会立即抛出 <code>ConcurrentModificationException</code> 异常，从而快速失败</strong>并终止迭代过程。</p><p><code>fail-fast</code> 机制的实现依赖于集合中的一个计数器 <code>modCount</code>。每当集合的结构发生变化时，<code>modCount</code> 的值就会增加。迭代器在创建时会记录当前的 <code>modCount</code> 值（记为 <code>expectedModCount</code>），在每次迭代操作时，会检查 <code>modCount</code> 和 <code>expectedModCount</code> 是否相等。如果不相等，说明集合的结构在迭代过程中被修改了，迭代器会立即抛出 <code>ConcurrentModificationException</code> 异常。</p><p><strong><code>fail-fast</code> 机制主要用于检测并发修改错误，适用于单线程环境下快速发现程序中的错误。在多线程环境中，如果需要对集合进行并发操作，使用 <code>fail-fast</code> 集合可能会导致频繁抛出异常，因此不适合。</strong></p><blockquote><p><code>fail-safe</code>也就是安全失败的含义，它旨在即使面对意外情况也能恢复并继续运行，这使得它特别适用于不确定或者不稳定的环境</p></blockquote><p><code>fail-safe</code> 是一种相对安全的迭代机制。当一个线程正在迭代集合时，如果其他线程对该集合的结构进行了修改，迭代器不会抛出 <code>ConcurrentModificationException</code> 异常，而是继续迭代，使用的是集合的一个副本，因此不会影响原集合的迭代过程。</p><p><code>fail-safe</code> 机制的实现通常是在迭代时创建集合的一个副本，迭代器在副本上进行操作。由于副本和原集合是相互独立的，因此在迭代过程中对原集合的修改不会影响副本，也就不会抛出异常。</p><p><strong><code>fail-safe</code> 机制适用于多线程环境下对集合进行并发操作的场景，它可以避免因并发修改而导致的异常。但由于需要创建集合的副本，会消耗额外的内存，并且在迭代过程中可能无法及时反映原集合的最新状态。</strong></p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/fail-fast-and-fail-safe-copyonwritearraylist.png" alt="img" style="zoom:67%;"><h3 id="Comparable-Comparator"><a href="#Comparable-Comparator" class="headerlink" title="Comparable / Comparator"></a>Comparable / Comparator</h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p><code>Comparable</code> 接口位于 <code>java.lang</code> 包下，它定义了一个<strong>对象本身</strong>的自然排序规则。一个类实现了 <code>Comparable</code> 接口，就意味着<strong>该类的对象可以进行自我比较，从而支持使用一些排序算法（如 <code>Arrays.sort()</code>、<code>Collections.sort()</code>）对对象数组或集合进行排序</strong></p><ul><li>当一个类的排序规则是固定的、唯一的，并且该类的对象在大多数情况下都按照这个规则进行排序时，适合实现 <code>Comparable</code> 接口。例如，<code>String</code> 类就实现了 <code>Comparable</code> 接口，其 <code>compareTo()</code> 方法按照字典序对字符串进行比较。</li></ul><p><code>Comparator</code> 接口位于 <code>java.util</code> 包下，它提供了一种<strong>外部比较器</strong>的机制。与 <code>Comparable</code> 不同，<code>Comparator</code> 允许在不修改类本身的情况下，为类的对象定义多种不同的排序规则。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// void sort(List list),按自然排序的升序排序</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collections.sort(arrayList):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 定制排序的用法</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// person对象没有实现Comparable接口，所以必须实现，===这样才可以使treemap中的数据按顺序排列===</span><span class="token comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span><span class="token comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// set, get methods</span>    <span class="token comment">/**     * T重写compareTo方法实现按年龄来排序     * 若返回值小于 0，表示当前对象小于传入对象。若返回值大于 0，表示当前对象大于传入对象。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Person</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">-</span> o<span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pdata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"wangwu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"小红"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"xiaohong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 得到key的值的同时得到key所对应的值</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> pdata<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Person</span> key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> key<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位。线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程<strong>共享</strong>进程的<strong>堆</strong>和<strong>方法区</strong>（<strong>JDK1.8 之后的元空间</strong>）资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为<strong>轻量级进程</strong>。</p><p><strong>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p><p>私有：</p><ul><li><strong>程序计数器</strong>：字节码解释器通过<strong>改变程序计数器来依次读取指令</strong>，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。计数器私有是为了<strong>各线程之间切换，便于恢复到正确的执行位置。</strong></li><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储===<strong>局部变量表、操作数栈、常量池引用</strong>===等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。如果虚拟机栈是共享的，多个线程可能会同时修改栈中的数据，导致数据不一致和程序崩溃。<ul><li>例如，线程 A 和线程 B <strong>同时调用同一个方法</strong>，若共享虚拟机栈，线程 A 的<strong>局部变量可能会被线程 B 覆盖</strong>，从而产生不可预期的结果。线程私有可以保证每个线程的<strong>方法调用和局部变量的独立性</strong>，避免线程间的干扰，确保线程安全。</li></ul></li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<ul><li>本地方法栈用于支持本地方法（使用非 Java 语言编写的方法，如 C、C++ 等）的执行。本地方法在执行过程中也需要自己的栈空间来存储相关信息。</li></ul></li></ul><blockquote><p>为了<strong>保证线程中的===局部变量===不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p></blockquote><p>公有：</p><p>堆和方法区是所有线程共享的资源，其中<strong>堆是进程中最大的一块内存</strong>，主要用于存放新创建的<strong>对象</strong> (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p><p>================================================</p><ul><li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li><li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li><li>用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。</li></ul><p><strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p><p>线程模型：线程模型是用户线程和内核线程之间的关联方式。</p><ol><li>一对一（一个用户线程对应一个内核线程）</li><li>多对一（多个用户线程映射到一个内核线程）</li><li>多对多（多个用户线程映射到多个内核线程）</li></ol><p>在 Windows 和 Linux 等主流操作系统中，<strong>Java 线程采用的是一对一的线程模型</strong>，也就是一个 Java 线程对应一个系统内核线程。</p><h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>Java语言的JVM允许程序运行多个线程，使用<code>java.lang.Thread</code>类代表<strong>线程，所有的线程对象都必须是Thread类或其子类的实例。</strong></p><p>Thread类的特性</p><ul><li><p><strong>每个线程都是通过某个特定Thread对象的run()方法来完成操作的</strong>，因此把run()方法体称为<strong>线程执行体</strong>。</p><ul><li>实现Runnable、Callable接口，包括继承Thread类重写run()方法，都是创建线程体的方式。</li><li>线程是一个独立的执行单元，可以被操作系统调度；而线程体仅仅只是任务，就类似于一段普通的代码，需要线程作为载体才能运行。<strong>线程是执行线程体的容器，线程体是一个可运行的任务</strong>。</li></ul></li><li><p><strong>通过该Thread对象的start()方法来启动这个线程</strong>，而非直接调用run()。</p><ul><li><p><strong>在<code>Java</code>中，创建线程的方式就只有一种：调用<code>Thread.start()</code>方法</strong>！只有这种形式，才能在真正意义上创建一条线程！</p><p>而例如<code>ExecutorService</code>线程池、<code>ForkJoin</code>线程池、<code>CompletableFuture</code>类、<code>Timer</code>定时器类、<code>parallelStream</code>并行流……，它们最终都依赖于<code>Thread.start()</code>方法创建线程。</p></li></ul></li><li><p>要想实现多线程，必须在主线程中创建新的线程对象。</p></li></ul><p><strong>继承Thread类</strong>，重写run方法。创建该类的实例，并调用 start() 方法启动线程。</p><p>优点：编写简单；缺点：因为继承了Thread，不能再继承其他类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExtendsThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">ExtendsThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现Runnable接口</strong>，重写run方法。创建该类的实例，<strong>将其作为参数传递给 Thread 类的构造函数</strong>，创建 Thread 对象，最后调用 start() 方法启动线程。</p><p>优点：只是实现了Runnable接口，可以继承其他类。可以多线程共享同一个目标对象。缺点：编程稍微复杂，访问当前线程需要Thread.currentThread()方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImplementsRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ImplementsRunnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImplementsRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现Callable接口并结合 FutureTask</strong>：和上一种方式类似，只不过<strong>这种方式可以拿到线程执行完的返回值</strong>。方法可以抛出异常。支持泛型的返回值（需要借助FutureTask类，获取返回结果）</p><p>创建该类的实例，将其作为参数传递给 FutureTask 类的构造函数，创建 FutureTask 对象。将 FutureTask 对象作为参数传递给 Thread 类的构造函数（FutureTask实现了Runnable接口），创建 Thread 对象，调用 start() 方法启动线程。</p><p>优缺点同Runnable。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImplementsCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"zhuZi"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">ImplementsCallable</span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImplementsCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取线程执行结果</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用ExecutorService线程池</strong>：使用 Executors 工具类创建线程池，或者直接使用 ThreadPoolExecutor 类创建自定义线程池。提交任务到线程池，可以提交 Runnable 或 Callable 任务。</p><p>优点：</p><ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，降低创建和销毁线程的开销）</li><li>便于线程管理（统一分配，调优和监控）</li></ul><p>缺点：程序复杂度高。错误的配置可能导致线程死锁或资源耗尽。缺乏异步组合能力：对于多个异步任务的组合和编排支持不够方便，需要手动编写大量的代码来处理任务之间的依赖关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ublic <span class="token keyword">class</span> <span class="token class-name">UseExecutorService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ExecutorService</span> poolA <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolA<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"4A......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolA<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 又或者自定义线程池</span>        <span class="token class-name">ThreadPoolExecutor</span> poolB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolB<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"4B......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolB<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用CompletableFuture类</strong>：CompletableFuture是JDK1.8引入的新类，可以用来执行异步任务。</p><ul><li>优点<ul><li><strong>强大的异步组合能力</strong>：可以方便地对多个异步任务进行组合和编排，如任务的串行执行、并行执行、合并结果等。例如，可以使用 <code>thenApply()</code>、<code>thenCompose()</code> 等方法实现任务的串行执行，使用 <code>allOf()</code>、<code>anyOf()</code> 等方法实现任务的并行执行。</li><li><strong>链式调用</strong>：支持链式调用，代码更加简洁易读。可以通过链式调用的方式将多个异步操作连接起来，形成一个异步操作链。</li><li><strong>异常处理方便</strong>：提供了丰富的异常处理方法，如 <code>exceptionally()</code>、<code>handle()</code> 等，可以方便地处理任务执行过程中的异常。</li></ul></li><li>缺点<ul><li><strong>学习成本较高</strong>：由于 <code>CompletableFuture</code> 提供了丰富的功能和方法，对于初学者来说，学习和掌握这些方法的使用需要花费一定的时间和精力。</li><li><strong>线程管理不够精细</strong>：<code>CompletableFuture</code> 默认使用 <code>ForkJoinPool.commonPool()</code> 线程池，对于一些对线程管理有特殊要求的场景，可能无法满足需求。例如，无法像 <code>ExecutorService</code> 那样灵活地创建和配置线程池。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UseCompletableFuture</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cf <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"5......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">"zhuZi"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 需要阻塞，否则看不到结果</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>基于ThreadGroup线程组</strong>：Java线程可以分组，可以创建多条线程作为一个组。</p><p>优点：</p><ul><li><p><strong>统一管理</strong>：<code>ThreadGroup</code> 提供了一种简单的方式来对一组线程进行统一管理。可以通过线程组一次性对组内的所有线程进行操作，例如中断组内的所有线程，调用 <code>ThreadGroup</code> 的 <code>interrupt()</code> 方法就可以中断组内所有未被中断的线程。</p></li><li><p><strong>层次结构清晰</strong>：<code>ThreadGroup</code> 可以形成树形的层次结构，便于组织和管理大量的线程。例如，在一个大型的应用程序中，可以根据不同的功能模块创建不同的线程组，每个线程组下再包含具体的线程，这样可以使线程的管理更加清晰。</p></li></ul><p>缺点：</p><ul><li><strong>功能有限</strong>：<code>ThreadGroup</code> 的主要功能集中在线程的分组和统一管理上，对于线程的执行控制和任务调度功能相对较弱。与 <code>ExecutorService</code> 相比，它不能像线程池那样灵活地控制线程的数量、复用线程以及处理任务队列。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UseThreadGroup</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ThreadGroup</span> group <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadGroup</span><span class="token punctuation">(</span><span class="token string">"groupName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"6-T1......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"T1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"6-T2......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"T2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul><li><p>线程创建之后它将处于 <strong>NEW（新建/初始）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><ul><li>在操作系统层面，线程有 <strong>READY 和 RUNNING</strong> 状态；而<strong>在 JVM 层面，只能看到 RUNNABLE 状态</strong>， Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。JVM没有区分这两种状态，时分（time-sharing）多任务（multi-task）操作系统架构通常都是用“时间分片”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，<strong>一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态）</strong>，也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</li></ul></li><li><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需<strong>要依靠其他线程的通知</strong>才能够返回到运行状态。（等待状态，表示<strong>该线程需要等待其他线程做出一些特定动作如通知或中断</strong>）</p></li><li><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p></li><li><p>当线程进入 <code>synchronized</code> 方法/块或者调用 <code>wait</code> 被 <code>notify</code>重新进入 <code>synchronized</code> 方法/块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。、</p></li><li><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p></li></ul><img src="/2024/06/15/java/640.png" alt="Java 线程状态变迁图" style="zoom:80%;"><p><strong>线程上下文切换：</strong>保存当前线程的上下文（线程运行过程中的条件和状态），留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。线程切换可能发生在这些场景：<strong>主动让出 CPU</strong>，比如调用了 sleep(), wait() 等。<strong>时间片用完</strong>，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。调用了阻塞类型的<strong>系统中断</strong>，比如请求 IO，线程被阻塞。<strong>被终止</strong>或<strong>结束运行</strong>。</p><h4 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h4><p><strong>Thread#sleep() 方法和 Object#wait() 方法</strong>：都可以暂停线程的执行。区别是sleep是让当前线程休眠一会，之后就会自动恢复，所以不会释放锁。而wait（）对应线程生命周期中的等待状态，目的是线程之间的通信和交互，需要释放锁等待其他线程通知才能回到运行状态。<code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</p><ul><li><code>wait()</code> 是让获得<strong>对象锁</strong>的线程实现等待，会自动释放当前线程占有的对象锁。<strong>每个对象（<code>Object</code>）都拥有对象锁</strong>，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要<strong>操作对应的对象</strong>（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</li><li><code>sleep()</code> 是让当前<strong>线程</strong>暂停执行，不涉及到对象类，也不需要获得对象锁。所以定义在Thread中。</li></ul><p>关于run和start：调用 <code>start()</code> 方法启动线程并使线程进入就绪状态，会执行线程的相应准备工作，然后<strong>自动执行 <code>run()</code> 方法</strong>的内容。如果开发者手动直接执行 <code>run()</code> 方法的话，<strong>会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，</strong>不会以多线程的方式执行。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><p>操作系统主要通过两种线程调度方式来管理多线程的执行：</p><ul><li><strong>抢占式调度（Preemptive Scheduling）</strong>：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。这种切换通常是由系统时钟中断（时间片轮转）或其他高优先级事件（如 I/O 操作完成）触发的。这种方式存在上下文切换开销，但公平性和 CPU 资源利用率较好，不易阻塞。</li><li><strong>协同式调度（Cooperative Scheduling）</strong>：线程执行完毕后，主动通知系统切换到另一个线程。这种方式可以减少上下文切换带来的性能开销，但公平性较差，容易阻塞。</li></ul><p>Java 使用的线程调度是抢占式的。也就是说，JVM 本身不负责线程的调度，而是<strong>将线程的调度委托给操作系统</strong>。操作系统通常会基于线程优先级和时间片来调度线程的执行，高优先级的线程通常获得 CPU 时间片的机会更多。</p><p>并发编程的目的就是为了能提高程序的执行效率进而提高程序的运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等等。</p><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。</p><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是多线程或多进程并发编程中的一种常见问题，它发生在<strong>两个或多个线程（或进程）相互等待对方释放资源</strong>的情况下，导致它们都无法继续执行下去的状态。这种情况下，每个线程都在等待某个资源，而同时也拥有一些资源。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 1</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 2</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li><strong>请求与保持</strong>/占有并等待条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>非抢占条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p><strong>预防死锁（破坏死锁的产生的必要条件即可）</strong>：</p><p>1.破坏占有并等待条件：一次性申请所有资源；</p><p>2.破坏非抢占条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p>3.破坏循环等待条件：对资源进行排序，按照固定的顺序请求资源，反序释放资源。</p><blockquote><p>例如为系统中的所有资源分配唯一的编号，进程在请求资源时，必须按照编号从小到大的顺序进行请求。这样可以保证不会出现循环等待的情况，因为如果一个进程已经持有了编号较大的资源，它就不能再请求编号较小的资源，从而打破了循环等待的环路。</p></blockquote><p><strong>避免死锁</strong>：避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>Java 内存模型（Java Memory Model，JMM）是 Java 语言规范中定义的一种抽象概念（并不真实存在），它屏蔽了各种硬件和操作系统的内存访问差异，以实现 Java 程序在不同平台下都能达到一致的内存访问效果。<strong>JMM 规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步地访问共享变量。</strong></p><ul><li><strong>定义</strong>：Java 内存模型是一组规则，它规定了<strong>一个线程对共享变量的写入何时对另一个线程可见</strong>，即解决了多线程环境下共享变量的可见性、有序性和原子性问题。</li><li><strong>主要目标</strong>：提供一种跨平台的内存访问协议，保证 Java 程序在不同的硬件和操作系统上都能具有一致的并发行为，使得开发者可以更方便地编写多线程程序，而无需关心底层硬件的内存访问细节。</li></ul><h4 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h4><ul><li><strong>主内存（Main Memory）</strong>：主内存是<strong>所有线程共享</strong>的内存区域，它存储了<strong>对象实例、静态变量</strong>等共享数据。可以把主内存看作是计算机的物理内存，它是数据的最终存储位置。</li><li><strong>工作内存（Working Memory）</strong>：每个线程都有自己独立的工作内存，它是<strong>线程私有</strong>的。线程在工作内存中保存了该线程使用到的主内存中<strong>共享变量的副本</strong>。线程对共享变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。</li></ul><h4 id="数据交互流程"><a href="#数据交互流程" class="headerlink" title="数据交互流程"></a>数据交互流程</h4><p>当一个线程要访问共享变量时，会先从主内存中读取该变量的值到自己的工作内存中，形成一个副本。线程对副本进行操作后，在某个时刻（具体由 JMM 决定）<strong>将修改后的值刷新回主内存</strong>。由于不同线程的工作内存是相互独立的，所以一个线程对共享变量的修改需要通过刷新到主内存，然后其他线程再从主内存中读取新值，才能被其他线程看到。</p><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ul><li><strong>原子性</strong>：指一个操作是不可中断的，要么全部执行成功，要么全部执行失败。在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作，但像 <code>i++</code> 这种复合操作不是原子性的。可以使用 <code>synchronized</code> 或 <code>Lock</code> 来保证操作的原子性。</li><li><strong>可见性</strong>：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。JMM 通过控制主内存和工作内存之间的交互，来实现可见性。例如，使用 <code>volatile</code> 关键字可以保证变量的可见性，当一个变量被声明为 <code>volatile</code> 时，它会保证对该变量的写操作会立即刷新到主内存，读操作会直接从主内存中读取。</li><li><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。但在实际执行过程中，为了提高性能，编译器和处理器可能会对指令进行重排序。JMM 提供了 <code>happens-before</code> 原则来<strong>保证一定的有序性</strong>，确保在某些情况下指令不会被重排序。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是Java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色。<code>volatile</code> 关键字可以保证变量的可见性， <strong>所谓可见性，是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更</strong>。如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是<strong>共享且不稳定</strong>的，每次使用它都到<strong>主存</strong>中进行读取。<code>volatile</code> 关键字能保证数据的可见性，<strong>但不能保证数据的原子性</strong>。<code>synchronized</code> 关键字两者都能保证。</p><p><strong>JMM规定了所有的变量都存储在主内存中</strong>。普通变量不能保证内存可见性。而volatile则保证了<strong>可见性和有序性</strong>。</p><ul><li>当<strong>写</strong>一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值<strong>立即刷新回主内存中</strong>。</li><li>当<strong>读</strong>一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存<strong>中读取最新共享变量</strong>。</li></ul><p>有序性，即<strong>禁止指令重排序</strong>。在对volatile变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><ul><li>重排序是指编译器和处理器为了优化程序性能<strong>面对指令序列进行重新排序</strong>的一种手段，有时候会改变程序予以的先后顺序。（但重排后的指令绝对不能改变原有串行语义）<ul><li>不存在数据依赖关系，可以重排序；</li><li>存在数据依赖关系，禁止重排序。</li></ul></li></ul><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p><ul><li><strong>读屏障</strong>(Load Memory Barrier) ：在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据。</li><li><strong>写屏障</strong>(Store Memory Barrier) ：在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中。</li></ul><p>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。一句话：<strong>对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读，也叫写后读。</strong></p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//类对象加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。<strong>指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。</strong>例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。使用volatile修饰，就能禁止指令重排。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><blockquote><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p></blockquote><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用<strong>版本号机制或 CAS 算法</strong>）。</p><p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><blockquote><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p></blockquote><p>理论上来说：</p><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以<strong>避免频繁失败和重试影响性能</strong>，悲观锁的<strong>开销是固定的</strong>。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以<strong>避免频繁加锁影响性能</strong>。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于<strong>实现乐观锁</strong>，被广泛应用于各大框架中。CAS 的思想很简单，就是<strong>用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</strong></p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令：</p><ul><li>在Java中，通过 <code>sun.misc.Unsafe</code> 类调用本地（Native）方法实现。</li><li>示例：<code>Unsafe.compareAndSwapInt()</code>、<code>Unsafe.compareAndSwapObject()</code>。</li></ul><p>CAS 涉及到三个操作数：<strong>V</strong>：要更新的变量值(Var)；<strong>E</strong>：预期值(Expected)；<strong>N</strong>：拟写入的新值(New)</p><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。（和版本号机制思想一致）</p><p><code>Unsafe#getAndAddInt</code>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 原子地获取并增加整数值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment">// 以 volatile 方式获取对象 o 在内存偏移量 offset 处的整数值</span>        v <span class="token operator">=</span> <span class="token function">getIntVolatile</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v <span class="token operator">+</span> delta<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回旧值</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>getAndAddInt</code> 使用了 <code>do-while</code> 循环：在<code>compareAndSwapInt</code>操作失败时，会不断重试直到成功。也就是说，<code>getAndAddInt</code>方法会通过 <code>compareAndSwapInt</code> 方法来尝试更新 <code>value</code> 的值，如果更新失败（当前值在此期间被其他线程修改），它会重新获取当前值并再次尝试更新，直到操作成功。</p><p>由于 CAS 操作可能会因为并发冲突而失败，因此通常会与<code>while</code>循环搭配使用，在失败后不断重试，直到操作成功。这就是 <strong>自旋锁机制</strong>。</p><p>问题：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>解决方案：在变量前面追加上<strong>版本号或者时间戳</strong>。<code>AtomicStampedReference</code> 类的 <code>compareAndSet()</code> 方法就是首先检查当前<strong>引用</strong>是否等于预期引用，并且当前<strong>标志</strong>是否等于预期标志，如果<strong>全部相等</strong>，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>另一个问题：<strong>循环时间长开销大</strong>。CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升。</p><h4 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h4><p>Java 中的 <code>Atomic</code> 原子类是一组基于 <strong>CAS（Compare and Swap）</strong> 实现的无锁线程安全工具类，位于 <code>java.util.concurrent.atomic</code> 包中。它们提供了一种高效的方式来操作共享变量，避免了传统锁机制带来的性能开销。</p><ul><li>所有操作都是原子的，确保多线程环境下的数据一致性。</li></ul><ul><li>直接操作内存，通过硬件指令保证原子性。</li><li>支持多种数据类型包括基本类型（如 int、long）、数组类型和引用类型（如对象）。</li></ul><h3 id="JUC-常用的类"><a href="#JUC-常用的类" class="headerlink" title="JUC 常用的类"></a>JUC 常用的类</h3><ol><li><code>java.util.concurrent</code>这是 JUC 最核心的包，包含了大量用于并发编程的类和接口，主要有以下几类：</li></ol><ul><li>线程池相关类<ul><li><code>ExecutorService</code>：线程池的<strong>核心接口</strong>，定义了线程池的基本操作，如提交任务、关闭线程池等。</li><li><code>ThreadPoolExecutor</code>：<code>ExecutorService</code> 的一个具体实现类，开发者可以<strong>通过它自定义线程池的各种参数</strong>，如核心线程数、最大线程数、线程空闲时间等。</li><li><code>Executors</code>：线程池<strong>工厂类</strong>，提供了一系列静态方法用于创建不同类型的线程池，如 <code>newFixedThreadPool</code>（固定大小线程池）、<code>newCachedThreadPool</code>（缓存线程池）、<code>newSingleThreadExecutor</code>（单线程线程池）等。</li></ul></li><li>锁相关类<ul><li><code>Lock</code>：一个<strong>接口</strong>，定义了锁的基本操作，如加锁、解锁等。与传统的 <code>synchronized</code> 关键字相比，<code>Lock</code> 提供了更灵活的锁机制。</li><li><code>ReentrantLock</code>：<code>Lock</code> 接口的一个实现类，是可重入锁，支持公平锁和非公平锁。</li><li><code>ReadWriteLock</code>：一个<strong>接口</strong>，定义了读写锁的基本操作，将锁分为读锁和写锁，允许多个线程同时获取读锁，但写锁是排他的。</li><li><code>ReentrantReadWriteLock</code>：<code>ReadWriteLock</code> 接口的一个实现类。</li></ul></li><li>并发容器类<ul><li><code>ConcurrentHashMap</code>：<strong>线程安全的哈希表</strong>，在多线程环境下可以高效地进行读写操作。</li><li><code>ConcurrentLinkedQueue</code>：<strong>线程安全的链表队列</strong>，适用于多线程环境下的队列操作。</li><li><code>CopyOnWriteArrayList</code>：<strong>线程安全的动态数组</strong>，在进行写操作时会复制一份原数组，适用于读多写少的场景。</li></ul></li><li>同步工具类<ul><li><code>CountDownLatch</code>：一种同步辅助工具，允许一个或多个线程等待其他线程完成操作后再继续执行。</li><li><code>CyclicBarrier</code>：也是一种同步辅助工具，它允许一组线程相互等待，直到所有线程都到达某个屏障点后再继续执行，并且可以重复使用。</li><li><code>Semaphore</code>：用于控制同时访问某个资源的线程数量，通过获取和释放许可证来实现。</li><li><code>Exchanger</code>：用于两个线程之间交换数据，当两个线程都到达交换点时，它们会交换彼此的数据。</li></ul></li></ul><ol start="2"><li><code>java.util.concurrent.atomic</code></li></ol><p>该包提供了一些原子类，这些类可以在多线程环境下进行原子操作，避免了使用传统的同步机制带来的性能开销。常见的原子类有：</p><ul><li><code>AtomicInteger</code>：用于对整数进行原子操作，如自增、自减等。</li><li><code>AtomicLong</code>：用于对长整数进行原子操作。</li><li><code>AtomicBoolean</code>：用于对布尔值进行原子操作。</li><li><code>AtomicReference</code>：用于对引用类型进行原子操作。</li></ul><h4 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h4><p> <strong>CountDownLatch</strong></p><ul><li><strong>功能</strong>：<code>CountDownLatch</code> 是一个同步辅助类，<strong>允许一个或多个线程等待其他线程完成操作</strong>。它使用一个<strong>计数器</strong>来实现，初始化时设置计数器的值，当某个线程完成操作后，调用 <code>countDown()</code> 方法将计数器减 1，当计数器的值变为 0 时，等待的线程将被唤醒继续执行。**<code>CountDownLatch</code> 是一次性的**，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</li><li><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。<strong>直到<code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</strong></li><li><strong>使用场景</strong>：适用于一个或多个线程需要等待其他一组线程完成任务后再继续执行的场景，比如主线程等待多个子线程完成数据加载或计算任务。</li></ul><p> <strong>CyclicBarrier</strong></p><ul><li><strong>功能</strong>：<code>CyclicBarrier</code> 也是一个同步辅助类，它允许<strong>一组线程在某个屏障点等待，直到所有线程都到达该屏障点</strong>后，再一起继续执行后续操作。与 <code>CountDownLatch</code> 不同的是，**<code>CyclicBarrier</code> 的计数器可以重置**，因此可以重复使用。</li><li>CyclicBarrier 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</li><li><strong>使用场景</strong>：在并行计算中，当多个线程需要协同工作，在某个阶段等待所有线程都完成部分任务后，再进行下一步计算时，<code>CyclicBarrier</code> 非常有用。</li></ul><p><code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</p><p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p><p><strong>Semaphore</strong></p><ul><li><strong>功能</strong>：<code>Semaphore</code> 是一个计数信号量，用于<strong>控制同时访问某个资源的线程数量</strong>。它有一个初始值，表示可用的资源数量。线程在访问资源前需要先获取信号量，如果信号量的值大于 0，则获取成功，信号量的值减 1；如果信号量的值为 0，则线程会被阻塞，直到有其他线程释放信号量。</li><li><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为<strong>许可证的数量</strong>，只有拿到许可证的线程才能执行。</li><li><strong>使用场景</strong>：常用于限制对有限资源的访问，如数据库连接池、线程池的最大并发数控制等。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 初始共享资源数量</span><span class="token keyword">final</span> <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取1个许可</span>semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放1个许可</span>semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Semaphore</code> 有两种模式：<strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；<strong>非公平模式：</strong> 抢占式的。</p><p><strong>Future 和 Callable</strong></p><ul><li><p><code>Callable</code> 是一个泛型接口，类似于 <code>Runnable</code>，但 <code>Callable</code> 可以有返回值并且可以抛出异常。</p></li><li><p><code>Future</code> 是一个接口，用于获取 <code>Callable</code> 任务的执行结果或取消任务的执行。<code>FutureTask</code> 类实现了 <code>RunnableFuture</code> 接口（继承自 <code>Runnable</code> 和 <code>Future</code>），既可以作为 <code>Runnable</code> 被线程执行，又可以作为 <code>Future</code> 获取 <code>Callable</code> 任务的执行结果。</p></li><li><p><strong>使用场景</strong>：在需要异步执行任务并获取任务执行结果的场景中，如异步计算、异步数据加载等。</p></li></ul><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><code>synchronized</code> 是 Java 中的一个<strong>关键字</strong>，翻译成中文是同步的意思，主要解决的是<strong>多个线程之间访问资源的同步性</strong>，可以保证<strong>被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p><p>在 Java 6以前，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。它的实现依赖于操作系统的互斥量（Mutex），线程在获取锁和释放锁时需要进行<strong>用户态和内核态的切换</strong>，这种切换的开销非常大，导致性能较低。（也就是挂起或唤醒线程进行线程上下文切换时，<strong>都需要从用户态转换成内核态</strong>）</p><p>在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。（JDK18 中，偏向锁已经被彻底废弃）锁主要存在四种状态，依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，他们会随着竞争的激烈而逐渐升级。注意<strong>锁可以升级不可降级</strong>，这种策略是为了提高获得锁和释放锁的效率。</p><ul><li><strong>偏向锁</strong>：偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无需做任何同步操作，这样可以在单线程环境下提高性能。偏向锁适用于大多数情况下只有一个线程访问同步块的场景。</li><li><strong>轻量级锁</strong>：轻量级锁是为了在没有多线程竞争的情况下减少传统重量级锁使用操作系统互斥量产生的性能开销。当线程尝试获取锁时，如果<strong>发现锁是偏向锁且偏向的线程不是自己，会尝试将偏向锁升级为轻量级锁</strong>。轻量级锁使用 CAS（Compare and Swap）操作来获取和释放锁，避免了用户态和内核态的切换。</li><li><strong>锁粗化</strong>：锁粗化是指将多个连续的加锁、解锁操作合并为一个更大范围的加锁、解锁操作。例如，在一个循环中多次对同一个对象加锁和解锁，JVM 会将锁的范围扩大到循环外部，减少锁的竞争和同步开销。</li><li><strong>锁消除</strong>：锁消除是指 JVM 在编译时，通过逃逸分析技术，发现某些代码块中的锁是不必要的，就会将这些锁消除。例如，在方法内部创建的对象，并且该对象不会被其他线程访问，那么对该对象的加锁操作就是不必要的，JVM 会将其消除。</li></ul><img src="https://cdn.xiaolincoding.com//picgo/1721808326210-cce43537-20e7-4b7d-bed3-737dc7904d9a.png" alt="image.png" style="zoom: 33%;"><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 修饰实例方法，给当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 。</span><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//业务代码</span><span class="token punctuation">}</span><span class="token comment">// 修饰静态方法，当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。</span><span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//业务代码</span><span class="token punctuation">}</span><span class="token comment">// 修饰代码块，对括号里指定的对象/类加锁：synchronized(object)或synchronized(类.class)</span><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//业务代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>synchronized 关键字底层原理属于 JVM 层面的东西。</p><p><strong>同步语句块</strong></p><p><code>synchronized</code> <strong>同步语句块</strong>的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>同步方法</strong></p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。<strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong>JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h4 id="synchronized-vs-volatile"><a href="#synchronized-vs-volatile" class="headerlink" title="synchronized vs volatile"></a>synchronized vs volatile</h4><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个<strong>互补</strong>的存在，而不是对立的存在！</p><ul><li><code>volatile</code> 关键字是线程同步的<strong>轻量级</strong>实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字<strong>只能用于变量</strong>而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><code>volatile</code> 关键字能保证<strong>数据的可见性</strong>，但不能保证数据的原子性。<code>synchronized</code> 关键字<strong>两者都能保证</strong>。</li><li><code>volatile</code>关键字主要用于解决<strong>变量在多个线程之间的可见性</strong>，而 <code>synchronized</code> 关键字解决的是<strong>多个线程之间访问资源的同步性</strong>。</li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个<strong>可重入且独占式</strong>的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了<strong>轮询、超时、中断、公平锁和非公平锁</strong>等高级功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>ReentrantLock</code> 里面有一个**内部类 <code>Sync</code>**，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><code>ReentrantLock</code> <strong>默认使用非公平锁</strong>，也可以通过构造器来显式的指定使用公平锁。<code>ReentrantLock</code> 的底层就是由 AQS 来实现的。</p><img src="/2024/06/15/java/reentrantlock-class-diagram.png" alt="img" style="zoom: 50%;"><p><strong>公平锁</strong> : 锁被释放之后，<strong>先申请的线程先得到锁</strong>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，<strong>上下文切换更频繁</strong>。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，<strong>cpu唤醒阻塞线程的开销会很大</strong>。</li></ul><p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。<strong>性能更好</strong>，但可能会导致某些线程永远无法获取到锁。</p><ul><li>非公平锁比公平锁效率高的原因主要在于<strong>减少了线程切换和同步操作的次数</strong>。</li><li>当线程在运行期间直接抢占到锁资源时，不需要进行“执行<strong>现场保存和恢复</strong>”的操作，从而能够更快地执行业务代码。相比之下，如果一个就绪态的线程想要获得锁资源，首先需要恢复现场，之后争抢锁（可能成功也可能失败），这个过程浪费了大量的CPU资源，只有在获取锁成功后才能继续执行业务代码。因此，非公平锁在效率上优于公平锁，主要原因就在于是否需要进行现场恢复和不同态之间的切换。<strong>非公平锁减少了线程挂起的几率</strong>，后来的线程有一定几率逃离被挂起的开销。</li></ul><h3 id="synchronized-vs-ReentrantLock"><a href="#synchronized-vs-ReentrantLock" class="headerlink" title="synchronized vs ReentrantLock"></a>synchronized vs ReentrantLock</h3><ul><li>两者都是可重入锁。<strong>可重入锁</strong> 也叫<strong>递归锁</strong>，指的是<strong>线程可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，<strong>如果是不可重入锁的话，就会造成死锁。</strong><ul><li>可重入锁主要用在线程需要多次进入临界区代码时，需要使用可重入锁。</li><li>每一个锁关联一个<strong>线程持有者和计数器</strong>，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会<strong>记下锁的持有线程</strong>，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以<strong>再次拿到这个锁，同时计数器会递增</strong>；当线程<strong>退出同步代码块时，计数器会递减</strong>，如果计数器为 0，则释放该锁。</li></ul></li><li><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是<strong>这些优化都是在虚拟机层面实现的，并没有直接暴露给我们</strong>。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以<strong>通过查看它的源代码，来看它是如何实现的</strong>。</li><li>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能：<ul><li><strong>支持超时</strong> ：<code>ReentrantLock</code> 提供了 <code>tryLock(timeout)</code> 的方法，可以指定等待获取锁的最长等待时间，如果超过了等待时间，就会获取锁失败，不会一直等待。</li><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够<strong>中断等待锁的线程</strong>的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说<strong>正在等待的线程可以选择放弃等待，改为处理其他事情。</strong><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能<strong>等到拿到锁以后才能进行其他的逻辑处理</strong>。 <code>synchronized</code> 就属于是不可中断锁。</li></ul></li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而**<code>synchronized</code>只能是非公平锁**。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。<ul><li><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现<strong>多路通知功能</strong>也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即<strong>对象监视器</strong>），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，</strong>在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知” ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而**<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例<strong>，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而</strong><code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。**</li></ul></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRentrantlock</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">ReentrantLock</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 1.1、第一次尝试获取锁，可以获取成功</span>            r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 1.2、此时锁的重入次数为 1</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lock() : lock count :"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 2、中断当前线程，通过 Thread.currentThread().isInterrupted() 可以看到当前线程的中断状态为 true</span>            <span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current thread is intrupted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 3.1、尝试获取锁，可以成功获取</span>            r<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 3.2、此时锁的重入次数为 2</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tryLock() on intrupted thread lock count :"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment">// 4、打印线程的中断状态为 true，那么调用 lockInterruptibly() 方法就会抛出 InterruptedException 异常</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current Thread isInterrupted:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                r<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lockInterruptibly() --NOt executable statement"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 5、打印锁的重入次数，可以发现 lockInterruptibly() 方法并没有成功获取到锁</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lockInterruptibly() not able to Acqurie lock: lock count :"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lock count :"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lock count :"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">MyRentrantlock</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRentrantlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token punctuation">.</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个<strong>可重入的读写锁</strong>，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><blockquote><p><code>ReentrantReadWriteLock</code> 内部维护了两个锁，一个是读锁（共享锁），一个是写锁（排他锁）。这两个锁是通过 AQS（AbstractQueuedSynchronizer，抽象队列同步器）来实现的。AQS 是一个用于构建锁和同步器的框架，它通过一个状态变量（<code>state</code>）来表示锁的状态。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantReadWriteLock</span>        <span class="token keyword">implements</span> <span class="token class-name">ReadWriteLock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ReadWriteLock</span> <span class="token punctuation">{</span>    <span class="token class-name">Lock</span> <span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Lock</span> <span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。<strong>读锁是共享锁，写锁是独占锁</strong>。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。<code>ReentrantReadWriteLock</code> 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</p><p>在<strong>读多写少</strong>的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能。</p><ul><li><strong>共享锁</strong>：一把锁可以被多个线程同时获得。</li><li><strong>独占锁</strong>：一把锁只能被一个线程获得。</li></ul><p>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</p><p><strong>在线程持有读锁的情况下，该线程不能取得写锁。</strong>在线程持有写锁的情况下，该线程可以继续获取读锁（可重入）。</p><p><strong>当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</strong></p><ol><li>读锁的获取与释放<ul><li><strong>获取读锁</strong>：多个线程可以同时获取读锁，只要没有线程持有写锁。在获取读锁时，会检查当前是否有线程持有写锁，如果没有，则将读锁的持有线程数增加。读锁的持有线程数是通过对 <code>state</code> 的高 16 位进行记录的。</li><li><strong>释放读锁</strong>：当线程释放读锁时，会将读锁的持有线程数减少。当读锁的持有线程数为 0 时，表示没有线程持有读锁。</li></ul></li><li>写锁的获取与释放<ul><li><strong>获取写锁</strong>：写锁是排他锁，同一时间只能有一个线程持有写锁。在获取写锁时，会检查当前是否有线程持有读锁或写锁，如果有，则当前线程会被阻塞，进入等待队列。如果没有，则将写锁的持有者设置为当前线程，并将 <code>state</code> 的低 16 位设置为 1，表示持有写锁。</li><li><strong>释放写锁</strong>：当线程释放写锁时，会将 <code>state</code> 的低 16 位设置为 0，表示不再持有写锁，并唤醒等待队列中的线程。</li></ul></li></ol><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的<strong>性能更好的读写锁</strong>，相比于 <code>ReentrantReadWriteLock</code> 等传统读写锁，它提供了更灵活和高效的并发控制方式。<strong>不可重入且不支持条件变量</strong> <code>Condition</code>。</p><p><code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。<code>StampedLock</code> 通过 CLH 队列进行线程的管理，通过同步状态值 <code>state</code> 来表示锁的状态和类型。</p><p><code>StampedLock</code> 使用一个 <code>stamp</code>（时间戳）来表示锁的状态。<code>stamp</code> 是一个长整型数值，它在每次获取锁或释放锁时都会发生变化。<code>StampedLock</code> 支持三种锁模式：写锁（独占锁）、悲观读锁和乐观读锁。</p><ul><li><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是<strong>不可重入</strong>的。</li><li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</li><li><strong>乐观读</strong>：<strong>允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</strong></li></ul><p><code>StampedLock</code> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是<code>StampedLock</code>不可重入的原因。</p><p><strong>StampedLock比ReentrantReadWriteLock性能更好，主要体现在以下几个方面：</strong><br>1、增加乐观读功能，减少写线程饥饿现象出现</p><p>​当线程尝试获取乐观读锁时，StampedLock 会检查当前是否有写锁被持有。如果没有，它会增加一个读锁计数器并返回一个 stamp（通常是当前状态的一个快照）。<strong>乐观读锁不会阻塞其他读线程或写线程</strong>，但可能在写线程获得锁后读取到不一致的数据。</p><p>2、StampedLock要比ReentrantReadWriteLock消耗小</p><p>3、StampedLock<strong>增加了更多的无锁操作</strong>，使线程间阻塞减少到最小。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，拥有自己的私有数据（专属本地变量）。如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的<strong>每个线程都会有这个变量的本地副本</strong>，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而<strong>避免了线程安全问</strong>题。</p><p>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</p><p><strong>对比synchronized</strong></p><p>ThreadLocal和Synchonized都用于解决<strong>多线程并发访问</strong>。但是ThreadLocal与synchronized有本质的区别：</p><p>1、Synchronized用于线程间的<strong>数据共享</strong>，而ThreadLocal则用于线程间的<strong>数据隔离</strong>。</p><p>2、Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的<strong>并不是同一个对象</strong>，这样就隔离了多个线程对数据的数据共享。</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><blockquote><p>一句话理解ThreadLocal，ThreadLocal是作为<strong>当前线程Thread中</strong>  属性ThreadLocalMap集合  中的<strong>某一个Entry的key值</strong>Entry（threadlocal, value），虽然不同的线程之间ThreadLocal这个key值是一样，但是不同的线程所拥有的<strong>ThreadLocalMap是独一无二的</strong>，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。</p></blockquote><p><strong>ThreadLocal的set()方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token comment">//......</span>    <span class="token comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护。存储线程本地变量</span>    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span>    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//......</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程<strong>调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法</strong>时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p><p><strong><code>ThreadLocalMap</code> 的结构</strong></p><p><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的静态内部类，本质是一个<strong>自定义哈希表</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>    <span class="token comment">// Entry 继承自 WeakReference，键是 ThreadLocal 实例</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token class-name">Object</span> value<span class="token punctuation">;</span>  <span class="token comment">// 实际存储的值</span>        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 键是弱引用</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>  <span class="token comment">// 哈希表数组</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>       <span class="token comment">// 元素数量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>  <span class="token comment">// 扩容阈值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//1、获取当前线程</span>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，</span>    <span class="token comment">//则直接更新要保存的变量值，否则创建threadLocalMap，并赋值</span>    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 初始化thradLocalMap 并赋值</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ThreadLocal set赋值的时候首先会获取当前线程thread，并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap，并将value值初始化。</p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong>比如在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 <strong>key 就是 <code>ThreadLocal</code>对象</strong>，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p><img src="/2024/06/15/java/threadlocal-data-structure.png" alt="ThreadLocal 数据结构" style="zoom:80%;"><h4 id="ThreadLocal-内存泄露问题是怎么导致的"><a href="#ThreadLocal-内存泄露问题是怎么导致的" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的"></a>ThreadLocal 内存泄露问题是怎么导致的</h4><p><code>ThreadLocalMap</code> 中使用的 <strong>key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。</strong>所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。<strong>AQS 就是一个抽象类，主要用来构建锁和同步器。</strong>使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractOwnableSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>AQS 解决了开发者在实现同步器时的复杂性问题。它提供了一个通用框架，用于实现各种同步器，例如 <strong>可重入锁</strong>（<code>ReentrantLock</code>）、<strong>信号量</strong>（<code>Semaphore</code>）和 <strong>倒计时器</strong>（<code>CountDownLatch</code>）。通过封装底层的线程同步机制，AQS 将复杂的线程管理逻辑隐藏起来，使开发者只需专注于具体的同步逻辑。</p><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>AQS 提供了一种通用的机制来实现阻塞锁和相关的同步器，其核心思想是通过一个 <strong>FIFO 队列</strong> 和一个 <strong>状态变量</strong> 来管理线程的阻塞和唤醒。如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为<strong>有效的工作线程</strong>，将共享资源设置为<strong>锁定状态</strong>；如果共享资源被占用，就需要一定的<strong>阻塞等待唤醒机制</strong>来保证锁分配。这个机制主要用的是<strong>CLH队列的变体</strong>实现的，将暂时获取不到锁的线程加入到队列中。<br>CLH:Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的<strong>虚拟双向队列(FIFO）</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），AQS是通过<strong>将每条请求共享资源的线程封装成一个节点</strong>来实现锁的分配。</p><p>CLH 锁通过引入一个队列来组织并发竞争的线程，对自旋锁进行了改进：</p><ul><li>每个线程会作为一个节点加入到队列中，并通过<strong>自旋监控前一个线程节点的状态</strong>，而不是直接竞争共享变量。</li><li>线程按顺序排队，确保公平性，从而避免了 “饥饿” 问题。</li></ul><p>AQS（AbstractQueuedSynchronizer）在 CLH 锁的基础上进一步优化，形成了其内部的 <strong>CLH 队列变体</strong>。主要改进点有以下两方面：</p><ul><li><p><strong>自旋 + 阻塞：</strong> CLH 锁使用纯自旋方式等待锁的释放，但<strong>大量的自旋操作会占用过多的 CPU 资源</strong>。AQS 引入了 自旋 + 阻塞 的混合机制： 如果线程获取锁失败，会先<strong>短暂自旋尝试获取锁</strong>；如果仍然失败，则线程会<strong>进入阻塞状态</strong>，等待被唤醒，从而减少 CPU 的浪费。</p></li><li><p><strong>单向队列改为双向队列</strong>：CLH 锁使用单向队列，节点只知道前驱节点的状态，而当某个节点释放锁时，需要通过队列唤醒后续节点。AQS 将队列改为 <strong>双向队列</strong>，新增了 <code>next</code> 指针，使得节点不仅知道前驱节点，也可以<strong>直接唤醒后继节点</strong>，从而<strong>简化了队列操作</strong>，提高了唤醒效率。</p></li></ul><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/clh-queue-state.png" alt="CLH 变体队列" style="zoom: 67%;"><p><strong>核心组件：</strong></p><ol><li><strong>状态变量（state）</strong>：表示<strong>共享资源的状态</strong>，可以是锁的持有次数、信号量的许可数等。通过 <code>getState()</code>、<code>setState()</code> 和 <code>compareAndSetState()</code> 方法操作。<ul><li>这里state的具体含义，会根据具体实现类的不同而不同：比如在Semapore里，他表示剩余许可证的数量；在CountDownLatch里，它表示还需要倒数的数量；在ReentrantLock中，state用来表示”锁”的占有情况，包括可重入计数，当state的值为O的时候，标识该Lock不被任何线程所占有。</li><li><strong>state是volatile修饰的</strong>，并被并发修改，所以修改state的方法都需要保证线程安全，比如getState、setState以及compareAndSetState操作来读取和更新这个状态。这些方法都依赖于unsafe类。</li></ul></li><li><strong>FIFO 队列</strong>：一个双向链表，用于存储等待获取资源的线程。每个节点（<code>Node</code>）包含线程（<code>thread</code>）、等待状态（<code>waitStatus</code>）和前驱/后继指针。<ul><li>这个队列用来存放“等待的线程，AQS就是“排队管理器”，当多个线程争用同一把锁时，必须有排队机制将那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁。</li></ul></li><li><strong>节点状态（waitStatus）</strong>：<code>CANCELLED</code>（1）：线程已取消。<code>SIGNAL</code>（-1）：当前节点的后继节点需要被唤醒。<code>CONDITION</code>（-2）：节点在条件队列中等待。<code>PROPAGATE</code>（-3）：共享模式下，释放资源时需要传播给后续节点。<ul><li>在 AQS 中，一个节点加入队列之后，初始状态为 <code>0</code> 。</li><li>当有新的节点加入队列，此时新节点的前继节点状态就会由 <code>0</code> 更新为 <code>SIGNAL</code> ，表示前继节点释放锁之后，需要对新节点进行唤醒操作。</li><li>如果一个节点在队列中等待获取锁锁时，因为某种原因失败了，该节点的状态就会变为 <code>CANCELLED</code> ，表明取消获取锁，这种状态的节点是异常的，无法被唤醒，也无法唤醒后继节点。</li></ul></li></ol><p><strong>同步状态的获取和释放</strong></p><ul><li>独占模式<ul><li><code>acquire(int arg)</code>：尝试以独占模式获取同步状态，如果获取失败则将当前线程加入到队列中等待。</li><li><code>release(int arg)</code>：尝试以独占模式释放同步状态，如果释放成功则唤醒队列中的后继节点。</li></ul></li><li>共享模式<ul><li><code>acquireShared(int arg)</code>：尝试以共享模式获取同步状态，如果获取失败则将当前线程加入到队列中等待。</li><li><code>releaseShared(int arg)</code>：尝试以共享模式释放同步状态，如果释放成功则唤醒队列中的后继节点。</li></ul></li></ul><p>基于 AQS 可以实现自定义的同步器， AQS 提供了 5 个模板方法（<strong>模板方法模式</strong>）。如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>自定义的同步器继承 <code>AbstractQueuedSynchronizer</code> 。</li><li>重写 AQS 暴露的模板方法。</li></ol><p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>什么是钩子方法呢？</strong> 钩子方法是一种被声明在抽象类中的方法，一般使用 <code>protected</code> 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p><p>获取资源：</p><ul><li><strong>acquire(int)<strong>：acquire是一种</strong>以独占方式获取资源</strong>，如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。该方法是独占模式下线程获取共享资源的顶层入口。获取到资源后，线程就可以去执行其临界区代码了。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>tryAcquire()</code> ：尝试获取锁（模板方法），<code>AQS</code> 不提供具体实现，由子类实现。</p></li><li><p><code>addWaiter()</code> ：如果获取锁失败，会将当前线程封装为 Node 节点加入到 AQS 的 CLH 变体队列中等待获取锁。</p></li><li><p><code>acquireQueued()</code> ：CAS对线程进行<strong>阻塞、唤醒</strong>，并调用 <code>tryAcquire()</code> 方法让队列中的线程尝试获取锁。</p></li></ul><p>在 <code>AQS</code> 中，当前节点的唤醒需要依赖于上一个节点。如果上一个节点取消获取锁，它的状态就会变为 <code>CANCELLED</code> ，<code>CANCELLED</code> 状态的节点没有获取到锁，也就无法执行解锁操作对当前节点进行唤醒。因此<strong>在阻塞当前线程之前，需要跳过 <code>CANCELLED</code> 状态的节点。</strong></p><p>shouldParkAfterFailedAcquire(Node pred, Node node)：调整前驱节点的waitStatus为SIGNAL，确保后续唤醒。</p><p>关于selfInterrupt：</p><ul><li>当 <code>if</code> 判断为 <code>true</code> 时，需要 <code>tryAcquire()</code> 返回 <code>false</code> ，并且 <code>acquireQueued()</code> 返回 <code>true</code> 。</li><li>其中 <code>acquireQueued()</code> 方法返回的是线程被唤醒之后的 <strong>中断状态</strong> ，通过执行 <code>Thread.interrupted()</code> 来返回。该方法在返回中断状态的同时，会清除线程的中断状态。</li><li>因此如果 <code>if</code> 判断为 <code>true</code> ，表明线程的中断状态为 <code>true</code> ，但是调用 <code>Thread.interrupted()</code> 之后，线程的中断状态被清除为 <code>false</code>，因此需要重新执行 <code>selfInterrupt()</code> 来重新设置线程的中断状态。</li></ul><blockquote><p>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；<br>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；<br>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果<strong>在整个等待过程中被中断过，则返回true</strong>（在true的情况下，才会执行selfInterrupt()），否则返回false。<br>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</p></blockquote><p>释放资源：</p><p>AQS 中以独占模式释放资源的入口方法是 <code>release()</code> ，主要做两件事：尝试释放锁和唤醒后继节点。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 1、尝试释放锁 -- 计算释放锁之后的 state 值，为0表明完全释放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 2、唤醒后继节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><p>核心参数，拒绝策略，任务提交流程，线程创建时机，销毁时机，线程池关闭</p><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h3><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p><strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。（池化技术，减少每次获取资源的消耗，提高对资源的利用率）</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的<strong>分配，调优和监控</strong>。</li></ul><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * 用给定的初始参数创建一个新的ThreadPoolExecutor。     */</span><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的核心线程数量</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的最大线程数</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment">//===当线程数大于核心线程数时===，多余的空闲线程存活的最长时间</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span><span class="token comment">//时间单位</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span><span class="token comment">//任务队列，用来储存等待执行任务的队列</span>                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span><span class="token comment">//线程工厂，用来创建线程，一般默认即可</span>                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token comment">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>                         <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最重要的三个参数：</p><ul><li><code>corePoolSize</code> : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><code>maximumPoolSize</code> : 任务队列中存放的任务达到队列容量的时候，<strong>当前可以同时运行的线程数量变为最大线程数。</strong></li><li><code>workQueue</code>: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><strong>使用示例</strong></p><ul><li>execute用于提交不需要返回值的任务。</li><li>submit用于提交需要返回值的任务。</li><li>shutdown平缓关闭线程池，不再接受新任务，<strong>已提交任务继续执行。</strong></li><li>shutdownNow试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 实际项目中使用ThreadPoolExecutor的示例</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">RequestHandler</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maxPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">int</span> queueCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>queueCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maxPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 提交一个任务</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 停止线程池的方法，通常在服务停止时调用</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><p>如果<strong>当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时</strong>，<code>ThreadPoolExecutor</code> 定义一些策略:</p><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行自己的线程运行任务，也就是<strong>直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务</strong>。因此这种策略会<strong>降低对于新任务提交速度</strong>，影响程序的整体性能。如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。<ul><li>将任务回退给调用者，使用调用者的线程来执行任务。除非线程池被停止或任务队列已有空缺。</li></ul></li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：不做任何处理，直接丢弃掉，静默拒绝新任务。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃最早的未处理的任务请求，然后执行当前任务。</li><li>自定义拒绝策略：实现RejectedExecutionHandler接口来自定义拒绝策略。</li></ul><p>如果不允许丢弃任务，只能选择CallerRunsPolicy，<strong>问题</strong>：如果走到<code>CallerRunsPolicy</code>的任务是个非常耗时的任务，且处理提交任务的线程是主线程，可能会<strong>导致主线程阻塞，影响程序的正常运行。</strong></p><p><strong>解决思路</strong></p><p>我们从问题的本质入手，调用者采用<code>CallerRunsPolicy</code>是<strong>希望所有的任务都能够被执行</strong>，暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中。这样的话，在内存允许的情况下，我们可以<strong>增加阻塞队列<code>BlockingQueue</code>的大小</strong>并调整堆内存以容纳更多的任务，确保任务能够被准确执行。</p><p>为了充分利用 CPU，我们还可以调整线程池的<code>maximumPoolSize</code> （最大线程数）参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</p><p><strong>进一步：为了保证任务不被丢弃且后续能被处理，可以把任务持久化到数据库/缓存/消息队列</strong></p><p>如果服务器资源已达到可利用的极限，这就意味我们要在<strong>设计策略</strong>上改变线程池的调度了，我们都知道，导致主线程卡死的本质就是因为我们不希望任何一个任务被丢弃。换个思路，有没有办法<strong>既能保证任务不被丢弃且在服务器有余力时及时处理呢？</strong></p><p>这里提供的一种<strong>任务持久化</strong>的思路，这里所谓的任务持久化，包括但不限于:</p><ol><li>设计一张任务表将任务存储到 MySQL 数据库中。</li><li><code>Redis</code>缓存任务。</li><li>将任务提交到消息队列中。</li></ol><h3 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h3><p><strong>1. 固定大小的线程池（FixedThreadPool）</strong></p><ul><li><p>核心线程数（corePoolSize）和最大线程数（maximumPoolSize）相等。</p></li><li><p>使用<strong>无界队列</strong>（<code>LinkedBlockingQueue</code>）存储任务。</p></li><li><p><strong>线程池中的线程数量固定，不会动态增加或减少。</strong></p></li><li><p>适合任务数量稳定且需要限制并发线程数的场景。例如：Web 服务器的请求处理。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> fixedThreadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 10 个线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>2. 缓存线程池（CachedThreadPool）</strong></p><ul><li><p>核心线程数为 0，最大线程数为 <code>Integer.MAX_VALUE</code>。（<strong>线程数量不固定</strong></p></li><li><p>使用<strong>直接传递队列</strong>（<code>SynchronousQueue</code>），<strong>任务不会排队，直接交给线程执行。</strong></p></li><li><p>空闲线程的存活时间为 60 秒，超过时间后会被回收。</p></li><li><p>适合任务数量不确定且任务处理时间短的场景。例如：短时异步任务处理。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> cachedThreadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>3. 单线程线程池（SingleThreadExecutor）</strong></p><ul><li><p>核心线程数和最大线程数均为 1。</p></li><li><p>使用<strong>无界队列</strong>（<code>LinkedBlockingQueue</code>）存储任务。</p></li><li><p><strong>保证所有任务按顺序执行。</strong></p></li><li><p>适合需要顺序执行任务的场景。例如：日志记录、任务调度。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> singleThreadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>4. 定时任务线程池（ScheduledThreadPool）</strong></p><ul><li><p>核心线程数由用户指定，最大线程数为 <code>Integer.MAX_VALUE</code>。</p></li><li><p>使用<strong>延迟队列</strong>（<code>DelayedWorkQueue</code>）存储任务。</p></li><li><p>支持定时任务和周期性任务。</p></li><li><p>适合需要定时执行或周期性执行任务的场景。例如：定时数据同步、心跳检测。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ScheduledExecutorService</span> scheduledThreadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 延迟 10 秒后执行任务</span>scheduledThreadPool<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task executed"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 延迟 10 秒后，每隔 5 秒执行一次任务</span>scheduledThreadPool<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task executed"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>5.单线程定时任务线程池（SingleThreadScheduledExecutor）</strong></p><p>用于在单个线程中调度定时任务或周期性任务。</p><p><strong>6. 工作窃取线程池（WorkStealingPool）</strong></p><ul><li><p>基于 ForkJoinPool 实现。</p></li><li><p>线程池中的线程可以窃取其他线程的任务，充分利用 CPU 资源。</p></li><li><p>默认线程数为 CPU 核心数。</p></li><li><p>适合任务可以拆分为子任务的场景。例如：并行计算、分治算法。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> workStealingPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newWorkStealingPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>7. 自定义线程池（ThreadPoolExecutor）</strong></p><ul><li>通过 <code>ThreadPoolExecutor</code> 类自定义线程池参数。</li><li>可以灵活设置核心线程数、最大线程数、队列类型、线程存活时间、拒绝策略等。</li></ul><h3 id="线程池常用阻塞队列"><a href="#线程池常用阻塞队列" class="headerlink" title="线程池常用阻塞队列"></a>线程池常用阻塞队列</h3><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code><strong>（无界队列）</strong>：<code>FixedThreadPool</code>（可重用固定线程数的线程池） 和 <code>SingleThreadExector</code> 。<code>FixedThreadPool</code>最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code>SingleThreadExector</code>只能创建一个线程（核心线程数和最大线程数都是 1），二者的<strong>任务队列永远不会被放满。</strong></li><li><code>SynchronousQueue</code><strong>（同步队列）</strong>：<code>CachedThreadPool</code>（根据需要创建新线程的线程池） 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为<strong>线程数是可以无限扩展的，可能会创建大量线程</strong>，从而导致 OOM。<ul><li><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</li></ul></li><li><code>DelayedWorkQueue</code><strong>（延迟阻塞队列）</strong>：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会<strong>按照延迟的时间长短对任务进行排序</strong>，内部采用的是“堆”的数据结构，可以保证<strong>每次出队的任务都是当前队列中执行时间最靠前的</strong>。<code>DelayedWorkQueue</code> <strong>添加元素满了之后会自动扩容</strong>原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><p>对比：Java 中常用的阻塞队列实现类有以下几种：</p><ol><li><code>ArrayBlockingQueue</code>：使用<strong>数组</strong>实现的有界阻塞队列。<strong>在创建时需要指定容量大小</strong>，并支持公平和非公平两种方式的锁访问机制。</li><li><code>LinkedBlockingQueue</code>：使用<strong>单向链表</strong>实现的<strong>可选有界</strong>阻塞队列。在创建时可以指定容量大小，如果<strong>不指定则默认为<code>Integer.MAX_VALUE</code><strong>。和<code>ArrayBlockingQueue</code>不同的是， 它仅支持</strong>非公平</strong>的锁访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的<strong>无界</strong>阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</li><li><code>SynchronousQueue</code>：<strong>同步队列</strong>，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：<strong>延迟队列</strong>，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li></ol><p>假如我们需要实现一个优先级任务线程池的话，那可以考虑使用 <code>PriorityBlockingQueue</code> （<strong>优先级阻塞队列</strong>）作为任务队列（<code>ThreadPoolExecutor</code> 的构造函数有一个 <code>workQueue</code> 参数可以传入任务队列）。</p><h4 id="优先级任务队列"><a href="#优先级任务队列" class="headerlink" title="优先级任务队列"></a>优先级任务队列</h4><p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列，可以看作是线程安全的 <code>PriorityQueue</code>，两者底层都是使用小顶堆形式的二叉堆，即值最小的元素优先出队。不过，<code>PriorityQueue</code> 不支持阻塞操作。</p><p>要想让 <code>PriorityBlockingQueue</code> 实现对任务的排序，<strong>传入其中的任务必须是具备排序能力</strong>的，方式有两种：</p><ol><li>提交到线程池的任务实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来指定任务之间的优先级比较规则。</li><li><strong>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</strong></li></ol><p>不过，这存在一些风险和问题，比如：</p><ul><li><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。<ul><li>解决：继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，<strong>当插入的元素数量超过指定值就返回 false 。</strong></li></ul></li><li>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。<ul><li>解决：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</li></ul></li><li>由于需要对队列中的元素进行<strong>排序操作以及保证线程安全</strong>（并发控制采用的是可重入锁 <code>ReentrantLock</code>），因此会降低性能。</li></ul><h3 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h3><img src="/2024/06/15/java/thread-pool-principle.png" alt="图解线程池实现原理" style="zoom:80%;"><ul><li>如果当前运行的线程数小于核心线程数，那么就会<strong>新建一个线程</strong>来执行任务。<ul><li>当提交一个新任务到线程池时，如果线程池中的线程数量小于核心线程数，<strong>即使其他工作线程是空闲的，也会创建一个新线程来处理该任务。</strong></li></ul></li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（<strong>任务队列已经满了</strong>），但是当前运行的线程数是小于最大线程数的，就<strong>创建一个新线程来执行当前提交的任务</strong>。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ul><h3 id="线程异常后，销毁还是复用"><a href="#线程异常后，销毁还是复用" class="headerlink" title="线程异常后，销毁还是复用"></a>线程异常后，销毁还是复用</h3><p><strong>使用<code>execute()</code>提交任务</strong>：当任务通过<code>execute()</code>提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么<strong>该异常会导致当前线程终止</strong>，并且异常会被打印到控制台或日志文件中。<strong>线程池会检测到这种线程终止，并创建一个新线程来替换它</strong>，从而保持配置的线程数不变。</p><p><strong>使用<code>submit()</code>提交任务</strong>：对于通过<code>submit()</code>提交的任务，如果在任务执行中发生异常，<strong>这个异常不会直接打印出来</strong>。相反，异常会被<strong>封装在由<code>submit()</code>返回的<code>Future</code>对象</strong>中。当调用<code>Future.get()</code>方法时，可以捕获到一个<code>ExecutionException</code>。在这种情况下，<strong>线程不会因为异常而终止</strong>，它会继续存在于线程池中，准备执行后续的任务。</p><h3 id="execute和submit区别"><a href="#execute和submit区别" class="headerlink" title="execute和submit区别"></a>execute和submit区别</h3><p>1、<strong>返回结果</strong>：submit()方法可以接受并<strong>返回Future对象，用于表示异步任务的结果</strong>。你可以通过Future对象获取任务的执行结果，或者等待任务执行完成。而execute()方法没有返回值，无法获取任务的执行结果。<br>2、<strong>异常处理</strong>：submit()方法能够处理任务执行过程中抛出的异常。你可以通过调用Future对象的get()方法来获取任务执行过程中的异常，或者通过捕获ExecutionException异常来处理异常情况。而execute()方法无法处理任务执行过程中的异常，异常会被传播到线程池的未捕获异常处理器(UncaughtExceptionHandler)。<br>3、<strong>方法重载</strong>：submit()方法有多种重载形式，可以接受<strong>Runnable、Callable和其他可执行任务作为参数</strong>。它们的返回值类型分别为Future、Future和Future，其中T为Callable返回结果的类型。这使得submit()方法更加灵活，可以处理不同类型的任务。而<strong>execute()方法只接受Runnable类型的任务作为参数</strong>，没有方法重载的选项。</p><h3 id="Runnable与Callable"><a href="#Runnable与Callable" class="headerlink" title="Runnable与Callable"></a>Runnable与Callable</h3><ul><li>Callable规定的方法是 call(), Runnable规定的方法是 run()。</li><li>Callable的任务执行后可返回值，而 Runnable的任务是不能返回值。</li><li>call方法可以抛出异常， run方法不可以。</li><li>运行 Callable任务可以拿到一个 Future对象</li></ul><h3 id="shutdown-VS-shutdownNow"><a href="#shutdown-VS-shutdownNow" class="headerlink" title="shutdown()  VS  shutdownNow()"></a>shutdown()  VS  shutdownNow()</h3><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是<strong>队列里的任务得执行完毕。</strong></li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程池的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated()  VS  isShutdown()"></a>isTerminated()  VS  isShutdown()</h3><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h3 id="设定线程池大小"><a href="#设定线程池大小" class="headerlink" title="设定线程池大小"></a>设定线程池大小</h3><ul><li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现<strong>任务队列满了之后任务/请求无法处理</strong>的情况，或者<strong>大量任务堆积在任务队列导致 OOM</strong>。这样很明显是有问题的，CPU 根本没有得到充分利用。</li><li>如果我们设置线程数量太大，<strong>大量线程可能会同时在争取 CPU 资源</strong>，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li></ul><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。<strong>过多的线程会导致频繁的上下文切换，反而降低性能。</strong>比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。<ul><li><strong>最大线程数（maximumPoolSize）</strong>：与核心线程数相同，避免创建过多线程。</li><li><strong>队列容量（workQueue）</strong>：使用有界队列（如 <code>ArrayBlockingQueue</code>），防止任务堆积。</li><li><strong>拒绝策略（RejectedExecutionHandler）</strong>：根据业务需求选择。</li></ul></li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。<strong>由于任务会频繁等待 IO，可以创建更多线程以充分利用 CPU。</strong><ul><li><strong>最大线程数（maximumPoolSize）</strong>：根据任务的平均等待时间和 CPU 负载动态调整。<ul><li>可以设置为较大的值（如 <code>2 * CPU 核心数 + 1</code> 或更高）。</li></ul></li></ul></li></ul><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><img src="/2024/06/15/java/image-20250313151853353.png" alt="image-20250313151853353" style="zoom: 67%;"><img src="/2024/06/15/java/image-20250313152029216.png" alt="image-20250313152029216" style="zoom:67%;"><h3 id="线程池实践规范"><a href="#线程池实践规范" class="headerlink" title="线程池实践规范"></a>线程池实践规范</h3><p>线程池必须手动通过 <code>ThreadPoolExecutor</code> 的构造函数来声明，避免使用<code>Executors</code>类创建线程池，会有 OOM 风险。<strong>使用有界队列，控制线程创建数量。</strong></p><p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p><ul><li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该<strong>显示地给我们的线程池命名</strong>，这样有助于我们定位问题。</li></ul><p><strong>不同的业务使用不同的线程池</strong>，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。如果<strong>父业务和子业务调用同一个线程池，可能产生死锁；</strong></p><p>当线程池不再需要使用时，应该<strong>显式地关闭线程池</strong>，释放线程资源。</p><p>调用完 <code>shutdownNow</code> 和 <code>shuwdown</code> 方法后，并不代表线程池已经完成关闭操作，它只是<strong>异步的通知线程池进行关闭处理</strong>。如果要同步等待线程池彻底关闭后才继续往下执行，需要调用<code>awaitTermination</code>方法进行同步等待。</p><p>在调用 <code>awaitTermination()</code> 方法时，应该设置合理的超时时间，以避免程序长时间阻塞而导致性能问题。另外。由于线程池中的任务可能会被取消或抛出异常，因此在使用 <code>awaitTermination()</code> 方法时还需要进行异常处理。<code>awaitTermination()</code> 方法会抛出 <code>InterruptedException</code> 异常，需要捕获并处理该异常，以避免程序崩溃或者无法正常退出。</p><p>线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。</p><p>因此，在使用线程池时，我们应该<strong>尽量避免将耗时任务提交到线程池中执行</strong>。对于一些比较耗时的操作，如网络请求、文件读写等，可以采用<strong>异步操作</strong>的方式来处理，以避免阻塞线程池中的线程</p><p>线程池和 <code>ThreadLocal</code>共用，可能会导致线程从<code>ThreadLocal</code>获取到的是旧值/脏数据。这是因为<strong>线程池会复用线程对象</strong>，与线程对象绑定的类的静态属性 <code>ThreadLocal</code> 变量也会被重用，这就导致一个线程可能获取到其他线程的<code>ThreadLocal</code> 值。</p><h2 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h2><p><code>Future</code> 是 Java 提供的一个接口，用于表示异步计算的结果。它允许我们在一个线程中提交一个任务，然后在另一个线程中获取任务的执行结果。虽然 <code>Future</code> 提供了一种简单的方式来进行异步编程，但它的功能有限，不能很好地处理复杂的并发场景。这其实就是<strong>多线程中</strong>经典的 <strong>Future 模式</strong>，你可以将其看作是<strong>一种设计模式，核心思想是异步调用，主要用在多线程领域</strong>，并非 Java 语言独有。</p><ul><li><strong>Callable</strong>：代表一个可异步执行的任务，通常包含需要返回结果的逻辑。</li></ul><ul><li><strong>Future</strong>：作为异步计算的<strong>句柄</strong>，用于跟踪任务状态（如是否完成、取消）和获取结果。任务提交后立即返回 Future，允许程序继续执行其他操作。</li></ul><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；mayInterruptIfRunning参数表示是否允许中断已经</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// V 代表了Future执行的任务返回值的类型</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">// 取消任务执行</span>    <span class="token comment">// 成功取消返回 true，否则返回 false</span>    <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断任务是否被取消</span>    <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断任务是否已经执行完成</span>    <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取任务执行结果</span>    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">;</span>    <span class="token comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span>    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>FutureTask 提供了 Future 接口的基本实现</strong>，常用来封装 Callable 和 Runnable。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。FutureTask 实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p><p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为<code>Callable</code> 对象。</p><p><strong><code>FutureTask</code>相当于对<code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建线程池</span>        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 提交任务并获取 Future 对象</span>        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 模拟耗时操作</span>            <span class="token keyword">return</span> <span class="token string">"Task completed"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task submitted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">// 获取任务结果（阻塞直到任务完成）</span>            <span class="token class-name">String</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task result: "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> <span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 关闭线程池</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p><code>Future</code> 在实际使用过程中存在一些局限性比如<strong>不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</strong></p><p>Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了<strong>函数式编程、异步任务编排组合</strong>（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><p><code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。</p><img src="/2024/06/15/java/completablefuture-class-diagram.jpg" alt="img" style="zoom:80%;"><p><code>CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。<code>CompletionStage</code> 接口中的方法比较多，**<code>CompletableFuture</code> 的函数式能力就是这个接口赋予的。**</p><p><strong>创建方式：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> supplier<span class="token punctuation">)</span><span class="token comment">//自定义线程，根据supplier构建执行任务  -- supply支持返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> supplier<span class="token punctuation">,</span> <span class="token class-name">Executor</span> executor<span class="token punctuation">)</span><span class="token comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据runnable构建执行任务</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">)</span> <span class="token comment">//自定义线程，根据runnable构建执行任务   --- run不支持返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">,</span>  <span class="token class-name">Executor</span> executor<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>获取结果：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCompletableGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span> <span class="token punctuation">{</span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cp1 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">"商品A"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// getNow方法测试 -- 立即获取结果不阻塞，结果计算已完成将返回结果或计算过程中的异常，如果未计算完成将返回设定的 valueIfAbsent 参数值，这里会输出商品B，因为cp1没有执行完成，getNow就已经获取了</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cp1<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token string">"商品B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//join方法测试 </span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> cp2 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// join 方法获取结果方法里不会抛异常，但是执行结果会抛异常，抛出的异常为 CompletionException</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cp2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//get方法测试</span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> cp3 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// get 方法获取结果方法里将抛出异常，执行结果抛出的异常为 ExecutionException</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cp3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>异步回调：</strong></p><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>作用</strong></th><th align="left"><strong>返回值</strong></th></tr></thead><tbody><tr><td align="left"><code>thenApply</code></td><td align="left">对任务结果进行转换，<strong>有传参，有返回值</strong></td><td align="left"><code>CompletableFuture&lt;U&gt;</code></td></tr><tr><td align="left"><code>thenAccept</code></td><td align="left"><strong>消费任务结果</strong>，有传参，不返回新值</td><td align="left"><code>CompletableFuture&lt;Void&gt;</code></td></tr><tr><td align="left"><code>thenRun</code></td><td align="left"><strong>在任务完成后执行操作</strong>，无传参，无返回值</td><td align="left"><code>CompletableFuture&lt;Void&gt;</code></td></tr><tr><td align="left"><code>thenCompose</code></td><td align="left">将两个任务串联。</td><td align="left"><code>CompletableFuture&lt;U&gt;</code></td></tr><tr><td align="left"><code>thenCombine</code></td><td align="left">将两个任务的结果合并。</td><td align="left"><code>CompletableFuture&lt;U&gt;</code></td></tr><tr><td align="left"><code>allOf</code></td><td align="left"><strong>等待所有任务完成。</strong></td><td align="left"><code>CompletableFuture&lt;Void&gt;</code></td></tr><tr><td align="left"><code>anyOf</code></td><td align="left">等待任意一个任务完成。</td><td align="left"><code>CompletableFuture&lt;Object&gt;</code></td></tr><tr><td align="left"><code>exceptionally**</code></td><td align="left"><strong>处理异常，返回默认值。</strong></td><td align="left"><code>CompletableFuture&lt;T&gt;</code></td></tr><tr><td align="left"><code>handle</code></td><td align="left">处理结果和异常，返回新结果。</td><td align="left"><code>CompletableFuture&lt;U&gt;</code></td></tr><tr><td align="left"><code>whenComplete</code></td><td align="left"><strong>在任务完成后执行操作，可访问结果和异常。</strong></td><td align="left"><code>CompletableFuture&lt;T&gt;</code></td></tr><tr><td align="left"><code>supplyAsync</code></td><td align="left">异步执行有返回值的任务。</td><td align="left"><code>CompletableFuture&lt;T&gt;</code></td></tr><tr><td align="left"><code>runAsync</code></td><td align="left">异步执行无返回值的任务。</td><td align="left"><code>CompletableFuture&lt;Void&gt;</code></td></tr><tr><td align="left"><code>complete</code></td><td align="left">手动完成任务并设置结果。</td><td align="left"><code>boolean</code></td></tr><tr><td align="left"><code>completeExceptionally</code></td><td align="left">手动完成任务并设置异常。</td><td align="left"><code>boolean</code></td></tr><tr><td align="left"><code>getNow</code></td><td align="left">获取任务结果，未完成则返回默认值。</td><td align="left"><code>T</code></td></tr></tbody></table><p><strong>「thenRun 和 thenRunAsync 有什么区别呢？」</strong></p><p>如果你执行第一个任务的时候，传入了一个自定义线程池：</p><ul><li>调用 thenRun 方法执行第二个任务时，则第二个任务和第一个任务是共用同一个线程池。</li><li>调用 thenRunAsync 执行第二个任务时，则第一个任务使用的是你自己传入的线程池，第二个任务使用的是 ForkJoin 线程池。</li></ul><p><code>说明</code>:  thenAccept 和 thenAcceptAsync，thenApply 和 thenApplyAsync 等，它们之间的区别也是这个。</p><hr><img src="https://cdn.tobebetterjavaer.com/paicoding/2be0942bcbe746228e00b7f87a70c3a4.jpg" alt="img" style="zoom:50%;"><p><strong><code>thenCompose</code></strong></p><ul><li><p><strong>作用</strong>：将两个任务串联起来，前一个任务的结果作为后一个任务的输入。</p></li><li><p><strong>返回值</strong>：返回一个新的 <code>CompletableFuture</code>。</p></li><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">thenCompose</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> s <span class="token operator">+</span> <span class="token string">" World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p><strong><code>thenCombine</code></strong></p><ul><li><p><strong>作用</strong>：将两个任务的结果合并。</p></li><li><p><strong>返回值</strong>：返回一个新的 <code>CompletableFuture</code>。</p></li><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future1 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future2 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> future1<span class="token punctuation">.</span><span class="token function">thenCombine</span><span class="token punctuation">(</span>future2<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> s1 <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong><code>allOf</code></strong></p><ul><li><p><strong>作用</strong>：等待所有任务完成。</p></li><li><p><strong>返回值</strong>：返回一个 <code>CompletableFuture&lt;Void&gt;</code>。</p></li><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future1 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future2 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> allFutures <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>future1<span class="token punctuation">,</span> future2<span class="token punctuation">)</span><span class="token punctuation">;</span>allFutures<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待所有任务完成</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>注意事项：Future 需要获取返回值，才能获取到异常信息。如果不加 <code>get()/join()</code>方法，看不到异常信息。</p><p><strong>自定义线程池</strong></p><p><code>CompletableFuture</code> 默认使用全局共享的 <code>ForkJoinPool.commonPool()</code> 作为执行器，所有未指定执行器的异步任务都会使用该线程池。这意味着应用程序、多个库或框架（如 Spring、第三方库）若都依赖 <code>CompletableFuture</code>，<strong>默认情况下它们都会共享同一个线程池</strong>。</p><p>虽然 <code>ForkJoinPool</code> 效率很高，但<strong>当同时提交大量任务时，可能会导致资源竞争和线程饥饿</strong>，进而影响系统性能。</p><p>为避免这些问题，建议为 <code>CompletableFuture</code> 提供自定义线程池，带来以下优势：</p><ul><li><strong>隔离性</strong>：为不同任务分配独立的线程池，避免全局线程池资源争夺。</li><li><strong>资源控制</strong>：根据任务特性调整线程池大小和队列类型，优化性能表现。</li><li><strong>异常处理</strong>：通过自定义 <code>ThreadFactory</code> 更好地处理线程中的异常情况。</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>字节码文件(.class)会通过类加载器加载到JVM虚拟机中，接下来JVM虚拟机就会执行其中的字节码指令。我们把<strong>JVM虚拟机被分配的内存</strong>叫做运行时数据区域。而<strong>内存模型</strong>就是指<strong>运行时数据区域中被划分的不同区域。</strong></p><ul><li>JDK1.6：<strong>字符串常量池</strong>存放在<strong>方法区</strong>中，方法区存放在<strong>堆中</strong>；此时方法区的实现叫永久代。</li><li>JDK1.7：字符串常量池离开方法区，直接存放在堆内存；</li><li>JDK1.8：方法区发生移动，从<strong>JVM虚拟机内存</strong>中，移动到<strong>本地内存</strong>中。此时方法区的实现叫元空间。<ul><li><strong>运行时常量池在元空间</strong>，元空间和直接内存都属于本地内存。</li><li>元空间属于JVM 运行时数据区域，而直接内存不属于。</li></ul></li></ul><p><code>Java</code>虚拟机（<code>JVM</code>）的内存模型是<code>Java</code>程序<strong>运行时内存管理的基础</strong>。它定义了<code>Java</code>程序如何<strong>在内存中分配、使用和回收资源</strong>。</p><img src="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" alt="img" style="zoom:67%;"><p>线程私有程序计数器，虚拟机栈，本地方法栈（在并发–线程里面也记录了）</p><p>JVM内存结构如下：</p><ul><li><strong>元空间：</strong>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存。</strong><ul><li>从Java 8开始，永久代(Permanent Generation)被元空间取代，用于存储类的元数据信息，如类的结构信息(如字段、方法信息等）。元空间并不在Java堆中，而是使用本地内存，这<strong>解决了永久代容易出现的内存溢出问题。</strong></li><li><strong>方法区存储内容：类信息（结构信息、访问修饰符、父类与接口信息）、类中常量、类和方法的符号引用及运行时常量池、常量池缓存、静态变量、方法字节码</strong></li></ul></li><li><strong>Java虚拟机栈：</strong>每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了<strong>局部变量表（基本数据类型和对象引用）、操作数栈、方法出口</strong>等信息。栈的大小可以固定也可以动态扩展。</li><li><strong>本地方法栈：</strong>与虚拟机栈类似，区别是虚拟机栈执行Java方法，<strong>本地方法栈执行native方法</strong>。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。</li><li><strong>程序计数器：</strong>程序计数器可以看成是当前线程所执行的<strong>字节码的行号指示器</strong>。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有”内存。</li><li><strong>堆内存：</strong>堆内存是JVM所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的<strong>对象实例和数组</strong>都在堆上分配，这部分空间<strong>可通过GC进行回收</strong>。当申请不到空间时会抛出OutOfMemoryError。堆是JVM内存占用最大、管理最复杂的一个区域。</li><li><strong>直接内存：</strong>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在JDK1.4中新加入了NIO类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以<strong>使用native函数库直接分配堆外内存</strong>，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引l用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li></ul><p>为啥要把方法区从JVM内存（永久代）移到本地内存（元空间）？主要有两个原因：</p><ol><li>本地内存属于本地系统的IO操作，具有更高的一个IO操作性能，而JVM的堆内存这种，<strong>如果有IO操作，也是先复制到直接内存，然后再去进行本地IO操作</strong>。经过了一系列的中间流程，性能就会差一些。非直接内存操作：<code>本地IO操作——&gt;直接内存操作——&gt;非直接内存操作——&gt;直接内存操作——&gt;本地IO操作</code>，而直接内存操作：<code>本地IO操作——&gt;直接内存操作——&gt;本地IO操作</code>。</li><li>永久代有一个无法调整更改的JVM固定大小上限，回收不完全时，会出现<code>OutOfMemoryError</code>问题；而<strong>本地内存（元空间）是受到本地机器内存的限制，不会有这种问题。</strong></li></ol><img src="/2024/06/15/java/constant-pool-20240604095423.png" alt="字符串常量池的位置变化" style="zoom: 33%;"><h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><p>JVM内存模型里堆vs栈：</p><ul><li><strong>用途：</strong>栈存储<strong>局部变量、方法调用参数、方法返回地址和临时数据</strong>，每个线程有独立的栈，用于支持方法执行。每当一个方法被调用，一个<strong>栈帧</strong>就会在栈中创建，用于存储该方法的信息，方法执行完毕栈帧就被移除。堆存储所有<strong>对象实例</strong>和<strong>数组</strong>，是JVM中最大的一块内存区域。所有线程共享堆内存。</li><li><strong>可见性：</strong>堆-所有线程共享，需处理并发安全问题（如通过锁或CAS）。栈-线程私有，生命周期与线程一致，无需考虑多线程同步。</li><li><strong>生命周期：</strong>堆-<strong>对象的生命周期由垃圾回收</strong>器（GC）管理，对象不再被引用时会被回收。<strong>栈-内存自动分配和释放。</strong>方法执行时创建栈帧，方法结束后<strong>栈帧弹出，内存立即回收。</strong></li><li><strong>存储内容：</strong>堆-存储对象实例（如 new Object()）和静态变量（在方法区，Java 8后移至元空间）。栈-存储基本数据类型（如 int、boolean）和对象引用（如 Object obj = new MyObject（）中的 obj）。</li><li><strong>存取速度：</strong>栈-访问速度更快（直接操作栈顶，后进先出，无碎片问题）。堆-访问较慢（对象在堆上的分配和回收耗时长，需通过引用寻址，可能涉及内存碎片和GC开销）。</li></ul><h4 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h4><p>在Java虚拟机（JVM）中，<strong>堆（Heap）</strong> 是内存管理的核心区域，用于存储<strong>对象实例</strong>和<strong>数组</strong>。为了提高垃圾回收（GC）效率，<strong>堆被划分为不同的代（Generations）</strong>，每个代针对对象的生命周期特点采用不同的管理策略。</p><p>堆的分代基于<strong>分代收集理论（Generational Collection Theory）</strong>，核心思想是：</p><ul><li><strong>大部分对象是“朝生夕死”的</strong>（如临时对象、局部变量）。</li><li><strong>存活较久的对象</strong>（如缓存、全局配置）会逐渐晋升到老年代。</li><li>不同代的GC频率和策略不同，以优化性能。</li></ul><img src="https://cdn.xiaolincoding.com//picgo/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png" alt="img" style="zoom:67%;"><ul><li><strong>新生代(Young Generation)<strong>：新生代分为Eden Space和Survivor Space。在Eden Space中，大多数新创建的对象首先存放在这里。当Eden区满时，会触发一次MinorGC(新生代垃圾回收)。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0(Survivor 0)和S1(Survivor 1)。在每次MinorGC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。</strong>这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</strong></li><li><strong>Eden区</strong><ul><li><strong>作用</strong>：大多数<strong>新创建的对象</strong>首先分配在Eden区。</li><li><strong>特点</strong>：<ul><li>占新生代的绝大部分空间（默认比例：<code>Eden : Survivor（s0和s1） = 8:1:1</code>，可通过 <code>-XX:SurvivorRatio</code> 调整）。</li><li>频繁触发<strong>Minor GC</strong>（针对新生代的垃圾回收）。</li></ul></li><li><strong>对象分配</strong>：<ul><li>当Eden区满时，触发Minor GC，<strong>存活对象被复制到Survivor区。</strong></li><li>若对象过大（如大数组），可能直接进入老年代（避免复制开销）。</li></ul></li></ul></li><li><strong>Survivor区（From &amp; To）</strong><ul><li><strong>作用</strong>：存放<strong>从Eden区或另一个Survivor区晋升的存活对象</strong>。</li><li><strong>特点</strong>：<ul><li>两个Survivor区（From和To）大小相等，始终有一个是空的。</li><li>采用<strong>复制算法</strong>：Minor GC时，存活对象从Eden和From区复制到To区，并清空原区域。</li><li>对象每经历一次Minor GC，年龄（Age）加1。</li></ul></li><li><strong>晋升老年代</strong>：<ul><li>对象年龄达到阈值（默认15，通过 <code>-XX:MaxTenuringThreshold</code> 配置）。</li><li>Survivor区空间不足时，存活对象直接进入老年代。</li></ul></li></ul></li><li><strong>老年代(Old Generation/TenuredGeneration)：</strong>经过一次或多次MinorGC仍存活的对象会被移动到老年代。<strong>老年代中的对象生命周期较长</strong>，因此MajorGC(也称为Full GC，涉及老年代的垃圾回收)发生的频率相对较低，<strong>但其执行时间通常比MinorGC长</strong>。老年代的空间通常比新生代大，以存储更多的长期存活对象。<ul><li><strong>大对象区(Large Object Space/Humongous Objects)：</strong>在某些JVM实现中(如G1垃圾收集器)，为大对象分配了专门的区域，称为大对象区或HumongousObjects区域。<strong>大对象是指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代</strong>，以避免因频繁的年轻代晋升而导致的内存碎片化问题。</li></ul></li></ul><h5 id="堆的工作流程示例"><a href="#堆的工作流程示例" class="headerlink" title="堆的工作流程示例"></a><strong>堆的工作流程示例</strong></h5><ol><li><strong>对象分配</strong>：新对象进入Eden区。</li><li><strong>Minor GC</strong>：Eden满时触发，存活对象复制到Survivor区（To）。</li><li><strong>Survivor区轮换</strong>：From和To区角色交换，清空旧的From区。</li><li><strong>晋升老年代</strong>：对象年龄达标或Survivor区不足时晋升。</li><li><strong>Full GC</strong>：老年代不足时触发，回收整个堆，可能导致应用暂停。</li></ol><h5 id="堆分代的优势"><a href="#堆分代的优势" class="headerlink" title="堆分代的优势"></a>堆分代的优势</h5><ul><li><strong>降低GC开销</strong>：高频Minor GC仅处理新生代（小区域），减少停顿时间。</li><li><strong>适应对象生命周期</strong>：区分短命和长命对象，针对性优化回收策略。</li><li><strong>提升内存利用率</strong>：避免频繁扫描老年代对象。</li></ul><h4 id="方法执行过程"><a href="#方法执行过程" class="headerlink" title="方法执行过程"></a>方法执行过程</h4><p>当程序中通过对象或类直接调用某个方法时，主要包括以下几个步骤：</p><ul><li><strong>解析方法调用：</strong>JVM会根据方法的符号引用找到实际的<strong>方法地址</strong>(如果之前没有解析过的话）。</li><li><strong>栈帧创建：</strong>在调用一个方法前，JVM会在当前线程的Java虚拟机栈中为该方法分配一个新的<strong>栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<ul><li>局部变量表（用于存储局部变量和参数）。</li><li>操作数栈（用于存储计算过程中的<strong>临时数据</strong>）。</li><li>动态链接（指向方法所属类的运行时常量池的引用）。</li><li>方法返回地址（记录方法执行完毕后返回的位置）。</li></ul></li><li><strong>执行方法：</strong>执行方法内的字节码指令，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等</li><li><strong>返回处理：</strong>方法执行完毕后，可能会返回一个结果给调用者，并清理当前栈帧，<strong>恢复调用者的执行环境。</strong></li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期，这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p><ul><li><strong>强引用</strong>指的就是代码中普遍存在的赋值方式，比如<code>A a=new A()</code>这种。强引用关联的对象，<strong>永远不会被GC回收。</strong>当内存空间不足时，JVM 宁愿抛出 OutOfMemoryError异常。如果强引用对象不使用时，需要弱化从而使GC能够回收（如对象赋值null）<ul><li>显式地设置强引用对象为null，或让其超出对象的生命周期范围，则GC认为该对象不存在引用，这时就可以回收这个对象，具体什么时候收集这要取决于GC算法。</li></ul></li><li><strong>软引用</strong>可以用SoftReference来描述，指的是那些<strong>有用但是不是必须要的对象</strong>。系统在发生内存<strong>溢出前</strong>会对这类引用的对象进行回收（在OOM前触发）。<ul><li>软引用通常用在对内存敏感的程序中，比如<strong>高速缓存</strong>就有用到软引用，内存够用的时候就保留，不够用就回收。</li></ul></li><li><strong>弱引用</strong>可以用WeakReference来描述，他的强度比软引用更低一点，弱引I用的对象<strong>下一次GC的时候一定会被回收</strong>，而不管内存是否足够。</li><li><strong>虚引用</strong>也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。<ul><li>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</li><li><strong>无法通过虚引用获取对象</strong>（<code>get()</code>始终返回<code>null</code>）。</li><li>虚引用仅用于跟踪对象被回收的状态。</li><li>对象被回收时，虚引用会被加入关联的<code>ReferenceQueue</code>。</li></ul></li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>我们看下 Mybatis 缓存类 SoftCache 用到的软引用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Object</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> softReference <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>delegate<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>softReference <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> softReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>delegate<span class="token punctuation">.</span><span class="token function">removeObject</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hardLinksToAvoidGarbageCollection<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>hardLinksToAvoidGarbageCollection<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hardLinksToAvoidGarbageCollection<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numberOfHardLinks<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>hardLinksToAvoidGarbageCollection<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的，就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p><strong>WeakHashMap</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeakHashMapDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token function">myHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">myWeakHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">myHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token string">"v1"</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">myWeakHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">WeakHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//String key = "weak";</span>        <span class="token comment">// 刚开始写成了上边的代码</span>        <span class="token comment">//思考一下，写成上边那样会怎么样？ 那可不是引用了</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"weak"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token string">"map"</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//去掉强引用</span>        key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当key只有弱引用时，GC发现后会自动清理键和值，作为简单的缓存表解决方案。</p><p><strong>ThreadLocal</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token class-name">Object</span> value<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//......}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ThreadLocal.ThreadLocalMap.Entry 继承了<strong>弱引用</strong>，key为当前线程实例，和WeakHashMap基本相同。</p><h4 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h4><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>内存泄漏（Memory Leak）</strong></th><th align="left"><strong>内存溢出（Out of Memory）</strong></th></tr></thead><tbody><tr><td align="left"><strong>定义</strong></td><td align="left">对象不再使用，但无法被回收，导致内存占用增加。</td><td align="left">内存不足，无法分配新对象，导致程序崩溃。</td></tr><tr><td align="left"><strong>原因</strong></td><td align="left">长生命周期对象持有短生命周期对象的引用：如静态数据结构存储对象，事件监听，未停止的线程、数据库连接</td><td align="left">内存泄漏、内存设置过小、大对象或频繁创建对象（深度递归导致栈溢出）。</td></tr><tr><td align="left"><strong>表现</strong></td><td align="left">内存逐渐耗尽，程序性能下降。</td><td align="left">直接抛出 <code>OutOfMemoryError</code>，程序崩溃。</td></tr><tr><td align="left"><strong>解决方法</strong></td><td align="left">清理无用对象、使用弱引用、分析内存泄漏。</td><td align="left">增加内存、优化代码、分析内存泄漏。</td></tr><tr><td align="left"><strong>关系</strong></td><td align="left">内存泄漏可能导致内存溢出。</td><td align="left">内存溢出可能是内存泄漏的结果。</td></tr></tbody></table><p>内存溢出：</p><img src="/2024/06/15/java/my-hexo-blog\blogs\source\_posts\Java\image-20250318134026910.png" alt="image-20250318134026910" style="zoom:67%;"><h5 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h5><img src="https://cdn.xiaolincoding.com//picgo/image-20240820112835783.png" alt="image-20240820112835783" style="zoom: 50%;"><p><code>ThreadLocal</code> 为每个线程维护一个独立的变量副本。</p><p>每个线程内部有一个 <code>ThreadLocalMap</code>，用于存储该线程的 <code>ThreadLocal</code> 变量。</p><p><code>ThreadLocalMap</code> 的键是 <code>ThreadLocal</code> 对象，值是该线程的变量副本。</p><p><strong>键的弱引用</strong></p><ul><li><code>ThreadLocalMap</code> 的键（即 <code>ThreadLocal</code> 对象）是 <strong>弱引用（WeakReference）</strong>。</li><li>弱引用的特点是：如果只有弱引用指向某个对象，则下一次GC时该对象会被垃圾回收器回收。</li><li>当 <code>ThreadLocal</code> 对象没有强引用时（例如设置为 <code>null</code>），它会被垃圾回收，导致 <code>ThreadLocalMap</code> 中的键为 <code>null</code>。</li></ul><p><strong>值的强引用</strong></p><ul><li><code>ThreadLocalMap</code> 的值（即线程的变量副本）是 <strong>强引用</strong>。</li><li>即使 <code>ThreadLocal</code> 对象被回收，**<code>ThreadLocalMap</code> 中的值仍然存在，**因为值是被强引用的。</li></ul><p><strong>线程的生命周期</strong></p><ul><li>如果线程是线程池中的线程（如 <code>ThreadPoolExecutor</code>），线程不会被销毁，而是会被复用。</li><li>如果 <code>ThreadLocal</code> 对象被回收，但 <code>ThreadLocalMap</code> 中的值没有被清理，<strong>这些值会一直占用内存</strong>，导致内存泄漏。</li></ul><p><strong>ThreadLocal内存泄漏示例：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalLeakExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置一个大对象</span>            <span class="token comment">// 使用完后未清理</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 模拟长时间运行</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// ...</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中：</p><ol><li>线程池中的线程执行任务时，<code>threadLocal</code> 设置了一个大对象。</li><li>任务执行完后，<code>threadLocal</code> 没有被清理。</li><li>由于线程池中的线程不会被销毁，<code>ThreadLocalMap</code> 中的值会一直存在，导致内存泄漏。</li></ol><p>如何解决此问题？</p><ul><li>第一，使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除;</li><li>第二，<strong>不要使用ThreadLocal.set(null)<strong>的方式清除value，它实际上并没有清除值，而是</strong>查找与当前线程关联的Map并将键值对分别设置为当前线程和null。</strong></li><li>第三，最好将ThreadLocal视为需要在finally块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源。</li></ul><h3 id="类初始化和加载"><a href="#类初始化和加载" class="headerlink" title="类初始化和加载"></a>类初始化和加载</h3><h4 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h4><img src="https://cdn.xiaolincoding.com//picgo/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp" alt="img" style="zoom: 50%;"><p><strong>Step1:类加载检查</strong></p><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到这个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类<strong>是否已被加载过、解析和初始化过</strong>。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</p><p><strong>Step2:分配内存</strong></p><p>在类加载检查通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的<strong>内存大小</strong>在类加载完成后便可确定，为对象分配空间的任务等同于<strong>把一块确定大小的内存从 Java 堆中划分出来</strong>。分配方式有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><strong>内存分配的两种方式</strong> ：</p><ul><li>指针碰撞： <ul><li>适用场合：堆<strong>内存规整</strong>（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，<strong>只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</strong></li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表： <ul><li>适用场合：<strong>堆内存不规整</strong>的情况下。</li><li>原理：虚拟机会维护一个列表，<strong>该列表中会记录哪些内存块是可用的</strong>，在分配的时候，<strong>找一块儿足够大的内存块</strong>儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p><strong>Step3:初始化零值</strong></p><p>内存分配完成后，虚拟机需要将<strong>分配到的内存空间都初始化为零值</strong>（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以<strong>不赋初始值就直接使用</strong>，程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>Step4:进行必要设置如对象头</strong></p><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p><strong>Step5:执行 init 方法</strong></p><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，构造函数，即class文件中的方法还没有执行（<code>&lt;init&gt;</code> 方法还没有执行），所有的字段都还为零，<strong>对象需要的其他资源和状态信息</strong>还没有按照预定的意图构造好。所以一般来说，<strong>执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法</strong>，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h4 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h4><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</strong>。</p><p><strong>对象头：</strong>对象头是对象内存布局的第一部分，主要用于存储对象的<strong>元数据和运行时信息</strong>。它包括以下两部分：</p><ul><li><strong>标记字段（Mark Word）</strong>：用于存储对象自身的运行时数据， 如<strong>哈希码</strong>（HashCode）、GC 分代年龄、<strong>锁状态</strong>标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li><li><strong>类型指针（Klass pointer）</strong>：指向对象的类元数据（即类的 Class 对象），用于确定对象属于哪个类的实例。</li></ul><p><strong>实例数据：</strong>实例数据部分是对象真正存储的有效信息，包括程序中定义的<strong>各种类型的字段内容</strong>。</p><p><strong>对齐填充（Padding）</strong>：对齐填充是对象内存布局的最后一部分，用于确保对象的大小是 8 字节的整数倍。</p><ul><li>对象填充不是必然存在，只是用于占位。</li><li>HotSpot 虚拟机要求对象的起始地址必须是 8 字节的整数倍。</li><li>对象头部分正好是 8 字节的倍数（1 倍或 2 倍）。如果实例数据部分未对齐，则通过对齐填充来补全。</li></ul><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><img src="https://cdn.xiaolincoding.com//picgo/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp" alt="img" style="zoom: 50%;"><p>在 Java 中，类的生命周期是指<strong>从类被加载到虚拟机内存中，到类被卸载出内存</strong>的整个过程。类的生命周期包括以下几个阶段。其中验证、准备和解析可以统称为<strong>连接</strong>。</p><ol><li><p><strong>加载：将字节码文件加载到内存。</strong>触发条件：创建类的实例。访问类的静态字段或静态方法。使用反射加载类。初始化类的子类时，父类会被加载。</p><ul><li>通过<strong>全类名</strong>获取定义此类的<strong>二进制字节流</strong>。</li><li>将字节流所代表的<strong>静态存储结构</strong>转换为方法区的<strong>运行时数据结构</strong>。</li><li>在<strong>内存</strong>中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li></ul></li><li><p><strong>验证：确保字节码文件合法</strong>。确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><ul><li>文件格式验证（如魔数、版本号）。</li><li>元数据验证（如类是否有父类、字段和方法是否合法）。</li><li>字节码验证（如操作数栈类型是否匹配）。</li><li>符号引用验证（如引用的类、字段和方法是否存在）。</li></ul><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-process-verification.png" alt="验证阶段示意图" style="zoom:67%;"></li><li><p><strong>准备</strong>：为类中的<strong>静态字段</strong>分配内存并设置默认的初始值。final修饰的static字段不设置，因为编译时候已经分配过了。</p></li><li><p><strong>解析</strong>：将常量池的<strong>符号引用替换为直接引用</strong>。</p><ul><li><strong>符号引用</strong>：一组符号描述所引用的目标（如类、字段、方法）。</li><li><strong>直接引用</strong>：指向目标的指针、偏移量或句柄。</li><li><strong>目的</strong>：将符号引用转换为可以直接使用的内存地址或偏移量。</li></ul><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/symbol-reference-and-direct-reference.png" alt="符号引用和直接引用" style="zoom:80%;"></li><li><p><strong>初始化</strong>：类加载过程的最后一个阶段，执行类的<strong>静态初始化代码</strong>（如静态代码块和静态变量赋值）。</p><ul><li>静态代码块和静态变量赋值按代码顺序执行。</li><li>初始化是线程安全的，JVM 会加锁确保只有一个线程执行初始化。</li></ul></li><li><p><strong>使用</strong>：类的实例化和方法调用。</p></li><li><p><strong>卸载</strong>：当类不再被使用时，从内存中移除。</p></li></ol><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>在 JVM 中，类加载器（ClassLoader）负责<strong>将类的字节码文件（<code>.class</code> 文件）加载到内存中，</strong>并生成对应的 <code>java.lang.Class</code> 对象。JVM 提供了以下几种类加载器，它们按照层次结构组织，共同完成类的加载任务。</p><ul><li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</li><li>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</li><li><strong>数组类</strong>不是通过 <code>ClassLoader</code> 创建的（数组类没有对应的二进制字节流），<strong>是由 JVM 直接生成的</strong>。</li><li>除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。</li></ul><p>JVM 启动的时候，<strong>并不会一次性加载所有的类，而是根据需要去动态加载</strong>。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。<strong>对于已经加载的类会被放在 <code>ClassLoader</code> 中。</strong>在类加载的时候，系统会首先判断当前类是否被加载过。<strong>已经被加载的类会直接返回，否则才会尝试加载。</strong></p><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p><ol><li><p><strong><code>BootstrapClassLoader</code>(启动类加载器)<strong>：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，</strong>主要用来加载 JDK 内部的核心类库如 <code>java.lang.*</code>、<code>java.util.*</code> 等（</strong> <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</p><ul><li><p><strong>特点</strong>：</p><ul><li>由 C/C++ 实现，是 JVM 的一部分。</li><li><strong>是最高层次的类加载器，没有父类加载器。</strong></li><li>加载的类在 <code>java.lang.ClassLoader</code> 中返回 <code>null</code>。</li></ul></li><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 null</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>**<code>ExtensionClassLoader</code>(扩展类加载器)**：加载 JVM <strong>扩展类库</strong>（如 <code>javax.*</code> 等），这些类库位于 <code>JAVA_HOME/lib/ext</code> 目录下，或者通过 <code>java.ext.dirs</code> 系统属性指定的路径。</p><ul><li><p><strong>特点</strong>：</p><ul><li>由 Java 实现，是 <code>sun.misc.Launcher$ExtClassLoader</code> 的实例。</li><li>父类加载器是启动类加载器。</li></ul></li><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>parsers<span class="token punctuation">.</span></span>DocumentBuilderFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 sun.misc.Launcher$ExtClassLoader</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>**<code>AppClassLoader</code>(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath（用户类路径） 下的所有 jar 包和类。通常是程序的入口类（如包含 <code>main()</code> 方法的类）。</p><ul><li><strong>特点</strong>：<ul><li>由 Java 实现，是 <code>sun.misc.Launcher$AppClassLoader</code> 的实例。</li><li>父类加载器是扩展类加载器。</li><li><strong>是默认的类加载器</strong>，如果没有自定义类加载器，JVM 会使用它来加载类。</li></ul></li></ul><ul><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 sun.misc.Launcher$AppClassLoader</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ol><hr><p><strong>4. 自定义类加载器（Custom ClassLoader）</strong></p><ul><li><p><strong>作用</strong>：用户可以通过继承 <code>java.lang.ClassLoader</code> 类，实现自定义的类加载器，用于加载特定路径或来源的类。</p></li><li><p><strong>特点</strong>：</p><ul><li>可以打破双亲委派模型，实现类的动态加载。</li><li>常用于热部署、模块化加载、加密类加载等场景。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>        <span class="token comment">// 自定义加载逻辑</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token function">loadClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">loadClassData</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从文件或网络加载字节码</span>        <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><strong>双亲委派模型（Parent Delegation Model）</strong> 是 Java 类加载器（ClassLoader）的一种工作机制，它定义了类加载器在加载类时的协作方式。双亲委派模型是 Java 类加载机制的核心设计原则之一，确保了类的<strong>唯一性、安全性和一致性</strong>。</p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom: 67%;"><p>这些类加载器之间的关系形成了双亲委派模型，其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是<strong>把这个请求委派给父类加载器去完成</strong>，每一层次的类加载器都是如此，因此<strong>所有的加载请求最终都应该传送到顶层的启动类加载器中</strong>。只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><ul><li><code>ClassLoader</code> 类使用<strong>委托模型</strong>来搜索类和资源。</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li><li><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，<strong>将搜索类或资源的任务委托给其父类加载器。</strong></li></ul><p>流程：</p><ol><li>当前类加载器检查是否已加载过该类。</li><li>如果没有，将加载请求委派给父类加载器。</li><li>如果父类加载器无法加载，当前类加载器尝试加载。</li></ol><p>双亲委派模型是 Java 类加载机制的重要组成部分，它通过委派父加载器优先加载类的方式，实现了两个关键的安全目标：<strong>避免类的重复加载和防止核心 API 被篡改。</strong></p><ul><li><strong>保证类的唯一性：</strong>通过委托机制，确保了所有加载请求<strong>都会传递到启动类加载器</strong>，<strong>避免</strong>了不同类加载器<strong>重复加载</strong>相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。</li><li><strong>保证安全性：</strong>由于Java<strong>核心库被启动类加载器</strong>加载，而<strong>启动类加载器只加载信任的类路径中的类</strong>，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个Java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。</li><li><strong>支持隔离和层次划分：</strong>双亲委派模型支持<strong>不同层次的类加载器服务于不同的类加载需求</strong>，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。</li><li><strong>简化了加载流程：</strong>通过委派，大部分类能够被正确的类加载器加载，<strong>减少了每个加载器需要处理的类的数量</strong>，简化了类的加载过程，提高了加载效率。</li></ul><p><strong>打破双亲委派模型</strong></p><p>在某些场景下，可能需要打破双亲委派模型。例如：</p><ul><li><strong>热部署</strong>：动态加载类而不受父类加载器的限制。</li><li><strong>模块化加载</strong>：如 OSGi 框架，每个模块有自己的类加载器。</li></ul><p>如何打破双亲委派模型：自定义类加载器时，<strong>重写 <code>loadClass()</code> 方法，直接加载类而不委派给父类加载器。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>        <span class="token comment">// 直接加载类，不委派给父类加载器</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>Java 的自动内存管理主要是针对<strong>对象内存的回收和对象内存的分配</strong>。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>Java 的垃圾回收（Garbage Collection, GC）是 JVM <strong>自动管理内存</strong>的机制，<strong>用于回收不再使用的对象，释放内存空间</strong>。Java 开发者不需要手动释放内存，垃圾回收器会<strong>自动检测并回收</strong>无用的对象。用于避免内存泄漏和内存管理错误，减少手动管理内存的复杂性。</p><p><strong>回收对象：</strong>堆内存–垃圾回收主要针对堆内存中的对象。方法区–方法区（元空间）中的类元数据和常量池也可能被回收。</p><p>垃圾回收的触发：</p><ul><li><strong>内存不足时</strong>：当JVM检测到堆内存不足，无法为新的对象分配内存时，会自动触发垃圾回收。</li><li><strong>手动请求</strong>：虽然垃圾回收是自动的，开发者可以通过调用System.gc(或Runtime.getRuntime().gc()建议JVM进行垃圾回收。不过这只是一个建议，并不能保证立即执行。</li><li><strong>JVM参数</strong>：启动Java应用时可以通过JVM参数来调整垃圾回收的行为，比如：-Xmx（最大堆大小)、-Xms（初始堆大小）等。</li><li><strong>对象数量或内存使用达到阈值</strong>：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阀值时触发垃圾回收。</li></ul><h4 id="判断垃圾"><a href="#判断垃圾" class="headerlink" title="判断垃圾"></a>判断垃圾</h4><p>垃圾回收器通过以下算法判断对象是否可回收：</p><p><strong>引用计数法</strong></p><ul><li><strong>原理</strong>：每个对象维护一个引用计数器，记录有多少引用指向它。当引用计数为 0 时，对象可被回收。</li><li><strong>缺点</strong>：无法解决循环引用问题（如两个对象互相引用，但无外部引用）。</li></ul><p><strong>可达性分析法</strong></p><ul><li><strong>原理</strong>：从根对象（如栈中的局部变量、静态变量等）出发，遍历所有可达对象。不可达的对象可被回收。</li><li><strong>根对象（GC Roots）</strong>：栈中的局部变量。静态变量。JNI 引用（Native 方法引用的对象）。活跃线程。</li><li><strong>优点</strong>：解决了循环引用问题。</li></ul><img src="https://cdn.xiaolincoding.com//picgo/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png" alt="img" style="zoom:67%;"><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是<strong>废弃常量</strong>呢？</p><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p><ul><li>该类<strong>所有的实例都已经被回收</strong>，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象<strong>没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p><strong>标记-清除算法（Mark-Sweep）</strong>：分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在<strong>标记完成后统一回收</strong>掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p><p>缺点：<strong>产生内存碎片。效率较低。</strong>在申请大块内存的时候可能因为没有足够的内连续空间导致再次GC。</p><p><strong>复制算法（Copying）</strong>：将内存分为两块，<strong>每次申请内存时只使用一块</strong>。当内存不够时，将这一块内存中所有存活的对象复制到另一块内存。然后再把已使用的内存整个清理掉。<strong>优点</strong>：无内存碎片。<strong>缺点</strong>：内存利用率低（只能使用一半内存）。<strong>不适合老年代</strong>–如果存活对象数量比较大，复制性能会变得很差。</p><p><strong>标记-整理算法（Mark-Compact）</strong>：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是<strong>让所有存活的对象向一端移动</strong>，然后直接清理掉端边界以外的内存。<strong>优点</strong>：无内存碎片。内存利用率高。<strong>缺点</strong>：效率较低。</p><p><strong>分代收集算法（Generational Collection）</strong>：根据对象的生命周期将堆内存分为新生代（Young Generation）和老年代（Old Generation），对不同代采用不同的回收算法。</p><ul><li><strong>新生代</strong>：使用复制算法。分为 Eden 区和两个 Survivor 区（From 和 To）。</li><li><strong>老年代</strong>：使用标记-清除或标记-整理算法。</li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8: Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK22: G1</li></ul><p><strong>1. Serial 收集器</strong></p><ul><li><p><strong>特点</strong>：单线程收集（只使用一条垃圾收集线程，<strong>在进行垃圾收集时必须暂停其他所有工作线程</strong>，直到它收集结束）。适用于单核 CPU 或小型应用。新生代使用复制算法，老年代使用标记-整理算法。</p></li><li><p><strong>适用场景</strong>：客户端应用或单核服务器。  没有线程交互的开销，自然可以获得很高的单线程收集效率。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseSerialGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>2. Parallel 收集器（吞吐量优先收集器）</strong></p><ul><li><p><strong>特点</strong>：多线程收集。新生代使用复制算法，老年代使用标记-整理算法。<strong>注重吞吐量</strong>（Throughput）（高效率地利用cpu）。</p></li><li><p><strong>适用场景</strong>：多核 CPU 和<strong>吞吐量优先</strong>的应用（如批处理任务）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseParallelGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>3. Parallel Old 收集器</strong></p><ul><li><p><strong>特点</strong>：Parallel 收集器的老年代版本。多线程收集。使用标记-整理算法。</p></li><li><p><strong>适用场景</strong>：需要高吞吐量的多核服务器。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseParallelOldGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>4. CMS 收集器（Concurrent Mark-Sweep）</strong></p><ul><li><p><strong>特点：并发收集，减少停顿时间。</strong>新生代使用复制算法，老年代使用标记-清除算法。注重低延迟。</p></li><li><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。它非常符合在<strong>注重用户体验</strong>的应用上使用。CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了<strong>让垃圾收集线程与用户线程（基本上）同时工作。</strong></p></li><li><p><strong>缺点</strong>：产生内存碎片。对 CPU 资源敏感。</p></li><li><p><strong>适用场景</strong>：响应时间优先的应用（如 Web 服务）。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseConcMarkSweepGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>5. G1 收集器（Garbage-First）</strong></p><ul><li><p><strong>特点</strong>：将堆内存划分为多个区域（Region）。并发收集，兼顾吞吐量和响应时间。使用标记-整理算法。可预测的停顿时间（通过设置最大停顿时间）。另外，G1回收的范围是整个java堆，而之前的仅限于新生代或老年代。</p></li><li><p><strong>适用场景</strong>：大内存和多核 CPU 的应用。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseG1GC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h4 id="6-ZGC-收集器（Z-Garbage-Collector）"><a href="#6-ZGC-收集器（Z-Garbage-Collector）" class="headerlink" title="6. ZGC 收集器（Z Garbage Collector）"></a><strong>6. ZGC 收集器（Z Garbage Collector）</strong></h4><ul><li><p><strong>特点</strong>：低延迟（停顿时间不超过 10ms）。支持超大堆内存（TB 级别）。并发收集，使用染色指针（Colored Pointers）和读屏障（Load Barrier）。</p></li><li><p>ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。</p></li><li><p><strong>适用场景</strong>：大内存和低延迟场景（如实时系统）。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseZGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>7. Shenandoah 收集器</strong></p><ul><li><p><strong>特点</strong>：低延迟（停顿时间与堆大小无关）。并发收集，使用 Brooks 指针和读屏障。支持大内存。</p></li><li><p><strong>适用场景</strong>：大内存和低延迟场景。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseShenandoahGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>8. Epsilon 收集器</strong></p><ul><li><p><strong>特点</strong>：不进行垃圾回收，仅分配内存。适用于性能测试或极短生命周期的应用。</p></li><li><p><strong>适用场景</strong>：测试环境或不需要垃圾回收的场景。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseEpsilonGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p><p><a href="https://javabetter.cn/string/constant-pool.html">深入理解Java字符串常量池 | 二哥的Java进阶之路</a></p><p>泛型：<a href="https://blog.csdn.net/weixin_45395059/article/details/126006369">Java 中的泛型（两万字超全详解）_java 泛型-CSDN博客</a></p><p>反射：<a href="https://blog.csdn.net/weixin_74268571/article/details/131345164">Java反射详解-CSDN博客</a></p><p>注解：<a href="https://segmentfault.com/a/1190000044576598">Spring注解是如何实现的？万字详解 - 架构师技术栈 - SegmentFault 思否</a></p><p>hashset源码：<a href="https://blog.csdn.net/weixin_45663027/article/details/135825567">Java集合系列 HashSet底层源码 细致解读（超通俗易懂）_hashset 初始化长度的源代码-CSDN博客</a></p><p>ArrayDeque源码：<a href="https://javabetter.cn/collection/arraydeque.html">详解 Java 中的双端队列（ArrayDeque附源码分析） | 二哥的Java进阶之路</a></p><p>线程创建：<a href="https://mp.weixin.qq.com/s/NspUsyhEmKnJ-4OprRFp9g">大家都说Java有三种创建线程的方式！并发编程中的惊天骗局！</a></p><p>多线程：<a href="https://nan-ying.github.io/2023/03/25/Java%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%9310-%E5%A4%9A%E7%BA%BF%E7%A8%8B/#8-JDK5-0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F">Java知识整理和总结10-多线程 | Nan-ying’s Blog</a></p><p>volatile：<a href="https://blog.csdn.net/m0_49183244/article/details/125493673">Java中的volatile_java volatile-CSDN博客</a></p><p><a href="https://www.xiaolincoding.com/interview/juc.html#syncronized%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AE%B2%E4%B8%80%E4%B8%8B">Java并发编程面试题 | 小林coding</a></p><p><a href="https://blog.csdn.net/2301_78320637/article/details/142900288">【JVM】内存模型_jvm内存模型-CSDN博客</a></p><p><a href="https://segmentfault.com/a/1190000042313862">Java四大引用详解：强引用、软引用、弱引用、虚引用 - BAT架构技术与大厂面试 - SegmentFault 思否</a></p>  <pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM</title>
      <link href="/2024/05/21/ssm/"/>
      <url>/2024/05/21/ssm/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>Spring 5.X版本模块：</p><img src="/2024/05/21/ssm/1.png" alt="Spring5.x主要模块"><table><thead><tr><th align="left"><strong>功能模块</strong></th><th align="left"><strong>功能介绍</strong></th></tr></thead><tbody><tr><td align="left">Core Container</td><td align="left">核心容器，<strong>主要提供 IoC 依赖注入功能的支持</strong>。在 Spring 环境下使用任何功能都必须基于 <strong>IOC 容器</strong>。</td></tr><tr><td align="left">AOP&amp;Aspects</td><td align="left">面向切面编程</td></tr><tr><td align="left">Testing</td><td align="left">提供了对 junit 或 TestNG 测试框架的整合。</td></tr><tr><td align="left">Data Access/Integration</td><td align="left">提供了对数据访问/集成的功能。</td></tr><tr><td align="left">Spring MVC</td><td align="left">提供了面向Web应用程序的集成功能。</td></tr></tbody></table><h4 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h4><ul><li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong>：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong>：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul><li><strong>spring-aspects</strong>：该模块为与 AspectJ 的集成提供支持。</li><li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li><li><strong>spring-instrument</strong>：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li></ul><h4 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access/Integration"></a>Data Access/Integration</h4><ul><li><strong>spring-jdbc</strong>：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li><strong>spring-tx</strong>：提供对事务的支持。</li><li><strong>spring-orm</strong>：提供对 Hibernate、JPA、iBatis 等 ORM（对象关系映射） 框架的支持。</li><li><strong>spring-oxm</strong>：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li></ul><h4 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h4><ul><li><strong>spring-web</strong>：对 Web 功能的实现提供一些最基础的支持。</li><li><strong>spring-webmvc</strong>：提供对 Spring MVC 的实现。</li><li><strong>spring-websocket</strong>：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li><strong>spring-webflux</strong>：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li></ul><h4 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h4><ul><li><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</li></ul><h4 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h4><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="==Spring IOC=="></a>==Spring IOC==</h3><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是<strong>将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</strong>(对象创建控制权由程序转移到外部)。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><ul><li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。IOC容器的作用：</p><ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为==Bean==</li><li>IOC容器中放的就是一个个的Bean对象</li></ul><p>当IOC容器中创建好service和dao对象后，程序能正确执行么?</p><ul><li>不行，因为service运行需要依赖dao对象</li><li>IOC容器中虽然有service和dao对象，但是service对象和dao对象没有任何关系</li><li>需要把dao对象交给service,也就是说<strong>要绑定service和dao对象之间的关系</strong></li></ul><p>像这种在容器中建立对象与对象之间的绑定关系就要用到<strong>DI依赖注入</strong></p><ul><li><p>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入</p></li><li><p>如业务层需要依赖数据层，service就要和dao建立依赖关系</p></li></ul><p>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:==充分解耦==，具体实现靠:</p><ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul><blockquote><p>总结：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种具体实现。</p></blockquote><h3 id="IOC在Spring中的实现"><a href="#IOC在Spring中的实现" class="headerlink" title="IOC在Spring中的实现"></a>IOC在Spring中的实现</h3><p>resources下添加spring配置文件applicationContext.xml，并完成bean的配置</p><img src="/2024/05/21/ssm/1629734336440.png" alt="1629734336440" style="zoom: 67%;"><h4 id="bean基础配置-id与class"><a href="#bean基础配置-id与class" class="headerlink" title="bean基础配置(id与class)"></a>bean基础配置(id与class)</h4><p>对于bean的基础配置，在前面的案例中已经使用过:</p><pre class="line-numbers language-none"><code class="language-none">&lt;bean id="" class=""/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下</p><img src="/2024/05/21/ssm/image-20210729183500978.png" alt="image-20210729183500978" style="zoom: 50%;"><ul><li><p>bean依赖注入的ref属性指定bean，必须在容器中存在</p><img src="/2024/05/21/ssm/1629771744003.png" alt="1629771744003" style="zoom: 67%;"></li></ul><h4 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h4><p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p><p>就需要研究下<code>bean的实例化过程</code>，在这块内容中主要解决两部分内容，分别是</p><ul><li>bean是如何创建的</li><li>实例化bean的三种方式，<code>构造方法</code>,<code>静态工厂</code>和<code>实例工厂</code></li></ul><h5 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h5><blockquote><p>Spring 底层默认通过反射技术<strong>调用组件类的无参构造器</strong>来创建组件对象，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出异常。</p></blockquote><p>将类配置到Spring容器</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写运行程序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppForInstanceBook</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span>             <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BookDao</span> bookDao <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BookDao</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类中提供构造函数测试</p><p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">BookDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao constructor is running ...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数。将构造函数改成private测试，运行程序，能执行成功,说明内部走的依然是构造函数,能访问到类中的私有构造方法,显而易见Spring底层用的是反射。</p><h5 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h5><p>在spring的配置文件application.properties中添加以下内容:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>orderDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.factory.OrderDaoFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getOrderDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>class:工厂类的类全名</p><p>factory-mehod:具体工厂类中创建对象的方法名</p><p>对应关系如下图:</p><img src="/2024/05/21/ssm/image-20210729195248948.png" alt="image-20210729195248948" style="zoom:80%;"><p>在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppForInstanceOrder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">OrderDao</span> orderDao <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">OrderDao</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"orderDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，这些操作必不可少。这种方式一般是用来兼容早期的一些老系统，所以==了解为主==。</p><h5 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h5><p>在spring的配置文件中添加以下内容:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.factory.UserDaoFactory<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getUserDao<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userFactory<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实例化工厂运行的顺序是:</p><ul><li><p>创建实例化工厂对象,对应的是第一行配置</p></li><li><p>调用对象中的方法来创建bean，对应的是第二行配置</p><ul><li><p>factory-bean:工厂的实例对象</p></li><li><p>factory-method:工厂对象中的具体创建对象的方法名,对应关系如下:</p><img src="/2024/05/21/ssm/image-20210729200203249.png" alt="image-20210729200203249" style="zoom:80%;"></li></ul></li></ul><p>factory-mehod:具体工厂类中创建对象的方法名</p><p>(2)在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppForInstanceUser</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span>             <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">UserDao</span> userDao <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserDao</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例工厂实例化的方式就已经介绍完了，配置的过程还是比较复杂，所以Spring为了简化这种配置方式就提供了一种叫<code>FactoryBean</code>的方式来简化开发。</p><h5 id="FactoryBean的使用"><a href="#FactoryBean的使用" class="headerlink" title="FactoryBean的使用"></a>FactoryBean的使用</h5><p>具体的使用步骤为:</p><p>(1)创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDaoFactoryBean</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserDao</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//代替原始实例工厂中创建对象的方法</span>    <span class="token keyword">public</span> <span class="token class-name">UserDao</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回所创建类的Class对象</span>    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">UserDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)在Spring的配置文件中进行配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.factory.UserDaoFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(3)AppForInstanceUser运行类不用做任何修改，直接运行</p><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><ol><li>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</li></ol><ul><li>在bean中定义引用类型属性，并<strong>提供可访问的==set==方法</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">BookDao</span> bookDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBookDao</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span> bookDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bookDao <span class="token operator">=</span> bookDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置中使用==property==标签==ref==属性注入引用类型对象</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.imipl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.注入简单数据类型：和引用类型类似</p><blockquote><p>1.在BookDaoImpl类中声明对应的简单数据类型的属性</p><p>2.为这些属性提供对应的setter方法</p><p>3.在applicationContext.xml中配置</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> databaseName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> connectionNum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setConnectionNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> connectionNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>connectionNum <span class="token operator">=</span> connectionNum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token class-name">String</span> databaseName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>databaseName <span class="token operator">=</span> databaseName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token operator">+</span>databaseName<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>connectionNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置文件中使用property标签注入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>databaseName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>connectionNum<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookService</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">BookDao</span> bookDao<span class="token punctuation">;</span>    <span class="token comment">// 利用构造器传参</span>    <span class="token keyword">public</span> <span class="token class-name">BookServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span> bookDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bookDao <span class="token operator">=</span> bookDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book service save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标签<constructor-arg>中</constructor-arg></p><ul><li><p>name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。</p></li><li><p>ref属性指向的是spring的IOC容器中其他bean对象。</p></li></ul><p><strong>注入简单数据类型</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> databaseName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> connectionNum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">BookDaoImpl</span><span class="token punctuation">(</span><span class="token class-name">String</span> databaseName<span class="token punctuation">,</span> <span class="token keyword">int</span> connectionNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>databaseName <span class="token operator">=</span> databaseName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>connectionNum <span class="token operator">=</span> connectionNum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token operator">+</span>databaseName<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>connectionNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>databaseName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>connectionNum<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>666<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变</li><li>这两块存在紧耦合，具体该如何解决?</li></ul><p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，大家都以了解为主。</p><p>方式一:删除name属性，添加type属性，按照类型注入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种方式可以解决构造函数形参名发生变化带来的耦合问题</li><li>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</li></ul><p>方式二:删除type属性，添加index属性，按照索引下标注入，下标从0开始</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种方式可以解决参数类型重复问题</li><li>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</li></ul><p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul><li>强制依赖指对象在创建的过程中必须要注入指定的参数</li></ul></li><li>可选依赖使用setter注入进行，灵活性强<ul><li>可选依赖指对象在创建过程中注入的参数可有可无</li></ul></li></ol><h4 id="依赖自动装配"><a href="#依赖自动装配" class="headerlink" title="依赖自动装配"></a>依赖自动装配</h4><p>IoC容器根据bean所依赖的资源<strong>在容器中自动查找并注入到bean中的过程称</strong>为自动装配</p><p>自动装配只需要修改applicationContext.xml配置文件即可:</p><p>(1)将<code>&lt;property&gt;</code>标签删除</p><p>(2)在<code>&lt;bean&gt;</code>标签中添加autowire属性</p><p>首先来实现按照类型注入的配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byType<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意事项:==</p><ul><li>需要注入属性的类中<strong>对应属性的setter方法不能省略</strong></li><li><strong>被注入的对象必须要被Spring的IOC容器管理</strong></li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li></ul><p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要<strong>按照名称注入</strong>，配置方式为:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byName<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意事项:==</p><ul><li><p><strong>按照名称注入中的名称指的是什么?</strong></p><img src="/2024/05/21/ssm/1629806856156.png" alt="1629806856156" style="zoom:80%;"><ul><li>bookDao是private修饰的，外部类无法直接方访问</li><li>外部类只能通过属性的set方法进行访问</li><li>==========<strong>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名</strong>=============<ul><li>为什么是去掉set首字母小写?</li><li>这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名</li></ul></li><li>所以按照名称注入，其实是和对应的set方法有关，但是<strong>如果按照标准起名称，属性名和set对应的名是一致的</strong></li></ul></li><li><p>如果按照名称去找对应的bean对象，<strong>找不到则注入Null</strong></p></li><li><p>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</p></li></ul><p>两种方式介绍完后，以后用的<strong>更多的是==按照类型==注入。</strong></p><p>最后对于依赖注入，需要注意一些其他的配置特征:</p><ol><li>自动装配<strong>用于引用类型依赖注入</strong>，因为被注入的对象必须要被Spring的IOC容器管理，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中<strong>相同类型的bean唯一</strong>，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中<strong>具有指定名称的bean</strong>，因<strong>变量名与配置耦合，不推荐使用</strong></li><li>自动装配优先级低于setter注入与构造器注入，<strong>同时出现时自动装配配置失效</strong></li></ol><h4 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h4><p>下面的配置方式，都是在bookDao的bean标签中使用<property>进行注入</property></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注入数组类型数据"><a href="#注入数组类型数据" class="headerlink" title="注入数组类型数据"></a>注入数组类型数据</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>array<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>100<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>200<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>300<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注入Map"><a href="#注入Map" class="headerlink" title="注入Map"></a>注入Map</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>country<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>china<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>province<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>henan<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>kaifeng<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注入Properties类型数据"><a href="#注入Properties类型数据" class="headerlink" title="注入Properties类型数据"></a>注入Properties类型数据</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>properties<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>props</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>country<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>china<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>province<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>henan<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>kaifeng<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>props</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BeanFactory-与-FactoryBean-的区别"><a href="#BeanFactory-与-FactoryBean-的区别" class="headerlink" title="BeanFactory 与 FactoryBean 的区别"></a>BeanFactory 与 FactoryBean 的区别</h3><p><strong>BeanFactory</strong></p><ul><li><p>BeanFactory<strong>定义了IOC容器的最基本形式</strong>，并提供了IOC容器应遵守的的最基本的接口，也就是SpringIOC所遵守的最底层和最基本的编程规范。</p></li><li><p>它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。在Spring代码中，BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，都是附加了某种功能的实现。</p></li><li><p>BeanFactory</p><ul><li>使用BeanFactory创建的容器是延迟加载</li><li>使用ApplicationContext创建的容器是立即加载</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">BeansException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">ResolvableType</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token constant">FACTORY_BEAN_PREFIX</span> <span class="token operator">=</span> <span class="token string">"&amp;"</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> var1<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isTypeMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">ResolvableType</span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isTypeMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAliases</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>FactoryBean</strong></p><ul><li>一般情况下，Spring通过反射机制利用的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案.</li><li>Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean的形式</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">T</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在该接口中还定义了以下3个方法：</p><ul><li>T getObject()返回由FactoryBean创建的Bean实例，如果isSingleton()返回true，则该实例会放到Spring容器中单实例缓存池中；</li><li>boolean isSingleton()：返回由FactoryBean创建的Bean实例的作用域是singleton还是prototype；</li><li>Class getObjectType()：返回FactoryBean创建的Bean类型。当配置文件中的class属性配置的实现类是FactoryBean时，通过getBean()方法返回的不是FactoryBean本身，而是FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。<br>例：如果使用传统方式配置下面Car的时，Car的每个属性分别对应一个元素标签。</li></ul><h3 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h3><p><strong>创建 Bean 的实例</strong>：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</p><p><strong>Bean 属性赋值/填充</strong>：为 Bean 设置相关属性和依赖，例如<code>@Autowired</code> 等注解注入的对象、<code>@Value</code> 注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</p><p><strong>Bean 初始化</strong>： </p><ul><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li><strong>给bean对象设置属性</strong>：如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li><strong>bean对象初始化之前操作</strong>：如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 <code>init-method</code> 属性，执行指定的方法。</li><li><strong>bean对象初始化之后操作</strong>：如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法。</li></ul><p><strong>销毁 Bean</strong>：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。 </p><ul><li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li></ul><img src="/2024/05/21/ssm/spring-bean-lifestyle.png" alt="img" style="zoom:80%;"><h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。</p><h4 id="注解开发定义bean（2-5）"><a href="#注解开发定义bean（2-5）" class="headerlink" title="注解开发定义bean（2. 5）"></a>注解开发定义bean（2. 5）</h4><p><strong>步骤1:删除原XML配置</strong></p><p>将配置文件中的<code>&lt;bean&gt;</code>标签删除掉</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>步骤2:Dao上添加注解</strong></p><p>在BookDaoImpl类上添加<code>@Component</code>注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意:@Component注解不可以添加在接口上，因为接口是无法创建对象的。==</p><p>XML与注解配置的对应关系:</p><img src="/2024/05/21/ssm/1629990315619.png" alt="1629990315619" style="zoom:80%;"><p><strong>步骤3:配置Spring的注解包扫描</strong></p><p>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明:</strong></p><p>component-scan</p><ul><li>component:组件,<strong>Spring将管理的bean视作自己的一个组件</strong></li><li>scan:扫描</li></ul><p>base-package<strong>指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</strong></p><ul><li>包路径越多[如:com.itheima.dao.impl]，扫描的范围越小速度越快</li><li>包路径越少[如:com.itheima],扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下[如:com.itheima]即可。</li></ul><h4 id="纯注解开发（3-0）"><a href="#纯注解开发（3-0）" class="headerlink" title="纯注解开发（3.0）"></a>纯注解开发（3.0）</h4><p>实现思路：将配置文件applicationContext.xml删除掉，使用类来替换。</p><ul><li><p>Java类（SpringConfig）替换Spring核心配置文件（ApplicationContext）</p><img src="/2024/05/21/ssm/1630029254372.png" alt="1630029254372" style="zoom:80%;"></li><li><p>@Configuration注解用于设定当前类为配置类</p></li><li><p>@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</p><pre class="line-numbers language-none"><code class="language-none">@ComponentScan({com.itheima.service","com.itheima.dao"})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 加载配置文件初始化容器</span><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 加载配置类初始化容器</span><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="注解相关问题"><a href="#注解相关问题" class="headerlink" title="注解相关问题"></a>注解相关问题</h3><h4 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些"></a>将一个类声明为 Bean 的注解有哪些</h4><ul><li><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</li></ul><p>通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是<strong>在@Component注解的基础上起了三个新的名字</strong>。</p><p>对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。</p><p>注意：虽然它们<strong>本质上一样</strong>，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。</p><h4 id="Component-和-Bean-的区别是什么"><a href="#Component-和-Bean-的区别是什么" class="headerlink" title="@Component 和 @Bean 的区别是什么"></a>@Component 和 @Bean 的区别是什么</h4><ul><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。**<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。**</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的<strong>自定义性更强</strong>，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我<strong>们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</strong></li></ul><p><code>@Bean</code>注解使用示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码相当于下面的 xml 配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transferService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.acme.TransferServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>@Bean注解的作用是将方法的返回值制作为Spring管理的一个bean对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">DataSource</span> <span class="token function">dataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">DruidDataSource</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DruidDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/spring_db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ds<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意:不能使用<code>DataSource ds = new DruidDataSource()</code></strong></p><p>因为DataSource接口中没有对应的setter方法来设置属性。</p><h4 id="注入-Bean-的注解有哪些"><a href="#注入-Bean-的注解有哪些" class="headerlink" title="注入 Bean 的注解有哪些"></a>注入 Bean 的注解有哪些</h4><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th>Annotation</th><th>Package</th><th>Source</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td><code>org.springframework.bean.factory</code></td><td>Spring 2.5+</td></tr><tr><td><code>@Resource</code></td><td><code>javax.annotation</code></td><td>Java JSR-250</td></tr><tr><td><code>@Inject</code></td><td><code>javax.inject</code></td><td>Java JSR-330</td></tr></tbody></table><p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p><h4 id="Autowired-和-Resource-的区别是什么"><a href="#Autowired-和-Resource-的区别是什么" class="headerlink" title="@Autowired 和 @Resource 的区别是什么"></a>@Autowired 和 @Resource 的区别是什么</h4><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会<strong>优先根据接口类型去匹配并注入 Bean</strong> （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> <strong>当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了</strong>，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p><strong>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。</strong>就比如说下面代码中的 <code>smsService</code> 就是我这里所说的名称，这样应该比较好理解了吧。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// smsService 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><span class="token comment">// smsServiceImpl1 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还是建议通过 <code>@Qualifier</code> 注解来显式指定名称而不是依赖变量的名称。</p><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p><p>简单总结一下：</p><ul><li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li><li><strong><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用</strong>。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li></ul><p>为什么不需要set方法：</p><ul><li>@Autowired可以写在属性上，也可也写在setter方法上，最简单的处理方式是<code>写在属性上并将setter方法删除掉</code></li><li>为什么setter方法可以删除呢?<ul><li><strong>自动装配基于反射设计创建对象并通过暴力反射为私有属性进行设值</strong></li><li>普通反射只能获取public修饰的内容</li><li><strong>暴力反射除了获取public修饰的内容还可以获取private修改的内容</strong></li><li>所以此处无需提供setter方法</li></ul></li></ul><h3 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h3><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p><p><strong>步骤1：resource下准备properties文件</strong></p><p>jdbc.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">name</span><span class="token punctuation">=</span><span class="token value attr-value">itheima888</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>步骤2: 使用注解加载properties配置文件</strong></p><p>在配置类上添加<code>@PropertySource</code>注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.itheima"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token string">"jdbc.properties"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤3：使用@Value读取配置文件中的内容</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Repository</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${name}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bean作用范围"><a href="#bean作用范围" class="headerlink" title="bean作用范围"></a>bean作用范围</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 <strong>bean 默认都是单例的</strong>，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，<strong>连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</strong></li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application/global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml 方式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>singleton<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注解方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">personPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bean-是线程安全的吗"><a href="#Bean-是线程安全的吗" class="headerlink" title="Bean 是线程安全的吗"></a>Bean 是线程安全的吗</h3><p>Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。</p><p>我们这里以最常用的两种作用域 prototype 和 singleton 为例介绍。几乎所有场景的 Bean 作用域都是使用默认的 singleton ，重点关注 singleton 作用域即可。</p><blockquote><p>prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。<strong>如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。</strong></p><p>不过，大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p></blockquote><p>对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：</p><ol><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="==Spring AOP=="></a>==Spring AOP==</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它是通过预编译方式和运行期动态代理方式实现在<strong>不修改源代码的情况下给程序动态统一添加额外功能</strong>的一种技术。</p></li><li><p>OOP(Object Oriented Programming)面向对象编程</p></li><li><p>作用：在不修改原始设计的基础上为其进行功能增强。利用Aop可以对业务逻辑的<strong>各个部分进行隔离</strong>，从而使得业务逻辑各个部分之间的**<code>耦合度</code>降低<strong>，提高程序的</strong>可重用性**，同时提高可开发效率</p></li></ul><blockquote><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些<strong>与业务无关，却为业务模块所共同调用的逻辑或责任</strong>（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是<strong>基于动态代理</strong>的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p></blockquote><img src="/2024/05/21/ssm/230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess"><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p><strong>1.横切关注点</strong></p><p>从每个方法中抽取出来的<strong>同一类非核心业务</strong>。在同一个项目中，我们可以使用多个横切关注点对相关的方法进行多个不同方面的增强。</p><p>这个概念不是语法层面天然存在的，而是<strong>根据附加功能的逻辑上的需要</strong>：有十个附加功能，就有十个横切关注点。</p><p><strong>2.通知</strong></p><p>每一个横切关注点上<strong>要做的事情</strong>都需要写一个方法来实现，这样的方法就叫<strong>通知方法</strong>。</p><ul><li><p>前置通知：在被代理的目标方法前执行</p></li><li><p>返回通知：在被代理的目标方法成功结束后执行（寿终正寝）</p></li><li><p>异常通知：在被代理的目标方法异常结束后执行（死于非命）</p></li><li><p>后置通知：在被代理的目标方法最终结束后执行（盖棺定论）</p></li><li><p>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</p></li></ul><p><strong>3.切面</strong></p><p>封装通知方法的类</p><p><strong>4.目标</strong></p><p>被代理的目标对象</p><p><strong>5.代理</strong></p><p>向目标对象应用通知之后创建的代理对象</p><p><strong>6.连接点</strong></p><p>这也是一个纯逻辑概念，不是语法定义的。</p><ul><li>把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。</li><li><strong>程序执行过程中的任意位置</strong>，粒度为执行方法、抛出异常、设置变量等</li></ul><img src="/2024/05/21/ssm/23.png" alt="23" style="zoom: 67%;"><p><strong>7.切入点</strong></p><p>定位连接点的方式。（<strong>匹配连接点的式子</strong>）</p><p>如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。</p><p>Spring 的 AOP 技术可以通过切入点定位到特定的连接点。切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。<br>连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是<strong>连接点的方法就不一定要被增强，所以可能不是切入点。</strong></p><h3 id="基于注解的AOP"><a href="#基于注解的AOP" class="headerlink" title="基于注解的AOP"></a>基于注解的AOP</h3><p>案例设定：测算接口执行效率，但是这个案例稍微复杂了点，我们对其进行简化。</p><p>简化设定：在方法执行前输出当前系统时间。</p><blockquote><p>1.导入坐标(pom.xml)</p><p>2.制作连接点(原始操作，Dao接口与实现类)</p><p>3.制作共性功能(通知类与通知)</p><p>4.定义切入点</p><p>5.绑定切入点与通知关系(切面)</p></blockquote><ul><li><p>pom.xml添加Spring依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.2.10.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加BookDao和BookDaoImpl类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Repository</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao update ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建Spring的配置类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.itheima"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写App运行类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BookDao</span> bookDao <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>我们要使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能。</p><h4 id="AOP实现"><a href="#AOP实现" class="headerlink" title="AOP实现"></a>AOP实现</h4><p><strong>步骤1:添加依赖</strong></p><p>pom.xml</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.aspectj<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aspectjweaver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.9.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤2:定义接口与实现类</strong></p><pre class="line-numbers language-none"><code class="language-none">环境准备的时候，BookDaoImpl已经准备好，不需要做任何修改<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>步骤3:定义通知类和通知</strong></p><p>通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类名和方法名没有要求，可以任意。</p><p><strong>步骤4:定义切入点</strong></p><p>BookDaoImpl中有两个方法，分别是save和update，我们<strong>要增强的是update方法</strong>，该如何定义呢?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明:</strong></p><ul><li>切入点定义<strong>依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</strong></li><li>execution及后面编写的内容，后面会有章节专门去学习。</li></ul><p><strong>步骤5:制作切面</strong></p><p>切面是用来描述通知和切入点之间的关系，如何进行关系的绑定?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span><span class="token comment">// 设置切入点方法</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span><span class="token comment">// 设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行==位置==</strong></p><img src="/2024/05/21/ssm/1630148447689.png" alt="1630148447689" style="zoom:80%;"><p><strong>说明:</strong>@Before翻译过来是之前，也就是说<strong>通知会在切入点方法执行之前执行，</strong>除此之前还有其他四种类型，后面会讲。</p><p><strong>步骤6:将通知类配给容器并标识其为切面类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token comment">// 设置当前类为AOP切面类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤7:开启注解格式AOP功能</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.itheima"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token comment">// 开启注解格式AOP功能</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤8:运行程序</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BookDao</span> bookDao <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到在执行update方法之前打印了系统时间戳，说明对原始方法进行了增强，AOP编程成功。</p><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul><li>切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类/接口名.方法名(参数) 异常名）</li></ul><p>对于这个格式，我们不需要硬记，通过一个例子，理解它:</p><pre class="line-numbers language-none"><code class="language-none">execution(public User com.itheima.service.UserService.findById(int))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>public:访问修饰符,还可以是public，private等，可以省略</li><li>User：返回值，写返回值类型</li><li>com.itheima.service：包名，多级包使用点连接</li><li>UserService:类/接口名称</li><li>findById：方法名</li><li>int:参数，直接写参数的类型，多个类型用逗号隔开</li><li>异常名：方法定义中抛出指定异常，可以省略</li></ul><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>我们使用通配符描述切入点，主要的目的就是简化之前的配置，具体都有哪些通配符可以使用?</p><ul><li><p><code>*</code>:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><pre class="line-numbers language-none"><code class="language-none">execution（public * com.itheima.*.UserService.find*(*))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p></li><li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p><pre class="line-numbers language-none"><code class="language-none">execution（public User com..UserService.findById(..))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法</p></li><li><p><code>+</code>：专用于匹配子类类型</p><pre class="line-numbers language-none"><code class="language-none">execution(* *..*Service+.*(..))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个使用率较低，描述子类的，咱们做JavaEE开发，继承机会就一次，使用都很慎重，所以很少用它。*Service+，表示所有以Service结尾的接口的子类。</p></li></ul><h5 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h5><ul><li>描述切入点通**==常描述接口==**，而不描述实现类,如果描述到实现类，就出现紧耦合了</li><li>访问控制修饰符针对接口开发均采用public描述（**==可省略访问控制修饰符描述==**）</li><li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述</li><li>**==包名==<strong>书写</strong>==尽量不使用..匹配==**，效率过低，常用*做单个包描述匹配，或精准匹配</li><li>**==接口名/类名==<strong>书写名称与模块相关的</strong>==采用*匹配==**，例如UserService书写成*Service，绑定业务层接口名</li><li>**==方法名==<strong>书写以</strong>==动词==<strong>进行</strong>==精准匹配==*<em>，名词采用</em>匹配，例如getById书写成getBy*,selectAll书写成selectAll</li><li>参数规则较为复杂，根据业务方法灵活调整</li><li>通常**==不使用异常==<strong>作为</strong>==匹配==**规则</li></ul><h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><img src="/2024/05/21/ssm/1630166147697.png" alt="1630166147697" style="zoom:80%;"><p>(1)前置通知，追加功能到方法执行前,类似于在代码1或者代码2添加内容</p><p>(2)后置通知,追加功能到方法执行后,不管方法执行的过程中有没有抛出异常都会执行，类似于在代码5添加内容</p><p>(3)返回后通知,追加功能到方法执行后，只有方法正常执行结束后才进行,类似于在代码3添加内容，如果方法执行抛出异常，返回后通知将不会被添加</p><p>(4)抛出异常后通知,追加功能到方法抛出异常后，只有方法执行出异常才进行,类似于在代码4添加内容，只有方法抛出异常后才会被添加</p><p>(5)环绕通知,环绕通知功能比较强大，它可以追加功能到方法执行的前后，这也是比较常用的方式，它可以实现其他四种通知类型的功能，具体是如何实现的，需要我们往下学习。</p><p><strong>各种通知</strong></p><p>如果我们使用环绕通知的话，要根据原始方法的返回值来设置环绕通知的返回值，具体解决方案为:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(int com.itheima.dao.BookDao.select())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"pt2()"</span><span class="token punctuation">)</span><span class="token comment">// 返回后通知</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterReturning</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"afterReturning advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"pt2()"</span><span class="token punctuation">)</span>    <span class="token comment">// 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">aroundSelect</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> pjp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"around before advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//表示对原始操作的调用</span>        <span class="token class-name">Object</span> ret <span class="token operator">=</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"around after advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明:</strong></p><p>​为什么返回的是Object而不是int的主要原因是Object类型更通用。</p><p>​在环绕通知中是可以对原始方法返回值就行修改的。</p><h3 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h3><p><strong>流程1:Spring容器启动</strong></p><ul><li>容器启动就需要去加载bean,哪些类需要被加载呢?</li><li><strong>需要被增强的类，如:BookServiceImpl</strong></li><li><strong>通知类，如:MyAdvice</strong></li><li>注意此时<strong>bean对象还没有创建成功</strong></li></ul><p><strong>流程2:读取所有切面配置中的切入点</strong></p><ul><li><p>上面这个例子中有两个切入点的配置，但是第一个<code>ptx()</code>并没有被使用，所以不会被读取。</p><img src="/2024/05/21/ssm/1630151682428.png?lastModify=171635275" alt="1630151682428" style="zoom: 67%;"></li></ul><p><strong>流程3:初始化bean</strong></p><p>判定bean对应的<strong>类中的方法是否匹配到任意切入点</strong></p><ul><li>注意第1步在容器启动的时候，bean对象还没有被创建成功。</li><li>要被实例化bean对象的类中的方法和切入点进行匹配</li><li>匹配失败，创建原始对象,如<code>UserDao</code><ul><li>匹配失败说明不需要增强，直接调用原始对象的方法即可。</li></ul></li><li>匹配成功，<strong>创建原始对象（==目标对象==）的==代理==对象,如:<code>BookDao</code></strong><ul><li>匹配成功说明需要对其进行增强</li><li>对哪个类做增强，这个类对应的对象就叫做目标对象</li><li>因为<strong>要对目标对象进行功能增强，而采用的技术是动态代理，所以会为其创建一个代理对象</strong></li><li>最终运行的是<strong>代理对象的方法</strong>，在该方法中会对原始方法进行功能增强</li></ul></li></ul><p><strong>流程4:获取bean执行方法</strong></p><ul><li>获取的bean是原始对象时，调用方法并执行，完成操作</li><li>获取的bean是代理对象时，<strong>根据代理对象的运行模式运行原始方法与增强的内容</strong>，完成操作</li></ul><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><p>在上面介绍AOP的工作流程中，我们提到了两个核心概念，分别是:</p><ul><li>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</li><li>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li></ul><p>上面这两个概念比较抽象，简单来说，</p><p>目标对象就是要增强的类[如:BookServiceImpl类]对应的对象，也叫原始对象，不能说它不能运行，只能说它在运行的过程中对于要增强的内容是缺失的。</p><p>SpringAOP是在不改变原有设计(代码)的前提下对其进行增强的，它的底层采用的是<strong>代理模式</strong>实现的，所以要对原始对象进行增强，就需要对原始对象创建代理对象，<strong>在代理对象中的方法把通知[如:MyAdvice中的method方法]内容加进去，就实现了增强,这就是我们所说的代理(Proxy)。</strong></p><h3 id="AOP的优点"><a href="#AOP的优点" class="headerlink" title="AOP的优点"></a>AOP的优点</h3><ol><li><p><strong>模块化</strong>: AOP可以将横向关注点与纵向业务逻辑分离，从而实现模块化，使代码更加清晰易懂，易于维护和扩展；</p></li><li><p><strong>可重用性</strong>: AOP可以将横向关注点作为独立的模块，从而使这些模块可以被多个应用程序共用，提高代码的可重用性；</p></li><li><p><strong>简化代码</strong>: AOP可以用比传统方法更少的代码来实现同样的功能，从而简化代码，提高代码的可读性和可维护性；</p></li><li><p><strong>提高程序的灵活性</strong>: AOP可以通过将横向关注点独立出来，使得程序的各个模块之间的耦合度降低，从而提高程序的灵活性，便于进行功能扩展和修改；</p></li><li><p><strong>提高程序的安全性</strong>: AOP<strong>可以通过将安全控制与业务逻辑分离，提高程序的安全性，减少潜在的安全漏洞。</strong></p></li></ol><hr><p>可以使用@Order注解来控制切面的顺序。在同一个方法上应用多个切面时，可以为每个切面添加不同的@Order值，值越小的切面将先执行，值越大的切面将后执行。如果没有指定@Order值，则默认优先级为0。</p><h3 id="拦截器和aop的区别"><a href="#拦截器和aop的区别" class="headerlink" title="拦截器和aop的区别"></a>拦截器和aop的区别</h3><p>拦截器和AOP在以下四个方面存在区别：</p><blockquote><p>定义和用途：拦截器是一种<strong>设计模式</strong>，拦截器可以在方法调用之前、之后或异常发生时插入额外的逻辑，常见于各种编程语言和框架，如Java的Servlet过滤器、Spring的拦截器等。在Java中，拦截器通常与AOP框架结合使用。拦截器可以在<strong>方法级别或类级别</strong>进行配置，并按照一定的顺序依次执行。</p><p>AOP是一种<strong>编程范式</strong>，旨在通过<strong>将跨越多个对象和层的功能（称为“切面”）从业务逻辑中解耦出来，实现横切关注点的复用</strong>。AOP可以在不修改原始代码的情况下，将切面应用于一个或多个目标对象，以增加特定功能，例如<strong>日志记录、事务管理、性能监控</strong>等。</p><p>拦截对象：拦截器主要针对<strong>URL</strong>进行拦截，而AOP针对的是<strong>具体的代码</strong>，能够实现更加复杂的业务逻辑。</p><p>灵活性：AOP更加灵活，可以对方法进行拦截，也可以对类进行拦截，而拦截器只能对特定的URL或者action进行拦截。</p><p>实现方式：拦截器和AOP都是使用<strong>代理模式</strong>实现，但AOP还包含一种特殊的代理，即CGLib代理。这种代理可以针对类进行代理，而不仅仅是对接口进行代理。</p></blockquote><p>总结来说，拦截器和AOP在定义和用途、拦截对象、灵活性和实现方式上存在区别。拦截器主要用于过滤和拦截特定URL或action，而AOP主要用于解耦和复用横切关注点。</p><h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别"></a>Spring AOP 和 AspectJ AOP 有什么区别</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>SpringMVC是一种<strong>基于Java实现MVC模型</strong>的轻量级Web框架，隶属于Spring框架的一部分，对Servlet进行了封装。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC 是<strong>模型(Model)、视图(View)、控制器(Controller)<strong>的简写，其核心思想是通过将</strong>业务逻辑、数据、显示</strong>分离来组织代码。</p><img src="/2024/05/21/ssm/image-20210809181452421.png" alt="img"><blockquote><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><p>MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p></blockquote><h3 id="SpringMVC-的核心组件"><a href="#SpringMVC-的核心组件" class="headerlink" title="SpringMVC 的核心组件"></a>SpringMVC 的核心组件</h3><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p><ul><li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h3 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h3><img src="/2024/05/21/ssm/de6d2b213f112297298f3e223bf08f28.png" alt="img"><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li><li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><h3 id="Spring-框架用到了哪些设计模式"><a href="#Spring-框架用到了哪些设计模式" class="headerlink" title="Spring 框架用到了哪些设计模式"></a>Spring 框架用到了哪些设计模式</h3><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h3 id="Spring循环依赖-三级缓存"><a href="#Spring循环依赖-三级缓存" class="headerlink" title="Spring循环依赖-三级缓存"></a>Spring循环依赖-三级缓存</h3><p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%86%E8%A7%A3%E5%90%97-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%86%E8%A7%A3%E5%90%97-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3</a></p><p>Spring 框架通过使用三级缓存来解决这个问题，确保即使在循环依赖的情况下也能正确创建 Bean。</p><p>Spring 中的三级缓存其实就是三个 Map，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 一级缓存</span><span class="token comment">/** Cache of singleton objects: bean name to bean instance. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 二级缓存</span><span class="token comment">/** Cache of early singleton objects: bean name to bean instance. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 三级缓存</span><span class="token comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>一级缓存（singletonObjects）</strong>：存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。一般情况我们获取 Bean 都是从这里获取的，但是并不是所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。</p><p><strong>二级缓存（earlySingletonObjects）</strong>：存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中<code>ObjectFactory</code>产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用<code>ObjectFactory#getObject()</code>都是会产生新的代理对象的。</p><p><strong>三级缓存（singletonFactories）</strong>：存放<code>ObjectFactory</code>，<code>ObjectFactory</code>的<code>getObject()</code>方法（最终调用的是<code>getEarlyBeanReference()</code>方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。</p></blockquote><p>接下来说一下 Spring 创建 Bean 的流程：</p><ol><li>先去 <strong>一级缓存 <code>singletonObjects</code></strong> 中获取，存在就返回；</li><li>如果不存在或者对象正在创建中，于是去 <strong>二级缓存 <code>earlySingletonObjects</code></strong> 中获取；</li><li>如果还没有获取到，就去 <strong>三级缓存 <code>singletonFactories</code></strong> 中获取，通过执行 <code>ObjectFacotry</code> 的 <code>getObject()</code> 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。</li></ol><p>解决循环依赖的流程如下：</p><ul><li>当 Spring 创建 A 之后，发现 A 依赖了 B ，又去创建 B，B 依赖了 A ，又去创建 A；</li><li>在 B 创建 A 的时候，那么此时 A 就发生了循环依赖，由于 A 此时还没有初始化完成，因此在 <strong>一二级缓存</strong> 中肯定没有 A；</li><li>那么此时就去三级缓存中调用 <code>getObject()</code> 方法去获取 A 的 <strong>前期暴露的对象</strong> ，也就是调用上边加入的 <code>getEarlyBeanReference()</code> 方法，生成一个 A 的 <strong>前期暴露对象</strong>；</li><li>然后就将这个 <code>ObjectFactory</code> 从三级缓存中移除，并且将前期暴露对象放入到二级缓存中，那么 B 就将这个前期暴露对象注入到依赖，来支持循环依赖。</li></ul><blockquote><p><strong>最后总结一下 Spring 如何解决三级缓存</strong>：</p><p>在三级缓存这一块，主要记一下 Spring 是如何支持循环依赖的即可，也就是如果发生循环依赖的话，就去 <strong>三级缓存 <code>singletonFactories</code></strong> 中拿到三级缓存中存储的 <code>ObjectFactory</code> 并调用它的 <code>getObject()</code> 方法来获取这个循环依赖对象的前期暴露对象（虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了），并且将这个前期暴露对象放到二级缓存中，这样在循环依赖时，就不会重复初始化了！</p><p>不过，这种机制也有一些缺点，比如增加了内存开销（需要维护三级缓存，也就是三个 Map），降低了性能（需要进行多次检查和转换）。并且，还有少部分情况是不支持循环依赖的，比如非单例的 bean 和<code>@Async</code>注解的 bean 无法支持循环依赖。</p></blockquote><h4 id="Lazy能解决循环依赖吗"><a href="#Lazy能解决循环依赖吗" class="headerlink" title="@Lazy能解决循环依赖吗"></a>@Lazy能解决循环依赖吗</h4><p><code>@Lazy</code> 用来标识类是否需要懒加载/延迟加载，可以作用在类上、方法上、构造器上、方法参数上、成员变量中。</p><p>Spring Boot 2.2 新增了全局懒加载属性，开启后全局 bean 被设置为懒加载，需要时再去创建。</p><p>配置文件配置全局懒加载：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#默认false</span><span class="token key attr-name">spring.main.lazy-initialization</span><span class="token punctuation">=</span><span class="token value attr-value">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编码的方式设置全局懒加载：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SpringApplication</span> springApplication<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">Start</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>springApplication<span class="token punctuation">.</span><span class="token function">setLazyInitialization</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>springApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如非必要，尽量不要用全局懒加载。<strong>全局懒加载会让 Bean 第一次使用的时候加载会变慢，并且它会延迟应用程序问题的发现</strong>（当 Bean 被初始化时，问题才会出现）。</p><p>如果一个 Bean 没有被标记为懒加载，那么它会在 Spring IoC 容器启动的过程中被创建和初始化。如果一个 Bean 被标记为懒加载，那么<strong>它不会在 Spring IoC 容器启动时立即实例化，而是在第一次被请求时才创建</strong>。这可以帮助减少应用启动时的初始化时间，也可以用来解决循环依赖问题。</p><p>循环依赖问题是如何通过<code>@Lazy</code> 解决的呢？这里举一个例子，比如说有两个 Bean，A 和 B，他们之间发生了循环依赖，那么 A 的构造器上添加 <code>@Lazy</code> 注解之后（延迟 Bean B 的实例化），加载的流程如下：</p><ul><li>首先 Spring 会去创建 A 的 Bean，创建时需要注入 B 的属性；</li><li>由于在 A 上标注了 <code>@Lazy</code> 注解，因此 <strong>Spring 会去创建一个 B 的代理对象，将这个代理对象注入到 A 中的 B 属性；</strong></li><li>之后开始执行 B 的实例化、初始化，在注入 B 中的 A 属性时，此时 A 已经创建完毕了，就可以将 A 给注入进去。</li></ul><p>通过 <code>@Lazy</code> 就解决了循环依赖的注入， <strong>关键点就在于对 A 中的属性 B 进行注入时，注入的是 B 的代理对象，因此不会循环依赖。</strong></p><p>之前说的发生循环依赖是因为在对 A 中的属性 B 进行注入时，注入的是 B 对象，此时又会去初始化 B 对象，发现 B 又依赖了 A，因此才导致的循环依赖。</p><p>一般是不建议使用循环依赖的，但是如果项目比较复杂，可以使用 <code>@Lazy</code> 解决一部分循环依赖的问题。</p><h2 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h2><ul><li><p>==REST==（Representational State Transfer），表现形式状态转换,它是一种<strong>软件架构==风格==</strong></p><p>当我们想表示一个网络资源的时候，可以使用两种方式:</p><ul><li>传统风格资源描述形式<ul><li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li><li><code>http://localhost/user/saveUser</code> 保存用户信息</li></ul></li><li>REST风格描述形式<ul><li><code>http://localhost/user/1</code> </li><li><code>http://localhost/user</code></li></ul></li></ul></li></ul><p>传统方式一般是一个请求url对应一种操作，这样做不仅麻烦，也不安全。查看REST风格的描述，你会发现请求地址变的简单了，并且光看请求URL并不是很能猜出来该URL的具体功能</p><p>所以REST的优点有:</p><ul><li><strong>隐藏资源的访问行为</strong>，无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul><p>根据REST风格对资源进行访问称为==RESTful==。</p><h3 id="传递路径参数"><a href="#传递路径参数" class="headerlink" title="传递路径参数"></a>传递路径参数</h3><p>前端发送请求的时候使用:<code>http://localhost/users/1</code>,路径中的<code>1</code>就是我们想要传递的参数。</p><p>后端获取参数，需要做如下修改:</p><ul><li>修改@RequestMapping的value属性，将其中修改为<code>/users/{id}</code>，目的是和路径匹配</li><li>在方法的形参前添加@PathVariable注解：绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应</li></ul><img src="/2024/05/21/ssm/1630506231379.png" alt="1630506231379" style="zoom:80%;"><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token comment">//设置当前请求方法为PUT，表示REST风格中的修改操作</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/users"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">PUT</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user update..."</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'user update'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>将请求路径更改为<code>/users</code></p><ul><li>访问该方法使用 PUT: <code>http://localhost/users</code></li></ul></li><li><p>访问并携带参数:</p><img src="/2024/05/21/ssm/1630506507096.png" alt="1630506507096" style="zoom:80%;"></li></ul><p>关于接收参数，我们学过三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>,这三个注解之间的区别和应用分别是什么?</p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h3 id="RESTful快速开发"><a href="#RESTful快速开发" class="headerlink" title="RESTful快速开发"></a>RESTful快速开发</h3><p>做完了RESTful的开发，你会发现==好麻烦==，麻烦在哪?</p><img src="/2024/05/21/ssm/1630507339724.png" alt="1630507339724" style="zoom:80%;"><p>问题1：每个方法的@RequestMapping注解中都定义了访问路径/books，重复性太高。</p><p>问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。</p><p>问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。</p><p>对于上面所提的这三个问题，具体该如何解决?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span> <span class="token comment">// 设置当前控制器类为RESTful风格，等价于@Controller + ReponseBody</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">)</span><span class="token comment">// 将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookController</span> <span class="token punctuation">{</span>    <span class="token comment">//@RequestMapping(method = RequestMethod.POST)</span>    <span class="token annotation punctuation">@PostMapping</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book save..."</span> <span class="token operator">+</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book save'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(value = "/{id}",method = RequestMethod.DELETE)</span>    <span class="token comment">// 使用@GetMapping  @PostMapping  @PutMapping  @DeleteMapping代替requestmapping</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book delete..."</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book delete'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(method = RequestMethod.PUT)</span>    <span class="token annotation punctuation">@PutMapping</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book update..."</span> <span class="token operator">+</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book update'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(value = "/{id}",method = RequestMethod.GET)</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book getById..."</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book getById'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(method = RequestMethod.GET)</span>    <span class="token annotation punctuation">@GetMapping</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book getAll..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book getAll'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h3><p>分模块开发：将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享。</p><img src="/2024/05/21/ssm/1630768869208.png" alt="1630768869208" style="zoom: 50%;"><p>对于项目的拆分，大致会有如下几个步骤:</p><p>(1) 创建Maven模块</p><p>(2) 书写模块代码：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。拆分方式可以按照功能拆也可以按照模块拆。</p><p>(3)通过maven指令安装模块到本地仓库(install 指令)，在不同模块间引入依赖</p><p>团队内部开发需要发布模块功能到团队内部可共享的仓库中(私服)</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>依赖是具有传递性的:</p><img src="/2024/05/21/ssm/1630853726532.png" alt="1630853726532" style="zoom: 50%;"><p>**说明:**A代表自己的项目；B,C,D,E,F,G代表的是项目所依赖的jar包；D1和D2 E1和E2代表是相同jar包的不同版本</p><p>(1) A依赖了B和C,B和C有分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递</p><p>(2) 依赖传递有直接依赖和间接依赖</p><ul><li>相对于A来说，A直接依赖B和C,间接依赖了D1,E1,G，F,D2和E2</li><li>相对于B来说，B直接依赖了D1和E1,间接依赖了G</li><li>直接依赖和间接依赖是一个相对的概念</li></ul><p>(3)因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题，Maven是如何解决冲突的?</p><p>如果想避免传递依赖：</p><p><strong>方案1-可选依赖</strong>：可选依赖指对外隐藏当前所依赖的资源—不透明<optional>true</optional></p><p><strong>方案2-排除依赖</strong>：排除依赖指主动断开依赖的资源，被排除的资源无需指定版本—不需要</p><h3 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h3><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li>所谓聚合：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的”空”工程（有且仅有一个pom文件）</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建<ul><li>当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。</li></ul></li></ul><p>聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>所谓继承：描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</li><li>作用：简化配置；减少版本冲突</li></ul><p>步骤1:创建一个空的Maven项目并将其打包方式设置为pom</p><p>步骤2:在子项目中设置其父工程</p><p>步骤3:优化子项目共有依赖导入问题（将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中）</p><p>步骤4:优化子项目依赖版本问题</p><p><strong>父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</strong>。</p><p>聚合和继承的作用:</p><ul><li>聚合用于快速构建项目，对项目进行管理</li><li>继承用于快速配置和管理子项目中所使用jar包的版本</li></ul><p>聚合和继承的相同点:</p><ul><li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>聚合与继承均属于设计型模块，并无实际的模块内容</li></ul><p>聚合和继承的不同点:</p><ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul><h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3><ul><li><p>父工程中定义多环境</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profiles</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>环境名称<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">&gt;</span></span>value<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activation</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activation</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">&gt;</span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profiles</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用多环境(构建过程)</p><pre class="line-numbers language-none"><code class="language-none">mvn 指令 -P 环境定义ID[环境定义中获取]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p><code>SpringBoot</code> 是由Pivotal团队提供的全新框架，其设计目的是用来==简化==Spring应用的==初始搭建==以及==开发过程==。</p><p>原始 <code>Spring</code> 环境搭建和开发存在以下问题：</p><ul><li>配置繁琐</li><li>依赖设置繁琐</li></ul><p><code>SpringBoot</code> 程序优点恰巧就是针对 <code>Spring</code> 的缺点</p><ul><li>自动配置。这个是用来解决 <code>Spring</code> 程序配置繁琐的问题</li><li>起步依赖。这个是用来解决 <code>Spring</code> 程序依赖设置繁琐的问题</li><li>辅助功能（内置服务器,…）。我们在启动 <code>SpringBoot</code> 程序时既没有使用本地的 <code>tomcat</code> 也没有使用 <code>tomcat</code> 插件，而是使用 <code>SpringBoot</code> 内置的服务器。</li></ul><img src="/2024/05/21/ssm/image-20210911172200292.png" alt="image-20210911172200292" style="zoom:80%;"><h3 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h3><p>我们使用 <code>Spring Initializr</code>  方式创建的 <code>Maven</code> 工程的的 <code>pom.xml</code> 配置文件中自动生成了很多包含 <code>spring-boot-starter</code> 的依赖，如下图</p><img src="/2024/05/21/ssm/image-20210918220338109.png" alt="image-20210918220338109" style="zoom: 80%;"><p>从上面的文件中可以看到指定了一个父工程，我们进入到父工程，发现父工程中又指定了一个父工程，如下图所示</p><img src="/2024/05/21/ssm/image-20210918220855024.png" alt="image-20210918220855024" style="zoom:80%;"><p>再进入到该父工程中，在该工程中我们可以看到配置内容结构如下图所示</p><img src="/2024/05/21/ssm/image-20210918221042947.png" alt="image-20210918221042947" style="zoom:80%;"><p>在 <code>properties</code> 中我们找 <code>servlet</code>  和 <code>mysql</code> 的版本如下图</p><img src="/2024/05/21/ssm/image-20210918221511249.png" alt="image-20210918221511249" style="zoom:80%;"><blockquote><p>上图中的 <code>properties</code> 标签中定义了各个技术软件依赖的版本，避免了我们在使用不同软件技术时考虑版本的兼容问题。</p><p><code>dependencyManagement</code> 标签是进行依赖版本锁定，但是并没有导入对应的依赖；如果我们工程需要那个依赖只需要引入依赖的 <code>groupid</code> 和 <code>artifactId</code> 不需要定义 <code>version</code>。</p></blockquote><p>而 <code>build</code> 标签中也对插件的版本进行了锁定，如下图</p><img src="/2024/05/21/ssm/image-20210918221942453.png" alt="image-20210918221942453" style="zoom:80%;"><p>看完了父工程中 <code>pom.xml</code> 的配置后不难理解我们工程的的依赖为什么都没有配置 <code>version</code>。</p><p>在我们创建的工程中的 <code>pom.xml</code> 中配置了如下依赖</p><img src="/2024/05/21/ssm/image-20210918222321402.png" alt="image-20210918222321402" style="zoom:80%;"><p>进入到该依赖，查看 <code>pom.xml</code> 的依赖会发现它引入了如下的依赖</p><img src="/2024/05/21/ssm/image-20210918222607469.png" alt="image-20210918222607469" style="zoom:80%;"><p>里面引入了 <code>spring-web</code> 和 <code>spring-webmvc</code> 的依赖，这就是为什么我们的工程中没有依赖这两个包还能正常使用 <code>springMVC</code> 中的注解的原因。</p><p>而依赖 <code>spring-boot-starter-tomcat</code> ，从名字基本能确认内部依赖了 <code>tomcat</code>，所以我们的工程才能正常启动。</p><p>==结论：以后需要使用技术，只需要引入该技术对应的起步依赖即可==</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><a href="https://blog.csdn.net/dreamstar613/article/details/90265078">https://blog.csdn.net/dreamstar613/article/details/90265078</a></p><img src="/2024/05/21/ssm/image-20240531092335394.png" alt="image-20240531092335394" style="zoom:80%;"><h2 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h2><p>MybatisPlus(简称MP)是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提供效率。</p><p>MP是MyBatis的一套增强工具，它是在MyBatis的基础上进行开发的，我们虽然使用MP但是底层依然是MyBatis的东西，也就是说我们也可以在MP中写MyBatis的内容。</p><p>官方文档：<a href="https://baomidou.com/introduce/">https://baomidou.com/introduce/</a></p><p>MP的特性:</p><ul><li>无侵入：只做增强不做改变，引入它不会对现有工程产生影响。</li><li>损耗小：启动即会自动注入基本CURD，性能基本无损耗，直接面向对象操作。</li><li>强大的CRUD操作：内置通用Mapper、通用Service，仅仅通过少量配置即可实现单表大部分CRUD操作，更有强大的条件构造器，满足各类使用需求。</li><li>支持Lambda形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错。</li><li>支持主键自动生成：支持多达4种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题。</li><li><strong>支持ActiveRecord模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作。</li><li>支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）。</li><li>内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎。</li><li>内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询。分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库。</li><li>内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询。</li><li>内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作。</li></ul><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>Lombok常见的注解有:</p><ul><li>@Setter:为模型类的属性提供setter方法</li><li>@Getter:为模型类的属性提供getter方法</li><li>@ToString:为模型类的属性提供toString方法</li><li>@EqualsAndHashCode:为模型类的属性提供equals和hashcode方法</li><li><strong>==@Data:是个组合注解，包含上面的注解的功能==</strong></li><li>==@NoArgsConstructor:提供一个无参构造函数==</li><li>==@AllArgsConstructor:提供一个包含所有参数的构造函数==</li></ul><h3 id="标准数据层开发"><a href="#标准数据层开发" class="headerlink" title="标准数据层开发"></a>标准数据层开发</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 插入一条记录</span><span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 entity 条件，删除记录</span><span class="token keyword">int</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除（根据ID 批量删除）</span><span class="token keyword">int</span> <span class="token function">deleteBatchIds</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">COLLECTION</span><span class="token punctuation">)</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> idList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 ID 删除，传入id</span><span class="token keyword">int</span> <span class="token function">deleteById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 columnMap 条件，删除记录</span><span class="token keyword">int</span> <span class="token function">deleteByMap</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">COLUMN_MAP</span><span class="token punctuation">)</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 whereEntity 条件，更新记录</span><span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">ENTITY</span><span class="token punctuation">)</span> <span class="token class-name">T</span> entity<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> updateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 ID 修改，传入的是entity</span><span class="token keyword">int</span> <span class="token function">updateById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">ENTITY</span><span class="token punctuation">)</span> <span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据条件，查询记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectList</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 查询，传入id</span><span class="token class-name">T</span> <span class="token function">selectById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span> <span class="token comment">// 查询（根据 columnMap 条件）</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectByMap</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">COLUMN_MAP</span><span class="token punctuation">)</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectMaps</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录。注意： 只返回第一个字段的值</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectObjs</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录（并分页）</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectPage</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录（并分页）</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectMapsPage</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询总记录数</span><span class="token class-name">Integer</span> <span class="token function">selectCount</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DQL编程"><a href="#DQL编程" class="headerlink" title="DQL编程"></a>DQL编程</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">Mybatisplus02DqlApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testGetAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 模拟页面传递过来的查询数据</span>        <span class="token class-name">UserQuery</span> uq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        uq<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        uq<span class="token punctuation">.</span><span class="token function">setAge2</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">LambdaQueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> lqw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LambdaQueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查询指定字段，对应语句 SELECT id,name,age FROM user</span>        lqw<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果前端传来的age2属性不为空，则添加 where age &lt; xx 的条件</span>        <span class="token comment">// 类名::方法名的lambda表达式获取查询条件，避免自己写"age"出错</span>        lqw<span class="token punctuation">.</span><span class="token function">lt</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">!=</span>uq<span class="token punctuation">.</span><span class="token function">getAge2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">,</span> uq<span class="token punctuation">.</span><span class="token function">getAge2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lqw<span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">!=</span>uq<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">,</span> uq<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 聚合和分组查询，不能用lambda</span>        lqw<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"count(*) as count,tel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lqw<span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span><span class="token string">"tel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/**         * condition ：条件，返回boolean，         当condition为true，进行排序，如果为false，则不排序         * isAsc:是否为升序，true为升序，false为降序         * columns：需要操作的列，这里是按id降序         */</span>        lqw<span class="token punctuation">.</span><span class="token function">orderBy</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> userList <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>lqw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MP只是对MyBatis的增强，如果MP实现不了，我们可以直接在DAO接口中使用MyBatis的方式实现</p><h3 id="映射兼容"><a href="#映射兼容" class="headerlink" title="映射兼容"></a>映射兼容</h3><p><strong>问题1:表字段与编码属性设计不同步</strong></p><p>当表的列名和模型类的属性名发生不一致，就会导致数据封装不到模型对象。</p><p>MP给我们提供了一个注解<code>@TableField</code>,使用该注解可以实现<strong>模型类属性名和表的列名之间的映射</strong>关系</p><p><strong>问题2:编码中添加了数据库中未定义的属性</strong></p><p>当模型类中多了一个数据库表不存在的字段，就会导致生成的sql语句中在select的时候查询了数据库不存在的字段，程序运行就会报错，错误信息为:  ==Unknown column ‘多出来的字段名称’ in ‘field list’==</p><p>具体的解决方案用到的还是<code>@TableField</code>注解，它有一个属性叫<code>exist</code>，设置该字段是否在数据库表中存在，如果设置为false则不存在，生成sql语句查询的时候，就不会再查询该字段了。</p><p><strong>问题3：采用默认查询开放了更多的字段查看权限</strong></p><p>查询表中所有的列的数据，就可能把一些敏感数据查询到返回给前端，这个时候我们就需要<strong>限制哪些字段默认不要进行查询</strong>。解决方案是<code>@TableField</code>注解的一个属性叫<code>select</code>，该属性设置默认是否需要查询该字段的值，true(默认值)表示默认查询该字段，false表示默认不查询该字段。</p><p><strong>问题4:表名与编码开发设计不同步</strong></p><p>该问题主要是表的名称和模型类的名称不一致，导致查询失败，这个时候通常会报如下错误信息:==Table ‘databaseName.tableNaem’ doesn’t exist==,翻译过来就是数据库中的表不存在。解决方案是使用MP提供的另外一个注解<code>@TableName</code>来设置表与模型类之间的对应关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@TableName</span><span class="token punctuation">(</span><span class="token string">"tbl_user"</span><span class="token punctuation">)</span><span class="token comment">// 映射数据库名</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"pwd"</span><span class="token punctuation">,</span>select<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">// 映射数据库表字段pwd，默认不要查询</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> tel<span class="token punctuation">;</span>    <span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>exist<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">// 表中不存在的字段</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> online<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DML编程"><a href="#DML编程" class="headerlink" title="DML编程"></a>DML编程</h3><h4 id="id生成"><a href="#id生成" class="headerlink" title="id生成"></a>id生成</h4><table><thead><tr><th>名称</th><th>@TableId</th></tr></thead><tbody><tr><td>类型</td><td>==属性注解==</td></tr><tr><td>位置</td><td>模型类中用于表示主键的属性定义上方</td></tr><tr><td>作用</td><td>设置当前类中主键属性的生成策略</td></tr><tr><td>相关属性</td><td>value(默认)：设置数据库表主键名称<br>type:设置主键属性的生成策略，值查照IdType的枚举值</td></tr></tbody></table><p> @TableId(type = IdType.AUTO) – 自增</p><ul><li>NONE: 不设置id生成策略</li><li>INPUT:用户手工输入id</li><li>ASSIGN_ID:雪花算法生成id(可兼容数值型与字符串型)</li><li>ASSIGN_UUID:以UUID生成算法作为id生成策略</li><li>其他的几个策略均已过时，都将被ASSIGN_ID和ASSIGN_UUID代替掉。</li></ul><p>对比：</p><ul><li>NONE: 不设置id生成策略，MP不自动生成，约等于INPUT,所以这两种方式都需要用户手动设置，但是手动设置第一个问题是容易出现相同的ID造成主键冲突，为了保证主键不冲突就需要做很多判定，实现起来比较复杂</li><li>AUTO:数据库ID自增,这种策略适合在数据库服务器只有1台的情况下使用,不可作为分布式ID使用</li><li>ASSIGN_UUID:可以在分布式的情况下使用，而且能够保证唯一，但是生成的主键是32位的字符串，长度过长占用空间而且还不能排序，查询性能也慢</li><li>ASSIGN_ID:可以在分布式的情况下使用，生成的是Long类型的数字，可以排序性能也高，但是生成的策略和服务器时间有关，如果修改了系统时间就有可能导致出现重复主键</li></ul><h4 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h4><p><strong>模型类主键策略设置</strong></p><p>对于主键ID的策略已经介绍完，但是如果要在项目中的每一个模型类上都需要使用相同的生成策略，如：</p><img src="/2024/05/21/ssm/1631245676125-1717399291442.png" alt="1631245676125" style="zoom:80%;"><p>确实是稍微有点繁琐，我们能不能在某一处进行配置，就能让所有的模型类都可以使用该主键ID策略呢?</p><p>答案是肯定有，我们只需要在配置文件中添加如下内容:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>    <span class="token key atrule">id-type</span><span class="token punctuation">:</span> assign_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成后，每个模型类的主键ID策略都将成为assign_id.</p><p><strong>数据库表与模型类的映射关系</strong></p><p>MP会默认将模型类的类名名首字母小写作为表名使用，假如数据库表的名称都以<code>tbl_</code>开头，那么我们就需要将所有的模型类上添加<code>@TableName</code>，如:</p><img src="/2024/05/21/ssm/1631245757169-1717399327044.png" alt="1631245757169" style="zoom:80%;"><p>配置起来还是比较繁琐，简化方式为在配置文件中配置如下内容:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>    <span class="token key atrule">table-prefix</span><span class="token punctuation">:</span> tbl_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置表的前缀内容，这样MP就会拿 <code>tbl_</code>加上模型类的首字母小写，就刚好组装成数据库的表名。</p><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><p><strong>@TableLogic</strong></p><table><thead><tr><th>名称</th><th>@TableLogic</th></tr></thead><tbody><tr><td>类型</td><td>==属性注解==</td></tr><tr><td>位置</td><td>模型类中用于表示删除字段的属性定义上方</td></tr><tr><td>作用</td><td>标识该字段为进行逻辑删除的字段</td></tr><tr><td>相关属性</td><td>value：逻辑未删除值<br>delval:逻辑删除值</td></tr></tbody></table><h3 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h3><h4 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>com<span class="token punctuation">.</span>baomidou<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>mybatis<span class="token operator">-</span>plus<span class="token operator">-</span>generator<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">3.5</span><span class="token number">.6</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于代码生成器用到了模板引擎，请自行引入您喜好的模板引擎。MyBatis-Plus Generator 支持如下模板引擎：</p><ul><li>VelocityTemplateEngine(Default)</li><li>FreemarkerTemplateEngine</li><li>BeetlTemplateEngine</li><li>EnjoyTemplateEngine</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>velocity<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>velocity<span class="token operator">-</span>engine<span class="token operator">-</span>core<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">2.3</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码生成类"><a href="#代码生成类" class="headerlink" title="代码生成类"></a>代码生成类</h5><p>在 CodeGenerator 中的 main 方法中直接添加生成器代码，并进行相关配置，然后直接运行即可生成代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">FastAutoGenerator</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">,</span> <span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">)</span>        <span class="token comment">// 全局配置</span>            <span class="token punctuation">.</span><span class="token function">globalConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                builder<span class="token punctuation">.</span><span class="token function">author</span><span class="token punctuation">(</span><span class="token string">"baomidou"</span><span class="token punctuation">)</span> <span class="token comment">// 设置作者</span>                        <span class="token punctuation">.</span><span class="token function">enableSwagger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 开启 swagger 模式</span>                        <span class="token punctuation">.</span><span class="token function">outputDir</span><span class="token punctuation">(</span><span class="token string">"D://"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指定输出目录</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token comment">// 数据源配置</span>            <span class="token punctuation">.</span><span class="token function">dataSourceConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span>                    builder<span class="token punctuation">.</span><span class="token function">typeConvertHandler</span><span class="token punctuation">(</span><span class="token punctuation">(</span>globalConfig<span class="token punctuation">,</span> typeRegistry<span class="token punctuation">,</span> metaInfo<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> typeCode <span class="token operator">=</span> metaInfo<span class="token punctuation">.</span><span class="token function">getJdbcType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token constant">TYPE_CODE</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>typeCode <span class="token operator">==</span> <span class="token class-name">Types</span><span class="token punctuation">.</span><span class="token constant">SMALLINT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment">// 自定义类型转换</span>                            <span class="token keyword">return</span> <span class="token class-name">DbColumnType</span><span class="token punctuation">.</span><span class="token constant">INTEGER</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">return</span> typeRegistry<span class="token punctuation">.</span><span class="token function">getColumnType</span><span class="token punctuation">(</span>metaInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token comment">// 包配置</span>            <span class="token punctuation">.</span><span class="token function">packageConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span>                    builder<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token string">"com.baomidou.mybatisplus.samples.generator"</span><span class="token punctuation">)</span> <span class="token comment">// 设置父包名</span>                            <span class="token punctuation">.</span><span class="token function">moduleName</span><span class="token punctuation">(</span><span class="token string">"system"</span><span class="token punctuation">)</span> <span class="token comment">// 设置父包模块名</span>                            <span class="token punctuation">.</span><span class="token function">pathInfo</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonMap</span><span class="token punctuation">(</span><span class="token class-name">OutputFile</span><span class="token punctuation">.</span>xml<span class="token punctuation">,</span> <span class="token string">"D://"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 设置mapperXml生成路径</span>            <span class="token punctuation">)</span>        <span class="token comment">// 策略配置</span>            <span class="token punctuation">.</span><span class="token function">strategyConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span>                    builder<span class="token punctuation">.</span><span class="token function">addInclude</span><span class="token punctuation">(</span><span class="token string">"t_simple"</span><span class="token punctuation">)</span> <span class="token comment">// 设置需要生成的表名</span>                            <span class="token punctuation">.</span><span class="token function">addTablePrefix</span><span class="token punctuation">(</span><span class="token string">"t_"</span><span class="token punctuation">,</span> <span class="token string">"c_"</span><span class="token punctuation">)</span> <span class="token comment">// 设置过滤表前缀</span>            <span class="token punctuation">)</span>        <span class="token comment">// 模板引擎</span>            <span class="token punctuation">.</span><span class="token function">templateEngine</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FreemarkerTemplateEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 使用Freemarker引擎模板，默认的是Velocity引擎模板</span>            <span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Service-Interface"><a href="#Service-Interface" class="headerlink" title="Service Interface"></a>Service Interface</h3><p>IService是 MyBatis-Plus 提供的一个通用 Service 层接口，它封装了常见的 CRUD 操作，包括插入、删除、查询和分页等。通过继承 IService 接口，可以快速实现对数据库的基本操作，同时保持代码的简洁性和可维护性。</p><p><strong>IService 接口中的方法命名遵循了一定的规范，如 get 用于查询单行，remove 用于删除，list 用于查询集合，page 用于分页查询，这样可以避免与 Mapper 层的方法混淆。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token keyword">extends</span> <span class="token class-name">IService</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserDao</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 插入一条记录（选择字段，策略插入）</span><span class="token keyword">boolean</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 插入（批量）</span><span class="token keyword">boolean</span> <span class="token function">saveBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 插入（批量）</span><span class="token keyword">boolean</span> <span class="token function">saveBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">,</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*  根据实体对象的主键 ID 进行判断，存在则更新记录，否则插入记录。 */</span><span class="token comment">// TableId 注解属性值存在则更新记录，否则插入一条记录</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdate</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据updateWrapper尝试更新，否则继续执行saveOrUpdate(T)方法</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdate</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> updateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 批量修改插入</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdateBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 批量修改插入</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdateBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">,</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 queryWrapper 设置的条件，删除记录</span><span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 删除</span><span class="token keyword">boolean</span> <span class="token function">removeById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 columnMap 条件，删除记录</span><span class="token keyword">boolean</span> <span class="token function">removeByMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 删除（根据ID 批量删除）</span><span class="token keyword">boolean</span> <span class="token function">removeByIds</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> idList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span><span class="token keyword">boolean</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> updateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 whereWrapper 条件，更新记录</span><span class="token keyword">boolean</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">T</span> updateEntity<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> whereWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 选择修改</span><span class="token keyword">boolean</span> <span class="token function">updateById</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据ID 批量更新</span><span class="token keyword">boolean</span> <span class="token function">updateBatchById</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据ID 批量更新</span><span class="token keyword">boolean</span> <span class="token function">updateBatchById</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">,</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 查询</span><span class="token class-name">T</span> <span class="token function">getById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last("LIMIT 1")</span><span class="token class-name">T</span> <span class="token function">getOne</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录</span><span class="token class-name">T</span> <span class="token function">getOne</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">,</span> <span class="token keyword">boolean</span> throwEx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">V</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询所有</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询列表</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询（根据ID 批量查询）</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">listByIds</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> idList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询（根据 columnMap 条件）</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">listByMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询所有列表</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">listMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询列表</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">listMaps</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询全部记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询全部记录</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询全部记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询全部记录</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 无条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">page</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">page</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 无条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">pageMaps</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">pageMaps</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询总记录数</span><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询总记录数</span><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自3.4.3.2开始,返回值修改为long</span><span class="token comment">// 查询总记录数</span><span class="token keyword">long</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询总记录数</span><span class="token keyword">long</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员SSM：<a href="https://www.bilibili.com/video/BV1Fi4y1S7ix/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1Fi4y1S7ix/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>JavaGuide：<a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></p><p>spring中BeanFactory和FactoryBean的区别：<a href="https://blog.csdn.net/dongyang2019/article/details/113725058">https://blog.csdn.net/dongyang2019/article/details/113725058</a></p><p>Nan-ying’s blog：<a href="https://nan-ying.github.io/2023/07/10/Spring/#%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A6%82%E5%BF%B5">https://nan-ying.github.io/2023/07/10/Spring/#%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A6%82%E5%BF%B5</a></p><p>牛客高启盛同学资料：<a href="https://github.com/viego1999/JavaWxy">https://github.com/viego1999/JavaWxy</a></p><p>MybatisPlus官方文档：<a href="https://baomidou.com/guides/data-interface/">https://baomidou.com/guides/data-interface/</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评</title>
      <link href="/2024/05/13/hei-ma-dian-ping/"/>
      <url>/2024/05/13/hei-ma-dian-ping/</url>
      
        <content type="html"><![CDATA[<h1 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h1><h2 id="MySQL表"><a href="#MySQL表" class="headerlink" title="MySQL表"></a>MySQL表</h2><ul><li>tb_user：用户表</li><li>tb_user_info：用户详情表</li><li>tb_shop：商户信息表</li><li>tb_shop_type：商户类型表</li><li>tb_blog：用户日记表（达人探店日记）</li><li>tb_follow：用户关注表</li><li>tb_voucher：优惠券表</li><li>tb_voucher_order：优惠券的订单表</li></ul><h2 id="当前模型"><a href="#当前模型" class="headerlink" title="当前模型"></a>当前模型</h2><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的是HTTP协议，可以实现<strong>基于Lua直接绕开tomcat访问redis</strong>，也可以作为<strong>静态资源服务器</strong>，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p><p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们<strong>在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群对外提供更好的服务。</strong></p><h2 id="用户鉴权"><a href="#用户鉴权" class="headerlink" title="用户鉴权"></a>用户鉴权</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>cookie 是一个非常具体的东西，指的就是<strong>浏览器里面能永久存储</strong>的一种数据，仅仅是浏览器实现的一种数据存储功能。</p><p>cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。</p><p>由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p><p><strong>Cookie 技术主要用于：</strong></p><ul><li>身份验证：保存用户登录状态，实现持久登录。</li><li>会话管理：追踪用户的会话信息，例如购物车内容。</li><li>个性化设置：存储用户偏好设置，以提供个性化的用户体验。</li></ul><p>Cookie 的相关操作和属性可以通过 JavaScript 的 document.cookie 对象进行访问和修改。可以设置 Cookie 的<strong>过期时间、作用域、路径</strong>等属性，以控制其有效性和访问范围。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session（会话）是一种<strong>在服务器端存储用户状态和数据的机制</strong>。它通过在服务器端创建一个唯一的会话标识（通常是一个 Session ID），并将该标识发送给客户端，实现在不同的请求中跟踪和管理用户的状态。</p><p>当用户访问一个网站时，服务器会为该用户创建一个会话，并将会话 ID 存储在 Cookie 中，或者通过其他方式将其发送给客户端。客户端的浏览器会自动在后续的请求中<strong>将会话 ID 发送给服务器，在服务器端找到对应的会话数据。</strong></p><p>会话数据存储在服务器端的临时存储区域，通常是在服务器的内存中或在数据库中。服务器会根据会话 ID 来检索和更新相应的数据，从而实现用户状态的管理和维护。</p><p><strong>Session 技术的主要作用：</strong></p><ul><li>身份验证：存储用户登录信息和权限，实现用户认证。</li><li>会话管理：追踪用户的操作和活动，在请求之间保持连续性。</li><li>数据存储：存储用户数据，例如购物车、表单数据等。</li></ul><p>需要注意的是，为了保护用户数据的安全性和隐私，开发人员应采取适当的安全措施：</p><ul><li>使用安全的传输协议（如 HTTPS）来保护会话数据在网络传输中的安全性。</li><li>针对会话 ID 的保护，包括生成安全的随机会话 ID、设置合适的过期时间，以及通过 HttpOnly 和 Secure 标志来防止跨站脚本攻击和会话劫持。</li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>Token（令牌）是一种<strong>在身份验证和授权中使用的字符串</strong>，用于验证客户端的身份和权限。它作为客户端和服务器之间进行安全通信的一种方式，来确保用户的身份和访问权限。</p><p>Token 的主要特点是它是<strong>无状态</strong>的，<strong>即服务器不需要在存储设备中维护任何信息</strong>。服务器在生成 Token 后，将其发送给客户端，客户端在以后的请求中将 Token 作为身份凭证发送给服务器。服务器通过验证 Token 的有效性，来确认客户端的身份和权限。</p><p>Token 的生成和验证过程一般包含以下步骤：</p><ul><li>客户端向服务器发送身份验证请求，通常是提供用户名和密码。</li><li>服务器验证客户端提供的身份信息，并生成一个 Token。</li><li>服务器将生成的 Token 发送给客户端，客户端将其保存。</li><li>客户端在以后的请求中将 Token 添加到请求头中，作为身份凭证。</li><li>服务器在接收到请求时，验证 Token 的有效性和权限，并相应地处理请求。</li></ul><p><strong>Token 的主要作用：</strong></p><ul><li>身份验证：通过 Token 来验证客户端的身份，替代传统的基于会话的身份验证机制，不需要在服务器端存储会话信息，减轻服务器的负担。</li><li>授权：服务器可以根据 Token 中的信息来判断客户端的权限，决定是否允许相应的操作。</li><li>单点登录（SSO）：Token 可以在不同的应用程序之间共享，实现用户的单点登录功能。</li></ul><p>Token 可以有不同的类型和格式，常见的包括 JSON Web Token（JWT）、OAuth 2.0 的访问令牌等。同时，Token 也可以通过加密和签名等方式来保证其安全性。</p><h2 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h2><h3 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h3><blockquote><p>1、用户提交手机号<br>2、校验手机号是否合法<br>3、生成验证码<br>4、将生成的验证码保存到session中，用于后续的验证<br>5、发送验证码给用户</p></blockquote><p><strong>接口地址</strong>:<code>/user/code</code></p><p><strong>请求方式</strong>:<code>POST</code></p><p><strong>请求数据类型</strong>:<code>application/json</code></p><p><strong>请求参数</strong>:</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>请求类型</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>phone</td><td></td><td>query</td><td>true</td><td>string</td><td></td></tr><tr><td>session</td><td></td><td>query</td><td>true</td><td>HttpSession</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">{</span><span class="token string-property property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string-property property">"errorMsg"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token string-property property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token string-property property">"total"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="登录-注册"><a href="#登录-注册" class="headerlink" title="登录/注册"></a>登录/注册</h3><blockquote><p>1、提交手机号和验证码<br>2、校验验证码<br>3、根据手机号查询数据库信息<br>4、用户存在就保存到session，否则就创建新用户并保存到数据库，最后也保存到session中</p></blockquote><p><strong>接口地址</strong>:<code>/user/login</code></p><p><strong>请求方式</strong>:<code>POST</code></p><p><strong>请求数据类型</strong>:<code>application/json</code></p><p><strong>请求参数</strong>:</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>请求类型</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>loginForm</td><td>loginForm</td><td>body</td><td>true</td><td>LoginFormDTO</td><td>LoginFormDTO</td></tr><tr><td>  code</td><td></td><td></td><td>false</td><td>string</td><td></td></tr><tr><td>  password</td><td></td><td></td><td>false</td><td>string</td><td></td></tr><tr><td>  phone</td><td></td><td></td><td>false</td><td>string</td><td></td></tr><tr><td>session</td><td></td><td>query</td><td>true</td><td>HttpSession</td><td></td></tr></tbody></table><h3 id="校验登录状态-拦截器"><a href="#校验登录状态-拦截器" class="headerlink" title="校验登录状态-拦截器"></a>校验登录状态-拦截器</h3><p>首先我们要知道怎么基于session进行校验，session是基于cookie的（每一个session的id都会保存到cookie中），当用户访问的时候会携带cookie，所以我们可以根据cookie中的session_id来查询session中是否有这个用户：</p><blockquote><p>1、用户发送请求并携带cookie<br>2、从session中获取用户<br>3、判断用户是否存在：<br>（1）没有这个用户就拦截<br>（2）有这个用户就保存用户信息到ThreadLocal用于登录缓存（ThreadLocal是一个线程域对象，<strong>每一个请求到达服务都会是一个独立线程，直接保存到本地变量会出现并发修改的安全问题，而ThreadLocal会将数据保存到每个线程内部，在线程内部创建一个Map来进行保存</strong>），保存完后就放行该用户即可</p></blockquote><p>基于session校验需要<strong>在跨各种组件和页面的时候都访问session，编写重复的校验代码</strong>，增加了访问session的开销。所以使用ThreadLocal，使得每一个线程只需要访问一次session。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MvcConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoginInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span>   <span class="token comment">// 白名单</span>                        <span class="token string">"/shop/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/shop-type/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/voucher/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/upload/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/blog/hot"</span><span class="token punctuation">,</span>                        <span class="token string">"/user/code"</span><span class="token punctuation">,</span>                        <span class="token string">"/user/login"</span>                <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取客户端请求传进来的session</span>        <span class="token class-name">HttpSession</span> session <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取user</span>        <span class="token class-name">Object</span> user <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 用户不存在，拦截，返回401状态码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 用户存在session中，保存到localthread，放行</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">UserDTO</span><span class="token punctuation">)</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 线程执行后移除用户</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">removeUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="集群的session共享问题"><a href="#集群的session共享问题" class="headerlink" title="集群的session共享问题"></a>集群的session共享问题</h3><p><strong>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同Tomcat服务时导致数据丢失的问题。</strong><br>这是因为我们为了我们将来系统的<strong>高并发性</strong>，就需要<strong>水平拓展，形成负载均衡的集群</strong>，<strong>每个Tomcat都会有一个对应的session。当我们在某一台Tomcat上进行登录以后，第二次登录的时候，要是被负载均衡到了另一台Tomcat，就会造成没办法获得之前登录时的session，就没办法再做验证了。</strong><br>这个问题听起来好像也挺容易解决，如果每台Tomcat都互相拷贝，保存相同的数据，那肯定就不至于发生如上的问题，但是这样的解决方式太浪费空间了，而且拷贝的过程还是比较费时的，如果这时候已经有访问请求，就可能会出现数据不一致的情况。<br>因此，我们的session信息共享的解决方案应该满足以下特点：<br><strong>1、数据共享</strong><br>2、内存存储<br>3、key-value结构<br>这时候我们就回到了Redis了，我们知道Redis是独立于Tomcat的，单独进行存储，且任何一台Tomcat都可以访问到Redis，因此可以实现数据共享</p><h4 id="基于Redis实现共享session"><a href="#基于Redis实现共享session" class="headerlink" title="基于Redis实现共享session"></a>基于Redis实现共享session</h4><h5 id="发送验证码-1"><a href="#发送验证码-1" class="headerlink" title="发送验证码"></a>发送验证码</h5><p>验证码保存到redis中，Redis的结构是key-value的，且value是很多种类型的，在这里我们选择最简单的String类型即可。</p><blockquote><p>一个需要考虑的问题是key的选取，在session中我们选用了“code”来作为key，但在这里却不行。这是因为<strong>每一个不同的浏览器在发送请求的时候都会有一个不同的独立的session，也就是说Tomcat的内部维护了很多的session，互相之间是不会干扰的</strong>。但是Redis是一个共享的内存空间，如果直接使用key会造成<strong>覆盖</strong>，所以我们不能直接选用“code”来作为key。因此我们可以<strong>用手机号作为key（因为同一账号同一时刻仅在一个平台登录）。</strong></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">sendCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> phone<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 校验手机号，正则，不合法则返回错误信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">RegexUtils</span><span class="token punctuation">.</span><span class="token function">isPhoneInvalid</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"手机号格式错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 生成验证码</span>    <span class="token class-name">String</span> code <span class="token operator">=</span> <span class="token class-name">RandomUtil</span><span class="token punctuation">.</span><span class="token function">randomNumbers</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保存验证码到redis，用phone为key，限制有效期5min</span>    <span class="token comment">//        session.setAttribute("code", code);  这个是存到session</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">LOGIN_CODE_KEY</span><span class="token operator">+</span>phone<span class="token punctuation">,</span> code<span class="token punctuation">,</span> <span class="token constant">LOGIN_CODE_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送验证码，调用第三方平台</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"发送验证码："</span> <span class="token operator">+</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="验证码登录与注册"><a href="#验证码登录与注册" class="headerlink" title="验证码登录与注册"></a>验证码登录与注册</h5><p>最终的用户信息不再保存到session中，而是保存都Redis中去了，同样要考虑key跟value的选择：<br>（1）value的选取：我们要保存的是用户的信息，这是一个对象。我们用Hash结构是最合适的。<br>（2）key的选取：这里并不建议用phone作为key，而是<strong>以随机token（服务器生成的令牌）为key来存储用户数据</strong>，因为<strong>这里的token要存到前端，使用手机号为key不安全，容易泄露。</strong></p><p>在之前我们校验登录状态的时候，是从cookie中获取session再得到用户信息，而现在我们校验登录的时候<strong>要访问的凭证就是这个随机token了</strong>，但Tomcat不会将这个token自动写到浏览器上面。所以我们<strong>把数据保存到Redis以后还需要手动的把token返回到前端</strong>，流程就得修改：</p><blockquote><p>1、提交手机号和验证码<br>2、校验验证码<br>3、根据手机号查询用户信息<br>4、<strong>用户保存到Redis</strong><br>5、<strong>返回token给客户端（重要一步）</strong></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">LoginFormDTO</span> loginForm<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> phone <span class="token operator">=</span> loginForm<span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 校验手机号</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">RegexUtils</span><span class="token punctuation">.</span><span class="token function">isPhoneInvalid</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"手机号格式错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 校验验证码，从redis中获取验证码</span>    <span class="token comment">//        Object cacheCode = session.getAttribute("code");</span>    <span class="token class-name">String</span> cacheCode <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">LOGIN_CODE_KEY</span> <span class="token operator">+</span> phone<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> code <span class="token operator">=</span> loginForm<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 不一致，报错</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheCode <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>cacheCode<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"验证码错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 一致，查数据库tb_user</span>    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"phone"</span><span class="token punctuation">,</span> phone<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 不存在，创建新用户</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        user <span class="token operator">=</span> <span class="token function">createUserWithPhone</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 保存用户信息DTO(id，昵称，头像信息)到redis，需要生成token</span>    <span class="token class-name">String</span> token <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">UserDTO</span> userDTO <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token class-name">UserDTO</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将user对象转为map类型，拆分所有字段，以哈希结构存到redis里 -- 对象中的数据类型都应该是string</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> userMap <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">beanToMap</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 将Java对象（Bean）转换为Map类型</span>                                                     <span class="token class-name">CopyOptions</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 对象转换时的配置项</span>                                                     <span class="token punctuation">.</span><span class="token function">setIgnoreNullValue</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>   <span class="token comment">// 是否忽略空值，当源对象的值为null时，true: 忽略而不注入此值，false: 注入null</span>                                                     <span class="token punctuation">.</span><span class="token function">setFieldValueEditor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">,</span> fieldValue<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> fieldValue<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 对转换过程中的字段值进行编辑处理，对象值转为string</span>    <span class="token class-name">String</span> user_token <span class="token operator">=</span> <span class="token constant">LOGIN_USER_KEY</span> <span class="token operator">+</span> token<span class="token punctuation">;</span>    <span class="token comment">// 这里long id直接转string会报错</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>user_token<span class="token punctuation">,</span> userMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置token有效期（超过30分钟没有访问就删除）</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>user_token<span class="token punctuation">,</span> <span class="token constant">LOGIN_USER_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//        session.setAttribute("user", BeanUtil.copyProperties(user, UserDTO.class));</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/05/13/hei-ma-dian-ping/image-20240515164315155.png"><h5 id="校验登录状态"><a href="#校验登录状态" class="headerlink" title="校验登录状态"></a>校验登录状态</h5><p>我们不再是从浏览器中的cookie指定的session来获取用户信息，而是以随机token为key来从Redis中获取信息，流程如下：</p><blockquote><p>1、用户发送请求并<strong>携带token</strong><br>2、从Redis中获取用户（以随机token为key）<br>3、判断用户是否存在：<br>（1）没有这个用户就拦截<br>（2）有这个用户就保存用户信息到ThreadLocal，并放行</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token comment">// 这个拦截器类不是由spring管理的，所以需要手动构造stringRedisTemplate而不能用依赖注入</span>    <span class="token comment">// 通过调用该类的spring类注入stringRedisTemplate，然后传递参数到拦截器来完成构造</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">LoginInterceptor</span><span class="token punctuation">(</span><span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取客户端请求头传进来的token</span>        <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        HttpSession session = request.getSession();</span>        <span class="token comment">// token为空或仅包含空白字符</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 基于token构造redis中存的用户信息的key</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_KEY</span> <span class="token operator">+</span> token<span class="token punctuation">;</span>        <span class="token comment">// 基于token获取redis中存的user</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> userMap <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 用户不存在，拦截，返回401状态码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>userMap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">UserDTO</span> userDTO <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">fillBeanWithMap</span><span class="token punctuation">(</span>userMap<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 用户存在，保存到localthread，放行</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新过期时间 -- 也就是每次访问新的页面，进行拦截器判断，更新过期时间</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 线程执行后移除用户</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">removeUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="解决状态登录刷新的问题——登录拦截器的优化"><a href="#解决状态登录刷新的问题——登录拦截器的优化" class="headerlink" title="解决状态登录刷新的问题——登录拦截器的优化"></a>解决状态登录刷新的问题——登录拦截器的优化</h5><p>上述代码实现完还有一点小问题，之前的拦截器并不会拦截掉一切路径，而是所有需要登录的路径，那么会出现一个问题：我们的首页并不需要登录就可以直接访问，那么<strong>已经登录过的用户一直在首页进行操作，拦截器中的登录状态并不会刷新，就可能造成明明一直在操作系统，却被视为不算是在登录状态。</strong><br>解决方法是<strong>再加上一个拦截器，用户的请求要先经过这个拦截器，这个拦截器会拦截一切的路径，所以我们可以在这个拦截器里面进行token有效期的刷新操作：</strong></p><blockquote><p>1、获取token<br>2、查询Redis的用户<br>3、保存到ThreadLocal<br>4、刷新token有效期<br>5、放行</p></blockquote><p>这样的话，一切的请求都会触发刷新的操作。那么<strong>之前的拦截器只需要查询ThreadLocal的用户，存在则继续，不存在则拦截。</strong></p><p>新的拦截一切的拦截器做用户校验，存到threadlocal并放行一切：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取客户端请求头传进来的token</span>    <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// token为空或仅包含空白字符，直接放行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 基于token构造redis中存的用户信息的key</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_KEY</span> <span class="token operator">+</span> token<span class="token punctuation">;</span>    <span class="token comment">// 基于key获取redis中存的user</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> userMap <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用户不存在，直接放行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>userMap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">UserDTO</span> userDTO <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">fillBeanWithMap</span><span class="token punctuation">(</span>userMap<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用户存在，保存到localthread，更新放行</span>    <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新过期时间</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>旧的拦截器只检查threadlocal有没有用户：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token comment">// 在login拦截器中只需要校验threadlocal里面有没有存用户，没有则拦截</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="==商户查询缓存=="></a>==商户查询缓存==</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h3><p>缓存：数据交换的缓冲区（Cache），是<strong>存储数据的临时地方，读写性能高。</strong>俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">例<span class="token number">1</span><span class="token operator">:</span><span class="token class-name">Static</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 本地用于高并发例<span class="token number">2</span><span class="token operator">:</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token constant">USER_CACHE</span> <span class="token operator">=</span> <span class="token class-name">CacheBuilder</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 用于redis等缓存例<span class="token number">3</span><span class="token operator">:</span><span class="token class-name">Static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 本地缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;</p><p>我们的浏览器有浏览器缓存，在浏览器未命中数据，就会在tomcat的应用层缓存中取数据，再没有命中的话就去数据库进行查询检索。<br><strong>缓存的作用：</strong><br>1、降低后端负载<br>2、提高读写效率，降低响应时间<br><strong>缓存的成本：</strong><br>1、数据的一致性成本<br>2、代码维护成本（解决一致性问题的时候带来的代码复杂）<br>3、运维的成本</p><h3 id="商户查询添加缓存"><a href="#商户查询添加缓存" class="headerlink" title="商户查询添加缓存"></a>商户查询添加缓存</h3><p>如果直接查数据库，逻辑是这样的。速度慢</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryShopById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//这里是直接查询数据库</span>    <span class="token keyword">return</span> shopService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改成缓存，用string类型存商户json信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 查缓存，若存在直接返回，不存在就查数据库</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 存在店铺信息，反序列化json为bean对象并返回</span>            <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span>  <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 查数据库</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>shop <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"店铺不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 数据库中存在，将店铺信息序列化为json字符串，存储到redis缓存中</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="商户类型序列缓存"><a href="#商户类型序列缓存" class="headerlink" title="商户类型序列缓存"></a>商户类型序列缓存</h3><p>shopTypeController</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"list"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//        List&lt;ShopType&gt; typeList = typeService</span>    <span class="token comment">//                .query().orderByAsc("sort").list();</span>    <span class="token keyword">return</span> typeService<span class="token punctuation">.</span><span class="token function">queryShopTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shopTypeServiceImpl</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShopTypeServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShopTypeMapper</span><span class="token punctuation">,</span> <span class="token class-name">ShopType</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">IShopTypeService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryShopTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 要返回的商户列表</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShopType</span><span class="token punctuation">&gt;</span></span> typeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 存到redis中的商户类型list，是商户这个类型的json字符串的list集合</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisTypeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查询redis缓存</span>        <span class="token class-name">Long</span> size <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOPTYPE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 缓存有数据就返回</span>            redisTypeList <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOPTYPE_KEY</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 利用stream流和map将string类型的json list转换为bean list</span>            typeList <span class="token operator">=</span> redisTypeList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token class-name">ShopType</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>typeList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 缓存没有，查数据库，存缓存，返回</span>        typeList <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orderByAsc</span><span class="token punctuation">(</span><span class="token string">"sort"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>typeList <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> typeList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"不存在商户类型数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查到的bean list通过stream流转为string list，存到缓存</span>        redisTypeList <span class="token operator">=</span> typeList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>shopType<span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>shopType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPushAll</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOPTYPE_KEY</span><span class="token punctuation">,</span> redisTypeList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>typeList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>上面的作用模型可能会造成数据一致性问题，当我们对数据库进行修改的时候，缓存并没有同步进行修改，页面在缓存中获取数据的时候，其实并不是最新的数据。这肯定是不允许的。</p><p>下面是缓存更新策略：</p><table><thead><tr><th></th><th align="center">内存淘汰</th><th align="center">超时剔除</th><th align="center">主动更新</th></tr></thead><tbody><tr><td>说明</td><td align="center">不用自己维护，利用Redis的内存淘汰机制，<strong>内存不足时自动淘汰部分数据</strong>，下次查询时更新缓存</td><td align="center">给缓存数据添加TTL时间，<strong>到期后自动删除缓存</strong>。下次查询即可实现缓存的更新</td><td align="center">自己编写业务逻辑，在修改数据库的同时，更新缓存</td></tr><tr><td>一致性</td><td align="center">差</td><td align="center">一般</td><td align="center">好</td></tr><tr><td>维护成本</td><td align="center">无</td><td align="center">低</td><td align="center">高</td></tr></tbody></table><p>上述的策略选择要根据具体的业务场景：<br>1、低一致性需求/数据很少更新：使用内存淘汰机制。例如店铺类型的查询缓存。<br>2、高一致性需求：<strong>主动更新，以超时剔除作兜底方案。例如店铺详情查询的缓存。</strong></p><h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p>1、<strong>Cache Aside Pattern（最常用）</strong> – 由缓存的调用者，在更新数据库的同时更新缓存<br>2、<strong>Read/Write Through Pattern</strong> – 缓存与数据库整合为一个<strong>服务</strong>，由服务来维护一致性（调用者不知道服务内部）。调用者调用该服务无需关注一致性问题。但这种服务的成本肯定是很高的。<br>3、<strong>Write Behind Caching Pattern（写回）</strong> – 调用<strong>者只操作缓存</strong>，<strong>由其它线程异步的将缓存数据持久化到数据库</strong>，保证最终一致。<br>比如我们一直对缓存进行更新，更新10次以后轮到这个线程工作，就维护一下数据库的数据为更新10次后的数据，中途的其他9次更新操作根本不重要，这样的<strong>性能显然是很高的</strong>。这种方式当然也有很大问题，比如<strong>长期的数据不一致、缓存宕机造成的严重后果</strong>等。</p><p>操作缓存和数据库时要考虑如下几个问题：</p><ul><li>删除缓存还是更新缓存？ <ul><li>更新缓存：每次更新数据库都更新缓存，<strong>无效写操作较多</strong>。（写多读少的情况，假设更新100次数据，读1次数据，这边会有100次无效更新缓存）</li><li>删除缓存：<strong>更新数据库时让缓存失效，查询时再更新缓存</strong>（<strong>更优</strong>） 。（写多读少时，更新100次也只需要删一次缓存，避免无效写操作）</li></ul></li><li>如何保证缓存和数据库的操作的同时成功或失败？（原子性） <br>- 单体系统：<strong>事务控制</strong>，将缓存与数据库操作放在一个事务 <br>- 分布式系统：利用TCC等<strong>分布式事务方案</strong> </li><li>先操作缓存还是先操作数据库？（线程安全） <br>- 先删除缓存，再操作数据库 <br>- 先操作数据库，再删除缓存 - 由于 redis 的速度远比MySQL要快，所以方案二为优选</li></ul><p><strong>先删缓存再操作数据库的线程安全问题：</strong>正常情况如左图，两个线程得到的数据一致。异常情况下如果线程2（读操作）在线程1写数据库之前查缓存，就会使得缓存与数据库不同步。因为写MySQL数据库操作比查Redis缓存操作慢，所以异常情况很容易发生。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516121851596.png" style="zoom:80%;"><p><strong>先操作数据库再删缓存的线程安全问题</strong>：正常情况如左图。异常情况如右图。异常情况发生条件是（1）线程并行（2）缓存失效（3）在线程1（读操作）查数据库过程中，线程2完成了更新数据库和删缓存两个操作。由于MySQL写数据比查数据慢，在微秒级别内完成更新数据库和删除缓存概率很低。所以这个方式更好。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516122155989.png" alt="image-20240516122155989" style="zoom:80%;"><h3 id="总结Redis读写策略"><a href="#总结Redis读写策略" class="headerlink" title="总结Redis读写策略"></a>总结Redis读写策略</h3><p>读操作：</p><ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li></ul><p>写操作：</p><ul><li><strong>先写数据库，然后再删除缓存</strong></li><li>要确保数据库与缓存操作的原子性</li></ul><h2 id="商铺缓存与双写一致"><a href="#商铺缓存与双写一致" class="headerlink" title="商铺缓存与双写一致"></a>商铺缓存与双写一致</h2><p>现在我们要给查询商铺的缓存添加<strong>主动更新</strong>和<strong>超时剔除</strong>策略。<br>修改ShopController的业务逻辑满足：<br>（1）根据id查询店铺，没命中就查数据库，然后写入缓存，<strong>并设置超时时间</strong><br>（2）根据id<strong>修改</strong>店铺，<strong>先操作数据库，再删除缓存</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span>  <span class="token comment">// 通过事务控制数据库和缓存操作的原子性</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Shop</span> shop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Long</span> id <span class="token operator">=</span> shop<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"店铺不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新数据库</span>    <span class="token function">updateById</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 删除缓存</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="缓存穿透、雪崩、击穿"><a href="#缓存穿透、雪崩、击穿" class="headerlink" title="缓存穿透、雪崩、击穿"></a>缓存穿透、雪崩、击穿</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透</strong>是指<strong>客户端请求的数据在缓存和数据库中都不存在</strong>，这样缓存永远不会生效，这些请求都会打到数据库。不断发起这样的请求，给数据库带来巨大压力。过程即：<br>（1）客户端访问Redis，未命中（2）接着访问数据库，未命中<br>这样的话，如果有人恶意多线程地访问不存在的内容，可能就把我们的系统弄垮了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>1、缓存空对象：</strong><br>（1）客户端请求Redis，未命中<br>（2）接着访问数据库，未命中<br>（3）<strong>数据库将空值null缓存到Redis里</strong><br>这样如果继续访问的话，<strong>就会访问Redis了，不会一直去对数据库造成攻击</strong>，尽管访问Redis以后返回的内容是NULL。<br><strong>优点</strong>：实现简单，维护方便<br><strong>缺点</strong>：<strong>额外内存消耗</strong>（每次进行不同的访问，都创建null，不过设置TTL可以解决）；可能<strong>造成短期的不一致</strong>（设置为NULL之后，数据库真的新增了这个数据，不过设置TTL可以有效缓解这种情况的出现概率）</p><p><strong>2、布隆过滤：</strong><br>这其实是一种算法，它<strong>在客户端与Redis交互之间加了一个布隆过滤器</strong>：<br>（1）用户请求布隆过滤器，<strong>不存在就直接拒绝</strong><br>（2）存在的话就放行，让客户端去访问Redis，有就返回，没有就访问数据库<br>布隆过滤器存储的一系列的二进制位，<strong>这种二进制数是先对数据库数据进行某种哈希运算以后再转成二进制存储到布隆过滤器的</strong>，具体原理可以自行查询，这种算法实现方式决定了<strong>过滤器存在概率性</strong>：如果过滤器返回<strong>不存在</strong>，那就是不存在；如果返回<strong>存在</strong>，那就不一定了。</p><p><strong>优点</strong>：<strong>内存占用较少</strong>，没有多余key<br><strong>缺点</strong>：实现复杂（不过Redis里面存在，可以简化开发）；存在<strong>误判可能</strong>。</p><p>因为布隆过滤器存在误判，所以我们的开发过程中，会选择<strong>缓存空对象</strong>的方式来解决缓存穿透。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516130239055.png" alt="image-20240516130239055"><p><strong>缓存穿透的其他解决方案：</strong></p><ul><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="解决商铺查询的缓存穿透问题"><a href="#解决商铺查询的缓存穿透问题" class="headerlink" title="解决商铺查询的缓存穿透问题"></a>解决商铺查询的缓存穿透问题</h3><p>1、我们需要在之前业务流程环节中增加缓存空对象的环节，即可解决，也就是根据id查询数据库的时候，判断商铺不存在之后，不再直接结束，而是将空值写入Redis。<br>2、那么我们之后的查询，可以在缓存中查询出null值，因此我们的查询就需要对查询出来的值进行判断，不是空值的话才能返回商铺信息到前端。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516214714449.png" alt="image-20240516214714449" style="zoom:80%;"><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩</strong>是指在同一时段<strong>大量的缓存key同时失效或者Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</p><p>正常情况下，大量请求会到达Redis，少数请求到达数据库。而Redis一旦宕机，或者Redis中的大量key都因为TTL到期而失效了，这时候的很多请求都会指向数据库。<br>针对这个问题，我们可以提出一些解决方案：<br>1、给不同的key的<strong>TTL添加随机值</strong>，避免大量的key在同一个小时段内失效<br>2、利用<strong>Redis集群</strong>提高服务的可用性（Redis哨兵机制可以实现服务的监控，<strong>发现宕机的主Redis，就可以立刻将从Redis替代上去</strong>），这个内容相对比较高级，在之后讲。<br>3、给<strong>缓存业务添加降级限流策略（微服务部分）</strong>（如果整个集群的Redis全部都宕机了，我们可以提前做容错处理，当这些Redis都失效的时候，我们要<strong>及时的拒绝请求</strong>，防止大量请求到达数据库）<br>4、给业务添加<strong>多级缓存</strong></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>也叫作热点key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><blockquote><p>我们可以这么理解，网站中有一些内容是非常的重要的，很可能<strong>在同一时段被多个用户给同时访问，也就是高并发访问</strong>，而这个<strong>被高并发访问的key失效了，这时候访问就会到达数据库</strong>，大量请求到达数据库是很危险的，很容易造成缓存雪崩。<br>即便数据库比较坚强，也有可能用户进行访问的内容是很复杂的，可能涉及到了多表查询，也可能其转换到Redis中进行存储的时候需要进行一系列的业务。当缓存重建业务复杂的时候，如此大的请求在那一瞬间给数据库带来的冲击是非常巨大的。</p></blockquote><p>缓存击穿问题，有两种比较主流的解决方法：<br>1、互斥锁<br>2、逻辑过期</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>1、当第一个线程<strong>未命中缓存</strong>的时候，<strong>获取互斥锁，直到这个线程查询数据库完，并且重建了缓存数据并存入Redis，才能释放互斥锁；</strong><br>2、后面的线程在缓存数据存入Redis的过程中，同样会发生查询Redis未命中的情况，那么这些线程无法获得互斥锁，只能进行<strong>休眠，休眠一段时间后再重试，直到锁被解开</strong>（Redis中已经有数据了）。</p><h4 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><p>缓存击穿会出现的原因，其实无非就是TTL到期，Redis失效了，因此我们可以<strong>不给其设置TTL</strong>。但是我们该如何知道key过期了呢？我们要给这个key设置一个逻辑过期，类似：</p><table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>wxj:user:1</td><td>{name:“Jack”, age:21, expire:151467}</td></tr></tbody></table><p>这里的expire不是TTL，而是我们添加到Redis之前设定的，用<strong>代码逻辑来进行维护</strong>。</p><p>那么这个key一旦存储到了Redis里面，没有任何干预的情况下是永不过期的。</p><p>也就是说有线程在查询缓存的时候，代码逻辑里发现<strong>逻辑时间过期了，我们也直接把旧数据返还给客户端</strong>，同时数据更新交给另一个线程去做。此时有更多线程要查缓存，因为拿不到锁所以直接返回旧数据，避免了等待。</p><p>毕竟已经是高并发，一时的旧数据在很多时候也能接受，在我看来这是一种牺牲策略，客户端无须等待新数据到来，当然了，<strong>旧数据迟早要进行修改，但数据的更新操作完全可以交给其他线程，这样可以提高效率</strong>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>解决方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>互斥锁</td><td>没有额外内存消耗；保持一致性；实现简单</td><td>线程要等待，性能受影响；可能死锁</td></tr><tr><td>逻辑过期</td><td>线程无需等待，性能较好</td><td><strong>不保证一致性</strong>；有<strong>额外内存消耗</strong>；实现复杂</td></tr></tbody></table><img src="/2024/05/13/hei-ma-dian-ping/image-20240516215835297.png" alt="image-20240516215835297" style="zoom:80%;"><h3 id="解决商铺查询的缓存击穿问题"><a href="#解决商铺查询的缓存击穿问题" class="headerlink" title="解决商铺查询的缓存击穿问题"></a>解决商铺查询的缓存击穿问题</h3><h4 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>加互斥锁。获取锁与释放锁的方法定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 利用redis setnx - 向Redis中添加一个key，只用当key不存在的时候才添加并返回1</span>    <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 直接返回flag的话，拆箱可能拿到空指针</span>    <span class="token keyword">return</span> <span class="token class-name">BooleanUtil</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整合了缓存穿透和缓存击穿的代码。和前面的代码相比主要是在没有命中缓存，且没有存储空值的情况下，<strong>在查数据库前要先获取互斥锁。防止多个线程同时打到数据库。</strong>拿到锁以后查了数据库同步重建缓存返回数据，也就是<strong>这个线程的任务完成后，才能释放锁给其他线程用</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Shop</span> <span class="token function">queryWithMutex</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 查缓存，若存在直接返回，不存在就查数据库</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>    <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 存在店铺信息，反序列化json为bean对象并返回</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>  shop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果没有命中缓存。命中空值，也就是shopJson是“” 空字符串，而非null，返回错误</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shopJson <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// ====== 没缓存，没空值，需要查数据库 -- 查之前先尝试获取互斥锁，拿到锁以后才能查数据库 ======</span>    <span class="token class-name">String</span> lockKey <span class="token operator">=</span> <span class="token string">"lock:shop:"</span> <span class="token operator">+</span> id<span class="token punctuation">;</span> <span class="token comment">// 每个商户都对应一个锁</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断是否获取成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">// 失败则休眠并重试（递归）</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 单位：ms</span>            <span class="token comment">// 如果担心递归造成爆栈，可以用循环，一样的</span>            <span class="token keyword">return</span> <span class="token function">queryWithMutex</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 拿到了锁，查数据库</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 模拟重建的延时，测试用</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>shop <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 空值有效期相对更短</span>            stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token constant">CACHE_NULL_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 数据库中存在，将店铺信息序列化为json字符串，存储到redis缓存中，并添加超时剔除</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">CACHE_SHOP_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放锁</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Jmeter做并发测试，设定并发量为1000。配置好路径和接口。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516223930023.png" alt="image-20240516223930023" style="zoom: 80%;"><p>运行完以后打开查看结果树：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516224240314.png" alt="image-20240516224240314" style="zoom:80%;"><p>打开汇总报告可以看到我们的吞吐量为204</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516224424100.png" alt="image-20240516224424100" style="zoom:80%;"><p>如此大的数据量打下去，但是我们的日志显示我们的数据库只执行了一次的查询语句：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516224134785.png" alt="image-20240516224134785" style="zoom:80%;"><p>说明我们已经使用互斥锁成功避免了缓存击穿。</p><h4 id="逻辑过期-1"><a href="#逻辑过期-1" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><p>其实通常情况，因为是热点key，一般都是会出现在Redis里面的，且因为我们没有设置TTL，所以热点key是一定会一直存在的，但为了严谨起见，还是在判定缓存未命中的时候返回空。</p><p>主要流程：</p><blockquote><p>1、我们判断一下缓存是否逻辑过期了，如果没有过期，我们直接返回信息到客户端即可<br>2、如果缓存逻辑过期了，这个线程就尝试获取互斥锁，<strong>如果获取成功，说明它是第一个访问Redis的这个过期key的线程</strong>，那么这个线程要做2件事：<br>（1）返回这个旧数据给客户，虽然数据是旧的，但是这是一种暂时的牺牲<br>（2）<strong>开辟新的线程来进行缓存数据的重建，重建完毕就释放这个互斥锁</strong><br>3、除了第2种情况说的这个线程，其他线程<strong>在知道自己访问的数据过期之后，获取互斥锁都会失败，那么这时候只需要直接返还数据给客户就好了</strong>，可能是旧数据，也可能是新数据（第一个线程释放锁或者缓存数据重建成功了）</p></blockquote><img src="/2024/05/13/hei-ma-dian-ping/image-20240517164654459.png" alt="image-20240517164654459"><p>首先我们要对Shop类增加逻辑过期时间这样一个字段，一种方案是<strong>直接添加，这种会违背开闭原则</strong>，一种是可以<strong>新增加一个类</strong>，并且类中包含了逻辑过期时间expireTime，但是该怎么把这个属性添加到Shop里面呢？可以让Shop继承这个类，就可以获得这个类中的属性，但同样会修改Shop这个类的源代码，同样违背开闭原则，所以最好的方法就<strong>是用关联来代替继承：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisData</span> <span class="token punctuation">{</span>    <span class="token comment">/**     *  万能的逻辑过期数据类     */</span>    <span class="token keyword">private</span> <span class="token class-name">LocalDateTime</span> expireTime<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>商铺查询逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 线程池</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ExecutorService</span> <span class="token constant">CACHE_REBUILD_EXECUTOR</span> <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Shop</span> <span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 查缓存，若不存在直接返回空</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>    <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 命中，将json反序列化为对象，判断过期时间。</span>    <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">RedisData</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取到的redisdata存的数据本质是jsonobject类型</span>    <span class="token class-name">JSONObject</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JSONObject</span><span class="token punctuation">)</span> redisData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">LocalDateTime</span> expireTime <span class="token operator">=</span> redisData<span class="token punctuation">.</span><span class="token function">getExpireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 没过期直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>expireTime<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token comment">// 过期了重建缓存，尝试获取互斥锁</span>    <span class="token class-name">String</span> lockKey <span class="token operator">=</span> <span class="token constant">LOCK_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span> <span class="token comment">// 每个商户都对应一个锁</span>    <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断是否获取成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">// 失败说明已经有别的线程处理了，不需要再尝试重建</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 拿到了锁，开启独立线程重建缓存</span>    <span class="token constant">CACHE_REBUILD_EXECUTOR</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token comment">// 为了便于测试缓存重建机制设置20秒逻辑缓存</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">saveShop2Redis</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token number">20L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment">//释放锁</span>            <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> shop<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Jmeter测试，100个线程，1s执行完。查看idea后台，可以发现我们只执行了一次重构，说明只有一个线程操作了数据库，其他返回的在重建前是旧数据，重建完是新数据。这也证明了逻辑过期方法会造成短暂的数据不一致的情况。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240517172349168.png" alt="image-20240517172349168" style="zoom:80%;"><h2 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h2><p>基于StringRedisTemplate封装一个缓存工具类，可以满足以下的需求：<br>1、将<strong>任意</strong>Java对象序列化为json并<strong>存储在string类型的key</strong>中，并且可以设置TTL过期时间。— 存储对象<br>2、将任意Java对象序列化为json并存储在string类型的key中，并且可以<strong>设置逻辑过期时间</strong>，用于处理缓存击穿问题。— 存储逻辑过期对象<br>3、根据<strong>指定的key查询</strong>缓存，并反序列化为<strong>指定类型</strong>，利用<strong>缓存空值</strong>的方式解决缓存穿透问题。— 取对象<br>4、根据指定的key查询缓存，并反序列化指定类型，需要利用<strong>逻辑过期解决缓存击穿</strong>问题。— 取逻辑过期对象<br>1+3：存储普通对象；2+4：存储热点数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CacheClient</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">CacheClient</span><span class="token punctuation">(</span><span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 将任意Java对象序列化为json并存储在string类型的key中</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 带逻辑过期的存储方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWithLogicalExpire</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 逻辑过期类</span>        <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        redisData<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置逻辑过期时间</span>        redisData<span class="token punctuation">.</span><span class="token function">setExpireTime</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">plusSeconds</span><span class="token punctuation">(</span>unit<span class="token punctuation">.</span><span class="token function">toSeconds</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>redisData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 解决缓存穿透，这里用泛型接收任意类型id和对象类型，以便返回对应类型bean     * 参数：key的前缀，对应对象的id，以及对象类型     * 这里的id也同样是泛型，因为没办法保证用户传过来的id类型是Int还是Long或者其他     * 如果redis不存在，需要查询数据库，通用的函数根本不知道从数据库的哪张表进行查询（如果写到service可以利用mybatis-plus getById查对应类型），这里要自行传入 -- 函数式编程     * Function&lt;T, R&gt;表示有参数有返回值的类型，“dbFallback”表示数据库降级逻辑，代表查询Redis失败后要去做的后备方案     */</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">,</span> ID<span class="token punctuation">&gt;</span></span> <span class="token class-name">R</span> <span class="token function">queryWithPassThrough</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyPrefix<span class="token punctuation">,</span> <span class="token class-name">ID</span> id<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> dbFallback<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> keyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>json <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 传入的函数，参数T=id，返回值R为对象类型</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> dbFallback<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//不存在，返回错误</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//存一个null到Redis中，避免缓存穿透</span>            stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//存在，写入Redis，直接用set方法</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> r<span class="token punctuation">,</span> time<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//返回</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//逻辑过期解决缓存击穿问题</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ExecutorService</span> <span class="token constant">CACHE_REBUILD_EXECUTOR</span> <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">R</span> <span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyPrefix<span class="token punctuation">,</span> <span class="token class-name">String</span> lockKeyPrefix<span class="token punctuation">,</span> <span class="token class-name">ID</span> id<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> dbFallback<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> keyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断redis中是否存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 未命中，直接返回</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 命中，先把json反序列化成对象</span>        <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> <span class="token class-name">RedisData</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">JSONObject</span> data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JSONObject</span><span class="token punctuation">)</span> redisData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取到对象类型的r</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">LocalDateTime</span> expireTime <span class="token operator">=</span> redisData<span class="token punctuation">.</span><span class="token function">getExpireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断是否过期，未过期直接返回r</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>expireTime<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> r<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 已过期，缓存重建。尝试获取互斥锁。互斥锁key由参数传递</span>        <span class="token class-name">String</span> lockKey <span class="token operator">=</span> lockKeyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//判断是否获取锁成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isLock<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//成功获取锁，开启独立线程来实现缓存重建，用线程池来做</span>            <span class="token constant">CACHE_REBUILD_EXECUTOR</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment">//查询数据库，这里依旧使用函数式编程</span>                    <span class="token class-name">R</span> r1 <span class="token operator">=</span> dbFallback<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//写入Redis</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setWithLogicalExpire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> r1<span class="token punctuation">,</span> time<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment">//释放锁</span>                    <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//没有拿到锁，直接返回信息</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// opsForValue里面没有真正的setNx，而是setIfAbsent，表示如果不存在就执行set</span>        <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">BooleanUtil</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工具类调用"><a href="#工具类调用" class="headerlink" title="工具类调用"></a>工具类调用</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 缓存穿透</span>    <span class="token comment">// Shop shop = queryWithPassTrough(id);</span>    <span class="token comment">// 缓存击穿 -- 互斥锁</span>    <span class="token comment">// Shop shop = queryWithMutex(id);</span>    <span class="token comment">// 缓存击穿 -- 逻辑过期</span>    <span class="token comment">// Shop shop = queryWithLogicalExpire(id);</span>    <span class="token comment">// 封装的工具类，解决缓存穿透</span>    <span class="token comment">// Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span>    <span class="token comment">// 封装的工具类，解决缓存击穿</span>    <span class="token class-name">Shop</span> shop <span class="token operator">=</span> cacheClient<span class="token punctuation">.</span><span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOP_KEY</span><span class="token punctuation">,</span> <span class="token constant">LOCK_SHOP_KEY</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">::</span><span class="token function">getById</span><span class="token punctuation">,</span> <span class="token number">10L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shop <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"商铺不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="==优惠券秒杀=="></a>==优惠券秒杀==</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><p>每个店铺都可以发布优惠券（代金券），当用户抢购的时候，就会生成订单并且保存到tb_voucher_order这张表中：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tb_voucher_order<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>user_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'下单的用户id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>voucher_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'购买的代金券id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>pay_type<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span> <span class="token keyword">COMMENT</span> <span class="token string">'支付方式 1：余额支付；2：支付宝；3：微信'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>status<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span> <span class="token keyword">COMMENT</span> <span class="token string">'订单状态，1：未支付；2：已支付；3：已核销；4：已取消；5：退款中；6：已退款'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'下单时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>pay_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'支付时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>use_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'核销时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>refund_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'退款时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，我们的主键ID没有使用自增长，这是因为如果使用数据库自增ID就会存在一些问题：<br>1、ID的规律性太明显，容易让别人猜测到信息（比如商城在一天时间内，卖出了多少单）<br>2、受单表数据量的限制（<strong>订单可能数据非常大，可能会分多表进行存储</strong>，但表的自增长相互之间不受影响，所以不同表之间可能会出现ID相同的情况，也就是说这种时候会违背ID的唯一性，这显然是不可以的）<br><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：<strong>1、唯一性  2、高可用  3、高性能  4、递增性  5、安全性</strong></p><p>除了第5点，Redis及其数据结构已经可以直接满足前4点的要求了，为了增加ID的安全性，不要直接使用Redis自增的数值，而是拼接一些其他信息，最终我们将ID组成定义为64位的二进制数，分别是<strong>1位符号位，31位时间戳，32位序列号。</strong></p><h4 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisIdWorker</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token comment">/**     * 开始时间戳由main函数运行得到     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token constant">BEGIN_TIMESTAMP</span> <span class="token operator">=</span> <span class="token number">1716076800L</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 序列号的位数：32bit，秒内的计数器，支持每秒产生2^32个不同ID     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">nextId</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyPrefix<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//获得当前时间</span>        <span class="token class-name">LocalDateTime</span> now <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> nowSecond <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">toEpochSecond</span><span class="token punctuation">(</span><span class="token class-name">ZoneOffset</span><span class="token punctuation">.</span><span class="token constant">UTC</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//生成时间戳：31bit，以秒为单位，可以使用69年</span>        <span class="token keyword">long</span> timestamp <span class="token operator">=</span> nowSecond <span class="token operator">-</span> <span class="token constant">BEGIN_TIMESTAMP</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 接下来生成序列号         * 我们的key的设置除了加上icr表示是自增长的，还需要在最后拼接一个日期字符串         * 这是因为我们的序列号上限是2^32，并不大，如果每天的key都是一样的，这是很有可能超过上限的         * 在后面拼接一个日期字符串，可以保证每一天的key都是不一样的，而且一天内也基本不可能到达2^32的上限         * 这样做还有一个好处，我们以后可以根据每天或者每月来查看value值，起到统计效果         */</span>        <span class="token comment">//获取当前日期，精确到天</span>        <span class="token class-name">String</span> date <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"yyyy:MM:dd"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> count <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token string">"icr:"</span> <span class="token operator">+</span> keyPrefix <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//拼接并返回，这里灵活用位运算</span>        <span class="token keyword">return</span> timestamp <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">|</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//定义时间为2024年5月19日00:00:00</span>        <span class="token class-name">LocalDateTime</span> time <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将时间变成变成秒数的形式</span>        <span class="token keyword">long</span> second <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">toEpochSecond</span><span class="token punctuation">(</span><span class="token class-name">ZoneOffset</span><span class="token punctuation">.</span><span class="token constant">UTC</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//在这里运行出来的时间作为BEGIN_TIMESETAMP</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全局唯一ID生成策略"><a href="#全局唯一ID生成策略" class="headerlink" title="全局唯一ID生成策略"></a>全局唯一ID生成策略</h3><ul><li>UUID：优点使用简单，不依赖其他组件，不影响数据库扩展；缺点数据库索引效率低，太过于无意义.用户不友好，空间占用大，集群环境容易重复</li><li>Redis自增：优点利用redis操作原子性的特征,可以保证在并发的时候不会重复，拓展性强,可以方便的结合业务进行处理；缺点增加一侧网络开销 需要对reids服务实现高可用</li><li>snowflake算法：优点性能较优,速度快 无需第三方依赖,实现也简单 可以根据实际情况调整和拓展算法,方便灵活；缺点依赖时间机器,如果发生回拨会导致生成id重复</li><li>数据库自增：优点无需编码，性能也过得去，索引友好；缺点大表不能做水平分表,否则插入删除易出现问题，依赖前期规划,拓展麻烦 依赖mysql内部维护自增锁,高并发下插入数据影响性能</li></ul><h3 id="秒杀数据表"><a href="#秒杀数据表" class="headerlink" title="秒杀数据表"></a>秒杀数据表</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券，平价券可以任意购买，而特价券需要秒杀抢购，表关系如下</p><p>tb_voucher（平价与秒杀券都有）：优惠券基本信息（金额，规则等）:上面的type可以表示标识出是平价券还是特价券，如果是特价券我们也需要一些特定的信息，因此我们会专门拓展出一张表。<br>tb_seckill_voucher（对应秒杀券）：优惠券库存、开始抢购时间、结束抢购时间（特价券需要此表）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tb_voucher<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>shop_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'商铺id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>title<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'代金券标题'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>sub_title<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'副标题'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>rules<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'使用规则'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>pay_value<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'支付金额，单位是分。例如200代表2元'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>actual_value<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'抵扣金额，单位是分。例如200代表2元'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>type<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span> <span class="token keyword">COMMENT</span> <span class="token string">'0,普通券；1,秒杀券'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>status<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span> <span class="token keyword">COMMENT</span> <span class="token string">'1,上架; 2,下架; 3,过期'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tb_seckill_voucher<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>voucher_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'关联的优惠券的id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>stock<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'库存'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>begin_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'生效时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>end_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'失效时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>voucher_id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_general_ci <span class="token keyword">COMMENT</span> <span class="token operator">=</span> <span class="token string">'秒杀优惠券表，与优惠券是一对一关系'</span> ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h3><p>在VoucherController中提供一个接口，调用就可以实现添加普通券。mapper中普通券除了定义对应tb_voucher的内容，还添加了库存、生效时间和失效时间字段。这样添加普通券和添加秒杀券都可以通过这个类传递对象，传递过来以后如果是普通券，这几个字段默认exsit=false（也就是没有该字段到数据库表的映射），直接利用VoucherServiceImpl的save方法保存即可。如果是秒杀券，就首先save到tb_voucher，再对库存、生效时间、失效时间等手动保存，利用seckillVoucherService添加到tb_seckill_voucher表。也就实现了通过前端一次传递，就在后端保存两张表的信息，简化代码逻辑。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519145646945.png" alt="image-20240519145646945" style="zoom:80%;"><h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><p><strong>接口地址</strong>:<code>/voucher-order/seckill/{id}</code></p><p><strong>请求方式</strong>:<code>POST</code></p><p><strong>请求参数</strong>:</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>请求类型</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>id</td><td>优惠券id</td><td>path</td><td>true</td><td>integer(int64)</td><td></td></tr></tbody></table><p><strong>返回值</strong>：订单id</p><p>基础功能实现（不考虑并发）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span>  <span class="token comment">// 涉及多表操作，添加事务以便回滚</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">seckillVoucher</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 查询优惠券</span>    <span class="token class-name">SeckillVoucher</span> voucher <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀券不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 判断时间区间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getBeginTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀尚未开始！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀已经结束！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 判断库存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 扣减库存</span>    <span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 创建订单</span>    <span class="token class-name">VoucherOrder</span> voucherOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VoucherOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> orderId <span class="token operator">=</span> redisIdWorker<span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token string">"order"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    voucherOrder<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 从threadlocal中取用户id</span>    <span class="token class-name">Long</span> userId <span class="token operator">=</span> <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>userId <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"用户未登录！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    voucherOrder<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>    voucherOrder<span class="token punctuation">.</span><span class="token function">setVoucherId</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保存订单</span>    <span class="token function">save</span><span class="token punctuation">(</span>voucherOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回订单id</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h2><p>以上代码存在线程安全问题。高并发场景下会有库存超卖 – 在库存为1的时候，多个线程同时查询库存，得到库存1，后面的线程读到的都是脏数据。</p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：</p><p><strong>悲观锁</strong>：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保<strong>线程串行执行</strong>。（Synchronized、Lock等）</p><p><strong>乐观锁</strong>：认为线程安全问题不一定会发生，因此<strong>不加锁</strong>，只是<strong>在更新数据时去判断有没有其它线程对数据做了修改</strong>。（如果没有修改，那就是安全的；<strong>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常</strong>）</p><p>显然乐观锁的性能会好很多，但是实现起来会更复杂，我们要处理好关键的一点，那就是更新数据的时候，该<strong>如何去判断有没有其它线程对数据做了修改</strong>。</p><p>乐观锁的实现方式有2种方法（其实思想相同）：<br><strong>1、版本号法：</strong><br>给数据增加一个字段version，初始值为1，每次我们<strong>要修改库存量之前都需要先查询库存量与版本号</strong>，然后线程执行SQL语句，执行SQL语句必须要确定数据库中的这条数据的版本号就是查询出来的版本号，<strong>如果不相同说明有其他线程修改了数据</strong>，导致当前数据的版本号与之前查询的不一样：<br><strong>2、CAS法</strong><br>上面的方法加一个版本号其实是一种标识，但是我们不一定要借助version，实际上我们可以<strong>直接依靠库存量来做标识</strong>，在对数据库进行修改的时候，我们要首先判断当前数据的库存量与之前线程查询出来的库存量是否相同，不相同则说明发生线程安全问题，不能修改</p><h3 id="乐观锁解决超卖"><a href="#乐观锁解决超卖" class="headerlink" title="乐观锁解决超卖"></a>乐观锁解决超卖</h3><p>我们选用CAS法来解决超卖，根据上述思想，我们只需要在SQL语句那增加一个判断库存量的条件：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 扣减库存</span><span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"stock"</span><span class="token punctuation">,</span> voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用Jmeter测试发现200个线程抢100张票，只卖出了20+张票。</p><p><strong>问题</strong>：假设stock=100，当线程查询出来的stock与数据库的stock不一致的时候，并不能说明票卖完了，只能说明其他线程抢先了票。理论上库存量大概率不为0，该线程还是应该要能够实现买票操作，但全都因为查询的stock与数据库不一致导致有大量线程买票失败。</p><p><strong>修改</strong>：只需要查询数据库中的stock是否大于0即可。— <code>.gt("stock", 0)</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token string">"stock"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// /where id = ? and stock &gt; 0</span>    <span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新测试发现能够正好下单100份秒杀券。</p><blockquote><p>但是这不代表乐观锁就是完美的，很显然代码逻辑中要操作数据库，大量的线程就会给数据库带来压力，仅仅使用乐观锁在更高并发的场景下还是不太够的。</p></blockquote><h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单。</p><p>解决：只需要判断当前尝试抢优惠券的线程，其用户id在订单表中是否已经存在了，如果存在则不允许下单。</p><p>这里仍然会有多线程问题，由于这段逻辑不涉及数据库更新而是要插入数据，所以<strong>加悲观锁</strong>。这里锁放在函数内部，因为如果在方法上加锁，那么不管是哪个用户来下单都变成串行了，所以我们需要在内部调用synchronized，并指定锁定对象为userId。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoucherOrderServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">VoucherOrderMapper</span><span class="token punctuation">,</span> <span class="token class-name">VoucherOrder</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">IVoucherOrderService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">ISeckillVoucherService</span> seckillVoucherService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">RedisIdWorker</span> redisIdWorker<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">seckillVoucher</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 查询优惠券</span>        <span class="token class-name">SeckillVoucher</span> voucher <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀券不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 判断时间区间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getBeginTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀尚未开始！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀已经结束！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 判断库存</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Transactional</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">createVoucherOrder</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从threadlocal中取用户id</span>        <span class="token class-name">Long</span> userId <span class="token operator">=</span> <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * userId值一样的，我们用同一把锁，即为同一个用户的多线程访问加锁。         * 但是每个请求一来，我们的id对象都是全新的（toString得到的是新的string对象）         * 所以要加上intern()方法，从字符串常量池中返回字符串的规范表示，保证多个请求访问一个用户字符串时得到的是同样的地址         */</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>userId<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 查询用户是否已经下单了对应优惠券</span>            <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"user_id"</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"用户已经购买！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 没买过，扣减库存</span>            <span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token string">"stock"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 创建订单</span>            <span class="token keyword">long</span> orderId <span class="token operator">=</span> redisIdWorker<span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token string">"order"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">VoucherOrder</span> voucherOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VoucherOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            voucherOrder<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>            voucherOrder<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>            voucherOrder<span class="token punctuation">.</span><span class="token function">setVoucherId</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 保存订单</span>            <span class="token function">save</span><span class="token punctuation">(</span>voucherOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回订单id</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意一个细节，<strong>上面代码还是会发生并发安全问题：</strong></p><blockquote><p>我们这边的整个函数已经是被Spring托管了，所以<strong>事务的提交会在函数执行完毕之后</strong>，也就是说我们会<strong>先释放锁，再提交事务</strong>，当我们事务还没有提交完成，<strong>修改数据还没写入数据库，却又有其他线程进来了</strong>，再次发生线程并发问题。</p></blockquote><h3 id="事务与锁顺序"><a href="#事务与锁顺序" class="headerlink" title="事务与锁顺序"></a>事务与锁顺序</h3><p>所以，锁的范围太小了，我们应该要把整个函数都锁起来。这样就是<strong>先获取锁，提交事务，再释放锁。</strong></p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519174917100.png" alt="image-20240519174917100"><h3 id="事务生效问题"><a href="#事务生效问题" class="headerlink" title="事务生效问题"></a>事务生效问题</h3><p>直接调用createVoucherOrder方法是不行的，因为它相当于调用了this.createVoucherOrder，然而当前类并不是代理对象，这会导致Sping代理失效。</p><blockquote><p>Spring的事务是通过AOP来实现的，只有通过代理对象调用<code>@Transactional</code>注解的对象方法时，事务才会生效，也就是直接调用<code>createVoucherOrder()</code>方法事务才会生效，调用<code>seckillVoucher()</code>方法后间接调用<code>createVoucherOrder()</code>方法事务是不会生效的。因为这次调用并不是通过代理对象来实现的。</p></blockquote><img src="/2024/05/13/hei-ma-dian-ping/image-20240519175418682.png" alt="image-20240519175418682"><p>所以我们要先获得当前对象的代理对象，然后再去调用这个函数（这个函数也要创建在service接口中，表明它属于代理对象能调用的方法）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>userId<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">IVoucherOrderService</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IVoucherOrderService</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要引入依赖：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">&lt;dependency<span class="token punctuation">&gt;</span>        &lt;groupId<span class="token punctuation">&gt;</span>org.aspectj&lt;/groupId<span class="token punctuation">&gt;</span>        &lt;artifactId<span class="token punctuation">&gt;</span>aspectjweaver&lt;/artifactId<span class="token punctuation">&gt;</span>&lt;/dependency<span class="token punctuation">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>并且在启动类中需要暴露代理对象：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519180101176.png" alt="image-20240519180101176" style="zoom:80%;"><p>使用Jmeter测试，同一用户200个线程，最终只插入一条数据。问题解决。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519222713031.png" alt="image-20240519222713031" style="zoom:80%;"><h2 id="集群下的线程并发安全问题"><a href="#集群下的线程并发安全问题" class="headerlink" title="集群下的线程并发安全问题"></a>集群下的线程并发安全问题</h2><p>现在已经通过加锁解决一人一单问题安全，但是这只能解决单机情况的，集群模式依旧不行。</p><p>利用idea模拟集群模式，复制一个新的服务，设置端口8082（program arguments）</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519225432012.png" alt="image-20240519225432012" style="zoom:80%;"><p>重启形成2个机子的集群：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519231204101.png" alt="image-20240519231204101"><p>修改nginx的conf目录下的nginx.conf文件，配置反向代理、负载均衡：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519230039737.png" alt="image-20240519230039737" style="zoom:80%;"><p>最后重新加载一下Nginx：<code>nginx.exe -s reload</code></p><p>最后访问网址，并连续刷新2次：</p><blockquote><p><a href="http://localhost:8080/api/voucher/list/1">http://localhost:8080/api/voucher/list/1</a></p></blockquote><p>查看后台可以发现两个启动服务都可以接受到信息，因为api（8080）包括了8081与8082，访问是以<strong>轮询</strong>的方式进行的。这样就实现了负载均衡。</p><p>测试：需要在锁那里打个断点，并且在postman里面分别抢券（都用同一个用户）来进行优惠券抢购，可以发现只用1个用户信息，数据库中却少了2张券，说明又一次发生了并发问题。</p><blockquote><p>我们部署另外一台Tomcat，这是<strong>锁的锁监视器</strong>，<strong>其监视的内容和之前锁中的监视器内容是不一样的</strong>，那么新Tomcat的线程获取锁就会成功（获取的userId.toString()是不一样的，不理解的可以去看toString方法的源码），并成功的操作数据库，因此才会造成线程并行问题。<br>如下图，线程1、3发生了线程安全问题。因此我们只能保证单个JVM下的线程安全，却无法保证集群中多个JVM的线程安全，我们需要在集群中加锁，也就是<strong>分布式锁</strong>，将在后续讲解。</p></blockquote><img src="/2024/05/13/hei-ma-dian-ping/image-20240519231759949.png" alt="image-20240519231759949" style="zoom:80%;"><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="==分布式锁=="></a>==分布式锁==</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><strong>JVM内</strong>的线程之间可以用<strong>锁</strong>实现互斥，synchronized锁只能保证单个JVM内部的多个线程之间互斥，不能保证多JVM下多进程的互斥。因为每个JVM都只有一个锁监视器，但是多个JVM就会有多个锁监视器，导致多个线程获取到锁，从而发生线程安全问题。<br>因此，要实现互斥，可以<strong>让多个JVM都共用一个锁监视器</strong>，这样让JVM与JVM之间、每个JVM的线程之间都共用这个锁，就不会发生线程安全问题了。</p><p>由此引出<strong>分布式锁</strong>的定义：<strong>满足分布式系统或集群模式下多进程可见并且互斥的锁。</strong><br>需要满足的特点：多进程可见、互斥、高可用、高性能、安全性</p><h3 id="不同实现方式对比"><a href="#不同实现方式对比" class="headerlink" title="不同实现方式对比"></a>不同实现方式对比</h3><table><thead><tr><th></th><th>MySQL</th><th>Redis</th><th>Zookeeper</th></tr></thead><tbody><tr><td>互斥</td><td>本身的互斥锁机制</td><td>利用互斥命令setnx</td><td>利用节点的唯一性和有序性实现互斥</td></tr><tr><td>高可用</td><td>好</td><td>好</td><td>好</td></tr><tr><td>高性能</td><td>一般</td><td>好</td><td>一般</td></tr><tr><td>安全性</td><td>断开连接，自动释放锁</td><td>利用锁超时时间，到时释放</td><td>临时节点，断开连接自动释放</td></tr></tbody></table><h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul></li></ul><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可。（解决缓存击穿的互斥锁方案就用了）</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520153020729.png" alt="image-20240520153020729"><h3 id="实现分布式锁版本1"><a href="#实现分布式锁版本1" class="headerlink" title="实现分布式锁版本1"></a>实现分布式锁版本1</h3><p>直接在utils包下创建ILock接口与SimpleRedisLock 类，这个内容和之前的差不多</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleRedisLock</span> <span class="token keyword">implements</span> <span class="token class-name">ILock</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_PREFIX</span> <span class="token operator">=</span> <span class="token string">"lock:"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">// 不同业务有不同的锁，业务name即为锁的name</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SimpleRedisLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//获取线程表示</span>        <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取锁</span>        <span class="token class-name">Boolean</span> success <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                <span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> threadId <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">,</span> timeoutSec<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//防止拆箱操作，不能直接返回success</span>        <span class="token keyword">return</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着修改我们的下单业务的impl，改变之前的加锁逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建锁对象，key需要加上用户id，因为不同的用户无所谓，只有同一个用户才要锁起来，因此要指定好用户id</span><span class="token class-name">SimpleRedisLock</span> simpleRedisLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleRedisLock</span><span class="token punctuation">(</span><span class="token string">"order:"</span> <span class="token operator">+</span> userId<span class="token punctuation">,</span> stringRedisTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isLock <span class="token operator">=</span> simpleRedisLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">1200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取锁失败，由于是对一个人限制锁，所以获取失败直接返回</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"不允许重复下单！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token class-name">IVoucherOrderService</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IVoucherOrderService</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>    simpleRedisLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>集群下测试：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520155946888.png" alt="image-20240520155946888" style="zoom:80%;"><img src="/2024/05/13/hei-ma-dian-ping/image-20240520160019728.png" alt="image-20240520160019728" style="zoom:80%;"><h2 id="Redis分布式锁误删问题"><a href="#Redis分布式锁误删问题" class="headerlink" title="Redis分布式锁误删问题"></a>Redis分布式锁误删问题</h2><p><strong>情况：</strong>持有锁的线程<strong>在锁的内部出现了阻塞，导致他的锁自动释放</strong>，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，<strong>线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑</strong>，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p><strong>解决方案：</strong>解决方案就是在每个线程释放锁的时候，<strong>去判断一下当前这把锁是否属于自己，如果不属于自己，则不进行锁的删除</strong>，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前<strong>这把锁不是属于自己，于是不进行删除锁逻辑，</strong>当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><img src="/2024/05/13/hei-ma-dian-ping/1653385920025.png" alt="1653385920025" style="zoom:80%;"><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>根据上述的分析，我们需要修改一下分布式锁，使得满足：<br>1、在获取锁时存入线程标识</p><blockquote><p>在这里增加了UUID来作为线程的标识，不再使用线程自己的ID了，这是因为虽然每个JVM的线程都是递增的，每个JVM内部之间的都会维护线程的唯一ID，但是不同的JVM之间还是会产生冲突，因此让JVM自己去维护线程的ID，会导致不同JVM之间的ID冲突。<br>事实上，也可以用UUID来表示不同的JVM，用线程ID来区分JVM内部的线程，两者拼接在一块。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 增加线程标识的前缀</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、在释放锁时限获取锁中的线程标识，判断是否与当前线程标识一致（一致才可释放）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//获取线程表示</span>    <span class="token class-name">String</span> threadId <span class="token operator">=</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取锁</span>    <span class="token class-name">Boolean</span> success <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>        <span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> threadId <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">,</span> timeoutSec<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//防止拆箱操作，不能直接返回success</span>    <span class="token keyword">return</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取线程表示</span>    <span class="token class-name">String</span> threadId <span class="token operator">=</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取线程中的id，判断是否一致</span>    <span class="token class-name">String</span> redisId <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>redisId<span class="token punctuation">)</span><span class="token punctuation">)</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h2><p>上述的方式已经可以解决业务阻塞导致的误删操作，但是还会有一些问题：</p><blockquote><p>如果我们阻塞的不是业务，而是业务执行完了，并且<strong>判断锁标识成功，即将释放锁的时候发生的阻塞</strong>（这种阻塞不是业务阻塞，而可能是JVM内部的垃圾回收机制异常导致阻塞），这时候还会发生新的问题。<br>如果被阻塞的时间足够长，导致锁的TTL到期了，一旦释放，其他线程又开始乘虚而入，成功获取锁，执行业务。<br>这时候，被阻塞的线程恢复正常了，但是因为已经进行锁标识的逻辑判断了，这时候被阻塞的线程就可以完成这个释放锁的操作，再次造成误删问题。</p></blockquote><p>分析一下问题发生的原因，之所以会出现这种情况，主要原因是<strong>锁标识的逻辑判断与锁的释放操作，是两个不同的操作，不满足原子性，所以当在两个操作之间发生了阻塞，那么线程并发问题依旧会出现。</strong><br>所以，我们必须要保证<strong>判断锁标识</strong>的动作与<strong>释放锁</strong>的动作必须得保证<strong>原子性</strong>。</p><h2 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h2><p>想到原子性，我们很容易就想到MySQL中的事务，但是Redis中的事务却不太一样<strong>，Redis事务虽然能保障原子性，但是无法保证事务的一致性</strong>。Redis事务的操作是一系列的批处理，是在最终一次性执行的，必须要有乐观锁来做判断，会麻烦很多。</p><p>Lua语言能够保证原子性，是因为它在执行原子操作时会将其他线程或进程阻塞，直到该操作完成。</p><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AF%AD%E6%B3%95%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，语法如下：</a></p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'命令名称'</span><span class="token punctuation">,</span> <span class="token string">'key'</span><span class="token punctuation">,</span> <span class="token string">'其它参数'</span><span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我们要执行set name jack，则脚本是这样：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">#</span> 执行 set name jackredis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'jack'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">#</span> 先执行 set name jackredis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'Rose'</span><span class="token punctuation">)</span><span class="token operator">#</span> 再执行 get name<span class="token keyword">local</span> name <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token operator">#</span> 返回<span class="token keyword">return</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写好脚本以后，需要用Redis命令来调用脚本</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">EVAL script numkeys key… arg…<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，要执行redis.call(‘set’, ‘name’, ‘jack’)这个脚本。0表示key类型的参数的个数</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">EVAL “<span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>‘set’<span class="token punctuation">,</span> ‘name’<span class="token punctuation">,</span> ‘jack’<span class="token punctuation">)</span>” <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数 – 1代表key类型的参数有一个，也就是紧接着的name，会放入KEYS[1]，而Rose则放入ARGV[1]中</p><img src="/2024/05/13/hei-ma-dian-ping/1653392438917.png" alt="1653392438917"><h3 id="Java调用Lua脚本改造分布式锁"><a href="#Java调用Lua脚本改造分布式锁" class="headerlink" title="Java调用Lua脚本改造分布式锁"></a>Java调用Lua脚本改造分布式锁</h3><p>在resources下新建Lua文件：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- 锁中的线程标识与当前线程一致</span><span class="token keyword">if</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">then</span>    <span class="token comment">-- 释放锁</span>    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'del'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment">-- 不一致则什么也不做</span><span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在impl中增加静态变量，防止每次调用unLock函数都要重新调用Lua脚本。修改unLock函数，调用Lua脚本。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520171239197.png" alt="image-20240520171239197"><h2 id="分布式锁-Redisson"><a href="#分布式锁-Redisson" class="headerlink" title="==分布式锁-Redisson=="></a>==分布式锁-Redisson==</h2><p>基于setnx的分布式锁存在下面的问题：<br><strong>1、不可重入</strong>：同一个线程无法多次获取同一把锁（当同一个线程内，方法A获取了锁，然后调用方法B，方法B中没办法获取同一把锁）<br><strong>2、不可重试</strong>：获取锁只尝试一次就返回false，没有重试机制<br><strong>3、超时释放</strong>：虽然可以避免死锁，但如果业务耗时很长，也会导致锁释放，会再次发生线程安全问题<br><strong>4、主从一致性问题</strong>：若Redis提供了主从集群，主从同步存在延迟。当主节点宕机时，从节点充当主节点。如果从节点没有同步主节点中的锁数据，即没有锁标识，则会让其他节点拿到锁</p><p>Redisson是一个在Redis基础上实现的<strong>分布式工具集合</strong>，提供了很多分布式服务，包含了各种分布式锁的实现。</p><h3 id="Redisson快速入门"><a href="#Redisson快速入门" class="headerlink" title="Redisson快速入门"></a>Redisson快速入门</h3><p>引入依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.23.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置客户端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedissonConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RedissonClient</span> <span class="token function">redissonClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//配置</span>        <span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//添加Redis地址，这里添加的是单点的地址，也可以使用config.userClusterServer()来添加集群的地址</span>        config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"redis://ip:6379"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建客户端</span>        <span class="token keyword">return</span> <span class="token class-name">Redisson</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Redisson的分布式锁：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520185500237.png" alt="image-20240520185500237" style="zoom:80%;"><p>订单业务中的修改：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建锁对象，key需要加上用户id，因为不同的用户无所谓，只有同一个用户才要锁起来，因此要指定好用户id</span><span class="token comment">//        SimpleRedisLock simpleRedisLock = new SimpleRedisLock("order:" + userId, stringRedisTemplate);</span><span class="token comment">//        boolean isLock = simpleRedisLock.tryLock(1200);</span><span class="token comment">// 获取锁（可重入），指定锁的名称</span><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock:order:"</span> <span class="token operator">+</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>…………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Redisson的可重入锁原理"><a href="#Redisson的可重入锁原理" class="headerlink" title="Redisson的可重入锁原理"></a>Redisson的可重入锁原理</h2><img src="/2024/05/13/hei-ma-dian-ping/image-20240520192526025.png" alt="image-20240520192526025" style="zoom:80%;"><p>我们需要找到一种数据结构，能够<strong>在一个key里面获取多个东西</strong>——Hash：</p><p>Hash结构（hset）的KEY对应的VALUE包含了field与value，因此我们可以<strong>让KEY对应锁名称，让field对应线程标识，让value位置记录锁的重入次数</strong>（初始为0）。</p><p>因此，发生上述情况的时候，虽然线程的标识是相同的，但我们可以<strong>将重入次数+1，代表第二次获取锁，这时候整体的VALUE是不相同的。</strong><br>需要注意的是，method2执行完毕以后不能直接释放这个key对应的锁，因为这样的话会导致method1没有执行完毕就被删掉了，解决的方法是让重入次数-1，只有<strong>所有业务都执行完了（重入次数=0）的时候才能真正释放。</strong><br>这样我们的流程就会发生变化（哈希结构没有直接的EX来设置有效期）：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520193101664.png" alt="image-20240520193101664"><p>用Lua脚本来保证代码的原子性，而Lua代码获取锁与释放锁的逻辑已经是保存到RedissonLock类中了，我们只需要直接调用tyrLock与unlock方法就行。</p><blockquote><p>总结：Redisson的可重入原理的核心就是因为我们使用了hash结构，记录了获取锁的线程以及可重用的次数</p></blockquote><h2 id="Redisson的锁重试和WatchDog机制"><a href="#Redisson的锁重试和WatchDog机制" class="headerlink" title="Redisson的锁重试和WatchDog机制"></a>Redisson的锁重试和WatchDog机制</h2><p>redisson在尝试获取锁的时候，如果传了时间参数，就不会在获取锁失败时立即返回失败，而是会进行重试。</p><ul><li><p><strong>waitTime：</strong>是<strong>最大等待时间</strong>，如果使用 <strong>tryLock()</strong> 的时候，<strong>有传参数</strong>表明是<strong>可重试的锁</strong>；反之，不是！</p></li><li><p><strong>leaseTime</strong>：超时释放时间，默认是-1，建议不要设定，Redisson<strong>看门狗机制</strong>可以进行<strong>锁续约</strong></p></li></ul><h3 id="锁重试"><a href="#锁重试" class="headerlink" title="锁重试"></a>锁重试</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>tryLock()</strong> ：里面实现了<strong>重试机制</strong>。通过<strong>消息订阅</strong>和<strong>信号量机制</strong>，避免了 <strong>while(true)</strong> 让其一直无效尝试，避免了<strong>CPU空转问题</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token comment">// 转成毫秒，后面都是以毫秒为单位</span>    <span class="token keyword">long</span> time <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前时间</span>    <span class="token keyword">long</span> current <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 线程ID-线程标识</span>    <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 尝试获取锁，返回锁的剩余过期时间（对应获取锁的lua脚本的返回值） tryAcquire() ==========!!!</span>    <span class="token class-name">Long</span> ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果上面尝试获取锁返回的是null，表示成功；如果返回的是时间则表示失败。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 剩余等待时间 = 最大等待时间 -（用现在时间 - 获取锁前的时间）</span>    time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> current<span class="token punctuation">;</span>    <span class="token comment">// 剩余等待时间 &lt; 0 失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 再次获取当前时间</span>    current <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ==================重试逻辑，但不是简单的直接重试！==================</span>    <span class="token comment">// subscribe是订阅的意思，订阅锁的释放事件</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">&gt;</span></span> subscribeFuture <span class="token operator">=</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待一段时间，看是否能获取到锁的释放事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 如果等待超时，则取消订阅并获取锁失败，返回false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            subscribeFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token comment">// 取消订阅</span>                    <span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscribeFuture<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 获取锁失败</span>        <span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// =======循环重试=======</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// 减去已经消耗的时间</span>        time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> current<span class="token punctuation">;</span>        <span class="token comment">// 如果还有剩余等待时间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token comment">// 获取当前时间戳</span>                <span class="token keyword">long</span> currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 再次尝试获取锁，返回锁的剩余过期时间</span>                ttl <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果锁成功获取</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 减去已经消耗的时间</span>                time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> currentTime<span class="token punctuation">;</span>                <span class="token comment">// 如果等待时间已经用完，则获取锁失败，返回false</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 根据剩余时间尝试获取锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">&gt;=</span> <span class="token number">0L</span> <span class="token operator">&amp;&amp;</span> ttl <span class="token operator">&lt;</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 这里采用====信号量机制=======，等待释放锁的线程释放锁</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">)</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                        <span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>ttl<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">// 如果这个ttl时间比当前线程尝试获取锁的时间还长</span>                    <span class="token comment">// 那么就直接等待尝试获取锁的时间</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">)</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                        <span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 减去已经消耗的时间</span>                time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> currentTime<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果还有剩余等待时间，则继续尝试获取锁</span>            <span class="token comment">// 如果等待时间已经用完，则获取锁失败，返回false</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 如果等待时间已经用完，则获取锁失败，返回false</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment">// 释放订阅</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscribeFuture<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在 tryLock() 中调 tryAcquire() 执行获取锁的操作</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Long</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 尝试以异步方式获取锁的剩余过期时间。 * @param waitTime 等待时间 * @param leaseTime 锁的租期时间 * @param unit 时间单位 * @param threadId 当前线程ID * @return 表示剩余过期时间的Future对象 */</span><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 锁自动释放时间为默认的-1，所以会走else。如果设定了释放时间，走if</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leaseTime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_LONG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// leaseTime我们没有传，这里设定默认值（看门狗）30s</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> ttlRemainingFuture <span class="token operator">=</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span>            commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCfg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_LONG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在获取剩余过期时间的异步结果完成后，执行回调、回调函数 ttlRemaining：剩余有效期，e：异常</span>    ttlRemainingFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ttlRemaining<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 剩余有效期为null，表示获取锁成功！</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlRemaining <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 锁续约</span>            <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ttlRemainingFuture<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 把 leaseTime锁释放时间 记录成一个本地的成员变量</span>    internalLockLeaseTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取锁成功返回nil（空），失败返回时间，锁的剩余有效期（pttl是以毫秒为单位）</span>    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> command<span class="token punctuation">,</span>            <span class="token string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return nil; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return nil; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"return redis.call('pttl', KEYS[1]);"</span><span class="token punctuation">,</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="超时续约"><a href="#超时续约" class="headerlink" title="超时续约"></a>超时续约</h3><p><strong>那么此时还有一个问题，如果当前持有锁的线程业务阻塞了，TTL到期了别其它线程获取到了锁，那么此时就会有安全问题了</strong></p><p>而Redisson是通过看门狗来解决这个问题的</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 更新锁的有效期 * @param threadId 当前线程ID */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 这个entry里主要存储了两个东西，一个是更新锁释放时间的定时任务，还有一个就是线程ID</span>    <span class="token class-name">ExpirationEntry</span> entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExpirationEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将entry添加到ConcurrentHashMap中，如果是第一次添加则会返回null</span>    <span class="token comment">// 保证每次重入拿到的是同一个extry</span>    <span class="token class-name">ExpirationEntry</span> oldEntry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEntry <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 将当前线程ID添加到旧的entry中</span>        oldEntry<span class="token punctuation">.</span><span class="token function">addThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token comment">// 如果旧的条目为null，说明是第一次添加该条目</span>        <span class="token comment">// 将当前线程ID添加到map中</span>        entry<span class="token punctuation">.</span><span class="token function">addThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 第一次来，就需要创建的更新释放时间的定时任务</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 续约锁的过期时间。 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取锁的过期续约条目</span>    <span class="token class-name">ExpirationEntry</span> ee <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果续约条目不为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ee <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建一个定时任务，用于===定时执行续约操作===</span>        <span class="token class-name">Timeout</span> task <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newTimeout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Timeout</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                <span class="token comment">// 获取锁的过期续约条目</span>                <span class="token class-name">ExpirationEntry</span> ent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果续约条目不为null</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 获取第一个等待续约的线程ID</span>                    <span class="token class-name">Long</span> threadId <span class="token operator">=</span> ent<span class="token punctuation">.</span><span class="token function">getFirstThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 如果线程ID不为null</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 异步执行续约操作</span>                        <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 在续约操作完成后执行回调</span>                        future<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment">// 如果续约操作出现异常，则记录日志</span>                                <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Can't update lock "</span> <span class="token operator">+</span> <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" expiration"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token comment">// 如果更新超时时间成功，继续递归更新超时时间</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>internalLockLeaseTime <span class="token operator">/</span> <span class="token number">3L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新间隔为看门狗时间的1/3也就是30秒</span>        <span class="token comment">// 将定时任务设置到续约条目中</span>        ee<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看一下释放锁的源码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 异步释放锁。 * @param threadId 当前线程ID * @return 表示释放结果的Future对象 */</span><span class="token keyword">public</span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">unlockAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 创建一个Promise对象，用于表示释放结果</span>    <span class="token class-name">RPromise</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedissonPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 异步执行内部的解锁操作</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unlockInnerAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在解锁操作完成后执行回调</span>    future<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>opStatus<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token comment">// 取消锁的自动更新释放时间</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果解锁操作出现异常</span>            <span class="token comment">// 设置Promise为失败状态，并将异常作为失败原因</span>            result<span class="token punctuation">.</span><span class="token function">tryFailure</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>opStatus <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果操作状态为null，说明锁未被当前线程持有</span>            <span class="token comment">// 设置Promise为失败状态，并抛出IllegalMonitorStateException异常</span>            <span class="token class-name">IllegalMonitorStateException</span> cause <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token string">"attempt to unlock lock, not locked by current thread by node id: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">+</span> <span class="token string">" thread-id: "</span> <span class="token operator">+</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">tryFailure</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 否则，解锁成功</span>            <span class="token comment">// 设置Promise为成功状态</span>            result<span class="token punctuation">.</span><span class="token function">trySuccess</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回表示释放结果的Future对象</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>取消自动更新锁的释放时间方法</p><p>EXPIRATION_RENEWAL_MAP对应上面添加更新任务，这个Map里存的是一个个ExpirationEntry，ExpirationEntry里主要包含定时更新锁释放时间的任务和线程ID</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 取消锁的过期续约。 * @param threadId 要取消续约的线程ID，如果为null，则表示取消所有线程的续约 */</span><span class="token keyword">void</span> <span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span><span class="token class-name">Long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取锁的过期续约任务</span>    <span class="token class-name">ExpirationEntry</span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果过期续约任务不为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 如果线程ID不为null，则移除指定线程的续约</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            task<span class="token punctuation">.</span><span class="token function">removeThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 如果线程ID为null，或者任务已经没有任何线程在续约</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> task<span class="token punctuation">.</span><span class="token function">hasNoThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 获取任务的定时器任务</span>            <span class="token class-name">Timeout</span> timeout <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">getTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果定时器任务不为null，则取消定时器任务</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                timeout<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 从过期续约映射中移除该任务</span>            <span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>首先线程来获<strong>尝试获取锁（调用Lua脚本）</strong>，判断Lua脚本的返回值TTL是否为NULL（为剩余释放时间说明获取失败）</p></li><li><p>ttl为空说明获取成功，判断锁的释放时间是否设置，<strong>为-1表示未设置，则开启看门狗（看门狗的释放锁时间为30秒）</strong></p></li><li><p>如果自己设置了锁的释放时间则不会启用开门狗，也就是是<strong>不会自动更新释放时间</strong></p></li><li><p>如果获取TTL<strong>不为null说明锁被其他线程给占用了</strong>，被占用就去判断当前线程的剩余等待时间是否大于0</p></li><li><p>剩余等待时间不大于0则说明等待超时直接返回false表示获取锁失败</p></li><li><p>剩余等待时间大于0则<strong>订阅等待锁的释放信号</strong>，等待别的线程的剩余释放时间</p></li><li><p>如果<strong>别的线程的释放时间大于等于当前获取锁线程的最大等待时间，则当前线程直接等待最大等待时间</strong></p></li><li><p>等待完毕后判断等待时间是否超时，是则返回false获取锁失败</p></li><li><p>没有超时则继续尝试获取锁</p></li></ul><img src="/2024/05/13/hei-ma-dian-ping/image-20240520194740741.png" alt="image-20240520194740741"><p>Redisson分布式锁原理：<br>1、可重入：利用hash结构记录线程id和重入次数<br>2、可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制<br>3、超时续约：利用watchDog，每隔一段时间（releaseTime/3），重置超时时间</p><h2 id="Redisson锁的MutiLock原理"><a href="#Redisson锁的MutiLock原理" class="headerlink" title="Redisson锁的MutiLock原理"></a>Redisson锁的MutiLock原理</h2><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，<strong>哨兵会发现主机宕机，并且选举一个slave变成master</strong>，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><img src="/2024/05/13/hei-ma-dian-ping/1653553998403.png" alt="1653553998403" style="zoom: 50%;"><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，<strong>每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功</strong>，假设现在某个节点挂了，那么他去获得锁的时候，<strong>只要有一个节点拿不到，都不能算是加锁成功</strong>，就保证了加锁的可靠性。</p><img src="/2024/05/13/hei-ma-dian-ping/1653554055048.png" alt="1653554055048" style="zoom: 50%;"><p>那么MutiLock 加锁原理是什么呢？</p><p>当我们去设置了多个锁时，redission<strong>会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁</strong>，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，<strong>那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</strong></p><img src="/2024/05/13/hei-ma-dian-ping/1653553093967.png" alt="1653553093967"><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>1）不可重入Redis分布式锁：</p><p>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示<br>缺陷：不可重入、无法重试、锁超时失效</p><p>2）可重入的Redis分布式锁：</p><p>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待<br>缺陷：redis宕机引起锁失效问题</p><p>3）Redisson的multiLock：</p><p>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功<br>缺陷：运维成本高、实现复杂</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员Redis部分资料</p><p>Cookie、Session、Token概念、区别、如何实现：<a href="https://blog.csdn.net/weixin_44369049/article/details/132062232">https://blog.csdn.net/weixin_44369049/article/details/132062232</a></p><p>CSDN笔记：<a href="https://blog.csdn.net/m0_52380556?type=blog">https://blog.csdn.net/m0_52380556?type=blog</a></p><p>redisson：<a href="https://blog.csdn.net/weixin_53946852/article/details/137270519">https://blog.csdn.net/weixin_53946852/article/details/137270519</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DepGraph: Towards Any Structural Pruning</title>
      <link href="/2024/05/13/depgraph-towards-any-structural-pruning/"/>
      <url>/2024/05/13/depgraph-towards-any-structural-pruning/</url>
      
        <content type="html"><![CDATA[<h1 id="DepGraph-Towards-Any-Structural-Pruning"><a href="#DepGraph-Towards-Any-Structural-Pruning" class="headerlink" title="DepGraph: Towards Any Structural Pruning"></a>DepGraph: Towards Any Structural Pruning</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>结构化剪枝通过从神经网络中<strong>删除结构化分组的参数</strong>来实现模型加速。然而，参数分组模式在不同的模型中存在很大差异，这使得特定于体系结构的修剪器<strong>依赖于手工设计的分组方案，无法推广到新的体系结构中</strong>。</p><p>本工作在结构化剪枝的<strong>自动化上做了改进</strong>，提出了一种非深度图算法DepGraph，实现了<strong>架构通用的结构化剪枝</strong>，适用于CNNs,，Transformers, RNNs, GNNs等网络。DepGraph能够显式地建模层之间的依赖关系，并对耦合参数进行综合剪枝。自动地分析复杂的结构耦合，从而正确地移除参数实现网络加速。基于DepGraph算法，作者开发了PyTorch结构化剪枝框架 Torch-Pruning。不同于依赖Masking实现的“模拟剪枝”，该框架能够<strong>实际地移除参数和通道，降低模型推理成本</strong>。在DepGraph的帮助下，研究者和工程师无需再与复杂的网络结构斗智斗勇，可以轻松完成复杂模型的一键剪枝。</p><p>本文在几个架构和任务包括ResNe (X)t，DenseNet，MobileNet，VIT，GAT，DGCNN，LSTM上进行广泛评估。并证明提出的方法始终产生令人满意的性能。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>模型部署优化：通过减小模型大小，提高推理速度等，使得模型能够成功部署在各个硬件之中去并且实时有效的运作</p><h3 id="模型剪枝"><a href="#模型剪枝" class="headerlink" title="模型剪枝"></a>模型剪枝</h3><p>深度学习网络模型从卷积层到全连接层存在着大量冗余的参数，大量神经元激活值趋近于0，将这些神经元去除后可以表现出同样的模型表达能力，这种情况被称为过参数化，而对应的技术则被称为模型剪枝。</p><p>Dropout和DropConnect代表着非常经典的模型剪枝技术。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/3e76176a7a84934ac3c2773f8ce98490.png" alt="img" style="zoom:80%;"><p>Dropout中随机的将一些<strong>神经元的输出置零</strong>，这就是<strong>神经元剪枝</strong>。DropConnect则随机的将一些<strong>神经元之间的连接置零</strong>，使得<strong>权重连接矩阵变得稀疏</strong>，这便是<strong>权重连接剪枝</strong>。它们就是最细粒度的剪枝技术，只是这个操作仅仅发生在训练中，对最终的模型不产生影响，因此没有被称为模型剪枝技术。</p><p>当然，模型剪枝不仅仅只有对神经元的剪枝和对权重连接的剪枝，根据粒度的不同，至少可以粗分为4个粒度。</p><ul><li>细粒度剪枝(fine-grained)：即对连接或者神经元进行剪枝，它是粒度最小的剪枝。</li><li>向量剪枝(vector-level)：它相对于细粒度剪枝粒度更大，属于对<strong>卷积核内部(intra-kernel)的剪枝</strong>。</li><li>核剪枝(kernel-level)：即<strong>去除某个卷积核</strong>，它将丢弃对输入通道中对应计算通道的响应。</li><li>滤波器剪枝(Filter-level)：对<strong>整个卷积核组进行剪枝</strong>，会造成推理过程中输出特征通道数的改变。</li></ul><blockquote><p>细粒度剪枝(fine-grained)，向量剪枝(vector-level)，核剪枝(kernel-level)方法在参数量与模型性能之间取得了一定的平衡，但是<strong>网络的拓扑结构本身发生了变化</strong>，需要专门的算法设计来支持这种稀疏的运算，被称之为<strong>非结构化剪枝</strong>。</p><p>而滤波器剪枝(Filter-level)只改变了<strong>网络中的滤波器组和特征通道数目</strong>，所获得的模型不需要专门的算法设计就能够运行，被称为<strong>结构化剪枝</strong>。除此之外还有对整个网络层的剪枝，它可以被看作是滤波器剪枝(Filter-level)的变种，即所有的滤波器都丢弃。</p></blockquote><p>Google在《To prune, or not to prune: exploring the efficacy of pruning for model compression》[1]中探讨了具有同等参数量的稀疏大模型和稠密小模型的性能对比，在图像和语音任务上表明<strong>稀疏大模型普遍有更好的性能</strong>。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>首先训练一个大模型至最佳性能。</li><li>对模型的权重进行分析，去除那些对模型输出影响最小的权重。</li><li>对经过剪枝的模型重新进行微调，以恢复因剪枝造成的性能下降。</li></ul><h3 id="模型量化"><a href="#模型量化" class="headerlink" title="模型量化"></a>模型量化</h3><p>我们知道为了保证较高的精度，大部分的科学运算都是采用浮点型进行计算，常见的是32位浮点型和64位浮点型，即float32和double64。</p><p>对于深度学习模型来说，<strong>乘加计算量是非常大的</strong>，往往需要GPU等专用的计算平台才能实现实时运算，这对于端上产品来说是不可接受的，而模型量化是一个有效降低计算量的方法。</p><p><strong>量化，即将网络的权值，激活值等从高精度转化成低精度的操作过程</strong>，例如将32位浮点数转化成8位整型数int8，同时我们期望转换后的模型准确率与转化前相近。</p><p>模型量化可以带来几方面的优势，如下。</p><p>(1) 更小的模型尺寸。以8bit量化为例，与32bit浮点数相比，我们可以<strong>将模型的体积降低为原来的四分之一，</strong>这对于模型的存储和更新来说都更有优势。</p><p>(2) 更低的功耗。移动8bit数据与移动32bit浮点型数据相比，前者比后者高4倍的效率，而在一定程度上内存的使用量与功耗是成正比的。</p><p>(3) 更快的计算速度。相对于浮点数，大多数处理器都支持8bit数据的更快处理，如果是二值量化，则更有优势。</p><h3 id="知识蒸馏"><a href="#知识蒸馏" class="headerlink" title="知识蒸馏"></a>知识蒸馏</h3><p>一般地，大模型往往是单个复杂网络或者是若干网络的集合，拥有良好的性能和泛化能力，而小模型因为网络规模较小，表达能力有限。<strong>利用大模型学习到的知识去指导小模型训练</strong>，使得小模型具有与大模型相当的性能，但是参数数量大幅降低，从而可以实现模型压缩与加速，就是知识蒸馏与迁移学习在模型优化中的应用。Hinton等人最早在文章“Distilling the knowledge in a neural network”中提出了知识蒸馏这个概念，其核心思想是一旦复杂网络模型训练完成，便可以用另一种训练方法<strong>从复杂模型中提取出来更小的模型</strong>，因此知识蒸馏框架通常包含了一个大模型(被称为teacher模型)，和一个小模型(被称为student模型)。</p><p>具体的方法是在训练小模型时，在损失函数中添加额外的损失函数，损失函数的添加方式有以下几种：</p><p><strong>1.输出层的差异损失</strong>：这种方法是对比学生网络和教师网络在输出层上的概率分布之间的差异；</p><p><strong>2.隐藏层的相似度损失（余弦相似度损失）</strong>：这种方法是对比学生网络和教师网络在隐藏层的相似度差异；</p><p><strong>3.中间层的回归损失（均方误差，mse）</strong>：计算学生网络和教师网络在中间层的均方误差</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>边缘计算应用需要深度神经网络的压缩。在众多的网络压缩范式中，剪枝已经被证明是高效和实用的。网络剪枝的目标是<strong>从给定的网络中去除冗余参数，以使模型更轻量化，并潜在地加快推理速度。</strong>主流剪枝方法大致可分为两类：结构化剪枝和非结构化剪枝。</p><ul><li>结构化剪枝：通过从物理上去除分组参数来改变神经网络的结构；</li><li>非结构化剪枝：对部分权值进行调零，而不修改网络结构。</li></ul><p>在实践中非结构化剪枝能够直接地实现并且天然适用于各种网络，但它通常需要专门的人工智能加速器或软件来实现模型加速。而结构化剪枝不依赖于特定的人工智能加速器或软件来减少内存消耗和计算成本，应用更广泛。</p><p>挑战1：</p><p>深度神经网络建立在大量的基本模块之上，如卷积、标准化或激活，然而这些模块，无论参数化或未参数化，都是通过复杂的连接内在耦合的。因此，<strong>即使我们试图从CNN中只删除一个channel（如图1a），我们必须同时处理它对所有层的相互依赖关系</strong>。（这张图中，残差连接需要两个conv的参数来共享channel，所以修改conv2需要同时修改conv1，BN1，BN2）</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240513144816132.png" style="zoom:80%;"><p>（<em>图1：来自不同层的参数在跨网络架构中本质上是相互依赖的，这迫使多个层必须同时被修剪。本文引入了一个通用的方案，称为依赖图，以显式地解释这种依赖，并以全自动的方式对任意架构执行修剪。</em>）</p><ul><li>依赖性不仅出现在残差结构中，在现代模型中可能是无限复杂的。现有的结构化剪枝方案都依赖于个案分析，也就是<strong>针对于特定的网络</strong>。虽然效果好但费时费力且不能推广。</li><li>本文模型为了跟踪不同层之间的依赖关系，<strong>将依赖链分解并建模为一个递归过程</strong>，这自然可以归结为<strong>在图中寻找最大连通分量</strong>的问题，并且可以通过图遍历来实现O (N)复杂度。具体来说，对于网络中要修剪的层，可以将其作为根来触发相邻耦合层上的修剪，然后继续以被触发层为起点递归重复触发过程。通过这样做，可以全面收集所有耦合层以进行修剪。</li></ul><p>挑战2：</p><p>在结构剪枝中，分组层同时被修剪，这期望<strong>同一组中所有被删除的参数都是不重要的</strong>。这样的话，由于和其他层之间的关联，在单层中的参数重要性就不能反映真实情况。在不同的层上估计的重要性很可能是非加性的，有时甚至是相互矛盾的，这使得很难选择真正不重要的组来进行修剪。</p><p>为了解决这个问题，本文利用DepGraph的依赖建模能力设计了一个“分组级别”的重要性标准，该准则学习组内的一致稀疏性，以便可以安全地删除那些归零的层，而不会造成太多的性能损失。通过依赖建模，在实验中表明了一个简单的L2范数准则可以达到与现代方法相当的性能。</p><p>总之，本文的贡献是针对任何结构修剪的通用修剪方案，称为依赖图（DepGraph），它允许自动参数分组，并有效地提高了各种网络架构（包括CNN、RNN、GNN和Vision Transformer）上结构修剪的可推广性。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul><li><p>剪枝：剪枝算法的设计空间包括一系列方面，包括<strong>剪枝方案、参数选择、层稀疏性和训练技术</strong>。近年来，人们引入了许多稳健的标准，如基于幅度的标准和基于梯度的标准。另一种类型的方法通过稀疏训练来区分不重要的参数，稀疏训练将一些参数推到零以进行修剪。与那些静态标准相比，稀疏训练更可能找到不重要的参数，但由于需要网络训练，因此需要更多的计算资源。最近，还进行了一项综合性研究，以评估各种标准的效果，并提供一个公平的基准。</p></li><li><p>修剪分组参数：依赖性建模是任何结构修剪的关键和前提步骤，因为它涉及同时删除由于复杂的网络架构而在结构上彼此耦合的参数。剪枝分组参数的概念从结构剪枝的早期就已被研究。例如，<strong>当修剪两个连续卷积层时，修剪第一层内的卷积核会导致在后续层中去除与该滤波器相关的核</strong>。最近，已经提出了一些试点工作来解决层之间的复杂关系，并利用分组属性来提高结构修剪性能。</p><p>不幸的是，现有的技术仍然依赖于经验规则或预定义的架构模式，这使得它们在所有结构剪枝应用程序中都不够通用。在本研究中，我们提出了一种解决这一挑战的通用方法，证明了解决参数依赖性有效地推广了广泛网络的结构剪枝，从而在多个任务上获得令人满意的性能。</p></li></ul><h2 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h2><h3 id="神经网络的依赖性"><a href="#神经网络的依赖性" class="headerlink" title="神经网络的依赖性"></a>神经网络的依赖性</h3><p>不失一般性，在全连接层开发本文方法。从由三个连续层组成的线性神经网络开始，如图2 (a)所示，分别由二维<strong>权重矩阵</strong>wl、wl+1和wl+2参数化。这种简单的神经网络可以通过<strong>去除神经元的结构</strong>修剪而变得轻量化。在这种情况下，很容易发现参数之间存在一些依赖关系，表示为wl⇔wl+1, 这<strong>迫使二者同时被修剪</strong>。具体而言，为了修剪连接wl和wl+1的第k个神经元，将移除wl [k, :]和wl+1[:, k]。</p><blockquote><p>当我们希望通过剪枝某个神经元（高亮表示）实现加速时，与该神经元相连的多组参数需要被同时移除，<strong>这些参数就组成了结构化剪枝的最小单元，通常称为组（Group）</strong>。然而，在不同的网络架构中，参数的分组方式通常千差万别。图2（b）-（d）分别可视化了残差结构、拼接结构、以及降维度结构所致的参数分组情况，这些结构甚至可以互相嵌套，从而产生更加复杂的分组模式。</p></blockquote><p>通过手动设计和模型特定的方案来处理层依赖性，以逐个案例的方式手动分析所有这些依赖关系是很难的，更不用说简单的依赖关系可以嵌套或组合成更任意复杂的模式。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240513160026964.png"><p>（<em>图2：在不同的结构中具有相互依赖性的分组参数。必须同时修剪所有突出显示的参数。</em>）</p><p>为了解决结构修剪中的依赖问题，在本文工作中引入了依赖关系图，它为依赖关系建模提供了一种通用的、全自动的机制。</p><h3 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h3><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>为了实现结构化剪枝，首先需要根据层之间的相互依赖关系进行分组。形式上，目标是找到一个分组矩阵G∈R^L*L，其中L是一个待修剪网络的深度，Gij=1表示第i层和第j层之间存在依赖关系。令Diag(G)=1^1×L来保证自依赖。使用分组矩阵，很容易<strong>找到所有与第i层相互依赖的耦合层</strong>，即找到组：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240513161232441.png"><p>然而，由于现代深度网络可能由<strong>数千层复杂的连接</strong>组成，从神经网络中估计分组模式并不简单，他可能产生一个<strong>大而复杂的分组矩阵G</strong>。在这个矩阵中，Gij不仅由第i层和第j层决定，而且还受到它们之间的中间层的影响。这种非局部隐式关系在大多数情况下都不能用简单的规则来处理。为了克服这一挑战，作者没有直接估计分组矩阵G，而是<strong>提出了一种等效但易于估计的依赖建模方法，即依赖图，从中可以有效地推导出G</strong>。</p><h4 id="依赖图-1"><a href="#依赖图-1" class="headerlink" title="依赖图"></a>依赖图</h4><p>考虑一个分组g = {w1, w2, w3}，其中存在依赖关系w1⇔w2，w2⇔w3和1⇔w3。可以观察到<strong>冗余依赖</strong>（例如w1到w3可以通过w1w2，w2w3来推出传递依赖）。首先，我们以w1为起点，并检查它对其他层的依赖性，例如w1⇔w2。此时w2作为新的起点以递归扩展依赖，触发w2⇔w3，<strong>这个递归过程最终以一个传递关系结束</strong>，w1⇔w2⇔w3。在这种情况下，我们只需要两个依赖关系来描述组g中的关系。类似地，第3.2节中讨论的分组矩阵对于依赖关系建模也是冗余的，因此可以在保留相同信息的同时，压缩成更少的边和更紧凑的形式。</p><p><strong>一种新的图D测量相邻层之间的局部相互依赖性，称为依赖图，可以作为分组矩阵G的有效约简。</strong></p><p><strong>依赖图只记录具有直接连接的相邻层之间的依赖关系。</strong>他具有和G一样的顶点，但是有尽可能少的边。形式上，D被构造为，对于所有的Gij = 1，在顶点i和j之间存在一条路径。因此，Gij可以通过检验D中顶点i和j之间的路径的存在来得到。</p><h4 id="网络分解"><a href="#网络分解" class="headerlink" title="网络分解"></a>网络分解</h4><p>在层级之间构建依赖图在实践中可能存在问题。一些基本层，如全连接层，可能有两种不同的修剪方案，如w[k, : ]和w[ : , k]，它们<strong>分别压缩输入和输出的维度</strong>（如前面图2所示，同样的全连接层，要考虑两种剪枝）。此外，网络还包含<strong>非参数化的操作，如跳跃连接</strong>，这也会影响层[40]之间的依赖性。</p><p>对于一个卷积层而言，我们可以对参数的不同维度进行独立的修剪，从而分别剪枝输入通道或者输出通道。然而，上述的依赖图D却无法对这一现象进行建模。为此，我们提出了一种更细粒度的模型描述符，<strong>将网络F（x；w）分解为更精细、更基本的组件</strong>，记为F = {f1，f2，…，fL}，其中每个组件f表示（1）一个参数层如卷积层 或者（2）一个非参数操作如残差连接。<strong>关注层的输入和输出之间的关系而不是在层之间建模</strong>。具体地说，将分量fi的输入和输出分别表示为𝑓𝑖−和𝑓𝑖+。对于任何网络，最终的分解都可以形式化为F = {𝑓1−，𝑓1+，…，𝑓L−，𝑓L+}。这种表示法更容易进行依赖关系建模，并允许<strong>对同一层使用不同的剪枝方案。</strong></p><h4 id="依赖建模"><a href="#依赖建模" class="headerlink" title="依赖建模"></a>依赖建模</h4><p>利用这种符号，我们将神经网络重新定义为方程2，其中可以识别出两种主要的依赖类型，即层间依赖和层内依赖，如下所示：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240516144322342.png" alt="image-20240516144322342" style="zoom:80%;"><p><strong>符号↔表示两个相邻层之间的连通性。</strong>对这两个依赖关系的检查产生了简单但通用的<strong>依赖关系建模规则</strong>：</p><ul><li><p>层间依赖性：依赖性fi−⇔fj+持续出现在连接层中，其中𝑓𝑖−↔𝑓j+。由于一个层的输出和下一层的输入对应的是同一个中间特征（Feature），这就导致两者需要被同时剪枝。例如在通道剪枝中，“某一层的的输出通道剪枝”和“相邻后续层的输入通道剪枝”是等价的。</p></li><li><p>层内依赖性：在神经网络中，我们可以把各种层分为两类：第一类层的输入输出可以独立地进行剪枝，分别拥有不同的剪枝布局（pruning scheme），记作 𝑠𝑐ℎ(𝑓𝑖+) 或者 𝑠𝑐ℎ(𝑓𝑖−) 。例如对于全连接层的2D参数矩阵 𝑤 ，可以得到 𝑤[𝑘,:] 和 𝑤[:,𝑘] 两种不同的布局。这种情况下，输入 𝑓𝑖− 和输出 𝑓𝑖+ 在依赖图中是相互独立、非耦合的；而另一类层输入输出之间存在耦合，例如逐元素运算、Batch Normalization等。他们的参数（如果有）仅有一种剪枝布局，且同时影响输入输出的维度。如果 𝑓𝑖− 和 𝑓𝑖+ 共享相同的修剪方案，则存在依赖 𝑓𝑖− ⇔ 𝑓𝑖+ ，用𝑠𝑐ℎ(𝑓𝑖-) =𝑠𝑐ℎ(𝑓𝑖+) 表示。实际上，相比于复杂的参数耦合类型，深度网络中的层类型是非常有限的，我们可以预先定义不同层的剪枝布局来确定图中的依赖关系。</p></li></ul><p>正式定义如下的依赖关系建模：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240517110026498.png" alt="image-20240517110026498" style="zoom:80%;"><p>其中 ∨ 和 ∧ 分别表示逻辑”OR“和“AND”。第一项检查由<strong>网络连接引起的层间依赖关系</strong>，而第二项检查由<strong>层输入和输出之间的共享剪枝方案所引入的层内依赖关系。</strong></p><p>我们在算法1和算法2中总结了依赖图构建和参数分组的过程，其中参数分组是一个递归的连通分量（Connected Component）搜索问题，可以通过简单深度(DFS)或者宽度(BFS)优先搜索实现。算法2简要描述了这一过程，即以某个节点i作为起始分组g，找到依赖图D中与之相连的新节点j，合并入当前组，直到不存在新的联通节点为止。此处省略了分组的去重处理。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240517112155305.png" alt="image-20240517112155305" style="zoom:80%;"><p>将上述算法应用于一个具体的残差结构块，我们可以得到如下可视化结果。在具体剪枝时，以任意一个节点作为起始点，例如以 𝑓4+ 作为起点，递归地搜索能够访问到的所有其他节点，并将它们归入同一个组进行剪枝。值得注意的是，卷积网络由于输入输出使用了不同的剪枝布局（ 𝑠𝑐ℎ(𝑓4−)≠𝑠𝑐ℎ(𝑓4+) ），在依赖图中其输入输出节点间不存在层内依赖，但是由于skip连接 𝑓7 的存在，递归搜索过程中 𝑓4−和 𝑓4+ 会被分入同一组，即他们依旧需要被同时裁剪。其他层例如Batch Normalization的输入输出则存在简单的层内依赖。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240517105422995.png" alt="image-20240517105422995" style="zoom:80%;"><p>图3。层分组是通过在DepGraph上递归传递实现的（从f4+开始）</p><h3 id="组级别剪枝"><a href="#组级别剪枝" class="headerlink" title="组级别剪枝"></a>组级别剪枝</h3><p>依赖图的一个重要作用是<strong>参数自动分组</strong>，从而实现任意架构的模型剪枝。实际上，依赖图的自动分组能力还可以帮助设计<strong>组级别剪枝（Group-level Pruning）</strong>。在结构化剪枝中，属于同一组的参数会被同时移除，这一情况下需要保证这些被移除参数是“一致冗余”的，如果这些参数中包含对网络预测至关重要的参数，那么移除这些参数难免会损伤性能。</p><p>一个重要问题<strong>是如何在涉及多个耦合层的情况下评估分组参数的重要性程度</strong>。在本节中，作者利用一个简单的norm-based标准来建立一个实用的组级剪枝方法。给定一个参数组g = {w1，w2，…，w|g|}，现有的标准如<strong>L2-norm重要性可以对每一个w产生独立的分数</strong>。估计组重要性的一种自然方法是计算一个聚合分数I(g)=每层分数的求和。但独立估计的各层重要性程度是非加性的，且由于分布和大小的散度而毫无意义。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240605144536610.png" alt="image-20240605144536610"><p>为了使这个简单的聚合能够作用于重要性估计，我们<strong>提出了一种稀疏训练方法来在组级别上稀疏参数</strong>（如图4(c)），这些零化的组就可以安全地从网络中移除。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524101302850.png" alt="image-20240524101302850" style="zoom:80%;"><p>如图4 (c)所示，目标是<strong>学习所有分组层之间的一致稀疏性，同时将某些维度归零为零。</strong>作者<strong>将分组参数扁平化并合并为一个大的参数矩阵（也就是对于分组中的每一层，获取到特定通道的独立的参数组重要性后，展平，然后添加到分组重要性list，构成二维矩阵），其中检索所有属于第k个可调维数的参数，就像CNN块的第k个通道一样</strong>。现在，<strong>一致的稀疏性可以通过一个简单的加权收缩来促进</strong>（采用一个L2正则项，通过赋予参数组的不同正则权重 𝛾 来进行组稀疏化）</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524104156855.png" alt="image-20240524104156855" style="zoom:80%;"><p>其中k用于<strong>可剪枝参数的切片</strong>（Slicing），用于定位当前参数内<strong>第k组参数子矩阵</strong>，上述稀疏算法会得到<strong>k组不同程度稀疏的耦合参数</strong>，我们选择整体L2 norm最小的耦合参数进行剪枝。我们使用一个可控的指数策略来确定γk如下：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524104920144.png" alt="image-20240524104920144" style="zoom:80%;"><p>经过稀疏训练后，作者进一步使用了一个相对分数<img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524105432943.png" alt="image-20240524105432943" style="zoom: 67%;">来识别和删除不重要的参数。</p><p>实际上，依赖图还可以用于设计各种更强大的<strong>组剪枝方法</strong>，但由于稀疏训练、重要性评估等技术并非DepGraph的主要内容，这里也就不再赘述。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>本文主要关注分类任务，在各种数据集上进行广泛的实验，如用于图像分类的CIFAR和ImageNet，用于图形分类的PPI，用于三维分类的ModelNet，用于文本分类的AGNews。使用模型如概要所述。为了进行ImageNet实验，使用了Torchvision 的现成模型作为原始模型。修剪后，所有模型都将按照与预训练阶段相似的协议进行微调，使用更小的学习率和更少的迭代。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>CIFAR是一个小型的图像数据集，被广泛用于验证剪枝算法的有效性。</p><p>我们利用DepGraph和一致性稀疏构建了一个非常简单的剪枝器，能够在这两种数据集上取得不错的性能。 当然，我们在Imagenet上并没有达到SOTA，因为我们的目标在于通用性而非特定架构上的性能。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524110639744.png" alt="image-20240524110639744" style="zoom:80%;"><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524113933711.png" alt="image-20240524113933711"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="一致性稀疏"><a href="#一致性稀疏" class="headerlink" title="一致性稀疏"></a>一致性稀疏</h4><p>在分析实验中，首先我们首先评估了一致性稀疏和逐层独立稀疏的差异，结论符合3.3中的分析，即<strong>逐层算法无法实现依赖参数的一致稀疏</strong>。例如下图中绿色的直方图表示传统的逐层稀疏策略，相比于本文提出的一致性稀疏，其整体稀疏性表现欠佳。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524114128417.png" alt="image-20240524114128417" style="zoom:80%;"><h4 id="分组策略"><a href="#分组策略" class="headerlink" title="分组策略"></a>分组策略</h4><p>我们同样对分组策略进行了评估，我们考虑了<strong>无分组（No Grouping）、卷积分组（Conv-only）和全分组（Full Grouping）</strong>三种策略：无分组对参数进行独立稀疏；卷积分组只考虑卷积层而忽略其他参数化的层；全分组将所有参数化的层进行一致性稀疏。实验表明全稀疏在得到更优的结果同时，剪枝的稳定性更高，不容易出现过度剪枝的情况（性能显著下降）。</p><p>另外剪枝的稀疏度如何分配也是一个重要问题，我们测试了算法在<strong>逐层相同稀疏度（Uniform Sparsity）和可学习稀疏度（Learned Sparsity）</strong>下的表现。可学习稀疏度根据稀疏后的参数L2 Norm进行全局排序，从而决定稀疏度。<strong>这一方法假设参数冗余并不是平均分布在所有层的</strong>，对不同层应用了不同的剪枝率，因此一般情况下可以取得更好的性能，这类方法通常也称为全局剪枝（Global Pruning）。但与此同时，<strong>可学习的稀疏度存在过度剪枝风险，即在某一层中移除过多的参数</strong>。下图中可以看到VGG网络出现了过度剪枝的问题，导致Learned Sparsity效果显著低于Uniform Sparsity。在实际应用中，还是需要根据具体网络、评估指标的特点选择合适的稀疏度分配策略。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240601163320807.png" alt="image-20240601163320807" style="zoom:80%;"><h5 id="可学习稀疏度"><a href="#可学习稀疏度" class="headerlink" title="可学习稀疏度"></a>可学习稀疏度</h5><p>层的稀疏性也是剪枝的一个重要因素，它决定了剪枝神经网络的最终结构。表2提供了关于层稀疏性的一些结果。本研究主要关注两种稀疏性，即逐层相同稀疏性和可学习稀疏性。在相同稀疏性的情况下，由于假设了冗余参数通过网络均匀分布，所以对不同的层采用相同的剪枝比。然而，图5中之前的实验表明，不同的层并不是相同的。在大多数情况下，可学习的稀疏性优于均匀的稀疏性，尽管有时它可能会过度修剪某些层，导致精度下降。</p><h5 id="DepGraph的通用性"><a href="#DepGraph的通用性" class="headerlink" title="DepGraph的通用性"></a>DepGraph的通用性</h5><p>表2中的结果也证明了我们的框架的通用性，它能够处理各种卷积神经网络。此外，我们强调我们的方法与DenseNet和GoogleNet兼容，它们包含密集的连接和并行结构。</p><h4 id="依赖图可视化"><a href="#依赖图可视化" class="headerlink" title="依赖图可视化"></a>依赖图可视化</h4><p>由于参数分组的复杂过程，修剪大型神经网络是一个相当大的挑战。然而，通过利用深度图，可以毫不费力地得到所有的耦合群。下图中我们可视化了DenseNet-121、ResNet-18、ViT-Base的依赖图和递归推导得到的分组矩阵，可以发现不同网络的参数依赖关系是复杂且各不相同的。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240601165302830.png" alt="image-20240601165302830" style="zoom:80%;"><h4 id="非图像模型结构化剪枝"><a href="#非图像模型结构化剪枝" class="headerlink" title="非图像模型结构化剪枝"></a>非图像模型结构化剪枝</h4><p> 深度模型不仅仅只有CNN和transformer，我们还对其他架构的深度模型进行了初步验证，包括用于文本分类的LSTM，用于3D点云分类的DGCNN以及用于图数据的GAT，我们的方法都取得了令人满意的结果。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240601165426443.png" alt="image-20240601165426443" style="zoom:80%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提出了一种面向任意架构的结构化剪枝技术DepGraph，极大简化了剪枝的流程。目前，我们的框架已经覆盖了Torchvision模型库中95%的模型，涵盖分类、分割、检测等任务。总体而言，本文工作是第一次尝试开发一种可应用于多种架构（CNNs, RNNs, GNNs, and Transformers）的通用算法。此外，当前大多数剪枝算法都是针对单层设计的，我们的工作为将来“组级别剪枝”的研究提供了一些有用的基础资源。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="权值剪枝器（Magnitude-Pruner）"><a href="#权值剪枝器（Magnitude-Pruner）" class="headerlink" title="权值剪枝器（Magnitude Pruner）"></a>权值剪枝器（Magnitude Pruner）</h3><p>MagnitudePruner是一种利用权值大小定位冗余参数的经典算法，相关技术发表于“Pruning Filters for Efficient ConvNets”一文。作者讨论了一种神经网络中最基础的依赖关系（卷积和残差连接）</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240604114918956.png" alt="image-20240604114918956"><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240604115208636.png" alt="image-20240604115208636"><h4 id="tp实现"><a href="#tp实现" class="headerlink" title="tp实现"></a>tp实现</h4><p>类tp.importance.Importance要求我们实现一个非常简单的接口__call__，其中输入参数是一个group，它包含了多个相互耦合的层。该函数的输出则是一个<strong>一维的重要性得分向量</strong>，其含义是每个通道的重要性，因此他的维度和通道数通常是相同的。由于输入的Group通常会包含多个可剪枝层，因此我们<strong>首先对这些层进行独立的重要性计算，然后通过求平均值得到最终结果</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch_pruning <span class="token keyword">as</span> tp<span class="token keyword">class</span> <span class="token class-name">MyMagnitudeImportance</span><span class="token punctuation">(</span>tp<span class="token punctuation">.</span>importance<span class="token punctuation">.</span>Importance<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> group<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 1. 首先定义一个列表用于存储分组内==每一层==的重要性</span>        group_imp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token comment"># 2. 迭代分组内的各个层，对Conv层计算重要性</span>        <span class="token keyword">for</span> dep<span class="token punctuation">,</span> idxs <span class="token keyword">in</span> group<span class="token punctuation">:</span> <span class="token comment"># idxs是一个包含所有可剪枝索引的列表，用于处理DenseNet中的局部耦合的情况</span>            layer <span class="token operator">=</span> dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span>module <span class="token comment"># 获取 nn.Module</span>            prune_fn <span class="token operator">=</span> dep<span class="token punctuation">.</span>handler    <span class="token comment"># 获取 剪枝函数</span>            <span class="token comment"># 3. 这里我们简化问题，仅计算卷积输出通道的重要性</span>            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>layer<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">)</span> <span class="token keyword">and</span> prune_fn <span class="token operator">==</span> tp<span class="token punctuation">.</span>prune_conv_out_channels<span class="token punctuation">:</span>                w <span class="token operator">=</span> layer<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">[</span>idxs<span class="token punctuation">]</span><span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 用索引列表获取耦合通道对应的参数，并展开成2维</span>                local_norm <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 计算==每个通道参数子矩阵的 L1 Norm==</span>                group_imp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>local_norm<span class="token punctuation">)</span> <span class="token comment"># 将其保存在列表中</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>group_imp<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span> <span class="token comment"># 跳过不包含卷积层的分组</span>        <span class="token comment"># 4. 按通道计算平均重要性</span>        group_imp <span class="token operator">=</span> torch<span class="token punctuation">.</span>stack<span class="token punctuation">(</span>group_imp<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> group_imp <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于每个Group，我们计算了其中卷积层输出通道的重要性，然后求平均值得到最终的评估结果。基于上述代码，一个MagnitudePruner实际上已经完成了，但是参数修剪由谁来执行呢？Torch-Pruning库定义了一个元剪枝器tp.pruner.MetaPruner，能够帮助我们完成除了重要性评估之外的所有工作。因此，我们现在可以开始执行剪枝了。为了增加难度，这里我们对一个DenseNet模型进行剪枝：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> torchvision<span class="token punctuation">.</span>models <span class="token keyword">import</span> densenet121<span class="token keyword">import</span> torch_pruning <span class="token keyword">as</span> tpmodel <span class="token operator">=</span> densenet121<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>example_inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token comment"># 1. 使用我们上述定义的重要性评估</span>imp <span class="token operator">=</span> MyMagnitudeImportance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 2. 忽略无需剪枝的层，例如最后的分类层</span>ignored_layers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> m <span class="token keyword">in</span> model<span class="token punctuation">.</span>modules<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">)</span> <span class="token keyword">and</span> m<span class="token punctuation">.</span>out_features <span class="token operator">==</span> <span class="token number">1000</span><span class="token punctuation">:</span>        ignored_layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token comment"># DO NOT prune the final classifier!</span><span class="token comment"># 3. 初始化剪枝器</span>iterative_steps <span class="token operator">=</span> <span class="token number">5</span> <span class="token comment"># 迭代式剪枝，重复5次Pruning-Finetuning的循环完成剪枝。</span>pruner <span class="token operator">=</span> tp<span class="token punctuation">.</span>pruner<span class="token punctuation">.</span>MetaPruner<span class="token punctuation">(</span>    model<span class="token punctuation">,</span>    example_inputs<span class="token punctuation">,</span> <span class="token comment"># 用于分析依赖的伪输入</span>    importance<span class="token operator">=</span>imp<span class="token punctuation">,</span> <span class="token comment"># 重要性评估指标</span>    iterative_steps<span class="token operator">=</span>iterative_steps<span class="token punctuation">,</span> <span class="token comment"># 迭代剪枝，设为1则一次性完成剪枝</span>    ch_sparsity<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token comment"># 目标稀疏性，这里我们移除50%的通道 ResNet18 = {64, 128, 256, 512} =&gt; ResNet18_Half = {32, 64, 128, 256}</span>    ignored_layers<span class="token operator">=</span>ignored_layers<span class="token punctuation">,</span> <span class="token comment"># 忽略掉最后的分类层</span><span class="token punctuation">)</span><span class="token comment"># 4. Pruning-Finetuning的循环</span>base_macs<span class="token punctuation">,</span> base_nparams <span class="token operator">=</span> tp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>count_ops_and_params<span class="token punctuation">(</span>model<span class="token punctuation">,</span> example_inputs<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>iterative_steps<span class="token punctuation">)</span><span class="token punctuation">:</span>    pruner<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 执行裁剪，本例子中我们每次会裁剪10%，共执行5次，最终稀疏度为50%</span>    macs<span class="token punctuation">,</span> nparams <span class="token operator">=</span> tp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>count_ops_and_params<span class="token punctuation">(</span>model<span class="token punctuation">,</span> example_inputs<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"  Iter %d/%d, Params: %.2f M =&gt; %.2f M"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> iterative_steps<span class="token punctuation">,</span> base_nparams <span class="token operator">/</span> <span class="token number">1e6</span><span class="token punctuation">,</span> nparams <span class="token operator">/</span> <span class="token number">1e6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"  Iter %d/%d, MACs: %.2f G =&gt; %.2f G"</span><span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> iterative_steps<span class="token punctuation">,</span> base_macs <span class="token operator">/</span> <span class="token number">1e9</span><span class="token punctuation">,</span> macs <span class="token operator">/</span> <span class="token number">1e9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># finetune your model here</span>    <span class="token comment"># finetune(model)</span>    <span class="token comment"># ...</span><span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Slimming剪枝器"><a href="#Slimming剪枝器" class="headerlink" title="Slimming剪枝器"></a>Slimming剪枝器</h3><p>在上文中，我们介绍了如何快速实现一个简单的权值剪枝算法，它直接作用于模型的参数上，选取那些相对较小的参数进行裁剪。然而，实际上<strong>一个模型中的各个参数权值大小可能非常接近，因此我们难以直接根据参数大小来判断其重要性</strong>。针对这一问题，于ICCV2017会议上发表的slimming算法提出了一种经典的解决方案：利用Batch Normalization的scale参数完成重要性评估。</p><p>…………</p><h2 id="LLM剪枝"><a href="#LLM剪枝" class="headerlink" title="LLM剪枝"></a>LLM剪枝</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>LLM压缩与传统网络压缩区别：</p><ol><li><p><strong>模型规模：</strong>第一个主要差异来自LLM的巨大参数量，这导致许多侧重训练（Training-heavy）的压缩方案，例如知识蒸馏[1]变得较为困难.</p></li><li><p><strong>海量训练语料</strong>：许多LLMs经历了1万亿甚至更大规模的tokens上的训练[3]，这导致许多依赖于原始数据或收集替代数据的方案变得尤其昂贵。</p></li><li><p><strong>任务无关的模型压缩：</strong>现有的压缩算法通常针对单一、特定的任务进行压缩，而LLMs是很优秀的多任务处理器，在压缩过程中我们不希望折损LLM的通用性和多功能性。</p></li></ol><p>我们需要一种能够避免大规模重新训练、且能保持模型原有能力的压缩方法。现有的较为可行的两种方案是【模型量化】和【网络剪枝】<strong>。</strong>其中模型量化侧重于降低推理阶段的存储开销以及提升计算速度，而网络剪枝则移除部分参数实现压缩，两种方案可以相互结合达到最优性能。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240605165433575.png" alt="image-20240605165433575" style="zoom:80%;"><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><p><strong>1.训练语料库规模巨大</strong>：以往的压缩方法严重依赖于训练语料库。LLM已经将语料库规模升级到1万亿token。巨大的存储需求和漫长的传输时间使数据集难以获取。</p><p><strong>2.修建后的LLM的后训练时间巨大</strong>：现有的方法需要大量的时间来后训练生成的小模型。例如，在TinyBERT中的一般蒸馏大约需要14 GPU天。即使是后训练特定任务的BERT压缩模型也需要大约33小时。随着llm的模型和语料库的大小迅速增加，这一步骤必然会消耗更长的时间。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>遵循常规的剪枝流程，LLM-Pruner包含三个步骤：发现阶段，估计阶段，恢复阶段。</p><p>(1) 发现阶段：这一步聚焦于识别LLM内部相互依赖的结构，这些相互依赖的结构需要被同时移除已确保剪枝后结构的正确性。</p><p>(2) 估计阶段：一旦耦合结构被分组，第二步就包含估计每个组对模型总体性能的贡献，并决定要剪枝的组。</p><p>(3) 恢复阶段：这一步涉及到快速的后训练，用于缓解由于结构删除而可能引起的性能降级。</p><h4 id="依赖分组"><a href="#依赖分组" class="headerlink" title="依赖分组"></a>依赖分组</h4><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240605170758309.png" alt="image-20240605170758309" style="zoom:80%;"><p>Ni指向Nj，且Nj入度为1。则Nj依赖于Ni。</p><p>Nj唯一依赖于Ni，则Ni与Nj在同一组</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240606144246633.png" alt="image-20240606144246633" style="zoom:80%;"><p>图2: LLaMA中耦合结构的示例。我们简化了每层的神经元以清晰地展示依赖组。剪枝的起始神经元被铃图案所标记，这一操作会导致具有依赖性的权重被剪枝（虚线），并继续传播到耦合神经元（虚线圆圈）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>CVPR 2023 | DepGraph 通用结构化剪枝：<a href="https://zhuanlan.zhihu.com/p/619146631">https://zhuanlan.zhihu.com/p/619146631</a></p><p>模型加速｜CNN与ViT模型都适用的结构化剪枝方法（一）：<a href="https://developer.aliyun.com/article/1231617">https://developer.aliyun.com/article/1231617</a></p><p>【深度学习之模型优化】模型剪枝、模型量化、知识蒸馏概述：<a href="https://blog.csdn.net/qq_51831335/article/details/126660743">https://blog.csdn.net/qq_51831335/article/details/126660743</a></p><p>Torch-Pruning | 轻松实现结构化剪枝算法： <a href="https://zhuanlan.zhihu.com/p/619482727">https://zhuanlan.zhihu.com/p/619482727</a></p><p>YOLOv8模型剪枝实战： <a href="https://www.bilibili.com/video/BV1iA4m1F7zf/?vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1iA4m1F7zf/?vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>NeurIPS 2023 | LLM-Pruner: 大语言模型的结构化剪枝： <a href="https://zhuanlan.zhihu.com/p/630902012">https://zhuanlan.zhihu.com/p/630902012</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 压缩 </tag>
            
            <tag> 推理加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2024/05/11/redis/"/>
      <url>/2024/05/11/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>使用阿里云hit账号数据库，密码首字母大写</p><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li><strong>单线程</strong>，每个命令具备原子性</li><li>低延迟，速度快（<strong>基于内存</strong>、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p>NoSql</p></li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json</p><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。也称为<strong>非关系型数据库</strong>。</p><p>sql vs nosql：</p><ul><li><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：<strong>字段名、字段数据类型、字段约束</strong>等等信息，插入的数据必须遵守这些约束。而NoSql则对数据库格式没有严格约束，往往<strong>形式松散，自由</strong>。可以是键值型，也可以是文档型或者图格式。</p></li><li><p>传统数据库的表与表之间往往存在关联，例如外键。而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  name<span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>  orders<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>       id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>       item<span class="token operator">:</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">"荣耀6"</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token number">4999</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>       id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>       item<span class="token operator">:</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">"小米11"</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token number">3999</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><img src="/2024/05/11/redis/AzaHOTF.png" style="zoom:67%;"></li><li><p>传统关系型数据库能满足事务ACID的原则。而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现<strong>基本的一致性</strong>。</p></li></ul><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><img src="/2024/05/11/redis/1.png" style="zoom: 67%;"><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的<strong>磁盘IO</strong>，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是<strong>依赖于内存来操作，内存的读写速度会非常快</strong>，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以<strong>将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展</strong>。</li><li><strong>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</strong></li></ul></li></ul><h2 id="初识redis"><a href="#初识redis" class="headerlink" title="初识redis"></a>初识redis</h2><h3 id="linux启动"><a href="#linux启动" class="headerlink" title="linux启动"></a>linux启动</h3><h4 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h4><p>安装完成后，在任意目录输入redis-server命令即可启动Redis</p><img src="/2024/05/11/redis/v7xWsqC.png" style="zoom:67%;"><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h4 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf</p><p>我们先将这个配置文件备份一份：</p><pre class="line-numbers language-none"><code class="language-none">cp redis.conf redis.conf.bck<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>然后修改redis.conf文件中的一些配置：</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><span class="token key attr-name">bind</span> <span class="token value attr-value">0.0.0.0</span><span class="token comment"># 守护进程，修改为yes后即可后台运行</span><span class="token key attr-name">daemonize</span> <span class="token value attr-value">yes </span><span class="token comment"># 密码，设置后访问Redis必须输入密码</span><span class="token key attr-name">requirepass</span> <span class="token value attr-value">123321</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis的其它常见配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 监听的端口</span><span class="token key attr-name">port</span> <span class="token value attr-value">6379</span><span class="token comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><span class="token key attr-name">dir</span> <span class="token value attr-value">.</span><span class="token comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><span class="token key attr-name">databases</span> <span class="token value attr-value">1</span><span class="token comment"># 设置redis能够使用的最大内存</span><span class="token key attr-name">maxmemory</span> <span class="token value attr-value">512mb</span><span class="token comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><span class="token key attr-name">logfile</span> <span class="token value attr-value">"redis.log"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>启动Redis：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入redis安装目录 </span><span class="token builtin class-name">cd</span> /usr/local/src/redis-6.2.6<span class="token comment"># 启动</span>redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>停止服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><span class="token comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span>redis-cli <span class="token parameter variable">-u</span> <span class="token number">123321</span> <span class="token function">shutdown</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512130026010.png" style="zoom:67%;"><h4 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h4><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/systemd/system/redis.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容如下：</p><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>然后重载系统服务：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们可以用下面这组命令来操作redis了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动</span>systemctl start redis<span class="token comment"># 停止</span>systemctl stop redis<span class="token comment"># 重启</span>systemctl restart redis<span class="token comment"># 查看状态</span>systemctl status redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行下面的命令，可以让redis开机自启：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Redis桌面客户端"><a href="#Redis桌面客户端" class="headerlink" title="Redis桌面客户端"></a>Redis桌面客户端</h3><h4 id="命令行客户端"><a href="#命令行客户端" class="headerlink" title="命令行客户端"></a>命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-cli <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>commonds<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的<strong>IP地址</strong>，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p><strong>不指定commond时，会进入<code>redis-cli</code>的交互控制台</strong></p><img src="/2024/05/11/redis/OYYWPNo.png" style="zoom:80%;"><h4 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h4><p>RedisDesktopManager：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><p>Redis默认有20个仓库，编号从0至19.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><img src="/2024/05/11/redis/image-20240512133415507.png" style="zoom:67%;"><h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h2><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><img src="/2024/05/11/redis/8tli2o9.png" style="zoom:67%;"><p>官方文档与数据类型分组：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></p><img src="/2024/05/11/redis/image-20240512133753203.png" style="zoom:67%;"><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">keys *查看当前库所有key exits key  判断某个key是否存在 <span class="token builtin class-name">type</span> key  查看key是什么类型 del key删除指定的key数据 unlink key根据value选择非阻塞删除（仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作） expire key <span class="token number">10</span>  为给定的key设置过期时间（10s） ttl key查看还有多少秒过期：-1表示永不过期，-2表示已经过期 <span class="token keyword">select</span>切换数据库 dbsize查看当前数据库的key数量 flushdb清空当前库 flushall  通杀全部库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  添加或修改键值对（key存在时，set覆盖旧值） get <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  查询对应键值 append <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  将给定的value追加到原值的末尾 strlen <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  获得值的长度 setnx <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  只有key不存在时，设置key值 incr <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  将key中储存的数字值增1，<span class="token operator">==</span><span class="token operator">=</span>只能对数字值操作<span class="token operator">==</span><span class="token operator">=</span>，如果为空，新增值为1incrby <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> xx 让一个整型的key自增并指定步长，例如：incrby num <span class="token number">2</span> 让num值自增2incrbyfloat <span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span> xx 让一个浮点型的key自增并指定步长decr <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  将key中储存的数字值建减1，只能对数字值操作，如果为空，新增值为-1 incrby / decrvy <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>步长<span class="token operator">&gt;</span>  将key中储存的数字值增减，自定义步长 mset <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……  批量添加一个或多个 key-value 对 mget <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span>……  批量获取一个或多个value msetnax  <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……  同时设置一个或多个key-value对，当且仅当所有给定key都不存在 getrange <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>起始位置<span class="token operator">&gt;</span><span class="token operator">&lt;</span>结束位置<span class="token operator">&gt;</span>  获得值的范围，类似java中的substring，前包，后包 setrange <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>起始位置<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  用<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>覆写<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>所存储的字符串值，从起始位置开始（索引从0开始） setex <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>过期时间<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  设置键值的同时，设置过期时间（单位：秒） getset <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  以新换旧，设置了新值的同时获得旧值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="key结构"><a href="#key结构" class="headerlink" title="key结构"></a>key结构</h4><p>Redis没有类似MySQL中的Table的概念，我们该如何区分<strong>不同类型的key</strong>呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分：Redis的key允许<strong>有多个单词形成层级结构，多个单词之间用’:’隔开</strong>，格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">项目名:业务名:类型:id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样我们就可以把不同类型的数据区分开了。从而<strong>避免了key的冲突问题。</strong></p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以<strong>将对象序列化为JSON字符串后存储：</strong></p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><img src="/2024/05/11/redis/image-20240512143035672.png" style="zoom:80%;"><p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p><img src="/2024/05/11/redis/image-20240512143224071.png" style="zoom:80%;"><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash类型，也叫散列，其value是一个无序字典（<code>Hash</code>是一个<code>String</code>类型的<code>Field</code>和<code>Value</code>的映射表），类似于HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便；<strong>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。</strong></p><img src="/2024/05/11/redis/VF2EPt0.png"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hset <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  给<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>集合中的<span class="token operator">&lt;</span>filed<span class="token operator">&gt;</span>键赋值<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>，可以添加也可以修改 hget <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span>  从<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>集合<span class="token operator">&lt;</span>field<span class="token operator">&gt;</span>取出value hmset <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……  批量设置hash的值hmget <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token punctuation">..</span>.  批量获取hash的field的值 hexits <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>filed<span class="token operator">&gt;</span>  查看哈希表key中，给定域field是否存在 hkeys <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  列出该hash集合key的所有field hvals <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  列出该hash集合的所有value hincrby <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span><span class="token operator">&lt;</span>increment<span class="token operator">&gt;</span>  为哈希表key中的域field的值加上增量（自增自减）并指定步长 hsetnx <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  将哈希表key中的域field的值设置为value，当且仅当域field不存在hgetall <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> 获取一个hash类型的key中的所有的field和value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512144509760.png" style="zoom:80%;"><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li><strong>有序</strong></li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lpush / rpush <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span>……  从左边（头插法）/右边（尾插法）插入一个或多个值 lpop / rpop <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  从左边/右边移除并返回第一个值，没有则返回null rpoplpush <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>  从<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>列表右边移除一个值，插到<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>列表左边 lrange <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>start<span class="token operator">&gt;</span><span class="token operator">&lt;</span>stop<span class="token operator">&gt;</span>  按照索引下标获得元素（从左到右） eg：lrange mylist <span class="token number">0</span> <span class="token parameter variable">-1</span>  <span class="token number">0</span>左边第一个，-1右边第一个（0 <span class="token parameter variable">-1</span> 表示获取所有） lindex <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>index<span class="token operator">&gt;</span>  按照索引下标获得元素（从左到右） llen <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  获得列表长度 linsert <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> before <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span><span class="token operator">&lt;</span>newvalue<span class="token operator">&gt;</span>  在<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>后面插入<span class="token operator">&lt;</span>newvalue<span class="token operator">&gt;</span>插入值 lrem <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>n<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  从左起删除n个vlaue（从左到右） lset <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>index<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  将列表key下标为index的值替换成value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">LPUSH <span class="token function">users</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>RPUSH <span class="token function">users</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>结果是users中包含 <span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>LRANGE <span class="token function">users</span> <span class="token number">1</span> <span class="token number">2</span>结果是<span class="token punctuation">[</span><span class="token string">"1"</span>,<span class="token string">"4"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li><strong>元素不可重复</strong></li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sadd <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……将一个或多个元素加入到集合key中，已经存在的元素将被忽略srem <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……删除集合中的指定元素 smembers <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>取出该集合的所有值 sismember <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>判断集合<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>是否包含该<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>值，有1，没有0 scard <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>返回该集合的元素个数 spop <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>随机从该集合中吐出一个值 srandmember <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>n<span class="token operator">&gt;</span>随机从该集合中取出n个值，不会从集合中删除 smove <span class="token operator">&lt;</span>source<span class="token operator">&gt;</span><span class="token operator">&lt;</span>destination<span class="token operator">&gt;</span>value把集合中的一个值从一个集合移动到另一额集合 sinter<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>返回两个集合的交集元素 sunion <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>返回两个集合的并集元素 <span class="token function">sdiff</span> <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>返回两个集合的差集元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sadd s1 a b c<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> smembers s1<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"c"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"b"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"a"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> srem s1 a<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>    <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SISMEMBER s1 a<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>    <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SISMEMBER s1 b<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>    <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SCARD s1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SortedSet（Zset）"><a href="#SortedSet（Zset）" class="headerlink" title="SortedSet（Zset）"></a>SortedSet（Zset）</h3><p>Redis的SortedSet是一个<strong>可排序的set集合</strong>，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于<strong>score属性对元素排序</strong>，底层的实现是<strong>一个跳表（SkipList）加 hash表</strong>。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><pre class="line-numbers language-none"><code class="language-none">zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;……  将一个或多个member元素及其score值加入到有序集key中，若已存在则覆盖score值 zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]  返回有序集key中，下标在strart到stop之间的元素（带WITHSCORES，可以让分数一起返回） zrangebyscore key min max [withscores][limit offset count]  返回有序集key中，所有score值介于min和max之间的成员(从小到大) zrevrangebyscore key max min [withscores][limit offet count]  同上，从大到小排序 zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;  让sorted set中的指定元素自增，步长为指定的increment值 zrem &lt;key&gt;&lt;value&gt;  删除该集合下，指定元素value zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;  统计该集合，分数区间内的元素个数 zrank &lt;key&gt;&lt;value&gt;  返回该值在集合中的排名，从0开始zscore &lt;key&gt;&lt;value&gt; 获取sorted set中的指定元素的score值zcard &lt;key&gt; 获取sorted set中的元素个数ZDIFF.ZINTER.ZUNION：求差集.交集.并集<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>将班级的下列学生得分存入Redis的SortedSet中：</p><p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p><p>并实现下列功能：</p><ul><li>删除Tom同学</li><li>获取Amy同学的分数</li><li>获取Rose同学的排名</li><li>查询80分以下有几个学生</li><li>给Amy同学加2分</li><li>查出成绩前3名的同学</li><li>查出成绩80分以下的所有同学</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ZADD studs <span class="token number">85</span> Jack <span class="token number">89</span> Lucy <span class="token number">82</span> Rose <span class="token number">95</span> tom <span class="token number">78</span> Jerry <span class="token number">92</span> Amy <span class="token number">76</span> Miles<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512152116142.png" style="zoom:80%;"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zrem studs tomzrank studs Rose排名2zrevrank studs Rose排名3（倒数4）zcount studs <span class="token number">0</span> <span class="token number">80</span>结果2人zincrby studs <span class="token number">2</span> Amy结果94.0分zrange studs <span class="token number">0</span> <span class="token number">2</span>结果<span class="token punctuation">[</span><span class="token string">"Miles"</span>,<span class="token string">"Rose"</span>,<span class="token string">"Jerry"</span><span class="token punctuation">]</span>zrangebyscore studs <span class="token number">0</span> <span class="token number">80</span>结果<span class="token punctuation">[</span><span class="token string">"Miles"</span>,<span class="token string">"Jerry"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><pre class="line-numbers language-none"><code class="language-none">setbit &lt;key&gt;&lt;offset&gt;&lt;value&gt;  设置Bitmaps中某个偏移量的值（0或1）（offset：偏移量从0开始） getbit &lt;key&gt;&lt;offset&gt;  获取Bitmaps中某个偏移量的值 bitcount &lt;key&gt;[start end]  统计字符串从start字节到end字节比特值为1的量 bitop and(or/not/xor) &lt;destkey&gt; [key] 复合操作，可以做多个bitmaps的交集(and)、并集(or)、非(not)、异或(xor)操作并将结果保存在destkey中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><pre class="line-numbers language-none"><code class="language-none">pfadd &lt;key&gt;&lt;element&gt;[element……]  添加指定元素到HyperLogLog中 pfcount &lt;key&gt; [key……]  计算HLL的近似基数，可以计算多个HLL（比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可） pfmerge &lt;destkey&gt;&lt;sourcekey&gt;[sourcekey……]  将一个或多个HLL合并后的结果存储在另一个HLL中（比如每月活跃用户可以使用每天的活页用户来合并计算可得）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><pre class="line-numbers language-none"><code class="language-none">geoadd &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;&lt;member&gt;[longitude lattitude member……] 添加地理位置（经度、维度、名称） geopos &lt;key&gt;&lt;member&gt;[member……]  获得指定地区的坐标值 geodist &lt;key&gt;&lt;member1&gt;&lt;member2&gt; [m|km|ft|mi]  获取两个位置之间的直线距离 georadius &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;radius m|km|ft|mi以给定的经纬度为中心，找出某一半径内的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p>其中Java客户端也包含很多：</p><img src="/2024/05/11/redis/image-20240512153303012.png"><p>标记为*的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而<strong>SpringDataRedis又对这两种做了抽象和封装</strong>，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是<strong>在Redis基础上实现了分布式的可伸缩的java数据结构</strong>，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h3 id="Jedis客户端"><a href="#Jedis客户端" class="headerlink" title="Jedis客户端"></a>Jedis客户端</h3><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> redisTest <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Jedis</span> jedis<span class="token punctuation">;</span>    <span class="token annotation punctuation">@BeforeEach</span>    <span class="token keyword">void</span> <span class="token function">setUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 建立连接</span>        jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"ip"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 选择库</span>        jedis<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 存入数据</span>    <span class="token class-name">String</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"虎哥"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result = "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取数据</span>    <span class="token class-name">String</span> name <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 插入hash数据</span>    jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hgetAll</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>释放资源</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@AfterEach</span><span class="token keyword">void</span> <span class="token function">tearDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>jedis <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="jedis连接池"><a href="#jedis连接池" class="headerlink" title="jedis连接池"></a>jedis连接池</h4><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisConnectionFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">JedisPool</span> jedisPool<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token comment">// 配置连接池</span>        <span class="token class-name">JedisPoolConfig</span> poolConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 最大空闲连接</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMinIdle</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 最小空闲连接</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 没有连接时，最多等待1000ms</span>        <span class="token comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span>        jedisPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>poolConfig<span class="token punctuation">,</span> <span class="token string">"ip"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Jedis</span> <span class="token function">getJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了<strong>对不同Redis客户端的整合（Lettuce和Jedis）</strong></li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><img src="/2024/05/11/redis/UFlNIV0.png" style="zoom:80%;"><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- spring-data-redis--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--common-pool--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--Jackson依赖--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h4><p>application.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># REDIS (RedisProperties)</span><span class="token comment"># Redis数据库索引（默认为0）</span><span class="token key attr-name">spring.data.redis.database</span><span class="token punctuation">=</span><span class="token value attr-value">0</span><span class="token comment"># Redis服务器地址</span><span class="token key attr-name">spring.data.redis.host</span><span class="token punctuation">=</span><span class="token value attr-value">ip</span><span class="token comment"># Redis服务器连接端口</span><span class="token key attr-name">spring.data.redis.port</span><span class="token punctuation">=</span><span class="token value attr-value">6379</span><span class="token comment"># Redis服务器连接密码（默认为空）</span><span class="token key attr-name">spring.data.redis.password</span><span class="token punctuation">=</span><span class="token value attr-value">pwd</span><span class="token comment"># 连接池最大连接数（使用负值表示没有限制）</span><span class="token key attr-name">spring.data.redis.jedis.pool.max-active</span><span class="token punctuation">=</span><span class="token value attr-value">8</span><span class="token comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><span class="token key attr-name">spring.data.redis.jedis.pool.max-wait</span><span class="token punctuation">=</span><span class="token value attr-value">1000</span><span class="token comment"># 连接池中的最大空闲连接</span><span class="token key attr-name">spring.data.redis.jedis.pool.max-idle</span><span class="token punctuation">=</span><span class="token value attr-value">8</span><span class="token comment"># 连接池中的最小空闲连接</span><span class="token key attr-name">spring.data.redis.jedis.pool.min-idle</span><span class="token punctuation">=</span><span class="token value attr-value">0</span><span class="token comment"># 连接超时时间（毫秒）</span><span class="token key attr-name">spring.data.redis.timeout</span><span class="token punctuation">=</span><span class="token value attr-value">5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注入RedisTemplate，测试"><a href="#注入RedisTemplate，测试" class="headerlink" title="注入RedisTemplate，测试"></a>注入RedisTemplate，测试</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">SpringRedisApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 写入string</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"胡歌"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取string数据</span>        <span class="token class-name">Object</span> name <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> name <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h4><p><strong>RedisTemplate默认采用JDK的序列化工具，可以接收任意Object作为值写入Redis，序列化为字节形式，在redis中可读性很差且内存占用大。</strong><br>修改默认的序列化方式为jackson</p><p>我们可以自定义RedisTemplate的序列化方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> connectionFactory<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 创建RedisTemplate对象</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置连接工厂</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建JSON序列化工具</span>        <span class="token class-name">GenericJackson2JsonRedisSerializer</span> jsonRedisSerializer <span class="token operator">=</span>             <span class="token keyword">new</span> <span class="token class-name">GenericJackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置Key的序列化</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置Value的序列化</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512170814734.png" style="zoom:80%;"><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><img src="/2024/05/11/redis/image-20240512170944012.png"><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，<strong>其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</strong></p><h4 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h4><p>为了<strong>节省内存空间</strong>，我们可以<strong>不使用JSON序列化器来处理value，而是统一使用String序列化器</strong>，要求<strong>只能存储String类型的key和value</strong>。当需要存储Java对象时，<strong>手动完成对象的序列化和反序列化。</strong></p><p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">RedisStringTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 写入一条String数据</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"verify:phone:13600527634"</span><span class="token punctuation">,</span> <span class="token string">"124143"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取string数据</span>        <span class="token class-name">Object</span> name <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// JSON序列化工具</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ObjectMapper</span> mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testSaveUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">JsonProcessingException</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建对象</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"虎哥"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 手动序列化</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写入数据</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user:200"</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取数据</span>        <span class="token class-name">String</span> jsonUser <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user:200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 手动反序列化</span>        <span class="token class-name">User</span> user1 <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>jsonUser<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user1 = "</span> <span class="token operator">+</span> user1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user:400"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"虎哥"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user:400"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> entries <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token string">"user:400"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"entries = "</span> <span class="token operator">+</span> entries<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h3><p>性能优化（1）Redis <strong>基于内存</strong>，内存的访问速度比磁盘快很多；（2）Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是<strong>单线程事件循环和 IO 多路复用</strong>（Redis 线程模式后面会详细介绍到）；（3）Redis 内置了多种<strong>优化过后的数据类型/结构实现</strong>，性能非常高。（4）Redis 通信协议实现简单且解析高效。</p><img src="https://javaguide.cn/assets/why-redis-so-fast-TbWX24ja.png" alt="why-redis-so-fast" style="zoom: 33%;"><h3 id="分布式缓存方案"><a href="#分布式缓存方案" class="headerlink" title="分布式缓存方案"></a>分布式缓存方案</h3><p><strong>Memcached</strong></p><ul><li><p><strong>简介</strong>：Memcached 是一个高性能的分布式内存对象缓存系统，它最初是为了加速动态 Web 应用程序而开发的，通过在内存中缓存数据和对象，减少对数据库等后端存储的访问，从而提高应用程序的响应速度。</p></li><li><p><strong>适用场景</strong>：适用于对缓存读写性能要求极高、数据更新频率不高且<strong>允许数据丢失</strong>的场景，如网页缓存、热门数据缓存等。</p></li></ul><p>对比：</p><ul><li><strong>数据类型</strong>：Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Memcached 只支持最简单的 k/v 数据类型。</li><li><strong>数据持久化</strong>：Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 把数据全部存在内存之中，一旦服务器重启或崩溃，内存中的数据将全部丢失。也就是说，Redis 有灾难恢复机制而 Memcached 没有。</li><li><strong>集群模式支持</strong>：Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 自 3.0 版本起是原生支持集群模式的。</li><li><strong>线程模型</strong>：Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 针对网络数据的读写引入了多线程）</li><li><strong>特性支持</strong>：Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</li><li><strong>过期数据删除</strong>：Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</li></ul><h3 id="redis优点"><a href="#redis优点" class="headerlink" title="redis优点"></a>redis优点</h3><p><strong>1、访问速度更快</strong> 传统数据库数据保存在磁盘，而 Redis 基于内存，内存的访问速度比磁盘快很多。引入 Redis 之后，我们可以把一些高频访问的数据放到 Redis 中，这样下次就可以直接从内存中读取，速度可以提升几十倍甚至上百倍。</p><p><strong>2、高并发</strong> 一般像 MySQL 这类的数据库的 QPS 大概都在 4k 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 5w+，甚至能达到 10w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p><blockquote><p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p></blockquote><p>由此可见，<strong>直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的</strong>，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也<strong>就提高了系统整体的并发。</strong></p><p><strong>3、功能全面</strong> Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景，</p><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><img src="https://i-blog.csdnimg.cn/blog_migrate/388f43060891ccdae94082a154e1ad54.png" alt="img" style="zoom:50%;"><h4 id="String底层"><a href="#String底层" class="headerlink" title="String底层"></a>String底层</h4><p>应用场景：</p><ul><li>常规数据（比如 <strong>Session、Token、序列化后的对象、图片的路径</strong>）的缓存；</li><li><strong>计数</strong>比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数</li><li><strong>分布式锁</strong>(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li></ul><p>存储对象时和Hash对比：</p><ul><li>String适合存储嵌套结构较多或结构复杂的对象，可以直接存储整个对象序列化数据，操作简单，读写性能好，多数情况下更适合；</li><li>Hash适合需要频繁对指定字段做修改或查询的对象，占用内存比String小，特别是字段多且字段长度短的情况（底层ziplist存储优化），操作开销大</li></ul><h5 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h5><p>Redis基于C语言编写了 <strong>SDS（Simple Dynamic String，简单动态字符串）</strong> 作为底层实现。在 Redis 中，当存储的字符串长度小于 44 字节时（Redis 3.2 版本之前是 39 字节），默认使用 SDS 来存储。SDS 有多种不同的结构定义，以适应不同长度的字符串，常见的有 <code>sdshdr5</code>、<code>sdshdr8</code>、<code>sdshdr16</code>、<code>sdshdr32</code> 和 <code>sdshdr64</code>。SDS 可以存储字符串，也可以存储二进制数据，包括空字符，因此在处理二进制数据时更为灵活，不受空字符的限制。</p><p>与C语言中的字符串相比：（1）<strong>可以避免缓冲区溢出</strong>（先根据len检查空间大小）；（2）<strong>获取字符串长度的复杂度低</strong>（C要遍历）；（3）<strong>动态扩容，减少内存分配次数</strong>（扩容时，空间预分配；字符串缩短时，惰性空间释放-即标记多余空间为可用，等待后续使用）；（4）<strong>二进制安全</strong>（C语言以空字符\0作为结束标记）</p><p>采用了空间预分配和惰性空间释放的策略。在进行扩容时，除了分配实际需要的空间外，还会<strong>额外分配一些空间</strong>，以便后续的操作使用，减少了内存分配的次数。在进行<strong>字符串缩短</strong>操作时，不会立即释放多余的空间，而是<strong>将其标记为可用，等待后续使用</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, and 5 msb of string length */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span>  <span class="token comment">// 字符串的实际长度 -- 获取串长度为O(1)，C语言字符串是遍历计数，复杂度O(n)</span>    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">// 分配的内存空间大小，不包含头部和结尾的空字符 -- 在进行字符串拼接等操作时，SDS 会先检查分配的内存空间是否足够，如果不够会自动进行扩容，避免了 C 字符串可能出现的缓冲区溢出问题。</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">// 标志位，用于标识 SDS 的类型</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 存储字符串的字符数组</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span>    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span>    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ziplist-早期使用"><a href="#ziplist-早期使用" class="headerlink" title="ziplist 早期使用"></a>ziplist 早期使用</h5><p>在 Redis 早期版本中，对于长度较短的字符串，可能会使用<strong>压缩列表（ziplist）</strong>来存储。压缩列表是一种为了节省内存而设计的连续内存块数据结构，它将多个元素紧凑地存储在一起。不过，随着 Redis 的发展，现在对于较短字符串更多使用 SDS 来存储。</p><h4 id="list底层"><a href="#list底层" class="headerlink" title="list底层"></a>list底层</h4><p>Redis 的 <code>List</code> 类型是一个有序的字符串列表，它的底层数据结构主要有两种：<strong>压缩列表（ziplist）和双向链表（linkedlist）</strong>，在 Redis 3.2 版本之后，引入了<strong>快速列表（quicklist）</strong>作为 <code>List</code> 的底层实现。</p><h5 id="ziplist-早期使用-1"><a href="#ziplist-早期使用-1" class="headerlink" title="ziplist 早期使用"></a>ziplist 早期使用</h5><p>压缩列表（ZipList）是一种用于在 Redis 中<strong>紧凑存储列表和哈希表数据</strong>的数据结构。它是由一系列<strong>特定编码格式</strong>的<strong>连续内存块</strong>组成的<strong>顺序型数据结构</strong>，每个<strong>内存块</strong>称为一个<strong>节点（entry）</strong>。每个节点可以存储一个<strong>字节数组或整数值</strong>，并且可以根据实际存储的数据<strong>动态地调整节点的长度。</strong>列表或hash键元素较少且每个元素占用空间较小时使用压缩列表，目的是利用紧凑连续块来节省内存。</p><blockquote><ul><li><strong>优点</strong>：紧凑存储，可变长度，支持多种数据类型，适合小规模数据，需要遍历访问</li></ul><ul><li><strong>缺点</strong>：在插入或删除元素时，可能需要对内存进行重新分配和数据移动，时间复杂度较高。（插入或删除元素可能导致多个 entry 的 <code>prevlen</code> 字段扩展，触发连锁内存重分配（性能风险））</li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ziplist 头部结构定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zlentry</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlensize<span class="token punctuation">;</span> <span class="token comment">// 编码前一个节点长度所需的字节数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlen<span class="token punctuation">;</span>     <span class="token comment">// 前一个节点的实际长度</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lensize<span class="token punctuation">;</span>        <span class="token comment">// 编码当前节点长度所需的字节数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>            <span class="token comment">// 当前节点的实际长度</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> headersize<span class="token punctuation">;</span>     <span class="token comment">// 当前节点的头部大小（prevrawlensize + lensize）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> encoding<span class="token punctuation">;</span>      <span class="token comment">// 当前节点的编码方式</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>            <span class="token comment">// 指向当前节点的指针</span><span class="token punctuation">}</span> zlentry<span class="token punctuation">;</span><span class="token comment">// ziplist 整体结构定义</span><span class="token comment">// zlbytes: 记录整个压缩列表占用的内存字节数</span><span class="token comment">// zltail: 记录压缩列表表尾节点距离压缩列表起始地址的偏移量--O(1)复杂度内找到表尾节点，支持反向遍历</span><span class="token comment">// zllen: 记录压缩列表包含的节点（entry）数量</span><span class="token comment">// entry: 压缩列表中的每个节点，存储具体的数据元素--每个元素存储为 [prevlen][encoding][content]。</span><span class="token comment">// zlend: 一个特殊的结束标记，值为 0xFF</span><span class="token comment">// ziplist 内存布局（无显式结构体，通过字节操作）-- redis3.0  ziplist.c</span><span class="token comment">// &lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;...&lt;entry&gt;&lt;zlend&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="双向链表-早期使用"><a href="#双向链表-早期使用" class="headerlink" title="双向链表 早期使用"></a>双向链表 早期使用</h5><p>当列表元素较多或者元素占用空间较大时，Redis 会使用双向链表作为 <code>List</code> 的底层数据结构。双向链表在插入和删除元素时具有较好的性能。</p><ul><li><strong>内存不连续</strong>：每个节点独立分配内存，通过指针连接。意味着与压缩列表相比，⽆法很好利⽤ CPU 缓存</li><li><strong>操作高效</strong>：头尾插入/删除时间复杂度为 O(1)，但随机访问为 O(n)。</li><li><strong>内存开销大</strong>：每个节点需额外存储两个指针（每个指针占 8 字节）。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 数据结构定义（Redis 3.0，adlist.h）</span><span class="token comment">// 双向链表节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>  <span class="token comment">// 前驱节点指针</span>    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">// 后继节点指针</span>    <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>            <span class="token comment">// 存储的实际数据</span><span class="token punctuation">}</span> listNode<span class="token punctuation">;</span><span class="token comment">// 双向链表结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> <span class="token punctuation">{</span>    listNode <span class="token operator">*</span>head<span class="token punctuation">;</span>         <span class="token comment">// 头节点</span>    listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>         <span class="token comment">// 尾节点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>      <span class="token comment">// 链表长度（元素数量）</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 节点值复制函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 节点值释放函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 节点值比较函数</span><span class="token punctuation">}</span> list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="quicklist-新版"><a href="#quicklist-新版" class="headerlink" title="quicklist 新版"></a>quicklist 新版</h5><p>为了综合压缩列表和双向链表的优点，Redis 3.2 版本之后引入了快速列表作为 <code>List</code> 的底层实现。快速列表<strong>结合了压缩列表节省内存和双向链表插入删除高效</strong>的特点。</p><ul><li>快速列表是一个双向链表，链表中的**每个节点(quicklistNode)是一个压缩列表(ziplist)**。</li><li>当插入元素导致 ziplist 超过 <code>fill</code> 限制时，节点会分裂；删除元素可能导致相邻节点合并。</li><li><code>head</code> 和 <code>tail</code> 指针使得 LPUSH、RPUSH、LPOP、RPOP 的时间复杂度为 **O(1)**。通过 <code>prev</code> 和 <code>next</code> 指针支持双向遍历。</li><li>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// quicklist 结构（src/quicklist.h）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token punctuation">{</span>    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>        <span class="token comment">// 指向头节点的指针</span>    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>        <span class="token comment">// 指向尾节点的指针</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>        <span class="token comment">// 所有 ziplist 中的元素总数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>          <span class="token comment">// quicklist 的节点数量（即 ziplist 的数量）</span>    <span class="token keyword">int</span> fill <span class="token operator">:</span> QL_FILL_BITS<span class="token punctuation">;</span>    <span class="token comment">// 单个 ziplist 的最大容量限制（由 list-max-ziplist-size 配置）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">// 压缩深度（由 list-compress-depth 配置）</span><span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span><span class="token comment">// quicklist 节点结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span> <span class="token comment">// 前驱节点指针</span>    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 后继节点指针</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>          <span class="token comment">// 指向 ziplist 的指针（未压缩时）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>            <span class="token comment">// ziplist 的字节大小</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token comment">// ziplist 的元素数量</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 编码方式：RAW（原始 ziplist）或 LZF（压缩存储）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 容器类型（固定为 2，表示使用 ziplist）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 是否正在被解压</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 测试用</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> extra <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// 预留位</span><span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="hash底层"><a href="#hash底层" class="headerlink" title="hash底层"></a>hash底层</h4><h5 id="Ziplist-HashTable-早期"><a href="#Ziplist-HashTable-早期" class="headerlink" title="Ziplist+HashTable 早期"></a>Ziplist+HashTable 早期</h5><p>当哈希对象满足以下两个条件时，Redis 会使用压缩列表作为 <code>Hash</code> 的底层数据结构：</p><ul><li>哈希对象保存的<strong>所有</strong>键值对的<strong>键和值的字符串长度都小于 64 字节</strong>（可以通过 <code>hash-max-ziplist-value</code> 配置项进行修改）。</li><li>哈希对象保存的键值对<strong>数量小于 512 个</strong>（该阈值可以通过 <code>hash-max-ziplist-entries</code> 配置项进行修改）。</li></ul><blockquote><p>在压缩列表中，哈希对象的键值对是<strong>按顺序依次存储</strong>的。每个键值对由<strong>两个连续的节点</strong>表示，前一个节点存储键，后一个节点存储值。例如，对于哈希对象 <code>{"name": "John", "age": 30}</code>，在压缩列表中的存储顺序可能是：<code>"name", "John", "age", 30</code>。</p></blockquote><p>Ziplist 的每个元素（entry）由三部分组成：</p><pre class="line-numbers language-none"><code class="language-none">[prevlen][encoding][content]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**<code>prevlen</code>**：存储前一个元素的长度（支持反向遍历）。</li><li>**<code>encoding</code>**：当前元素的数据类型和长度。</li><li>**<code>content</code>**：实际数据。</li></ul><p>局限：</p><ul><li><strong>级联更新</strong>：插入或删除元素可能导致多个 entry 的 <code>prevlen</code> 字段扩展，触发连锁内存重分配（性能风险）。</li><li><strong>遍历效率低</strong>：查找<strong>特定键</strong>需要遍历整个 ziplist（时间复杂度 O(n)）。</li></ul><p>当哈希对象不满足使用压缩列表的条件时，Redis 会将底层数据结构转换为<strong>哈希表。</strong></p><ul><li><strong>渐进式 rehash</strong>：当哈希表需要扩容或缩容时，<strong>数据逐步迁移到新哈希表</strong>，避免一次性操作阻塞服务。</li><li><strong>高效随机访问</strong>：平均时间复杂度为 O(1)。</li><li><strong>链地址法解决冲突</strong>：哈希冲突时，通过链表将多个键值对连接在同一个桶中。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 哈希表结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{</span>    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>      <span class="token comment">// 哈希桶数组</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>      <span class="token comment">// 哈希表大小（桶的数量）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>  <span class="token comment">// 哈希掩码（用于计算索引，等于 size-1）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>      <span class="token comment">// 已使用的桶数量（键值对总数）</span><span class="token punctuation">}</span> dictht<span class="token punctuation">;</span><span class="token comment">// 字典结构（Redis 哈希的顶层结构）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>         <span class="token comment">// 类型特定函数（如哈希函数）</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>         <span class="token comment">// 私有数据</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">// 两个哈希表（用于渐进式 rehash）</span>    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span>         <span class="token comment">// rehash 进度索引（-1 表示未进行 rehash）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> iterators<span class="token punctuation">;</span> <span class="token comment">// 当前运行的迭代器数量</span><span class="token punctuation">}</span> dict<span class="token punctuation">;</span><span class="token comment">// 哈希表节点（键值对）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>              <span class="token comment">// 键</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>        <span class="token class-name">uint64_t</span> u64<span class="token punctuation">;</span>        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span>        <span class="token keyword">double</span> d<span class="token punctuation">;</span>    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>                    <span class="token comment">// 值</span>    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 指向下一个节点（解决哈希冲突）</span><span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://i-blog.csdnimg.cn/blog_migrate/4bf663222bb37404c915b58dec8e8cbd.png" alt="img" style="zoom: 67%;"><h5 id="listpack-HashTable-新版"><a href="#listpack-HashTable-新版" class="headerlink" title="listpack+HashTable 新版"></a>listpack+HashTable 新版</h5><p>在 Redis 的最新版本（如 <strong>7.0 及以上</strong>）中，<strong>listpack</strong> 已逐步替代 <strong>ziplist</strong>，成为某些数据结构的底层实现，以解决 ziplist 的级联更新问题，并提升内存效率和操作性能。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// listpack 内存布局（源码：listpack.c）</span><span class="token comment">// &lt;总字节数&gt;&lt;元素数量&gt;&lt;element&gt;...&lt;element&gt;&lt;结束符&gt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">lpInsert</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>lp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> size<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> where<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 计算新元素所需内存</span>    <span class="token class-name">uint32_t</span> poff <span class="token operator">=</span> p <span class="token operator">?</span> p <span class="token operator">-</span> lp <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> enclen <span class="token operator">=</span> <span class="token function">lpEncodeGetType</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>enctype<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> backlen_size <span class="token operator">=</span> <span class="token function">lpEncodeBacklen</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> enclen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> old_listpack_bytes <span class="token operator">=</span> <span class="token function">lpGetTotalBytes</span><span class="token punctuation">(</span>lp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> new_elements <span class="token operator">=</span> <span class="token function">lpGetNumElements</span><span class="token punctuation">(</span>lp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 分配新内存并插入元素</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>newlp <span class="token operator">=</span> <span class="token function">lp_realloc</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> old_listpack_bytes <span class="token operator">+</span> enclen <span class="token operator">+</span> backlen_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新元素位置和元数据...</span>    <span class="token keyword">return</span> newlp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>总字节数（4 Bytes）</strong>：整个 listpack 占用的内存大小。</li><li><strong>元素数量（2 Bytes）</strong>：元素个数（若超过 65535，需遍历统计）。</li><li><strong>元素（element）</strong>：每个元素独立编码，格式为 <code>[编码类型][数据内容][元素长度]</code>。</li><li><strong>结束符（1 Byte）</strong>：固定值 <code>0xFF</code>。</li></ul><blockquote><p>每个元素（entry）的元数据（如长度）存储在其自身末尾，而非依赖前驱节点，<strong>彻底消除了级联更新</strong>的可能性。<strong>级联更新（Cascade Update）</strong> 指的是在数据结构中，修改一个元素可能导致后续多个元素的内存布局被迫调整，从而引发连锁反应。</p><p>例如，插入新元素时，仅需修改自身及后续元素的长度字段，无需回溯前驱节点。</p></blockquote><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>Listpack</strong></th><th align="left"><strong>Ziplist</strong></th></tr></thead><tbody><tr><td align="left"><strong>级联更新</strong></td><td align="left"><strong>无</strong>（长度信息存储在自身末尾）</td><td align="left">有（依赖前驱节点的 <code>prevlen</code> 字段）</td></tr><tr><td align="left"><strong>内存连续性</strong></td><td align="left">连续内存块</td><td align="left">连续内存块</td></tr><tr><td align="left"><strong>插入/删除性能</strong></td><td align="left">稳定 O(n)</td><td align="left">最坏 O(n²)（级联更新时）</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">高频插入、删除的紧凑数据</td><td align="left">已逐步被 listpack 替代</td></tr></tbody></table><p>消除级联更新的本质：</p><ul><li><strong>解耦元素长度依赖</strong>：每个元素的长度信息仅影响自身，不依赖前驱或后继元素。</li><li><strong>内存操作局部化</strong>：插入或删除操作仅需处理当前元素及后续元素的位置，不触发连锁更新。</li></ul><h4 id="Set底层"><a href="#Set底层" class="headerlink" title="Set底层"></a>Set底层</h4><p>Redis 的集合（Set）底层数据结构根据元素类型和数量动态选择 <strong>intset（整数集合）</strong> 或 <strong>hashtable（哈希表）</strong>，以优化内存和性能。</p><p>在redis.conf中配置<code>set-max-intset-entries 512</code>，表示<strong>当元素数量&lt;=512且所有元素为整数</strong>时，使用intset。</p><ul><li><strong>小规模整数集合</strong>：使用 <code>intset</code>（内存紧凑，连续存储）。</li><li><strong>其他情况</strong>：使用 <code>hashtable</code>（支持任意类型元素，高效随机访问）。</li></ul><h5 id="intset-整数集合"><a href="#intset-整数集合" class="headerlink" title="intset 整数集合"></a>intset 整数集合</h5><p>intset是一个由整数组成的有序集合，可以进行二分查找。整数集合在存储整数值的过程中，会根据需要动态调整存储空间，避免了固定大小数组可能带来的空间浪费或溢出问题。用途：用于<strong>存储用户 ID、商品 ID</strong> 等。由于其高效的存储方式和快速的查找性能，使得整数集合成为了处理<strong>整数集合类数据</strong>的首选数据结构之一。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">intset</span> <span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> encoding<span class="token punctuation">;</span>  <span class="token comment">// 编码类型（INTSET_ENC_INT16/32/64）</span>    <span class="token class-name">uint32_t</span> length<span class="token punctuation">;</span>    <span class="token comment">// 元素数量</span>    <span class="token class-name">int8_t</span> contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 实际存储元素的数组</span><span class="token punctuation">}</span> intset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>内存连续</strong>：元素按升序存储在 <code>contents</code> 数组中，无指针开销。</li><li><strong>编码升级</strong>：插入新元素时，若超出当前编码范围（例如插入 <code>int32</code> 到 <code>int16</code> 集合），自动升级编码并重新分配内存。</li></ul><p>集合元素包含非整数或数量超过阈值时，使用与 Redis <strong>哈希类型相同的 <code>dict</code> 结构（</strong>源码：dict.h），但 <strong>值部分为 NULL</strong>（仅存储键）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>     <span class="token comment">// 类型特定函数</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 双哈希表（用于渐进式 rehash）</span>    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span> dict<span class="token punctuation">;</span><span class="token comment">// 哈希表节点（仅存储键）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>          <span class="token comment">// 集合元素（值存储在 key 字段）</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span> v<span class="token punctuation">;</span>    <span class="token comment">// 值字段未被使用（设为 NULL）</span>    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SortedSet底层"><a href="#SortedSet底层" class="headerlink" title="SortedSet底层"></a>SortedSet底层</h4><p>zset中的**每个元素包含数据本身和一个对应的分数(score)**。经典例子：一个zset的key是”math”，代表数学课的成绩，然后可以往这个key里插入很多数据。输入数据的时候，每次需要输入一个姓名和一个对应的成绩。那么这个姓名就是数据本身，成绩就是它的score。</p><p>zset的数据本身不允许重复，但是score允许重复。</p><p>zset底层实现原理：</p><ul><li>数据少时，使用ziplist：ziplist占用连续内存，<strong>每项元素都是（数据+score）的方式连续存储，按照score从小到大排序</strong>。ziplist为了节省内存，每个元素占用的空间可以不同，对于大的数据（long long），就多用一些字节来存储，而对于小的数据（short），就少用一些字节来存储。因此查找的时候需要按顺序遍历。ziplist省内存但是查找效率低。<ul><li>在有序集合<strong>元素小于 64 字节且个数小于 128</strong> 的时候，会使用 ziplist。</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">zset<span class="token operator">-</span>max<span class="token operator">-</span>listpack<span class="token operator">-</span>entries <span class="token number">128</span>  # 元素数量 ≤ <span class="token number">128</span> 时，使用 listpack（Redis <span class="token number">7.0</span><span class="token operator">+</span>）zset<span class="token operator">-</span>max<span class="token operator">-</span>listpack<span class="token operator">-</span>value <span class="token number">64</span>     # 元素值长度 ≤ <span class="token number">64</span> 字节时，使用 listpack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>数据多时，使用字典+跳表。<strong>字典用来根据数据查score，跳表用来根据score查找数据（查找效率高）。</strong>成员和分值在跳表和字典中各存一份，以空间换时间。</li></ul><img src="https://i-blog.csdnimg.cn/blog_migrate/d28bf11bb5b5e2d9957c316d6c7f2b8b.png" alt="img" style="zoom: 67%;"><h5 id="dict哈希字典-skiplist跳表"><a href="#dict哈希字典-skiplist跳表" class="headerlink" title="dict哈希字典+skiplist跳表"></a>dict哈希字典+skiplist跳表</h5><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005436.png" alt="img" style="zoom:80%;"><p>跳跃表是一种随机化的数据结构，它通过在每个节点中维护多个指向其他节点的指针，从而实现快速的查找、插入和删除操作。跳跃表的平均时间复杂度为O(log n) ，与平衡二叉树相当，但实现起来更加简单。</p><ul><li><strong>多层结构</strong>：跳跃表由多个层（level）组成，每层都是一个有序的链表。最底层的链表包含了所有的元素，而<strong>上面的层则是下面层的索引</strong>。通过这种分层的结构，查找元素时可以从高层开始快速定位到大致的位置，然后再逐层向下查找，降低了查找的时间复杂度。</li><li><strong>随机层数</strong>：<strong>每个节点的层数是随机确定的</strong>，通常是通过一个随机函数来决定。这样可以保证跳跃表的平衡性，避免出现极端情况下的性能下降。</li><li><strong>分数有序</strong>：跳跃表中的节点按照分数从小到大排序，如果分数相同，则按照元素的字典序排序。这种排序方式使得有序集合可以方便地进行范围查找，如根据分数范围获取元素。</li></ul><blockquote><p>时间复杂度：时间复杂度 = 索引的层数 * 每层索引遍历元素的个数。</p><p>首先看索引层数，假设每两个节点抽一个出来作为上一级索引的结点，而且最高一级索引有3个节点，则索引层数为log2(n)。</p><p>然后看每层遍历多少个元素，首先最高层最多遍历3个节点，就能往下走了，同理，次高层也最多遍历三个节点，就能往下走。取平均之后，可以认为每层遍历2个节点。</p><p>因此时间复杂度=2log2(n)，同理，如果是每k个节点取一个索引的话，就是klogk(n)</p><p>空间复杂度：也是以每两个节点取一个索引为例，第一层n个节点，第二层n/2，第三次n/4，等比序列求和，或者取极限，可以认为索引节点数量无限接近于n，所以空间复杂度为O(n)。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 有序集合结构（源码：server.h）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">{</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>          <span class="token comment">// 字典（和哈希结构里的dict一样）：存储 member -&gt; score 的映射（O(1) 查找）</span>    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>      <span class="token comment">// 跳表：按分值排序，支持范围操作</span><span class="token punctuation">}</span> zset<span class="token punctuation">;</span><span class="token comment">// 跳表节点（源码：server.h）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{</span>    sds ele<span class="token punctuation">;</span>                         <span class="token comment">// 成员（member）</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span>                    <span class="token comment">// 分值（score）</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>  <span class="token comment">// 后向指针（双向链表）</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>  <span class="token comment">// 前向指针</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> span<span class="token punctuation">;</span>             <span class="token comment">// 跨度（用于计算排名）</span>    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                          <span class="token comment">// 多层索引：从原始节点逐层往上记录其后继元素（即forward）</span><span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span><span class="token comment">// 跳表结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>  <span class="token comment">// 头尾节点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>                 <span class="token comment">// 元素数量</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span>                            <span class="token comment">// 最大层数</span><span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Redis 跳表的特点</strong>：</p><ol><li>采用<strong>双向链表</strong>，存在一个回退指针。主要用于简化操作，例如删除某个元素时，还需要找到该元素的前驱节点，使用回退指针会非常方便。</li><li><code>score</code> 值可以重复，如果 <code>score</code> 值一样，则按照 ele（节点存储的值，为 sds）字典排序</li><li>Redis 跳跃表默认允许最大的层数是 32，被源码中 <code>ZSKIPLIST_MAXLEVEL</code> 定义。</li></ol><p><strong>插入（平均 O(logn)：依赖跳表的多层索引，快速跳过无关节点）：</strong></p><p>1.<strong>计算随机层数</strong>：生成新节点的层数 <code>level</code>（1~32），遵循 <strong>幂次定律</strong>（越高层数概率越小）。</p><p>2.<strong>查找插入位置</strong>：从跳表的最高层开始，向右遍历，找到每一层中最后一个 <strong>小于新节点分值</strong> 的节点（或同分值但成员字典序较小的节点），记录到 <code>update</code> 数组中。</p><p>3.<strong>创建新节点</strong>：分配内存，存储 <code>member</code> 和 <code>score</code>，并初始化各层的 <code>forward</code> 指针。</p><p>4.<strong>调整指针和跨度</strong>：基于update数组将新节点的各层 <code>forward</code> 指针指向后续节点，并更新前驱节点的 <code>forward</code> 指针指向新节点。更新各层的 <strong>跨度（span）</strong>，维护后续节点的排名信息。</p><p>5.<strong>更新跳表元数据</strong>：如果新节点的层数超过当前跳表的最大层数，更新跳表的 <code>level</code> 字段。更新跳表长度 <code>length</code>。</p><p><strong>删除（O(logn)）：</strong></p><p>1.<strong>查找待删除节点</strong>：从最高层开始遍历，记录每层中 <strong>可能指向待删除节点</strong> 的<strong>前驱节点</strong>到 <code>update</code> 数组。</p><p>2.<strong>验证节点存在性</strong>：检查找到的节点是否匹配 <code>member</code> 和 <code>score</code>（避免哈希冲突误删）。</p><p>3.<strong>调整指针和跨度</strong>：遍历各层，将前驱节点的 <code>forward</code> 指针指向待删除节点的后续节点。更新各层的 <strong>跨度（span）</strong>，减去被删除节点的跨度值。</p><p>4.<strong>释放内存</strong>：释放节点内存，并更新跳表长度 <code>length</code>。如果删除的是头节点或尾节点，更新跳表的 <code>header</code> 或 <code>tail</code> 指针。</p><p><strong>按成员查询分值（ZSCORE）</strong>：直接通过哈希表。ZSET 的 dict 哈希表存储了 member -&gt; score 的映射，时间复杂度 O(1)。</p><p><strong>查询–按分值的范围查询（ZRANGE）：</strong></p><p>1.<strong>定位起始节点</strong>：从跳表的最高层开始，向右遍历找到 <strong>第一个 ≥ 最小分值</strong> 的节点。</p><p>2.<strong>遍历链表</strong>：从起始节点开始，沿底层（<code>level[0]</code>）指针向右遍历，直到节点分值超过最大分值。收集遍历路径上的所有节点。</p><p><strong>按排名查询（ZRANK/ZREVRANK）</strong>：<strong>利用跨度（span）字段</strong>：在查找节点的过程中，累加各层的跨度值，得到节点的排名。</p><h3 id="为什么ZSet底层用跳表"><a href="#为什么ZSet底层用跳表" class="headerlink" title="为什么ZSet底层用跳表"></a>为什么ZSet底层用跳表</h3><p>Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？</p><p>与平衡树相比</p><ul><li>平衡树我们又会称之为 <strong>AVL 树</strong>，是一个严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过 1，即平衡因子为范围为 <code>[-1,1]</code>）。平衡树的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong> 。</li><li>对于范围查询来说，它也可以通过中序遍历的方式达到和跳表一样的效果。但是它的<strong>每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡</strong>，这个过程是比较耗时的。</li><li>跳表是一种可以用来代替平衡树的数据结构。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</li></ul><p>与红黑树相比：</p><ul><li><p>红黑树（Red Black Tree）也是一种自平衡二叉查找树，它的查询性能略微逊色于 AVL 树，但插入和删除效率更高。红黑树的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong> 。</p></li><li><p>按照<strong>区间查找</strong>数据这个操作，红黑树的效率没有跳表高。跳表可以<strong>定位区间的起点，然后在原始链表中顺序向后</strong>查询就可以了。</p></li><li><p>相比于红黑树，跳表还具有代码更容易实现、可读性好、不容易出错、更加灵活等优点。</p></li><li><p>插入、删除时跳表只需要调整少数几个节点，红黑树需要<strong>颜色重涂和旋转</strong>，开销较大。（比起AVL要好一点）</p></li></ul><p>与B+树相比：</p><ul><li><strong>节省内存</strong>：B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到<strong>尽可能多的索引</strong>来获得查询数据。对于 Redis 这种内存数据库来说，它对这些并不感冒，因为 Redis 作为内存数据库它不可能存储大量的数据，所以<strong>对于索引不需要通过 B+树这种方式进行维护</strong>，只需按照概率进行随机维护即可，<strong>节约内存</strong>。</li><li><strong>简单好用，容易实现</strong>：而且使用跳表实现 zset 时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，也<strong>不需要像 B+树那样插入时发现失衡时还需要对节点分裂与合并</strong>。</li></ul><h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><p>Redis 的线程模型是其高性能设计的核心，其核心思想是 <strong>单线程处理命令 + 多线程辅助任务</strong>。</p><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p><ul><li><p>单线程主逻辑：所有<strong>客户端命令的执行</strong>（如 GET、SET、INCR 等）由 <strong>单个主线程</strong> 顺序处理。</p><ul><li><strong>避免多线程竞争锁</strong>的开销，简化实现。天然保证操作的<strong>原子性</strong>，无需考虑并发问题。基于<strong>事件循环（Event Loop）和 I/O 多路复用（如 epoll）</strong>实现高并发。</li></ul></li><li><p>多线程辅助任务：<strong>后台异步任务</strong>：如持久化（RDB/AOF）、大键删除（UNLINK）、网络 I/O（Redis 6.0+）等，由后台线程处理。</p><ul><li>避免主线程阻塞，保持低延迟。充分利用多核CPU资源。</li><li><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</li></ul></li></ul><p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>Redis 通过<strong>过期字典</strong>（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的<strong>值是一个 long long 类型的整数</strong>，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><ul><li><strong>缓解内存的消耗</strong>：如果不设置TTL，内存占用会不断增长，可能导致OOM。设置TTL可以自动删除暂时不需要的数据，腾出空间；</li><li><strong>临时数据存储</strong>：部分业务场景下数据只在一段时间内有效，如短信验证码，用户登录token。</li></ul><p>过期字典是存储在 redisDb 这个结构里的。在查询一个 key 的时候，Redis 首先检查该 key 是否存在于过期字典中（时间复杂度为 O(1)），如果不在就直接返回，在的话需要判断一下这个 key 是否过期，过期直接删除 key 然后返回 null。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>     <span class="token comment">//数据库键空间,保存着数据库中所有键值对</span>    dict <span class="token operator">*</span>expires   <span class="token comment">// 过期字典,保存着键的过期时间</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-expired-dictionary.png" alt="Redis 过期字典" style="zoom: 33%;"><p><strong>过期删除策略</strong></p><p>常用的过期数据的删除策略就下面这几种：</p><ol><li><strong>惰性删除</strong>：只会在取出/查询 key 的时候才对数据进行过期检查。这种方式<strong>对 CPU 最友好</strong>，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong>：<strong>周期性地随机</strong>从设置了过期时间的 key 中<strong>抽查</strong>一批，然后逐个检查这些 key 是否过期，过期就删除 key。相比于惰性删除，定期删除<strong>对内存更友好</strong>，对 CPU 不太友好。</li><li><strong>延迟队列</strong>：把设置过期时间的 key 放到一个延迟队列里，到期之后就删除 key。这种方式可以保证每个过期 key 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。</li><li><strong>定时删除</strong>：每个设置了过期时间的 key 都会在设置的时间到达时立即被删除。这种方法可以确保内存中不会有过期的键，但是它对 CPU 的压力最大，因为它需要<strong>为每个键都设置一个定时器</strong>。</li></ol><p>Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 结合的策略，这也是大部分缓存框架的选择。定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，结合起来使用既能兼顾 CPU 友好，又能兼顾内存友好。</p><p>Redis 的定期删除过程是随机的（周期性地随机从设置了过期时间的 key 中抽查一批），所以并不保证所有过期键都会被立即删除。这也就解释了为什么有的 key 过期了，并没有被删除。并且，Redis 底层会通过<strong>限制删除操作执行的时长和频率来减少删除操作对 CPU 时间</strong>的影响。</p><p>另外，定期删除还会受到执行时间和过期 key 的比例的影响：</p><ul><li>执行时间已经超过了阈值，那么就<strong>中断</strong>这一次定期删除循环，以<strong>避免使用过多的 CPU 时间。</strong></li><li>如果这一批过期的 key 比例超过一个比例，就会重复执行此删除流程，以更积极地清理过期 key。相应地，如果<strong>过期的 key 比例低于这个比例，就会中断这一次定期删除循环</strong>，避免做过多的工作而获得很少的内存回收。</li></ul><p><code>expire.c</code>中定义了每次随机抽查的数量，Redis 7.2 版本为 20 ，也就是说每次会随机选择 20 个设置了过期时间的 key 判断是否过期。定期删除的频率是由 <strong>hz</strong> 参数控制的。hz 默认为 10，代表每秒执行 10 次，也就是每秒钟进行 10 次尝试来查找并删除过期的 key。hz 的取值范围为 1~500。增大 hz 参数的值会提升定期删除的频率。<strong>如果你想要更频繁地执行定期删除任务，可以适当增加 hz 的值，但这会加 CPU 的使用率。</strong>根据 Redis 官方建议，hz 的值不建议超过 100</p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>Redis 的内存淘汰策略只有在<strong>运行内存达到了配置的最大内存阈值</strong>时才会触发，这个阈值是通过<code>redis.conf</code>的<code>maxmemory</code>参数来定义的。64 位操作系统下，<code>maxmemory</code> 默认为 0 ，表示不限制内存大小。32 位操作系统下，默认的最大内存值是 3GB。</p><p>Redis 提供了 6 种内存淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li><li><strong>allkeys-lru（least recently used）</strong>：从数据集（<code>server.db[i].dict</code>）中移除最近最少使用的数据淘汰。</li><li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li><li><strong>no-eviction</strong>（默认内存淘汰策略）：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu（least frequently used）</strong>：从数据集（<code>server.db[i].dict</code>）中移除最不经常使用的数据淘汰。</li></ol><p><code>allkeys-xxx</code> 表示从所有的键值中淘汰数据，而 <code>volatile-xxx</code> 表示从设置了过期时间的键值中淘汰数据。</p><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis 事务提供了一种<strong>将多个命令请求打包</strong>的功能。然后，再<strong>按顺序执行打包</strong>的所有命令，并且<strong>不会被中途打断</strong>（满足隔离性）。</p><ul><li><strong>原子操作，不满足原子性</strong>：事务内的命令按顺序执行，但 <strong>不支持回滚</strong>（若某个命令失败，<strong>后续命令仍会执行</strong>）。</li><li><strong>满足隔离性</strong>：事务执行期间不会被其他客户端命令打断。</li><li><strong>不满足一致性</strong>：执行事务前后数据不一定一致，命令可能部分成功。</li><li><strong>持久性</strong>：Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式：快照（snapshotting，RDB）、只追加文件（append-only file, AOF）、RDB 和 AOF 的混合持久化(Redis 4.0 新增)。AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。<strong>always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</strong>因此，Redis 事务的持久性也是没办法保证的。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">MULTISET key1 value1SET key2 value2EXEC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Redis 事务实际开发中<strong>使用的非常少</strong>。除了不满足原子性和持久性之外，<strong>事务中的每条命令都会与 Redis 服务器进行网络交互</strong>（性能较差），这是比较浪费资源的行为。<strong>Redis 事务是不建议在日常开发中使用的。</strong></p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis的读写操作都是在内存中，所以Redis性能才会高，但是当Redis重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在Redis重启就能够从磁盘中恢复原有的数据。Redis共有三种数据持久化的方式：</p><ul><li><strong>AOF日志：</strong>每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里;</li><li><strong>RDB快照：</strong>将某一时刻的内存数据，以二进制的方式写入磁盘；</li></ul><h4 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h4><p><strong>AOF（Append-Only File）</strong>：Redis在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后Redis重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p><img src="https://cdn.xiaolincoding.com//picgo/1719110103188-58f6e37a-6bf9-41a5-9209-7683b21b6b04.webp" alt="img" style="zoom:50%;"><p>AOF 提供了三种同步策略（通过 <code>appendfsync</code> 配置）：</p><ul><li><strong>always</strong>：每次写操作都同步到磁盘，数据安全性最高，但性能最差。</li><li><strong>everysec</strong>：每秒同步一次，性能和安全性平衡（默认配置）。</li><li><strong>no</strong>：由操作系统决定何时同步，性能最好，但数据丢失风险最高。</li></ul><p>优点：</p><ul><li><strong>数据安全性高</strong>：AOF 可以做到秒级数据持久化，数据丢失风险低。即使文件损坏，还提供了redis-check-aof工具修复。</li><li><strong>可读性强</strong>：AOF 文件是文本文件，记录了所有写操作，便于分析和修复。</li></ul><p>缺点：</p><ul><li><strong>文件体积大</strong>：AOF 文件通常比 RDB 文件大（记录了每一个写操作）。</li><li><strong>性能影响</strong>：频繁的磁盘IO操作（特别是always同步策略）影响Redis的写入性能。</li><li><strong>恢复速度慢</strong>：AOF 文件需要逐条执行命令来恢复数据，速度较慢。</li></ul><h4 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h4><p><strong>RDB（Redis Database）</strong>：RDB 是 Redis 默认的持久化方式，它通过生成数据快照（Snapshot）将内存中的数据保存到磁盘上的二进制文件（<code>.rdb</code> 文件）中。</p><p>优点：</p><ul><li><strong>性能高</strong>：RDB 文件是紧凑的二进制文件，恢复速度快。</li><li><strong>适合备份</strong>：可以定期生成 RDB 文件，用于数据备份和灾难恢复。</li><li><strong>文件体积小</strong>：相比 AOF，RDB 文件占用的磁盘空间更小。</li></ul><p>缺点：</p><ul><li><strong>数据丢失风险、数据不一致</strong>：如果 Redis 崩溃，最后一次快照之后的数据会丢失。</li><li><strong>不适合实时持久化</strong>：RDB 是定时快照，无法做到秒级数据持久化。</li></ul><h3 id="Redis性能优化"><a href="#Redis性能优化" class="headerlink" title="Redis性能优化"></a>Redis性能优化</h3><h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p><p><strong>原生批量操作</strong>：mget，mset，hmget，sadd……单条批量命令本身是原子的。<strong>分片集群方案下，存在问题</strong>–<code>MGET</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>MGET</code>可能<strong>还是需要多次网络传输</strong>，原子操作也无法保证。</p><p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p><ol><li>找到 key 对应的所有 hash slot；</li><li><strong>分别</strong>向对应的 Redis 节点发起 <code>MGET</code> 请求获取数据；</li><li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li></ol><blockquote><p>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公式找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p></blockquote><p><strong>pipeline</strong>：对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令<strong>封装成一组</strong>，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。</p><ul><li><p>与原生操作对比：原生批量操作命令是原子操作，<strong>pipeline 是非原子操作</strong>（命令逐个执行）。pipeline 可以打包不同的命令，原生批量操作命令不可以。原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</p></li><li><p>与事务对比：事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。<strong>Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次</strong>，请求次数更少。</p><ul><li>事务可以看作原子操作，但并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰。</li></ul></li></ul><p><strong>Lua脚本</strong>：它的功能和事务非常类似。我们可以利用 Lua 脚本来<strong>批量执行多条 Redis 命令</strong>，一段 Lua 脚本可以视作一条命令执行，<strong>一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行</strong>，保证了操作不会被其他指令插入或打扰。支持复杂逻辑（条件判断、循环、组合多命令）。</p><ul><li>如果 Lua 脚本运行时出错并中途结束，后续命令是不会被执行的（和事务对比！！）。并且，出错之前执行的命令是无法被撤销的。因此， 严格来说的话，<strong>通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></li></ul><p>Redis 7.0 新增了 Redis functions 特性，可以看作是比 Lua 更强大的脚本。</p><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>事务</strong></th><th align="left"><strong>原生批量操作</strong></th><th align="left"><strong>Pipeline</strong></th><th align="left"><strong>Lua 脚本</strong></th></tr></thead><tbody><tr><td align="left"><strong>原子性</strong></td><td align="left">部分（无回滚）</td><td align="left">单命令原子</td><td align="left">无</td><td align="left">全原子</td></tr><tr><td align="left"><strong>网络开销</strong></td><td align="left">高（多次往返）</td><td align="left">低（单次往返）</td><td align="left">低（单次往返）</td><td align="left">低（单次往返）</td></tr><tr><td align="left"><strong>灵活性</strong></td><td align="left">低（仅顺序执行）</td><td align="left">低（固定命令）</td><td align="left">高（任意命令组合）</td><td align="left">高（支持复杂逻辑）</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">低</td><td align="left">最高</td><td align="left">高</td><td align="left">中（依赖脚本复杂度）</td></tr><tr><td align="left"><strong>错误处理</strong></td><td align="left">需手动处理</td><td align="left">自动回滚</td><td align="left">需解析响应</td><td align="left">脚本内处理</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">简单批量操作</td><td align="left">同类型数据批量处理</td><td align="left">高吞吐非原子操作</td><td align="left">复杂原子操作</td></tr></tbody></table><h4 id="Bigkey"><a href="#Bigkey" class="headerlink" title="Bigkey"></a>Bigkey</h4><p>单个 Key 的 Value 占用内存过大，或数据结构中元素过多。例如：</p><ul><li><strong>String 类型</strong>：Value 超过1MB。</li><li><strong>Hash/List/Set/ZSet</strong>：元素数量超过 1 万，或总内存超过 1MB。</li></ul><p>bigkey 通常是由于下面这些原因产生的：</p><ul><li>程序设计不当，比如直接使用 String 类型存储较大的文件对应的二进制数据。</li><li>对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。</li><li>未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。</li></ul><p>危害：</p><ol><li><strong>内存不均衡</strong>：导致集群数据倾斜，部分节点<strong>内存压力大</strong>。</li><li><strong>阻塞主线程</strong>：删除 BigKey 时可能触发内存回收阻塞（如删除大 Hash）。</li><li><strong>网络拥塞</strong>：序列化/反序列化耗时增加，影响吞吐量。</li><li><strong>持久化问题</strong>：<code>fork</code> 子进程生成 RDB 时，内存拷贝延迟高。</li></ol><p>检测方法：</p><ol><li><p><strong><code>redis-cli --bigkeys</code> 命令</strong>：<strong>缺点</strong>：线上慎用（全表扫描可能阻塞服务）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-cli <span class="token parameter variable">-h</span> <span class="token number">127.0</span>.0.1 <span class="token parameter variable">-p</span> <span class="token number">6379</span> <span class="token parameter variable">--bigkeys</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>自定义扫描（SCAN + 类型分析）</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 扫描 Hash 类型 Key 的元素数量</span>redis-cli <span class="token parameter variable">--scan</span> <span class="token parameter variable">--pattern</span> <span class="token string">'*'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-L</span> <span class="token number">1</span> redis-cli <span class="token builtin class-name">type</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token builtin class-name">hash</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-L</span> <span class="token number">1</span> redis-cli hlen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>监控工具</strong>：<strong>RedisInsight</strong>：可视化分析内存分布。<strong>监控报警</strong>：通过 <code>INFO memory</code> 观察内存波动。</p></li></ol><p>解决方案：</p><ol><li><strong>拆分 Key</strong>：将大 Hash 拆分为多个子 Hash（如 <code>user:1000:info</code> → <code>user:1000:base</code> + <code>user:1000:contact</code>）。</li><li><strong>使用合适的数据结构</strong>：替代大 String：使用 Hash 存储字段。替代大 List：分片为多个 List（如 <code>list:part1</code>、<code>list:part2</code>）。</li><li><strong>异步删除</strong>：使用 <code>UNLINK</code> 替代 <code>DEL</code>（Redis 4.0+）。</li><li><strong>设置 TTL</strong>：对非核心数据设置过期时间，避免长期驻留。</li></ol><h4 id="Hotkey"><a href="#Hotkey" class="headerlink" title="Hotkey"></a>Hotkey</h4><p>某个 Key 的访问频率远高于其他 Key（如每秒数万次读/写），通常出现在缓存击穿、高频计数器等场景。</p><p>危害：</p><ol><li><strong>单节点压力大</strong>：若 Key 集中在某一节点（如集群模式），导致 CPU 和网络过载。</li><li><strong>性能瓶颈</strong>：高并发访问可能触发连接数限制或线程阻塞。</li><li><strong>缓存击穿</strong>：热 Key 突然过期，大量请求直接穿透到数据库。</li></ol><p>检测方法：</p><ol><li><p><strong><code>redis-cli --hotkeys</code> 命令</strong>（需启用 LFU 策略）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 配置 LFU（redis.conf）</span>maxmemory-policy volatile-lfuredis-cli <span class="token parameter variable">--hotkeys</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>监控工具</strong>：<strong>Redis 监控系统</strong>（如 Prometheus + Grafana）：观察 QPS 分布。<strong>业务日志分析</strong>：统计高频访问的 Key。</p></li><li><p><strong>代理层统计</strong>：通过代理（如 Redis Cluster Proxy）记录 Key 访问频率。</p></li></ol><p>解决方案：</p><ol><li><strong>本地缓存</strong>：客户端缓存热 Key（如 Guava Cache），降低 Redis 压力。设置合理的本地缓存过期时间，避免数据不一致。</li><li><strong>分片打散</strong>：对热 Key 增加随机后缀（如 <code>hotkey:1234</code> → <code>hotkey:1234_{1..N}</code>），分散到多个 Key。</li><li><strong>读写分离</strong>：读操作分流到从节点（注意数据同步延迟）。</li><li><strong>使用 Redis 集群</strong>：通过集群模式分散热 Key 到不同节点（需确保 Hash Tag 合理）。</li></ol><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>执行时间超过阈值的命令（默认 10ms），常见于复杂操作或 BigKey 操作。</p><p>危害：</p><ol><li><strong>阻塞主线程</strong>：单线程模型下，慢查询会阻塞后续所有命令。</li><li><strong>超时风险</strong>：客户端等待响应时间过长，触发连接超时。</li><li><strong>资源消耗</strong>：长时间占用 CPU 和内存。</li></ol><p>检测方法：</p><ol><li><p><strong>慢查询日志</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 配置慢查询阈值（redis.conf）</span>slowlog-log-slower-than <span class="token number">10000</span>  <span class="token comment"># 单位微秒（默认 10ms）</span>slowlog-max-len <span class="token number">128</span>            <span class="token comment"># 最多记录 128 条慢查询</span><span class="token comment"># 查看慢查询日志</span>SLOWLOG GET <span class="token number">10</span>  <span class="token comment"># 获取最近 10 条慢查询</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>监控系统</strong>：通过 <code>INFO commandstats</code> 统计命令耗时。集成 APM 工具（如 SkyWalking）追踪 Redis 操作。</p></li></ol><p>常见慢查询场景：</p><ol><li><strong>大 Key 操作</strong>：<code>HGETALL</code> 大 Hash、<code>LRANGE</code> 大 List。</li><li><strong>复杂命令</strong>：<code>ZUNIONSTORE</code>、<code>SINTER</code> 等多集合操作。</li><li><strong>低效查询</strong>：<code>KEYS *</code>、<code>FLUSHALL</code>（阻塞式命令）。</li></ol><p>解决方案：</p><ol><li><strong>优化命令</strong>：使用 <code>SCAN</code> 替代 <code>KEYS</code>，<code>HSCAN</code> 替代 <code>HGETALL</code>。<strong>避免在循环中执行 Redis 命令。</strong></li><li><strong>拆分操作</strong>：将 <code>ZUNIONSTORE</code> 分批执行，或提前计算并缓存结果。</li><li><strong>使用 Pipeline/Lua 脚本</strong>：减少网络往返（但需控制脚本复杂度）。</li></ol><h3 id="生产问题"><a href="#生产问题" class="headerlink" title="生产问题"></a>生产问题</h3><h4 id="缓存穿透、击穿、雪崩"><a href="#缓存穿透、击穿、雪崩" class="headerlink" title="缓存穿透、击穿、雪崩"></a>缓存穿透、击穿、雪崩</h4><ul><li><p>穿透：大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。大量请求打到数据库。</p><ul><li>解决：做好参数校验，防止非法参数请求。缓存无效Key，缓解非法key变化不频繁的情况。布隆过滤器，请求值不存在直接返回参数错误。接口限流，根据用户或ip的异常频繁访问，采取黑名单机制。</li></ul></li><li><p>击穿：热点key<strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。导致瞬时大量请求打到数据库。</p><ul><li>解决：延长过期时间。提前预热（推荐）。互斥锁保证失效后只有一个请求去查询数据库并更新缓存。</li></ul></li><li><p>雪崩：多个缓存在同一时间大面积失效，导致大量请求落到数据库。</p><ul><li>解决：redis集群。多级缓存。随机失效时间。提前预热。持久缓存策略。</li></ul></li></ul><p>常见的缓存预热方式有两种：</p><ol><li>使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li><li>使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li></ol><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>1、先删除缓存，再更新数据库</p><p>如果删除了缓存更新数据库的操作没有成功，此时查询数据的请求会把旧数据存储到缓存中。</p><p>2、先更新数据库，再删除缓存。</p><ul><li><p>如果更新了数据库，删除缓存的操作失败了，此时查询数据的请求查到的数据仍然是旧数据。</p></li><li><p>线程A读取商品数据，刚好缓存失效了，去查询数据库数据，刚要执行放入redis缓存时，CPU发生上下文切换，线程A暂时得不到执行，此时线程B修改数据，执行update商品操作，然后删除缓存，线程A执行时，将之前查询到的旧的数据存到redis缓存中，此时就会出现redis和数据库的数据不一致的情况。</p></li></ul><p><a href="https://blog.csdn.net/oldboy1999/article/details/126180530">为什么是删除缓存而不是更新缓存？</a></p><p>3、延迟双删，先删除缓存、再更新数据库，再延迟一定的时间去删除缓存。</p><ul><li><p>为什么要两次删除缓存，因为有可能第一次删除缓存后其它查询请求将旧数据存储到了缓存。</p></li><li><p>为什么要延迟一定的时间去删除缓存，为了给mysql主向从同步的时间，如果立即删除缓存很可能其它请求读到的数据还是旧数据。</p></li><li><p>延迟的时间不好确定，延迟双删仍然可能导致脏数据。</p></li></ul><p><strong>所以结论：以上方案当存在高并发时都无法解决数据库和缓存强一致性的问题。</strong></p><p>如何做缓存一致性？需要根据需求来定：</p><p>1、<strong>实现强一致性 需要使用分布式锁控制</strong>，修改数据和向缓存存储数据使用同一个分布式锁。（数据修改的同时更新缓存-同一个事务）</p><p>2、实现最终一致性，缓存数据要加过期时间，即使出现数据不致性当过期时间一到缓存失效又会从数据库查询最新的数据存入缓存。</p><p>3、对于实时性要求强的，要实现数据强一致性要尽量避免使用缓存，可以直接操作数据库。</p><p>使用工具对数据进行同步方案如下：</p><p>1、使用任务表加任务调度的方案进行同步。</p><p>2、使用Canal基于MySQL的binlog进行同步。</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h4><p>主从同步是 Redis 实现 <strong>数据冗余</strong> 和 <strong>高可用性</strong> 的核心机制。通过将一台 Redis 服务器（主节点，Master）的数据复制到其他服务器（从节点，Replica），实现以下目标：</p><ul><li><strong>数据备份</strong>：从节点作为主节点的数据副本，防止数据丢失。</li><li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求，提升吞吐量。</li><li><strong>故障恢复</strong>：当主节点宕机时，从节点可提升为新的主节点，保障服务可用性。</li></ul><p>主从同步分为 <strong>全量同步（Full Sync）</strong> 和 <strong>增量同步（Partial Sync）</strong> 两种模式：</p><ul><li><p><strong>全量同步</strong>：发生在 初次同步/从服务器数据丢失/主服务器数据发生变化 这些情况下。流程如下：</p><img src="https://cdn.xiaolincoding.com//picgo/1720157699223-d4aa2235-35e2-42ec-84a8-522600f531c2.png" alt="img" style="zoom:50%;"><ol><li><strong>初次连接</strong>：从节点向主节点发送 <code>PSYNC</code> 命令请求同步。</li><li><strong>生成 RDB 快照</strong>：主节点执行 <code>BGSAVE</code> 生成当前数据的 RDB 文件。</li><li><strong>传输 RDB</strong>：主节点将 RDB 文件发送给从节点，从节点加载到内存。</li><li><strong>主节点缓存写命令</strong>：主节点在生成 RDB 期间，将新的写命令缓存到 <code>replication buffer</code>。</li><li><strong>同步增量数据</strong>：RDB 传输完成后，主节点将缓冲的写命令发送给从节点，确保数据一致性。</li></ol></li><li><p><strong>增量同步</strong><br>当从节点与主节点短暂断开后重新连接时，主节点仅发送<strong>断开期间缺失的写命令</strong>，依赖以下机制：</p><img src="https://cdn.xiaolincoding.com//picgo/1720157758362-f61b89b5-5194-4d63-8cbd-f00ca524a417.png" alt="img" style="zoom:67%;"><ul><li><strong>Replication ID</strong>：主节点的唯一标识，重启或切换主节点时会改变。</li><li><strong>Offset</strong>：记录主从节点的数据同步偏移量。若从节点的 Offset 仍在主节点的复制积压缓冲区（<code>repl_backlog</code>）范围内，则触发增量同步。</li></ul></li></ul><p>主要有三个步骤：</p><ul><li>从服务器在恢复网络后，会发送psync命令给主服务器，此时的psync命令里的offset参数不是-1;</li><li>主服务器收到该命令后，然后用CONTINUE响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li><li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li></ul><h5 id="增量数据"><a href="#增量数据" class="headerlink" title="增量数据"></a>增量数据</h5><p>在 Redis 的主从同步中，<strong>增量同步（Partial Sync）</strong> 是通过 <strong>复制偏移量（Replication Offset）</strong> 和 <strong>复制积压缓冲区（Replication Backlog）</strong> 来实现的。</p><p><strong>复制偏移量（Replication Offset）</strong></p><ul><li><strong>主节点</strong>：每次执行写操作后，会记录一个全局的复制偏移量（<code>master_repl_offset</code>），表示当前写操作的字节位置。</li><li><strong>从节点</strong>：从节点也会记录自己已经复制的偏移量（<code>slave_repl_offset</code>），表示从节点已经同步到主节点的哪个位置。</li></ul><p><strong>复制积压缓冲区（Replication Backlog）</strong></p><ul><li><strong>作用</strong>：主节点会将最近的写操作命令存储在一个固定大小的环形缓冲区（<code>repl_backlog</code>）中，用于支持增量同步。</li><li><strong>大小</strong>：通过 <code>repl-backlog-size</code> 参数配置，默认大小为 1MB。</li><li><strong>内容</strong>：缓冲区中存储的是写操作的字节流，而不是具体的命令。</li></ul><p><strong>复制 ID（Replication ID）</strong></p><ul><li><strong>作用</strong>：每个主节点都有一个唯一的复制 ID，用于标识主节点的复制流。</li><li><strong>变化</strong>：当主节点重启或发生主从切换时，复制 ID 会改变。</li></ul><p>增量同步的触发条件是：</p><ol><li><strong>从节点与主节点的复制 ID 一致</strong>：表示从节点之前是从该主节点同步的。</li><li><strong>从节点的复制偏移量仍在主节点的复制积压缓冲区范围内</strong>：即 <code>slave_repl_offset</code> 在 <code>master_repl_offset - repl_backlog_size</code> 到 <code>master_repl_offset</code> 之间。</li></ol><p>如果满足以上条件，主节点会从复制积压缓冲区中提取从节点缺失的数据，并发送给从节点。</p><ol><li><p><strong>从节点连接主节点</strong>：<br>从节点向主节点发送 <code>PSYNC</code> 命令，携带自己的复制 ID 和复制偏移量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token constant">PSYNC</span> <span class="token operator">&lt;</span>replication<span class="token operator">-</span>id<span class="token operator">&gt;</span> <span class="token generics"><span class="token punctuation">&lt;</span>offset<span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>主节点检查复制 ID 和偏移量</strong>：</p><ul><li>如果复制 ID 匹配且偏移量在复制积压缓冲区范围内，主节点回复 <code>+CONTINUE</code>，表示可以执行增量同步。</li><li>否则，主节点回复 <code>+FULLRESYNC</code>，表示需要执行全量同步。</li></ul></li><li><p><strong>主节点发送增量数据</strong>：</p><ul><li>主节点从复制积压缓冲区中提取从节点缺失的数据（从 <code>slave_repl_offset</code> 到 <code>master_repl_offset</code> 之间的数据）。</li><li>将这些数据以字节流的形式发送给从节点。</li></ul></li><li><p><strong>从节点应用增量数据</strong>：</p><ul><li>从节点接收到增量数据后，将其应用到自己的数据库中。</li><li>更新自己的复制偏移量（<code>slave_repl_offset</code>）。</li></ul></li></ol><h4 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h4><p>Redis 哨兵（Sentinel）是 Redis 官方提供的 <strong>高可用性（HA）解决方案</strong>，用于管理主从架构中的故障自动检测与恢复。通过哨兵机制，Redis 可以实现<strong>主节点的自动故障转移（Failover）</strong>、配置中心化和客户端服务发现。</p><img src="https://cdn.xiaolincoding.com//picgo/1720094217984-6192d46c-16ba-47d2-a58d-ee8ddb1d49de.png" alt="img" style="zoom: 33%;"><p>Redis在2.8版本以后提供的哨兵（Sentinel）机制，它的作用是实现主从节点故障转移。它会<strong>监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</strong></p><p>哨兵其实是一个运行在特殊模式下的Redis进程，所以它也是一个<strong>节点</strong>。从“哨兵”这个名字也可以看得出来，它相当于是“观察者节点”，观察的对象是主从节点。当然，它不仅仅是观察那么简单，在它观察到有异常的状况下，会做出一些”动作”，来修复异常状态。</p><p>哨兵节点主要负责三件事情：<strong>监控、选主、通知。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员redis：<a href="https://www.bilibili.com/video/BV1cr4y1671t/?p=16&amp;spm_id_from=pageDriver&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1cr4y1671t/?p=16&amp;spm_id_from=pageDriver&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>redis常用命令：<a href="https://blog.csdn.net/weixin_49851451/article/details/134311296">https://blog.csdn.net/weixin_49851451/article/details/134311296</a></p><p><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E8%AF%B4%E4%B8%80%E4%B8%8B-redis-%E5%92%8C-memcached-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9">Redis常见面试题总结(上) | JavaGuide</a></p><p>数据结构：<a href="https://blog.csdn.net/weixin_44772566/article/details/137008421">一文彻底搞懂Redis底层数据结构-CSDN博客</a> 博客部分内容有误，借鉴文字</p><p>图源：<a href="https://blog.csdn.net/weixin_41519463/article/details/109208476">redis的5种数据结构及其底层实现原理_redis5种数据类型对应底层结构-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UrbanGPT: Spatio-Temporal Large Language Models</title>
      <link href="/2024/04/30/urbangpt-spatio-temporal-large-language-models/"/>
      <url>/2024/04/30/urbangpt-spatio-temporal-large-language-models/</url>
      
        <content type="html"><![CDATA[<h1 id="UrbanGPT-Spatio-Temporal-Large-Language-Models"><a href="#UrbanGPT-Spatio-Temporal-Large-Language-Models" class="headerlink" title="UrbanGPT: Spatio-Temporal Large Language Models"></a>UrbanGPT: Spatio-Temporal Large Language Models</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><strong>时空预测旨在对不断变化的动态城市场景进行预测和洞察，涵盖了时间和空间两个维度。</strong>它的目的是预测城市生活的不同方面的未来模式、趋势和事件，包括交通运输、人口流动和犯罪率等。尽管大量研究都致力于开发神经网络技术来准确预测时空数据，但需要注意的是，<strong>许多方法严重依赖于有足够的标记数据来生成精确的时空表示</strong>。不幸的是，<strong>数据稀缺</strong>的问题在实际的城市感知场景中是普遍存在的。在某些情况下，从下游场景中收集任何标记数据变得具有挑战性，这进一步加剧了问题。因此，有必要建立一个时空模型，能够在不同的时空学习场景中表现出强大的泛化能力。</p><p>受大语言模型（LLMs）的显著成就的启发，我们的目标是<strong>创建一个时空LLM，能够在广泛的下游城市任务中表现出特殊的泛化能力。</strong>为了实现这一目标，我们提出了UrbanGPT，它无缝地<strong>集成了一个时空依赖编码器与指令微调范式</strong>。这种集成使llm能够理解复杂的时间和空间相互依赖，促进在数据稀缺下进行更全面和准确的预测。为了验证我们的方法的有效性，我们在各种公共数据集上进行了广泛的实验，包括不同的时空预测任务。结果一致表明，我们的UrbanGPT，以其精心设计的架构，始终优于最先进的基准模型。这些发现突出了为时空学习建立大型语言模型的潜力，特别是在标记数据稀缺的零样本场景中。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>时空预测的动机源于对准确预测和获取城市环境动态本质的渴望。通过对时间和空间上不断变化的动态进行分析和理解，时空预测使我们能够预测未来城市生活各个方面的模式、趋势以及各种事件。这在城市计算领域至关重要，因为预测交通模式可以优化交通流量、减少拥堵，增强整体城市流动性[17,30]。此外，预测人口流动有助于有效的城市规划和资源分配[6,19]。再者，预测犯罪的能力可以极大地提高公共安全[31]。时空预测在塑造更智能、更高效的城市方面扮演着关键角色，最终提升城市生活质量。</p><p>在时空预测领域常用的各种神经网络架构是十分重要的。这些架构旨在捕捉和建模数据中空间和时间维度之间复杂的关系。其中一种广泛采用的架构是卷积神经网络（CNN）[14, 38, 44]，它通过对输入数据应用卷积滤波器，可以有效地提取空间特征。另一类时空神经网络是循环神经网络（RNN）系列[1, 33, 42]。这些时空RNN非常适合通过维护一个可以随时间保留信息的记忆状态来实现时间依赖关系的捕捉。最近，图神经网络（GNNs）在时空预测中的应用急剧增加[35, 39, 46]。<strong>GNNs在建模数据中的复杂空间关系方面表现出色，其中每个节点对应一个空间位置，边捕捉它们之间的连接关系。</strong></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>挑战1：标注数据稀缺，数据无法迁移到新场景，重新训练开销巨大</strong>：虽然时空神经网络技术已被证明非常有效，但它们严重依赖于大量标记数据以生成准确的预测。实际城市场景中普遍存在数据稀缺问题，例如，由于成本高昂，在整个城市空间部署传感器来监控全市交通量或空气质量是不切实际的。此外，<strong>现有模型在应对新地区或城市预测任务时不具备良好的泛化能力，需重新训练以生成时空表征。</strong></p><p><strong>挑战2：LLMs和现有时空模型缺乏零样本场景下的泛化能力：</strong>如图1所示，大语言模型LLaMA可根据输入文本对流量模式进行推断。然而，它在处理具有复杂时空依赖性的<strong>数字时间序列数</strong>据方面的局限性有时会导致相反的预测结果。另一方面，预训练的基线模型能够很好地编码时空依赖关联。然而，<strong>它可能会由于对源数据集的过拟合导致其在零样本场景下表现不佳。</strong></p><p><strong>挑战3：如何将LLMs的出色推理能力扩展到时空预测场景</strong>：时空数据的独特特征与LLMs中所编码的知识之间存在差距，如何减少这一差距进而建立在广泛的城市任务中具有出色的泛化能力时空大语言模型是一项重大挑战。</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><p><strong>（1） 据我们所知，这是首次尝试</strong>开发一种能够在不同数据集上预测各种城市现象的时空大语言模型，尤其是在训练样本受限的情况下。</p><p><strong>（2）提出了时空预测模型UrbanGPT</strong>：我们提出了UrbanGPT，一种专门针对时空预测而定制的大型语言模型。UrbanGPT的核心是<strong>一种新的时空指令调整范式</strong>，它寻求将时间和空间的复杂依赖关系与llm的知识空间相结合。</p><ul><li>在我们的UrbanGPT框架中，我们首先合并了一个<strong>时空依赖编码器</strong>，它<strong>利用了一个多层的时间卷积网络以捕捉时间动态。</strong></li><li>然后，我们的模型涉及到<strong>对齐文本和时空信息</strong>，以使语言模型能够有效地注入时空上下文信号。这是通过使用一个<strong>轻量级对齐模块</strong>来实现的。其结果是，通过整合来自文本和时空领域的有价值的信息，生成更具表达性的语义表示</li><li><strong>通过将时空依赖编码器无缝集成到指令微调范式中，有效地将时空上下文与大语言模型相结合。</strong></li></ul><p>为了展示我们提出的模型的优越的预测性能，我们将其与大型语言模型（LLaMA- 70B）和时空图神经网络（STGCN）进行了比较。</p><ul><li>大型语言模型LLaMA可以从输入的文本中有效地推断出流量模式。然而，<strong>它在处理具有复杂时空依赖性的数字-时间序列数据方面具有局限性，有时会导致相反的交通趋势预测。</strong></li><li>另一方面，预先训练的基线模型显示了对时空依赖性的强烈理解。然而，<strong>它可能会对源数据集进行过拟合，并且在零样本场景下表现不佳，这表明它对现有时空预测模型的泛化能力有限</strong>。</li><li>相比之下，我们提出的模型实现了对特定领域的时空知识和语言建模能力的和谐集成。这使我们能够在数据匮乏的情况下做出更准确和可靠的预测</li></ul><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318132230618.png" alt="image-20240318132230618" style="zoom:80%;"><p>图1：与大型语言模型（LLaMA-70B）和时空图神经网络（STGCN）相比，该模型在零样本交通流预测场景中具有优越的预测性能。</p><p><strong>(3) 在现实世界数据上进行的大量实验</strong>证明了本文提出的UrbanGPT在零样本时空学习场景中具有出色的泛化能力。这些发现突显了该模型的强大泛化能力，表明它在准确预测和理解时空模式方面的有效性，即使在零样本场景下也是如此。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="时空数据-Spatio-Temporal-Data"><a href="#时空数据-Spatio-Temporal-Data" class="headerlink" title="时空数据 Spatio-Temporal Data."></a>时空数据 <strong>Spatio-Temporal Data</strong>.</h3><p><strong>时空数据</strong>可以表示为三维张量<strong>：X∈R^𝑅×𝑇×𝐹</strong>。张量中的每个元素<strong>X𝑟、𝑡、𝑓</strong>都对应于在第𝑟个区域的第𝑡个时间间隔上的第𝑓个特征的值。</p><ul><li>考虑预测一个城市地区的出租车交通模式。在这种情况下，数据可以表示从𝑡到𝑡−1的给定时间段（例如，30分钟的间隔）内，特定区域（例如，第𝑟个空间区域）内出租车的流入和流出。‘</li></ul><h3 id="时空预测-Spatio-Temporal-Forecasting"><a href="#时空预测-Spatio-Temporal-Forecasting" class="headerlink" title="时空预测 Spatio-Temporal Forecasting"></a>时空预测 <strong>Spatio-Temporal Forecasting</strong></h3><p><strong>时空预测</strong>：在时空预测任务中，一个常见的场景是利用历史数据来预测未来的趋势。具体来说，其目标是根据从前面的𝐻步骤中获得的信息来预测下一个𝑃时间步长的数据。</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318153916911.png" alt="image-20240318153916911"><p>函数𝑓（·）代表了一个利用历史数据进行有效训练的时空预测模型。时空预测任务主要可分为两大类：</p><ul><li><strong>回归预测</strong>，包括预测交通流量或出租车需求等连续值；</li><li><strong>分类预测</strong>，其目标是分类犯罪发生预测等事件。</li></ul><p>为了优化函数f，基于时空场景的具体特征使用了不同的损失函数</p><h3 id="时空零样本学习-Zero-Shot-Learning"><a href="#时空零样本学习-Zero-Shot-Learning" class="headerlink" title="时空零样本学习 Zero-Shot Learning"></a>时空零样本学习 <strong>Zero-Shot Learning</strong></h3><p>尽管目前的时空学习方法是有效的，但它们在有效地推广到各种下游时空学习场景时经常遇到困难。在本研究中，我们的重点是解决时空零样本场景的挑战，我们的目标是<strong>学习下游时空预测数据集或任务里没见过的数据</strong>。这可以正式定义如下：</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318155213668.png"><p>在这个特殊的场景中，预测函数𝑓ˆ（·）负责预测以前没有遇到过的下游任务的时空数据˜X。需要注意的是，模型𝑓ˆ（·）并不是针对目标数据进行专门训练的。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318210558121.png"><p>图2：所提出的时空语言模型UrbanGPT的总体架构。</p><h3 id="时空依赖编码器"><a href="#时空依赖编码器" class="headerlink" title="时空依赖编码器"></a>时空依赖编码器</h3><ul><li><p>集成一个包含多层次时间卷积网络（ a multi-level temporal convolutional network.）的时空编码器来增强大型语言模型在时空上下文中捕获时间依赖性的能力。</p></li><li><p>具体来说，我们的时空编码器由两个关键组件组成：<strong>门控扩散（空洞）卷积层（</strong>a gated dilated convolution layer ）和<strong>多层次关联注入层</strong>（a multi-level correlation injection layer）</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318201003133.png"></li><li><p>初始化时空嵌入：Er∈R^T×d。这种嵌入是通过一个线性层来增强原始数据X而获得的。</p></li><li><p>为了解决梯度消失的问题，我们使用了一个E𝑟切片，表示为Er‘，由扩张的卷积核的大小决定。<strong>该切片用于执行残差操作。</strong></p></li><li><p>使用<strong>一维扩散卷积核</strong>W¯k，<img src="https://latex.csdn.net/eq?%5Cbar%7B%5Ctextbf%7BW%7D%7D_g%5Cin%5Cmathbb%7BR%7D%5E%7BT_g%5Ctimes%20d_%7Bin%7D%5Ctimes%20d_%7Bout%7D%7D" alt="\bar{\textbf{W}}_g\in\mathbb{R}^{T_g\times d_{in}\times d_{out}}">编码时间关联，相应偏置项bk，bg属于R^dout。Sigmoid激活函数δ用于控制多层卷积运算的信息保留程度。在进行门控时间扩张卷积层编码后，我们能够有效地捕获<strong>多个时间步长中的时间依赖性</strong>，从而生成时间表示。</p></li><li><p><strong>这些表示包含不同级别的时间依赖关系</strong>，反映了各种具有粒度感知的<strong>时间演化模式</strong>。为了保留这些信息模式，我们引入了一个多层次关联注入层</p></li></ul><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318202940267.png"><ul><li>其中Ws∈R^Ts×dout×d′out是形如W¯k的卷积核，经过L层编码后，我们<strong>使用一个简单的非线性层融合门控扩散卷积层和多层次关联注入层的结果</strong>，<strong>最终的时空依赖性表征表示为</strong>Ψ~∈R^R×T×d</li><li>为了处理下游可能出现的各种城市场景集，本文提出的时空编码器在<strong>建模空间相关性时独立于图结构</strong>。因为在零样本预测环境中，实体之间的空间关系可能是未知的或难以确定的。通过不依赖于显式的图结构，我们的编码器可以有效地处理广泛的城市场景，在这些场景中，空间相关性和依赖性可能会发生变化，或者很难预先定义。这种灵活性使我们的模型能够适应并表现良好，确保其在广泛的城市环境中的适用性。</li></ul><h3 id="时空指令微调"><a href="#时空指令微调" class="headerlink" title="时空指令微调"></a>时空指令微调</h3><h4 id="时空文本对齐"><a href="#时空文本对齐" class="headerlink" title="时空文本对齐"></a>时空文本对齐</h4><ul><li>为了<strong>使语言模型能够有效地理解时空模式，对齐文本信息和时空信息是至关重要的。这种对齐允许融合不同模态，从而产生信息更丰富的表示</strong>。</li><li>通过整合来自文本和时空领域的上下文特征，我们可以<strong>捕获互补信息</strong>，提取更具表达力和意义的更高层次的语义表示。为了实现这一目标，我们使用了一个<strong>轻量级的对齐模块来投影时空依赖表示˜Ψ</strong>。这个投影涉及到使用线性层参数W𝑝∈R^𝑑×𝑑𝐿和b𝑝∈R^𝑑𝐿，其中𝑑𝐿表示语言模型（llm）中常用的隐藏维度。</li><li>所得到的投影，表示为H∈R^𝑅×𝐹×𝑑𝐿，在指令中使用特殊的标记表示为： <st_start>，<st_his>，…，<st_his>，<st_end>。在这里，<st_start>和<st_end>作为标识时空的开始和结束的标识符。<strong>这些标识符可以通过扩展其词汇量来包含在大语言模型中</strong>。占位符<st_his>表示时空标记，并<strong>对应于隐藏层中的投影H</strong>。通过使用该技术，该模型获得了<strong>识别时空依赖性</strong>的能力，从而提高了其在城市场景中成功执行时空预测任务的熟练程度。</st_his></st_end></st_start></st_end></st_his></st_his></st_start></li></ul><h4 id="时空提示词（prompt）指令"><a href="#时空提示词（prompt）指令" class="headerlink" title="时空提示词（prompt）指令"></a>时空提示词（prompt）指令</h4><ul><li><p>在时空预测的场景中，<strong>时间和空间信息都包含了有价值的语义细节</strong>，有助于模型理解特定上下文的时空模式。例如，清晨和高峰时间段的交通流量有很大的不同，并且商业区和住宅区之间的交通模式也存在差异。因此，<strong>将时间和空间信息表示为提示文本对时空预测任务是有益的</strong>。</p></li><li><p>我们利用大语言模型的文本理解能力来编码这些信息。在UrbanGPT框架中，我们<strong>集成了多粒度的时间信息和空间细节，作为大语言模型的指令输入</strong>。</p><ul><li>时间信息包括一周的日期和时间，一天的时间等因素。</li><li>而<strong>区域信息包括城市、行政区域和附近的兴趣点（POI）数据等</strong>，如图3所示。</li><li>通过合并这些不同的元素，UrbanGPT能够<strong>识别和理解复杂的时空环境下不同区域和时段的时空模式</strong>，从而增强其零样本推理能力。</li></ul></li></ul><p>时空信息指令文本的设计如图3所示。图3：编码时间和位置感知信息的时空提示指令的说明。</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318210901930.png"><h4 id="LLM的时空指令微调"><a href="#LLM的时空指令微调" class="headerlink" title="LLM的时空指令微调"></a>LLM的时空指令微调</h4><p>使用指令微调LLMs以生成文本格式的时空预测存在两个挑战。</p><ul><li>首先，<strong>时空预测通常依赖于数值数据，其结构和模式与语言模型擅长处理的自然语言不同，后者侧重于语义和句法关系</strong>。</li><li>其次，<strong>LLMs通常使用多分类损失进行预训练以预测词汇，从而得到潜在结果的概率分布。而回归任务则需要连续值分布。</strong><ul><li>也就是说llm是一个词一个词的预测，而回归任务需要直接得到一组连续的数值分布</li></ul></li></ul><p>为了解决这些挑战，UrbanGPT采用了一种不同的策略，===<strong>不直接预测未来的时空值，而是生成辅助预测过程的预测标记</strong>（token）===。</p><p><strong>这些标记随后通过回归层，将隐藏表示映射为生成更准确的预测值</strong>：</p><p><strong>（STLlama  409-433）</strong></p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318211556936.png"><p>预测结果，记为ˆY𝑟，𝑓∈R^𝑃，使用<strong>线性整流激活函数（ReLU），用𝜎表示</strong>。<strong>预测标记的隐藏表示，表示为Γ𝑟，𝑓∈R^𝑑𝐿</strong>，<strong>作为大型语言模型（LLMs）词汇表中的一个新术语被引入</strong>。回归层使用权重矩阵W1∈R𝑑‘×𝑑𝐿、W2∈R𝑑’×𝑑𝐿和W3∈R𝑃×2𝑑‘表示，其中[·，·]表示连接操作。**虽然预测token的概率分布保持相对稳定，但其隐藏的表征包含了丰富的时空上下文属性，从而捕获了动态的时空相互依赖性。这使得我们的模型能够通过利用这些上下文信息来提供精确的预测。</p><h3 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h3><ul><li>在基线模型[1,7]的基础上，我们采用<strong>绝对误差损失作为回归损失函数</strong>。这种选择使我们能够有效地处理各种城市场景中的预测。</li><li>此外，我们引入了一个分类损失作为一个联合损失，以满足不同的任务需求。</li><li>为了确保最佳的性能，我们的模型会<strong>根据特定的任务输入来优化不同的损失</strong>。例如，我们对交通流量预测等任务使用回归损失，而对犯罪预测等任务使用分类损失。这种方法使我们的模型能够有效地解决每个任务所带来的独特挑战</li></ul><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318224114032.png" alt="image-20240318224114032" style="zoom: 67%;"><p>这里，𝑦𝑖表示来自ˆY的一个样本，𝑁表示样本总数，计算为𝑅、𝑇和𝐹的乘积。我们在我们的模型中使用了各种损失函数，包括Lc–二元交叉熵损失；L𝑟表示回归损失，以及在我们的时空语言模型中采用的交叉熵损失。为了从预测中获取概率分布，我们使用了用𝛿表示的sigmoid激活函数。这些损失函数在我们的模型中都扮演着特定的角色，使我们能够根据需要有效地处理分类、回归和语言建模任务。</p><h3 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h3><p>超参数设置。时间编码器中膨胀卷积核的参数设置如下：𝑑𝑖𝑛、𝑑𝑜𝑢𝑡、𝑑‘𝑜𝑢𝑡均设置为32，膨胀因子为1。对于我们的预测任务，我们的目标是基于之前的12个步骤来预测数据的下一个12个步骤。历史记录长度（𝐻）和预测记录长度（𝑃）均设置为12。投影层参数配置为𝑑设置为64，𝑑𝐿设置为4096。最后，将回归层的隐层参数𝑑‘设置为128。</p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>关键问题：</p><ul><li>RQ1：UrbanGPT在不同的零样本时空预测任务中的性能和泛化能力是什么？</li><li>RQ2：与现有的时空模型相比，UrbanGPT在经典监督场景中的表现如何？</li><li>RQ3：提出的关键组件为提高我们的UrbanGPT模型的能力带来了哪些具体的贡献？</li><li>RQ4：所提出的模型能否稳健地处理不同时空模式的预测情景？</li></ul><h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><ul><li><p>为了评估所提出的模型在预测不同城市计算场景的时空模式方面的有效性，我们使用四个不同的数据集进行了实验：纽约出租车、纽约自行车、纽约犯罪和芝加哥出租车。</p></li><li><p><strong>为了便于分析，我们根据经纬度信息将城市划分为类似网格的区域。</strong>在特定的时间间隔内，我们汇总了每个区域的统计测量值。</p></li><li><p>例如，这涉及到计算区域A30分钟周期内的出租车流入和流出的数量，或确定区域B一天内的盗窃事件的数量。此外，利用不同区域的纬度和经度，兴趣点（POIs）数据可以通过地图服务提供的api获得。</p></li></ul><p>纽约市的出租车数据集包含263个区域，每个区域的面积约为3公里x3公里。该数据集的时间采样间隔为30分钟。纽约自行车和纽约犯罪数据集包括2162个地区，每个地区都由一个1公里x1公里的网格代表。纽约自行车的采样间隔也是30分钟，而纽约犯罪的采样间隔是1天。所有数据集涵盖了纽约市从2016年1月1日至2021年12月31日的时间段。芝加哥出租车数据集包括77个区域，每个区域的长度约为4公里x4公里。该数据集包括从2021年1月1日至2021年12月31日期间的所有出租车数据，时间采样间隔为30分钟。</p><h4 id="评估协议"><a href="#评估协议" class="headerlink" title="评估协议"></a>评估协议</h4><p>为了研究大型语言模型在分析不同地区的不同时空数据方面的能力，我们选择了来自纽约市不同地区的出租车、自行车和犯罪数据的一个子集作为我们的训练集。</p><p><strong>零样本学习场景：</strong>我们通过预测来自纽约市甚至芝加哥那些<strong>在训练阶段未见过的地区的未来时空数据</strong>来评估模型的性能。</p><p><strong>监督学习场景：</strong>我们使用来自训练集相同区域的未来数据来评估该模型。</p><ul><li><p><strong>回归任务</strong>：我们在所有基线模型上保持了一致的训练和测试方法。</p></li><li><p>在涉及犯罪数据的<strong>分类任务</strong>时，我们使用二元交叉熵作为损失函数对模型进行训练和测试。</p></li></ul><p>我们的实验是使用稳健的vicuna-7b [49]作为UrbanGPT的基础大型语言模型进行的。关于我们的方法和实验设置的更全面的理解，请参阅附录中的详细信息。</p><h4 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h4><ul><li><p>对于回归任务，我们使用MAE（平均绝对误差）和RMSE（均方根误差）作为评价度量。这些指标量化了预测结果和实际标签之间的差异，较低的值表明优越的性能[11,48]。</p></li><li><p>在分类任务的情况下，我们使用召回率和Macro-F1作为评估指标来评估绩效。召回度量了模型正确识别积极实例的能力，而Macro-F1是一个综合的性能度量，它结合了精度和召回率，提供了分类精度[10,29]的总体度量。</p></li></ul><h4 id="基线模型"><a href="#基线模型" class="headerlink" title="基线模型"></a>基线模型</h4><p>我们与10个高级模型进行了彻底的比较：</p><p>（1）在基于rnn的时空预测方法类别中，我们将我们提出的方法与AGCRN [1]、DMVSTNET [38]和ST-LSTM [32]进行了比较。这些方法利用rnn进行建模和预测。</p><ul><li>ST-LSTM[32]：它结合了长短期记忆来捕获时空数据中的时间依赖性。</li><li>AGCRN[1]：rnn被用来捕获时间相关性，允许表示随着时间的推移的进化模式。</li><li>DMVSTNET[38]：在这种方法中，rnn被用来有效地建模时间依赖关系，捕获随时间演变的模式。此外，利用卷积网络和全连接层来捕获局部空间相关性，并建立有意义的空间关系。</li></ul><p>（2）基于gnn的时空模型主要利用图神经网络来捕获空间相关性，并整合时间编码器来捕获时空关系。我们与这类模型进行了比较，包括GWN [36]，MTGNN [35]，STSGCN [25]，TGCN [46]，和STGCN [41].</p><ul><li>GWN[36]：它结合了一个可学习的图结构和一维卷积来有效地学习时空依赖关系。</li><li>MTGNN[35]：它利用一个可学习的图结构来建模多元的时间相关性。MTGNN使用一维膨胀卷积来生成时间表示。</li><li>TGCN[46]：该模型结合了图神经网络（GNNs）进行空间相关建模和递归神经网络（RNNs）进行时间相关建模。</li><li>STGCN[41]：它分别使用门控时间卷积和gnn来建模时间和空间依赖性。</li><li>STSGCN[25]：它引入了一个时空图的构造来学习相邻时间步长之间的空间相关性。</li></ul><p>（3）在基于注意的时空模型类别中，该方法采用注意机制来建模时空相关性。我们在这一类中比较的模型是ASTGCN [7]和STWA [5]。</p><ul><li>ASTGCN[7]：该方法采用注意机制来捕获多粒度的时间相关特征。</li><li>STWA[5]：该模型将个性化的时间和空间参数纳入注意模块，允许对动态时空相关性的建模</li></ul><h3 id="零样本预测性能（RQ1）"><a href="#零样本预测性能（RQ1）" class="headerlink" title="零样本预测性能（RQ1）"></a>零样本预测性能（RQ1）</h3><h4 id="相同城市内未见区域的预测"><a href="#相同城市内未见区域的预测" class="headerlink" title="相同城市内未见区域的预测"></a>相同城市内未见区域的预测</h4><p>跨区域场景需要使用来自城市内某些区域的数据来<strong>预测模型没有遇到的其他区域的未来情况</strong>。通过对模型在跨区域预测中的表现的全面分析，我们可以注意到三个重要的观察结果：</p><p><strong>（1）优越的零样本预测性能。</strong>表1中的结果突出了所提出的模型在不同数据集上的<strong>回归和分类任务</strong>中的卓越性能，超过了零样本预测中的基线模型。UrbanGPT的成功可以归因于两个关键因素。</p><ul><li><strong>时空-文本对齐。</strong>时空上下文信号与语言模型的文本理解能力的对齐对模型成功起着关键作用。这种融合使模型能够有效地<strong>利用从时空信号中编码的城市动态和由大语言模型提供的对文本上下文的全面理解</strong>，从而扩展了模型在零样本场景的预测能力。</li><li><strong>时空指令微调。</strong>自适应调整过程使LLMs能够有效地整合指令中的关键信息，增强其对空间和时间因素之间复杂关系和依赖性的理解。 通过将时空指令微调与时空依赖编码器无缝合并， UrbanGPT成功地保留了<strong>通用且可转移的时空知识</strong>，进而实现零样本场景中的精确预测。</li></ul><p><strong>（2）增强了对城市语义的理解。</strong>城市语义提供了对多样的空间和时间特性的重要见解。所提出的方法在各种数据集上对模型进行训练，<strong>丰富其对不同时段和地理位置的时空动态的理解。</strong>相比之下，<strong>基准模型往往优先考虑编码时空依赖关系，忽视了区域、时段和数据类别之间的语义差异。</strong>通过将全面的语义信息注入UrbanGPT中，我们显著增强了其在先前未见的区域中进行准确零样本预测的能力。</p><p><strong>（3）稀疏数据场景中的性能提升。</strong>稀疏数据环境中预测时空模式是具有挑战性的，因为<strong>当数据点稀缺时，模型容易出现过拟合</strong>。在预测犯罪等情况下，数据通常是稀疏的，在这一条件下，基线在跨区域预测任务中表现困难，导致召回率低，表明可能存在过拟合的问题。为了克服这个限制，我们的模型<strong>通过使用有效的时空指令微调范式，将时空学习与大语言模型相结合。通过融入丰富的语义见解，所提出的方法增强了模型的时空表示能力，使其能够有效处理稀疏数据，并实现改进的预测准确性。</strong></p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319140723091.png"><h4 id="跨城市预测任务"><a href="#跨城市预测任务" class="headerlink" title="跨城市预测任务"></a>跨城市预测任务</h4><p>为评估模型在跨城市预测任务中的性能，我们对芝加哥出租车数据集进行了测试（该数据集没有出现在训练阶段）。如图4所示，结果显示模型在每个时间步长都始终优于比较方法，这说明UrbanGPT能够对跨城市知识进行有效的转移。通过整合时空编码器与时空指令微调范式，模型有效地捕获了普遍及特殊的时空模式。此外，通过考虑不同的地理信息和时间因素以及学到的转移知识，模型具备将相似功能区域和历史时期所表现出的时空模式进行关联的能力，使其能够做出更准确的预测。</p><ul><li><strong>多步预测的一致性</strong>：我们的模型<strong>在每个时间步长上始终优于比较方法</strong>。值得注意的是，它在短期和长期的时空预测中都保持了显著的优势，证明了我们提出的模型在跨城市预测场景中的鲁棒性。</li><li><strong>跨城市有效知识迁移</strong>：芝加哥出租车数据集预测结果验证了我们的模型在跨城市场景中的优越能力。这种增强可以<strong>归因于时空编码器与时空指令调整范式的集成。</strong>通过合并这些组件，我们的模型有效地<strong>捕获了通用的和可转移的时空模式</strong>，使它能够做出准确的预测。此外，<strong>通过考虑不同的地理信息和时间因素以及学习到的知识转移，我们的模型成功地关联了相似功能区和历史时期的时空模式。</strong></li></ul><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319143415576.png"><h3 id="典型有监督预测任务（RQ2）"><a href="#典型有监督预测任务（RQ2）" class="headerlink" title="典型有监督预测任务（RQ2）"></a>典型有监督预测任务（RQ2）</h3><p>本节研究了我们的UrbanGPT在端到端监督预测场景中的预测能力，如表2所示。</p><ul><li><strong>增强的长期预测能力</strong>：我们利用时间间隔跨度更广的测试数据集来测试模型在长期时空预测中的有效性。例如，使用2017年的数据训练模型，并使用2021年的数据进行评估。结果表明，我们的UrbanGPT在基线相比具有显著的优势，突显了其<strong>长期时间跨度场景的卓越泛化能力</strong>。此特性<strong>减少了频繁重新训练或增量更新的需要</strong>，使模型更符合实际应用。此外，实验还证实，<strong>加入额外的文本知识不会阻碍模型性能或引入噪声</strong>，从而进一步验证了利用大型语言模型增强时空预测任务的可行性。</li><li><strong>空间语义理解</strong>：准确捕捉空间相关性在时空预测领域至关重要。传统的方法通常使用<strong>图网络或注意机制</strong>来分析这些相关性。缺乏专门的空间相关模块的模型，如LSTM，在忽视空间环境时往往表现不佳。相比之下，我们的模型通过<strong>在文本输入中集成广泛的地理和感兴趣点（POIs）数据来弥补了显式空间编码器的缺失</strong>。<strong>这种方法使模型能够在更高的语义层次上理解具有相似功能的区域的共享特征。因此，它推导出不同功能区之间的关联模式，并有效地代表了不同区域之间的相互联系。</strong></li></ul><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319143505846.png" alt="image-20240319143505846" style="zoom:80%;"><h3 id="消融研究（RQ3）"><a href="#消融研究（RQ3）" class="headerlink" title="消融研究（RQ3）"></a>消融研究（RQ3）</h3><p>本节研究了不同关键组件对模型性能的影响，如图5所示。我们严格的测试主要围绕着使用纽约市出租车数据集的零样本场景展开。通过我们的分析，我们将不同模块所提供的好处提炼为四个关键点。</p><p><strong>(1) 时空上下文的影响</strong>：-STC。从指示文本中移除时空信息后出现了性能衰减，这可能由于<strong>缺乏时间信息</strong>，<strong>使得模型仅依赖于时空编码器来编码与时间相关的特征和执行预测任务</strong>。此外，空间信息的缺失阻碍了模型捕捉空间相关性的能力，使得分析不同区域的不同时空模式具有挑战性。</p><p><strong>(2) 使用多个数据集进行指令微调的影响</strong>：-Multi。我们仅在NYC-taxi数据集进行训练。由于<strong>缺乏不同的城市指标的信息，限制了模型充分揭示城市时空动态的能力</strong>。通过整合来自多个来源的不同时空数据，模型可以有效地捕获不同地理位置的独特特征及演化的时空模式。</p><p><strong>(3) 时空编码器的影响</strong>：-STE。我们从模型中移除了时空编码器。结果表明，时空编码器的缺失<strong>显著地阻碍了大语言模型在时空预测场景中的预测性能</strong>。这强调了所提出的时空编码器在提高模型的预测能力方面所发挥的关键作用。</p><p><strong>(4) 指令微调中的回归层</strong>：T2P。我们直接指示UrbanGPT以文本格式生成其预测。次优的性能表现主要是由于训练过程中依赖于多类损失来进行优化，导致<strong>模型的概率输出和时空预测所需的连续值分布之间的不匹配</strong>。为了弥补这一差距，我们在模型中加入了一个回归预测器，显著提高了它在回归任务生成更精确的数值预测的能力。</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319145301101.png" alt="image-20240319145301101" style="zoom:80%;"><h3 id="模型鲁棒性研究（RQ4）"><a href="#模型鲁棒性研究（RQ4）" class="headerlink" title="模型鲁棒性研究（RQ4）"></a>模型鲁棒性研究（RQ4）</h3><p>在本节中，我们将重点评估我们的UrbanGPT在不同时空模式场景下的稳健性。<strong>我们根据数值变化的大小对区域进行分类，</strong>如在特定时间段内的出租车流量。<strong>较低的方差表明稳定的时间模式，而较高的方差表明时空模式多样化的地段，如活跃商业区或人口稠密地区。</strong>如图6所示，大多模型在方差较低的区域表现良好，因为这些区域的时空模式相对稳定。然而，基线在方差较高的区域中表现不佳，特别是在方差处于 (0.75, 1.0] 范围的区域，这一限制可能源自<strong>基线模型在零样本场景下难以推断未见区域的复杂时空模式</strong>。在实际应用中，<strong>人口密集或繁华区域的准确预测对于城市治理至关重要</strong>，例如交通灯控制和安全调度。UrbanGPT在(0.75, 1.0]区间表现出显着的性能提升，突显了所提出方法的强大的零样本预测能力。</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319152953670.png" alt="image-20240319152953670" style="zoom:80%;"><h3 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h3><p>在我们的案例研究中，我们彻底评估了几个大型语言模型（llm）的零样本时空预测。我们强调了这些模型在直接从数字地理序列数据中理解时空模式方面所面临的挑战。相比之下，我们展示了我们提出的UrbanGPT框架在捕获通用时空模式方面的特殊性能，以及它在各种零样本时空预测场景中有效推广的能力。</p><p>结果表明，各种llm能够基于这些指令生成预测，从而突出了提示设计的有效性。<strong>例如，ChatGPT依赖于历史平均值，而不是在其预测中明确地组合时间或空间数据。Llama-2-70b分析了特定的时间段和区域，但它在编码数值时间序列依赖性方面遇到了挑战，导致了次优的预测性能。另一方面，Claude-2.1有效地总结和分析了历史数据，利用高峰时段模式和兴趣点来实现更准确的交通趋势预测。</strong></p><p>我们提出的UrbanGPT通过一个时空指令调优范式，无缝地将时空上下文信号与大型语言模型（llm）的推理能力集成起来。这种整合导致了预测数值和时空趋势的显著改进。</p><p>表3：我们用所提供的instruction测试了不同llm对纽约市自行车流量的零样本预测</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319170828390.png" alt="image-20240319170828390" style="zoom:80%;"><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p><strong>深度时空预测模型。</strong>深度时空预测方法由于其出色的性能而在深度学习中获得了突出的地位。这些模型通常由两个组成部分组成：<strong>时间依赖建模和空间相关编码。</strong>早期的模型，如D-LSTM [42]和ST-resnet [44]，使用rnn和卷积网络来建模时间和空间依赖性。图神经网络（GNNs）被证明是空间相关建模的一种自然拟合，就像在STGCN [41]和DCRNN [13]等模型中所看到的那样，它们利用了基于节点距离的图结构。可学习的区域级图结构[35,36]和动态时空图网络[8,47]等技术进一步增强了空间相关建模。</p><p>此外，研究人员还探索了诸如多尺度时间学习[33]和多粒度时间学习[7]来编码时间依赖性的方法。这些策略能够捕获诸如长期和短期相关性以及周期性等特征。这些进步有助于时空预测的进展。然而，值得注意的是，这些研究大多数是为监督环境量身定制的，有限的研究和发展集中在零样本时空预测。这是一个需要进一步探索的重要领域。</p><p><strong>时空预训练。</strong>时空预训练技术最近受到了广泛的研究关注。这些技术主要关注于<strong>生成式[15,23]和对比式[45]预训练模型</strong>，以提高下游任务的预测性能。对少样本学习场景[12,18]的训练前微调框架也进行了广泛的探索，<strong>旨在通过对齐源数据和目标数据来提高知识的可转移性。</strong>然而，这些方法需要对目标数据进行训练或微调，并且缺乏零样本预测能力。在这项工作中，我们通过提出UrbanGPT来解决下游城市场景中数据稀缺的挑战。我们的模型展示了在各种场景中很好地泛化的能力，减轻了对目标数据进行广泛训练或微调的需要。</p><p><strong>大型语言模型。</strong>大型语言模型[3,20]的出现由于其在<strong>文本理解和推理</strong>等任务中前所未有的机器性能而引起了广泛的关注。这些模型已经成为一个热点话题，展示了从智能算法发展到人工智能的发展潜力。开源的大型语言模型，如Llama [27,28]、Vicuna [49]和ChatGLM [43]已经发布，导致研究人员探索它们在各个领域的应用，<strong>通过这些模型中的领域知识来增强迁移学习能力。</strong>在计算机视觉领域，研究人员将多模态大型语言模型与即时学习方法相结合，以实现下游任务[24,50,51]的零样本预测。此外，大型语言模型在图推理[2,4,26]和推荐[9,22,34]中的能力已被广泛研究。然而，在时空预测领域，利用大型语言模型进行零样本时空预测任务仍未得到很大程度的探索</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们提出了UrbanGPT，一种时空大型语言模型，以很好地推广到不同的城市场景。为实现时空上下文信号与LLMs无缝对齐，本文引入了一种时空指令微调范式。这赋予UrbanGPT在各种类型的城市数据中学习通用和可迁移的时空模式的卓越能力。大量实验分析展示了UrbanGPT架构及其关键组件的卓越有效性。</p><p>然而，需要注意的是，虽然结果是令人鼓舞的，但在未来的研究中仍然存在待解决的限制。作为第一步，我们积极收集更多种类的城市数据，以增强和完善UrbanGPT在更广泛的城市计算领域的能力。此外，理解UrbanGPT的决策过程也是重要的。虽然该模型表现出卓越的性能，但提供可解释性同样重要。未来的研究也将集中于赋予UrbanGPT模型解释其预测的能力。</p><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="训练UrbanGPT"><a href="#训练UrbanGPT" class="headerlink" title="训练UrbanGPT"></a>训练UrbanGPT</h3><h4 id="准备预训练checkpoint"><a href="#准备预训练checkpoint" class="headerlink" title="准备预训练checkpoint"></a>准备预训练checkpoint</h4><blockquote><p>checkpoint文件包含的内容很多，比如：模型参数、优化器状态、训练进度等信息。checkpoint文件的主要作用是在训练过程中保存模型状态，以便在训练过程中发生中断或结束后能够恢复模型的状态，或者在推断时使用已经训练好的模型参数。</p></blockquote><p>UrabnGPT基于以下优秀的现有模型进行训练。请按照指示准备checkpoint：</p><ul><li><p><code>Vicuna</code>:<br>准备我们的基本模型Vicuna，它是一个指令微调过的的chatbot，也是我们实现中的base model。</p><p>请下载权重<a href="https://github.com/lm-sys/FastChat#model-weights">here</a>.  我们通常使用具有7B参数的v1.5和v1.5-16k模型。您应该更新vicuna中的config.json，例如，v1.5-16k中的Json ‘可以在<a href="https://huggingface.co/datasets/bjdwh/checkpoints/blob/main/train_config/config.json">config.json</a>中找到。</p></li><li><p><code>Spatio-temporal Encoder</code>:<br>我们使用一个简单的基于TCN的时空编码器对时空依赖进行编码。通过典型的<strong>多步时空预测任务</strong>对<a href="./checkpoints/st_encoder/pretrain_stencoder.pth">st_encoder</a>的权值进行预训练。</p></li><li><p><code>Spatio-temporal Train Data</code>:<br>我们利用由纽约市出租车、自行车和犯罪数据组成的预训练数据，包括时空统计、记录的时间戳和有关区域兴趣点(poi)的信息。这些数据被组织在<a href="https://huggingface.co/datasets/bjdwh/ST_data_urbangpt/tree/main/train_data">train_data</a>中。请下载并放在。/UrbanGPT/ST_data_urbangpt/train_data 下。</p></li></ul><h4 id="指令微调"><a href="#指令微调" class="headerlink" title="指令微调"></a>指令微调</h4><ul><li><strong>Start tuning:</strong> 在上述步骤之后，您可以通过在<a href="urbangpt_train.sh">urbangpt_train.sh</a>中填充空白来开始指令调优。示例：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># to fill in the following path to run our UrbanGPT!</span><span class="token assign-left variable">model_path</span><span class="token operator">=</span>./checkpoints/vicuna-7b-v1.5-16k<span class="token assign-left variable">instruct_ds</span><span class="token operator">=</span>./ST_data_urbangpt/train_data/multi_NYC.json<span class="token assign-left variable">st_data_path</span><span class="token operator">=</span>./ST_data_urbangpt/train_data/multi_NYC_pkl.pkl<span class="token assign-left variable">pretra_ste</span><span class="token operator">=</span>ST_Encoder<span class="token assign-left variable">output_model</span><span class="token operator">=</span>./checkpoints/UrbanGPTwandb offlinepython <span class="token parameter variable">-m</span> torch.distributed.run <span class="token parameter variable">--nnodes</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--nproc_per_node</span><span class="token operator">=</span><span class="token number">8</span> <span class="token parameter variable">--master_port</span><span class="token operator">=</span><span class="token number">20001</span> <span class="token punctuation">\</span>    urbangpt/train/train_mem.py <span class="token punctuation">\</span>    <span class="token parameter variable">--model_name_or_path</span> <span class="token variable">${model_path}</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--version</span> v1 <span class="token punctuation">\</span>    <span class="token parameter variable">--data_path</span> <span class="token variable">${instruct_ds}</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--st_content</span> ./TAXI.json <span class="token punctuation">\</span>    <span class="token parameter variable">--st_data_path</span> <span class="token variable">${st_data_path}</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--st_tower</span> <span class="token variable">${pretra_ste}</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--tune_st_mlp_adapter</span> True <span class="token punctuation">\</span>    <span class="token parameter variable">--st_select_layer</span> <span class="token parameter variable">-2</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--use_st_start_end</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--bf16</span> True <span class="token punctuation">\</span>    <span class="token parameter variable">--output_dir</span> <span class="token variable">${output_model}</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--num_train_epochs</span> <span class="token number">3</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--per_device_train_batch_size</span> <span class="token number">4</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--per_device_eval_batch_size</span> <span class="token number">4</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--gradient_accumulation_steps</span> <span class="token number">1</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--evaluation_strategy</span> <span class="token string">"no"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--save_strategy</span> <span class="token string">"steps"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--save_steps</span> <span class="token number">2400</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--save_total_limit</span> <span class="token number">1</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--learning_rate</span> 2e-3 <span class="token punctuation">\</span>    <span class="token parameter variable">--weight_decay</span> <span class="token number">0</span>. <span class="token punctuation">\</span>    <span class="token parameter variable">--warmup_ratio</span> <span class="token number">0.03</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--lr_scheduler_type</span> <span class="token string">"cosine"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--logging_steps</span> <span class="token number">1</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--tf32</span> True <span class="token punctuation">\</span>    <span class="token parameter variable">--model_max_length</span> <span class="token number">2048</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--gradient_checkpointing</span> True <span class="token punctuation">\</span>    <span class="token parameter variable">--lazy_preprocess</span> True <span class="token punctuation">\</span>    <span class="token parameter variable">--report_to</span> wandb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="评估UrbanGPT"><a href="#评估UrbanGPT" class="headerlink" title="评估UrbanGPT"></a>评估UrbanGPT</h3><h4 id="准备-Checkpoints-and-Data"><a href="#准备-Checkpoints-and-Data" class="headerlink" title="准备 Checkpoints and Data"></a>准备 Checkpoints and Data</h4><ul><li>**Checkpoints: **您可以尝试通过使用自己的模型或我们发布的检查点来评估UrbanGPT。</li><li><strong>Data:</strong> 我们为纽约出租车数据拆分测试集，并为评估创建指令数据。请参阅[评估]<a href="https://huggingface.co/datasets/bjdwh/ST_data_urbangpt%EF%BC%89">https://huggingface.co/datasets/bjdwh/ST_data_urbangpt）</a></li></ul><span id="Running Evaluation"><h4 id="运行Evaluation"><a href="#运行Evaluation" class="headerlink" title="运行Evaluation"></a>运行Evaluation</h4><p>您可以通过在[urbangpt_eval.sh]（urbangpt_eval.sh）填充空白开始第二阶段tuning。下面是一个示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># to fill in the following path to evaluation!</span><span class="token assign-left variable">output_model</span><span class="token operator">=</span>./checkpoints/tw2t_multi_reg-cla-gird<span class="token assign-left variable">datapath</span><span class="token operator">=</span>./ST_data_urbangpt/NYC_taxi_cross-region/NYC_taxi.json<span class="token assign-left variable">st_data_path</span><span class="token operator">=</span>./ST_data_urbangpt/NYC_taxi_cross-region/NYC_taxi_pkl.pkl<span class="token assign-left variable">res_path</span><span class="token operator">=</span>./result_test/cross-region/NYC_taxi<span class="token assign-left variable">start_id</span><span class="token operator">=</span><span class="token number">0</span><span class="token assign-left variable">end_id</span><span class="token operator">=</span><span class="token number">51920</span><span class="token assign-left variable">num_gpus</span><span class="token operator">=</span><span class="token number">8</span>python ./urbangpt/eval/run_urbangpt.py --model-name <span class="token variable">${output_model}</span>  <span class="token parameter variable">--prompting_file</span> <span class="token variable">${datapath}</span> <span class="token parameter variable">--st_data_path</span> <span class="token variable">${st_data_path}</span> <span class="token parameter variable">--output_res_path</span> <span class="token variable">${res_path}</span> <span class="token parameter variable">--start_id</span> <span class="token variable">${start_id}</span> <span class="token parameter variable">--end_id</span> <span class="token variable">${end_id}</span> <span class="token parameter variable">--num_gpus</span> <span class="token variable">${num_gpus}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="扩张卷积"><a href="#扩张卷积" class="headerlink" title="扩张卷积"></a>扩张卷积</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DilatedInception</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cin<span class="token punctuation">,</span> cout<span class="token punctuation">,</span> dilation_factor<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>DilatedInception<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tconv <span class="token operator">=</span> nn<span class="token punctuation">.</span>ModuleList<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 创建一个列表以容纳多个卷积层</span>        self<span class="token punctuation">.</span>kernel_set <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>  <span class="token comment"># 不同的卷积核大小</span>        cout <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>cout<span class="token operator">/</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>kernel_set<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 计算每个卷积的输出通道数</span>        <span class="token keyword">for</span> kern <span class="token keyword">in</span> self<span class="token punctuation">.</span>kernel_set<span class="token punctuation">:</span>            <span class="token comment"># 添加具有不同卷积核大小和扩张率的卷积层，一维扩散卷积核</span>            self<span class="token punctuation">.</span>tconv<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>cin<span class="token punctuation">,</span> cout<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">,</span> dilation<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> dilation_factor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 使用定义的层执行卷积操作</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>kernel_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tconv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>kernel_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>   <span class="token comment"># 沿最后一个维度切片张量</span>        x <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>x<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>                 <span class="token comment"># 沿着通道维度拼接张量</span>        <span class="token keyword">return</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ST-Encoder-前向传播"><a href="#ST-Encoder-前向传播" class="headerlink" title="ST_Encoder 前向传播"></a>ST_Encoder 前向传播</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">:</span>    inputs <span class="token operator">=</span> source    <span class="token comment"># 转置维度以进行正确的卷积操作</span>    inputs <span class="token operator">=</span> inputs<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># (batch_size, feature_dim, num_nodes, input_window)</span>    <span class="token keyword">assert</span> inputs<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>input_window<span class="token punctuation">,</span> <span class="token string">'input sequence length not equal to preset sequence length'</span>    <span class="token comment"># 输入扩展到最大感受野，扩展部分填充0</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>input_window <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>receptive_field<span class="token punctuation">:</span>        inputs <span class="token operator">=</span> nn<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>pad<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>receptive_field<span class="token operator">-</span>self<span class="token punctuation">.</span>input_window<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    x <span class="token operator">=</span> self<span class="token punctuation">.</span>start_conv<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>     <span class="token comment"># 将输入张量进行卷积操作，输出特征图的通道数为 residual_channels=32，</span>    skip <span class="token operator">=</span> self<span class="token punctuation">.</span>skip0<span class="token punctuation">(</span>F<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dropout<span class="token punctuation">,</span> training<span class="token operator">=</span>self<span class="token punctuation">.</span>training<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 三层卷积</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>layers<span class="token punctuation">)</span><span class="token punctuation">:</span>        residual <span class="token operator">=</span> x  <span class="token comment"># 记录当前块输入作为残差</span>        filters <span class="token operator">=</span> self<span class="token punctuation">.</span>filter_convs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 普通卷积操作</span>        filters <span class="token operator">=</span> torch<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>filters<span class="token punctuation">)</span>  <span class="token comment"># 应用tanh激活函数</span>        gate <span class="token operator">=</span> self<span class="token punctuation">.</span>gate_convs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 执行门控卷积操作</span>        gate <span class="token operator">=</span> torch<span class="token punctuation">.</span>sigmoid<span class="token punctuation">(</span>gate<span class="token punctuation">)</span>  <span class="token comment"># 应用sigmoid激活函数，映射到0，1范围，进行门控</span>        x <span class="token operator">=</span> filters <span class="token operator">*</span> gate  <span class="token comment"># 使用门控机制进行特征调整---张量积，逐元素相乘，抑制噪声</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dropout<span class="token punctuation">,</span> training<span class="token operator">=</span>self<span class="token punctuation">.</span>training<span class="token punctuation">)</span>  <span class="token comment"># 执行dropout操作</span>        s <span class="token operator">=</span> x        s <span class="token operator">=</span> self<span class="token punctuation">.</span>skip_convs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>  <span class="token comment"># 跳跃连接中的卷积操作</span>        skip <span class="token operator">=</span> s <span class="token operator">+</span> skip  <span class="token comment"># 计算跳跃连接的输出</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>residual_convs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 执行残差卷积操作</span>        x <span class="token operator">=</span> x <span class="token operator">+</span> residual<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment"># 添加残差并更新当前块输入</span>    <span class="token comment"># 跳跃连接  负责多层次关联注入</span>    skip <span class="token operator">=</span> self<span class="token punctuation">.</span>skipE<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> skip    x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>skip<span class="token punctuation">)</span>    x_emb <span class="token operator">=</span> x<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span>    x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>end_conv_1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    x <span class="token operator">=</span> self<span class="token punctuation">.</span>end_conv_2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">return</span> x<span class="token punctuation">,</span> x_emb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="STLlama-前向传播"><a href="#STLlama-前向传播" class="headerlink" title="STLlama 前向传播"></a>STLlama 前向传播</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        input_ids<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>LongTensor <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        attention_mask<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        past_key_values<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>List<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        inputs_embeds<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        use_cache<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        output_attentions<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        output_hidden_states<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        st_data_x<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        st_data_y<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        region_start<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>        region_end<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>        return_dict<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Union<span class="token punctuation">[</span>Tuple<span class="token punctuation">,</span> BaseModelOutputWithPast<span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token comment"># HACK: replace back original embeddings for LLaVA pretraining</span>    orig_embeds_params <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token string">'orig_embeds_params'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>    <span class="token comment"># if orig_embeds_params is not None:</span>    <span class="token comment">#     orig_embeds_params = orig_embeds_params[0]</span>    <span class="token comment">#     with torch.no_grad():</span>    <span class="token comment">#         self.get_input_embeddings().weight.data[:-2] = orig_embeds_params[:-2].data</span>    <span class="token comment"># 检查是否有传入的嵌入 inputs_embeds，如果没有则通过 embed_tokens 方法将输入的 input_ids 转换成嵌入表示。</span>    <span class="token keyword">if</span> inputs_embeds <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        inputs_embeds <span class="token operator">=</span> self<span class="token punctuation">.</span>embed_tokens<span class="token punctuation">(</span>input_ids<span class="token punctuation">)</span>    <span class="token comment"># 检查是否需要将多个 st_data_x 和 st_data_y 进行拼接</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>st_data_x<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>        st_data_x <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>st_data_x<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        st_data_y <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>st_data_y<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    st_tower <span class="token operator">=</span> self<span class="token punctuation">.</span>get_st_tower<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 如果 st_tower 不为空，且输入数据的长度不为1或者处于训练模式，同时 st_data_x 也不为空，则进行时空信息的处理。</span>    <span class="token keyword">if</span> st_tower <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>input_ids<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>training<span class="token punctuation">)</span> <span class="token keyword">and</span> st_data_x <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">type</span><span class="token punctuation">(</span>st_data_x<span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token builtin">list</span><span class="token punctuation">:</span>            <span class="token comment"># variable length images</span>            <span class="token comment"># 将 st_data_x 输入到 st_tower 中，得到时空编码的结果 STE_out，同时将 st_data_y 输入到 st_tower 中得到时空编码标签的结果 STE_lbls_out</span>            pre_STE<span class="token punctuation">,</span> STE_out <span class="token operator">=</span> st_tower<span class="token punctuation">(</span>st_data_x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            _<span class="token punctuation">,</span> STE_lbls_out <span class="token operator">=</span> st_tower<span class="token punctuation">(</span>st_data_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> STE_out<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token comment"># 根据指定的 region_start 和 region_end 对 STE_out（时空编码信息） 进行切片得到区域选择输出 region_select_out。</span>                region_select_out <span class="token operator">=</span> STE_out<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>region_end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>bfloat16<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            pre_STE<span class="token punctuation">,</span> STE_out <span class="token operator">=</span> st_tower<span class="token punctuation">(</span>st_data_x<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            _<span class="token punctuation">,</span> STE_lbls_out <span class="token operator">=</span> st_tower<span class="token punctuation">(</span>st_data_y<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            region_select_out <span class="token operator">=</span> STE_out<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>region_end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>bfloat16<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>pre_STE <span class="token operator">=</span> pre_STE        <span class="token comment"># ===========将 region_select_out 经过线性层 st_projector 处理得到投影的结果 st_projector_out。==========</span>        st_projector_out <span class="token operator">=</span> self<span class="token punctuation">.</span>st_projector<span class="token punctuation">(</span>region_select_out<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        new_input_embeds <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># new_stpre_embeds = []</span>        cur_st_idx <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 遍历输入的 input_ids 和对应的 inputs_embeds。</span>        <span class="token keyword">for</span> cur_input_ids<span class="token punctuation">,</span> cur_input_embeds <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>input_ids<span class="token punctuation">,</span> inputs_embeds<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># if st_tower.config.use_st_start_end:</span>            <span class="token comment"># 根据 st_tower 的配置信息，找到对应的起始标记和结束标记位置，然后根据这些位置和时空特征的投影结果，更新输入嵌入表示。</span>            cur_st_features <span class="token operator">=</span> st_projector_out<span class="token punctuation">[</span>cur_st_idx<span class="token punctuation">]</span>            cur_st_features <span class="token operator">=</span> cur_st_features<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>cur_st_features<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment"># 根据时空特征来划分patch</span>            num_patches <span class="token operator">=</span> cur_st_features<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token comment"># 判断开始标记和结束标记数量要一致</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_input_ids <span class="token operator">==</span> st_tower<span class="token punctuation">.</span>config<span class="token punctuation">.</span>st_start_token<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span>                    cur_input_ids <span class="token operator">==</span> st_tower<span class="token punctuation">.</span>config<span class="token punctuation">.</span>st_end_token<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"The number of st start tokens and st end tokens should be the same."</span><span class="token punctuation">)</span>            st_start_tokens <span class="token operator">=</span> torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>cur_input_ids <span class="token operator">==</span> st_tower<span class="token punctuation">.</span>config<span class="token punctuation">.</span>st_start_token<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token comment"># st_end_tokens = torch.where(cur_input_ids == st_tower.config.st_end_token)[0]</span>            <span class="token keyword">if</span> st_start_tokens<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">:</span>   <span class="token comment"># 标记&gt;=3</span>                st_start_token_pos1 <span class="token operator">=</span> st_start_tokens<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                st_start_token_pos2 <span class="token operator">=</span> st_start_tokens<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                st_start_token_pos3 <span class="token operator">=</span> st_start_tokens<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>                self<span class="token punctuation">.</span>st_start_id0 <span class="token operator">=</span> st_start_token_pos1                self<span class="token punctuation">.</span>st_start_id1 <span class="token operator">=</span> st_start_token_pos3                <span class="token keyword">if</span> cur_input_ids<span class="token punctuation">[</span>                    st_start_token_pos1 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> st_tower<span class="token punctuation">.</span>config<span class="token punctuation">.</span>st_end_token<span class="token punctuation">:</span>                    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"The st end token should follow the st start token."</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> orig_embeds_params <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    <span class="token comment"># 根据这些位置和时空特征的投影结果，更新输入嵌入表示（拼接文本embedding张量+时空特征投影结果，只有start到end位置参与梯度更新）</span>                    cur_new_input_embeds <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>cur_input_embeds<span class="token punctuation">[</span><span class="token punctuation">:</span>st_start_token_pos1<span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                      <span class="token comment"># 时空特征前后拼接原始input embed的start与end位置，start之前和end之后的用detach</span>                                                      <span class="token comment"># 创建离断版本 将这些元素从计算图中分离出来，使得它们不参与梯度计算，从而防止对它们的修改影响到之后的反向传播过程</span>                                                      cur_input_embeds<span class="token punctuation">[</span>st_start_token_pos1<span class="token punctuation">:</span>st_start_token_pos1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_st_features<span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos1 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>st_start_token_pos1 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos1 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">:</span>st_start_token_pos2<span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos2<span class="token punctuation">:</span>st_start_token_pos2 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos2 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">:</span>st_start_token_pos3<span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos3<span class="token punctuation">:</span>st_start_token_pos3 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos3 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    cur_new_input_embeds <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>cur_input_embeds<span class="token punctuation">[</span><span class="token punctuation">:</span>st_start_token_pos1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_st_features<span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>st_start_token_pos1 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                     dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>                cur_st_idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>   <span class="token comment"># 一组标记，流程和上面一样</span>                st_start_token_pos <span class="token operator">=</span> st_start_tokens<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                self<span class="token punctuation">.</span>st_start_id0 <span class="token operator">=</span> st_start_token_pos                num_patches <span class="token operator">=</span> cur_st_features<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                <span class="token keyword">if</span> cur_input_ids<span class="token punctuation">[</span>st_start_token_pos <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> st_tower<span class="token punctuation">.</span>config<span class="token punctuation">.</span>st_end_token<span class="token punctuation">:</span>                    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"The st end token should follow the st start token."</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> orig_embeds_params <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    cur_new_input_embeds <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>cur_input_embeds<span class="token punctuation">[</span><span class="token punctuation">:</span>st_start_token_pos<span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>st_start_token_pos<span class="token punctuation">:</span>st_start_token_pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_st_features<span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>st_start_token_pos <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    cur_new_input_embeds <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>cur_input_embeds<span class="token punctuation">[</span><span class="token punctuation">:</span>st_start_token_pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_st_features<span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>st_start_token_pos <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                     dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>                cur_st_idx <span class="token operator">+=</span> <span class="token number">1</span>            new_input_embeds<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_new_input_embeds<span class="token punctuation">)</span>        <span class="token keyword">assert</span> cur_st_idx <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>st_projector_out<span class="token punctuation">)</span>        <span class="token comment"># 输入embedding替换为缝合了时空编码信息的embedding</span>        inputs_embeds <span class="token operator">=</span> torch<span class="token punctuation">.</span>stack<span class="token punctuation">(</span>new_input_embeds<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># 调用llama的前向传播过程，解码输入信息</span>    <span class="token keyword">return</span> <span class="token builtin">super</span><span class="token punctuation">(</span>STLlamaModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>forward<span class="token punctuation">(</span>        input_ids<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> attention_mask<span class="token operator">=</span>attention_mask<span class="token punctuation">,</span> past_key_values<span class="token operator">=</span>past_key_values<span class="token punctuation">,</span>        inputs_embeds<span class="token operator">=</span>inputs_embeds<span class="token punctuation">,</span> use_cache<span class="token operator">=</span>use_cache<span class="token punctuation">,</span>        <span class="token comment"># 隐层也要输出，所以有这个参数</span>        output_attentions<span class="token operator">=</span>output_attentions<span class="token punctuation">,</span> output_hidden_states<span class="token operator">=</span>output_hidden_states<span class="token punctuation">,</span>        return_dict<span class="token operator">=</span>return_dict    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="主体模型-前向传播"><a href="#主体模型-前向传播" class="headerlink" title="主体模型 前向传播"></a>主体模型 前向传播</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 对时空信息的处理，包括时空特征的提取、投影和整合，以及更新输入嵌入表示后的模型正常前向传播过程</span>  <span class="token comment"># 根据分类和回归损失对STLlama的时空相关部分进行梯度更新</span>  <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>          self<span class="token punctuation">,</span>          input_ids<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>LongTensor <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 输入标记的ID</span>          attention_mask<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 注意力遮罩</span>          past_key_values<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>List<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 过去的键值</span>          inputs_embeds<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 输入的嵌入表示</span>          labels<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 标签（用于计算损失）</span>          use_cache<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 是否使用缓存</span>          output_attentions<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 输出注意力权重</span>          output_hidden_states<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 输出隐藏状态</span>          st_data_x<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 时序数据</span>          st_data_y<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 时序数据的标签</span>          <span class="token comment"># x和y要送入STLlama执行时空编码，编码后经过线性层 st_projector 处理得到投影的结果，然后将其与文本嵌入拼接形成新的嵌入，送入大模型</span>          region_start<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment"># 区域开始位置</span>          region_end<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment"># 区域结束位置</span>          return_dict<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 是否返回字典形式的输出</span>  <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Union<span class="token punctuation">[</span>Tuple<span class="token punctuation">,</span> CausalLMOutputWithPast<span class="token punctuation">]</span><span class="token punctuation">:</span>      output_attentions <span class="token operator">=</span> output_attentions <span class="token keyword">if</span> output_attentions <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>output_attentions      output_hidden_states <span class="token operator">=</span> <span class="token punctuation">(</span>          output_hidden_states <span class="token keyword">if</span> output_hidden_states <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>output_hidden_states      <span class="token punctuation">)</span>      return_dict <span class="token operator">=</span> return_dict <span class="token keyword">if</span> return_dict <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>use_return_dict      <span class="token comment"># STllama解码器的输出包括(dec_features, layer_state, dec_hidden, dec_attn)</span>      outputs <span class="token operator">=</span> self<span class="token punctuation">.</span>model<span class="token punctuation">(</span>          input_ids<span class="token operator">=</span>input_ids<span class="token punctuation">,</span>          attention_mask<span class="token operator">=</span>attention_mask<span class="token punctuation">,</span>          past_key_values<span class="token operator">=</span>past_key_values<span class="token punctuation">,</span>          inputs_embeds<span class="token operator">=</span>inputs_embeds<span class="token punctuation">,</span>          use_cache<span class="token operator">=</span>use_cache<span class="token punctuation">,</span>          output_attentions<span class="token operator">=</span>output_attentions<span class="token punctuation">,</span>          output_hidden_states<span class="token operator">=</span>output_hidden_states<span class="token punctuation">,</span>          return_dict<span class="token operator">=</span>return_dict<span class="token punctuation">,</span>          st_data_x<span class="token operator">=</span>st_data_x<span class="token punctuation">,</span>          st_data_y<span class="token operator">=</span>st_data_y<span class="token punctuation">,</span>          region_start<span class="token operator">=</span>region_start<span class="token punctuation">,</span>          region_end<span class="token operator">=</span>region_end      <span class="token punctuation">)</span>      feature_nums <span class="token operator">=</span> <span class="token number">2</span>      hidden_states <span class="token operator">=</span> outputs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># STllama解码的隐层</span>      batch_size <span class="token operator">=</span> hidden_states<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token comment"># =========通过自定义的回归层对hidden_state投影及预测部分做回归预测，然后比较和label之间的误差，</span>      <span class="token comment"># 同时融合大模型隐层预测的结果logits的误差，综合回归+分类+文本生成误差，更新梯度===========</span>      <span class="token comment"># 隐层做全连接得到最终st_pre结果</span>      <span class="token keyword">if</span> labels <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>          <span class="token comment"># 从 hidden_states 中切片出start-end对应的部分（分别是待预测序列，预测表征序列），并将其转换成训练表征 st_pre_embs1 和 st_pre_embs2。</span>          <span class="token comment"># 对 st_pre_embs1 和 st_pre_embs2 分别进行线性变换和relu激活函数操作，得到 st_pre_out1 和 st_pre_out2。</span>          st_pre_embs1 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>                         self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id0 <span class="token operator">+</span> feature_nums <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> feature_nums<span class="token punctuation">,</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>          <span class="token comment"># # [4, 1, 2, 4096]--&gt;[4, 1, 2, 128]</span>          st_pre_out1 <span class="token operator">=</span> self<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>st_pred_linear_1<span class="token punctuation">(</span>st_pre_embs1<span class="token punctuation">)</span><span class="token punctuation">)</span>          st_pre_embs2 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>                         self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id1 <span class="token operator">+</span> feature_nums <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> feature_nums<span class="token punctuation">,</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>          <span class="token comment"># # [4, 1, 2, 4096]--&gt;[4, 1, 2, 128]</span>          st_pre_out2 <span class="token operator">=</span> self<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>st_pred_linear_3<span class="token punctuation">(</span>st_pre_embs2<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment"># 将 st_pre_out1 和 st_pre_out2 拼接起来，并经过另一个线性变换得到最终结果 st_pre_final。</span>          <span class="token comment"># # [4, 1, 2, 256]--&gt;[4, 1, 2, 12]</span>          st_pre_final <span class="token operator">=</span> self<span class="token punctuation">.</span>st_pred_linear_2<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>st_pre_out1<span class="token punctuation">,</span> st_pre_out2<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment"># # [4, 1, 2, 12]--&gt;[4, 1, 12, 2]</span>          st_pre_final <span class="token operator">=</span> st_pre_final<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>   <span class="token comment"># 测试，而非训练</span>          self<span class="token punctuation">.</span>st_pre_res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>hidden_states<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment"># 线性层，lm_head将隐层特征映射到词表</span>      logits <span class="token operator">=</span> self<span class="token punctuation">.</span>lm_head<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span>      loss <span class="token operator">=</span> <span class="token boolean">None</span>      <span class="token keyword">if</span> labels <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>  <span class="token comment"># 训练过程</span>          <span class="token comment"># Shift so that tokens &lt; n predict n</span>          shift_logits <span class="token operator">=</span> logits<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span>          shift_labels <span class="token operator">=</span> labels<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment"># Flatten the tokens</span>          loss_fct <span class="token operator">=</span> CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># fct，交叉熵</span>          rec_loss <span class="token operator">=</span> scaler_mae_loss<span class="token punctuation">(</span>scaler<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> mask_value<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>    <span class="token comment">#MAE</span>          bce_loss <span class="token operator">=</span> BCEWithLogitsLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>          shift_logits <span class="token operator">=</span> shift_logits<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>vocab_size<span class="token punctuation">)</span>          shift_labels <span class="token operator">=</span> shift_labels<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>          <span class="token comment"># Enable model/pipeline parallelism</span>          shift_labels <span class="token operator">=</span> shift_labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>shift_logits<span class="token punctuation">.</span>device<span class="token punctuation">)</span>          <span class="token comment"># 处理标签</span>          <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>st_data_y<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>              st_data_y <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>st_data_y<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>              labels_stpre <span class="token operator">=</span> st_data_y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>region_end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">:</span>feature_nums<span class="token punctuation">]</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>                  torch<span class="token punctuation">.</span>bfloat16<span class="token punctuation">)</span>              task_type_all <span class="token operator">=</span> st_data_y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>              labels_stpre <span class="token operator">=</span> st_data_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>region_end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">:</span>feature_nums<span class="token punctuation">]</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>                  torch<span class="token punctuation">.</span>bfloat16<span class="token punctuation">)</span>              task_type_all <span class="token operator">=</span> st_data_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>          regress_idx_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          classificate_idx_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          regress_result_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          classificate_result_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>              task_type <span class="token operator">=</span> task_type_all<span class="token punctuation">[</span>i<span class="token punctuation">]</span>              <span class="token comment"># classification</span>              <span class="token keyword">if</span> task_type <span class="token operator">==</span> <span class="token number">3</span> <span class="token keyword">or</span> task_type <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>                  classificate_idx_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                  regress_result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st_pre_final<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                  classificate_result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st_pre_final<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span>              <span class="token comment"># regression</span>              <span class="token keyword">else</span><span class="token punctuation">:</span>                  regress_idx_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                  classificate_result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st_pre_final<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                  regress_result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st_pre_final<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span>          regress_result <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>regress_result_list<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>          classificate_result <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>classificate_result_list<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>          <span class="token comment"># 回归损失--MAE</span>          loss_regress <span class="token operator">=</span> rec_loss<span class="token punctuation">(</span>regress_result<span class="token punctuation">,</span> labels_stpre<span class="token punctuation">)</span>          labels_classificate <span class="token operator">=</span> labels_stpre          labels_classificate<span class="token punctuation">[</span>labels_classificate <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>          labels_classificate<span class="token punctuation">[</span>labels_classificate <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>          <span class="token comment"># 分类损失bce</span>          loss_classificate <span class="token operator">=</span> bce_loss<span class="token punctuation">(</span>classificate_result<span class="token punctuation">,</span> labels_classificate<span class="token punctuation">)</span>          <span class="token comment"># 综合损失</span>          loss <span class="token operator">=</span> loss_fct<span class="token punctuation">(</span>shift_logits<span class="token punctuation">,</span> shift_labels<span class="token punctuation">)</span> <span class="token operator">+</span> loss_regress <span class="token operator">+</span> loss_classificate      <span class="token keyword">if</span> <span class="token keyword">not</span> return_dict<span class="token punctuation">:</span>          <span class="token comment"># print('not return dict')</span>          output <span class="token operator">=</span> <span class="token punctuation">(</span>logits<span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token operator">+</span> outputs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>          <span class="token keyword">print</span><span class="token punctuation">(</span>loss<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token punctuation">(</span>loss<span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token operator">+</span> output <span class="token keyword">if</span> loss <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> output      <span class="token keyword">return</span> CausalLMOutputWithPast<span class="token punctuation">(</span>          loss<span class="token operator">=</span>loss<span class="token punctuation">,</span>          logits<span class="token operator">=</span>logits<span class="token punctuation">,</span>          past_key_values<span class="token operator">=</span>outputs<span class="token punctuation">.</span>past_key_values<span class="token punctuation">,</span>          hidden_states<span class="token operator">=</span>outputs<span class="token punctuation">.</span>hidden_states<span class="token punctuation">,</span>          attentions<span class="token operator">=</span>outputs<span class="token punctuation">.</span>attentions<span class="token punctuation">,</span>      <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="评估-1"><a href="#评估-1" class="headerlink" title="评估"></a>评估</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@ray<span class="token punctuation">.</span>remote</span><span class="token punctuation">(</span>num_gpus<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@torch<span class="token punctuation">.</span>inference_mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">eval_model</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> prompt_file<span class="token punctuation">,</span> start_idx<span class="token punctuation">,</span> end_idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># load prompting file</span>    <span class="token comment"># prompt_file = load_prompting_file(args.prompting_file)</span>    <span class="token comment"># Model</span>    disable_torch_init<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># model_name = os.path.expanduser(args.model_name)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'start loading'</span><span class="token punctuation">)</span>    <span class="token comment"># 加载预训练的tokenizer，用于对输入文本进行编码</span>    tokenizer <span class="token operator">=</span> AutoTokenizer<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>args<span class="token punctuation">.</span>model_name<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'finish loading'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'start loading'</span><span class="token punctuation">)</span>    <span class="token comment"># 加载预训练的时空语言模型</span>    model <span class="token operator">=</span> STLlamaForCausalLM<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>args<span class="token punctuation">.</span>model_name<span class="token punctuation">,</span> torch_dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>bfloat16<span class="token punctuation">,</span> use_cache<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                                                  low_cpu_mem_usage<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 设置时空依赖编码器</span>    model<span class="token punctuation">.</span>set_st_tower<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'finish loading'</span><span class="token punctuation">)</span>    <span class="token comment"># 根据模型配置，调整tokenizer的词汇表，添加时空相关的特殊标记。</span>    use_st_start_end <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>config<span class="token punctuation">,</span> <span class="token string">"use_st_start_end"</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>    tokenizer<span class="token punctuation">.</span>add_tokens<span class="token punctuation">(</span><span class="token punctuation">[</span>DEFAULT_ST_PATCH_TOKEN<span class="token punctuation">]</span><span class="token punctuation">,</span> special_tokens<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> use_st_start_end<span class="token punctuation">:</span>        tokenizer<span class="token punctuation">.</span>add_tokens<span class="token punctuation">(</span><span class="token punctuation">[</span>DEFAULT_ST_START_TOKEN<span class="token punctuation">,</span> DEFAULT_ST_END_TOKEN<span class="token punctuation">]</span><span class="token punctuation">,</span> special_tokens<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    st_tower <span class="token operator">=</span> model<span class="token punctuation">.</span>get_model<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_tower    <span class="token comment"># 配置编码器</span>    st_config <span class="token operator">=</span> st_tower<span class="token punctuation">.</span>config    st_config<span class="token punctuation">.</span>st_patch_token <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>convert_tokens_to_ids<span class="token punctuation">(</span><span class="token punctuation">[</span>DEFAULT_ST_PATCH_TOKEN<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 配置中的token使用对应词汇在词表中的id</span>    st_config<span class="token punctuation">.</span>use_st_start_end <span class="token operator">=</span> use_st_start_end    <span class="token keyword">if</span> use_st_start_end<span class="token punctuation">:</span>        st_config<span class="token punctuation">.</span>st_start_token<span class="token punctuation">,</span> st_config<span class="token punctuation">.</span>st_end_token <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>convert_tokens_to_ids<span class="token punctuation">(</span>            <span class="token punctuation">[</span>DEFAULT_ST_START_TOKEN<span class="token punctuation">,</span> DEFAULT_ST_END_TOKEN<span class="token punctuation">]</span><span class="token punctuation">)</span>    res_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'total: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token builtin">len</span><span class="token punctuation">(</span>prompt_file<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>st_data_path<span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>        st_data_all <span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span>    error_i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> idx<span class="token punctuation">,</span> instruct_item <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span>prompt_file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 使用load_st加载时空数据，包括时空标记长度、时空数据x和y的编码信息、时空区域的起始和结束位置等</span>        <span class="token comment"># prompt file对应的instruct item：NYC_taxi.json</span>        <span class="token comment"># st_data：pkl文件，存储已经训练好的时序编码信息</span>        st_dict <span class="token operator">=</span> load_st<span class="token punctuation">(</span>idx<span class="token punctuation">,</span> instruct_item<span class="token punctuation">,</span> st_data_all<span class="token punctuation">)</span>        st_token_len <span class="token operator">=</span> st_dict<span class="token punctuation">[</span><span class="token string">'st_token_len'</span><span class="token punctuation">]</span>        st_data_x <span class="token operator">=</span> st_dict<span class="token punctuation">[</span><span class="token string">'st_data_x'</span><span class="token punctuation">]</span>        st_data_y <span class="token operator">=</span> st_dict<span class="token punctuation">[</span><span class="token string">'st_data_y'</span><span class="token punctuation">]</span>        region_start <span class="token operator">=</span> st_dict<span class="token punctuation">[</span><span class="token string">'region_start'</span><span class="token punctuation">]</span>        region_end <span class="token operator">=</span> st_dict<span class="token punctuation">[</span><span class="token string">'region_end'</span><span class="token punctuation">]</span>        <span class="token comment"># 自然语言问题从instruct_item中提取</span>        qs <span class="token operator">=</span> instruct_item<span class="token punctuation">[</span><span class="token string">"conversations"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"value"</span><span class="token punctuation">]</span>        replace_token <span class="token operator">=</span> DEFAULT_ST_PATCH_TOKEN <span class="token operator">*</span> st_token_len        replace_token <span class="token operator">=</span> DEFAULT_ST_START_TOKEN <span class="token operator">+</span> replace_token <span class="token operator">+</span> DEFAULT_ST_END_TOKEN        qs <span class="token operator">=</span> qs<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>DEFAULT_STHIS_TOKEN<span class="token punctuation">,</span> replace_token<span class="token punctuation">)</span>        qs <span class="token operator">=</span> qs<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>DEFAULT_STPRE_TOKEN<span class="token punctuation">,</span> replace_token<span class="token punctuation">)</span>        <span class="token comment"># if "v1" in args.model_name.lower():</span>        <span class="token comment">#     conv_mode = "stchat_v1"</span>        <span class="token comment"># else:</span>        <span class="token comment">#     raise ValueError('Don\'t support this model')</span>        conv_mode <span class="token operator">=</span> <span class="token string">"stchat_v1"</span>        <span class="token keyword">if</span> args<span class="token punctuation">.</span>conv_mode <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> conv_mode <span class="token operator">!=</span> args<span class="token punctuation">.</span>conv_mode<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[WARNING] the auto inferred conversation mode is {}, while `--conv-mode` is {}, using {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>                conv_mode<span class="token punctuation">,</span> args<span class="token punctuation">.</span>conv_mode<span class="token punctuation">,</span> args<span class="token punctuation">.</span>conv_mode<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            args<span class="token punctuation">.</span>conv_mode <span class="token operator">=</span> conv_mode        conv <span class="token operator">=</span> conv_templates<span class="token punctuation">[</span>args<span class="token punctuation">.</span>conv_mode<span class="token punctuation">]</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        conv<span class="token punctuation">.</span>append_message<span class="token punctuation">(</span>conv<span class="token punctuation">.</span>roles<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> qs<span class="token punctuation">)</span>  <span class="token comment"># 为用户角色添加qs问题</span>        conv<span class="token punctuation">.</span>append_message<span class="token punctuation">(</span>conv<span class="token punctuation">.</span>roles<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>        prompt <span class="token operator">=</span> conv<span class="token punctuation">.</span>get_prompt<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 对prompt编码</span>        inputs <span class="token operator">=</span> tokenizer<span class="token punctuation">(</span><span class="token punctuation">[</span>prompt<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 输入张量</span>        input_ids <span class="token operator">=</span> torch<span class="token punctuation">.</span>as_tensor<span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>input_ids<span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 停用词</span>        stop_str <span class="token operator">=</span> conv<span class="token punctuation">.</span>sep <span class="token keyword">if</span> conv<span class="token punctuation">.</span>sep_style <span class="token operator">!=</span> SeparatorStyle<span class="token punctuation">.</span>TWO <span class="token keyword">else</span> conv<span class="token punctuation">.</span>sep2        keywords <span class="token operator">=</span> <span class="token punctuation">[</span>stop_str<span class="token punctuation">]</span>        stopping_criteria <span class="token operator">=</span> KeywordsStoppingCriteria<span class="token punctuation">(</span>keywords<span class="token punctuation">,</span> tokenizer<span class="token punctuation">,</span> input_ids<span class="token punctuation">)</span>        <span class="token keyword">with</span> torch<span class="token punctuation">.</span>inference_mode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 大模型解码，生成预测文本tokens的id序列</span>            output_ids <span class="token operator">=</span> model<span class="token punctuation">.</span>generate<span class="token punctuation">(</span>                input_ids<span class="token punctuation">,</span>                <span class="token comment"># st_data=st_data_x,</span>                st_data_x<span class="token operator">=</span>st_data_x<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                st_data_y<span class="token operator">=</span>st_data_y<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                region_start<span class="token operator">=</span>region_start<span class="token punctuation">,</span>                region_end<span class="token operator">=</span>region_end<span class="token punctuation">,</span>                do_sample<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                <span class="token comment"># do_sample=False,</span>                <span class="token comment"># temperature=0.2,</span>                temperature<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span>                <span class="token comment"># max_new_tokens=1024,</span>                max_new_tokens<span class="token operator">=</span><span class="token number">256</span><span class="token punctuation">,</span>                stopping_criteria<span class="token operator">=</span><span class="token punctuation">[</span>stopping_criteria<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment"># 找到自定义的special token</span>            start_inx <span class="token operator">=</span> torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>output_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">32001</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            end_inx <span class="token operator">=</span> torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>output_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">32002</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token comment"># 获取隐层状态</span>            hidden_states <span class="token operator">=</span> model<span class="token punctuation">.</span>get_st_pre_res<span class="token punctuation">(</span><span class="token punctuation">)</span>            hidden_states <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>hidden_states<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>            model<span class="token punctuation">.</span>reset_st_pre_res<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 将tokens解码为输出结果</span>            batch_size <span class="token operator">=</span> hidden_states<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            feature_nums <span class="token operator">=</span> <span class="token number">2</span>            st_pre_embs1 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>                           model<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>model<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id0 <span class="token operator">+</span> feature_nums <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                           <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> feature_nums<span class="token punctuation">,</span> model<span class="token punctuation">.</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>            <span class="token comment"># 通过一个线性层获取结果</span>            st_pre_out1 <span class="token operator">=</span> model<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>model<span class="token punctuation">.</span>st_pred_linear_1<span class="token punctuation">(</span>st_pre_embs1<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> start_inx<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> hidden_states<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> start_inx<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> feature_nums<span class="token punctuation">:</span>                    st_pre_embs2 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> start_inx<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>start_inx<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> feature_nums<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'========error========'</span><span class="token punctuation">)</span>                    error_i <span class="token operator">=</span> error_i <span class="token operator">+</span> <span class="token number">1</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span>error_i<span class="token punctuation">)</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span>hidden_states<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> start_inx<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                    st_pre_embs2 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span>feature_nums<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'========error========'</span><span class="token punctuation">)</span>                error_i <span class="token operator">=</span> error_i <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>error_i<span class="token punctuation">)</span>                st_pre_embs2 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span>feature_nums<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>            st_pre_embs2 <span class="token operator">=</span> st_pre_embs2<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> feature_nums<span class="token punctuation">,</span> model<span class="token punctuation">.</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>            st_pre_out2 <span class="token operator">=</span> model<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>model<span class="token punctuation">.</span>st_pred_linear_3<span class="token punctuation">(</span>st_pre_embs2<span class="token punctuation">)</span><span class="token punctuation">)</span>            st_pre_final <span class="token operator">=</span> model<span class="token punctuation">.</span>st_pred_linear_2<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>st_pre_out1<span class="token punctuation">,</span> st_pre_out2<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            st_pre_final <span class="token operator">=</span> st_pre_final<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>            st_pre_infolow <span class="token operator">=</span> st_pre_final<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>            st_pre_outfolow <span class="token operator">=</span> st_pre_final<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>        x_in<span class="token punctuation">,</span> y_in <span class="token operator">=</span> st_data_x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">:</span>region_end<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> st_data_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">:</span>region_end<span class="token punctuation">,</span>                                                                           <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>        x_out<span class="token punctuation">,</span> y_out <span class="token operator">=</span> st_data_x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">:</span>region_end<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> st_data_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">:</span>region_end<span class="token punctuation">,</span>                                                                             <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>        input_token_len <span class="token operator">=</span> input_ids<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        n_diff_input_output <span class="token operator">=</span> <span class="token punctuation">(</span>input_ids <span class="token operator">!=</span> output_ids<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span>input_token_len<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> n_diff_input_output <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'[Warning] </span><span class="token interpolation"><span class="token punctuation">{</span>n_diff_input_output<span class="token punctuation">}</span></span><span class="token string"> output_ids are not the same as the input_ids'</span></span><span class="token punctuation">)</span>        <span class="token comment"># outputs = tokenizer.batch_decode(output_ids[:, input_token_len:], skip_special_tokens=True)[0]</span>        outputs <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_decode<span class="token punctuation">(</span>output_ids<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> input_token_len<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> skip_special_tokens<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        outputs <span class="token operator">=</span> outputs<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> outputs<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span>stop_str<span class="token punctuation">)</span><span class="token punctuation">:</span>            outputs <span class="token operator">=</span> outputs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token builtin">len</span><span class="token punctuation">(</span>stop_str<span class="token punctuation">)</span><span class="token punctuation">]</span>        outputs <span class="token operator">=</span> outputs<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        res_data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>            <span class="token punctuation">{</span><span class="token string">"id"</span><span class="token punctuation">:</span> instruct_item<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"res"</span><span class="token punctuation">:</span> outputs<span class="token punctuation">,</span> <span class="token string">"x_in"</span><span class="token punctuation">:</span> x_in<span class="token punctuation">,</span> <span class="token string">"x_out"</span><span class="token punctuation">:</span> x_out<span class="token punctuation">,</span> <span class="token string">"y_in"</span><span class="token punctuation">:</span> y_in<span class="token punctuation">,</span> <span class="token string">"y_out"</span><span class="token punctuation">:</span> y_out<span class="token punctuation">,</span>             <span class="token string">"st_pre_infolow"</span><span class="token punctuation">:</span> st_pre_infolow<span class="token punctuation">,</span> <span class="token string">"st_pre_outfolow"</span><span class="token punctuation">:</span> st_pre_outfolow<span class="token punctuation">}</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>osp<span class="token punctuation">.</span>join<span class="token punctuation">(</span>args<span class="token punctuation">.</span>output_res_path<span class="token punctuation">,</span> <span class="token string">'arxiv_test_res_{}_{}.json'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>start_idx<span class="token punctuation">,</span> end_idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fout<span class="token punctuation">:</span>            json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>res_data<span class="token punctuation">,</span> fout<span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> res_data    <span class="token comment"># with open(args.output_res_path, "w") as fout:</span>    <span class="token comment">#     json.dump(res_data, fout, indent=4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></span>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 时间序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2024/04/26/mysql/"/>
      <url>/2024/04/26/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><img src="/2024/04/26/mysql/image-20240426154008919.png" alt="image-20240426154008919" style="zoom: 80%;"><blockquote><p><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</p><p><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</p><p><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</p><p><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</p></blockquote><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><ul><li><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p></li><li><p>NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p></li><li><p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p></li></ul><img src="/2024/04/26/mysql/sql-nosql-tushi.png" alt="img"><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p><p><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</p><p><strong>可扩展性：</strong> NoSQL 数据库通常被设计为<strong>通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</strong></p><p><strong>高性能：</strong> NoSQL 数据库<strong>针对特定的数据模型和访问模式进行了优化</strong>，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</p><p><strong>强大的功能：</strong> NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</p><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ul><li>关系型数据库（RDB，Relational Database）就是一种<strong>建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</strong>关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</li><li>关系型数据库中，我们的数据都被存放在了各种二维表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</li><li>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</li></ul><p>目前主流的<strong>关系型数据库管理系统</strong>的市场占有率排名如下：</p><img src="/2024/04/26/mysql/image-20240426154125989.png" alt="image-20240426154125989"><ul><li>Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。</li><li>MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。</li><li>SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。</li><li>PostgreSQL：开源免费的中小型数据库。</li><li>DB2：IBM公司的大型收费数据库产品。</li><li>SQLLite：嵌入式的微型数据库。Android内置的数据库以及微信本地的聊天记录存储采用的就是该数据库。</li><li>MariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、另外一个衍生产品，与MySQL数据库有很好的兼容性。</li></ul><h3 id="关系型-vs-非关系型"><a href="#关系型-vs-非关系型" class="headerlink" title="关系型 vs 非关系型"></a>关系型 vs 非关系型</h3><img src="/2024/04/26/mysql/image-20240426163636208.png" alt="image-20240426163636208"><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一<strong>标准</strong> 。</p><p>1). SQL语句可以单行或多行书写，以分号结尾。</p><p>2). SQL语句可以使用空格/缩进来增强语句的可读性。</p><p>3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</p><p>4). 注释：单行注释：– 注释内容 或 # 注释内容多行注释：/* 注释内容 */</p><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL</p><img src="/2024/04/26/mysql/image-20240426170912537.png" alt="image-20240426170912537" style="zoom: 80%;"><h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">--------------数据库操作---------------------</span><span class="token keyword">show</span> <span class="token keyword">databases</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 当前数据库</span><span class="token keyword">create</span> <span class="token keyword">database</span> <span class="token punctuation">[</span> <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token keyword">exists</span> <span class="token punctuation">]</span> 数据库名 <span class="token punctuation">[</span> <span class="token keyword">default</span> <span class="token keyword">charset</span> 字符集 <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token keyword">collate</span> 排序规则 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">database</span> <span class="token punctuation">[</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> <span class="token punctuation">]</span> 数据库名 <span class="token punctuation">;</span><span class="token keyword">use</span> 数据库名 <span class="token punctuation">;</span><span class="token comment">-----------------表操作---------------------</span><span class="token keyword">show</span> <span class="token keyword">tables</span><span class="token punctuation">;</span><span class="token keyword">desc</span> 表名 <span class="token punctuation">;</span> <span class="token comment">#查看表结构</span><span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> 表名 <span class="token punctuation">;</span><span class="token comment"># 查询指定表的建表语句</span><span class="token keyword">create</span> <span class="token keyword">table</span> emp<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token keyword">comment</span> <span class="token string">'编号'</span><span class="token punctuation">,</span>    workno <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'工号'</span><span class="token punctuation">,</span>    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'姓名'</span><span class="token punctuation">,</span>    gender <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'性别'</span><span class="token punctuation">,</span>    age <span class="token keyword">tinyint</span> <span class="token keyword">unsigned</span> <span class="token keyword">comment</span> <span class="token string">'年龄'</span><span class="token punctuation">,</span>    idcard <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'身份证号'</span><span class="token punctuation">,</span>    entrydate <span class="token keyword">date</span> <span class="token keyword">comment</span> <span class="token string">'入职时间'</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'员工表'</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> 字段名 类型 <span class="token punctuation">(</span>长度<span class="token punctuation">)</span> <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 注释 <span class="token punctuation">]</span> <span class="token punctuation">[</span> 约束 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment"># 添加字段</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> emp <span class="token keyword">ADD</span> nickname <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'昵称'</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">MODIFY</span> 字段名 新数据类型 <span class="token punctuation">(</span>长度<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 修改字段类型</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型 <span class="token punctuation">(</span>长度<span class="token punctuation">)</span> <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 注释 <span class="token punctuation">]</span> <span class="token punctuation">[</span> 约束 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> emp CHANGE nickname username <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'昵称'</span><span class="token punctuation">;</span> <span class="token number">1</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> 字段名<span class="token punctuation">;</span> <span class="token comment"># 删除字段</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">RENAME</span> <span class="token keyword">TO</span> 新表名<span class="token punctuation">;</span><span class="token comment"># 修改表名</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> 表名<span class="token punctuation">;</span><span class="token comment"># 删除表</span><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">;</span><span class="token comment"># 删除指定表, 并重新创建表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><table><thead><tr><th>类型</th><th>大小</th><th>有符号(SIGNED)范围</th><th>无符号(UNSIGNED)范围</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1byte</td><td>(-128,127)</td><td>(0,255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2bytes</td><td>(-32768,32767)</td><td>(0,65535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3bytes</td><td>(-8388608,8388607)</td><td>(0,16777215)</td><td>大整数值</td></tr><tr><td>INT/INTEGER</td><td>4bytes</td><td>(-2147483648  2147483647)</td><td>(0,4294967295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8bytes</td><td>(-2^63,2^63-1)</td><td>(0,2^64-1)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4bytes</td><td>(-3.402823466 E+38,  3.402823466351 E+38)</td><td>0和(1.175494351 E-38,3.402823466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8bytes</td><td>(-1.7976931348623157  E+308,  1.7976931348623157  E+308)</td><td>0和  (2.2250738585072014  E-308,  1.7976931348623157  E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td></td><td>依赖于M(精度)和D(标度）的值</td><td>依赖于M(精度)和D(标度)的值</td><td>小数值(精确定 点数)</td></tr></tbody></table><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><img src="/2024/04/26/mysql/image-20240505120222157.png" alt="image-20240505120222157"><p><strong>char是定长字符串</strong>，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char性能更好。</p><h4 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h4><img src="/2024/04/26/mysql/image-20240505124939337.png"><h3 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a>DML 数据操作语言</h3><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token punctuation">(</span>字段名<span class="token number">1</span><span class="token punctuation">,</span> 字段名<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment"># 批量添加</span><span class="token keyword">insert</span> <span class="token keyword">into</span> employee<span class="token punctuation">(</span>id<span class="token punctuation">,</span>workno<span class="token punctuation">,</span>name<span class="token punctuation">,</span>gender<span class="token punctuation">,</span>age<span class="token punctuation">,</span>idcard<span class="token punctuation">,</span>entrydate<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'Itcast'</span><span class="token punctuation">,</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'123456789012345678'</span><span class="token punctuation">,</span><span class="token string">'2000-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> 表名 <span class="token keyword">SET</span> 字段名<span class="token number">1</span> <span class="token operator">=</span> 值<span class="token number">1</span> <span class="token punctuation">,</span> 字段名<span class="token number">2</span> <span class="token operator">=</span> 值<span class="token number">2</span> <span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">[</span> <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token keyword">update</span> employee <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'小昭'</span> <span class="token punctuation">,</span> gender <span class="token operator">=</span> <span class="token string">'女'</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 表名 <span class="token punctuation">[</span> <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token keyword">delete</span> <span class="token keyword">from</span> employee <span class="token keyword">where</span> gender <span class="token operator">=</span> <span class="token string">'女'</span><span class="token punctuation">;</span><span class="token comment"># 删除一条数据</span><span class="token keyword">delete</span> <span class="token keyword">from</span> employee<span class="token punctuation">;</span><span class="token comment"># 删除所有员工数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL 数据查询语言"></a>DQL 数据查询语言</h3><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>字段列表<span class="token keyword">FROM</span>表名列表<span class="token keyword">WHERE</span>条件列表<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>分组字段列表<span class="token keyword">HAVING</span>分组后条件列表<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>排序字段列表<span class="token keyword">LIMIT</span>分页参数<span class="token keyword">SELECT</span> 字段<span class="token number">1</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token keyword">AS</span><span class="token punctuation">)</span> 别名<span class="token number">1</span> <span class="token punctuation">]</span> <span class="token punctuation">,</span> 字段<span class="token number">2</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token keyword">AS</span><span class="token punctuation">)</span> 别名<span class="token number">2</span> <span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> 表名<span class="token punctuation">;</span><span class="token comment"># 别名，as可以省略</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> 字段列表 <span class="token keyword">FROM</span> 表名<span class="token punctuation">;</span><span class="token comment"># 去除重复记录</span><span class="token comment"># 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</span><span class="token keyword">select</span> workaddress<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> address_count <span class="token keyword">from</span> emp <span class="token keyword">where</span> age <span class="token operator">&lt;</span> <span class="token number">45</span> <span class="token keyword">group</span> <span class="token keyword">by</span> workaddress <span class="token keyword">having</span> address_count <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表名 <span class="token keyword">LIMIT</span> 起始索引<span class="token punctuation">,</span> 查询记录数 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>where与having区别</li><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li><li><strong>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</strong></li></ul><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><img src="/2024/04/26/mysql/image-20240505180928668.png" alt="image-20240505180928668" style="zoom:80%;"><h3 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL 数据控制语言"></a>DCL 数据控制语言</h3><p>DCL英文全称是<strong>Data Control Language</strong>(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment"># 查询用户</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 User代表的是访问该数据库的用户名。在MySQL中<strong>需要通过Host和User来唯一标识一个用户。</strong></p><img src="/2024/04/26/mysql/image-20240505181311834.png"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'密码'</span><span class="token punctuation">;</span><span class="token comment"># 创建用户</span><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span> IDENTIFIED <span class="token keyword">WITH</span> mysql_native_password <span class="token keyword">BY</span> <span class="token string">'新密码'</span> <span class="token punctuation">;</span><span class="token comment"># 修改密码</span><span class="token keyword">DROP</span> <span class="token keyword">USER</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span> <span class="token punctuation">;</span><span class="token comment"># 删除用户主机名可以使用 % 通配。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><img src="/2024/04/26/mysql/image-20240505181611707.png" alt="image-20240505181611707" style="zoom: 67%;"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span> <span class="token punctuation">;</span><span class="token comment"># 查询权限</span><span class="token keyword">GRANT</span> 权限列表 <span class="token keyword">ON</span> 数据库名<span class="token punctuation">.</span>表名 <span class="token keyword">TO</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span><span class="token punctuation">;</span><span class="token comment"># 授予权限</span><span class="token keyword">REVOKE</span> 权限列表 <span class="token keyword">ON</span> 数据库名<span class="token punctuation">.</span>表名 <span class="token keyword">FROM</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span><span class="token punctuation">;</span><span class="token comment"># 撤销权限</span><span class="token keyword">show</span> grants <span class="token keyword">for</span> <span class="token string">'heima'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span class="token keyword">grant</span> <span class="token keyword">all</span> <span class="token keyword">on</span> itcast<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">to</span> <span class="token string">'heima'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span class="token comment"># 授予 'heima'@'%' 用户itcast数据库所有表的所有操作权限</span><span class="token keyword">revoke</span> <span class="token keyword">all</span> <span class="token keyword">on</span> itcast<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">'heima'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>多个权限之间，使用逗号分隔</p></li><li><p>授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><img src="/2024/04/26/mysql/image-20240507140710177.png" alt="image-20240507140710177" style="zoom: 67%;"><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><img src="/2024/04/26/mysql/image-20240507141021752.png" alt="image-20240507141021752" style="zoom: 67%;"><p>通过数据库的函数，生成一个六位数的随机验证码。</p><p>思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> lpad<span class="token punctuation">(</span><span class="token function">round</span><span class="token punctuation">(</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000000</span> <span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><img src="/2024/04/26/mysql/image-20240507141208167.png" alt="image-20240507141208167" style="zoom:67%;"><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><img src="/2024/04/26/mysql/image-20240507141452210.png" alt="image-20240507141452210" style="zoom:67%;"><p>需求: 查询emp表的员工姓名和工作地址 (北京/上海 —-&gt; 一线城市 , 其他 —-&gt; 二线城市)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span>    name<span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token keyword">case</span> workaddress <span class="token keyword">when</span> <span class="token string">'北京'</span> <span class="token keyword">then</span> <span class="token string">'一线城市'</span> <span class="token keyword">when</span> <span class="token string">'上海'</span> <span class="token keyword">then</span> <span class="token string">'一线城市'</span> <span class="token keyword">else</span>    <span class="token string">'二线城市'</span> <span class="token keyword">end</span> <span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token string">'工作地址'</span><span class="token keyword">from</span> emp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p><p>目的：保证数据库中数据的正确、有效性和完整性。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><img src="/2024/04/26/mysql/image-20240507143454084.png" alt="image-20240507143454084" style="zoom:80%;"><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><p>示例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tb_user<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">COMMENT</span> <span class="token string">'ID唯一标识'</span><span class="token punctuation">,</span>    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">COMMENT</span> <span class="token string">'姓名'</span> <span class="token punctuation">,</span>    age <span class="token keyword">int</span> <span class="token keyword">check</span> <span class="token punctuation">(</span>age <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> age <span class="token operator">&lt;=</span> <span class="token number">120</span><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'年龄'</span> <span class="token punctuation">,</span>    <span class="token keyword">status</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">'1'</span> <span class="token keyword">COMMENT</span> <span class="token string">'状态'</span><span class="token punctuation">,</span>    gender <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'性别'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/04/26/mysql/image-20240507143712836.png" alt="image-20240507143712836" style="zoom:80%;"><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">(</span>    字段名 数据类型<span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">[</span><span class="token keyword">CONSTRAINT</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>外键名称<span class="token punctuation">]</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>外键字段名<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> 主表 <span class="token punctuation">(</span>主表列名<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> 外键名称 <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>外键字段名<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> 主表 <span class="token punctuation">(</span>主表列名<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> emp <span class="token keyword">add</span> <span class="token keyword">constraint</span> fk_emp_dept_id <span class="token keyword">foreign</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>dept_id<span class="token punctuation">)</span> <span class="token keyword">references</span> dept<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> 外键名称<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/04/26/mysql/image-20240507144123244.png" style="zoom:80%;"><h4 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除/更新行为"></a>删除/更新行为</h4><p>添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行为有以下几种:</p><img src="/2024/04/26/mysql/image-20240507144346915.png" style="zoom:80%;"><p>语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> 外键名称 <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>外键字段<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span>主表名 <span class="token punctuation">(</span>主表字段名<span class="token punctuation">)</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CASCADE</span> <span class="token keyword">ON</span> <span class="token keyword">DELETE</span> <span class="token keyword">CASCADE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>执行多表查询，使用逗号分隔多张表，如： select * from emp , dept;  得到两表的<strong>笛卡尔积组合结果</strong></p><img src="/2024/04/26/mysql/image-20240507145729379.png" style="zoom:80%;"><p>在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。</p><p>select * from emp , dept where emp.dept_id = dept.id;</p><p>这种情况下，由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件没有查询到，也就不会显示在结果中。</p><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>连接查询<ul><li>内连接：相当于查询A、B<strong>交集部分</strong>数据–分为隐式内连接和显示内连接</li><li>外连接：</li><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li><li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 隐式内连接</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token punctuation">,</span> 表<span class="token number">2</span> <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token comment"># 显示内连接</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token punctuation">[</span> <span class="token keyword">INNER</span> <span class="token punctuation">]</span> <span class="token keyword">JOIN</span> 表<span class="token number">2</span> <span class="token keyword">ON</span> 连接条件 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token comment"># eg:</span><span class="token keyword">select</span> emp<span class="token punctuation">.</span>name <span class="token punctuation">,</span> dept<span class="token punctuation">.</span>name <span class="token keyword">from</span> emp <span class="token punctuation">,</span> dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> dept<span class="token punctuation">.</span>id <span class="token punctuation">;</span><span class="token keyword">select</span> e<span class="token punctuation">.</span>name<span class="token punctuation">,</span> d<span class="token punctuation">.</span>name <span class="token keyword">from</span> emp e <span class="token keyword">inner</span> <span class="token keyword">join</span> dept d <span class="token keyword">on</span> e<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token comment"># 左外连接</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token keyword">LEFT</span> <span class="token punctuation">[</span> <span class="token keyword">OUTER</span> <span class="token punctuation">]</span> <span class="token keyword">JOIN</span> 表<span class="token number">2</span> <span class="token keyword">ON</span> 条件 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span> <span class="token comment"># 右外连接</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token keyword">RIGHT</span> <span class="token punctuation">[</span> <span class="token keyword">OUTER</span> <span class="token punctuation">]</span> <span class="token keyword">JOIN</span> 表<span class="token number">2</span> <span class="token keyword">ON</span> 条件 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span> <span class="token comment"># 自连接</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表A 别名A <span class="token keyword">JOIN</span> 表A 别名B <span class="token keyword">ON</span> 条件 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token comment"># eg： 查询员工 及其 所属领导的名字</span><span class="token keyword">select</span> a<span class="token punctuation">.</span>name <span class="token punctuation">,</span> b<span class="token punctuation">.</span>name <span class="token keyword">from</span> emp a <span class="token punctuation">,</span> emp b <span class="token keyword">where</span> a<span class="token punctuation">.</span>managerid <span class="token operator">=</span> b<span class="token punctuation">.</span>id<span class="token punctuation">;</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表A <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">UNION</span> <span class="token punctuation">[</span> <span class="token keyword">ALL</span> <span class="token punctuation">]</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表B <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>对于联合查询的多张表的<strong>列数必须保持一致，字段类型也需要保持一致</strong>。</p></li><li><p><strong>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</strong></p></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> column1 <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> column1 <span class="token keyword">FROM</span> t2 <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。</p><p>eg：查询在 “方东白” 入职之后的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> entrydate <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">select</span> entrydate <span class="token keyword">from</span> emp <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'方东白'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p><img src="/2024/04/26/mysql/image-20240507152223041.png" style="zoom:80%;"><p> eg：查询比 财务部 所有人工资都高的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> salary <span class="token operator">&gt;</span> <span class="token keyword">all</span> <span class="token punctuation">(</span> <span class="token keyword">select</span> salary <span class="token keyword">from</span> emp <span class="token keyword">where</span> dept_id <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> dept <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'财务部'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p><p>eg：查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> <span class="token punctuation">(</span>salary<span class="token punctuation">,</span>managerid<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> salary<span class="token punctuation">,</span> managerid <span class="token keyword">from</span> emp<span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'张无忌'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>子查询返回的结果是多行多列，这种子查询称为表子查询。</p><p>eg：查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> <span class="token punctuation">(</span>job<span class="token punctuation">,</span>salary<span class="token punctuation">)</span> <span class="token operator">in</span> <span class="token punctuation">(</span> <span class="token keyword">select</span> job<span class="token punctuation">,</span> salary <span class="token keyword">from</span> emp <span class="token keyword">where</span> name <span class="token operator">=</span><span class="token string">'鹿杖客'</span> <span class="token operator">or</span> name <span class="token operator">=</span> <span class="token string">'宋远桥'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>eg：查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> e<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> entrydate <span class="token operator">&gt;</span> <span class="token string">'2006-01-01'</span><span class="token punctuation">)</span> e <span class="token keyword">left</span><span class="token keyword">join</span> dept d <span class="token keyword">on</span> e<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> d<span class="token punctuation">.</span>id <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务 是一组操作的集合，它是一个不可分割的工作单位</strong>，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>我们只需要在业务逻辑执行之前开启事务，执行完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。</p><h3 id="控制事务"><a href="#控制事务" class="headerlink" title="控制事务"></a>控制事务</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 设置事务提交方式</span><span class="token keyword">SELECT</span> @<span class="token variable">@autocommit</span> <span class="token punctuation">;</span><span class="token keyword">SET</span> @<span class="token variable">@autocommit</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span><span class="token comment"># 开启事务</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span> 或 <span class="token keyword">BEGIN</span> <span class="token punctuation">;</span><span class="token comment"># 提交事务</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token comment"># 回滚事务</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p><p>上述就是事务的四大特性，简称ACID。<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的。</strong></p><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><h4 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="脏读（Dirty read）"></a>脏读（Dirty read）</h4><p> 赃读：一个事务读到另外一个事务还没有提交的数据。（A写数据，没提交就被B读）</p><blockquote><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那<strong>第二个事务读取到的就是脏数</strong>据，这也就是脏读的由来。</p></blockquote><img src="https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading-C1rL9lNt.png" alt="脏读" style="zoom:80%;"><h4 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="丢失修改（Lost to modify）"></a>丢失修改（Lost to modify）</h4><p>（AB都读数据，然后同时写，造成写覆盖）</p><blockquote><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p></blockquote><img src="https://javaguide.cn/assets/concurrency-consistency-issues-missing-modifications-D4pIxvwj.png" alt="丢失修改" style="zoom:80%;"><h4 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="不可重复读（Unrepeatable read）"></a>不可重复读（Unrepeatable read）</h4><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。（B在一个事务内多次读数据，A在这个区间写数据，导致B读到不同数据）</p><blockquote><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p></blockquote><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-unrepeatable-read-RYuQTZvh.png" alt="不可重复读" style="zoom:80%;"><h4 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="幻读（Phantom read）"></a>幻读（Phantom read）</h4><p> 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。</p><p>（B在一个事务内多次读数据，A在这个区间内新增数据，导致B前后读到新增的数据）</p><blockquote><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p></blockquote><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-phantom-read-D-ETycCp.png" alt="幻读" style="zoom:80%;"><ul><li><strong>不可重复读的重点是内容修改或者记录减少</strong>比如多次读取一条记录发现其中某些记录的值被修改；</li><li><strong>幻读的重点在于记录新增</strong>比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是<strong>解决幻读和不可重复读的方案不一样</strong>。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种</p><ul><li><p><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p></li><li><p><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p></li><li><p><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p></li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 查看事务隔离级别</span><span class="token keyword">SELECT</span> @<span class="token variable">@TRANSACTION_ISOLATION</span><span class="token punctuation">;</span><span class="token comment"># 设置事务隔离级别  事务隔离级别越高，数据越安全，但是性能越低。</span><span class="token keyword">SET</span> <span class="token punctuation">[</span> <span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span> <span class="token punctuation">]</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> { <span class="token keyword">READ</span> <span class="token keyword">UNCOMMITTED</span> <span class="token operator">|</span><span class="token keyword">READ</span> <span class="token keyword">COMMITTED</span> <span class="token operator">|</span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span> <span class="token operator">|</span> <span class="token keyword">SERIALIZABLE</span> }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><img src="/2024/04/26/mysql/体系结构.jpg" style="zoom:80%;"><p><strong>1). 连接层</strong></p><p>最上层是一些<strong>客户端和链接服务</strong>，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于<strong>连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了<strong>线程池</strong>的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p><strong>2). 服务层</strong></p><p>第二层架构主要完成大多数的<strong>核心服务功能</strong>，如<strong>SQL接口</strong>，并完成<strong>缓存的查询，SQL的分析和优化，部分内置函数的执行</strong>。所有跨存储引擎的功能也在这一层实现，如 <strong>过程、函数</strong>等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p><strong>3). 引擎层</strong></p><p>存储引擎层， <strong>存储引擎真正的负责了MySQL中数据的存储和提取</strong>，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的<strong>索引是在存储引擎层实现</strong>的。</p><p><strong>4). 存储层</strong></p><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)<strong>存储在文件系统</strong>之上，并完成<strong>与存储引擎的交互</strong>。</p><p>存储引擎架构：</p><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，<strong>插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h3 id="存储引擎介绍"><a href="#存储引擎介绍" class="headerlink" title="存储引擎介绍"></a>存储引擎介绍</h3><p><strong>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。</strong>存储引擎是<strong>基于表的</strong>，而不是基于库的，所以存储引擎也可被称为<strong>表类型</strong>。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎(InnoDB)。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> engines<span class="token punctuation">;</span><span class="token comment"># 查询当前数据库支持的存储引擎</span><span class="token comment"># 建表时指定存储引擎</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">(</span>字段<span class="token number">1</span> 字段<span class="token number">1</span>类型 <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 字段<span class="token number">1</span>注释 <span class="token punctuation">]</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>字段n 字段n类型 <span class="token punctuation">[</span><span class="token keyword">COMMENT</span> 字段n注释 <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span> <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 表注释 <span class="token punctuation">]</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</p><ul><li>DML操作遵循ACID模型，支持<strong>事务</strong>；InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</li><li><strong>行级锁，提高并发访问性能；</strong>– InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li><li>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code>。</li></ul><p>文件：xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p><h5 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h5><img src="/2024/04/26/mysql/image-20240507165406280.png"><ul><li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是<strong>表空间文件</strong>，在表空间中可以包含多个Segment段。</li><li>段 : 表空间是由各个段组成的， 常见的段有<strong>数据段、索引段、回滚段</strong>等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</li><li>区 : 区是表空间的<strong>单元结构</strong>，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</li><li>页 : 页是组成区的最小单元，<strong>页也是InnoDB 存储引擎磁盘管理的最小单元</strong>，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行 : InnoDB 存储引擎是面向行的，也就是说<strong>数据是按行进行存放的</strong>，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。</li></ul><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>MyISAM是MySQL早期的默认存储引擎。<strong>不支持事务，不支持外键；支持表锁，不支持行锁。最大的缺陷就是崩溃后无法安全恢复。</strong></p><p>xxx.sdi：存储表结构信息xxx.MYD: 存储数据xxx.MYI: 存储索引</p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作临时表或缓存使用。</p><p>内存存放； hash索引（默认）</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><img src="/2024/04/26/mysql/image-20240507171837044.png" alt="image-20240507171837044" style="zoom:80%;"><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用<strong>对事务的完整性有比较高的要求，在并发条件下要求数据的一致性</strong>，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li><li>MyISAM ： 如果应用是<strong>以读操作和插入操作为主</strong>，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于<strong>临时表及缓存</strong>。MEMORY的缺陷就是<strong>对表的大小有限制，太大的表无法缓存在内存</strong>中，而且无法保障数据的安全性。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着<strong>满足特定查找算法</strong>的数据结构，这些数据结构<strong>以某种方式引用（指向）数据</strong>， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><img src="/2024/04/26/mysql/image-20240507172545744.png" alt="image-20240507172545744" style="zoom:80%;"><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><img src="/2024/04/26/mysql/image-20240507172740796.png" style="zoom:80%;"><p>不同的存储引擎对于索引结构的支持情况：</p><img src="/2024/04/26/mysql/image-20240507173002960.png" style="zoom:80%;"><p>我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li><p>顺序插入时，会形成一个链表，查询性能大大降低。</p></li><li><p>大数据量情况下，层级较深，检索速度慢。</p></li></ul><p>此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树。但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：大数据量情况下，层级较深，检索速度慢。</p><p>在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree。在详解B+Tree之前，先来介绍一下B-Tree。</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>B-Tree，B树是一种<strong>多路平衡查找树</strong>，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：</p><img src="/2024/04/26/mysql/image-20240507222040839.png"><p>插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。</p><img src="/2024/04/26/mysql/image-20240507223005789.png" style="zoom:80%;"><p>特点：</p><ul><li><p>5阶的B树，每一个节点最多存储4个key，对应5个指针。</p></li><li><p>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</p></li><li><p>在B树中，非叶子节点和叶子节点都会存放数据。</p></li></ul><p>一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：</p><ul><li>根结点至少有两个子女；</li><li>每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1；</li><li>除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ &lt;= k &lt;= m ；</li><li>所有的叶子结点都位于同一层。</li></ul><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p><img src="/2024/04/26/mysql/image-20240507223154029.png" alt="image-20240507223154029" style="zoom:80%;"><p>与B树对比：</p><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;<strong>B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</strong></li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 <strong>B+树的范围查询，只需要对链表进行遍历即可。</strong></li></ul><p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p><p>MySQL中优化之后的B+Tree：在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p><img src="/2024/04/26/mysql/image-20240507235942534.png"><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p><blockquote><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其<strong>数据文件本身就是索引文件</strong>。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></blockquote><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><img src="/2024/04/26/mysql/image-20240508002143227.png"><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p>A. Hash索引只能用于对等比较(=，in)，<strong>不支持范围查询（between，&gt;，&lt; ，…）</strong></p><p>B. <strong>无法利用索引完成排序操作</strong></p><p>C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p><blockquote><p>MySQL 的 InnoDB 存储引擎不直接支持常规的哈希索引，但是，InnoDB 存储引擎中存在一种特殊的“自适应哈希索引”（Adaptive Hash Index），自适应哈希索引并不是传统意义上的纯哈希索引，而是结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的每个哈希桶实际上是一个小型的 B+Tree 结构。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。</p></blockquote><p><strong>为什么InnoDB存储引擎选择使用B+tree索引结构?</strong></p><p>A. 相对于二叉树，层级更少，搜索效率高；</p><p>B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致<strong>一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</strong></p><p>C. 相对Hash索引，B+tree支持范围匹配及排序操作；</p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><h4 id="按照数据结构维度划分"><a href="#按照数据结构维度划分" class="headerlink" title="按照数据结构维度划分"></a>按照数据结构维度划分</h4><ul><li>BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</li><li>哈希索引：类似键值对的形式，一次即可定位。</li><li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><h4 id="按照底层存储方式角度划分"><a href="#按照底层存储方式角度划分" class="headerlink" title="按照底层存储方式角度划分"></a>按照底层存储方式角度划分</h4><ul><li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，<strong>InnoDB 中的主键索引就属于聚簇索引。</strong></li><li>聚集索引选取规则:<ul><li>如果存在主键，主键索引就是聚集索引。如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ul></li><li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，索引结构的叶子节点关联的是对应的主键。<strong>二级索引(辅助索引)就属于非聚簇索引</strong>。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。<ul><li>聚集索引的叶子节点下挂的是这一行的数据 。</li><li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li></ul></li></ul><p>接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。</p><img src="/2024/04/26/mysql/image-20240508163939785.png" alt="image-20240508163939785" style="zoom:80%;"><ul><li>由于是根据name字段进行查询，所以先根据name=’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</li><li>最终拿到这一行的数据，直接返回即可。</li></ul><blockquote><p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p></blockquote><h4 id="按照应用维度划分"><a href="#按照应用维度划分" class="headerlink" title="按照应用维度划分"></a>按照应用维度划分</h4><ul><li>主键索引：针对于表中主键创建的索引。默认自动创建。加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li>普通索引：仅加速查询。快速定位特定数据。又叫常规索引</li><li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。避免同一个表中某数据列中的值重复，唯一索引可以有多个。</li><li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><h4 id="MySQL-8-x-中实现的索引新特性"><a href="#MySQL-8-x-中实现的索引新特性" class="headerlink" title="MySQL 8.x 中实现的索引新特性"></a>MySQL 8.x 中实现的索引新特性</h4><ul><li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是<strong>在索引中可以包含函数或者表达式。</strong></li></ul><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建（唯一/全文）索引</span><span class="token keyword">CREATE</span> <span class="token punctuation">[</span> <span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token punctuation">]</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>index_col_name<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment"># 查看索引</span><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> table_name <span class="token punctuation">;</span><span class="token comment"># 删除索引</span><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- session 是查看当前会话 ;</span><span class="token comment">-- global 是查询全局数据 ;</span><span class="token keyword">SHOW</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">STATUS</span> <span class="token operator">LIKE</span> <span class="token string">'Com_______'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/04/26/mysql/image-20240508165617129.png"><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p><p>不建议开启，因为开启会带来一定的性能影响</p><img src="/2024/04/26/mysql/image-20240508165730121.png"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 开启慢查询日志，只对当前数据库生效，并且重启数据库后失效</span><span class="token keyword">set</span> <span class="token keyword">global</span> slow_query_log <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment"># 设置阈值</span><span class="token keyword">set</span> long_query_time <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment"># 得到返回记录集最多的10 个SQL</span><span class="token punctuation">.</span><span class="token operator">/</span>mysqldumpslow <span class="token operator">-</span>s r <span class="token operator">-</span>t <span class="token number">10</span> <span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>mysql<span class="token operator">/</span>logs<span class="token operator">/</span>slow<span class="token punctuation">.</span>log<span class="token comment"># 得到访问次数最多的10 个SQL</span><span class="token punctuation">.</span><span class="token operator">/</span>mysqldumpslow <span class="token operator">-</span>s c <span class="token operator">-</span>t <span class="token number">10</span> <span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>mysql<span class="token operator">/</span>logs<span class="token operator">/</span>slow<span class="token punctuation">.</span>log<span class="token comment"># 得到按照时间排序的前10 条里面含有左连接的查询语句</span><span class="token punctuation">.</span><span class="token operator">/</span>mysqldumpslow <span class="token operator">-</span>s t <span class="token operator">-</span>t <span class="token number">10</span> <span class="token operator">-</span>g <span class="token string">"left join"</span> <span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>mysql<span class="token operator">/</span>logs<span class="token operator">/</span>slow<span class="token punctuation">.</span>log<span class="token comment"># 另外建议在使用这些命令时结合| 和more 使用，否则有可能出现爆屏情况</span><span class="token punctuation">.</span><span class="token operator">/</span>mysqldumpslow <span class="token operator">-</span>s r <span class="token operator">-</span>t <span class="token number">10</span> <span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>mysql<span class="token operator">/</span>logs<span class="token operator">/</span>slow<span class="token punctuation">.</span>log <span class="token operator">|</span> more<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 直接在select语句之前加上关键字 explain / desc</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2024/04/26/mysql/image-20240508214501370.png" style="zoom:80%;"><p>Explain 执行计划中各个字段的含义:</p><img src="/2024/04/26/mysql/image-20240508214613100.png" style="zoom:80%;"><h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。<strong>最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，或者中间使用了范围查询，索引将会部分失效(后面的字段索引失效)。</strong></p><p>索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p><p>举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子。</p><img src="/2024/04/26/mysql/image-20240508214330139.png" alt="image-20240508214330139" style="zoom:67%;"><p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因<strong>为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引。</strong></p><h5 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h5><ul><li>建立联合索引（a，b，c）时，实际相当于建立了（a），（b），（c）三个索引</li><li>全值匹配时，无论顺序abc还是cba，在查询时都使用到了联合索引。这是因为MySQL中有查询优化器explain，所以sql语句中字段的顺序不需要和联合索引定义的字段顺序相同，查询优化器会判断纠正这条SQL语句以什么样的顺序执行效率高，最后才能生成真正的执行计划。<ul><li>explain对这种查询的结果显示为type=ref，表示非唯一性索引扫描，返回匹配某个单独值的所有行。</li><li>注意这种情况下，最左侧必须是<strong>等值匹配</strong>，因为只有左边等值情况下，右边条件才有序</li></ul></li><li>匹配最左边的1个或多个列时，也是ref，能够利用联合索引。</li><li>如果中间跳过几个字段，那么只能索引到有序的位置为止。</li><li>如果匹配到b或者bc这种条件（跳过最左边），explain也显示用了abc，<strong>但type是index</strong><ul><li>index：这种类型表示是<strong>mysql会对整个该索引进行扫描</strong>。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引</li><li>它虽然使用了联合索引，但是它是对整个索引树进行了扫描，正好匹配到该索引，与最左匹配原则无关，一般只要是某联合索引的一部分，但又不遵循最左匹配原则时，都可能会采用index类型的方式扫描，但它的效率远不如最左匹配原则的查询效率高</li></ul></li></ul><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ul><li><strong>索引列运算</strong>：不要在索引列上进行运算操作， 索引将失效。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#  当根据phone字段进行等值匹配查询时, 索引生效。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">'17799990015'</span><span class="token punctuation">;</span><span class="token comment">#  当根据phone字段进行函数运算操作之后，索引失效。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> substring<span class="token punctuation">(</span>phone<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">'15'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>字符串不加引号</strong>：字符串类型字段使用时，不加引号，索引将失效。（如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。）</li></ul><img src="/2024/04/26/mysql/image-20240508221636173.png"><ul><li><strong>模糊查询</strong>：如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">'软件%'</span><span class="token punctuation">;</span><span class="token comment">#  下面的失效</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">'%工程'</span><span class="token punctuation">;</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">'%工%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>or连接条件</strong>：用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 由于age没有索引，所以即使id、phone有索引，索引也会失效。当or连接的条件，左右两侧字段都有索引时，索引才会生效。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">'17799990017'</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>数据分布影响</strong>：如果MySQL评估使用索引比全表更慢，则不使用索引。</li></ul><blockquote><p>MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，<strong>如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</strong></p></blockquote><h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">use</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">'软件工程'</span><span class="token punctuation">;</span><span class="token comment"># ignore index ： 忽略指定的索引。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">ignore</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">'软件工程'</span><span class="token punctuation">;</span><span class="token comment"># force index ： 强制使用索引。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">'软件工程'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ <strong>覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</strong></p><blockquote><p>在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 <strong>如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了</strong>，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。</p></blockquote><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。****</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">index</span> idx_xxxx <span class="token keyword">on</span> table_name<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment"># 为tb_user表的email字段，建立长度为5的前缀索引。</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_email_5 <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>email<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>前缀长度</strong>：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><pre class="line-numbers language-none"><code class="language-none">select count(distinct email) / count(*) from tb_user ;# 前缀为5情况下索引选择性select count(distinct substring(email,1,5)) / count(*) from tb_user ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/04/26/mysql/image-20240509162814392.png" style="zoom:80%;"><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p>1). 针对于数据量较大，且查询比较频繁的表建立索引。</p><p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p><p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p><p>6). 要控制索引的数量，索引并不是多多益善，<strong>索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</strong></p><p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>如果我们需要一次性往数据库表中<strong>插入多条记录</strong>，可以从以下三个方面进行优化。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方案1，批量插入</span><span class="token keyword">Insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 方案2，手动控制事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token comment"># 方案3，主键顺序插入，性能要高于乱序插入</span>主键乱序插入 : <span class="token number">8</span> <span class="token number">1</span> <span class="token number">9</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">15</span> <span class="token number">89</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">3</span>主键顺序插入 : <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">15</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">89</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h4><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。</p><img src="/2024/04/26/mysql/image-20240510111007454.png"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</span><span class="token comment">-- 客户端连接服务端时，加上参数 -–local-infile</span>mysql –<span class="token operator">-</span><span class="token keyword">local</span><span class="token operator">-</span><span class="token keyword">infile</span> <span class="token operator">-</span>u root <span class="token operator">-</span>p<span class="token comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><span class="token keyword">set</span> <span class="token keyword">global</span> local_infile <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">-- 执行load指令将准备好的数据，加载到表结构中</span><span class="token keyword">load</span> <span class="token keyword">data</span> <span class="token keyword">local</span> <span class="token keyword">infile</span> <span class="token string">'/root/sql1.log'</span> <span class="token keyword">into</span> <span class="token keyword">table</span> tb_user <span class="token keyword">fields</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">','</span> <span class="token keyword">lines</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p><strong>数据组织方式</strong>：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接。</p><h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p><p>主键顺序插入时，直接从磁盘中申请页，逐个写入即可。乱序插入时，假如1#，2#页已经写满，存放如下数据。</p><img src="/2024/04/26/mysql/image-20240510112438937.png"><p>此时插入id=50的记录时，</p><img src="/2024/04/26/mysql/image-20240510112619060.png" style="zoom:80%;"><p>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。</p><h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><p>目前表中已有数据的索引结构(叶子节点)如下</p><img src="/2024/04/26/mysql/image-20240510112833127.png"><img src="/2024/04/26/mysql/image-20240510112916942.png" style="zoom:80%;"><img src="/2024/04/26/mysql/image-20240510113018365.png" alt="image-20240510113018365" style="zoom:80%;"><p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p><h4 id="索引设计优化"><a href="#索引设计优化" class="headerlink" title="索引设计优化"></a>索引设计优化</h4><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><p>MySQL的排序，有两种方式：</p><p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后<strong>在排序缓冲区sort buffer中完成排序操作</strong>，所有<strong>不是通过索引直接返回排序结果的排序都叫 FileSort 排序</strong>。</p><p>Using index : 通过<strong>有序索引顺序扫描直接返回有序数据</strong>，这种情况即为 using index，不需要额外排序，操作效率高。</p><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。</p><p><strong>order by优化原则:</strong></p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。</p><p>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p><p>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</p><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><p>A. 在分组操作时，可以通过索引来提高效率。</p><p>B. 分组操作时，索引的使用也是满足最左前缀法则的。</p><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><img src="/2024/04/26/mysql/image-20240510114353842.png"><p>当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p>优化思路: 一般分页查询时，通过创建 <strong>覆盖索引</strong> 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_sku t <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> tb_sku <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">2000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> a <span class="token keyword">where</span> t<span class="token punctuation">.</span>id <span class="token operator">=</span> a<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p><p>InnoDB 引擎就麻烦了，它执行 count(<em>) 的时候，*<em>需要把数据一行一行地从引擎里面读出来，然后累积计数。</em></em></p><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：<strong>自己计数(可以借助于redis这样的数据库进行</strong>,但是如果是带条件的count又比较麻烦了)。</p><img src="/2024/04/26/mysql/image-20240510114710602.png" style="zoom:80%;"><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，所以尽量使用 count(*)。</p><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</strong></p><p>例如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</span><span class="token keyword">update</span> course <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'javaEE'</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> <span class="token comment"># 当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低。</span><span class="token keyword">update</span> course <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'SpringBoot'</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'PHP'</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="视图、存储过程、触发器"><a href="#视图、存储过程、触发器" class="headerlink" title="视图、存储过程、触发器"></a>视图、存储过程、触发器</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图（View）是一种<strong>虚拟存在</strong>的表。视图中的数据并不在数据库中实际存在，<strong>行和列数据来自定义视图的查询中使用的表</strong>，并且是在使用视图时<strong>动态生成</strong>的。</p><p>通俗的讲，视图只保存了查询的<strong>SQL逻辑</strong>，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建</span><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token operator">OR</span> <span class="token keyword">REPLACE</span><span class="token punctuation">]</span> <span class="token keyword">VIEW</span> 视图名称<span class="token punctuation">[</span><span class="token punctuation">(</span>列名列表<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token keyword">SELECT</span>语句 <span class="token punctuation">[</span> <span class="token keyword">WITH</span> <span class="token punctuation">[</span><span class="token keyword">CASCADED</span> <span class="token operator">|</span> <span class="token keyword">LOCAL</span> <span class="token punctuation">]</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span> <span class="token punctuation">]</span><span class="token comment"># 查询</span>查看创建视图语句：<span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> 视图名称<span class="token punctuation">;</span>查看视图数据：<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 视图名称 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token comment"># 修改</span>方式一：<span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token operator">OR</span> <span class="token keyword">REPLACE</span><span class="token punctuation">]</span> <span class="token keyword">VIEW</span> 视图名称<span class="token punctuation">[</span><span class="token punctuation">(</span>列名列表<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token keyword">SELECT</span>语句 <span class="token punctuation">[</span> <span class="token keyword">WITH</span> <span class="token punctuation">[</span> <span class="token keyword">CASCADED</span> <span class="token operator">|</span> <span class="token keyword">LOCAL</span> <span class="token punctuation">]</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span> <span class="token punctuation">]</span>方式二：<span class="token keyword">ALTER</span> <span class="token keyword">VIEW</span> 视图名称<span class="token punctuation">[</span><span class="token punctuation">(</span>列名列表<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token keyword">SELECT</span>语句 <span class="token punctuation">[</span> <span class="token keyword">WITH</span> <span class="token punctuation">[</span> <span class="token keyword">CASCADED</span> <span class="token operator">|</span> <span class="token keyword">LOCAL</span> <span class="token punctuation">]</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span> <span class="token punctuation">]</span><span class="token comment"># 删除</span><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> 视图名称 <span class="token punctuation">[</span><span class="token punctuation">,</span>视图名称<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h4><p>1). 简单</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。<strong>那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</strong></p><p>2). 安全</p><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只<strong>能查询和修改他们所能见到的数据</strong></p><p>3). 数据独立</p><p>视图可帮助用户<strong>屏蔽真实表结构变化带来的影响</strong>。</p><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程是<strong>事先经过编译并存储在数据库中的一段 SQL 语句的集合</strong>，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是<strong>数据库 SQL 语言层面的代码封装与重用。</strong></p><ul><li><p>封装，复用 —————-&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p></li><li><p>可以接收参数，也可以返回数据 ——–&gt; 再存储过程中，可以传递参数，也可以接收返回值。</p></li><li><p><strong>减少网络交互</strong>，效率提升 ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> 存储过程名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> 参数列表 <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token comment">-- SQL语句</span><span class="token keyword">END</span> <span class="token punctuation">;</span><span class="token comment"># 调用</span><span class="token keyword">CALL</span> 名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> 参数 <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 查看</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>ROUTINES <span class="token keyword">WHERE</span> ROUTINE_SCHEMA <span class="token operator">=</span> <span class="token string">'xxx'</span><span class="token punctuation">;</span> <span class="token comment">-- 查询指定数据库的存储过程及状态信息</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> 存储过程名称 <span class="token punctuation">;</span> <span class="token comment">-- 查询某个存储过程的定义</span><span class="token comment"># 删除</span><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> 存储过程名称<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p><p><strong>系统变量</strong> 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token punctuation">[</span> <span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span> <span class="token punctuation">]</span> VARIABLES <span class="token punctuation">;</span> <span class="token comment">-- 查看所有系统变量</span><span class="token keyword">SHOW</span> <span class="token punctuation">[</span> <span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span> <span class="token punctuation">]</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'......'</span><span class="token punctuation">;</span> <span class="token comment">-- 可以通过LIKE模糊匹配方式查找变量</span><span class="token keyword">SELECT</span> @@<span class="token punctuation">[</span><span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span><span class="token punctuation">]</span> 系统变量名<span class="token punctuation">;</span> <span class="token comment">-- 查看指定变量的值</span><span class="token keyword">SET</span> <span class="token punctuation">[</span> <span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span> <span class="token punctuation">]</span> 系统变量名 <span class="token operator">=</span> 值 <span class="token punctuation">;</span>  <span class="token comment">-- 设置系统变量，如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。</span><span class="token keyword">SET</span> @@<span class="token punctuation">[</span><span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span><span class="token punctuation">]</span>系统变量名 <span class="token operator">=</span> 值 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>用户定义变量</strong> 是用户根据需要自己定义的变量，<strong>用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以</strong>。其作用域为当前连接。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 赋值 方式1</span><span class="token keyword">SET</span> <span class="token variable">@var_name</span> <span class="token operator">=</span> expr <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token variable">@var_name</span> <span class="token operator">=</span> expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token keyword">SET</span> <span class="token variable">@var_name</span> :<span class="token operator">=</span> expr <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token variable">@var_name</span> :<span class="token operator">=</span> expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token comment"># 方式2</span><span class="token keyword">SELECT</span> <span class="token variable">@var_name</span> :<span class="token operator">=</span> expr <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token variable">@var_name</span> :<span class="token operator">=</span> expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token keyword">SELECT</span> 字段名 <span class="token keyword">INTO</span> <span class="token variable">@var_name</span> <span class="token keyword">FROM</span> 表名<span class="token punctuation">;</span><span class="token comment"># 使用</span><span class="token keyword">SELECT</span> <span class="token variable">@var_name</span> <span class="token punctuation">;</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>局部变量</strong> 是根据需要定义的在局部生效的变量，访问之前，<strong>需要DECLARE声明</strong>。可用作存储过程内的<strong>局部变量和输入参数</strong>，局部变量的范围是在其内声明的BEGIN … END块。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> 变量名 变量类型 <span class="token punctuation">[</span><span class="token keyword">DEFAULT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span>  <span class="token comment">-- 变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</span><span class="token keyword">SET</span> 变量名 <span class="token operator">=</span> 值 <span class="token punctuation">;</span><span class="token keyword">SET</span> 变量名 :<span class="token operator">=</span> 值 <span class="token punctuation">;</span><span class="token keyword">SELECT</span> 字段名 <span class="token keyword">INTO</span> 变量名 <span class="token keyword">FROM</span> 表名 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="if案例"><a href="#if案例" class="headerlink" title="if案例"></a>if案例</h4><p>根据定义的分数score变量，判定当前分数对应的分数等级。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">procedure</span> p3<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> score <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">58</span><span class="token punctuation">;</span>    <span class="token keyword">declare</span> result <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> score <span class="token operator">&gt;=</span> <span class="token number">85</span> <span class="token keyword">then</span>    <span class="token keyword">set</span> result :<span class="token operator">=</span> <span class="token string">'优秀'</span><span class="token punctuation">;</span>    <span class="token keyword">elseif</span> score <span class="token operator">&gt;=</span> <span class="token number">60</span> <span class="token keyword">then</span>    <span class="token keyword">set</span> result :<span class="token operator">=</span> <span class="token string">'及格'</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token keyword">set</span> result :<span class="token operator">=</span> <span class="token string">'不及格'</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span>    <span class="token keyword">select</span> result<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token keyword">call</span> p3<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>IN ：该类参数作为输入，也就是需要调用时传入值 默认</p><p>OUT ：该类参数作为输出，也就是该参数可以作为返回值</p><p>INOUT ：既可以作为输入参数，也可以作为输出参数</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> 存储过程名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token operator">IN</span><span class="token operator">/</span><span class="token keyword">OUT</span><span class="token operator">/</span><span class="token keyword">INOUT</span> 参数名 参数类型 <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token comment">-- SQL语句</span><span class="token keyword">END</span> <span class="token punctuation">;</span><span class="token comment"># 案例</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> p4<span class="token punctuation">(</span><span class="token operator">in</span> score <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">out</span> result <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">begin</span><span class="token keyword">if</span> score xxxx<span class="token keyword">end</span><span class="token punctuation">;</span><span class="token comment">-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明</span><span class="token keyword">call</span> p4<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token variable">@result</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token variable">@result</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，</span>执行statement_list2， 否则就执行 statement_list<span class="token keyword">CASE</span> case_value    <span class="token keyword">WHEN</span> when_value1 <span class="token keyword">THEN</span> statement_list1    <span class="token punctuation">[</span> <span class="token keyword">WHEN</span> when_value2 <span class="token keyword">THEN</span> statement_list2<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">[</span> <span class="token keyword">ELSE</span> statement_list <span class="token punctuation">]</span><span class="token keyword">END</span> <span class="token keyword">CASE</span><span class="token punctuation">;</span><span class="token comment">-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list</span><span class="token keyword">CASE</span>    <span class="token keyword">WHEN</span> search_condition1 <span class="token keyword">THEN</span> statement_list1    <span class="token punctuation">[</span><span class="token keyword">WHEN</span> search_condition2 <span class="token keyword">THEN</span> statement_list2<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">[</span><span class="token keyword">ELSE</span> statement_list<span class="token punctuation">]</span><span class="token keyword">END</span> <span class="token keyword">CASE</span><span class="token punctuation">;</span><span class="token comment">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span><span class="token keyword">WHILE</span> 条件 <span class="token keyword">DO</span><span class="token keyword">SQL</span>逻辑<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span><span class="token comment">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><span class="token keyword">REPEAT</span>    <span class="token keyword">SQL</span>逻辑<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    UNTIL 条件<span class="token keyword">END</span> <span class="token keyword">REPEAT</span><span class="token punctuation">;</span><span class="token punctuation">[</span>begin_label:<span class="token punctuation">]</span> <span class="token keyword">LOOP</span>    <span class="token keyword">SQL</span>逻辑<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">END</span> <span class="token keyword">LOOP</span> <span class="token punctuation">[</span>end_label<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">LEAVE</span> label<span class="token punctuation">;</span> <span class="token comment">-- 退出指定标记的循环体</span><span class="token keyword">ITERATE</span> label<span class="token punctuation">;</span> <span class="token comment">-- 直接进入下一次循环</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> 游标名称 <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> 查询语句 <span class="token punctuation">;</span><span class="token keyword">OPEN</span> 游标名称 <span class="token punctuation">;</span> <span class="token comment">-- 打开游标</span><span class="token keyword">FETCH</span> 游标名称 <span class="token keyword">INTO</span> 变量 <span class="token punctuation">[</span><span class="token punctuation">,</span> 变量 <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token comment">-- 获取游标记录</span><span class="token keyword">CLOSE</span> 游标名称 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h4><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> handler_action <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> condition_value <span class="token punctuation">[</span><span class="token punctuation">,</span> condition_value<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> statement <span class="token punctuation">;</span>handler_action 的取值：    <span class="token keyword">CONTINUE</span>: 继续执行当前程序    <span class="token keyword">EXIT</span>: 终止执行当前程序condition_value 的取值：    SQLSTATE sqlstate_value: 状态码，如 <span class="token number">02000</span>    SQLWARNING: 所有以<span class="token number">01</span>开头的SQLSTATE代码的简写    <span class="token operator">NOT</span> FOUND: 所有以<span class="token number">02</span>开头的SQLSTATE代码的简写    SQLEXCEPTION: 所有没有被SQLWARNING 或 <span class="token operator">NOT</span> FOUND捕获的SQLSTATE代码的简写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> 存储函数名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> 参数列表 <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">RETURNS</span> <span class="token keyword">type</span> <span class="token punctuation">[</span>characteristic <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token keyword">BEGIN</span>    <span class="token comment">-- SQL语句</span>    <span class="token keyword">RETURN</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>characteristic说明：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li></ul><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是与表有关的数据库对象，指<strong>在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合</strong>。触发器的这种特性可以协助应用在数据库端确保<strong>数据的完整性, 日志记录 , 数据校验</strong>等操作 。</p><p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><img src="/2024/04/26/mysql/image-20240510163048010.png" style="zoom:67%;"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建触发器</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_nameBEFORE<span class="token operator">/</span><span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span><span class="token operator">/</span><span class="token keyword">UPDATE</span><span class="token operator">/</span><span class="token keyword">DELETE</span><span class="token keyword">ON</span> tbl_name <span class="token keyword">FOR EACH ROW</span> <span class="token comment">-- 行级触发器</span><span class="token keyword">BEGIN</span>trigger_stmt <span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span class="token keyword">SHOW</span> TRIGGERS <span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token punctuation">[</span>schema_name<span class="token punctuation">.</span><span class="token punctuation">]</span>trigger_name <span class="token punctuation">;</span> <span class="token comment">-- 如果没有指定 schema_name，默认为当前数据库 。</span><span class="token comment"># 案例：通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加,修改 , 删除 ;</span><span class="token keyword">create</span> <span class="token keyword">trigger</span> tb_user_insert_trigger <span class="token keyword">after</span> <span class="token keyword">insert</span> <span class="token keyword">on</span> tb_user <span class="token keyword">for each row</span><span class="token keyword">begin</span>    <span class="token keyword">insert</span> <span class="token keyword">into</span> user_logs<span class="token punctuation">(</span>id<span class="token punctuation">,</span> operation<span class="token punctuation">,</span> operate_time<span class="token punctuation">,</span> operate_id<span class="token punctuation">,</span> operate_params<span class="token punctuation">)</span>    <span class="token keyword">VALUES</span>    <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'insert'</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> new<span class="token punctuation">.</span>id<span class="token punctuation">,</span> concat<span class="token punctuation">(</span><span class="token string">'插入的数据内容为:    id='</span><span class="token punctuation">,</span>new<span class="token punctuation">.</span>id<span class="token punctuation">,</span><span class="token string">',name='</span><span class="token punctuation">,</span>new<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">', phone='</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> <span class="token string">', email='</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token string">',    profession='</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>profession<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token comment"># 修改数据 的触发器</span><span class="token keyword">create</span> <span class="token keyword">trigger</span> tb_user_update_trigger <span class="token keyword">after</span> <span class="token keyword">update</span> <span class="token keyword">on</span> tb_user <span class="token keyword">for each row</span><span class="token keyword">begin</span>    <span class="token keyword">insert</span> <span class="token keyword">into</span> user_logs<span class="token punctuation">(</span>id<span class="token punctuation">,</span> operation<span class="token punctuation">,</span> operate_time<span class="token punctuation">,</span> operate_id<span class="token punctuation">,</span> operate_params<span class="token punctuation">)</span>    <span class="token keyword">VALUES</span>    <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'update'</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> new<span class="token punctuation">.</span>id<span class="token punctuation">,</span>    concat<span class="token punctuation">(</span><span class="token string">'更新之前的数据: id='</span><span class="token punctuation">,</span>old<span class="token punctuation">.</span>id<span class="token punctuation">,</span><span class="token string">',name='</span><span class="token punctuation">,</span>old<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">', phone='</span><span class="token punctuation">,</span>    old<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> <span class="token string">', email='</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token string">', profession='</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span>profession<span class="token punctuation">,</span>    <span class="token string">' | 更新之后的数据: id='</span><span class="token punctuation">,</span>new<span class="token punctuation">.</span>id<span class="token punctuation">,</span><span class="token string">',name='</span><span class="token punctuation">,</span>new<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">', phone='</span><span class="token punctuation">,</span>    NEW<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> <span class="token string">', email='</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token string">', profession='</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>profession<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token comment"># 删除</span><span class="token keyword">create</span> <span class="token keyword">trigger</span> tb_user_delete_trigger <span class="token keyword">after</span> <span class="token keyword">delete</span> <span class="token keyword">on</span> tb_user <span class="token keyword">for each row</span><span class="token keyword">begin</span>    <span class="token keyword">insert</span> <span class="token keyword">into</span> user_logs<span class="token punctuation">(</span>id<span class="token punctuation">,</span> operation<span class="token punctuation">,</span> operate_time<span class="token punctuation">,</span> operate_id<span class="token punctuation">,</span> operate_params<span class="token punctuation">)</span>    <span class="token keyword">VALUES</span>    <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'delete'</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span>id<span class="token punctuation">,</span>    concat<span class="token punctuation">(</span><span class="token string">'删除之前的数据: id='</span><span class="token punctuation">,</span>old<span class="token punctuation">.</span>id<span class="token punctuation">,</span><span class="token string">',name='</span><span class="token punctuation">,</span>old<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">', phone='</span><span class="token punctuation">,</span>    old<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> <span class="token string">', email='</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token string">', profession='</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span>profession<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="锁"><a href="#锁" class="headerlink" title="锁***"></a>锁***</h2><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong>在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何<strong>保证数据并发访问的一致性、有效性</strong>是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><ul><li><p><strong>全局锁</strong>：锁定数据库中的所有表。全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。其典型的使用场景是<strong>做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性</strong>。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span> <span class="token punctuation">;</span><span class="token comment">-- 加全局锁</span>mysqldump <span class="token operator">-</span>uroot –p1234 itcast <span class="token operator">&gt;</span> itcast<span class="token punctuation">.</span><span class="token keyword">sql</span><span class="token comment">-- 数据备份</span><span class="token keyword">unlock</span> <span class="token keyword">tables</span> <span class="token punctuation">;</span><span class="token comment">-- 释放锁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump <span class="token comment">--single-transaction -uroot –p123456 itcast &gt; itcast.sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><blockquote><p>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且<strong>由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作</strong>。</p><p>因为在可重复读的隔离级别下，<strong>即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View</strong>，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p><p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会<strong>在备份数据库之前先开启事务</strong>。这种方法只适用于<strong>支持「可重复读隔离级别的事务」</strong>的存储引擎。</p><p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p><p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p></blockquote><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><ul><li><p><strong>表级锁</strong>：每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>表级锁主要分为：表锁，元数据锁，意向锁</p></li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>对于表锁，分为两类：<strong>表共享读锁（read lock）</strong>–只阻塞写，<strong>表独占写锁（write lock）</strong>–阻塞读写</p><p>语法：<strong>加锁：lock tables 表名… read/write。</strong><strong>释放锁：unlock tables</strong> / 客户端断开连接 。</p><p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p><h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>meta data lock , 元数据锁，简写MDL。</p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性。</strong></p><p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，<strong>某一张表涉及到未提交的事务时，是不能够修改这张表的表结构</strong>的。在MySQL5.5中引入了MDL，<strong>当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</strong></p><p>常见的SQL操作时，所添加的元数据锁：</p><img src="/2024/04/26/mysql/image-20240510171058496.png" style="zoom:80%;"><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p><blockquote><p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p></blockquote><p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL <strong>写锁等待，会阻塞后续该表的所有 CRUD 操作。</strong></p><p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>为了避免DML在执行时，加的<strong>行锁与表锁的冲突</strong>，在InnoDB中引入了意向锁，<strong>使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</strong></p><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢：</p><p>1.首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁</p><p>2.当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会<strong>从第一行数据，检查到最后一行数据，效率较低。</strong></p><p>有了意向锁之后 :</p><p>1.客户端一，在执行DML操作时，会对涉及的行<strong>加行锁</strong>，同时也会对<strong>该表</strong>加上<strong>意向锁</strong>。</p><p>2.而其他客户端，在对这张表加表锁的时候，会<strong>根据该表上所加的意向锁来判定是否可以成功加表锁</strong>，而不用逐行判断行锁情况了。</p><p>分类：</p><ul><li><p><strong>意向共享锁(IS):</strong> 由语句<strong>select … lock in share mode</strong>添加 。 与 <strong>表锁共享锁 (read)兼容</strong>，与<strong>表锁排他锁</strong>(write)互斥。</p></li><li><p><strong>意向排他锁(IX):</strong> 由insert、update、delete、select…<strong>for update</strong>添加 。与<strong>表锁共享锁(read)及排他锁(write)都互斥</strong>，<strong>意向锁之间不会互斥。</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//先在表上加上意向共享锁，然后对读取的记录加共享锁</span><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span><span class="token comment">//先表上加上意向独占锁，然后对读取的记录加独占锁</span><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。</strong>（也就是说，意向锁只用于处理行锁与表锁冲突的情况）</p><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p></blockquote><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> object_schema<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span>lock_mode<span class="token punctuation">,</span>lock_data <span class="token keyword">from</span> performance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><ul><li><strong>行级锁</strong>：每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中</li></ul><p>InnoDB的数据是基于索引组织的，<strong>行锁是通过对索引上的索引项加锁来实现的</strong>，而不是对记录加的锁。对于行级锁，主要分为以下三类：（行锁感觉叫记录锁更清晰）</p><img src="/2024/04/26/mysql/image-20240510173950346.png" style="zoom:80%;"><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p></li><li><p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p></li></ul><p>共享锁和共享锁兼容，其他情况（共享与排他，排他与排他）不兼容。</p><p>普通的 select 语句是不会对记录加锁的，因为它属于<strong>快照读</strong>。如果要在查询时对记录加行锁，可以使用下面这两个方式（lock in share mode和for update，前面意向锁也有提到，这个语句会先加意向锁再加S/X锁），这种<strong>查询会加锁</strong>的语句称为<strong>锁定读</strong>。</p><img src="/2024/04/26/mysql/image-20240511095420544.png" style="zoom:80%;"><blockquote><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。</p></blockquote><p>示例：</p><img src="/2024/04/26/mysql/image-20240511110015133.png"><p>在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？原因就是因为此时，客户端一，<strong>根据name字段进行更新时，name字段是没有索引的，如果没有索引，此时行锁会升级为表锁</strong>(因为行锁是对索引项加的锁，而name没有索引)。</p><h4 id="间隙锁-临键锁"><a href="#间隙锁-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h4><p>Gap Lock 称为间隙锁，只存在于</p><p>可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><blockquote><p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以<strong>同时持有包含共同间隙范围的间隙锁</strong>，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。</p></blockquote><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><blockquote><p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p></blockquote><ul><li><p>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</p><img src="/2024/04/26/mysql/image-20240511110551714.png"></li><li><p>索引上的等值查询(<strong>非唯一普通索引</strong>)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</p><p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引<strong>查询值为18的数据，并加上共享锁</strong>，我们是只锁定18这一行就可以了吗？ 并不是，因为是<strong>非唯一索引，这个结构中可能有多个18的存在</strong>，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会<strong>对18加临键锁，并对29之前的间隙加锁。</strong></p><img src="/2024/04/26/mysql/image-20240511110923868.png" alt="image-20240511110923868" style="zoom:80%;"><img src="/2024/04/26/mysql/image-20240511111206605.png"><p><strong>间隙锁（X,GAP），行锁（X,REC_NOT_GAP），临键锁（X）</strong></p></li><li><p>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p><p>查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：[19]，(19,25]，(25,+∞]</p><p>所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。</p><img src="/2024/04/26/mysql/image-20240511111948747.png"></li></ul><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/gap%E9%94%81.drawio.png" alt="img"></p><p>当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个<strong>插入意向锁</strong>，然后将锁的状态设置为<strong>等待状态</strong>（PS：MySQL 加锁时，是先<strong>生成锁结构，然后设置锁的状态</strong>，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p><p>如果说间隙锁锁住的是一个区间，那么<strong>「插入意向锁」锁住的就是一个点</strong>。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p><p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员MySQL：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?vd_source=8f6745987f6d9c4a333570852e433d6c">https://www.bilibili.com/video/BV1Kr4y1i7ru/?vd_source=8f6745987f6d9c4a333570852e433d6c</a></p><p>JavaGuide：<a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></p><p>最左前缀匹配原则：<a href="https://blog.csdn.net/yuanchangliang/article/details/107798724">https://blog.csdn.net/yuanchangliang/article/details/107798724</a></p><p>小林coding：<a href="https://xiaolincoding.com/mysql/lock/mysql_lock.html">https://xiaolincoding.com/mysql/lock/mysql_lock.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2024/04/26/jdbc/"/>
      <url>/2024/04/26/jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>JDBC（Java Database Connectivity）是Java语言中用于与数据库通信的一种API，它允许Java应用程序通过标准的数据库访问方法与各种关系型数据库进行交互，例如MySQL、Oracle、SQL Server等。</li><li>JDBC为访问不同的数据库提供了统一的接口，使开发人员能够编写Java程序以执行SQL查询、更新数据库记录。为使用者屏蔽了细节问题。</li></ul><p>本质：</p><ul><li>官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包。<strong>（数据库驱动提供JDBC的实现类）</strong></li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</li></ul><p>优点：</p><ul><li><strong>跨数据库兼容性</strong>：各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发。可随时替换底层数据库，访问数据库的Java代码基本不变。</li><li><strong>安全性</strong>：JDBC提供了一种安全的数据库访问机制，可以防止SQL注入等安全问题。通过使用预编译语句和参数化查询等技术，可以有效地防止恶意用户对数据库进行攻击。</li></ul><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//1. 注册驱动</span>        <span class="token comment">// Class.forName("com.mysql.jdbc.Driver");</span>        <span class="token comment">//2. 获取连接</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://127.0.0.1:3306/db1"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">"1234"</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3. 定义sql</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"update account set money = 2000 where id = 1"</span><span class="token punctuation">;</span>        <span class="token comment">//4. 获取执行sql的对象 Statement</span>        <span class="token class-name">Statement</span> stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5. 执行sql</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//受影响的行数</span>        <span class="token comment">//6. 处理结果</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//7. 释放资源</span>        stmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><p>DriverManager（驱动管理类）作用：</p><ul><li>注册驱动</li></ul><img src="/2024/04/26/jdbc/registerDriver.png" alt="driver"><p>我们使用的注册驱动代码为</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为MySQL提供的Driver类源码调用了DriverManager.registerDriver。</p><img src="/2024/04/26/jdbc/driver.png" alt="driver" style="zoom:67%;"><p>在该类中的静态代码块中已经执行了 <code>DriverManager</code> 对象的 <code>registerDriver()</code> 方法进行驱动的注册了，那么我们只需要加载 <code>Driver</code> 类，该静态代码块就会执行。而<code>Class.forName("com.mysql.jdbc.Driver");</code> 就可以加载 <code>Driver</code> 类。</p><blockquote><p>==提示：==</p><ul><li>MySQL 5之后的驱动包，可以省略注册驱动的步骤</li><li>自动加载jar包中META-INF/services/java.sql.Driver文件中的驱动类</li></ul></blockquote><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>Connection（数据库连接对象）作用：获取执行 SQL 的对象；管理事务</p><h4 id="获取执行对象"><a href="#获取执行对象" class="headerlink" title="获取执行对象"></a>获取执行对象</h4><p>普通执行SQL对象–statement</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//3. 定义sql</span>String <span class="token keyword">sql</span> <span class="token operator">=</span> <span class="token string">"update account set money = 3000 where id = 1"</span><span class="token punctuation">;</span><span class="token comment">//4. 获取执行sql的对象 Statement</span>Statement stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span>createStatement<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 执行sql</span><span class="token keyword">int</span> count <span class="token operator">=</span> stmt<span class="token punctuation">.</span>executeUpdate<span class="token punctuation">(</span><span class="token keyword">sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>预编译SQL的执行SQL对象：防止SQL注入</p><ul><li><p>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p></li><li><p>例如普通statement如果使用字符串拼接构造SQL  <code>String sql = "select * from stu where name='" + name + "'";</code>  在name中传入<code>"lucy" or name="郭麒麟"</code>，此时就会改变原有的SQL，查询到两条语句。也就是SQL注入漏洞</p></li><li><p>可以使用<code>PreparedStatement</code>来实现数据库操作，它的特点是：使用占位符<code>?</code>表示SQL语句中的参数，通过<code>set</code>方法为SQL语句传入参数</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">public</span> static void queryPrepare<span class="token punctuation">(</span>String name<span class="token punctuation">)</span> throws SQLException {    <span class="token comment">// 预编译SQL，SQL语句中的参数值，使用？占位符替代</span>    ptmt <span class="token operator">=</span> conn<span class="token punctuation">.</span>prepareStatement<span class="token punctuation">(</span><span class="token string">"select * from stu where name=?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ptmt<span class="token punctuation">.</span>setString<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 打印预编译后的SQL语句</span>    System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span>println<span class="token punctuation">(</span>ptmt<span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用这个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。</span>    rs <span class="token operator">=</span> ptmt<span class="token punctuation">.</span>executeQuery<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token keyword">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> {        StringBuilder sb <span class="token operator">=</span> new StringBuilder<span class="token punctuation">(</span><span class="token string">"[id="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rs<span class="token punctuation">.</span>getLong<span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", name="</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span>getString<span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", age="</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span>getInt<span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", class_id="</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span>getLong<span class="token punctuation">(</span><span class="token string">"class_id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span>println<span class="token punctuation">(</span>sb<span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>==小结：==</p><ul><li>在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li><li>执行时就不用再进行这些步骤了，速度更快</li><li>如果sql模板一样，则只需要进行一次检查、编译</li></ul></blockquote><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><p>MySQL事务管理的操作：</p><ul><li>开启事务 ： BEGIN; 或者 START TRANSACTION;</li><li>提交事务 ： COMMIT;</li><li>回滚事务 ： ROLLBACK;</li></ul><p>Connection接口中定义了3个对应的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// ============开启事务==========</span>    conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//5. 执行sql</span>    <span class="token keyword">int</span> count1 <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//受影响的行数</span>    <span class="token comment">//6. 处理结果</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//5. 执行sql</span>    <span class="token keyword">int</span> count2 <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//受影响的行数</span>    <span class="token comment">//6. 处理结果</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ============提交事务==========</span>    <span class="token comment">//程序运行到此处，说明没有出现任何问题，则需求提交事务</span>    conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// ============回滚事务==========</span>    <span class="token comment">//程序在出现异常时会执行到这个地方，此时就需要回滚事务</span>    conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p></li><li><p>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</p></li><li><p>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li><p>好处</p><ul><li>资源重用：在需要时分配和回收资源</li><li>降低连接的建立和关闭开销，提升系统响应速度</li><li>限制并发连接数，便于管理和维护，避免数据库连接遗漏</li></ul></li></ul><p><strong>其他八股见Java基础数据库连接池部分</strong></p><p>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。</p><p>而数据库使用了数据库连接池后，就能达到Connection对象的复用，如下图</p><img src="/2024/04/26/jdbc/数据库连接池.png" alt="数据库连接池" style="zoom:80%;"><p>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。</p><h3 id="Driud连接池"><a href="#Driud连接池" class="headerlink" title="Driud连接池"></a>Driud连接池</h3><p>Druid（德鲁伊）连接池是阿里巴巴开源的数据库连接池项目。使用步骤：</p><blockquote><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件</li><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ul></blockquote><p>现在通过代码实现，首先需要先将druid的jar包放到项目下的lib下并添加为库文件</p><img src="/2024/04/26/jdbc/Driud导入.png" alt="image-20210725212911980" style="zoom:80%;"><p>项目结构如下：</p><img src="/2024/04/26/jdbc/Driud结构.png" alt="image-20210725213210091" style="zoom:80%;"><p>编写配置文件如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">driverClassName</span><span class="token punctuation">=</span><span class="token value attr-value">com.mysql.jdbc.Driver</span><span class="token key attr-name">url</span><span class="token punctuation">=</span><span class="token value attr-value">jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true</span><span class="token key attr-name">username</span><span class="token punctuation">=</span><span class="token value attr-value">root</span><span class="token key attr-name">password</span><span class="token punctuation">=</span><span class="token value attr-value">1234</span><span class="token comment"># 初始化连接数量</span><span class="token key attr-name">initialSize</span><span class="token punctuation">=</span><span class="token value attr-value">5</span><span class="token comment"># 最大连接数</span><span class="token key attr-name">maxActive</span><span class="token punctuation">=</span><span class="token value attr-value">10</span><span class="token comment"># 最大等待时间</span><span class="token key attr-name">maxWait</span><span class="token punctuation">=</span><span class="token value attr-value">3000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用druid的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DruidDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//3. 加载配置文件</span>        <span class="token class-name">Properties</span> prop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        prop<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"jdbc-demo/src/druid.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4. 获取连接池对象</span>        <span class="token class-name">DataSource</span> dataSource <span class="token operator">=</span> <span class="token class-name">DruidDataSourceFactory</span><span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5. 获取数据库连接 Connection</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取到了连接后就可以继续做其他操作了</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>Java持久层框架是在Java语言中用于与数据库交互的重要工具。它们提供了一种简便的方式来管理数据的持久性。在Java开发过程中，持久层框架可以大大简化数据访问的过程，并且提供了一些额外的功能，如事务管理和缓存机制。</p><ul><li>Hibernate是一个持久层的ORM的框架。允许开发者将Java类和数据库表之间进行映射，使得开发者可以直接操作Java对象，而不用关心底层数据库的细节</li><li>javaBean - config.xml –数据库(三者映射)</li><li>Hibernate 能够自动生成 SQL 语句并自动执行，实现对数据库进行操作，整个过程完全不需要人工干预，大大降低了开发成本。</li></ul><p><strong>Hibernate的优点：</strong></p><ol><li>简化JDBC的编程.</li><li>修改了实体类，不需要修改源代码.</li><li>轻量级的框架.</li><li>支持lazy，可以让你的数据只在需要的时候被加载</li><li>提供HQL（Hibernate Query Language），可以完全把查询映射到模型</li></ol><img src="/2024/04/26/jdbc/hibernate.png" alt="img" style="zoom:80%;"><p>流程说明:首先创建Configuration类的实例，并通过它来读取并解析配置文件hibernate.cfg.xml。然后创建SessionFactory读取解析映射文件信息，并将Configuration对象中的所有配置信息拷贝到SessionFactory内存(一级缓存级别)中。接下来，打开Session，让SessionFactory提供连接，并开启一个事务，之后创建对象，向对象中添加数据，通过session.save()方法完成向数据库中保存数据的操作。最后提交事务，并关闭资源。</p><p><strong>缺点：</strong></p><ol><li><strong>性能问题：</strong> 在大规模数据操作和复杂查询时，Hibernate的性能可能不如手动编写的SQL语句高效，需要开发者针对具体情况进行优化。</li><li><strong>学习成本：</strong> 对于初学者来说，学习和掌握Hibernate框架需要一定的时间和精力，尤其是理解ORM的概念和工作原理。</li><li><strong>对于特定场景的限制：</strong>hibernate将数据库与开发者隔离了，开发者不需要关注数据库是Oracle还是MySQL，hibernate来帮你生成查询的sql语句，但在某些特定场景下可能无法满足需求，需要开发者考虑是否需要自定义实现或者选择其他技术。</li></ol><img src="/2024/04/26/jdbc/hibernate缺点.png" alt="image-20240427153359661" style="zoom: 67%;"><h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><p>JPA，全称是：Java PersistenceAPI。是SUN公司推出的一套<strong>基于ORM的规范</strong>。hibernate框架中提供了JPA的实现（但是，JPA规范的实现仅仅是Hibernate的一部分）。JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。JPA框架中支持大数据集、事务、并发等容器级事务。</p><p>Spring Data JPA为Java Persistence API（JPA）提供了实现。它简化了通过JPA访问数据库的开发工作，提供了很多CRUD的快捷操作，还提供了如分页、排序、复杂查询、自定义查询（JPQL）等功能，Spring Data JPA底层也是依赖于Hibernate来实现的，Spring Data JPA拥有标准化、简单易用、面向对象等优势，并且Spring将EntityManager 的创建与销毁、事务管理等代码抽取出来，并由Spring统一进行管理。</p><h3 id="JPA搭建"><a href="#JPA搭建" class="headerlink" title="JPA搭建"></a>JPA搭建</h3><p>maven依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>springboot配置</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">spring</span><span class="token punctuation">:</span><span class="token key attr-name">  application</span><span class="token punctuation">:</span><span class="token comment">    #应用名称</span><span class="token key attr-name">    name</span><span class="token punctuation">:</span> <span class="token value attr-value">spring-data-jpa</span><span class="token key attr-name">  datasource</span><span class="token punctuation">:</span><span class="token comment">    #你的数据库密码</span><span class="token key attr-name">    password</span><span class="token punctuation">:</span> <span class="token value attr-value">123456</span><span class="token comment">    #你的数据库地址</span><span class="token key attr-name">    url</span><span class="token punctuation">:</span> <span class="token value attr-value">jdbc:mysql://localhost:3306/spring_test?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</span><span class="token comment">    #数据库用户名</span><span class="token key attr-name">    username</span><span class="token punctuation">:</span> <span class="token value attr-value">root</span><span class="token comment">    #数据库驱动名称</span><span class="token key attr-name">    driver-class-name</span><span class="token punctuation">:</span> <span class="token value attr-value">com.mysql.cj.jdbc.Driver #配置MySQL的驱动程序类</span><span class="token comment">    #指定连接池类型</span><span class="token key attr-name">    type</span><span class="token punctuation">:</span> <span class="token value attr-value">com.zaxxer.hikari.HikariDataSource</span><span class="token comment">    #数据库连接池的配置</span><span class="token key attr-name">    hikari</span><span class="token punctuation">:</span><span class="token comment">      #客户端等待连接池连接的最大毫秒数</span><span class="token key attr-name">      connection-timeout</span><span class="token punctuation">:</span> <span class="token value attr-value">30000</span>         ……<span class="token comment">      #连接池的名称</span><span class="token key attr-name">  pool-name</span><span class="token punctuation">:</span> <span class="token value attr-value">SpringDataJPAHikariCP</span><span class="token comment">  #jpa相关配置</span><span class="token key attr-name">  jpa</span><span class="token punctuation">:</span><span class="token key attr-name">    hibernate</span><span class="token punctuation">:</span><span class="token comment">      #DDL:用于定义数据库的三层结构，包括外模式、概念模式、内模式及其相互之间的映像，定义数据的完整性，安全控制等约束</span><span class="token key attr-name">      ddl-auto</span><span class="token punctuation">:</span> <span class="token value attr-value">none #什么也不做</span><span class="token comment">      #其他可选值</span><span class="token comment">      #create: 每次运行应用程序时，都会重新创建表，所以，数据都会丢失</span><span class="token comment">      #create-drop:每次运行程序时会创建表结构，然后程序结束时清空数据</span><span class="token comment">      #update: 每次运行程序没有表时会创建表，如果对象改变会更新表结构，原有数据不会清除，只会更新</span><span class="token comment">      #validate: 运行程序会校验数据与数据库的字段类型是否相同，字段不同会报错</span><span class="token comment">    #打印执行的sql及参数</span><span class="token key attr-name">    show-sql</span><span class="token punctuation">:</span> <span class="token value attr-value">true</span><span class="token comment">    # 关闭懒加载配置，否则会报错</span><span class="token key attr-name">    open-in-view</span><span class="token punctuation">:</span> <span class="token value attr-value">false</span><span class="token key attr-name">    properties</span><span class="token punctuation">:</span><span class="token key attr-name">      hibernate</span><span class="token punctuation">:</span><span class="token comment">        #输出sql语句</span><span class="token key attr-name">        show_sql</span><span class="token punctuation">:</span> <span class="token value attr-value">true</span><span class="token comment">        #格式化输出的sql，否则会一行显示</span><span class="token key attr-name">        format_sql</span><span class="token punctuation">:</span> <span class="token value attr-value">true</span><span class="token key attr-name">server</span><span class="token punctuation">:</span><span class="token comment">  #指定服务端口号</span><span class="token key attr-name">  port</span><span class="token punctuation">:</span> <span class="token value attr-value">8008</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JPA简单查询"><a href="#JPA简单查询" class="headerlink" title="JPA简单查询"></a>JPA简单查询</h3><h4 id="Repository的编写"><a href="#Repository的编写" class="headerlink" title="Repository的编写"></a><strong>Repository的编写</strong></h4><p>JPA中，我们只需要定义一个接口就可以轻松地操作数据库，这个接口要继承JpaRepository接口，这里需要指定两个泛型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BannerRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一个泛型是实体类的类型，第二个泛型是主键的类型。</p><h4 id="JPA简单条件查询"><a href="#JPA简单条件查询" class="headerlink" title="JPA简单条件查询"></a><strong>JPA简单条件查询</strong></h4><p>JPA要求 我们按照一定的规则进行命名就可以进行一些简单的查询，下面我们开始编写第一个JPA方法。</p><p>我们可以定义如下的方法，按照字面上的理解就是，通过查询Banner通过Id，参数是bannerId，也可以通过其他字段来进行查询，IDE会给出提示，我们仅仅需要编写一个这样的方法JPA就会自动的完成查询工作，当前方法中返回的Java8中的Optional对象，也可以直接返回Banner实体类，在一些业务场景下，返回的结果集可能是多个实体对象，这时要用List来进行接收。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BannerRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 查询banner 通过bannerId     *     * @param bannerId bannerId     * @return banner 详细信息     */</span>    <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">&gt;</span></span> <span class="token function">findBannerById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> bannerId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a><strong>多条件查询</strong></h4><p>如果通过多个条件进行查询，如通过名称和描述进行查询，JPA也支持这种查询方式，我们只需要将条件用and进行连接，这里的条件的属性名称与个数要与参数的位置和个数一一对应。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>Banner <span class="token function">findBannerByNameAndDescription</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> description<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>JPA几乎实现了MySQL所有的查询关键字，第一个查询是通过Equals关键字来查询名称相同和价格相等的商品，第二个查询是通过GreaterThanEqual关键字来查询名称相同价格大于等于给定价格的商品。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*** 查询商品列表通过名称和价格*/</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findByNameAndPriceEquals</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*** 查询商品列表并且价格大于等于指定的价格*/</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findByNameAndPriceGreaterThanEqual</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a><strong>排序与分页</strong></h4><p>JPA还提供了对排序和分页的支持，只需要在查询方法的入参中加入Sort对象作为入参，就可以实现排序功能，实现分页功能需要将Pageable作为入参就可以实现分页功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token class-name">Sort</span> sort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="JPA复杂查询"><a href="#JPA复杂查询" class="headerlink" title="JPA复杂查询"></a><strong>JPA复杂查询</strong></h3><h4 id="自定义JPQL"><a href="#自定义JPQL" class="headerlink" title="自定义JPQL"></a>自定义JPQL</h4><p>如果JPA规范定义的查询关键字不能满足需求的话，就可以使用@Query自定义查询的JPQL。</p><blockquote><p>第一个自定义简单查询</p></blockquote><p>查询最大id的商品信息，nativeQuery属性表示，是否使用原生SQL，目前使用的JPQL并不是原生的，该属性默认是false，默认可以不写就是使用JPQL查询，这里要注意的是查询使用的表名是实体类，而不是数据表。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**  * 查询id值最大的商品信息  */</span><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SELECT g from Goods g WHERE id = (SELECT max(id) FROM Goods)"</span><span class="token punctuation">,</span> nativeQuery <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token class-name">Goods</span> <span class="token function">getMaxIdGoods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种传递参数的方式：通过参数名来进行传递，通过@Param注解来指定参数名称，在JPQL中使用:参数名的方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">"SELECT g FROM Goods g WHERE name= :name and price &gt;= :price"</span><span class="token punctuation">)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findGoodsBySecondParam</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"price"</span><span class="token punctuation">)</span> <span class="token class-name">BigDecimal</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="JPA原生查询"><a href="#JPA原生查询" class="headerlink" title="JPA原生查询"></a><strong>JPA原生查询</strong></h4><p>之前我们使用的自定义查询都是使用JPQL来进行查询，下面将演示使用原生SQL来进行查询，如下查询所有的商品信息，前面已经介绍过，nativeQuery用来标志当前查询是一条原生SQL。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SELECT * FROM goods"</span><span class="token punctuation">,</span> nativeQuery <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAllNativeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么如果我们想要拿到原生查询的部分结果，那么我们就需要使用Map来进行接收。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SELECT name, price FROM goods"</span><span class="token punctuation">,</span> nativeQuery <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">getGoodsNameAndPriceNativeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员JDBC原理+实战：<a href="https://www.bilibili.com/video/BV1s3411K7jH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1s3411K7jH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>JDBC连接如何防止SQL注入：<a href="https://blog.csdn.net/u014454538/article/details/108952103">https://blog.csdn.net/u014454538/article/details/108952103</a></p><p>Java持久层框架整理：<a href="https://blog.csdn.net/jiamingTu/article/details/106298092">https://blog.csdn.net/jiamingTu/article/details/106298092</a></p><p>为什么90%的开发者放弃使用Hibernate，而选择MyBatis：<a href="https://www.zhihu.com/question/532452772">https://www.zhihu.com/question/532452772</a></p><p>JPA入门：<a href="https://zhuanlan.zhihu.com/p/519013984">https://zhuanlan.zhihu.com/p/519013984</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持久层 </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Survey of Large Language Models</title>
      <link href="/2024/04/24/a-survey-of-large-language-models/"/>
      <url>/2024/04/24/a-survey-of-large-language-models/</url>
      
        <content type="html"><![CDATA[<h1 id="大模型综述"><a href="#大模型综述" class="headerlink" title="大模型综述"></a>大模型综述</h1><p><strong>参考博客：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/630203554">https://zhuanlan.zhihu.com/p/630203554</a></p><p><a href="https://www.cnblogs.com/David-deng/p/17786107.html">https://www.cnblogs.com/David-deng/p/17786107.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/662673023">https://zhuanlan.zhihu.com/p/662673023</a></p><p><a href="https://blog.csdn.net/qq_41185868/article/details/131565801">https://blog.csdn.net/qq_41185868/article/details/131565801</a></p><p><a href="https://mp.weixin.qq.com/s/yIsHsZL2Kbav0LvTUry_dg">https://mp.weixin.qq.com/s/yIsHsZL2Kbav0LvTUry_dg</a></p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>语言模型的四个发展阶段：</p><h3 id="统计语言模型（SLM）"><a href="#统计语言模型（SLM）" class="headerlink" title="统计语言模型（SLM）"></a>统计语言模型（SLM）</h3><p>20世纪90年代，学术界对于统计语言模型(SLM)的研究开始兴起。</p><p><strong>基于马尔可夫假设建立词预测模型</strong>，例如根<strong>据最近的上下文预测下一个词</strong>，例如bigram 和 trigram 语言模型。</p><ul><li>bi-gram语言模型：当前词出现的概率只与上一个词出现的概率相关</li><li>tri-gram语言模型：当前词出现的概率只与上两个词出现的概率相关</li></ul><p>SLM 已被广泛应用于提高信息检索（IR） 和自然语言处理（NLP）任务。</p><p>问题：<strong>维数灾难.需要估计指数级数量的转换概率</strong>，因此很难准确估计高阶语言模型。因此，设计专门的平滑策略，如回退估计和古德图灵估计.</p><h3 id="神经语言模型-NLM"><a href="#神经语言模型-NLM" class="headerlink" title="神经语言模型(NLM)"></a>神经语言模型(NLM)</h3><p>通过神经网络，如循环神经网络（RNN），来<strong>描述单词序列的概率</strong>。在聚合上下文特征（即分布式词向量）的条件下构建词预测函数。</p><p><strong>word2vec  提出了构建一个简化的浅层神经网络来学习分布式单词表示的方法.</strong></p><p>这些研究开创了<strong>将语言模型用于表示学习（超越词序列建模）的应用</strong></p><h3 id="预训练语言模型-PLM"><a href="#预训练语言模型-PLM" class="headerlink" title="预训练语言模型 (PLM)"></a>预训练语言模型 (PLM)</h3><p>ELMo被提出<strong>通过预训练</strong>一个双向 LSTM（biLSTM）<strong>网络</strong>（而不是学习固定的词表示）<strong>来捕捉上下文感知的词表示，然后根据特定的下游任务微调 biLSTM 网络</strong>。</p><p>进一步，<strong>基于自注意力机制的高度并行化 Transformer 架构</strong> [22]，BERT [23] 作为双向语言模型，在大规模无标签语料库上使用专门设计的预训练任务。这些<strong>预训练的上下文感知词表示作为通用语义特征非常有效</strong>，其极大地提高了 NLP 任务的性能。</p><p>确立了“预训练和微调”学习范式。已经建立了大量关于 PLM 的研究，这些研究引入了不同的架构 [24, 25]（例如 GPT-2 [26] 和 BART [24]）或改进的预训练策略 [27–29]。在这个范式中，通常需要对 PLM进行微调以适配不同的下游任务。</p><h3 id="大语言模型-LLM"><a href="#大语言模型-LLM" class="headerlink" title="大语言模型(LLM)"></a>大语言模型(LLM)</h3><p>扩展 PLM（例如扩展模型大小或数据大小）通常会提高下游任务的模型性能（即遵循扩展法则 [30]）。许多研究通过训练越来越大的 PLM（例如 1750 亿参数的 GPT-3 和 5400 亿参数的 PaLM）来探索性能极限。</p><p>大规模的 PLM 与较小的 PLM表现出不同的行为，并在解决一系列复杂任务中展示了惊人的能力（称为涌现能力）。</p><p>例如，GPT-3 可以通过上下文学习（in-context learning, ICL）来解决小样本任务，而 GPT-2 则表现不佳。</p><p>研究界将这些大规模的 PLM 命名为“大语言模型”</p><p>通常，大型语言模型（LLM）是指包含数千亿（或更多）参数的语言模型，这些参数是在大量文本数据上训练的，例如模型 GPT-3、PaLM、Galactica 和 LLaMA。具体来说，LLM 建立在 Transformer 架构之上，其中多头注意力层堆叠在一个非常深的神经网络中。现有的 LLM 主要采用与小语言模型类似的模型架构（即 Transformer）和预训练目标（即语言建模）。作为主要区别，LLM 在很大程度上扩展了模型大小、预训练数据和总计算量（扩大倍数）。他们可以更好地理解自然语言，并根据给定的上下文（例如 prompt）生成高质量的文本。这种容量改进可以用标度律进行部分地描述，其中性能大致遵循模型大小的大幅增加而增加。然而根据标度律，某些能力（例如，上下文学习）是不可预测的，只有当模型大小超过某个水平时才能观察到。</p><h3 id="LLM-vs-PLM"><a href="#LLM-vs-PLM" class="headerlink" title="LLM vs PLM"></a>LLM vs PLM</h3><ul><li><p>wikipedia：大语言模型 (英语：large language model，LLM) 是一种语言模型，由具有许多参数（通常数十亿个权重或更多）的人工神经网络组成，使用自监督学习或半监督学习对大量未标记文本进行训练。大型语言模型在2018年左右出现，并在各种任务中表现出色。</p></li><li><p>本综述的观点：大语言模型是指包含数千亿（或更多）参数的Transformer语言模型，这些模型是在大规模文本数据上进行训练的，例如GPT-3，PaLM，Galactica 和 LLaMA。</p></li><li><p>我的理解：</p><ul><li>通过上面的回答我们可以看出，现在的研究中并没有对于多大的模型才能算作大语言模型有一个确切的定义。通常大语言模型一般拥有数十亿或者更多的参数。</li><li>对于本综述的观点我并不是非常的认可。因为我们知道 LLaMA 2 拥有三个版本，参数量分别是7B、13B和70B，没有达到综述中的千亿参数的规模，但是 LLaMA 2 还是被大家公认为是一个预训练的大语言模型。</li></ul></li></ul><p>1.<strong>LLM具有涌现能力(emergent abilities)：这是llm能解决复杂任务的关键</strong></p><p>2.LLM 将彻底改变人类开发和使用人工智能算法的方式。</p><p>3.LLM 的发展不再明确区分研究和工程。训练 LLM 需要在大规模数据处理和分布式并行训练方面具有丰富的实践经验，研究人员需要与工程人员合作。</p><h3 id="LLM机遇与挑战"><a href="#LLM机遇与挑战" class="headerlink" title="LLM机遇与挑战"></a>LLM机遇与挑战</h3><h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><p>ChatGPT 和 GPT-4 的出现促使人们重新思考通用人工智能（AGI）的可能性。</p><p>在 NLP 领域，LLM 可以在一定程度上作为通用语言任务解决器，研究范式已经转向使用 LLM。在 IR 领域，传统搜索引擎正受到通过 AI 聊天机器人（即 ChatGPT）搜索新信息的挑战。在计算机视觉（CV）领域，研究人员试图开发类似 ChatGPT 的视觉-语言模型，以更好地为多模态对话提供服务。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>其基本原理尚未得到充分探索。</strong></p><p><strong>涌现能力的出现难以解释。研究界缺乏对 LLM 优越能力的关键因素进行深入、详细的研究调查</strong></p><p>研究界很难训练出有能力的 LLM。由于计算资源的巨大需求，为了研究训练 LLM 的各种策略的效果，进行重复、消融研究的成本非常高</p><p>将 LLM 与人类价值观或偏好保持一致是具有挑战的。</p><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2.概述"></a>2.概述</h2><h3 id="2-1背景"><a href="#2-1背景" class="headerlink" title="2.1背景"></a>2.1背景</h3><p>为了对 LLM 的工作原理有一个快速的了解，本部分将介绍 LLM 的基本背景，包括扩展法则、涌现能力和关键技术。</p><h4 id="扩展法则-Scaling-Laws"><a href="#扩展法则-Scaling-Laws" class="headerlink" title="扩展法则 Scaling Laws"></a>扩展法则 Scaling Laws</h4><p><strong>现有的llm采用与小型语言模型类似的Transformer体系结构和预训练目标（例如，语言建模），但大幅度扩展了模型规模、数据规模和总计算量（数量级）。</strong></p><p>扩展可以大幅提高 LLM 的模型能力<strong>，因此，建立一个定量的方法来描述扩展效应是有意义的</strong>。</p><p>两个代表性工作：</p><p>（1）KM scaling law：2020年，Kaplan等人（OpenAI团队）首次提出建模模型参数和三个主要因素（即模型大小N、数据集大小D、训练计算量C）之间的幂律关系。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231023174256702.png" alt="image-20231023174256702"><p>其中L(·)表示使用纳特（nats：在信息论中，nats是自然对数的单位，用于度量信息量或信息熵。它是以自然对数的底数e为基础，表示信息的相对量——from ChatGPT）<strong>表示的交叉熵损失</strong>。这三个定律是在一些假设(例如，一个因素的分析不应该受到其他两个因素的瓶颈)下，通过拟合不同数据大小(22M到23B个tokens)、模型大小(768M到1.5B个非嵌入参数)和训练计算的模型性能得出的。<br>这里，Nc、Dc和Cc分别以非嵌入参数的数量、训练tokens的数量和FP天数来衡量。<br>（2）Chinchilla Scaling law：作为另一项具有代表性的研究，Hoffmann等人（谷歌DeepMind团队）提出了一种缩放定律的替代形式，以指导LLM的计算优化训练。</p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231023174356210.png" alt="image-20231023174356210"></p><p>其中 <em>E</em> = 1*.<em>69</em>, A* = 406*.<em>4</em>, B* = 410*.<em>7，</em>α* = 0*.<em>34 和 <em>β</em> = 0</em>.<em>28。通过在约束条件 <em>C</em> <em>≈</em> 6</em>ND* 下优化损失 <em>L</em>(<em>N, D</em>)，他们展示了将计算预算最优地分配给模型大小和数据大小的方法（如下）：</p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231023174428643.png" alt="image-20231023174428643"></p><p>随着给定计算预算的增加，<strong>KM 扩展法则更偏向于将更大的预算分配给模型大小，而 Chinchilla 扩展法则则认为模型大小和数据大小应该以相同的比例增加</strong>，即在公式 (3)中的 <em>a</em> 和 <em>b</em> 取相近的值。</p><h4 id="涌现能力-emergent-abilities"><a href="#涌现能力-emergent-abilities" class="headerlink" title="涌现能力 emergent abilities"></a>涌现能力 emergent abilities</h4><p>涌现：在小型模型中不存在但在大型模型中产生的能力。这是区别 LLM 与先前 PLM 的最显著特征之一</p><p>LLM 的三种典型涌现能力和具备这种能力的代表性模型：</p><h5 id="上下文学习-In-context-learning"><a href="#上下文学习-In-context-learning" class="headerlink" title="上下文学习 In-context learning"></a>上下文学习 In-context learning</h5><p>为语言模型提供一个自然语言指令和/或几个任务示例，它就可以通过完成输入文本的单词序列的方式来为测试实例生成预期的输出，而无需额外的训练或梯度更新。这种能力还取决于具体的下游任务。</p><p>在 GPT系列模型中，1750 亿的 GPT-3 模型在一般情况下表现出强大的 ICL 能力，但 GPT-1 和 GPT-2 模型则没有。然</p><h5 id="指令遵循-Instruction-following"><a href="#指令遵循-Instruction-following" class="headerlink" title="指令遵循 Instruction following"></a>指令遵循 Instruction following</h5><p>微调 基于自然语言描述来格式化的多任务混合数据集。对于没见过的按照指令的形式描述的任务，LLMs可以在做得很好。</p><p>通过指令微调，LLM 能够在没有使用显式示例的情况下遵循新的任务指令，因此它具有更好的泛化能力。</p><h5 id="逐步推理Step-by-step-reasoning"><a href="#逐步推理Step-by-step-reasoning" class="headerlink" title="逐步推理Step-by-step reasoning"></a>逐步推理Step-by-step reasoning</h5><p>通过使用思维链（Chain-of-Thought, CoT）提示策略 [32]，LLM 可以通过利用包含中间推理步骤的提示机制来解决复杂推理任务</p><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><h5 id="Scaling-扩展"><a href="#Scaling-扩展" class="headerlink" title="Scaling 扩展"></a>Scaling 扩展</h5><p>在Transformer语言模型中存在明显的缩放效应:更大的模型/数据大小和更多的训练计算通常会导致模型能力的改进。<br>此外，由于计算预算通常是有限的，因此可以使用缩放定律来进行计算效率更高的计算资源分配。<br>例如，Chinchilla(具有更多的训练tokens)通过在相同的计算预算下增加数据规模超过了其对应模型Gopher(具有更大的模型大小)。<br>然而，应该注意的是，数据缩放应该伴随着仔细的清理过程，因为预训练数据的质量在模型能力中起着关键作用。</p><h5 id="Training-训练"><a href="#Training-训练" class="headerlink" title="Training 训练"></a>Training 训练</h5><p>为了支持分布式训练，已经发布了几个优化框架来促进并行算法的实现和部署，例如DeepSpeed和Megatron-LM。<br>此外，优化技巧对于训练稳定性和模型性能也很重要，例如重新启动以克服训练损失尖峰和混合精度训练。<br>最近，GPT-4提出开发特殊的基础设施和优化方法，用小得多的模型可靠地预测大型模型的性能。</p><h5 id="Ability-Eliciting-能力引导"><a href="#Ability-Eliciting-能力引导" class="headerlink" title="Ability Eliciting 能力引导"></a>Ability Eliciting 能力引导</h5><p>作为一种技术方法，设计合适的任务指令或特定的上下文学习策略来诱导这种能力是有用的。<br>例如，思维链提示，即通过中间推理步骤以解决复杂的推理任务，已被证明是有用的。<br>此外，我们还可以对LLMs进行指令微调，用自然语言表达任务描述，提高LLMs对不曾见过的任务的泛化能力。</p><h5 id="Alignment-Tuning-对齐微调"><a href="#Alignment-Tuning-对齐微调" class="headerlink" title="Alignment Tuning 对齐微调"></a>Alignment Tuning 对齐微调</h5><p>有必要使 LLM 与人类价值观保持一致，例如有用性、诚实性和无害性。</p><p>为此，InstructGPT设计了一种有效的调优方法，使llm能够遵循预期的指令，该方法利用了带有人类反馈的强化学习技术（RLHF）。<br>ChatGPT确实是在与InstructGPT类似的技术基础上开发的，其在产生高质量、无害的回复方面显示出强大的对齐能力，例如，拒绝回答侮辱性的问题。</p><h5 id="Tool-Manipulation-工具操作"><a href="#Tool-Manipulation-工具操作" class="headerlink" title="Tool Manipulation 工具操作"></a>Tool Manipulation 工具操作</h5><p>从本质上讲，LLMs在大量纯文本语料库上被训练为文本生成器，因此在不能最好地以文本形式表达的任务(例如，数值计算)上表现不佳。此外，它们的能力也局限于预训练数据，例如，无法获取最新信息。为了解决这些问题，最近提出的一种技术是使用外部工具来弥补LLMs的不足。<br>例如，LLMs可以利用计算器进行精确计算，利用搜索引擎检索未知信息。最近，ChatGPT启用了使用外部插件(现有或新创建的应用程序)的机制，这被类比为LLMs的“眼睛和耳朵”。这种机制可以广泛扩展 LLM 的能力范围。</p><h3 id="2-2技术演进"><a href="#2-2技术演进" class="headerlink" title="2.2技术演进"></a>2.2技术演进</h3><img src="/2024/04/24/a-survey-of-large-language-models/image-20231106143336059.png" alt="image-20231106143336059" style="zoom:80%;"><p>GPT模型的基本原理是通过语言建模将世界知识压缩为仅含解码器的Transformer模型，从而恢复（或记忆）世界知识的语义，并充当通用任务求解器。成功的两个关键点是 (1)只训练解码器的Transformer语言模型，可以准确地预测下一个词  (2) 扩大语言模型的规模</p><h5 id="早期探索阶段"><a href="#早期探索阶段" class="headerlink" title="早期探索阶段"></a>早期探索阶段</h5><p>随着 Transformer 的出现，OpenAI开发了两个初始的 GPT 模型，即GPT-1和GPT-2</p><p>GPT表示生成式预训练（<em>Generative Pre-Training</em>）。GPT-1是基于生成式、仅解码器的Transformer架构开发的，采用了无监督预训练和有监督微调的混合方法。</p><p>GPT-2采用与GPT-1类似的架构，将参数尺度增加到1.5B，使用大型网页数据集WebText进行训练。它试图通过无监督语言建模来执行任务，而无需使用标记数据进行显式的微调。为了推动这种方法，他们引入了多任务求解的概率形式，即<em>p</em>(<em>output</em>*|*<em>input, task</em>)（类似的方法已在 [75] 中采用），它在给定输入和任务信息的条件下预测输出。为了对该条件概率建模，自然语言文本可以自然地用作为格式化输入、输出和任务信息的统一方式。通过这种方式，解决任务的过程可以被视为生成解决方案文本的单词预测问题。</p><p>由于(特定于任务的)监督目标与无监督(语言建模)目标相同，但只在序列的一个子集上进行评估，因此无监督目标的全局最小值也是监督目标的全局最小值(对于各种任务)。</p><p>对这个主张的基本理解是，每个 NLP 任务可以被视为基于世界文本的子集的单词预测问题。因此，如果模型训练后具有足够能力以复原世界文本，无监督语言建模可以解决各种任务。</p><h5 id="能力飞跃"><a href="#能力飞跃" class="headerlink" title="能力飞跃"></a>能力飞跃</h5><p>尽管GPT-2旨在成为一个“无监督多任务学习器”，但与监督微调的最先进方法相比，它的总体性能较差。<br>虽然它的模型尺寸相对较小，但它在下游任务中进行了广泛的微调，特别是对话任务。在GPT-2的基础上，GPT-3通过扩展(几乎相同的)生成预训练架构展示了关键的能力飞跃。<br>GPT-3扩展到175B参数，并引入上下文学习(ICL)的概念，它以少样本或零样本的方式利用LLM。</p><p>LLM 的预训练和使用在 ICL 下有着相同的语言建模范式：预训练预测给定上下文条件下的后续文本序列，而 ICL 预测正确的任务解决方案，该解决方案可以被格式化为给定任务描述和示范下的文本序列。</p><h5 id="能力增强"><a href="#能力增强" class="headerlink" title="能力增强"></a>能力增强</h5><p>OpenAI 探索了两种主要方法来进一步改进 GPT-3 模型，即使用代码数据进行训练以及与人类偏好的对齐</p><p><strong>使用代码数据进行训练：</strong></p><p>原始的GPT-3模型(在纯文本上预训练)的局限在于缺乏复杂任务的推理能力，例如补全代码和解决数学问题。<br>为了增强这种能力，OpenAI于2021年7月引入了Codex，这是一个在大型GitHub代码语料库上进行微调的GPT模型。它证明了Codex可以解决非常困难的编程问题，并且在解决数学问题时也可以显著提高性能。<br>此外，2022年1月报道了一种用于训练文本和代码嵌入的对比方法，该方法被证明可以改进一系列相关任务(即线性探测分类、文本搜索和代码搜索)。<br>实际上，GPT-3.5模型是基于基于代码的GPT模型(即code-davinci-002)开发的，这表明对代码数据的训练是提高GPT模型的建模能力，特别是推理能力的一个非常有用的实践。<br>此外，也有人推测，对代码数据进行训练可以大大提高LLMs的思维链提示能力，但这仍值得进一步研究，需要更彻底的验证。</p><p><strong>与人类对齐</strong><br>OpenAI对人类偏好的相关研究可以追溯到2017年(或更早):OpenAI博客上发表了一篇题为“从人类偏好中学习”的博客文章，描述了一项应用强化学习(RL)从人类标注的偏好比较中学习的工作。(类似于InstructGPT的图6中对齐算法中的reward-training步骤)。<br>这篇RL文章发布不久后，PPO的文章（Proximal Policy Optimization)于2017年7月发表，目前已成为从人类偏好中学习的基础强化学习算法。<br>随后在2020年1月，使用上述RL算法对GPT-2进行了微调，该算法利用人类偏好来提高GPT-2在NLP任务上的能力。同年，另一项研究以类似的方式训练了一个优化人类偏好的摘要模型。<br>在这些前期工作的基础上，2022年1月InstructGPT被提出，用于改进GPT-3模型的人类对齐，该模型正式建立了一种<strong>基于人类反馈的三阶段强化学习(RLHF)算法</strong>。请注意，OpenAI的论文和文档中似乎很少使用“instruction tuning”的措辞，取而代之的是对人类示例的有监督微调(即RLHF算法的第一步)。<br>除了提高指令遵循能力外，RLHF算法在减轻LLMs产生有害或有毒内容的问题上特别有用，这是LLMs在实践中安全部署的关键。</p><p>这些增强技术导致改进后的GPT-3模型具有更强的能力，OpenAI将其称为GPT-3.5模型。</p><h5 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h5><p><strong>chatgpt</strong></p><p>ChatGPT的训练方式与InstructGPT类似，但专门针对对话能力进行了优化。</p><p>他们报告了ChatGPT和InstructGPT在数据收集设置上的训练差异:人工生成的对话(扮演用户和人工智能的角色)与InstructGPT数据集以对话格式相结合，用于训练ChatGPT。</p><p>拥有丰富的知识库，擅长解决数学问题，准确追踪多轮对话中的上下文，并与人类的价值观保持一致以确保被安全使用。支持插件机制，这进一步扩展了ChatGPT与现有工具或应用程序的能力。</p><p><strong>GPT-4</strong></p><p>GPT-4于2023年3月发布，将文本输入扩展到多模态信号。</p><p>由于经过为期六个月的迭代对齐（在RLHF训练中加入了额外的安全奖励信号），GPT-4对于具有恶意或挑衅的提问的响应更加安全。例如，他们引入了一种称为红队评估（<em>red teaming</em>）的机制来减少有害或生成有毒内容的可能性。他们引入了一种称为可预测扩展（<em>predictablescaling</em>）的新机制，可以使用模型训练期间一小部分的计算量来准确预测最终性能。</p><p>从工程的角度来看，OpenAI采用了一种迭代部署策略，通过遵循五阶段的开发和部署生命周期来开发模型和产品，以有效降低使用模型带来的潜在风险。</p><h2 id="3-大模型资源"><a href="#3-大模型资源" class="headerlink" title="3.大模型资源"></a>3.大模型资源</h2><p>考虑到技术问题的挑战和计算资源的巨大需求，开发或复现LLM 绝非易事。一种可行的方法是在现有的 LLM 的基础上进行开发，即重复使用公开可用的资源进行增量开发或实验研究。在本节中，我们简要整理了用于开发 LLM 的公开可用的资源，包括公开的模型检查点（或 API）、语料库和代码库。</p><h3 id="3-1公开的模型检查点或API"><a href="#3-1公开的模型检查点或API" class="headerlink" title="3.1公开的模型检查点或API"></a>3.1公开的模型检查点或API</h3><p><strong>百亿参数模型</strong></p><p>除LLaMA(最大版本包含65B个参数)和NLLB(最大版本包含54.5B个参数)外，该类模型的参数尺度大多在10B - 20B之间。</p><p>Flan-T5 (11B版本)可以作为研究指令调优（instruction tuning）的首选模型，因为它从三个方面探索指令调优：增加任务数量，缩放模型大小，以及使用思维链提示数据进行微调。<br>此外，CodeGen (11B版本)作为一种为生成代码而设计的自回归语言模型，可以认为是探索代码生成能力的一个很好的候选。它还引入了一个专门针对多轮程序合成的新基准MTPB，由115个专家生成的问题组成。为了解决这些问题，LLMs需要掌握足够的编程知识(如数学、数组操作和算法)。<br>对于多语言任务，mT0 (13B版本)可能是一个很好的候选模型，它已经对具有多语言提示的多语言任务进行了微调。<br>此外，PanGu-α在基于深度学习框架MindSpore开发的中文下游任务中，在零样本或少样本设置中表现良好。（注意PanGu-α有多个版本，最大有200B参数，公开的最大版本是13B）。由于LLaMA的开放性和有效性，它已经引起了研究界的极大关注，许多努力都致力于对其不同的模型版本进行微调或持续预训练，以实现新的模型或工具。<br>通常，这种规模的预训练模型需要数百甚至数千个gpu或tpu。例如，GPT-NeoX-20B使用12台超微服务器，每台服务器配备8个NVIDIA A100-SXM4-40GB gpu，而LLaMA在其原始出版物中使用2,048个A100-80G gpu。</p><p><strong>千亿参数模型</strong></p><p>在跨语言泛化研究中，BLOOM (176B版本)和BLOOMZ (176B版本)可以作为基础模型，因为它们在多语言语言建模任务中的能力。<br>在这些模型中，OPT-IML已经使用指令进行了调优，这可能是研究指令调优效果的良好候选者。<br>这种规模的模型通常需要数千个gpu或tpu来训练。例如，OPT (175B版本)使用992个A100-80GB GPU，而GLM (130B版本)使用96个NVIDIA DGX-A100 (8x40G) GPU节点的集群。</p><p><strong>公共API</strong></p><p>OpenAI为GPT-3系列模型提供了七个主要接口：ada、babbage、curie、davinci (GPT-3系列中最强大的版本)、text-ada-001、text-babbage-001和text-curie-001。其中，前四个接口可以在OpenAI的主机服务器上进一步微调。babbage、curie和davinci分别对应于GPT-3 (1B)、GPT-3 (6.7B)和GPT-3 (175B)模型。<br>此外，还有两个与Codex相关的api，称为code-cushman-001 (Codex (12B)的强大多语言版本)和code-davinci-002。<br>此外，GPT-3.5系列包括一个基础模型code-davinci-002和三个增强版本，即text-davinci-002, text-davinci-003和GPT-3.5-turbo-0301。值得注意的是，gpt-3.5-turbo-0301是调用ChatGPT的接口。<br>最近，OpenAI也为GPT-4发布了相应的api，包括gpt-4、gpt-4-0314、gpt-4-32k和gpt-4-32k-0314。<br>api详细用法见：<a href="https://link.zhihu.com/?target=https://platform.openai.com/docs/models/overview">https://platform.openai.com/doc</a></p><h3 id="3-2常用语料库"><a href="#3-2常用语料库" class="headerlink" title="3.2常用语料库"></a>3.2常用语料库</h3><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231106164749415.png" alt="image-20231106164749415"></p><h4 id="books"><a href="#books" class="headerlink" title="books"></a>books</h4><p>BookCorpus–小规模模型（如 GPT和 GPT-2）中常用的数据集，包括超过 11,000 本电子书，涵盖广泛的主题和类型（如小说和传记）。另一个大规模的书</p><p>籍语料库是 Gutenberg，它有超过 70,000 本文学作品，包括小说、散文、诗歌、戏剧、历史、科学、哲学和其他公共领域的作品。它是目前最大的开源书籍集合之一，被用于训练 MT-NLG 和 LLaMA。</p><h4 id="CommonCrawl"><a href="#CommonCrawl" class="headerlink" title="CommonCrawl"></a><strong>CommonCrawl</strong></h4><p> <strong>CommonCraw 是最大的开源网络爬虫数据库之一</strong>，包含百万亿字节级的数据量，已被广泛用作LLMs训练。</p><p>由于web数据中普遍存在噪声和低质量的信息，因此在使用前需要对数据进行预处理。现有工作中常用的过滤数据集有四种：C4、CCStories、CC-News和RealNews。C4包括五个变体，即en (806G)， en.noclean (6T)、realnewslike (36G)、web-textlike (17G)和multilingual (38T)。en版本已被用于T5、LaMDA、Gopher和UL2的预训练。multilingual C4，也称为mC4，已在mT5中使用。</p><h4 id="Reddit-Links"><a href="#Reddit-Links" class="headerlink" title="Reddit Links"></a>Reddit Links</h4><p>Reddit是一个社交媒体平台，用户可以提交链接和文本帖子，其他人可以通过“赞”或“贬”对这些帖子进行投票。WebText 就是一个著名的基于 Reddit 的语料库，它由 Reddit 上高赞的链接组成，但尚未公开。作为替代，有一个易于获取的开源替代品叫做 OpenWebText。</p><h4 id="Wikipedia"><a href="#Wikipedia" class="headerlink" title="Wikipedia"></a>Wikipedia</h4><p>维基百科是一个在线百科全书，包含大量关于不同主题的高质量文章。通常情况下，维基百科的纯英文过滤版本在大多数LLMs中被广泛使用(例如GPT-3， LaMDA和LLaMA)。维基百科有多种语言版本，因此它可以在多语言环境中使用。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>代码数据有两个主要来源：包括开源许可证的公共代码库（例如 GitHub）和与代码相关的问答平台（例如 StackOverflow）。</p><p>Google 公开发布了 BigQuery 数据集，其中包括各种编程语言的大量开源许可证代码片段，是一个典型的代码数据集。</p><p>CodeGen 使用的 BIGQUERY是 BigQuery 数据集的一个子集，用于训练多语言版本的CodeGen（CodeGen-Multi）。</p><h4 id="others"><a href="#others" class="headerlink" title="others"></a>others</h4><p>The Pile是一个大规模、多样化、开源的文本数据集，有超过 800GB 数据，内容包括书籍、网站、代码、科学论文和社交媒体平台等。它由 22 个多样化的高质量子集构成。The Pile数据集广泛应用于不同参数规模的模型中，如GPT-J (6B)、CodeGen (16B)、MegatronTuring NLG (530B)。<br>此外，ROOTS由各种较小的数据集(总共1.61 TB的文本)组成，涵盖59种不同的语言(包括自然语言和编程语言)，被用来训练BLOOM。</p><p><strong>给出了三个代表性LLMs的预训练语料库：</strong><br>（1）GPT-3 (175B)：在一个包含300B个tokens的混合数据集上进行训练，包括CommonCrawl、WebText2、Books1、Books2和Wikipedia。<br>（2）PaLM (540B)：使用780B tokens的预训练数据集，这些数据来自社交媒体对话、过滤的网页、书籍、Github、多语言维基百科和新闻。<br>（3）LLaMA：从各种来源提取训练数据，包括CommonCrawl, C4 , Github, Wikipedia, books, ArXiv和StackExchange。LLaMA (6B)和LLaMA (13B)的训练数据大小为1.0T tokens，LLaMA (32B)和LLaMA (65B)的训练数据大小为1.4T tokens。</p><h3 id="3-3代码库资源"><a href="#3-3代码库资源" class="headerlink" title="3.3代码库资源"></a>3.3代码库资源</h3><p>（1）Transformers是一个开源Python库，用于使用Transformer架构构建模型，由Hugging Face开发和维护。方便使用和定制各种预训练模型。<br>（2）DeepSpeed是微软开发的深度学习优化库(与PyTorch兼容)，已被用于训练多个LLMs，如MT-NLG和BLOOM。它为分布式训练提供了各种优化技术的支持，例如内存优化(ZeRO技术、梯度检查点)和流水线并行。<br>（3）Megatron-LM是NVIDIA开发的用于训练大规模语言模型的深度学习库。它还为分布式训练提供了丰富的优化技术，包括模型和数据并行、混合精度训练和FlashAttention。这些优化技术可以大大提高训练效率和速度，实现高效的跨GPU分布式训练。<br>（4）JAX是谷歌开发的用于高性能机器学习算法的Python库，允许用户轻松地在硬件加速(例如GPU或TPU)下对数组执行计算。它可以在各种设备上进行有效的计算，并且还支持一些功能，例如自动微分和即时编译。<br>（5）colossal-AI是由HPC-AI Tech开发的用于训练大规模AI模型的深度学习库。它是基于PyTorch实现，并支持丰富的并行训练策略集合。此外，它还可以使用PatrickStar提出的方法优化异构内存管理。最近，一个名为ColossalChat的类chatgpt的模型已经公开发布了两个版本(7B和13B)，它是基于LLaMA使用colossal-ai开发的。<br>（6）BMTrain是OpenBMB开发的用于分布式训练大规模参数模型的高效库，强调代码简洁、低资源、高可用性。BMTrain已经将几个常见的LLM(例如，Flan-T5和GLM)合并到其ModelCenter中，开发人员可以直接使用这些模型。<br>（7）FastMoE是MoE(即混合专家)模型的专门训练库。它是基于PyTorch开发的，在设计中优先考虑效率和用户友好性。FastMoE简化了将Transformer模型转换为MoE模型的过程，并在训练期间支持数据并行和模型并行。<br>除了上述库资源外，现有的深度学习框架(如PyTorch、TensorFlow、MXNet、PaddlePaddle、MindSpore和OneFlow)也提供了对并行算法的支持，并行算法通常用于训练大规模模型。</p><h2 id="4-预训练"><a href="#4-预训练" class="headerlink" title="4.预训练"></a>4.预训练</h2><p>预训练为 LLM 的能力奠定了基础。通过在大规模语料库上进行预训练，LLM 可以获得基本的语言理解和生成能力。</p><h3 id="4-1数据收集"><a href="#4-1数据收集" class="headerlink" title="4.1数据收集"></a>4.1数据收集</h3><img src="/2024/04/24/a-survey-of-large-language-models/image-20231120151109467.png" alt="image-20231120151109467" style="zoom:80%;"><h4 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h4><p>预训练语料库的来源可以广义地分为两种类型：通用文本数据和专用文本数据。</p><p>通用文本数据，如网页、书籍和对话文本等，其由于规模大、多样性强且易于获取的特点，被大多数 LLM 所利用，这可以增强 LLM 的语言建模和泛化能力。</p><p><strong>通用文本数据</strong>：</p><p>之前的工作从网络中爬取了大量的数据，如CommonCrawl。抓取的web数据往往既包含高质量的文本(如Wikipedia)，也包含低质量的文本(如垃圾邮件)，因此对网页进行过滤和处理以提高数据质量非常重要。</p><p>对话数据可以增强 LLM 的对话能力，并可能改善 LLM 在问答任务上的表现 。由于在线对话数据通常涉及多个参与者之间的讨论，因此一种有效的处理方法是将对话转换为树状结构，其中话语与它所响应的话语相关联。过度引入对话数据来训练 LLM 可能会导致一个潜在的风险：<strong>陈述性指令和直接疑问句被错误地认为是对话的开始，从而导致指令的有效性下降。</strong></p><p>书籍提供了更正式的长文本，这对于 LLM <strong>学习语言知识、建模长期依赖关系以及生成叙述性和连贯的文本</strong>具有潜在的好处。为了获取开源图书数据，现有研究通常采用Books3和Bookcorpus2数据集，这两个数据集在Pile数据集中都有。</p><p><strong>专用文本数据</strong>：</p><p>专用数据通常对LLMs执行下游任务有用，包括多语言文本、科学文本、代码。整合多语言语料库可以增强模型的多语言的理解和生成能力。例如，BLOOM和PaLM在其预训练语料库中分别制作了涵盖46种和122种语言的多语言数据。</p><p><strong>通过在大量科学文本上进行预训练，LLM 可以在科学和推理任务中取得出色的性能。</strong>为了构建科学语料库，现有的工作主要是收集arXiv论文、科学教科书、数学网页以及其他相关的科学资源。由于科学领域中数据的复杂性，例如数学符号和蛋白质序列，通常需要特定的标记化（tokenization）和预处理技术来将这些不同格式的数据转换为可以由语言模型处理的统一形式。</p><p>一般来说，两种类型的代码语料库通常用于预训练LLM。第一个来源是编程问答社区，如Stack Exchange。第二个来源是开源软件仓库，如GitHub，它们收集代码数据(包括注释和文档字符串)以供使用。</p><p>与自然语言文本相比，代码以编程语言的格式呈现，对应着长距离依赖和准确的执行逻辑。最近的一项研究还推测，<strong>训练代码可能是复杂推理能力（例如 CoT 能力）的来源。此外，将推理任务格式化为代码的形式还可以帮助 LLM 生成更准确的结果。</strong></p><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><h5 id="质量过滤"><a href="#质量过滤" class="headerlink" title="质量过滤"></a>质量过滤</h5><p>为删除收集到的语料库中的低质量数据，现有的工作通常采用两种方法：（1）基于分类器的方法，和（2）基于启发式的方法。</p><p>前者通常训练一个二元分类器，<strong>将高质量数据(例如，维基百科页面)作为正实例，将样本候选数据作为负实例</strong>，并预测衡量每个数据示例质量的分数。</p><p>问题：<strong>基于分类器的方法可能会删除方言、口语和社会语言的高质量文本，从而可能导致有偏见的预训练语料库，并减少语料库的多样性</strong>。</p><p>第二种方法，BLOOM和Gopher等几项研究采用了基于启发式的方法，通过一套精心设计的规则来消除低质量的文本，这些规则可以总结如下：<br>a）基于语言的过滤。<strong>如果LLM主要用于某些语言的任务，则可以过滤其他语言的文本。</strong><br>b）基于度量的过滤。关于生成文本的<strong>评估指标</strong>，例如，<strong>困惑度，可以用来检测和删除不自然的句子。</strong><br>c）基于统计的过滤。语料库的统计特征，例如：如标点分布、字数比、句子长度等，可以用来衡量文本质量，过滤低质量数据。<br>d）基于关键词过滤。基于特定的关键词集合，可以识别和删除文本中<strong>嘈杂或无用的元素，如HTML标记、超链接、样板和冒犯性词语。</strong></p><h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><p>语料库中的重复数据会降低语言模型的多样性，这可能导致训练过程变得不稳定，从而影响模型的性能。特别地，去重可以在不同的粒度上执行，包括句子级、文档级和数据集级的去重。</p><p>a）在句子级别，应<strong>删除含有重复单词</strong>和短语的低质量句子，因为它们可能会在语言建模中引入重复的模式。<br>b）在文档层面，现有的研究大多**依靠文档之间表面特征的重叠比例(**如word和n-gram overlap)来检测和去除内容相似的重复文档。<br>c）为了避免数据集污染问题，通过从训练集中删除可能的重复文本，防止训练集和评估集之间的重叠也至关重要。</p><h5 id="隐私去除"><a href="#隐私去除" class="headerlink" title="隐私去除"></a>隐私去除</h5><p>需要从预训练语料库中删除可识别个人信息（PII）。一种直接有效的方法是采用基于规则的方法，例如关键字识别，来检测和删除 PII，例如姓名、地址和电话号码。此外，LLM 在隐私攻击下的脆弱性可能归因于预训练语料库中存在的重复 PII 数据。因此，去重也可以在一定程度上降低隐私风险。</p><h5 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h5><p>将原始文本分割成词序列，随后用作 LLM 的输入。</p><p>使用<strong>专门为预训练语料库设计的分词器</strong>可能会更加有效，特别是对于由多种领域、语言和格式组成的语料库。</p><p>最近的几个 LLM 使用<strong>SentencePiece为预训练语料库训练定制化的分词器</strong>。同时<strong>利用字节级的 <em>Byte Pair Encoding (BPE)</em> 算法来确保分词后的信息不会丢失</strong> </p><h4 id="数据对llm的影响"><a href="#数据对llm的影响" class="headerlink" title="数据对llm的影响"></a>数据对llm的影响</h4><p>（1）混合来源<br>通过对来自不同来源的混合文本数据进行预训练，LLMs可以获得广泛的知识，并可能表现出强大的泛化能力。当混合不同的数据源时，需要仔细设置预训练数据的分布，因为这也可能影响LLMs在下游任务上的性能。<br>Gopher对数据分布进行消融实验，考察混合源对下游任务的影响。<br>在LAMBADA数据集上的实验结果表明，增加图书数据的比例可以提高模型从文本中捕获长期依赖关系的能力，增加C4数据集的比例可以提高C4验证数据集的性能。然而，作为一个副作用，对某一领域的过多数据进行训练会影响LLMs在其他领域的泛化能力。<br>（2）预训练数据的数量<br>对于模型性能来说，在数据规模方面也观察到与模型规模相似的扩展法则。最近的一项研究表明，由于预训练数据不足，许多现有的LLM遭受次优训练。<br>通过广泛的实验，进一步证明了在给定的计算预算下，以相同的规模增加模型大小和数据大小可以得到计算效率更高的模型(即Chinchilla模型)。最近，LLaMA表明，在更多的数据和更长的训练时间下，较小的模型也可以获得良好的性能。<br>（3）预训练数据的质量<br>最近的研究，如T5、GLaM和Gopher，研究了数据质量对下游任务性能的影响。通过比较在过滤和未过滤的语料库上训练的模型的性能，他们得出了相同的结论，即在清洗过的数据上预训练LLMs可以提高性能。更具体地说，数据的重复可能会导致“双下降现象”（指性能最初恶化，随后得到改善），甚至可能会使训练过程不稳定。</p><h3 id="4-2架构"><a href="#4-2架构" class="headerlink" title="4.2架构"></a>4.2架构</h3><h4 id="主流架构"><a href="#主流架构" class="headerlink" title="主流架构"></a>主流架构</h4><p>现有 LLM 的主流架构可以大致分为三种类型，即编码器-解码器、因果解码器和前缀解码器。</p><p><strong>编码器-解码器架构</strong></p><p>传统 Transformer 模型是建立在编码器-解码器架构上，<strong>由两个 Transformer 块分别作为编码器和解码器</strong>。编码器采用堆叠的多头自注意层对输入序列进行编码以生成其潜在表示，而解码器对这些表示进行交叉注意并自回归地生成目标序列。</p><p>目前，只有少数LLM 是基于编码器-解码器架构构建的，例如 Flan-T5。</p><p><strong>因果解码器架构</strong></p><p>因果解码器架构采用单向注意力掩码，以确保每个输入 token 只能关注过去的 token 和它本身。输入和输出 token 通过解码器以相同的方式进行处理。</p><p>作为这种架构的代表性语言模型，GPT 系列模型是基于因果解码器架构开发的。</p><p>到目前为止，因果解码器已被各种现有LLMs广泛采用作为LLMs的架构，如OPT、BLOOM和Gopher。</p><p><strong>前缀解码器架构</strong></p><p>前缀解码器架构（也称非因果解码器架构）修正了因果解码器的掩码机制，使其能够对前缀 token 执行双向注意力，并仅对生成的 token 执行单向注意力。</p><p>前缀解码器可以双向编码前缀序列并自回归地逐个预测输出 token，其中在编码和解码过程中共享相同的参数。</p><p>基于前缀解码器架构的现有代表性 LLM 包括 GLM-130B和 U-PaLM。</p><p>对于这三种类型的架构，我们还可以考虑通过混合专家(MoE)缩放来扩展它们，其中每个输入的神经网络权重子集被稀疏激活，例如Switch Transformer和GLaM。研究表明，通过增加专家数量或总参数大小，可以观察到实质性的性能改进。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231120183205440.png" alt="image-20231120183205440" style="zoom:80%;"><h4 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h4><p>自 Transformer推出以来，已经提出了各种改进方法来提高其训练稳定性、性能和计算效率。在这部分中，我们将讨论Transformer 的四个主要部分的相应配置，包括标准化、位置编码、激活函数、注意力和偏置。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231121162112958.png" alt="image-20231121162112958" style="zoom:80%;"><h5 id="标准化（归一化）"><a href="#标准化（归一化）" class="headerlink" title="标准化（归一化）"></a>标准化（归一化）</h5><p>训练不稳定是预训练 LLM 的一个难题。为了缓解这个问题，<strong>层标准化 (Layer Norm, LN) 被广泛应用于Transformer 架构中</strong>。</p><p>Sandwich-LN在pre-LN的基础上，在剩余连接之前增加了额外的LN，以避免值爆炸。然而，研究发现，<strong>Sandwich-LN有时不能稳定训练LLMs，可能导致训练的崩溃。</strong><br>最近，人们提出了几种先进的规范化技术来替代LN。在Gopher和Chinchilla中，由于RMS Norm在训练速度和性能上的优势，采用了RMS Norm。与LN相比，DeepNorm在训练稳定性方面表现出了更好的能力，和后标准化一起被 GLM-130B 采用。</p><p>此外，<strong>在嵌入层之后增加一个LN也可以稳定LLMs的训练。然而，它往往会导致显著的性能下降，在最近的几个LLMs中已经被移除。</strong></p><h5 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h5><p>为了获得良好的性能，在前馈网络中也需要设置合适的激活函数。在现有的 LLM 中，广泛使用 GeLU 激活函数。</p><p>在现有LLMs中，GeLU激活被广泛使用。此外，在最新的LLMs(如PaLM和LaMDA)中，也使用了GLU激活的变体，特别是SwiGLU和GeGLU变体，在实践中往往取得更好的性能。然而，与GeLU相比，它们在前馈网络中需要额外的参数(约50%)。</p><h5 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h5><p>由于 Transformer 中的自注意模块具有置换不变性，因此需要使用位置编码来注入绝对或相对位置信息以建模序列。在经典的 Transformer 中有两种绝对位置编码的变体，即正弦函数和学习的位置编码，后者通常在 LLM 中使用。</p><p>不同于绝对位置编码，相对位置编码根据键和查询之间的偏移量生成嵌入，因此它可以在比训练期间看到的序列更长的序列上表现良好，即外推。ALiBi使用基于键和查询之间距离的惩罚来偏差注意力得分。实证结果表明，与其他位置嵌入相比，该方法具有更好的零样本泛化和更强的外推能力。此外，通过基于绝对位置设置特定的旋转矩阵，RoPE中键和查询之间的分数可以通过相对位置信息计算出来，这对长序列建模很有用。因此，RoPE在一些最新的LLMs中被广泛采用。</p><h5 id="注意力机制和偏置"><a href="#注意力机制和偏置" class="headerlink" title="注意力机制和偏置"></a>注意力机制和偏置</h5><p>除了原始 Transformer 中的全自注意力机制，GPT-3 采用了更低计算复杂度的稀疏注意力机制，即分解注意力。为了有效且高效地建模更长的序列，研究者们尝试引入特殊的注意力模式或考虑显存访问（即 FlashAttention）。</p><p>此外，与原始 Transformer一样，大多数 LLM 在每个线性层和层标准化中保留了偏置</p><h4 id="预训练任务"><a href="#预训练任务" class="headerlink" title="预训练任务"></a>预训练任务</h4><p>对于训练 LLM，有两个常用的预训练任务，即语言建模和去噪自编码。</p><h6 id="语言建模"><a href="#语言建模" class="headerlink" title="语言建模"></a><strong>语言建模</strong></h6><p>Language Modeling(LM) 语言建模任务(LM)是预训练Decoder-only的LLMs最常用的目标，例如GPT3和PaLM。给定一个token 序列 x = *{x1, . . . , xn}*，LM 任务旨在基于序列中前面的 token x&lt;i，自回归地预测目标 token <em>xi</em>。通常的训练目标是最大化以下似然函数：</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231121180748353.png" alt="image-20231121180748353" style="zoom:80%;"><p>由于大多数语言任务可以转换为基于输入的预测问题来解决，因此这些仅包含解码器的 LLM 可能具有优势，可以隐式地学习如何以统一的 LM 方式完成这些任务。一些研究还表明，仅包含解码器的 LLM 可以通过自回归地预测下一个token 而自然地迁移到某些任务中，而无需微调。</p><p>LM的一个重要变体是前缀语言建模任务，它是为预训练具有前缀解码器架构的模型设计的。在计算前缀语言模型的损失时，将不使用随机选择的前缀内的 token。由于模型预训练涉及的序列中 token 较少，因此在使用相同数量的预训练 token 时，前缀语言模型的性能往往略低于传统语言模型任务 </p><h6 id="去噪自编码"><a href="#去噪自编码" class="headerlink" title="去噪自编码"></a><strong>去噪自编码</strong></h6><img src="/2024/04/24/a-survey-of-large-language-models/image-20231121180955197.png" alt="image-20231121180955197" style="zoom:80%;"><p>通过使用语言模型目标进行预训练，因果解码器架构似乎可以实现更优越的零样本和小样本泛化能力。在没有进行多任务微调的情况下，因果解码器比其他架构具有更好的零样本性能。通过扩展模型大小、数据集大小和总计算量，可以大幅提高因果解码器的性能 </p><h3 id="4-3模型训练"><a href="#4-3模型训练" class="headerlink" title="4.3模型训练"></a>4.3模型训练</h3><h4 id="优化设置"><a href="#优化设置" class="headerlink" title="优化设置"></a>优化设置</h4><h5 id="批量训练Batch-Training"><a href="#批量训练Batch-Training" class="headerlink" title="批量训练Batch Training"></a>批量训练Batch Training</h5><p>对于语言模型的预训练，现有的研究通常将<strong>批量大小（batch size）</strong>设置为较大的数字（如 2,048 个例子或 400 万个 token），以提高训练的稳定性和吞吐量。像 GPT-3 和 PaLM 这样的LLM 引入了一种新的策略，即<strong>在训练过程中动态增加批量大小，最终达到百万级别</strong>。具体而言，GPT-3 的批量大小从 3.2万逐渐增加到 320 万个 token。实证结果表明，动态调整批量大小的策略可以有效地稳定 LLM 的训练过程。</p><h5 id="学习率Learning-Rate"><a href="#学习率Learning-Rate" class="headerlink" title="学习率Learning Rate"></a>学习率Learning Rate</h5><p>现有的LLMs通常在预训练期间采用类似的预热（warm-up）和衰减（decay）策略的学习率调度计划。具体地说，在最初的0.1%到0.5%的训练步骤中，采用线性预热策略linear warm-up schedule，逐步将学习率提高到最大值，范围约为5 × 10^−5到1 × 10^−4(例如:GPT-3为6 × 10^−5)。然后在后续步骤中采用余弦衰减策略，逐渐将学习率降低到其最大值的10%左右，直到训练损失收敛。</p><h5 id="优化器Optimizer"><a href="#优化器Optimizer" class="headerlink" title="优化器Optimizer"></a>优化器Optimizer</h5><p>Adam优化器和AdamW优化器被广泛用于训练LLMs(例如GPT3)，它们基于一阶梯度优化的低阶矩的自适应估计。通常，它的超参数设置如下：<em>β</em>1 = 0*.<em>9，</em>β<em>2 = 0</em>.<em>95 和 <em>ϵ</em> = 10</em>−*8。</p><p>同时，Adafactor优化器也被用于训练LLMs(例如PaLM和T5)，这是Adam优化器的一个变体，专门用于在训练过程中节省GPU。</p><h5 id="稳定训练Stabilizing-the-Training"><a href="#稳定训练Stabilizing-the-Training" class="headerlink" title="稳定训练Stabilizing the Training"></a>稳定训练Stabilizing the Training</h5><p>在LLMs预训练过程中，往往存在训练不稳定性问题，可能导致模型崩溃。为了解决这个问题，会广泛使用权重衰减（weight decay）和梯度裁剪（gradient clipping）。通常将梯度裁剪的阈值设置为 1*.<em>0，将权重衰减率设置为 0</em>.*1。<br>然而，随着LLMs规模的扩大，也更容易出现训练损失尖峰，导致训练不稳定。为了缓解这个问题，PaLM和OPT使用了一种简单的策略，即从发生突增之前的一个检查点重新开始训练过程，并跳过可能导致问题的数据。此外，GLM发现嵌入层的异常梯度通常会导致突增，并提出缩小嵌入层梯度以缓解这个问题。</p><h4 id="可扩展的训练技术"><a href="#可扩展的训练技术" class="headerlink" title="可扩展的训练技术"></a>可扩展的训练技术</h4><p>扩展训练需要解决两个主要的技术问题是提高训练吞吐量以及将更大的模型加载到显存中。现有工作中有几种广泛使用的方法来解决上述两个挑战，即 3D 并行、ZeRO 和混合精度训练。</p><h5 id="3D并行"><a href="#3D并行" class="headerlink" title="3D并行"></a>3D并行</h5><p>3D并行实际上是三种常用的并行训练技术的组合，即数据并行、流水线并行和张量并行。</p><p>【数据并行】<br>是提高训练吞吐量的最基本方法之一。它复制模型参数和优化器状态到多个GPU上，然后将整个训练语料库分配到这些GPU。这样，每个GPU只需要处理为其分配的数据，并执行前向和后向传播以获得梯度。将进一步聚合不同GPU上计算的梯度以获得整个批次的梯度，以更新所有GPU中的模型。<br>通过这种方式，由于梯度的计算是在不同的 GPU 上独立执行的，数据并行机制是高度可扩展的，从而能够增加 GPU 的数量以提高训练吞吐量的方式。此外，这种技术在实现中很简单，大多数现有的流行的深度学习库已经实现了数据并行性，例如 TensorFlow 和 PyTorch。<br>【流水线并行】<br>流水线并行旨在将 LLM 的不同层分布在多个 GPU 中。特别是，在 Transformer 模型的情况下，流水线并行将连续的层加载到同一个 GPU 上，以降低在 GPU 之间传输计算的隐藏状态或梯度的成本。<br>为了减少流水线并行中的这些气泡（bubble overhead），GPipe和PipeDream提出了填充多批次数据和异步梯度更新以提高流水线效率的技术。<br>【张量并行】<br>张量并行也是一种常用的技术，旨在分解LLM进行多gpu加载。与流水线并行不同，张量并行侧重于分解 LLM 的张量（参数矩阵）。<br>对于LLM中的矩阵乘法操作Y = XA，参数矩阵A可以按列分解为A1和A2，那么该操作可以表示为Y=[XA1, XA2]。通过在不同的GPU上放置矩阵A1和A2，矩阵乘法操作将在两个GPU上并行调用，最终结果可以通过跨GPU通信组合两个GPU的输出来获得。<br>目前，张量并行已在几个开源库中得到支持，例如Megatron-LM，并且可以扩展到高维张量。此外，Colossal-AI也实现了高维张量的张量并行，并提出了序列并行，特别是对于序列数据，可以进一步分解Transformer模型的注意力操作。</p><h5 id="ZeRO"><a href="#ZeRO" class="headerlink" title="ZeRO"></a>ZeRO</h5><p>DeepSpeed库提出的ZeRO技术侧重于数据并行中的内存冗余问题。<br>如前所述，数据并行要求每个GPU存储LLM的相同副本，包括模型参数、模型梯度和优化器参数。然而，并非所有上述数据都需要在每个GPU上保留，这会导致内存冗余问题。<br>为了解决这个问题，ZeRO 技术旨在在每个GPU上只保留一小部分数据，而在需要时可以从其他GPU中检索其余数据。<br>具体来说，ZeRO 提供了三个解决方案，具体取决于数据的三部分如何存储，即优化器状态分区、梯度分区和参数分区。实证结果表明，前两个解决方案不会增加通信开销，第三个解决方案增加了大约 50% 的通信开销，但节省了与 GPU 数量成比例的内存。<br>PyTorch 实现了与 ZeRO 类似的技术，称为 FSDP。</p><h5 id="混合精度训练"><a href="#混合精度训练" class="headerlink" title="混合精度训练"></a>混合精度训练</h5><p>在以前的PLM(例如，BERT)中，32位浮点数，也称为FP32，主要用于预训练。近年来，为了预训练非常大的语言模型，一些研究已经开始利用16位浮点数(FP16)，这减少了内存使用和通信开销。<br>然而，现有工作发现 FP16 可能会导致计算精度损失，这会影响最终的模型性能。为了缓解这种情况，使用了一种称为Brain Floating Point (BF16) 的替代方案进行训练，它分配比 FP16 更多的指数位和更少的重要位。对于预训练，BF16 在表示精度上通常比 FP16 表现更好。</p><h5 id="总体训练建议"><a href="#总体训练建议" class="headerlink" title="总体训练建议"></a>总体训练建议</h5><p>在实践中，上述训练技术，尤其是 3D 并行，通常用于提高训练吞吐量和大型模型加载。例如，研究人员结合了 8 路数据并行、4 路张量并行和 12 路流水线并行，可以在 384张A100 GPU 上训练 BLOOM。<br>目前，DeepSpeed、Colossal-AI和Alpa等开源库可以很好地支持三种并行训练方法。为了减少内存冗余，ZeRO、FSDP 和激活重计算技术也可用于训练 LLMs，这些已经集成到 DeepSpeed、PyTorch 和 Megatron-LM 中。<br>此外，还可以利用BF16等混合精度训练技术来提高训练效率，减少GPU内存使用，尽管需要硬件(如A100 GPU)必要的支持。<br>预测模型性能和检测异常问题会非常有用，GPT-4 最近引入了一种新的机制，叫做predictable scaling，建立在深度学习堆栈上，能够使用更小的模型预测大型模型，这对于开发 LLM 可能非常有用。<br>除了上述训练策略外，提高使用LLMs的推理速度也很重要。通常，量化技术在推理阶段被广泛用于降低LLMs的时间和空间成本。<br>对于模型量化，一种流行的选择是INT8-量化。此外，一些研究工作试图开发更积极的INT4量化方法。在这些开源LLMs中，BLOOM、GPT-J和GLM发布了相应的量化模型副本。</p><h2 id="5-适配微调"><a href="#5-适配微调" class="headerlink" title="5.适配微调"></a>5.适配微调</h2><p>我们主要介绍两种适配预训练LLMs的方法，即指令微调（Instruction tuning）和对齐微调（Alignment tuning）。前一种方法主要旨在增强（或解锁）LLM 的能力，而后一种方法旨在将 LLM 的行为与人类值或偏好对齐。此外，我们还将讨论快速模型适应的Efficient tuning。</p><h3 id="5-1指令微调"><a href="#5-1指令微调" class="headerlink" title="5.1指令微调"></a>5.1指令微调</h3><p>本质上，<strong>指令调优是在自然语言形式的格式化实例集合上微调预训练的LLMs</strong>的方法，这与监督微调和多任务提示训练高度相关。</p><p>需要收集或构建指令格式（instruction-formatted）的实例。然后，我们使用这种格式的实例以有监督的方式微调LLM（例如使用seq2seq的损失进行训练）。指令微调后，LLM 可以展现出泛化到未见过任务的卓越能力。</p><h4 id="格式化实例"><a href="#格式化实例" class="headerlink" title="格式化实例"></a>格式化实例</h4><p>指令格式的实例由任务描述（称为instruction）、输入输出对(input-output pair)和少量演示(demonstration)（可选）组成。</p><p>通过收集来自不同领域（例如文本摘要、文本分类和翻译）的实例来创建有监督的多任务训练数据集。</p><p>具体来说，使用人类撰写的任务描述来增广带标注的数据集，这些描述通过解释任务目标来指导LLM 理解任务。例如，在图 5（b）中，每个问答任务的实例都添加了一个任务描述“请回答下列问题”。<strong>在指令微调之后，LLM 可以通过遵循任务描述很好地泛化到其他未见过的任务上 [28, 62, 64]。特别地，指令被证明是影响 LLM 任务泛化能力的关键因素</strong>。</p><p>关键因素：</p><p>增加指令：大量研究已经证明扩大任务数量可以极大地提高 LLM 的泛化能力。但任务数量达到一定水平时，模型性能的提升变得微不足道。将某些任务的实例数量进一步增加（例如数百个）可能会潜在地导致过拟合并影响模型性能</p><p>设计格式：指令的格式设计也是影响 LLM 泛化性能的一个重要因素。通常来说，我们可以向现有数据集的输入-输出对添加任务描述和可选的示例，其中任务描述是 LLM理解任务的最关键部分。<strong>将其他部分（例如避免事项、原因和建议）添加到指令中对 LLM 的性能提升十分轻微，甚至会产生不利的影响</strong></p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204162206898.png" alt="image-20231204162206898"></p><h5 id="格式化任务数据集"><a href="#格式化任务数据集" class="headerlink" title="格式化任务数据集"></a>格式化任务数据集</h5><p>格式化任务数据集。在提出指令调优之前，一些早期的研究[266,273,274]从不同的任务范围（如文本摘要、文本分类和翻译）中收集实例，以创建有监督的多任务训练数据集。作为指令调优实例的主要来源，使用自然语言任务描述将这些多任务训练数据集格式化非常方便。具体来说，最近的工作[28,61,62,79]用<strong>人工编写的任务描述来增强已标记的数据集，它通过解释任务目标来指示llm来理解任务</strong>。例如，在图9(a)中，为问答任务中的每个示例添加了一个任务描述“请回答这个问题”。在指令调优之后，llm可以通过遵循其任务描述[28,62,64]来很好地推广到其他不可见的任务。特别是，已经证明了指令是LLMs [62]任务泛化能力的关键因素：通过在标记的数据集上对模型进行微调，去掉任务描述，它会导致模型性能的急剧下降。为了更好地为inst生成带有标记的实例</p><h5 id="格式化人类需求"><a href="#格式化人类需求" class="headerlink" title="格式化人类需求"></a>格式化人类需求</h5><p>尽管大量的训练实例已经通过添加指令进行格式化，但它们<strong>主要来自公共的 NLP 数据集</strong>，任务描述缺乏多样性或与人类真实需求不匹配。为了解决这个问题， InstructGPT建议<strong>采用真实用户提交给 OpenAI API 的 查询作为任务描述</strong>。用户查询以自然语言表示，很适合引导出 LLM 遵循指令的能力。此外，为了丰富任务的多样性，<strong>标注者还要为真实生活中的任务编写指令，包括开放式生成、开放式问答、头脑风暴和聊天等。然后让另一组标注人员直接按照将这些指令作为输出进行回答</strong>。最后，<strong>将指令（即采集的用户查询）和期望的输出（即人工编写的答案）配对作为一 个训练实例。</strong></p><p>InstructGPT 还将这些以自然语言格式化的真实世界任务用于对齐微调（在第 5.2 节中讨论）。</p><p><strong>进一步地，GPT-4 [45] 还设计了潜在高风险的指令，并监督微调模型拒绝这些指令以确保安全。</strong></p><h5 id="格式化合成数据。"><a href="#格式化合成数据。" class="headerlink" title="格式化合成数据。"></a>格式化合成数据。</h5><p>为了减少人工注释或人工收集的负担，人们提出了几种半自动化的方法[129]来构建实例，通过将现有的实例输入到llm中，以合成不同的任务描述和实例。如图9(c)所示，自指导方法只需要大约100个实例作为初始任务池。然后，<strong>他们从池中随机选择几个实例作为演示，并提示一个LLM生成新的指令和相应的输入-输出对。在进行质量和多样性过滤之后，新生成的实例将被添加到任务池中。因此，该合成方法是生成llm的大规模指令数据的一种有效而经济的方法。</strong></p><p>总的来说：</p><p>指令多样性似乎比实例数量更重要，因为表现良好的 InstructGPT [61] 和 Alpaca [220] 使用的指令（或实例）比 Flan 系列的 LLM [62, 64] 数量更少但更加多样化。</p><p>此外，邀请标注者构建人类真实需求的任务比使用特定数据集的任务更有用。</p><h4 id="指令微调策略"><a href="#指令微调策略" class="headerlink" title="指令微调策略"></a>指令微调策略</h4><p>与预训练不同，因为只需要使用较<strong>少数量的实例</strong>进行训练，指令微调通常更加高效。<strong>指令微调可以被视为一个有监督的训练过程</strong>，其优化过程与预训练有一些不同，比如训练目标函数（如序列到序列的损失）和优化参数设置（如更小的批量大小和学习率）。</p><p><strong>平衡数据分布：</strong>由于指令微调涉及多种任务的混合，因此在微调过程中平衡不同任务的比例非常重要。一种广泛使用的方法是实例比例混合策略，即将所有数据集合并，然后从混合数据集中按比例采样每种实例。此外，根据最近的研究发现，提高高质量数据集（例如 FLAN和 P3）的采样比例通常可以带来性能提升。同时，在指令微调期间通常会设置一个最大容量，以限制数据集中可以包含的最大实例数，这是为了防止较大的数据集挤占整个采样集合。在实践中，根据不同的数据集，最大容量通常设置为几千或几万个实例。</p><p><strong>结合指令微调和预训练：</strong>为了使微调过程更加有效和稳定， OPT-IML在指令微调期间加入了预训练数据，这可以看作是对模型的正则化（regularization）。此外，一些研究并没有使用单独的两阶段训练过程（预训练和指令微调），而是尝试混合使用预训练数据（即纯文本）和指令微调数据（即指令格式数据），用多任务学习的方式从头训练模型。具 体而言，GLM-130B和 Galactica将指令格式数据集作为预训练语料库的一小部分来预训练 LLM，这有可能同时获得预训练和指令微调的优势。</p><h3 id="5-2对齐微调"><a href="#5-2对齐微调" class="headerlink" title="5.2对齐微调"></a>5.2对齐微调</h3><p>LLM 在多个自然语言处理任务上展示出了惊人的能力，但是, 这些模型有时可能表现出预期之外的行为，<strong>例如编造虚假信息、追求不准确的目标，以及产生有害的、误导性的和有偏见的表达</strong>。对于 LLM 而言, <strong>模型参数的预训练使用了语言建模的目标，即用单词预测进行预训练，但这没有考虑到人类的价值观或偏好。</strong>为了避免这些预期外的行为，一些研究提出了<strong>人类对齐</strong>，使得 LLM 的行为能够符合人类期望。但是, 与原先的预训练和适配微调（例如指令微调）相比, <strong>对齐微调需要考虑的标准（例如有用性, 诚实性和无害性）十分不同</strong>。已有研究表明<strong>对齐微调可能会在某种程度上损害 LLM 的通用能力</strong>，这在相关研究中被称为<strong>对齐税</strong>。</p><p>对齐的标准：我们选取三个具有代表性的对齐标准（即有用性、诚实性、无害性）</p><p>无害性：无害性要求模型生成的语言不得是冒犯性或歧视性的。</p><h4 id="人类反馈的收集"><a href="#人类反馈的收集" class="headerlink" title="人类反馈的收集"></a>人类反馈的收集</h4><p><strong>标注人员的选择：</strong>InstructGPT通过评估标注人员与研究人员之间意图的一致性来选择标注人员。具体而言，研 究人员首先标注少量的数据，然后衡量他们自己和标注人员之间的标注一致性。选择一致性最高的标记者继续后续的标注工作。</p><p><strong>人类反馈的收集：</strong>1）基于<strong>排序</strong>的方法：引 入了 Elo 评分系统 ，通过一一比较所有候选输出结果来生成 一个偏好排序。候选输出的排序将用于调整模型更倾向的输出，从而产生更可靠和更安全的结果。 2）基于问题的方法：通过回答研究人员设计的特定问题，标注人员可以提供更详细的反馈，这些问题能够覆盖不同的对齐标准以及其他对 LLM 的约束条件。特别地，在 WebGPT中，为了帮助模型从检索到的文档中过滤和利 用相关信息，标注人员需要回答关于检索到的文档对于回答给定输入是否有帮助的选择题。 3）基于规则的方法：Sparrow不仅选择了标注人员挑选的最佳回复，<strong>还设计了一系列规则来测试模型生成的回复是否符合有用、正确和 无害的对齐标准</strong>。</p><p>通过这种方式，可以获得两种人类反馈数据：（1）通过成对比较模型生成的输出的质量来获得回复偏好反馈，以及（2）通过收集来自人类标注者的评估（即，指示生成的输出在多大程度上违反了规则的分数）来获得规则违反反馈。</p><p>GPT-4 利用一组（基于 GPT-4 本身的）<strong>零样本分类器作为基于规则的奖励模型，可以自动地确定模型生成的输出是否违反了一组人类编写的规则。</strong></p><h4 id="基于人类反馈的强化学习"><a href="#基于人类反馈的强化学习" class="headerlink" title="基于人类反馈的强化学习"></a>基于人类反馈的强化学习</h4><p>为了使 LLM 与人类价值观保持一致，人们提出了基于人类反馈的强化学习（ <em>Reinforcement Learning from Human Feedback</em>， RLHF），使用收集到的人类反馈数据对 LLM 进行微调，有助于改进对齐的指标。RLHF 采用强化学习（RL）算法（例如，近端策略优化（Proximal Policy Optimization, PPO））通过学习奖励模型使 LLM 适配人类反馈。</p><p><strong>基于人类反馈的强化学习系统：</strong> RLHF 系统主要包括三个关键组件：要对齐的 <strong>PLM</strong>、从人类反馈中学习的<strong>奖励模型</strong>，以 及训练 LM 的 <strong>RL 算法</strong>。具体来说，PLM 通常是一个生成模 型，它使用现有的 PLM 参数进行初始化。例如，OpenAI 在其 第一个主流的 RLHF 模型 InstructGPT [61] 中使用 1750 亿 参数量的 GPT-3。此外，<strong>奖励模型（RM）</strong> 提供（学习得到的）指导信号，这些信号反映了人类对 LM 生成的文本的偏好，通常以标量值的形式表示。奖励模型通 常具有两种形式：经过微调的 LM 或使用人类偏好数据重新 训练的 LM。</p><p><strong>基于人类反馈的强化学习的关键步骤</strong>：下图说明了 RLHF 的 整个三步过程，具体如下所述。</p><p><strong>1） 监督微调：</strong>为了使 LM 具有初步执行所需行为的能力， 通常需要收集一个包含输入提示（指令）和所需输出的有监督数据集，以对 LM 进行微调。<strong>这些提示和输出可以在确保任务多样性的情况下由人工标注人员针对某些特定任务编写</strong>。例 如，InstructGPT 要求人工标注者编写提示（例如，“列出五个关于我如何重拾对职业热情的想法”）和一些生成式任 务（如开放域问答、头脑风暴、聊天和重写）的期望输出。</p><p>请注意，在特定设置或场景中，第一步是可选的。</p><p><strong>2）训练奖励模型：</strong>第二步是使用人类反馈的数据<strong>训练RM。</strong> 具体来说，我们向 LM 中输入采样的提示（来自监督数据集 或人类生成的提示），以生成一定数量的输出文本，然后邀请 人工标注员为这些输入-输出对标注偏好。标注过程可以以多种形式进行，常见的做法是对生成的候选文本进行排序标注， 这样可以减少因标注者不同带来的差异。最后，训练 RM 预测人类偏好的输出。<strong>在 InstructGPT 中，标注员将模型生成 的输出从最好到最差进行排名，然后训练 RM（即 60 亿参数 量的 GPT-3）来预测排名。</strong></p><p><strong>3）强化学习微调：</strong>在这一步骤中，LM 的对齐微调可以被 形式化为 RL 问题。在这种情况中，RL 问题的策略（policy） 由 PLM 给出（将提示作为输入并返回输出文本），行动空间 （action space）是 LM 的词表，状态（state）是目前生成的 token 序列，奖励（reward）则由 RM 提供。为了避免 LM 显著偏离初始（微调前）的模型，通常在奖励函数中纳入一项 惩罚项。例如，InstructGPT 在使用 PPO 算法对抗 RM 来 优化 LM 时，<strong>对于每个输入提示，InstructGPT 计算当前 LM 和初始 LM 生成的结果之间的 KL 散度作为惩罚项</strong>。值得注 意的是，可以通过多次迭代第二步和最后一步来更好地对齐LLM。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204145938232.png" alt="image-20231204145938232" style="zoom:67%;"><h3 id="5-3参数高效微调方法"><a href="#5-3参数高效微调方法" class="headerlink" title="5.3参数高效微调方法"></a>5.3参数高效微调方法</h3><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204150735410.png" alt="image-20231204150735410"></p><p>参数高效微调（parameter-efficient fine-tuning）是一个重要的课题，旨在减少可训练参数的数量，同时尽可能保持良好的性能</p><h4 id="Adapter-Tuning"><a href="#Adapter-Tuning" class="headerlink" title="Adapter Tuning"></a>Adapter Tuning</h4><p>Adapter tuning将小型神经网络模块（称为适配器）融入Transformer模型。为了实现适配器模块，提出了一种bottleneck架构，该架构首先将原始特征向量压缩到较小的维度（然后进行非线性变换），然后将其恢复到原始维度。<br>Adapter模块将集成到每个Transformer层中，通常在Transformer层的两个核心部分（即注意力层和前馈层）中的每一个之后使用串行插入。作为替代方案，并行Adapter也可以用在Transformer层中，其中它相应地将两个Adapter模块与注意力层和前馈层并行放置。<br>在微调过程中，Adapter模块将根据特定的任务目标进行优化，而原始语言模型的参数在此过程中被冻结。</p><h4 id="Prefix-Tuning"><a href="#Prefix-Tuning" class="headerlink" title="Prefix Tuning"></a>Prefix Tuning</h4><p>前缀调优为语言模型中的每个Transformer层预先排列一系列前缀，这些前缀是一组可训练的连续向量。这些前缀向量是特定于任务的，可以被视为虚拟token embedding。<br>为了优化前缀向量，已经提出了一种重参数化技巧，通过学习一个MLP函数将一个较小的矩阵映射到前缀的参数矩阵，而不是直接优化前缀。已经证明，这个技巧对稳定训练是有用的。优化后，映射函数将被丢弃，只保留导出的前缀向量，以提高特定任务的性能。<br>由于只训练前缀参数，因此可以实现参数高效的模型优化。与前缀调优类似，p-tuning v2将layer-wise的prompt向量融合到Transformer架构中，专门用于自然语言理解，该架构还利用多任务学习来联合优化共享prompt。</p><h4 id="Prompt-Tuning"><a href="#Prompt-Tuning" class="headerlink" title="Prompt Tuning"></a>Prompt Tuning</h4><p>与prefix tuning不同，prompt tuning主要侧重于在输入层融入可训练的提示向量。<br>根据离散提示方法，它通过包含一组soft prompt tokens（以自由形式或前缀形式）来增强输入文本，然后采用提示增强输入来解决特定的下游任务。P-tuning提出了一种结合context、prompt和target tokens的自由形式，可以应用于自然语言理解和生成的架构。他们通过双向LSTM进一步学习soft prompt tokens的表示。另一种代表性的方法名为prompt tuning，直接在输入前加前缀提示。在训练过程中，根据特定任务的监督，只学习prompt embedding。<br>然而，由于该方法在输入层仅包括少量可训练参数，已经发现其性能在很大程度上取决于底层语言模型的模型能力。<br>这里的Prompt Tuning专门指的只在输入层包含prompt tokens的方法。</p><p><strong>Low-Rank Adaptation（LoRA）</strong><br>LoRA对每个密集层的更新矩阵施加了低秩约束，以减少适配下游任务的可训练参数。<br>考虑优化参数矩阵W的情况。更新过程可以用一般形式写成：W← W+∆W。LoRA的基本思想是冻结原始矩阵W∈Rm×n，同时通过低秩分解矩阵逼近参数更新∆W，即∆W=A·B^T，其中A∈Rm×k和B∈Rn×k是任务适配的可训练参数，r &lt;&lt; min(m，n)是降低的秩。<br>LoRA的主要优点是它可以在很大程度上节省内存和存储使用（例如，VRAM）。此外，只能保留单个大模型副本，同时保留许多特定于任务的低秩分解矩阵，以适应不同的下游任务。<br>此外，一些研究还讨论了如何以更原则化的方法设置秩，例如，基于重要性分数的分配和无搜索的最优秩选择。</p><h2 id="6-模型使用"><a href="#6-模型使用" class="headerlink" title="6.模型使用"></a>6.模型使用</h2><p>经过预训练或适配微调之后，使用 LLM 的主要方法是为解决各种任务设计适当的提示策略。一种典型的提示方法是将任务描述和（或）示范（demonstration）以自然语言文本的形式表达的上下文学习（<em>in-context learning, ICL</em>）。此外，采用思维链提示（<em>chain-of-thought prompting</em>）可以通过将一系列中间推理步骤加入提示中来增强 ICL。</p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204151041209.png" alt="image-20231204151041209"></p><h3 id="上下文学习"><a href="#上下文学习" class="headerlink" title="上下文学习"></a>上下文学习</h3><p>此外，ICL 还与指令微调（在5.1中已讨论）有着密切的联系，因为它们都将任务或样例转化为自然语言的形式。然而，指令微调需要微调 LLM来增强适配，而 ICL 仅仅是以提示的方式来使用LLM。指令微调可以提高 LLM 执行目标任务的 ICL 能力，尤其是在零样本设置时（仅使用任务描述）。</p><p>ICL使用格式化的自然语言提示，包括任务描述和/或一些任务示例作为演示。基于任务演示，LLM可以在没有显式梯度更新的情况下识别并执行新任务。<br>（当ICL在GPT-3的论文中被引入时，它最初被定义为任务描述和演示示例的组合，其中任何一个组件都是可有可无的。根据这个定义，当LLM需要只使用任务描述来解决没见过的任务时，它也可以被认为是执行ICL来解决任务，而ICL能力可以通过指令调优来增强。）<br>由于ICL的性能在很大程度上依赖于示范(demonstrations)，因此在提示中正确设计演示是一个重要问题。从三个方面介绍 ICL 的示范设计，即<strong>示范选择、格式和顺序。</strong></p><p><strong>示范选择：</strong> 主要方法有两种，被称作启发式方法和基于 LLM 的方法。</p><p>【启发式方法】<br>一些研究使用基于k-NN的检索器来选择与query语义相关的示例。<br>然而，他们为每个示例单独执行选择，而不是将示例集合作为一个整体进行评估。为了解决这个问题，提出了基于多样性的选择策略，为特定任务选择最具代表性的示例集合。</p><p>【基于LLM的方法】<br>另一路工作是通过使用LLM来选择演示。例如，<strong>LLM可以用于根据添加示例后的性能增益直接测量每个示例的信息性</strong>。此外，EPR提出了一种两阶段检索方法，该方法<strong>首先用无监督方法（例如，BM25）检索类似的样本，然后使用密集检索器（用LLM标注的阳性和阴性样本训练）对它们进行排序。</strong><br>作为一种替代方法，可以将演示选择任务形式化为RL问题，其中LLM作为奖励函数，为训练策略模型提供反馈。由于LLM在文本注释方面表现良好，最近的一些研究在没有人为干预的情况下将LLM本身用作演示生成器。</p><p><strong>格式</strong><br>选择任务样本后，下一步是将它们集成并格式化为LLM的自然语言提示。一个简单的方法是用相应的输入输出对实例化预定义的模板。<br>为了构建更具信息性的模板，最近的研究考虑添加任务描述或通过思维链提示增强LLM的推理能力。<br>为了降低注释成本，提出了一种半自动化方法，即<strong>使用由人工编写的任务描述组成的种子集来指导LLM为新任务生成任务描述。</strong><br>作为两种具有代表性的方法，<strong>Auto-CoT利用带有零样本提示“Let’s think step by step”的LLM来生成中间推理步骤，而least-to-most prompting首先询问LLM以执行问题分解，然后利用LLM根据之前解决的中间答案顺序解决子问题。</strong></p><p><strong>顺序</strong><br><strong>LLM有时会受到近因偏差的影响，即他们倾向于重复接近演示结束的答案</strong>。因此，以合理的顺序安排演示（即任务示例）是很重要的。<br>早期的工作提出了几种启发式方法来快速找到一个好的顺序。例如，<strong>可以直接根据它们与嵌入空间中查询的相似性来组织演示：越相似，越接近结尾。</strong><br>此外，全局和局部熵度量可用于对不同的演示顺序进行评分。<br>为了整合更多的任务信息，最近的一些研究提出<strong>将压缩和传输任务标签所需的代码长度最小化，这受到了信息论的启发</strong>。<br>然而，这些方法需要额外的标注数据作为验证集，以评估特定演示顺序的性能。为消除这种需要，<strong>可以从LLM本身采样验证数据。</strong></p><h4 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h4><p> ICL 的能力随着模型规模的增大而增强。然而，一些研究表明，<strong>小规模的 PLM 也可以通过特别设计的训练任务表现出强大的 ICL 能力。</strong>训练任务的设计是影响 LLM 的 ICL 能力的一个重要因素。</p><p>除了训练任务之外，近期的一些研究还探索了 ICL 与预训练语料之间的关系 [260, 265, 266]；研究表明，ICL 的性能主要<strong>取决于预训练语料的来源而非规模</strong> [266]。另一项研究 [265]深入分析了训练数据分布的影响；他们发现，<strong>当训练数据可以被聚类成许多不常见的类别，而不是均匀分布时，模型会表现出 ICL 的能力。</strong></p><p><strong>LLMs怎样执行ICL</strong><br>在推理阶段，研究人员专注于基于给定的演示来分析ICL能力是如何运行的，因为不涉及显式学习或更新。他们通常从梯度下降的角度进行分析，并将ICL视为隐式微调。<br>在这个框架下，ICL过程可以解释如下：<strong>通过前向计算，LLM生成关于演示的元梯度，并通过注意力机制隐式地执行梯度下降。实验也表明，LLM中的某些注意力头能够执行与任务无关的原子操作（例如，复制和前缀匹配），这与ICL能力密切相关。</strong><br>为了进一步探索ICL的工作机制，一些研究将ICL抽象为一个算法学习过程。具体而言，LLM在预训练期间基本上通过其参数对隐式模型进行编码。通过ICL中提供的例子，LLM可以实现诸如梯度下降之类的学习算法，或者直接计算闭式解，以在前向计算期间更新这些模型。在这个解释框架下，已经表明LLM<strong>可以有效地学习简单的线性函数，甚至可以使用ICL学习一些复杂的函数，如决策树</strong>。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231206143337223.png" alt="image-20231206143337223" style="zoom:80%;"><h3 id="思维链提示"><a href="#思维链提示" class="headerlink" title="思维链提示"></a>思维链提示</h3><p>思维链（Chain-of-Thought，CoT）是一种改进的提示策略，用于提高LLM在复杂推理任务中的性能，如算术推理、常识推理和符号推理。CoT没有像ICL那样简单地用输入输出对构建提示，而是结合了中间推理步骤，这些步骤可以将最终输出引入提示。</p><p><strong>小样本思维链 Few-shot CoT</strong><br>Few-shot CoT是ICL的一种特殊情况，它通过融合CoT推理步骤，将每个演示〈input，output〉扩充为〈input，CoT，output〉。<br>【CoT prompt的设计】<br>作为一种直接的方法，<strong>研究表明，使用不同的CoT（即每个问题的多个推理路径）可以有效地提高它们的性能。</strong><br><strong>另一个直观的想法是，具有更复杂推理路径的提示更有可能引发LLM的推理能力，这可以导致生成正确答案的准确性更高。然而，这两种方法都依赖于带标注的CoT数据集。</strong><br>为了克服这一限制，Auto-CoT建议利用Zero-shot-CoT，通过专门提示LLM来生成CoT推理路径，从而消除了手动操作。为了提高性能，Auto-CoT进一步将训练集中的问题划分为不同的聚类，然后选择最接近每个聚类中心的问题，这应该很好地代表训练集中的提问。<br>尽管Few-shot CoT可以被视为ICL的一种特殊提示情况，但与ICL中的标准提示相比，演示的顺序似乎影响相对较小：在大多数任务中，重新排序演示只会导致小于2%的性能变化。<br>【增强的CoT策略】<br>除了丰富上下文信息外，CoT提示还提供了更多选项来推断给定问题的答案。现有的研究主要集中在生成多条推理路径，并试图在得出的答案中找到共识。例如，在生成CoT和最终答案时，提出了self-consistency作为一种新的解码策略。<strong>它首先生成几个推理路径，然后对所有答案进行综合</strong>（例如，通过在这些路径中投票来选择最一致的答案）。self-consistency在很大程度上提高了CoT推理的性能，甚至可以改进一些CoT提示通常比标准提示差的任务（例如，闭书问答和自然语言推理）。<br>此外，作者在[283]中将自一致性策略扩展到更通用的集成框架（扩展到提示上的集成），他们发现<strong>不同的推理路径是提高CoT推理性能的关键。</strong><br>相反，其他研究训练评分模型来测量生成的推理路径的可靠性，或者在自己生成的推理路径上继续训练LLM以提高性能。</p><p><strong>零样本思维链 Zero-shot CoT</strong><br>与Few-shot CoT不同，Zero-shot CoT在prompt中不包括人工标注的任务演示。相反，它直接生成推理步骤，然后使用生成的CoT来导出答案。<br>Zero-shot CoT最早在中[281]提出，其中LLM首先由“Let’s think step by step”提示生成推理步骤，然后由“Therefore, the answer is”提示得出最终答案。他们发现，当模型规模超过一定规模时，这种策略会大大提高性能，但对小规模模型无效，显示出显著的<strong>涌现能力模式</strong>。<br>为了在更多的任务上解锁CoT能力，Flan-T5和Flan-PaLM进一步在CoT标注上执行指令调优，并且改进了在不可见任务上的零样本性能。</p><p>（1）什么时候CoT对LLMs有用<br>由于CoT是一种涌现能力，它只对足够大的模型（例如，通常包含10B或更多的参数）有积极影响，但对小模型没有影响。<br>此外，由于CoT通过中间推理步骤增强了标准提示，因此它主要有效地改进了需要逐步推理的任务，如算术推理、常识推理和符号推理。然而，对于不依赖于复杂推理的其他任务，它可能显示出比标准提示更差的性能，例如GLUE的MNLI-m/mm、SST-2和QQP。<br>（2）为什么LLMs可以执行CoT推理<br>【CoT能力的来源】<br>关于CoT能力的来源，<strong>人们普遍假设它可以归因于对代码的训练，因为在代码上训练的模型显示出强大的推理能力</strong>。从直觉上讲，代码数据通过算法逻辑和编程流程进行了良好的组织，这可能有助于提高LLM的推理性能。然而，<strong>这一假设仍然缺乏消融实验的公开报道证据</strong>（有和没有代码训练）。<br>此外，<strong>指令调优似乎不是获得CoT能力的关键原因</strong>，因为经验表明，对非CoT数据的指令调优并不能提高保持的CoT基准的性能。<br>【prompting组件的作用】<br><strong>CoT提示和标准提示之间的主要区别是在最终答案之前加入了推理路径。</strong><br>因此，一些研究人员调查了推理路径中不同成分的影响。具体而言，最近的一项研究确定了CoT提示中的三个关键组成部分，即<strong>symbols（例如，算术推理中的数字量）、patterns（例如，数学推理中的方程）和text（即，不是符号或模式的其余tokens）</strong>。结果表明，<strong>后两个部分（即patterns和text）对模型性能至关重要，删除其中任何一个都会导致性能显著下降</strong>。然而，<strong>symbols和patterns的正确性似乎并不重要。</strong>此外，<strong>text和patterns之间存在共生关系：text帮助LLM生成有用的patterns，patterns帮助LLM理解任务并生成有助于解决问题的text。</strong>总之，CoT提示为诱导LLM的推理能力提供了一种通用而灵活的方法。也有一些初步尝试将该技术扩展到解决多模态任务和多语言任务。除了将LLM与ICL和CoT直接结合使用外，最近的一些研究还探讨了如何将LLM的能力专门化到特定任务，这被称为模型专门化。例如，[294]中的研究人员通过微调LLM生成的CoT推理路径上的小规模Flan-T5[64]，专门研究LLM的数学推理能力。模型专业化也可用于解决各种任务，如问答、代码合成和信息检索。</p><p>本文最后在一下几个方面，介绍了大语言模型(LLM)的挑战和未来方向：</p><ol><li>理论和原理：<ul><li>挑战：<ul><li>大语言模型(LLM)的运行机制目前还不是非常的明朗，例如：大模型的涌现能力出现的原因。</li><li>大语言模型(LLM)如何通过非常大且深的神经网络分配、组织和利用信息。</li><li>理解、描述和解释大语言模型(LLM)的能力或行为的正式理论和原理仍然缺失。</li></ul></li><li>未来方向：<ul><li>对于大语言模型(LLM)的涌现能力的解释和研究。</li><li>对于大语言模型(LLM)对于信息的利用、分配、组织方式进行研究。</li><li>建立和完善理解、描述和解释大语言模型(LLM)的能力或行为的理论和原理。</li></ul></li></ul></li><li>模型架构：<ul><li>挑战：<ul><li>减少标准自注意力机制所带来的时间复杂度是一个实际应用时重要的考虑因素。</li><li><code>灾难性遗忘</code>一直是神经网络的长期挑战，其对大语言模型(LLM)也有负面影响。</li></ul></li><li>未来方向：<ul><li>研究如何构建大语言模型(LLM)中更高效的<code>Transformer</code>变体十分重要，例如 GPT-3 中已经使用了<code>稀疏注意力</code>。</li><li>考虑将现有架构扩展到更具灵活性的机制或模块，以有效支持数据更新和任务专用化。</li></ul></li></ul></li><li>模型训练：<ul><li>挑战：<ul><li>预训练强大的大语言模型(LLM)需要消耗巨大的算力，并且对<code>数据质量</code>和<code>训练技巧</code>要求很高。</li></ul></li><li>未来方向：<ul><li>开发更系统、经济的预训练方法以优化大语言模型(LLM)变得尤为重要，同时考虑到模型有效性、效率优化和训练稳定性等因素。</li></ul></li></ul></li><li>模型应用：<ul><li>挑战：<ul><li>由于在实际应用中微调的成本非常高，提示已成 为使用大语言模型(LLM)的主要方法，但是提示设计时需要大量人力。</li><li>一些复杂任务（例如形式证明和数值计算）需要特定的知识或逻辑规则，这些规则可能无法用自然语言很好地表达或通过示例演示。</li></ul></li><li>未来方向：<ul><li>研究如何自动生成有用且高校的提示以解决各种任务。</li><li>开发更具信息量和灵活性的任务格式化方法以进行提示非常重要。</li></ul></li></ul></li><li>安全与对齐：<ul><li>挑战：<ul><li>大语言模型(LLM)倾向于产生幻觉， 这些文本看似合理，但可能在事实上是错误的。例如：ChatGPT 刚发布的时候存在”一本正经的胡说八道”的情况。</li><li>现有的方法避免大语言模型(LLM)产生幻觉或者生成一些有毒，有害，有偏见的文本主要是讲人工纳入训练循环 来开发良好对齐的大语言模型(LLM)，并使用人类反馈强化学习(RLHF)。但是这严重依赖专业标注者的高质量人类反馈数据，这使得它在实践中难以适当实施。</li></ul></li><li>未来方向：<ul><li>研究如何避免大语言模型(LLM)产生幻觉或者生成一些有毒，有害，有偏见的文本。</li><li>有必要改进人类反馈强化学习(RLHF)框架以减少人类标注者的工作量，并寻求更高效的、具有保证数据质量的标注方法，例如LLM可以用于辅助标注工作。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> Survey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/23/hello-world/"/>
      <url>/2024/04/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>尽量减少恶意软件的传播</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> init <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">M</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// M - 移除某节点res的收益</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMalwareSpread</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>initial<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minNode <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>graph<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>            init<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            minNode <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minNode<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// System.out.println("i:"+String.valueOf(i)+",size:"+String.valueOf(size));</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">M</span> <span class="token operator">=</span> size<span class="token punctuation">;</span>                res <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>visited<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> minNode <span class="token operator">:</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 计算删除某节点n的收益=从该点扩散到的非initial中点的长度</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> graph<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>init<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ul><li>不支持本地图片</li><li>网络图片测试如下</li></ul><p><img src="https://hexo.io/themes/screenshots/Matery@2x.jpg" alt="Matery"></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
