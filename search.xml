<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL</title>
      <link href="/2024/04/26/mysql/"/>
      <url>/2024/04/26/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><img src="/2024/04/26/mysql/image-20240426154008919.png" alt="image-20240426154008919" style="zoom: 80%;"><blockquote><p><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</p><p><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</p><p><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</p><p><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</p></blockquote><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><ul><li><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p></li><li><p>NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p></li><li><p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p></li></ul><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/sql-nosql-tushi.png" alt="img"><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p><p><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</p><p><strong>可扩展性：</strong> NoSQL 数据库通常被设计为<strong>通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</strong></p><p><strong>高性能：</strong> NoSQL 数据库<strong>针对特定的数据模型和访问模式进行了优化</strong>，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</p><p><strong>强大的功能：</strong> NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</p><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ul><li>关系型数据库（RDB，Relational Database）就是一种<strong>建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</strong>关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</li><li>关系型数据库中，我们的数据都被存放在了各种二维表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</li><li>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</li></ul><p>目前主流的<strong>关系型数据库管理系统</strong>的市场占有率排名如下：</p><img src="/2024/04/26/mysql/image-20240426154125989.png" alt="image-20240426154125989"><ul><li>Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。</li><li>MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。</li><li>SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。</li><li>PostgreSQL：开源免费的中小型数据库。</li><li>DB2：IBM公司的大型收费数据库产品。</li><li>SQLLite：嵌入式的微型数据库。Android内置的数据库以及微信本地的聊天记录存储采用的就是该数据库。</li><li>MariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、另外一个衍生产品，与MySQL数据库有很好的兼容性。</li></ul><h3 id="关系型-vs-非关系型"><a href="#关系型-vs-非关系型" class="headerlink" title="关系型 vs 非关系型"></a>关系型 vs 非关系型</h3><img src="/2024/04/26/mysql/image-20240426163636208.png" alt="image-20240426163636208"><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一<strong>标准</strong> 。</p><p>1). SQL语句可以单行或多行书写，以分号结尾。</p><p>2). SQL语句可以使用空格/缩进来增强语句的可读性。</p><p>3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</p><p>4). 注释：单行注释：– 注释内容 或 # 注释内容多行注释：/* 注释内容 */</p><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL</p><img src="/2024/04/26/mysql/image-20240426170912537.png" alt="image-20240426170912537" style="zoom: 80%;"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员MySQL：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?vd_source=8f6745987f6d9c4a333570852e433d6c">https://www.bilibili.com/video/BV1Kr4y1i7ru/?vd_source=8f6745987f6d9c4a333570852e433d6c</a></p><p>JavaGuide：<a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2024/04/26/jdbc/"/>
      <url>/2024/04/26/jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>JDBC（Java Database Connectivity）是Java语言中用于与数据库通信的一种API，它允许Java应用程序通过标准的数据库访问方法与各种关系型数据库进行交互，例如MySQL、Oracle、SQL Server等。</li><li>JDBC为访问不同的数据库提供了统一的接口，使开发人员能够编写Java程序以执行SQL查询、更新数据库记录。为使用者屏蔽了细节问题。</li></ul><p>本质：</p><ul><li>官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包。<strong>（数据库驱动提供JDBC的实现类）</strong></li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</li></ul><p>优点：</p><ul><li><strong>跨数据库兼容性</strong>：各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发。可随时替换底层数据库，访问数据库的Java代码基本不变。</li><li><strong>安全性</strong>：JDBC提供了一种安全的数据库访问机制，可以防止SQL注入等安全问题。通过使用预编译语句和参数化查询等技术，可以有效地防止恶意用户对数据库进行攻击。</li></ul><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//1. 注册驱动</span>        <span class="token comment">// Class.forName("com.mysql.jdbc.Driver");</span>        <span class="token comment">//2. 获取连接</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://127.0.0.1:3306/db1"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">"1234"</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3. 定义sql</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"update account set money = 2000 where id = 1"</span><span class="token punctuation">;</span>        <span class="token comment">//4. 获取执行sql的对象 Statement</span>        <span class="token class-name">Statement</span> stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5. 执行sql</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//受影响的行数</span>        <span class="token comment">//6. 处理结果</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//7. 释放资源</span>        stmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><p>DriverManager（驱动管理类）作用：</p><ul><li>注册驱动</li></ul><p><img src="/2024/04/26/jdbc/JDBC%5CregisterDriver.png" alt="registerDriver"></p><p>我们使用的注册驱动代码为</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为MySQL提供的Driver类源码调用了DriverManager.registerDriver。</p><img src="/2024/04/26/jdbc/driver.png" alt="driver" style="zoom:67%;"><p>在该类中的静态代码块中已经执行了 <code>DriverManager</code> 对象的 <code>registerDriver()</code> 方法进行驱动的注册了，那么我们只需要加载 <code>Driver</code> 类，该静态代码块就会执行。而<code>Class.forName("com.mysql.jdbc.Driver");</code> 就可以加载 <code>Driver</code> 类。</p><blockquote><p>==提示：==</p><ul><li>MySQL 5之后的驱动包，可以省略注册驱动的步骤</li><li>自动加载jar包中META-INF/services/java.sql.Driver文件中的驱动类</li></ul></blockquote><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>Connection（数据库连接对象）作用：获取执行 SQL 的对象；管理事务</p><h4 id="获取执行对象"><a href="#获取执行对象" class="headerlink" title="获取执行对象"></a>获取执行对象</h4><p>普通执行SQL对象–statement</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//3. 定义sql</span>String <span class="token keyword">sql</span> <span class="token operator">=</span> <span class="token string">"update account set money = 3000 where id = 1"</span><span class="token punctuation">;</span><span class="token comment">//4. 获取执行sql的对象 Statement</span>Statement stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span>createStatement<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 执行sql</span><span class="token keyword">int</span> count <span class="token operator">=</span> stmt<span class="token punctuation">.</span>executeUpdate<span class="token punctuation">(</span><span class="token keyword">sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>预编译SQL的执行SQL对象：防止SQL注入</p><ul><li><p>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p></li><li><p>例如普通statement如果使用字符串拼接构造SQL  <code>String sql = "select * from stu where name='" + name + "'";</code>  在name中传入<code>"lucy" or name="郭麒麟"</code>，此时就会改变原有的SQL，查询到两条语句。也就是SQL注入漏洞</p></li><li><p>可以使用<code>PreparedStatement</code>来实现数据库操作，它的特点是：使用占位符<code>?</code>表示SQL语句中的参数，通过<code>set</code>方法为SQL语句传入参数</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">public</span> static void queryPrepare<span class="token punctuation">(</span>String name<span class="token punctuation">)</span> throws SQLException {    <span class="token comment">// 预编译SQL，SQL语句中的参数值，使用？占位符替代</span>    ptmt <span class="token operator">=</span> conn<span class="token punctuation">.</span>prepareStatement<span class="token punctuation">(</span><span class="token string">"select * from stu where name=?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ptmt<span class="token punctuation">.</span>setString<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 打印预编译后的SQL语句</span>    System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span>println<span class="token punctuation">(</span>ptmt<span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用这个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。</span>    rs <span class="token operator">=</span> ptmt<span class="token punctuation">.</span>executeQuery<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token keyword">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> {        StringBuilder sb <span class="token operator">=</span> new StringBuilder<span class="token punctuation">(</span><span class="token string">"[id="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rs<span class="token punctuation">.</span>getLong<span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", name="</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span>getString<span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", age="</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span>getInt<span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", class_id="</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span>getLong<span class="token punctuation">(</span><span class="token string">"class_id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span>println<span class="token punctuation">(</span>sb<span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>==小结：==</p><ul><li>在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li><li>执行时就不用再进行这些步骤了，速度更快</li><li>如果sql模板一样，则只需要进行一次检查、编译</li></ul></blockquote><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><p>MySQL事务管理的操作：</p><ul><li>开启事务 ： BEGIN; 或者 START TRANSACTION;</li><li>提交事务 ： COMMIT;</li><li>回滚事务 ： ROLLBACK;</li></ul><p>Connection接口中定义了3个对应的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// ============开启事务==========</span>    conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//5. 执行sql</span>    <span class="token keyword">int</span> count1 <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//受影响的行数</span>    <span class="token comment">//6. 处理结果</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//5. 执行sql</span>    <span class="token keyword">int</span> count2 <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//受影响的行数</span>    <span class="token comment">//6. 处理结果</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ============提交事务==========</span>    <span class="token comment">//程序运行到此处，说明没有出现任何问题，则需求提交事务</span>    conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// ============回滚事务==========</span>    <span class="token comment">//程序在出现异常时会执行到这个地方，此时就需要回滚事务</span>    conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p></li><li><p>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</p></li><li><p>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li><p>好处</p><ul><li>资源重用：在需要时分配和回收资源</li><li>降低连接的建立和关闭开销，提升系统响应速度</li><li>限制并发连接数，便于管理和维护，避免数据库连接遗漏</li></ul></li></ul><p><strong>其他八股见Java基础数据库连接池部分</strong></p><p>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。</p><p>而数据库使用了数据库连接池后，就能达到Connection对象的复用，如下图</p><img src="/2024/04/26/jdbc/数据库连接池.png" alt="数据库连接池" style="zoom:80%;"><p>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。</p><h3 id="Driud连接池"><a href="#Driud连接池" class="headerlink" title="Driud连接池"></a>Driud连接池</h3><p>Druid（德鲁伊）连接池是阿里巴巴开源的数据库连接池项目。使用步骤：</p><blockquote><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件</li><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ul></blockquote><p>现在通过代码实现，首先需要先将druid的jar包放到项目下的lib下并添加为库文件</p><img src="/2024/04/26/jdbc/Driud导入.png" alt="image-20210725212911980" style="zoom:80%;"><p>项目结构如下：</p><img src="/2024/04/26/jdbc/Driud结构.png" alt="image-20210725213210091" style="zoom:80%;"><p>编写配置文件如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">driverClassName</span><span class="token punctuation">=</span><span class="token value attr-value">com.mysql.jdbc.Driver</span><span class="token key attr-name">url</span><span class="token punctuation">=</span><span class="token value attr-value">jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true</span><span class="token key attr-name">username</span><span class="token punctuation">=</span><span class="token value attr-value">root</span><span class="token key attr-name">password</span><span class="token punctuation">=</span><span class="token value attr-value">1234</span><span class="token comment"># 初始化连接数量</span><span class="token key attr-name">initialSize</span><span class="token punctuation">=</span><span class="token value attr-value">5</span><span class="token comment"># 最大连接数</span><span class="token key attr-name">maxActive</span><span class="token punctuation">=</span><span class="token value attr-value">10</span><span class="token comment"># 最大等待时间</span><span class="token key attr-name">maxWait</span><span class="token punctuation">=</span><span class="token value attr-value">3000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用druid的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DruidDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//3. 加载配置文件</span>        <span class="token class-name">Properties</span> prop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        prop<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"jdbc-demo/src/druid.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4. 获取连接池对象</span>        <span class="token class-name">DataSource</span> dataSource <span class="token operator">=</span> <span class="token class-name">DruidDataSourceFactory</span><span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5. 获取数据库连接 Connection</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取到了连接后就可以继续做其他操作了</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>Java持久层框架是在Java语言中用于与数据库交互的重要工具。它们提供了一种简便的方式来管理数据的持久性。在Java开发过程中，持久层框架可以大大简化数据访问的过程，并且提供了一些额外的功能，如事务管理和缓存机制。</p><ul><li>Hibernate是一个持久层的ORM的框架。允许开发者将Java类和数据库表之间进行映射，使得开发者可以直接操作Java对象，而不用关心底层数据库的细节</li><li>javaBean - config.xml –数据库(三者映射)</li><li>Hibernate 能够自动生成 SQL 语句并自动执行，实现对数据库进行操作，整个过程完全不需要人工干预，大大降低了开发成本。</li></ul><p><strong>Hibernate的优点：</strong></p><ol><li>简化JDBC的编程.</li><li>修改了实体类，不需要修改源代码.</li><li>轻量级的框架.</li><li>支持lazy，可以让你的数据只在需要的时候被加载</li><li>提供HQL（Hibernate Query Language），可以完全把查询映射到模型</li></ol><img src="https://img-blog.csdnimg.cn/20200523174521551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW1pbmdUdQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"><p>流程说明:首先创建Configuration类的实例，并通过它来读取并解析配置文件hibernate.cfg.xml。然后创建SessionFactory读取解析映射文件信息，并将Configuration对象中的所有配置信息拷贝到SessionFactory内存(一级缓存级别)中。接下来，打开Session，让SessionFactory提供连接，并开启一个事务，之后创建对象，向对象中添加数据，通过session.save()方法完成向数据库中保存数据的操作。最后提交事务，并关闭资源。</p><p><strong>缺点：</strong></p><ol><li><strong>性能问题：</strong> 在大规模数据操作和复杂查询时，Hibernate的性能可能不如手动编写的SQL语句高效，需要开发者针对具体情况进行优化。</li><li><strong>学习成本：</strong> 对于初学者来说，学习和掌握Hibernate框架需要一定的时间和精力，尤其是理解ORM的概念和工作原理。</li><li><strong>对于特定场景的限制：</strong>hibernate将数据库与开发者隔离了，开发者不需要关注数据库是Oracle还是MySQL，hibernate来帮你生成查询的sql语句，但在某些特定场景下可能无法满足需求，需要开发者考虑是否需要自定义实现或者选择其他技术。</li></ol><img src="/2024/04/26/jdbc/hibernate缺点.png" alt="image-20240427153359661" style="zoom:80%;"><h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><p>JPA，全称是：Java PersistenceAPI。是SUN公司推出的一套<strong>基于ORM的规范</strong>。hibernate框架中提供了JPA的实现（但是，JPA规范的实现仅仅是Hibernate的一部分）。JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。JPA框架中支持大数据集、事务、并发等容器级事务。</p><p>Spring Data JPA为Java Persistence API（JPA）提供了实现。它简化了通过JPA访问数据库的开发工作，提供了很多CRUD的快捷操作，还提供了如分页、排序、复杂查询、自定义查询（JPQL）等功能，Spring Data JPA底层也是依赖于Hibernate来实现的，Spring Data JPA拥有标准化、简单易用、面向对象等优势，并且Spring将EntityManager 的创建与销毁、事务管理等代码抽取出来，并由Spring统一进行管理。</p><h3 id="JPA搭建"><a href="#JPA搭建" class="headerlink" title="JPA搭建"></a>JPA搭建</h3><p>maven依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>springboot配置</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">spring</span><span class="token punctuation">:</span><span class="token key attr-name">  application</span><span class="token punctuation">:</span><span class="token comment">    #应用名称</span><span class="token key attr-name">    name</span><span class="token punctuation">:</span> <span class="token value attr-value">spring-data-jpa</span><span class="token key attr-name">  datasource</span><span class="token punctuation">:</span><span class="token comment">    #你的数据库密码</span><span class="token key attr-name">    password</span><span class="token punctuation">:</span> <span class="token value attr-value">123456</span><span class="token comment">    #你的数据库地址</span><span class="token key attr-name">    url</span><span class="token punctuation">:</span> <span class="token value attr-value">jdbc:mysql://localhost:3306/spring_test?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</span><span class="token comment">    #数据库用户名</span><span class="token key attr-name">    username</span><span class="token punctuation">:</span> <span class="token value attr-value">root</span><span class="token comment">    #数据库驱动名称</span><span class="token key attr-name">    driver-class-name</span><span class="token punctuation">:</span> <span class="token value attr-value">com.mysql.cj.jdbc.Driver #配置MySQL的驱动程序类</span><span class="token comment">    #指定连接池类型</span><span class="token key attr-name">    type</span><span class="token punctuation">:</span> <span class="token value attr-value">com.zaxxer.hikari.HikariDataSource</span><span class="token comment">    #数据库连接池的配置</span><span class="token key attr-name">    hikari</span><span class="token punctuation">:</span><span class="token comment">      #客户端等待连接池连接的最大毫秒数</span><span class="token key attr-name">      connection-timeout</span><span class="token punctuation">:</span> <span class="token value attr-value">30000</span>         ……<span class="token comment">      #连接池的名称</span><span class="token key attr-name">  pool-name</span><span class="token punctuation">:</span> <span class="token value attr-value">SpringDataJPAHikariCP</span><span class="token comment">  #jpa相关配置</span><span class="token key attr-name">  jpa</span><span class="token punctuation">:</span><span class="token key attr-name">    hibernate</span><span class="token punctuation">:</span><span class="token comment">      #DDL:用于定义数据库的三层结构，包括外模式、概念模式、内模式及其相互之间的映像，定义数据的完整性，安全控制等约束</span><span class="token key attr-name">      ddl-auto</span><span class="token punctuation">:</span> <span class="token value attr-value">none #什么也不做</span><span class="token comment">      #其他可选值</span><span class="token comment">      #create: 每次运行应用程序时，都会重新创建表，所以，数据都会丢失</span><span class="token comment">      #create-drop:每次运行程序时会创建表结构，然后程序结束时清空数据</span><span class="token comment">      #update: 每次运行程序没有表时会创建表，如果对象改变会更新表结构，原有数据不会清除，只会更新</span><span class="token comment">      #validate: 运行程序会校验数据与数据库的字段类型是否相同，字段不同会报错</span><span class="token comment">    #打印执行的sql及参数</span><span class="token key attr-name">    show-sql</span><span class="token punctuation">:</span> <span class="token value attr-value">true</span><span class="token comment">    # 关闭懒加载配置，否则会报错</span><span class="token key attr-name">    open-in-view</span><span class="token punctuation">:</span> <span class="token value attr-value">false</span><span class="token key attr-name">    properties</span><span class="token punctuation">:</span><span class="token key attr-name">      hibernate</span><span class="token punctuation">:</span><span class="token comment">        #输出sql语句</span><span class="token key attr-name">        show_sql</span><span class="token punctuation">:</span> <span class="token value attr-value">true</span><span class="token comment">        #格式化输出的sql，否则会一行显示</span><span class="token key attr-name">        format_sql</span><span class="token punctuation">:</span> <span class="token value attr-value">true</span><span class="token key attr-name">server</span><span class="token punctuation">:</span><span class="token comment">  #指定服务端口号</span><span class="token key attr-name">  port</span><span class="token punctuation">:</span> <span class="token value attr-value">8008</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JPA简单查询"><a href="#JPA简单查询" class="headerlink" title="JPA简单查询"></a>JPA简单查询</h3><h4 id="Repository的编写"><a href="#Repository的编写" class="headerlink" title="Repository的编写"></a><strong>Repository的编写</strong></h4><p>JPA中，我们只需要定义一个接口就可以轻松地操作数据库，这个接口要继承JpaRepository接口，这里需要指定两个泛型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BannerRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一个泛型是实体类的类型，第二个泛型是主键的类型。</p><h4 id="JPA简单条件查询"><a href="#JPA简单条件查询" class="headerlink" title="JPA简单条件查询"></a><strong>JPA简单条件查询</strong></h4><p>JPA要求 我们按照一定的规则进行命名就可以进行一些简单的查询，下面我们开始编写第一个JPA方法。</p><p>我们可以定义如下的方法，按照字面上的理解就是，通过查询Banner通过Id，参数是bannerId，也可以通过其他字段来进行查询，IDE会给出提示，我们仅仅需要编写一个这样的方法JPA就会自动的完成查询工作，当前方法中返回的Java8中的Optional对象，也可以直接返回Banner实体类，在一些业务场景下，返回的结果集可能是多个实体对象，这时要用List来进行接收。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BannerRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 查询banner 通过bannerId     *     * @param bannerId bannerId     * @return banner 详细信息     */</span>    <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">&gt;</span></span> <span class="token function">findBannerById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> bannerId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a><strong>多条件查询</strong></h4><p>如果通过多个条件进行查询，如通过名称和描述进行查询，JPA也支持这种查询方式，我们只需要将条件用and进行连接，这里的条件的属性名称与个数要与参数的位置和个数一一对应。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>Banner <span class="token function">findBannerByNameAndDescription</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> description<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>JPA几乎实现了MySQL所有的查询关键字，第一个查询是通过Equals关键字来查询名称相同和价格相等的商品，第二个查询是通过GreaterThanEqual关键字来查询名称相同价格大于等于给定价格的商品。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*** 查询商品列表通过名称和价格*/</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findByNameAndPriceEquals</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*** 查询商品列表并且价格大于等于指定的价格*/</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findByNameAndPriceGreaterThanEqual</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a><strong>排序与分页</strong></h4><p>JPA还提供了对排序和分页的支持，只需要在查询方法的入参中加入Sort对象作为入参，就可以实现排序功能，实现分页功能需要将Pageable作为入参就可以实现分页功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token class-name">Sort</span> sort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="JPA复杂查询"><a href="#JPA复杂查询" class="headerlink" title="JPA复杂查询"></a><strong>JPA复杂查询</strong></h3><h4 id="自定义JPQL"><a href="#自定义JPQL" class="headerlink" title="自定义JPQL"></a>自定义JPQL</h4><p>如果JPA规范定义的查询关键字不能满足需求的话，就可以使用@Query自定义查询的JPQL。</p><blockquote><p>第一个自定义简单查询</p></blockquote><p>查询最大id的商品信息，nativeQuery属性表示，是否使用原生SQL，目前使用的JPQL并不是原生的，该属性默认是false，默认可以不写就是使用JPQL查询，这里要注意的是查询使用的表名是实体类，而不是数据表。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**  * 查询id值最大的商品信息  */</span><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SELECT g from Goods g WHERE id = (SELECT max(id) FROM Goods)"</span><span class="token punctuation">,</span> nativeQuery <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token class-name">Goods</span> <span class="token function">getMaxIdGoods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种传递参数的方式：通过参数名来进行传递，通过@Param注解来指定参数名称，在JPQL中使用:参数名的方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">"SELECT g FROM Goods g WHERE name= :name and price &gt;= :price"</span><span class="token punctuation">)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findGoodsBySecondParam</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"price"</span><span class="token punctuation">)</span> <span class="token class-name">BigDecimal</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="JPA原生查询"><a href="#JPA原生查询" class="headerlink" title="JPA原生查询"></a><strong>JPA原生查询</strong></h4><p>之前我们使用的自定义查询都是使用JPQL来进行查询，下面将演示使用原生SQL来进行查询，如下查询所有的商品信息，前面已经介绍过，nativeQuery用来标志当前查询是一条原生SQL。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SELECT * FROM goods"</span><span class="token punctuation">,</span> nativeQuery <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAllNativeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么如果我们想要拿到原生查询的部分结果，那么我们就需要使用Map来进行接收。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SELECT name, price FROM goods"</span><span class="token punctuation">,</span> nativeQuery <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">getGoodsNameAndPriceNativeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员JDBC原理+实战：<a href="https://www.bilibili.com/video/BV1s3411K7jH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1s3411K7jH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>JDBC连接如何防止SQL注入：<a href="https://blog.csdn.net/u014454538/article/details/108952103">https://blog.csdn.net/u014454538/article/details/108952103</a></p><p>Java持久层框架整理：<a href="https://blog.csdn.net/jiamingTu/article/details/106298092">https://blog.csdn.net/jiamingTu/article/details/106298092</a></p><p>为什么90%的开发者放弃使用Hibernate，而选择MyBatis：<a href="https://www.zhihu.com/question/532452772">https://www.zhihu.com/question/532452772</a></p><p>JPA入门：<a href="https://zhuanlan.zhihu.com/p/519013984">https://zhuanlan.zhihu.com/p/519013984</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持久层 </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Survey of Large Language Models</title>
      <link href="/2024/04/24/a-survey-of-large-language-models/"/>
      <url>/2024/04/24/a-survey-of-large-language-models/</url>
      
        <content type="html"><![CDATA[<h1 id="大模型综述"><a href="#大模型综述" class="headerlink" title="大模型综述"></a>大模型综述</h1><p><strong>参考博客：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/630203554">https://zhuanlan.zhihu.com/p/630203554</a></p><p><a href="https://www.cnblogs.com/David-deng/p/17786107.html">https://www.cnblogs.com/David-deng/p/17786107.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/662673023">https://zhuanlan.zhihu.com/p/662673023</a></p><p><a href="https://blog.csdn.net/qq_41185868/article/details/131565801">https://blog.csdn.net/qq_41185868/article/details/131565801</a></p><p><a href="https://mp.weixin.qq.com/s/yIsHsZL2Kbav0LvTUry_dg">https://mp.weixin.qq.com/s/yIsHsZL2Kbav0LvTUry_dg</a></p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>语言模型的四个发展阶段：</p><h3 id="统计语言模型（SLM）"><a href="#统计语言模型（SLM）" class="headerlink" title="统计语言模型（SLM）"></a>统计语言模型（SLM）</h3><p>20世纪90年代，学术界对于统计语言模型(SLM)的研究开始兴起。</p><p><strong>基于马尔可夫假设建立词预测模型</strong>，例如根<strong>据最近的上下文预测下一个词</strong>，例如bigram 和 trigram 语言模型。</p><ul><li>bi-gram语言模型：当前词出现的概率只与上一个词出现的概率相关</li><li>tri-gram语言模型：当前词出现的概率只与上两个词出现的概率相关</li></ul><p>SLM 已被广泛应用于提高信息检索（IR） 和自然语言处理（NLP）任务。</p><p>问题：<strong>维数灾难.需要估计指数级数量的转换概率</strong>，因此很难准确估计高阶语言模型。因此，设计专门的平滑策略，如回退估计和古德图灵估计.</p><h3 id="神经语言模型-NLM"><a href="#神经语言模型-NLM" class="headerlink" title="神经语言模型(NLM)"></a>神经语言模型(NLM)</h3><p>通过神经网络，如循环神经网络（RNN），来<strong>描述单词序列的概率</strong>。在聚合上下文特征（即分布式词向量）的条件下构建词预测函数。</p><p><strong>word2vec  提出了构建一个简化的浅层神经网络来学习分布式单词表示的方法.</strong></p><p>这些研究开创了<strong>将语言模型用于表示学习（超越词序列建模）的应用</strong></p><h3 id="预训练语言模型-PLM"><a href="#预训练语言模型-PLM" class="headerlink" title="预训练语言模型 (PLM)"></a>预训练语言模型 (PLM)</h3><p>ELMo被提出<strong>通过预训练</strong>一个双向 LSTM（biLSTM）<strong>网络</strong>（而不是学习固定的词表示）<strong>来捕捉上下文感知的词表示，然后根据特定的下游任务微调 biLSTM 网络</strong>。</p><p>进一步，<strong>基于自注意力机制的高度并行化 Transformer 架构</strong> [22]，BERT [23] 作为双向语言模型，在大规模无标签语料库上使用专门设计的预训练任务。这些<strong>预训练的上下文感知词表示作为通用语义特征非常有效</strong>，其极大地提高了 NLP 任务的性能。</p><p>确立了“预训练和微调”学习范式。已经建立了大量关于 PLM 的研究，这些研究引入了不同的架构 [24, 25]（例如 GPT-2 [26] 和 BART [24]）或改进的预训练策略 [27–29]。在这个范式中，通常需要对 PLM进行微调以适配不同的下游任务。</p><h3 id="大语言模型-LLM"><a href="#大语言模型-LLM" class="headerlink" title="大语言模型(LLM)"></a>大语言模型(LLM)</h3><p>扩展 PLM（例如扩展模型大小或数据大小）通常会提高下游任务的模型性能（即遵循扩展法则 [30]）。许多研究通过训练越来越大的 PLM（例如 1750 亿参数的 GPT-3 和 5400 亿参数的 PaLM）来探索性能极限。</p><p>大规模的 PLM 与较小的 PLM表现出不同的行为，并在解决一系列复杂任务中展示了惊人的能力（称为涌现能力）。</p><p>例如，GPT-3 可以通过上下文学习（in-context learning, ICL）来解决小样本任务，而 GPT-2 则表现不佳。</p><p>研究界将这些大规模的 PLM 命名为“大语言模型”</p><p>通常，大型语言模型（LLM）是指包含数千亿（或更多）参数的语言模型，这些参数是在大量文本数据上训练的，例如模型 GPT-3、PaLM、Galactica 和 LLaMA。具体来说，LLM 建立在 Transformer 架构之上，其中多头注意力层堆叠在一个非常深的神经网络中。现有的 LLM 主要采用与小语言模型类似的模型架构（即 Transformer）和预训练目标（即语言建模）。作为主要区别，LLM 在很大程度上扩展了模型大小、预训练数据和总计算量（扩大倍数）。他们可以更好地理解自然语言，并根据给定的上下文（例如 prompt）生成高质量的文本。这种容量改进可以用标度律进行部分地描述，其中性能大致遵循模型大小的大幅增加而增加。然而根据标度律，某些能力（例如，上下文学习）是不可预测的，只有当模型大小超过某个水平时才能观察到。</p><h3 id="LLM-vs-PLM"><a href="#LLM-vs-PLM" class="headerlink" title="LLM vs PLM"></a>LLM vs PLM</h3><ul><li><p>wikipedia：大语言模型 (英语：large language model，LLM) 是一种语言模型，由具有许多参数（通常数十亿个权重或更多）的人工神经网络组成，使用自监督学习或半监督学习对大量未标记文本进行训练。大型语言模型在2018年左右出现，并在各种任务中表现出色。</p></li><li><p>本综述的观点：大语言模型是指包含数千亿（或更多）参数的Transformer语言模型，这些模型是在大规模文本数据上进行训练的，例如GPT-3，PaLM，Galactica 和 LLaMA。</p></li><li><p>我的理解：</p><ul><li>通过上面的回答我们可以看出，现在的研究中并没有对于多大的模型才能算作大语言模型有一个确切的定义。通常大语言模型一般拥有数十亿或者更多的参数。</li><li>对于本综述的观点我并不是非常的认可。因为我们知道 LLaMA 2 拥有三个版本，参数量分别是7B、13B和70B，没有达到综述中的千亿参数的规模，但是 LLaMA 2 还是被大家公认为是一个预训练的大语言模型。</li></ul></li></ul><p>1.<strong>LLM具有涌现能力(emergent abilities)：这是llm能解决复杂任务的关键</strong></p><p>2.LLM 将彻底改变人类开发和使用人工智能算法的方式。</p><p>3.LLM 的发展不再明确区分研究和工程。训练 LLM 需要在大规模数据处理和分布式并行训练方面具有丰富的实践经验，研究人员需要与工程人员合作。</p><h3 id="LLM机遇与挑战"><a href="#LLM机遇与挑战" class="headerlink" title="LLM机遇与挑战"></a>LLM机遇与挑战</h3><h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><p>ChatGPT 和 GPT-4 的出现促使人们重新思考通用人工智能（AGI）的可能性。</p><p>在 NLP 领域，LLM 可以在一定程度上作为通用语言任务解决器，研究范式已经转向使用 LLM。在 IR 领域，传统搜索引擎正受到通过 AI 聊天机器人（即 ChatGPT）搜索新信息的挑战。在计算机视觉（CV）领域，研究人员试图开发类似 ChatGPT 的视觉-语言模型，以更好地为多模态对话提供服务。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>其基本原理尚未得到充分探索。</strong></p><p><strong>涌现能力的出现难以解释。研究界缺乏对 LLM 优越能力的关键因素进行深入、详细的研究调查</strong></p><p>研究界很难训练出有能力的 LLM。由于计算资源的巨大需求，为了研究训练 LLM 的各种策略的效果，进行重复、消融研究的成本非常高</p><p>将 LLM 与人类价值观或偏好保持一致是具有挑战的。</p><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2.概述"></a>2.概述</h2><h3 id="2-1背景"><a href="#2-1背景" class="headerlink" title="2.1背景"></a>2.1背景</h3><p>为了对 LLM 的工作原理有一个快速的了解，本部分将介绍 LLM 的基本背景，包括扩展法则、涌现能力和关键技术。</p><h4 id="扩展法则-Scaling-Laws"><a href="#扩展法则-Scaling-Laws" class="headerlink" title="扩展法则 Scaling Laws"></a>扩展法则 Scaling Laws</h4><p><strong>现有的llm采用与小型语言模型类似的Transformer体系结构和预训练目标（例如，语言建模），但大幅度扩展了模型规模、数据规模和总计算量（数量级）。</strong></p><p>扩展可以大幅提高 LLM 的模型能力<strong>，因此，建立一个定量的方法来描述扩展效应是有意义的</strong>。</p><p>两个代表性工作：</p><p>（1）KM scaling law：2020年，Kaplan等人（OpenAI团队）首次提出建模模型参数和三个主要因素（即模型大小N、数据集大小D、训练计算量C）之间的幂律关系。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231023174256702.png" alt="image-20231023174256702"><p>其中L(·)表示使用纳特（nats：在信息论中，nats是自然对数的单位，用于度量信息量或信息熵。它是以自然对数的底数e为基础，表示信息的相对量——from ChatGPT）<strong>表示的交叉熵损失</strong>。这三个定律是在一些假设(例如，一个因素的分析不应该受到其他两个因素的瓶颈)下，通过拟合不同数据大小(22M到23B个tokens)、模型大小(768M到1.5B个非嵌入参数)和训练计算的模型性能得出的。<br>这里，Nc、Dc和Cc分别以非嵌入参数的数量、训练tokens的数量和FP天数来衡量。<br>（2）Chinchilla Scaling law：作为另一项具有代表性的研究，Hoffmann等人（谷歌DeepMind团队）提出了一种缩放定律的替代形式，以指导LLM的计算优化训练。</p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231023174356210.png" alt="image-20231023174356210"></p><p>其中 <em>E</em> = 1*.<em>69</em>, A* = 406*.<em>4</em>, B* = 410*.<em>7，</em>α* = 0*.<em>34 和 <em>β</em> = 0</em>.<em>28。通过在约束条件 <em>C</em> <em>≈</em> 6</em>ND* 下优化损失 <em>L</em>(<em>N, D</em>)，他们展示了将计算预算最优地分配给模型大小和数据大小的方法（如下）：</p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231023174428643.png" alt="image-20231023174428643"></p><p>随着给定计算预算的增加，<strong>KM 扩展法则更偏向于将更大的预算分配给模型大小，而 Chinchilla 扩展法则则认为模型大小和数据大小应该以相同的比例增加</strong>，即在公式 (3)中的 <em>a</em> 和 <em>b</em> 取相近的值。</p><h4 id="涌现能力-emergent-abilities"><a href="#涌现能力-emergent-abilities" class="headerlink" title="涌现能力 emergent abilities"></a>涌现能力 emergent abilities</h4><p>涌现：在小型模型中不存在但在大型模型中产生的能力。这是区别 LLM 与先前 PLM 的最显著特征之一</p><p>LLM 的三种典型涌现能力和具备这种能力的代表性模型：</p><h5 id="上下文学习-In-context-learning"><a href="#上下文学习-In-context-learning" class="headerlink" title="上下文学习 In-context learning"></a>上下文学习 In-context learning</h5><p>为语言模型提供一个自然语言指令和/或几个任务示例，它就可以通过完成输入文本的单词序列的方式来为测试实例生成预期的输出，而无需额外的训练或梯度更新。这种能力还取决于具体的下游任务。</p><p>在 GPT系列模型中，1750 亿的 GPT-3 模型在一般情况下表现出强大的 ICL 能力，但 GPT-1 和 GPT-2 模型则没有。然</p><h5 id="指令遵循-Instruction-following"><a href="#指令遵循-Instruction-following" class="headerlink" title="指令遵循 Instruction following"></a>指令遵循 Instruction following</h5><p>微调 基于自然语言描述来格式化的多任务混合数据集。对于没见过的按照指令的形式描述的任务，LLMs可以在做得很好。</p><p>通过指令微调，LLM 能够在没有使用显式示例的情况下遵循新的任务指令，因此它具有更好的泛化能力。</p><h5 id="逐步推理Step-by-step-reasoning"><a href="#逐步推理Step-by-step-reasoning" class="headerlink" title="逐步推理Step-by-step reasoning"></a>逐步推理Step-by-step reasoning</h5><p>通过使用思维链（Chain-of-Thought, CoT）提示策略 [32]，LLM 可以通过利用包含中间推理步骤的提示机制来解决复杂推理任务</p><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><h5 id="Scaling-扩展"><a href="#Scaling-扩展" class="headerlink" title="Scaling 扩展"></a>Scaling 扩展</h5><p>在Transformer语言模型中存在明显的缩放效应:更大的模型/数据大小和更多的训练计算通常会导致模型能力的改进。<br>此外，由于计算预算通常是有限的，因此可以使用缩放定律来进行计算效率更高的计算资源分配。<br>例如，Chinchilla(具有更多的训练tokens)通过在相同的计算预算下增加数据规模超过了其对应模型Gopher(具有更大的模型大小)。<br>然而，应该注意的是，数据缩放应该伴随着仔细的清理过程，因为预训练数据的质量在模型能力中起着关键作用。</p><h5 id="Training-训练"><a href="#Training-训练" class="headerlink" title="Training 训练"></a>Training 训练</h5><p>为了支持分布式训练，已经发布了几个优化框架来促进并行算法的实现和部署，例如DeepSpeed和Megatron-LM。<br>此外，优化技巧对于训练稳定性和模型性能也很重要，例如重新启动以克服训练损失尖峰和混合精度训练。<br>最近，GPT-4提出开发特殊的基础设施和优化方法，用小得多的模型可靠地预测大型模型的性能。</p><h5 id="Ability-Eliciting-能力引导"><a href="#Ability-Eliciting-能力引导" class="headerlink" title="Ability Eliciting 能力引导"></a>Ability Eliciting 能力引导</h5><p>作为一种技术方法，设计合适的任务指令或特定的上下文学习策略来诱导这种能力是有用的。<br>例如，思维链提示，即通过中间推理步骤以解决复杂的推理任务，已被证明是有用的。<br>此外，我们还可以对LLMs进行指令微调，用自然语言表达任务描述，提高LLMs对不曾见过的任务的泛化能力。</p><h5 id="Alignment-Tuning-对齐微调"><a href="#Alignment-Tuning-对齐微调" class="headerlink" title="Alignment Tuning 对齐微调"></a>Alignment Tuning 对齐微调</h5><p>有必要使 LLM 与人类价值观保持一致，例如有用性、诚实性和无害性。</p><p>为此，InstructGPT设计了一种有效的调优方法，使llm能够遵循预期的指令，该方法利用了带有人类反馈的强化学习技术（RLHF）。<br>ChatGPT确实是在与InstructGPT类似的技术基础上开发的，其在产生高质量、无害的回复方面显示出强大的对齐能力，例如，拒绝回答侮辱性的问题。</p><h5 id="Tool-Manipulation-工具操作"><a href="#Tool-Manipulation-工具操作" class="headerlink" title="Tool Manipulation 工具操作"></a>Tool Manipulation 工具操作</h5><p>从本质上讲，LLMs在大量纯文本语料库上被训练为文本生成器，因此在不能最好地以文本形式表达的任务(例如，数值计算)上表现不佳。此外，它们的能力也局限于预训练数据，例如，无法获取最新信息。为了解决这些问题，最近提出的一种技术是使用外部工具来弥补LLMs的不足。<br>例如，LLMs可以利用计算器进行精确计算，利用搜索引擎检索未知信息。最近，ChatGPT启用了使用外部插件(现有或新创建的应用程序)的机制，这被类比为LLMs的“眼睛和耳朵”。这种机制可以广泛扩展 LLM 的能力范围。</p><h3 id="2-2技术演进"><a href="#2-2技术演进" class="headerlink" title="2.2技术演进"></a>2.2技术演进</h3><img src="/2024/04/24/a-survey-of-large-language-models/image-20231106143336059.png" alt="image-20231106143336059" style="zoom:80%;"><p>GPT模型的基本原理是通过语言建模将世界知识压缩为仅含解码器的Transformer模型，从而恢复（或记忆）世界知识的语义，并充当通用任务求解器。成功的两个关键点是 (1)只训练解码器的Transformer语言模型，可以准确地预测下一个词  (2) 扩大语言模型的规模</p><h5 id="早期探索阶段"><a href="#早期探索阶段" class="headerlink" title="早期探索阶段"></a>早期探索阶段</h5><p>随着 Transformer 的出现，OpenAI开发了两个初始的 GPT 模型，即GPT-1和GPT-2</p><p>GPT表示生成式预训练（<em>Generative Pre-Training</em>）。GPT-1是基于生成式、仅解码器的Transformer架构开发的，采用了无监督预训练和有监督微调的混合方法。</p><p>GPT-2采用与GPT-1类似的架构，将参数尺度增加到1.5B，使用大型网页数据集WebText进行训练。它试图通过无监督语言建模来执行任务，而无需使用标记数据进行显式的微调。为了推动这种方法，他们引入了多任务求解的概率形式，即<em>p</em>(<em>output</em>*|*<em>input, task</em>)（类似的方法已在 [75] 中采用），它在给定输入和任务信息的条件下预测输出。为了对该条件概率建模，自然语言文本可以自然地用作为格式化输入、输出和任务信息的统一方式。通过这种方式，解决任务的过程可以被视为生成解决方案文本的单词预测问题。</p><p>由于(特定于任务的)监督目标与无监督(语言建模)目标相同，但只在序列的一个子集上进行评估，因此无监督目标的全局最小值也是监督目标的全局最小值(对于各种任务)。</p><p>对这个主张的基本理解是，每个 NLP 任务可以被视为基于世界文本的子集的单词预测问题。因此，如果模型训练后具有足够能力以复原世界文本，无监督语言建模可以解决各种任务。</p><h5 id="能力飞跃"><a href="#能力飞跃" class="headerlink" title="能力飞跃"></a>能力飞跃</h5><p>尽管GPT-2旨在成为一个“无监督多任务学习器”，但与监督微调的最先进方法相比，它的总体性能较差。<br>虽然它的模型尺寸相对较小，但它在下游任务中进行了广泛的微调，特别是对话任务。在GPT-2的基础上，GPT-3通过扩展(几乎相同的)生成预训练架构展示了关键的能力飞跃。<br>GPT-3扩展到175B参数，并引入上下文学习(ICL)的概念，它以少样本或零样本的方式利用LLM。</p><p>LLM 的预训练和使用在 ICL 下有着相同的语言建模范式：预训练预测给定上下文条件下的后续文本序列，而 ICL 预测正确的任务解决方案，该解决方案可以被格式化为给定任务描述和示范下的文本序列。</p><h5 id="能力增强"><a href="#能力增强" class="headerlink" title="能力增强"></a>能力增强</h5><p>OpenAI 探索了两种主要方法来进一步改进 GPT-3 模型，即使用代码数据进行训练以及与人类偏好的对齐</p><p><strong>使用代码数据进行训练：</strong></p><p>原始的GPT-3模型(在纯文本上预训练)的局限在于缺乏复杂任务的推理能力，例如补全代码和解决数学问题。<br>为了增强这种能力，OpenAI于2021年7月引入了Codex，这是一个在大型GitHub代码语料库上进行微调的GPT模型。它证明了Codex可以解决非常困难的编程问题，并且在解决数学问题时也可以显著提高性能。<br>此外，2022年1月报道了一种用于训练文本和代码嵌入的对比方法，该方法被证明可以改进一系列相关任务(即线性探测分类、文本搜索和代码搜索)。<br>实际上，GPT-3.5模型是基于基于代码的GPT模型(即code-davinci-002)开发的，这表明对代码数据的训练是提高GPT模型的建模能力，特别是推理能力的一个非常有用的实践。<br>此外，也有人推测，对代码数据进行训练可以大大提高LLMs的思维链提示能力，但这仍值得进一步研究，需要更彻底的验证。</p><p><strong>与人类对齐</strong><br>OpenAI对人类偏好的相关研究可以追溯到2017年(或更早):OpenAI博客上发表了一篇题为“从人类偏好中学习”的博客文章，描述了一项应用强化学习(RL)从人类标注的偏好比较中学习的工作。(类似于InstructGPT的图6中对齐算法中的reward-training步骤)。<br>这篇RL文章发布不久后，PPO的文章（Proximal Policy Optimization)于2017年7月发表，目前已成为从人类偏好中学习的基础强化学习算法。<br>随后在2020年1月，使用上述RL算法对GPT-2进行了微调，该算法利用人类偏好来提高GPT-2在NLP任务上的能力。同年，另一项研究以类似的方式训练了一个优化人类偏好的摘要模型。<br>在这些前期工作的基础上，2022年1月InstructGPT被提出，用于改进GPT-3模型的人类对齐，该模型正式建立了一种<strong>基于人类反馈的三阶段强化学习(RLHF)算法</strong>。请注意，OpenAI的论文和文档中似乎很少使用“instruction tuning”的措辞，取而代之的是对人类示例的有监督微调(即RLHF算法的第一步)。<br>除了提高指令遵循能力外，RLHF算法在减轻LLMs产生有害或有毒内容的问题上特别有用，这是LLMs在实践中安全部署的关键。</p><p>这些增强技术导致改进后的GPT-3模型具有更强的能力，OpenAI将其称为GPT-3.5模型。</p><h5 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h5><p><strong>chatgpt</strong></p><p>ChatGPT的训练方式与InstructGPT类似，但专门针对对话能力进行了优化。</p><p>他们报告了ChatGPT和InstructGPT在数据收集设置上的训练差异:人工生成的对话(扮演用户和人工智能的角色)与InstructGPT数据集以对话格式相结合，用于训练ChatGPT。</p><p>拥有丰富的知识库，擅长解决数学问题，准确追踪多轮对话中的上下文，并与人类的价值观保持一致以确保被安全使用。支持插件机制，这进一步扩展了ChatGPT与现有工具或应用程序的能力。</p><p><strong>GPT-4</strong></p><p>GPT-4于2023年3月发布，将文本输入扩展到多模态信号。</p><p>由于经过为期六个月的迭代对齐（在RLHF训练中加入了额外的安全奖励信号），GPT-4对于具有恶意或挑衅的提问的响应更加安全。例如，他们引入了一种称为红队评估（<em>red teaming</em>）的机制来减少有害或生成有毒内容的可能性。他们引入了一种称为可预测扩展（<em>predictablescaling</em>）的新机制，可以使用模型训练期间一小部分的计算量来准确预测最终性能。</p><p>从工程的角度来看，OpenAI采用了一种迭代部署策略，通过遵循五阶段的开发和部署生命周期来开发模型和产品，以有效降低使用模型带来的潜在风险。</p><h2 id="3-大模型资源"><a href="#3-大模型资源" class="headerlink" title="3.大模型资源"></a>3.大模型资源</h2><p>考虑到技术问题的挑战和计算资源的巨大需求，开发或复现LLM 绝非易事。一种可行的方法是在现有的 LLM 的基础上进行开发，即重复使用公开可用的资源进行增量开发或实验研究。在本节中，我们简要整理了用于开发 LLM 的公开可用的资源，包括公开的模型检查点（或 API）、语料库和代码库。</p><h3 id="3-1公开的模型检查点或API"><a href="#3-1公开的模型检查点或API" class="headerlink" title="3.1公开的模型检查点或API"></a>3.1公开的模型检查点或API</h3><p><strong>百亿参数模型</strong></p><p>除LLaMA(最大版本包含65B个参数)和NLLB(最大版本包含54.5B个参数)外，该类模型的参数尺度大多在10B - 20B之间。</p><p>Flan-T5 (11B版本)可以作为研究指令调优（instruction tuning）的首选模型，因为它从三个方面探索指令调优：增加任务数量，缩放模型大小，以及使用思维链提示数据进行微调。<br>此外，CodeGen (11B版本)作为一种为生成代码而设计的自回归语言模型，可以认为是探索代码生成能力的一个很好的候选。它还引入了一个专门针对多轮程序合成的新基准MTPB，由115个专家生成的问题组成。为了解决这些问题，LLMs需要掌握足够的编程知识(如数学、数组操作和算法)。<br>对于多语言任务，mT0 (13B版本)可能是一个很好的候选模型，它已经对具有多语言提示的多语言任务进行了微调。<br>此外，PanGu-α在基于深度学习框架MindSpore开发的中文下游任务中，在零样本或少样本设置中表现良好。（注意PanGu-α有多个版本，最大有200B参数，公开的最大版本是13B）。由于LLaMA的开放性和有效性，它已经引起了研究界的极大关注，许多努力都致力于对其不同的模型版本进行微调或持续预训练，以实现新的模型或工具。<br>通常，这种规模的预训练模型需要数百甚至数千个gpu或tpu。例如，GPT-NeoX-20B使用12台超微服务器，每台服务器配备8个NVIDIA A100-SXM4-40GB gpu，而LLaMA在其原始出版物中使用2,048个A100-80G gpu。</p><p><strong>千亿参数模型</strong></p><p>在跨语言泛化研究中，BLOOM (176B版本)和BLOOMZ (176B版本)可以作为基础模型，因为它们在多语言语言建模任务中的能力。<br>在这些模型中，OPT-IML已经使用指令进行了调优，这可能是研究指令调优效果的良好候选者。<br>这种规模的模型通常需要数千个gpu或tpu来训练。例如，OPT (175B版本)使用992个A100-80GB GPU，而GLM (130B版本)使用96个NVIDIA DGX-A100 (8x40G) GPU节点的集群。</p><p><strong>公共API</strong></p><p>OpenAI为GPT-3系列模型提供了七个主要接口：ada、babbage、curie、davinci (GPT-3系列中最强大的版本)、text-ada-001、text-babbage-001和text-curie-001。其中，前四个接口可以在OpenAI的主机服务器上进一步微调。babbage、curie和davinci分别对应于GPT-3 (1B)、GPT-3 (6.7B)和GPT-3 (175B)模型。<br>此外，还有两个与Codex相关的api，称为code-cushman-001 (Codex (12B)的强大多语言版本)和code-davinci-002。<br>此外，GPT-3.5系列包括一个基础模型code-davinci-002和三个增强版本，即text-davinci-002, text-davinci-003和GPT-3.5-turbo-0301。值得注意的是，gpt-3.5-turbo-0301是调用ChatGPT的接口。<br>最近，OpenAI也为GPT-4发布了相应的api，包括gpt-4、gpt-4-0314、gpt-4-32k和gpt-4-32k-0314。<br>api详细用法见：<a href="https://link.zhihu.com/?target=https://platform.openai.com/docs/models/overview">https://platform.openai.com/doc</a></p><h3 id="3-2常用语料库"><a href="#3-2常用语料库" class="headerlink" title="3.2常用语料库"></a>3.2常用语料库</h3><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231106164749415.png" alt="image-20231106164749415"></p><h4 id="books"><a href="#books" class="headerlink" title="books"></a>books</h4><p>BookCorpus–小规模模型（如 GPT和 GPT-2）中常用的数据集，包括超过 11,000 本电子书，涵盖广泛的主题和类型（如小说和传记）。另一个大规模的书</p><p>籍语料库是 Gutenberg，它有超过 70,000 本文学作品，包括小说、散文、诗歌、戏剧、历史、科学、哲学和其他公共领域的作品。它是目前最大的开源书籍集合之一，被用于训练 MT-NLG 和 LLaMA。</p><h4 id="CommonCrawl"><a href="#CommonCrawl" class="headerlink" title="CommonCrawl"></a><strong>CommonCrawl</strong></h4><p> <strong>CommonCraw 是最大的开源网络爬虫数据库之一</strong>，包含百万亿字节级的数据量，已被广泛用作LLMs训练。</p><p>由于web数据中普遍存在噪声和低质量的信息，因此在使用前需要对数据进行预处理。现有工作中常用的过滤数据集有四种：C4、CCStories、CC-News和RealNews。C4包括五个变体，即en (806G)， en.noclean (6T)、realnewslike (36G)、web-textlike (17G)和multilingual (38T)。en版本已被用于T5、LaMDA、Gopher和UL2的预训练。multilingual C4，也称为mC4，已在mT5中使用。</p><h4 id="Reddit-Links"><a href="#Reddit-Links" class="headerlink" title="Reddit Links"></a>Reddit Links</h4><p>Reddit是一个社交媒体平台，用户可以提交链接和文本帖子，其他人可以通过“赞”或“贬”对这些帖子进行投票。WebText 就是一个著名的基于 Reddit 的语料库，它由 Reddit 上高赞的链接组成，但尚未公开。作为替代，有一个易于获取的开源替代品叫做 OpenWebText。</p><h4 id="Wikipedia"><a href="#Wikipedia" class="headerlink" title="Wikipedia"></a>Wikipedia</h4><p>维基百科是一个在线百科全书，包含大量关于不同主题的高质量文章。通常情况下，维基百科的纯英文过滤版本在大多数LLMs中被广泛使用(例如GPT-3， LaMDA和LLaMA)。维基百科有多种语言版本，因此它可以在多语言环境中使用。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>代码数据有两个主要来源：包括开源许可证的公共代码库（例如 GitHub）和与代码相关的问答平台（例如 StackOverflow）。</p><p>Google 公开发布了 BigQuery 数据集，其中包括各种编程语言的大量开源许可证代码片段，是一个典型的代码数据集。</p><p>CodeGen 使用的 BIGQUERY是 BigQuery 数据集的一个子集，用于训练多语言版本的CodeGen（CodeGen-Multi）。</p><h4 id="others"><a href="#others" class="headerlink" title="others"></a>others</h4><p>The Pile是一个大规模、多样化、开源的文本数据集，有超过 800GB 数据，内容包括书籍、网站、代码、科学论文和社交媒体平台等。它由 22 个多样化的高质量子集构成。The Pile数据集广泛应用于不同参数规模的模型中，如GPT-J (6B)、CodeGen (16B)、MegatronTuring NLG (530B)。<br>此外，ROOTS由各种较小的数据集(总共1.61 TB的文本)组成，涵盖59种不同的语言(包括自然语言和编程语言)，被用来训练BLOOM。</p><p><strong>给出了三个代表性LLMs的预训练语料库：</strong><br>（1）GPT-3 (175B)：在一个包含300B个tokens的混合数据集上进行训练，包括CommonCrawl、WebText2、Books1、Books2和Wikipedia。<br>（2）PaLM (540B)：使用780B tokens的预训练数据集，这些数据来自社交媒体对话、过滤的网页、书籍、Github、多语言维基百科和新闻。<br>（3）LLaMA：从各种来源提取训练数据，包括CommonCrawl, C4 , Github, Wikipedia, books, ArXiv和StackExchange。LLaMA (6B)和LLaMA (13B)的训练数据大小为1.0T tokens，LLaMA (32B)和LLaMA (65B)的训练数据大小为1.4T tokens。</p><h3 id="3-3代码库资源"><a href="#3-3代码库资源" class="headerlink" title="3.3代码库资源"></a>3.3代码库资源</h3><p>（1）Transformers是一个开源Python库，用于使用Transformer架构构建模型，由Hugging Face开发和维护。方便使用和定制各种预训练模型。<br>（2）DeepSpeed是微软开发的深度学习优化库(与PyTorch兼容)，已被用于训练多个LLMs，如MT-NLG和BLOOM。它为分布式训练提供了各种优化技术的支持，例如内存优化(ZeRO技术、梯度检查点)和流水线并行。<br>（3）Megatron-LM是NVIDIA开发的用于训练大规模语言模型的深度学习库。它还为分布式训练提供了丰富的优化技术，包括模型和数据并行、混合精度训练和FlashAttention。这些优化技术可以大大提高训练效率和速度，实现高效的跨GPU分布式训练。<br>（4）JAX是谷歌开发的用于高性能机器学习算法的Python库，允许用户轻松地在硬件加速(例如GPU或TPU)下对数组执行计算。它可以在各种设备上进行有效的计算，并且还支持一些功能，例如自动微分和即时编译。<br>（5）colossal-AI是由HPC-AI Tech开发的用于训练大规模AI模型的深度学习库。它是基于PyTorch实现，并支持丰富的并行训练策略集合。此外，它还可以使用PatrickStar提出的方法优化异构内存管理。最近，一个名为ColossalChat的类chatgpt的模型已经公开发布了两个版本(7B和13B)，它是基于LLaMA使用colossal-ai开发的。<br>（6）BMTrain是OpenBMB开发的用于分布式训练大规模参数模型的高效库，强调代码简洁、低资源、高可用性。BMTrain已经将几个常见的LLM(例如，Flan-T5和GLM)合并到其ModelCenter中，开发人员可以直接使用这些模型。<br>（7）FastMoE是MoE(即混合专家)模型的专门训练库。它是基于PyTorch开发的，在设计中优先考虑效率和用户友好性。FastMoE简化了将Transformer模型转换为MoE模型的过程，并在训练期间支持数据并行和模型并行。<br>除了上述库资源外，现有的深度学习框架(如PyTorch、TensorFlow、MXNet、PaddlePaddle、MindSpore和OneFlow)也提供了对并行算法的支持，并行算法通常用于训练大规模模型。</p><h2 id="4-预训练"><a href="#4-预训练" class="headerlink" title="4.预训练"></a>4.预训练</h2><p>预训练为 LLM 的能力奠定了基础。通过在大规模语料库上进行预训练，LLM 可以获得基本的语言理解和生成能力。</p><h3 id="4-1数据收集"><a href="#4-1数据收集" class="headerlink" title="4.1数据收集"></a>4.1数据收集</h3><img src="/2024/04/24/a-survey-of-large-language-models/image-20231120151109467.png" alt="image-20231120151109467" style="zoom:80%;"><h4 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h4><p>预训练语料库的来源可以广义地分为两种类型：通用文本数据和专用文本数据。</p><p>通用文本数据，如网页、书籍和对话文本等，其由于规模大、多样性强且易于获取的特点，被大多数 LLM 所利用，这可以增强 LLM 的语言建模和泛化能力。</p><p><strong>通用文本数据</strong>：</p><p>之前的工作从网络中爬取了大量的数据，如CommonCrawl。抓取的web数据往往既包含高质量的文本(如Wikipedia)，也包含低质量的文本(如垃圾邮件)，因此对网页进行过滤和处理以提高数据质量非常重要。</p><p>对话数据可以增强 LLM 的对话能力，并可能改善 LLM 在问答任务上的表现 。由于在线对话数据通常涉及多个参与者之间的讨论，因此一种有效的处理方法是将对话转换为树状结构，其中话语与它所响应的话语相关联。过度引入对话数据来训练 LLM 可能会导致一个潜在的风险：<strong>陈述性指令和直接疑问句被错误地认为是对话的开始，从而导致指令的有效性下降。</strong></p><p>书籍提供了更正式的长文本，这对于 LLM <strong>学习语言知识、建模长期依赖关系以及生成叙述性和连贯的文本</strong>具有潜在的好处。为了获取开源图书数据，现有研究通常采用Books3和Bookcorpus2数据集，这两个数据集在Pile数据集中都有。</p><p><strong>专用文本数据</strong>：</p><p>专用数据通常对LLMs执行下游任务有用，包括多语言文本、科学文本、代码。整合多语言语料库可以增强模型的多语言的理解和生成能力。例如，BLOOM和PaLM在其预训练语料库中分别制作了涵盖46种和122种语言的多语言数据。</p><p><strong>通过在大量科学文本上进行预训练，LLM 可以在科学和推理任务中取得出色的性能。</strong>为了构建科学语料库，现有的工作主要是收集arXiv论文、科学教科书、数学网页以及其他相关的科学资源。由于科学领域中数据的复杂性，例如数学符号和蛋白质序列，通常需要特定的标记化（tokenization）和预处理技术来将这些不同格式的数据转换为可以由语言模型处理的统一形式。</p><p>一般来说，两种类型的代码语料库通常用于预训练LLM。第一个来源是编程问答社区，如Stack Exchange。第二个来源是开源软件仓库，如GitHub，它们收集代码数据(包括注释和文档字符串)以供使用。</p><p>与自然语言文本相比，代码以编程语言的格式呈现，对应着长距离依赖和准确的执行逻辑。最近的一项研究还推测，<strong>训练代码可能是复杂推理能力（例如 CoT 能力）的来源。此外，将推理任务格式化为代码的形式还可以帮助 LLM 生成更准确的结果。</strong></p><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><h5 id="质量过滤"><a href="#质量过滤" class="headerlink" title="质量过滤"></a>质量过滤</h5><p>为删除收集到的语料库中的低质量数据，现有的工作通常采用两种方法：（1）基于分类器的方法，和（2）基于启发式的方法。</p><p>前者通常训练一个二元分类器，<strong>将高质量数据(例如，维基百科页面)作为正实例，将样本候选数据作为负实例</strong>，并预测衡量每个数据示例质量的分数。</p><p>问题：<strong>基于分类器的方法可能会删除方言、口语和社会语言的高质量文本，从而可能导致有偏见的预训练语料库，并减少语料库的多样性</strong>。</p><p>第二种方法，BLOOM和Gopher等几项研究采用了基于启发式的方法，通过一套精心设计的规则来消除低质量的文本，这些规则可以总结如下：<br>a）基于语言的过滤。<strong>如果LLM主要用于某些语言的任务，则可以过滤其他语言的文本。</strong><br>b）基于度量的过滤。关于生成文本的<strong>评估指标</strong>，例如，<strong>困惑度，可以用来检测和删除不自然的句子。</strong><br>c）基于统计的过滤。语料库的统计特征，例如：如标点分布、字数比、句子长度等，可以用来衡量文本质量，过滤低质量数据。<br>d）基于关键词过滤。基于特定的关键词集合，可以识别和删除文本中<strong>嘈杂或无用的元素，如HTML标记、超链接、样板和冒犯性词语。</strong></p><h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><p>语料库中的重复数据会降低语言模型的多样性，这可能导致训练过程变得不稳定，从而影响模型的性能。特别地，去重可以在不同的粒度上执行，包括句子级、文档级和数据集级的去重。</p><p>a）在句子级别，应<strong>删除含有重复单词</strong>和短语的低质量句子，因为它们可能会在语言建模中引入重复的模式。<br>b）在文档层面，现有的研究大多**依靠文档之间表面特征的重叠比例(**如word和n-gram overlap)来检测和去除内容相似的重复文档。<br>c）为了避免数据集污染问题，通过从训练集中删除可能的重复文本，防止训练集和评估集之间的重叠也至关重要。</p><h5 id="隐私去除"><a href="#隐私去除" class="headerlink" title="隐私去除"></a>隐私去除</h5><p>需要从预训练语料库中删除可识别个人信息（PII）。一种直接有效的方法是采用基于规则的方法，例如关键字识别，来检测和删除 PII，例如姓名、地址和电话号码。此外，LLM 在隐私攻击下的脆弱性可能归因于预训练语料库中存在的重复 PII 数据。因此，去重也可以在一定程度上降低隐私风险。</p><h5 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h5><p>将原始文本分割成词序列，随后用作 LLM 的输入。</p><p>使用<strong>专门为预训练语料库设计的分词器</strong>可能会更加有效，特别是对于由多种领域、语言和格式组成的语料库。</p><p>最近的几个 LLM 使用<strong>SentencePiece为预训练语料库训练定制化的分词器</strong>。同时<strong>利用字节级的 <em>Byte Pair Encoding (BPE)</em> 算法来确保分词后的信息不会丢失</strong> </p><h4 id="数据对llm的影响"><a href="#数据对llm的影响" class="headerlink" title="数据对llm的影响"></a>数据对llm的影响</h4><p>（1）混合来源<br>通过对来自不同来源的混合文本数据进行预训练，LLMs可以获得广泛的知识，并可能表现出强大的泛化能力。当混合不同的数据源时，需要仔细设置预训练数据的分布，因为这也可能影响LLMs在下游任务上的性能。<br>Gopher对数据分布进行消融实验，考察混合源对下游任务的影响。<br>在LAMBADA数据集上的实验结果表明，增加图书数据的比例可以提高模型从文本中捕获长期依赖关系的能力，增加C4数据集的比例可以提高C4验证数据集的性能。然而，作为一个副作用，对某一领域的过多数据进行训练会影响LLMs在其他领域的泛化能力。<br>（2）预训练数据的数量<br>对于模型性能来说，在数据规模方面也观察到与模型规模相似的扩展法则。最近的一项研究表明，由于预训练数据不足，许多现有的LLM遭受次优训练。<br>通过广泛的实验，进一步证明了在给定的计算预算下，以相同的规模增加模型大小和数据大小可以得到计算效率更高的模型(即Chinchilla模型)。最近，LLaMA表明，在更多的数据和更长的训练时间下，较小的模型也可以获得良好的性能。<br>（3）预训练数据的质量<br>最近的研究，如T5、GLaM和Gopher，研究了数据质量对下游任务性能的影响。通过比较在过滤和未过滤的语料库上训练的模型的性能，他们得出了相同的结论，即在清洗过的数据上预训练LLMs可以提高性能。更具体地说，数据的重复可能会导致“双下降现象”（指性能最初恶化，随后得到改善），甚至可能会使训练过程不稳定。</p><h3 id="4-2架构"><a href="#4-2架构" class="headerlink" title="4.2架构"></a>4.2架构</h3><h4 id="主流架构"><a href="#主流架构" class="headerlink" title="主流架构"></a>主流架构</h4><p>现有 LLM 的主流架构可以大致分为三种类型，即编码器-解码器、因果解码器和前缀解码器。</p><p><strong>编码器-解码器架构</strong></p><p>传统 Transformer 模型是建立在编码器-解码器架构上，<strong>由两个 Transformer 块分别作为编码器和解码器</strong>。编码器采用堆叠的多头自注意层对输入序列进行编码以生成其潜在表示，而解码器对这些表示进行交叉注意并自回归地生成目标序列。</p><p>目前，只有少数LLM 是基于编码器-解码器架构构建的，例如 Flan-T5。</p><p><strong>因果解码器架构</strong></p><p>因果解码器架构采用单向注意力掩码，以确保每个输入 token 只能关注过去的 token 和它本身。输入和输出 token 通过解码器以相同的方式进行处理。</p><p>作为这种架构的代表性语言模型，GPT 系列模型是基于因果解码器架构开发的。</p><p>到目前为止，因果解码器已被各种现有LLMs广泛采用作为LLMs的架构，如OPT、BLOOM和Gopher。</p><p><strong>前缀解码器架构</strong></p><p>前缀解码器架构（也称非因果解码器架构）修正了因果解码器的掩码机制，使其能够对前缀 token 执行双向注意力，并仅对生成的 token 执行单向注意力。</p><p>前缀解码器可以双向编码前缀序列并自回归地逐个预测输出 token，其中在编码和解码过程中共享相同的参数。</p><p>基于前缀解码器架构的现有代表性 LLM 包括 GLM-130B和 U-PaLM。</p><p>对于这三种类型的架构，我们还可以考虑通过混合专家(MoE)缩放来扩展它们，其中每个输入的神经网络权重子集被稀疏激活，例如Switch Transformer和GLaM。研究表明，通过增加专家数量或总参数大小，可以观察到实质性的性能改进。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231120183205440.png" alt="image-20231120183205440" style="zoom:80%;"><h4 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h4><p>自 Transformer推出以来，已经提出了各种改进方法来提高其训练稳定性、性能和计算效率。在这部分中，我们将讨论Transformer 的四个主要部分的相应配置，包括标准化、位置编码、激活函数、注意力和偏置。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231121162112958.png" alt="image-20231121162112958" style="zoom:80%;"><h5 id="标准化（归一化）"><a href="#标准化（归一化）" class="headerlink" title="标准化（归一化）"></a>标准化（归一化）</h5><p>训练不稳定是预训练 LLM 的一个难题。为了缓解这个问题，<strong>层标准化 (Layer Norm, LN) 被广泛应用于Transformer 架构中</strong>。</p><p>Sandwich-LN在pre-LN的基础上，在剩余连接之前增加了额外的LN，以避免值爆炸。然而，研究发现，<strong>Sandwich-LN有时不能稳定训练LLMs，可能导致训练的崩溃。</strong><br>最近，人们提出了几种先进的规范化技术来替代LN。在Gopher和Chinchilla中，由于RMS Norm在训练速度和性能上的优势，采用了RMS Norm。与LN相比，DeepNorm在训练稳定性方面表现出了更好的能力，和后标准化一起被 GLM-130B 采用。</p><p>此外，<strong>在嵌入层之后增加一个LN也可以稳定LLMs的训练。然而，它往往会导致显著的性能下降，在最近的几个LLMs中已经被移除。</strong></p><h5 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h5><p>为了获得良好的性能，在前馈网络中也需要设置合适的激活函数。在现有的 LLM 中，广泛使用 GeLU 激活函数。</p><p>在现有LLMs中，GeLU激活被广泛使用。此外，在最新的LLMs(如PaLM和LaMDA)中，也使用了GLU激活的变体，特别是SwiGLU和GeGLU变体，在实践中往往取得更好的性能。然而，与GeLU相比，它们在前馈网络中需要额外的参数(约50%)。</p><h5 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h5><p>由于 Transformer 中的自注意模块具有置换不变性，因此需要使用位置编码来注入绝对或相对位置信息以建模序列。在经典的 Transformer 中有两种绝对位置编码的变体，即正弦函数和学习的位置编码，后者通常在 LLM 中使用。</p><p>不同于绝对位置编码，相对位置编码根据键和查询之间的偏移量生成嵌入，因此它可以在比训练期间看到的序列更长的序列上表现良好，即外推。ALiBi使用基于键和查询之间距离的惩罚来偏差注意力得分。实证结果表明，与其他位置嵌入相比，该方法具有更好的零样本泛化和更强的外推能力。此外，通过基于绝对位置设置特定的旋转矩阵，RoPE中键和查询之间的分数可以通过相对位置信息计算出来，这对长序列建模很有用。因此，RoPE在一些最新的LLMs中被广泛采用。</p><h5 id="注意力机制和偏置"><a href="#注意力机制和偏置" class="headerlink" title="注意力机制和偏置"></a>注意力机制和偏置</h5><p>除了原始 Transformer 中的全自注意力机制，GPT-3 采用了更低计算复杂度的稀疏注意力机制，即分解注意力。为了有效且高效地建模更长的序列，研究者们尝试引入特殊的注意力模式或考虑显存访问（即 FlashAttention）。</p><p>此外，与原始 Transformer一样，大多数 LLM 在每个线性层和层标准化中保留了偏置</p><h4 id="预训练任务"><a href="#预训练任务" class="headerlink" title="预训练任务"></a>预训练任务</h4><p>对于训练 LLM，有两个常用的预训练任务，即语言建模和去噪自编码。</p><h6 id="语言建模"><a href="#语言建模" class="headerlink" title="语言建模"></a><strong>语言建模</strong></h6><p>Language Modeling(LM) 语言建模任务(LM)是预训练Decoder-only的LLMs最常用的目标，例如GPT3和PaLM。给定一个token 序列 x = *{x1, . . . , xn}*，LM 任务旨在基于序列中前面的 token x&lt;i，自回归地预测目标 token <em>xi</em>。通常的训练目标是最大化以下似然函数：</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231121180748353.png" alt="image-20231121180748353" style="zoom:80%;"><p>由于大多数语言任务可以转换为基于输入的预测问题来解决，因此这些仅包含解码器的 LLM 可能具有优势，可以隐式地学习如何以统一的 LM 方式完成这些任务。一些研究还表明，仅包含解码器的 LLM 可以通过自回归地预测下一个token 而自然地迁移到某些任务中，而无需微调。</p><p>LM的一个重要变体是前缀语言建模任务，它是为预训练具有前缀解码器架构的模型设计的。在计算前缀语言模型的损失时，将不使用随机选择的前缀内的 token。由于模型预训练涉及的序列中 token 较少，因此在使用相同数量的预训练 token 时，前缀语言模型的性能往往略低于传统语言模型任务 </p><h6 id="去噪自编码"><a href="#去噪自编码" class="headerlink" title="去噪自编码"></a><strong>去噪自编码</strong></h6><img src="/2024/04/24/a-survey-of-large-language-models/image-20231121180955197.png" alt="image-20231121180955197" style="zoom:80%;"><p>通过使用语言模型目标进行预训练，因果解码器架构似乎可以实现更优越的零样本和小样本泛化能力。在没有进行多任务微调的情况下，因果解码器比其他架构具有更好的零样本性能。通过扩展模型大小、数据集大小和总计算量，可以大幅提高因果解码器的性能 </p><h3 id="4-3模型训练"><a href="#4-3模型训练" class="headerlink" title="4.3模型训练"></a>4.3模型训练</h3><h4 id="优化设置"><a href="#优化设置" class="headerlink" title="优化设置"></a>优化设置</h4><h5 id="批量训练Batch-Training"><a href="#批量训练Batch-Training" class="headerlink" title="批量训练Batch Training"></a>批量训练Batch Training</h5><p>对于语言模型的预训练，现有的研究通常将<strong>批量大小（batch size）</strong>设置为较大的数字（如 2,048 个例子或 400 万个 token），以提高训练的稳定性和吞吐量。像 GPT-3 和 PaLM 这样的LLM 引入了一种新的策略，即<strong>在训练过程中动态增加批量大小，最终达到百万级别</strong>。具体而言，GPT-3 的批量大小从 3.2万逐渐增加到 320 万个 token。实证结果表明，动态调整批量大小的策略可以有效地稳定 LLM 的训练过程。</p><h5 id="学习率Learning-Rate"><a href="#学习率Learning-Rate" class="headerlink" title="学习率Learning Rate"></a>学习率Learning Rate</h5><p>现有的LLMs通常在预训练期间采用类似的预热（warm-up）和衰减（decay）策略的学习率调度计划。具体地说，在最初的0.1%到0.5%的训练步骤中，采用线性预热策略linear warm-up schedule，逐步将学习率提高到最大值，范围约为5 × 10^−5到1 × 10^−4(例如:GPT-3为6 × 10^−5)。然后在后续步骤中采用余弦衰减策略，逐渐将学习率降低到其最大值的10%左右，直到训练损失收敛。</p><h5 id="优化器Optimizer"><a href="#优化器Optimizer" class="headerlink" title="优化器Optimizer"></a>优化器Optimizer</h5><p>Adam优化器和AdamW优化器被广泛用于训练LLMs(例如GPT3)，它们基于一阶梯度优化的低阶矩的自适应估计。通常，它的超参数设置如下：<em>β</em>1 = 0*.<em>9，</em>β<em>2 = 0</em>.<em>95 和 <em>ϵ</em> = 10</em>−*8。</p><p>同时，Adafactor优化器也被用于训练LLMs(例如PaLM和T5)，这是Adam优化器的一个变体，专门用于在训练过程中节省GPU。</p><h5 id="稳定训练Stabilizing-the-Training"><a href="#稳定训练Stabilizing-the-Training" class="headerlink" title="稳定训练Stabilizing the Training"></a>稳定训练Stabilizing the Training</h5><p>在LLMs预训练过程中，往往存在训练不稳定性问题，可能导致模型崩溃。为了解决这个问题，会广泛使用权重衰减（weight decay）和梯度裁剪（gradient clipping）。通常将梯度裁剪的阈值设置为 1*.<em>0，将权重衰减率设置为 0</em>.*1。<br>然而，随着LLMs规模的扩大，也更容易出现训练损失尖峰，导致训练不稳定。为了缓解这个问题，PaLM和OPT使用了一种简单的策略，即从发生突增之前的一个检查点重新开始训练过程，并跳过可能导致问题的数据。此外，GLM发现嵌入层的异常梯度通常会导致突增，并提出缩小嵌入层梯度以缓解这个问题。</p><h4 id="可扩展的训练技术"><a href="#可扩展的训练技术" class="headerlink" title="可扩展的训练技术"></a>可扩展的训练技术</h4><p>扩展训练需要解决两个主要的技术问题是提高训练吞吐量以及将更大的模型加载到显存中。现有工作中有几种广泛使用的方法来解决上述两个挑战，即 3D 并行、ZeRO 和混合精度训练。</p><h5 id="3D并行"><a href="#3D并行" class="headerlink" title="3D并行"></a>3D并行</h5><p>3D并行实际上是三种常用的并行训练技术的组合，即数据并行、流水线并行和张量并行。</p><p>【数据并行】<br>是提高训练吞吐量的最基本方法之一。它复制模型参数和优化器状态到多个GPU上，然后将整个训练语料库分配到这些GPU。这样，每个GPU只需要处理为其分配的数据，并执行前向和后向传播以获得梯度。将进一步聚合不同GPU上计算的梯度以获得整个批次的梯度，以更新所有GPU中的模型。<br>通过这种方式，由于梯度的计算是在不同的 GPU 上独立执行的，数据并行机制是高度可扩展的，从而能够增加 GPU 的数量以提高训练吞吐量的方式。此外，这种技术在实现中很简单，大多数现有的流行的深度学习库已经实现了数据并行性，例如 TensorFlow 和 PyTorch。<br>【流水线并行】<br>流水线并行旨在将 LLM 的不同层分布在多个 GPU 中。特别是，在 Transformer 模型的情况下，流水线并行将连续的层加载到同一个 GPU 上，以降低在 GPU 之间传输计算的隐藏状态或梯度的成本。<br>为了减少流水线并行中的这些气泡（bubble overhead），GPipe和PipeDream提出了填充多批次数据和异步梯度更新以提高流水线效率的技术。<br>【张量并行】<br>张量并行也是一种常用的技术，旨在分解LLM进行多gpu加载。与流水线并行不同，张量并行侧重于分解 LLM 的张量（参数矩阵）。<br>对于LLM中的矩阵乘法操作Y = XA，参数矩阵A可以按列分解为A1和A2，那么该操作可以表示为Y=[XA1, XA2]。通过在不同的GPU上放置矩阵A1和A2，矩阵乘法操作将在两个GPU上并行调用，最终结果可以通过跨GPU通信组合两个GPU的输出来获得。<br>目前，张量并行已在几个开源库中得到支持，例如Megatron-LM，并且可以扩展到高维张量。此外，Colossal-AI也实现了高维张量的张量并行，并提出了序列并行，特别是对于序列数据，可以进一步分解Transformer模型的注意力操作。</p><h5 id="ZeRO"><a href="#ZeRO" class="headerlink" title="ZeRO"></a>ZeRO</h5><p>DeepSpeed库提出的ZeRO技术侧重于数据并行中的内存冗余问题。<br>如前所述，数据并行要求每个GPU存储LLM的相同副本，包括模型参数、模型梯度和优化器参数。然而，并非所有上述数据都需要在每个GPU上保留，这会导致内存冗余问题。<br>为了解决这个问题，ZeRO 技术旨在在每个GPU上只保留一小部分数据，而在需要时可以从其他GPU中检索其余数据。<br>具体来说，ZeRO 提供了三个解决方案，具体取决于数据的三部分如何存储，即优化器状态分区、梯度分区和参数分区。实证结果表明，前两个解决方案不会增加通信开销，第三个解决方案增加了大约 50% 的通信开销，但节省了与 GPU 数量成比例的内存。<br>PyTorch 实现了与 ZeRO 类似的技术，称为 FSDP。</p><h5 id="混合精度训练"><a href="#混合精度训练" class="headerlink" title="混合精度训练"></a>混合精度训练</h5><p>在以前的PLM(例如，BERT)中，32位浮点数，也称为FP32，主要用于预训练。近年来，为了预训练非常大的语言模型，一些研究已经开始利用16位浮点数(FP16)，这减少了内存使用和通信开销。<br>然而，现有工作发现 FP16 可能会导致计算精度损失，这会影响最终的模型性能。为了缓解这种情况，使用了一种称为Brain Floating Point (BF16) 的替代方案进行训练，它分配比 FP16 更多的指数位和更少的重要位。对于预训练，BF16 在表示精度上通常比 FP16 表现更好。</p><h5 id="总体训练建议"><a href="#总体训练建议" class="headerlink" title="总体训练建议"></a>总体训练建议</h5><p>在实践中，上述训练技术，尤其是 3D 并行，通常用于提高训练吞吐量和大型模型加载。例如，研究人员结合了 8 路数据并行、4 路张量并行和 12 路流水线并行，可以在 384张A100 GPU 上训练 BLOOM。<br>目前，DeepSpeed、Colossal-AI和Alpa等开源库可以很好地支持三种并行训练方法。为了减少内存冗余，ZeRO、FSDP 和激活重计算技术也可用于训练 LLMs，这些已经集成到 DeepSpeed、PyTorch 和 Megatron-LM 中。<br>此外，还可以利用BF16等混合精度训练技术来提高训练效率，减少GPU内存使用，尽管需要硬件(如A100 GPU)必要的支持。<br>预测模型性能和检测异常问题会非常有用，GPT-4 最近引入了一种新的机制，叫做predictable scaling，建立在深度学习堆栈上，能够使用更小的模型预测大型模型，这对于开发 LLM 可能非常有用。<br>除了上述训练策略外，提高使用LLMs的推理速度也很重要。通常，量化技术在推理阶段被广泛用于降低LLMs的时间和空间成本。<br>对于模型量化，一种流行的选择是INT8-量化。此外，一些研究工作试图开发更积极的INT4量化方法。在这些开源LLMs中，BLOOM、GPT-J和GLM发布了相应的量化模型副本。</p><h2 id="5-适配微调"><a href="#5-适配微调" class="headerlink" title="5.适配微调"></a>5.适配微调</h2><p>我们主要介绍两种适配预训练LLMs的方法，即指令微调（Instruction tuning）和对齐微调（Alignment tuning）。前一种方法主要旨在增强（或解锁）LLM 的能力，而后一种方法旨在将 LLM 的行为与人类值或偏好对齐。此外，我们还将讨论快速模型适应的Efficient tuning。</p><h3 id="5-1指令微调"><a href="#5-1指令微调" class="headerlink" title="5.1指令微调"></a>5.1指令微调</h3><p>本质上，<strong>指令调优是在自然语言形式的格式化实例集合上微调预训练的LLMs</strong>的方法，这与监督微调和多任务提示训练高度相关。</p><p>需要收集或构建指令格式（instruction-formatted）的实例。然后，我们使用这种格式的实例以有监督的方式微调LLM（例如使用seq2seq的损失进行训练）。指令微调后，LLM 可以展现出泛化到未见过任务的卓越能力。</p><h4 id="格式化实例"><a href="#格式化实例" class="headerlink" title="格式化实例"></a>格式化实例</h4><p>指令格式的实例由任务描述（称为instruction）、输入输出对(input-output pair)和少量演示(demonstration)（可选）组成。</p><p>通过收集来自不同领域（例如文本摘要、文本分类和翻译）的实例来创建有监督的多任务训练数据集。</p><p>具体来说，使用人类撰写的任务描述来增广带标注的数据集，这些描述通过解释任务目标来指导LLM 理解任务。例如，在图 5（b）中，每个问答任务的实例都添加了一个任务描述“请回答下列问题”。<strong>在指令微调之后，LLM 可以通过遵循任务描述很好地泛化到其他未见过的任务上 [28, 62, 64]。特别地，指令被证明是影响 LLM 任务泛化能力的关键因素</strong>。</p><p>关键因素：</p><p>增加指令：大量研究已经证明扩大任务数量可以极大地提高 LLM 的泛化能力。但任务数量达到一定水平时，模型性能的提升变得微不足道。将某些任务的实例数量进一步增加（例如数百个）可能会潜在地导致过拟合并影响模型性能</p><p>设计格式：指令的格式设计也是影响 LLM 泛化性能的一个重要因素。通常来说，我们可以向现有数据集的输入-输出对添加任务描述和可选的示例，其中任务描述是 LLM理解任务的最关键部分。<strong>将其他部分（例如避免事项、原因和建议）添加到指令中对 LLM 的性能提升十分轻微，甚至会产生不利的影响</strong></p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204162206898.png" alt="image-20231204162206898"></p><h5 id="格式化任务数据集"><a href="#格式化任务数据集" class="headerlink" title="格式化任务数据集"></a>格式化任务数据集</h5><p>格式化任务数据集。在提出指令调优之前，一些早期的研究[266,273,274]从不同的任务范围（如文本摘要、文本分类和翻译）中收集实例，以创建有监督的多任务训练数据集。作为指令调优实例的主要来源，使用自然语言任务描述将这些多任务训练数据集格式化非常方便。具体来说，最近的工作[28,61,62,79]用<strong>人工编写的任务描述来增强已标记的数据集，它通过解释任务目标来指示llm来理解任务</strong>。例如，在图9(a)中，为问答任务中的每个示例添加了一个任务描述“请回答这个问题”。在指令调优之后，llm可以通过遵循其任务描述[28,62,64]来很好地推广到其他不可见的任务。特别是，已经证明了指令是LLMs [62]任务泛化能力的关键因素：通过在标记的数据集上对模型进行微调，去掉任务描述，它会导致模型性能的急剧下降。为了更好地为inst生成带有标记的实例</p><h5 id="格式化人类需求"><a href="#格式化人类需求" class="headerlink" title="格式化人类需求"></a>格式化人类需求</h5><p>尽管大量的训练实例已经通过添加指令进行格式化，但它们<strong>主要来自公共的 NLP 数据集</strong>，任务描述缺乏多样性或与人类真实需求不匹配。为了解决这个问题， InstructGPT建议<strong>采用真实用户提交给 OpenAI API 的 查询作为任务描述</strong>。用户查询以自然语言表示，很适合引导出 LLM 遵循指令的能力。此外，为了丰富任务的多样性，<strong>标注者还要为真实生活中的任务编写指令，包括开放式生成、开放式问答、头脑风暴和聊天等。然后让另一组标注人员直接按照将这些指令作为输出进行回答</strong>。最后，<strong>将指令（即采集的用户查询）和期望的输出（即人工编写的答案）配对作为一 个训练实例。</strong></p><p>InstructGPT 还将这些以自然语言格式化的真实世界任务用于对齐微调（在第 5.2 节中讨论）。</p><p><strong>进一步地，GPT-4 [45] 还设计了潜在高风险的指令，并监督微调模型拒绝这些指令以确保安全。</strong></p><h5 id="格式化合成数据。"><a href="#格式化合成数据。" class="headerlink" title="格式化合成数据。"></a>格式化合成数据。</h5><p>为了减少人工注释或人工收集的负担，人们提出了几种半自动化的方法[129]来构建实例，通过将现有的实例输入到llm中，以合成不同的任务描述和实例。如图9(c)所示，自指导方法只需要大约100个实例作为初始任务池。然后，<strong>他们从池中随机选择几个实例作为演示，并提示一个LLM生成新的指令和相应的输入-输出对。在进行质量和多样性过滤之后，新生成的实例将被添加到任务池中。因此，该合成方法是生成llm的大规模指令数据的一种有效而经济的方法。</strong></p><p>总的来说：</p><p>指令多样性似乎比实例数量更重要，因为表现良好的 InstructGPT [61] 和 Alpaca [220] 使用的指令（或实例）比 Flan 系列的 LLM [62, 64] 数量更少但更加多样化。</p><p>此外，邀请标注者构建人类真实需求的任务比使用特定数据集的任务更有用。</p><h4 id="指令微调策略"><a href="#指令微调策略" class="headerlink" title="指令微调策略"></a>指令微调策略</h4><p>与预训练不同，因为只需要使用较<strong>少数量的实例</strong>进行训练，指令微调通常更加高效。<strong>指令微调可以被视为一个有监督的训练过程</strong>，其优化过程与预训练有一些不同，比如训练目标函数（如序列到序列的损失）和优化参数设置（如更小的批量大小和学习率）。</p><p><strong>平衡数据分布：</strong>由于指令微调涉及多种任务的混合，因此在微调过程中平衡不同任务的比例非常重要。一种广泛使用的方法是实例比例混合策略，即将所有数据集合并，然后从混合数据集中按比例采样每种实例。此外，根据最近的研究发现，提高高质量数据集（例如 FLAN和 P3）的采样比例通常可以带来性能提升。同时，在指令微调期间通常会设置一个最大容量，以限制数据集中可以包含的最大实例数，这是为了防止较大的数据集挤占整个采样集合。在实践中，根据不同的数据集，最大容量通常设置为几千或几万个实例。</p><p><strong>结合指令微调和预训练：</strong>为了使微调过程更加有效和稳定， OPT-IML在指令微调期间加入了预训练数据，这可以看作是对模型的正则化（regularization）。此外，一些研究并没有使用单独的两阶段训练过程（预训练和指令微调），而是尝试混合使用预训练数据（即纯文本）和指令微调数据（即指令格式数据），用多任务学习的方式从头训练模型。具 体而言，GLM-130B和 Galactica将指令格式数据集作为预训练语料库的一小部分来预训练 LLM，这有可能同时获得预训练和指令微调的优势。</p><h3 id="5-2对齐微调"><a href="#5-2对齐微调" class="headerlink" title="5.2对齐微调"></a>5.2对齐微调</h3><p>LLM 在多个自然语言处理任务上展示出了惊人的能力，但是, 这些模型有时可能表现出预期之外的行为，<strong>例如编造虚假信息、追求不准确的目标，以及产生有害的、误导性的和有偏见的表达</strong>。对于 LLM 而言, <strong>模型参数的预训练使用了语言建模的目标，即用单词预测进行预训练，但这没有考虑到人类的价值观或偏好。</strong>为了避免这些预期外的行为，一些研究提出了<strong>人类对齐</strong>，使得 LLM 的行为能够符合人类期望。但是, 与原先的预训练和适配微调（例如指令微调）相比, <strong>对齐微调需要考虑的标准（例如有用性, 诚实性和无害性）十分不同</strong>。已有研究表明<strong>对齐微调可能会在某种程度上损害 LLM 的通用能力</strong>，这在相关研究中被称为<strong>对齐税</strong>。</p><p>对齐的标准：我们选取三个具有代表性的对齐标准（即有用性、诚实性、无害性）</p><p>无害性：无害性要求模型生成的语言不得是冒犯性或歧视性的。</p><h4 id="人类反馈的收集"><a href="#人类反馈的收集" class="headerlink" title="人类反馈的收集"></a>人类反馈的收集</h4><p><strong>标注人员的选择：</strong>InstructGPT通过评估标注人员与研究人员之间意图的一致性来选择标注人员。具体而言，研 究人员首先标注少量的数据，然后衡量他们自己和标注人员之间的标注一致性。选择一致性最高的标记者继续后续的标注工作。</p><p><strong>人类反馈的收集：</strong>1）基于<strong>排序</strong>的方法：引 入了 Elo 评分系统 ，通过一一比较所有候选输出结果来生成 一个偏好排序。候选输出的排序将用于调整模型更倾向的输出，从而产生更可靠和更安全的结果。 2）基于问题的方法：通过回答研究人员设计的特定问题，标注人员可以提供更详细的反馈，这些问题能够覆盖不同的对齐标准以及其他对 LLM 的约束条件。特别地，在 WebGPT中，为了帮助模型从检索到的文档中过滤和利 用相关信息，标注人员需要回答关于检索到的文档对于回答给定输入是否有帮助的选择题。 3）基于规则的方法：Sparrow不仅选择了标注人员挑选的最佳回复，<strong>还设计了一系列规则来测试模型生成的回复是否符合有用、正确和 无害的对齐标准</strong>。</p><p>通过这种方式，可以获得两种人类反馈数据：（1）通过成对比较模型生成的输出的质量来获得回复偏好反馈，以及（2）通过收集来自人类标注者的评估（即，指示生成的输出在多大程度上违反了规则的分数）来获得规则违反反馈。</p><p>GPT-4 利用一组（基于 GPT-4 本身的）<strong>零样本分类器作为基于规则的奖励模型，可以自动地确定模型生成的输出是否违反了一组人类编写的规则。</strong></p><h4 id="基于人类反馈的强化学习"><a href="#基于人类反馈的强化学习" class="headerlink" title="基于人类反馈的强化学习"></a>基于人类反馈的强化学习</h4><p>为了使 LLM 与人类价值观保持一致，人们提出了基于人类反馈的强化学习（ <em>Reinforcement Learning from Human Feedback</em>， RLHF），使用收集到的人类反馈数据对 LLM 进行微调，有助于改进对齐的指标。RLHF 采用强化学习（RL）算法（例如，近端策略优化（Proximal Policy Optimization, PPO））通过学习奖励模型使 LLM 适配人类反馈。</p><p><strong>基于人类反馈的强化学习系统：</strong> RLHF 系统主要包括三个关键组件：要对齐的 <strong>PLM</strong>、从人类反馈中学习的<strong>奖励模型</strong>，以 及训练 LM 的 <strong>RL 算法</strong>。具体来说，PLM 通常是一个生成模 型，它使用现有的 PLM 参数进行初始化。例如，OpenAI 在其 第一个主流的 RLHF 模型 InstructGPT [61] 中使用 1750 亿 参数量的 GPT-3。此外，<strong>奖励模型（RM）</strong> 提供（学习得到的）指导信号，这些信号反映了人类对 LM 生成的文本的偏好，通常以标量值的形式表示。奖励模型通 常具有两种形式：经过微调的 LM 或使用人类偏好数据重新 训练的 LM。</p><p><strong>基于人类反馈的强化学习的关键步骤</strong>：下图说明了 RLHF 的 整个三步过程，具体如下所述。</p><p><strong>1） 监督微调：</strong>为了使 LM 具有初步执行所需行为的能力， 通常需要收集一个包含输入提示（指令）和所需输出的有监督数据集，以对 LM 进行微调。<strong>这些提示和输出可以在确保任务多样性的情况下由人工标注人员针对某些特定任务编写</strong>。例 如，InstructGPT 要求人工标注者编写提示（例如，“列出五个关于我如何重拾对职业热情的想法”）和一些生成式任 务（如开放域问答、头脑风暴、聊天和重写）的期望输出。</p><p>请注意，在特定设置或场景中，第一步是可选的。</p><p><strong>2）训练奖励模型：</strong>第二步是使用人类反馈的数据<strong>训练RM。</strong> 具体来说，我们向 LM 中输入采样的提示（来自监督数据集 或人类生成的提示），以生成一定数量的输出文本，然后邀请 人工标注员为这些输入-输出对标注偏好。标注过程可以以多种形式进行，常见的做法是对生成的候选文本进行排序标注， 这样可以减少因标注者不同带来的差异。最后，训练 RM 预测人类偏好的输出。<strong>在 InstructGPT 中，标注员将模型生成 的输出从最好到最差进行排名，然后训练 RM（即 60 亿参数 量的 GPT-3）来预测排名。</strong></p><p><strong>3）强化学习微调：</strong>在这一步骤中，LM 的对齐微调可以被 形式化为 RL 问题。在这种情况中，RL 问题的策略（policy） 由 PLM 给出（将提示作为输入并返回输出文本），行动空间 （action space）是 LM 的词表，状态（state）是目前生成的 token 序列，奖励（reward）则由 RM 提供。为了避免 LM 显著偏离初始（微调前）的模型，通常在奖励函数中纳入一项 惩罚项。例如，InstructGPT 在使用 PPO 算法对抗 RM 来 优化 LM 时，<strong>对于每个输入提示，InstructGPT 计算当前 LM 和初始 LM 生成的结果之间的 KL 散度作为惩罚项</strong>。值得注 意的是，可以通过多次迭代第二步和最后一步来更好地对齐LLM。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204145938232.png" alt="image-20231204145938232" style="zoom:67%;"><h3 id="5-3参数高效微调方法"><a href="#5-3参数高效微调方法" class="headerlink" title="5.3参数高效微调方法"></a>5.3参数高效微调方法</h3><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204150735410.png" alt="image-20231204150735410"></p><p>参数高效微调（parameter-efficient fine-tuning）是一个重要的课题，旨在减少可训练参数的数量，同时尽可能保持良好的性能</p><h4 id="Adapter-Tuning"><a href="#Adapter-Tuning" class="headerlink" title="Adapter Tuning"></a>Adapter Tuning</h4><p>Adapter tuning将小型神经网络模块（称为适配器）融入Transformer模型。为了实现适配器模块，提出了一种bottleneck架构，该架构首先将原始特征向量压缩到较小的维度（然后进行非线性变换），然后将其恢复到原始维度。<br>Adapter模块将集成到每个Transformer层中，通常在Transformer层的两个核心部分（即注意力层和前馈层）中的每一个之后使用串行插入。作为替代方案，并行Adapter也可以用在Transformer层中，其中它相应地将两个Adapter模块与注意力层和前馈层并行放置。<br>在微调过程中，Adapter模块将根据特定的任务目标进行优化，而原始语言模型的参数在此过程中被冻结。</p><h4 id="Prefix-Tuning"><a href="#Prefix-Tuning" class="headerlink" title="Prefix Tuning"></a>Prefix Tuning</h4><p>前缀调优为语言模型中的每个Transformer层预先排列一系列前缀，这些前缀是一组可训练的连续向量。这些前缀向量是特定于任务的，可以被视为虚拟token embedding。<br>为了优化前缀向量，已经提出了一种重参数化技巧，通过学习一个MLP函数将一个较小的矩阵映射到前缀的参数矩阵，而不是直接优化前缀。已经证明，这个技巧对稳定训练是有用的。优化后，映射函数将被丢弃，只保留导出的前缀向量，以提高特定任务的性能。<br>由于只训练前缀参数，因此可以实现参数高效的模型优化。与前缀调优类似，p-tuning v2将layer-wise的prompt向量融合到Transformer架构中，专门用于自然语言理解，该架构还利用多任务学习来联合优化共享prompt。</p><h4 id="Prompt-Tuning"><a href="#Prompt-Tuning" class="headerlink" title="Prompt Tuning"></a>Prompt Tuning</h4><p>与prefix tuning不同，prompt tuning主要侧重于在输入层融入可训练的提示向量。<br>根据离散提示方法，它通过包含一组soft prompt tokens（以自由形式或前缀形式）来增强输入文本，然后采用提示增强输入来解决特定的下游任务。P-tuning提出了一种结合context、prompt和target tokens的自由形式，可以应用于自然语言理解和生成的架构。他们通过双向LSTM进一步学习soft prompt tokens的表示。另一种代表性的方法名为prompt tuning，直接在输入前加前缀提示。在训练过程中，根据特定任务的监督，只学习prompt embedding。<br>然而，由于该方法在输入层仅包括少量可训练参数，已经发现其性能在很大程度上取决于底层语言模型的模型能力。<br>这里的Prompt Tuning专门指的只在输入层包含prompt tokens的方法。</p><p><strong>Low-Rank Adaptation（LoRA）</strong><br>LoRA对每个密集层的更新矩阵施加了低秩约束，以减少适配下游任务的可训练参数。<br>考虑优化参数矩阵W的情况。更新过程可以用一般形式写成：W← W+∆W。LoRA的基本思想是冻结原始矩阵W∈Rm×n，同时通过低秩分解矩阵逼近参数更新∆W，即∆W=A·B^T，其中A∈Rm×k和B∈Rn×k是任务适配的可训练参数，r &lt;&lt; min(m，n)是降低的秩。<br>LoRA的主要优点是它可以在很大程度上节省内存和存储使用（例如，VRAM）。此外，只能保留单个大模型副本，同时保留许多特定于任务的低秩分解矩阵，以适应不同的下游任务。<br>此外，一些研究还讨论了如何以更原则化的方法设置秩，例如，基于重要性分数的分配和无搜索的最优秩选择。</p><h2 id="6-模型使用"><a href="#6-模型使用" class="headerlink" title="6.模型使用"></a>6.模型使用</h2><p>经过预训练或适配微调之后，使用 LLM 的主要方法是为解决各种任务设计适当的提示策略。一种典型的提示方法是将任务描述和（或）示范（demonstration）以自然语言文本的形式表达的上下文学习（<em>in-context learning, ICL</em>）。此外，采用思维链提示（<em>chain-of-thought prompting</em>）可以通过将一系列中间推理步骤加入提示中来增强 ICL。</p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204151041209.png" alt="image-20231204151041209"></p><h3 id="上下文学习"><a href="#上下文学习" class="headerlink" title="上下文学习"></a>上下文学习</h3><p>此外，ICL 还与指令微调（在5.1中已讨论）有着密切的联系，因为它们都将任务或样例转化为自然语言的形式。然而，指令微调需要微调 LLM来增强适配，而 ICL 仅仅是以提示的方式来使用LLM。指令微调可以提高 LLM 执行目标任务的 ICL 能力，尤其是在零样本设置时（仅使用任务描述）。</p><p>ICL使用格式化的自然语言提示，包括任务描述和/或一些任务示例作为演示。基于任务演示，LLM可以在没有显式梯度更新的情况下识别并执行新任务。<br>（当ICL在GPT-3的论文中被引入时，它最初被定义为任务描述和演示示例的组合，其中任何一个组件都是可有可无的。根据这个定义，当LLM需要只使用任务描述来解决没见过的任务时，它也可以被认为是执行ICL来解决任务，而ICL能力可以通过指令调优来增强。）<br>由于ICL的性能在很大程度上依赖于示范(demonstrations)，因此在提示中正确设计演示是一个重要问题。从三个方面介绍 ICL 的示范设计，即<strong>示范选择、格式和顺序。</strong></p><p><strong>示范选择：</strong> 主要方法有两种，被称作启发式方法和基于 LLM 的方法。</p><p>【启发式方法】<br>一些研究使用基于k-NN的检索器来选择与query语义相关的示例。<br>然而，他们为每个示例单独执行选择，而不是将示例集合作为一个整体进行评估。为了解决这个问题，提出了基于多样性的选择策略，为特定任务选择最具代表性的示例集合。</p><p>【基于LLM的方法】<br>另一路工作是通过使用LLM来选择演示。例如，<strong>LLM可以用于根据添加示例后的性能增益直接测量每个示例的信息性</strong>。此外，EPR提出了一种两阶段检索方法，该方法<strong>首先用无监督方法（例如，BM25）检索类似的样本，然后使用密集检索器（用LLM标注的阳性和阴性样本训练）对它们进行排序。</strong><br>作为一种替代方法，可以将演示选择任务形式化为RL问题，其中LLM作为奖励函数，为训练策略模型提供反馈。由于LLM在文本注释方面表现良好，最近的一些研究在没有人为干预的情况下将LLM本身用作演示生成器。</p><p><strong>格式</strong><br>选择任务样本后，下一步是将它们集成并格式化为LLM的自然语言提示。一个简单的方法是用相应的输入输出对实例化预定义的模板。<br>为了构建更具信息性的模板，最近的研究考虑添加任务描述或通过思维链提示增强LLM的推理能力。<br>为了降低注释成本，提出了一种半自动化方法，即<strong>使用由人工编写的任务描述组成的种子集来指导LLM为新任务生成任务描述。</strong><br>作为两种具有代表性的方法，<strong>Auto-CoT利用带有零样本提示“Let’s think step by step”的LLM来生成中间推理步骤，而least-to-most prompting首先询问LLM以执行问题分解，然后利用LLM根据之前解决的中间答案顺序解决子问题。</strong></p><p><strong>顺序</strong><br><strong>LLM有时会受到近因偏差的影响，即他们倾向于重复接近演示结束的答案</strong>。因此，以合理的顺序安排演示（即任务示例）是很重要的。<br>早期的工作提出了几种启发式方法来快速找到一个好的顺序。例如，<strong>可以直接根据它们与嵌入空间中查询的相似性来组织演示：越相似，越接近结尾。</strong><br>此外，全局和局部熵度量可用于对不同的演示顺序进行评分。<br>为了整合更多的任务信息，最近的一些研究提出<strong>将压缩和传输任务标签所需的代码长度最小化，这受到了信息论的启发</strong>。<br>然而，这些方法需要额外的标注数据作为验证集，以评估特定演示顺序的性能。为消除这种需要，<strong>可以从LLM本身采样验证数据。</strong></p><h4 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h4><p> ICL 的能力随着模型规模的增大而增强。然而，一些研究表明，<strong>小规模的 PLM 也可以通过特别设计的训练任务表现出强大的 ICL 能力。</strong>训练任务的设计是影响 LLM 的 ICL 能力的一个重要因素。</p><p>除了训练任务之外，近期的一些研究还探索了 ICL 与预训练语料之间的关系 [260, 265, 266]；研究表明，ICL 的性能主要<strong>取决于预训练语料的来源而非规模</strong> [266]。另一项研究 [265]深入分析了训练数据分布的影响；他们发现，<strong>当训练数据可以被聚类成许多不常见的类别，而不是均匀分布时，模型会表现出 ICL 的能力。</strong></p><p><strong>LLMs怎样执行ICL</strong><br>在推理阶段，研究人员专注于基于给定的演示来分析ICL能力是如何运行的，因为不涉及显式学习或更新。他们通常从梯度下降的角度进行分析，并将ICL视为隐式微调。<br>在这个框架下，ICL过程可以解释如下：<strong>通过前向计算，LLM生成关于演示的元梯度，并通过注意力机制隐式地执行梯度下降。实验也表明，LLM中的某些注意力头能够执行与任务无关的原子操作（例如，复制和前缀匹配），这与ICL能力密切相关。</strong><br>为了进一步探索ICL的工作机制，一些研究将ICL抽象为一个算法学习过程。具体而言，LLM在预训练期间基本上通过其参数对隐式模型进行编码。通过ICL中提供的例子，LLM可以实现诸如梯度下降之类的学习算法，或者直接计算闭式解，以在前向计算期间更新这些模型。在这个解释框架下，已经表明LLM<strong>可以有效地学习简单的线性函数，甚至可以使用ICL学习一些复杂的函数，如决策树</strong>。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231206143337223.png" alt="image-20231206143337223" style="zoom:80%;"><h3 id="思维链提示"><a href="#思维链提示" class="headerlink" title="思维链提示"></a>思维链提示</h3><p>思维链（Chain-of-Thought，CoT）是一种改进的提示策略，用于提高LLM在复杂推理任务中的性能，如算术推理、常识推理和符号推理。CoT没有像ICL那样简单地用输入输出对构建提示，而是结合了中间推理步骤，这些步骤可以将最终输出引入提示。</p><p><strong>小样本思维链 Few-shot CoT</strong><br>Few-shot CoT是ICL的一种特殊情况，它通过融合CoT推理步骤，将每个演示〈input，output〉扩充为〈input，CoT，output〉。<br>【CoT prompt的设计】<br>作为一种直接的方法，<strong>研究表明，使用不同的CoT（即每个问题的多个推理路径）可以有效地提高它们的性能。</strong><br><strong>另一个直观的想法是，具有更复杂推理路径的提示更有可能引发LLM的推理能力，这可以导致生成正确答案的准确性更高。然而，这两种方法都依赖于带标注的CoT数据集。</strong><br>为了克服这一限制，Auto-CoT建议利用Zero-shot-CoT，通过专门提示LLM来生成CoT推理路径，从而消除了手动操作。为了提高性能，Auto-CoT进一步将训练集中的问题划分为不同的聚类，然后选择最接近每个聚类中心的问题，这应该很好地代表训练集中的提问。<br>尽管Few-shot CoT可以被视为ICL的一种特殊提示情况，但与ICL中的标准提示相比，演示的顺序似乎影响相对较小：在大多数任务中，重新排序演示只会导致小于2%的性能变化。<br>【增强的CoT策略】<br>除了丰富上下文信息外，CoT提示还提供了更多选项来推断给定问题的答案。现有的研究主要集中在生成多条推理路径，并试图在得出的答案中找到共识。例如，在生成CoT和最终答案时，提出了self-consistency作为一种新的解码策略。<strong>它首先生成几个推理路径，然后对所有答案进行综合</strong>（例如，通过在这些路径中投票来选择最一致的答案）。self-consistency在很大程度上提高了CoT推理的性能，甚至可以改进一些CoT提示通常比标准提示差的任务（例如，闭书问答和自然语言推理）。<br>此外，作者在[283]中将自一致性策略扩展到更通用的集成框架（扩展到提示上的集成），他们发现<strong>不同的推理路径是提高CoT推理性能的关键。</strong><br>相反，其他研究训练评分模型来测量生成的推理路径的可靠性，或者在自己生成的推理路径上继续训练LLM以提高性能。</p><p><strong>零样本思维链 Zero-shot CoT</strong><br>与Few-shot CoT不同，Zero-shot CoT在prompt中不包括人工标注的任务演示。相反，它直接生成推理步骤，然后使用生成的CoT来导出答案。<br>Zero-shot CoT最早在中[281]提出，其中LLM首先由“Let’s think step by step”提示生成推理步骤，然后由“Therefore, the answer is”提示得出最终答案。他们发现，当模型规模超过一定规模时，这种策略会大大提高性能，但对小规模模型无效，显示出显著的<strong>涌现能力模式</strong>。<br>为了在更多的任务上解锁CoT能力，Flan-T5和Flan-PaLM进一步在CoT标注上执行指令调优，并且改进了在不可见任务上的零样本性能。</p><p>（1）什么时候CoT对LLMs有用<br>由于CoT是一种涌现能力，它只对足够大的模型（例如，通常包含10B或更多的参数）有积极影响，但对小模型没有影响。<br>此外，由于CoT通过中间推理步骤增强了标准提示，因此它主要有效地改进了需要逐步推理的任务，如算术推理、常识推理和符号推理。然而，对于不依赖于复杂推理的其他任务，它可能显示出比标准提示更差的性能，例如GLUE的MNLI-m/mm、SST-2和QQP。<br>（2）为什么LLMs可以执行CoT推理<br>【CoT能力的来源】<br>关于CoT能力的来源，<strong>人们普遍假设它可以归因于对代码的训练，因为在代码上训练的模型显示出强大的推理能力</strong>。从直觉上讲，代码数据通过算法逻辑和编程流程进行了良好的组织，这可能有助于提高LLM的推理性能。然而，<strong>这一假设仍然缺乏消融实验的公开报道证据</strong>（有和没有代码训练）。<br>此外，<strong>指令调优似乎不是获得CoT能力的关键原因</strong>，因为经验表明，对非CoT数据的指令调优并不能提高保持的CoT基准的性能。<br>【prompting组件的作用】<br><strong>CoT提示和标准提示之间的主要区别是在最终答案之前加入了推理路径。</strong><br>因此，一些研究人员调查了推理路径中不同成分的影响。具体而言，最近的一项研究确定了CoT提示中的三个关键组成部分，即<strong>symbols（例如，算术推理中的数字量）、patterns（例如，数学推理中的方程）和text（即，不是符号或模式的其余tokens）</strong>。结果表明，<strong>后两个部分（即patterns和text）对模型性能至关重要，删除其中任何一个都会导致性能显著下降</strong>。然而，<strong>symbols和patterns的正确性似乎并不重要。</strong>此外，<strong>text和patterns之间存在共生关系：text帮助LLM生成有用的patterns，patterns帮助LLM理解任务并生成有助于解决问题的text。</strong>总之，CoT提示为诱导LLM的推理能力提供了一种通用而灵活的方法。也有一些初步尝试将该技术扩展到解决多模态任务和多语言任务。除了将LLM与ICL和CoT直接结合使用外，最近的一些研究还探讨了如何将LLM的能力专门化到特定任务，这被称为模型专门化。例如，[294]中的研究人员通过微调LLM生成的CoT推理路径上的小规模Flan-T5[64]，专门研究LLM的数学推理能力。模型专业化也可用于解决各种任务，如问答、代码合成和信息检索。</p><p>本文最后在一下几个方面，介绍了大语言模型(LLM)的挑战和未来方向：</p><ol><li>理论和原理：<ul><li>挑战：<ul><li>大语言模型(LLM)的运行机制目前还不是非常的明朗，例如：大模型的涌现能力出现的原因。</li><li>大语言模型(LLM)如何通过非常大且深的神经网络分配、组织和利用信息。</li><li>理解、描述和解释大语言模型(LLM)的能力或行为的正式理论和原理仍然缺失。</li></ul></li><li>未来方向：<ul><li>对于大语言模型(LLM)的涌现能力的解释和研究。</li><li>对于大语言模型(LLM)对于信息的利用、分配、组织方式进行研究。</li><li>建立和完善理解、描述和解释大语言模型(LLM)的能力或行为的理论和原理。</li></ul></li></ul></li><li>模型架构：<ul><li>挑战：<ul><li>减少标准自注意力机制所带来的时间复杂度是一个实际应用时重要的考虑因素。</li><li><code>灾难性遗忘</code>一直是神经网络的长期挑战，其对大语言模型(LLM)也有负面影响。</li></ul></li><li>未来方向：<ul><li>研究如何构建大语言模型(LLM)中更高效的<code>Transformer</code>变体十分重要，例如 GPT-3 中已经使用了<code>稀疏注意力</code>。</li><li>考虑将现有架构扩展到更具灵活性的机制或模块，以有效支持数据更新和任务专用化。</li></ul></li></ul></li><li>模型训练：<ul><li>挑战：<ul><li>预训练强大的大语言模型(LLM)需要消耗巨大的算力，并且对<code>数据质量</code>和<code>训练技巧</code>要求很高。</li></ul></li><li>未来方向：<ul><li>开发更系统、经济的预训练方法以优化大语言模型(LLM)变得尤为重要，同时考虑到模型有效性、效率优化和训练稳定性等因素。</li></ul></li></ul></li><li>模型应用：<ul><li>挑战：<ul><li>由于在实际应用中微调的成本非常高，提示已成 为使用大语言模型(LLM)的主要方法，但是提示设计时需要大量人力。</li><li>一些复杂任务（例如形式证明和数值计算）需要特定的知识或逻辑规则，这些规则可能无法用自然语言很好地表达或通过示例演示。</li></ul></li><li>未来方向：<ul><li>研究如何自动生成有用且高校的提示以解决各种任务。</li><li>开发更具信息量和灵活性的任务格式化方法以进行提示非常重要。</li></ul></li></ul></li><li>安全与对齐：<ul><li>挑战：<ul><li>大语言模型(LLM)倾向于产生幻觉， 这些文本看似合理，但可能在事实上是错误的。例如：ChatGPT 刚发布的时候存在”一本正经的胡说八道”的情况。</li><li>现有的方法避免大语言模型(LLM)产生幻觉或者生成一些有毒，有害，有偏见的文本主要是讲人工纳入训练循环 来开发良好对齐的大语言模型(LLM)，并使用人类反馈强化学习(RLHF)。但是这严重依赖专业标注者的高质量人类反馈数据，这使得它在实践中难以适当实施。</li></ul></li><li>未来方向：<ul><li>研究如何避免大语言模型(LLM)产生幻觉或者生成一些有毒，有害，有偏见的文本。</li><li>有必要改进人类反馈强化学习(RLHF)框架以减少人类标注者的工作量，并寻求更高效的、具有保证数据质量的标注方法，例如LLM可以用于辅助标注工作。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> Survey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/23/hello-world/"/>
      <url>/2024/04/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>尽量减少恶意软件的传播</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> init <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">M</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// M - 移除某节点res的收益</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMalwareSpread</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>initial<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minNode <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>graph<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>            init<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            minNode <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minNode<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// System.out.println("i:"+String.valueOf(i)+",size:"+String.valueOf(size));</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">M</span> <span class="token operator">=</span> size<span class="token punctuation">;</span>                res <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>visited<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> minNode <span class="token operator">:</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 计算删除某节点n的收益=从该点扩散到的非initial中点的长度</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> graph<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>init<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ul><li>不支持本地图片</li><li>网络图片测试如下</li></ul><p><img src="https://hexo.io/themes/screenshots/Matery@2x.jpg" alt="Matery"></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
