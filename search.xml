<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多模态信息处理</title>
      <link href="/2024/09/09/duo-mo-tai-xin-xi-chu-li/"/>
      <url>/2024/09/09/duo-mo-tai-xin-xi-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="多模态信息处理"><a href="#多模态信息处理" class="headerlink" title="多模态信息处理"></a>多模态信息处理</h1><h1 id="综述（2022）"><a href="#综述（2022）" class="headerlink" title="综述（2022）"></a>综述（2022）</h1><p>《多模态信息处理前沿综述：应用、融合和预训练》 2022</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>人工智能研究经过70多年的探索，在视觉、语音与声学、语言理解与生成等单模态人工智能领域已取得了巨大的突破。</li><li>近些年，如何让计算机拥有更接近人类的理解和处理多模态信息的能力，进而实现高鲁棒性的推理决策成为热点问题。</li><li>各种应用的涌现，对多模态信息处理技术在用户理解、内容理解和场景理解上提出了更高的要求，同时也给多模态技术提供了海量的数据和丰富的应用场景。</li><li>多模态核心技术又分为：<strong>多模态表示（Representation）、多模态融合（Fusion）、多模态转换（Translation）、多模态对齐（Alignment）和模态协同学习（Co-learning）</strong></li><li>本文从自然语言处理的视角出发，介绍多模态信息处理技术的最新进展，组织结构如下：第１节介绍NLP领域关注度较高的多模态应用和相关的数据集。多模态融合是多模态信息处理的核心问题。第２节从单模态信息的表示方法、多模态信息的融合阶段、融合模型的网络结构、未对齐模态和模态缺失情况下的多模态融合等角度介绍主流的多模态融合方法。第３节介绍多模态预训练技术，并从模型的网络结构、模型的输入、预训练目标、预训练语料和下游任务等维度对比最新提出的多模态预训练模型。第４节介绍多模态技术在工业界的应用。最后一节是总结和对未来工作的展望。</li></ul><h2 id="多模态应用"><a href="#多模态应用" class="headerlink" title="多模态应用"></a>多模态应用</h2><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/my-hexo-blog\blogs\source\_posts\多模态信息处理\image-20240909145625058.png" alt="image-20240909145625058" style="zoom: 33%;"><h3 id="多模态情感识别"><a href="#多模态情感识别" class="headerlink" title="多模态情感识别"></a>多模态情感识别</h3><ul><li>在交互场景下，多模态情感识别研究如何从<strong>人的表情和动作手势、语音音调、语言</strong>等多模态信息中理解用户细颗粒度的情感表达，进而指导人机交互策略。</li><li>其主要研究内容有：<strong>①基于多模态信息互补性和异步性的动态融合；</strong>②高噪声环境下对于<strong>模态模糊或模态缺失问题</strong>的鲁棒性融合；③客服和营销等<strong>自然交互情境</strong>下的情感识别等。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/my-hexo-blog\blogs\source\_posts\多模态信息处理\image-20240909151102370.png" alt="image-20240909151102370" style="zoom:67%;"><h3 id="视觉-语言生成"><a href="#视觉-语言生成" class="headerlink" title="视觉-语言生成"></a>视觉-语言生成</h3><ul><li>视觉（图像或视频）到语言的生成和语言到视觉（图像或视频）的生成打破了计算机视觉和自然语言处理两个领域的边界</li><li>2021年初，OpenAI推出的基于GPT-3的语言到视觉的生成模型DALL-E可以根据自然语言的描述生成逼真的图像</li></ul><h4 id="图像描述"><a href="#图像描述" class="headerlink" title="图像描述"></a>图像描述</h4><ul><li>图像描述（Image Captioning）是<strong>对给定的一幅自然图像生成一句自然语言描述的任务。</strong></li><li>2015以前：基于模板–监测图像物体、动作，填充到模板主谓宾结构</li><li>2015以后：通过从视觉图像中解析出属性、关系和结构（hierarchy）等高层语义信息，并将这些语义信息融入<strong>视觉编码和语言解码</strong>中，提高了图像描述的生成效果。</li></ul><h4 id="视频描述"><a href="#视频描述" class="headerlink" title="**视频描述"></a>**视频描述</h4><ul><li>视频描述（Video Captioning）是对给定的一段视频（通常是几十秒的短视频）生成一句准确、细致描述的任务。</li><li>包含<strong>图像、声音、时序</strong>等信息。视频描述可提取的特征更多，技术挑战也更大。</li><li>ACTIONS是首个无需人工标注、从数以亿计的网页内容中自动提炼“视频，描述”对的视频描述数据集，总共包含了163183个GIF视频。</li></ul><h4 id="视觉叙事"><a href="#视觉叙事" class="headerlink" title="视觉叙事"></a>视觉叙事</h4><ul><li>视觉叙事（Visual Story Telling）要求模型对于给定的图像序列，在深度理解图像序列的基础上<strong>生成连贯的叙事故事</strong>。</li><li>视觉叙事的输入是<strong>有时序关联的图像序列</strong>，需要模型具备<strong>根据历史视觉事件推测当前的视觉事件</strong>的能力。</li><li>对比图像描述和视频描述中的客观文字描述，视觉叙事的输出由更多评价性、会话性和抽象性语言组成。</li></ul><h3 id="视觉问答和多模态对话"><a href="#视觉问答和多模态对话" class="headerlink" title="视觉问答和多模态对话"></a>视觉问答和多模态对话</h3><h4 id="视觉问答（VQA）"><a href="#视觉问答（VQA）" class="headerlink" title="视觉问答（VQA）"></a>视觉问答（VQA）</h4><ul><li>给定一幅图像和一个关于该图像的开放式自然语言问题，要求模型准确回答该问题</li><li>视觉问答是一个典型的多模态问题，需要模型具备<strong>物体定位、属性检测、事件分类、场景理解和推理及数学计算</strong>等能力。</li><li>根据图片类型不同，VQA又分为自然图像理解VQA、合成图像推理VQA和自然图像推理VQA</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/my-hexo-blog\blogs\source\_posts\多模态信息处理\image-20240909151819273.png" alt="image-20240909151819273" style="zoom:67%;"><h4 id="视觉对话"><a href="#视觉对话" class="headerlink" title="**视觉对话"></a>**视觉对话</h4><ul><li>视觉对话（Visual DIalog）是给定一幅图像（或视频等视觉内容）和一个上下文相关的问题，要求模型根据图片（或视频）内容回答该问题。</li><li>与视觉问答相比，视觉对话还要解决对话中特有的挑战，如共指（Co-references）和省略（Ellipsis）等。</li><li>视觉对话中的用户问题只与单个图像（视频）相关，且用户问题和模型回答都是文字的。</li></ul><h4 id="多模态对话"><a href="#多模态对话" class="headerlink" title="多模态对话"></a>多模态对话</h4><ul><li>多模态对话（Multi-model Dialog）关注更接近人类自然对话的多模态人机对话技术研究。它与上一节介绍视觉对话的主要差异有：<ul><li>①多模态对话给定的输入图像可能是多幅的；</li><li>② 随着对话的推进，<strong>图像是不断更新的；</strong></li><li>③用户问题和模型的回答可以是<strong>文本的、图像的或者图文结合的；</strong></li><li>④模型可能需要查询外部领域知识库才能回答用户的问题（如购物者希望看到更多与特定商品相似的商品，或者要求提供满足某些特征的商品，或者查询特定商品的属性等）；</li><li>⑤模型可能需要通过反问等对话策略澄清用户需求。</li></ul></li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/my-hexo-blog\blogs\source\_posts\多模态信息处理\image-20240909151958971.png" alt="image-20240909151958971" style="zoom:67%;"><h3 id="多模态摘要"><a href="#多模态摘要" class="headerlink" title="多模态摘要"></a>多模态摘要</h3><ul><li><p>多模态摘要是基于对多模态输入（文本、语音、图像和视频等）的理解，归纳并生成单模态或者多模态的概括性总结（摘要）任务。</p></li><li><p>根据具体任务类型，多模态摘要又可细分为<strong>视频会议摘要、教学视频摘要、多模态新闻摘要 和多模态商品摘要</strong></p></li></ul><h3 id="多模态对齐"><a href="#多模态对齐" class="headerlink" title="**多模态对齐"></a>**多模态对齐</h3><ul><li>多模态对齐研究多个模态不同颗粒度元素间的对齐关系，具体又分为显式对齐和隐式对齐。</li><li>视觉－语言跨模态的显式对齐任务研究<strong>图像和句子、图像和词、图像中的目标和句子中的短语间的</strong>对齐关系。</li><li>多模态对齐方法可直接应用于<strong>多模态检索</strong>等应用，也可作为<strong>图像描述、VQA、多模态预训练</strong>的训练语料，尤其是在缺乏大规模多模态人工标注语料的场景。</li><li>Tan等人提出了 Vokenization技术（图３），其通过给文本中的每一个词打上一幅图像的标签，实现在大规模文本语料上自动构建多模态对齐语料库。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/my-hexo-blog\blogs\source\_posts\多模态信息处理\image-20240909152259522.png" alt="image-20240909152259522" style="zoom: 33%;"><h4 id="图像短语定位"><a href="#图像短语定位" class="headerlink" title="图像短语定位"></a>图像短语定位</h4><ul><li>图像中的目标和文本中的短语对齐也被称为<strong>图像短语定位</strong>（Phrase Grounding），可用于提高图像描述、VQA、视觉导航等视觉-语言下游任务的性能。</li><li>Plummer等人发布了一个大规模的短语定位数据集Flickr30kEntities，如图4所示。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/my-hexo-blog\blogs\source\_posts\多模态信息处理\image-20240909152343325.png" alt="image-20240909152343325" style="zoom:67%;"><h4 id="视频定位"><a href="#视频定位" class="headerlink" title="**视频定位"></a>**视频定位</h4><ul><li>视频定位（Video Grounding）是多模态对齐中另一项重要且具有挑战性的任务。给定一个查询（Query），它要求模型从视频中定位出与查询语言对应的一个目标视频片段。该技术可应用<strong>于视频理解、视频检索和人机交互</strong>等场景。</li></ul><h3 id="多模态翻译"><a href="#多模态翻译" class="headerlink" title="多模态翻译"></a>多模态翻译</h3><ul><li>多模态翻译是将多模态输入（文本、图像或视频等）中的源语言文本转换为目标语言文本的过程。</li><li>Elliott等人将多模态机器翻译分解为两个子任务：<strong>文本翻译 和 基于视觉的文本表示</strong></li><li>Wu等人的研究表明，视觉特征对多模态翻译的帮助来自于正则化，视觉特征的合理选取对模型性能至关重要。</li></ul><h3 id="多模态信息抽取"><a href="#多模态信息抽取" class="headerlink" title="多模态信息抽取"></a>多模态信息抽取</h3><ul><li>命名实体识别（NER）是指识别自由文本中的具体特定意义的实体（如人名、地名和组织机构名等）。</li><li>多模态命名实体识别（ＭＮER）通过引入视觉、语音等其他模态作为文本模态的补充，识别社交媒体中高噪声短文本中的实体。</li><li>模型方面，Moon等人首次提出了融合图像和文本模态信息的通用多模态注意力模型。</li><li>Yu等人首次将 Transformer应用于多模态NER任务中，并提出了实体片段检测辅助任务，进一步消除视觉偏差，提升了模型效果</li></ul><h2 id="多模态融合"><a href="#多模态融合" class="headerlink" title="多模态融合"></a>多模态融合</h2><ul><li>多模态融合将多个单模态表征整合成为一个多模态信息表征，它是多模态信息处理的核心问题。</li><li>多模态融合的研究方向有：基于多模态互补性的全模态融合问题、模态模糊或者模态缺失下的鲁棒性融合问题、非对齐的多模态融合问题等。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/my-hexo-blog\blogs\source\_posts\多模态信息处理\image-20240909154906558.png" alt="image-20240909154906558" style="zoom: 80%;"><h3 id="根据单模态表示分类"><a href="#根据单模态表示分类" class="headerlink" title="根据单模态表示分类"></a>根据单模态表示分类</h3><ul><li>单模态的特征表示是多模态融合的基石。这一类方法重点研究如何在多模态融合之前提取更好的单模态特征表示。</li><li>以视觉－语言－音频多模态应用为例，如何从<strong>视觉内容中解析出高层语义信息</strong>以增强视觉特征表达是这一类方法的主要研究内容。</li><li>语言表示通常使用词的独热编码表示、词的上下文表示 、句子表示、句法依存关系表示、场景图表示等。</li><li>音频表示可使用基于VOVAREP提取底层声学特征表示、基于预训练模型wav2vec提取低维特征向量表示等。</li></ul><h4 id="视觉全局表示"><a href="#视觉全局表示" class="headerlink" title="视觉全局表示"></a>视觉全局表示</h4><ul><li>视觉全局表示（Global Representation）是从<strong>图像编码器的高层网络提取一个D维静态向量v</strong>表示一幅图像。</li><li>相关工作通常<strong>使用预训练的ResNet对图像编码</strong>，再提取ResNet的最后一个池化层作为视觉全局表示（ResNet152池化层输出是1*2048维向量，即D=2048）。</li><li>视觉全局表示可用来<strong>初始化多模态自动摘要模型的解码器</strong>，或作为一个<strong>特殊的字符与文本字符拼接</strong>，再用递归神经网络对拼接的字符序列编码，或通过注意力机制学习与其他模态特征的<strong>联合表示</strong>等。</li><li>由于视觉全局表示将图像信息压缩到一个静态的向量中，<strong>这可能会导致大量图像细节信息的丢失。</strong></li></ul><h4 id="视觉区域表示"><a href="#视觉区域表示" class="headerlink" title="视觉区域表示"></a>视觉区域表示</h4><ul><li>视觉区域表示（Regional Representation）是从图像编码器的高层网络中提取一组 Ｄ 维向量表示一幅图像。每个 Ｄ 维向量表示图像中特定的大小相同的区域</li><li>视觉区域表示与注意力机制相结合，通过在每一步解码过程中关注不同的图像区域可生成内容丰富的图像描述</li><li>视觉区域表示实现了图像的细颗粒度表示，但是每个特征的感受野大小和形状相同，<strong>同一个目标可能被切分到多个区域中，它无法表达视觉上完整的语义信息。</strong></li></ul><h4 id="视觉目标表示"><a href="#视觉目标表示" class="headerlink" title="视觉目标表示"></a>视觉目标表示</h4><ul><li>视觉目标表示也是用一组Ｄ 维向量表示一幅图像，但每个 Ｄ 维向量表示图像中的一个目标。</li><li>预训练Faster Ｒ-CNN 通常被用来检测目标所在的区域，再使用目标所在区域的视觉特征和边界框（Bounding-box）特征作为该视觉目标表示。</li><li>视觉目标表示通过目标定位与分类实现视觉图像的浅层语义理解，但<strong>它无法刻画图像中多个目标间的语义关系</strong></li></ul><h4 id="视觉场景图表示"><a href="#视觉场景图表示" class="headerlink" title="视觉场景图表示"></a>视觉场景图表示</h4><ul><li>视觉场景图表示（scene graph representation）是用场景图Ｇ=（V，R）表示一幅图像。</li><li>场景图中的节点V={v1, v2…vk}是图像中的目标集合，关系R={r1, r2…rk}是图像中目标和目标间的显式语义关系（如 wearing、eating）、空间位置关系（如 cover、intersect、in）和隐式语义关系的集合。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/my-hexo-blog\blogs\source\_posts\多模态信息处理\image-20240909155741554.png" alt="image-20240909155741554" style="zoom:67%;"><h3 id="根据融合阶段进行分类"><a href="#根据融合阶段进行分类" class="headerlink" title="根据融合阶段进行分类"></a>根据融合阶段进行分类</h3><ul><li>早期融合的特点是单模态表示学习简单，而多模态融合部分的模型深度大，融合策略复杂。例如，词的独热编码表示和视觉区域表示直接参与多模态融合</li><li>晚期融合的特点是单模态表示学习模型复杂，多模态融合一般采用拼接、按位乘／求平均等简单策略</li><li>在第３节介绍的多模态预训练模型中，基于单流架构（single stream）的预训练模型把融合操作放在早期阶段。</li><li>基于双流架构（two stream）的预训练模型则把融合操作放置在深层模型的中期阶段的多个层中</li></ul><h3 id="根据融合方式进行分类"><a href="#根据融合方式进行分类" class="headerlink" title="根据融合方式进行分类"></a>根据融合方式进行分类</h3><h4 id="门控融合"><a href="#门控融合" class="headerlink" title="门控融合"></a>门控融合</h4><ul><li>基于自编码和自回归的大规模预训练语言模型和在下游任务上的微调相结合是自然语言处理研究和应用的新方法</li><li>Rahman提出了一种多模态适应门（Multi-model Adaptation Gate，MAG）的网络结构将非语言特征（视觉和声学特征）与文本预训练语言模型融合，MAG与BERT结 合 （MAG-BERT）以 及MAG与XLNET结合（ＭＡＧ－ＸＬＮＥＴ）都可以有效融合三 个 模 态 信 息，并在多模态情感识别数据 集CMU-MOSI和CMU-MOSEI上获得当时最优性能。</li></ul><h4 id="注意力融合"><a href="#注意力融合" class="headerlink" title="注意力融合"></a>注意力融合</h4><ul><li>Bahdanau等人在2015年提出的注意力机制是为了让神经机器翻译模型中的<strong>解码器</strong>在每一步解码过程中，有针对性地选择源语言中<strong>“对齐”的词</strong>来指导目标语言的解码，包括全局注意力和局部注意力两种方法。</li><li>Yang等人提出了stacked attention networks（SANs），通过多层视觉注意力机制逐步过滤掉图像中的噪声区域，定位到与答案高度相关的图像区域，从而提高 ＶＱＡ 准确率。</li><li>Anderson等人提出一种“自底向上”和“自顶向下”相结合的注意力机制。具体的，基于Faster R-CNN的“自底向上”的注意力机制提取图像中的兴趣区域，“自顶向下”的注意力机制确定兴趣区域的权重。</li><li>Yu 等人提出了一种类 Transformer 结构的协同注意力机制，可实现文本中的任一词与图像中的任一区域间的完全交互。</li></ul><h4 id="Transformer融合"><a href="#Transformer融合" class="headerlink" title="Transformer融合"></a>Transformer融合</h4><ul><li>BERT凭借着 transformer强大的特征学习能力和掩码语言模型（Masked Language Model）实现双向编码，刷新了多个 NLP任务的最优性能。</li><li>基 于transformer的多模态融合又分为单流模型和双流模模型两大类。 单流模型使用一个transformer在一开始便对多模态信息进行充分的交互。双流模型则对不同的模态使用独立的transformer编码，再通过协同注意力机制实现不同模态间的融合，如图７所示。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/my-hexo-blog\blogs\source\_posts\多模态信息处理\image-20240909155859453.png" alt="image-20240909155859453" style="zoom: 80%;"><h4 id="图模型融合"><a href="#图模型融合" class="headerlink" title="图模型融合"></a>图模型融合</h4><p>图模型融合方法将不同模态数据建模为图结构，并利用图神经网络（Graph Neural Networks）等方法进行图结构的表示和学习，从而实现对多模态信息的融合和推理。Yin 等人将基于图的多模态融合编码器应用到多模态神经机器翻译模型中，把源语言中的词和图像中的物体放到了同一个图中，再堆叠多个基于图神经网络的多模态融合层（在每一层顺序执行模态内融合和模态间融合）。</p><h2 id="多模态预训练"><a href="#多模态预训练" class="headerlink" title="多模态预训练"></a>多模态预训练</h2><ul><li>通过预训练语言模型从海量无标注数据中学习通用知识，再在下游任务上用少量的标注数据进行微调，已经成为自然语言处理领域成熟的新范式。</li><li>相对于文本预训练语言模型，多模态预训练模型可以更好地对细颗粒度的多模态语义单元（词或者目标）间的相关性进行建模。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/my-hexo-blog\blogs\source\_posts\多模态信息处理\image-20240909160214538.png" alt="image-20240909160214538" style="zoom: 67%;"><ul><li><p>从表５中的１１个图像－语言跨模态预训练模型的对比，我们发现的跨模态预训练模型的特点如下</p><ul><li><p>①单流模型和双流模型均被广泛采用。</p></li><li><p>②多模态预训练模型从应用于多模态理解任务或多模态生成任务发展到可兼顾多模态理解和生成两大任务的统一模型。</p></li><li><p>③相对动辄上百 Ｇ 甚至 Ｔ 级别的单模态数据，多模态对齐数据的规模有限。</p><p>最新的多模态预训练模型可以利用互联网上的大规模非对齐的文本数据、图像数据、以及文本－图像对齐数据学习更通用的文本和视觉表示，以提高模型在视觉和语言的理解和生成能力，如 M3P和UNIMO。</p></li><li><p>④多模态预训练模型从仅应用于多模态下游任务发展到可同时应用于单模态下游任务 和 多模态下游任务。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 多模态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2024/06/15/java/"/>
      <url>/2024/06/15/java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>Java特点</strong>：面向对象（封装，继承，多态）；平台无关（基于JVM）；可靠安全（异常处理，自动内存管理，多重安全防护）；编译与解释并存-&gt;一次编译，到处运行；Java生态</p><p>Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><blockquote><p>编译型：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有C、C++、Go、Rust等等。<br>解释型：释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。<br>Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，这些字节码可以在任何安装了Java虚拟机的平台上运行，由解释器逐条将字节码解释为机器码来执行。这种方式使得Java程序具有了跨平台性，同一份Java代码可以在各种操作系统和硬件平台上运行，而不需要针对不同平台进行重新编译。</p></blockquote><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，<strong>在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</strong>。</p><p>JVM引入 <strong>JIT（Just in Time Compilation）</strong> 编译器， 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p><strong>Java和C++：</strong></p><ul><li>Java <strong>不提供指针</strong>来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有**自动内存管理垃圾回收机制(GC)**，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java <strong>只支持方法重载（</strong>操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><img src="/2024/06/15/java/image-20240615094911702.png" alt="image-20240615094911702" style="zoom:80%;"><h3 id="基本类型和包装类型"><a href="#基本类型和包装类型" class="headerlink" title="基本类型和包装类型"></a>基本类型和包装类型</h3><ul><li><strong>用途</strong>：基本类型用于定义一些<strong>常量和局部变量</strong>。方法参数/对象属性等多用包装类型。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本类型的<strong>局部变量</strong>存放在 Java 虚拟机<strong>栈</strong>中的局部变量表中，基本数据类型的<strong>成员变量</strong>（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的<strong>堆</strong>中。包装类型属于对象类型，存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， <strong>基本数据类型占用的空间往往非常小。</strong></li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code>，而<strong>成员变量基本类型有默认值</strong>且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说<strong>，<code>==</code> 比较的是对象的内存地址。</strong>所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p><strong>包装类型缓存机制：</strong>包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><ul><li><p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p></li><li><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p></li><li><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p></li><li><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p></li></ul><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><img src="/2024/06/15/java/image-20240615115307076.png" alt="image-20240615115307076"><p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：<code>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改</code>。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p><strong>抽象类</strong>：包含抽象方法的类。通过abstract关键字来创建抽象类，以及定义抽象方法。抽象类的存在就是为了被继承，所以抽象类中的抽象方法不能被private、static、final修饰，否则无法被继承。抽象类虽然不能被实例化，但是它可以有构造方法，供子类创建对象时，初始化父类成员。</p><p><strong>接口</strong>：接口是一种引用数据类型，可以看成是多个类的公共规范。定义接口需要借助interface关键字，定义方式与定义类的方式相似：</p><p><strong>共同点</strong>：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。<strong>每个抽象方法前都隐藏着public abstract修饰。</strong></li><li><strong>都可以有默认实现的方法</strong>（Java 8 开始可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li><strong>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为</strong>。抽象类主要用于代码复用，强调的是<strong>所属关系</strong>。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而<strong>抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</strong></li><li>接口中<strong>不能有</strong>静态代码块（可以有静态成员方法）、实例代码块以及构造方法；而<strong>抽象类可以有构造方法</strong>，供子类创建对象时，初始化父类成员。</li></ul><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><img src="/2024/06/15/java/shallow&amp;deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图" style="zoom:80%;"><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>线程安全性：</strong><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了<strong>同步锁</strong>或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能：</strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="String不可变"><a href="#String不可变" class="headerlink" title="String不可变"></a>String不可变</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为<strong>这个数组保存的字符串是可变的</strong>（<code>final</code> 修饰引用类型变量的情况）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且**<code>String</code> 类没有提供/暴露修改这个字符串的方法。**</li><li><code>String</code> 类被 <code>final</code> 修饰导致其<strong>不能被继承</strong>，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><p>在 Java 9 之后，<code>String</code>、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>    <span class="token comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span>    <span class="token annotation punctuation">@Stable</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><img src="/2024/06/15/java/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图" style="zoom:80%;"><p><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p><ul><li><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p></li><li><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li></ul></li></ul><p>**<code>Error</code>**：<code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型，即“参数化类型”。在方法定义时，将方法签名中的<code>形参的数据类型</code>也设置为参数（也可称之为类型参数），在调用该方法时再从外部传入一个具体的数据类型和变量。<strong>泛型的本质是为了将类型参数化</strong>， 也就是说在泛型使用过程中，数据类型被设置为一个参数，在使用时再从外部传入一个数据类型；而一旦传入了具体的数据类型后，传入变量（实参）的数据类型如果不匹配，编译器就会直接报错。这种参数化类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><ul><li>泛型提供了一种扩展能力，更符合面向对象开发的软件编程宗旨。</li><li>泛型提高了程序代码的可读性。在定义泛型阶段（类、接口、方法）或者对象实例化阶段，由于 &lt; 类型参数 &gt; 需要在代码中显式地编写，所以程序员能够快速猜测出代码所要操作的数据类型，提高了代码可读性。</li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类型参数用于类的定义中，则该类被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>     <span class="token comment">// key 这个成员变量的数据类型为 T, T 的类型由外部传入  </span>    <span class="token keyword">private</span> <span class="token class-name">T</span> key<span class="token punctuation">;</span><span class="token comment">// 泛型构造方法形参 key 的类型也为 T，T 的类型由外部传入</span>    <span class="token keyword">public</span> <span class="token class-name">Generic</span><span class="token punctuation">(</span><span class="token class-name">T</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 泛型方法 getKey 的返回值类型为 T，T 的类型由外部指定</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>泛型类中的静态方法和静态变量不可以使用泛型类所声明的类型参数</strong></p><ul><li>泛型类中的<strong>类型参数的确定是在创建泛型类对象</strong>的时候（例如 ArrayList&lt; Integer &gt;）。</li><li>而静态变量和静态方法在类加载时已经初始化，直接使用类名调用；在泛型类的类型参数未确定时，静态成员有可能被调用，因此泛型类的类型参数是不能在静态成员中使用的。</li><li>静态泛型方法中可以使用自身的方法签名中<strong>新定义的类型参数</strong>（即泛型方法），而不能使用泛型类中定义的类型参数。</li></ul><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Inter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>泛型接口中的类型参数，在该接口被继承或者被实现时确定。</strong></p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>当在一个方法签名中的返回值前面声明了一个 &lt; T &gt; 时，该方法就被声明为一个<code>泛型方法</code>。&lt; T &gt;表明该方法声明了一个类型参数 T，并且这个类型参数 T 只能在该方法中使用。当然，泛型方法中也可以使用<code>泛型类中定义的泛型参数</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token comment">// 该方法只是使用了泛型类定义的类型参数，不是泛型方法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token class-name">U</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// &lt;T&gt; 真正声明了下面的方法是一个泛型方法</span><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">testMethod1</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>泛型类中定义的类型参数和泛型方法中定义的类型参数是相互独立的，它们一点关系都没有。<strong>也就是说，泛型方法始终以自己声明的类型参数为准。</strong></p><p>为了避免混淆，如果在一个泛型类中存在泛型方法，那么两者的类型参数最好不要同名。</p><p><strong>在静态成员中不能使用泛型类定义的类型参数，但我们可以将静态成员方法定义为一个泛型方法。</strong></p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>泛型的本质是将<code>数据类型参数化</code>，它通过<strong>擦除</strong>的方式来实现，即编译器会在编译期间<code>擦除</code>代码中的所有泛型语法并相应的做出一些类型转换动作。</p><p>换而言之，<strong>泛型信息只存在于代码编译阶段</strong>，在代码编译结束后，与泛型相关的信息会被擦除掉，专业术语叫做<code>类型擦除</code>。也就是说，<strong>成功编译过后的 class 文件中不包含任何泛型信息</strong>，泛型信息不会进入到<code>运行时阶段</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">T</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 将这个泛型类反编译, 结果如下</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 默认构造器，不用管</span><span class="token keyword">private</span> <span class="token class-name">Object</span> num<span class="token punctuation">;</span><span class="token comment">// T 被替换为 Object 类型</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以发现编译器<code>擦除</code>了 Caculate 类后面的泛型标识 &lt; T &gt;，并且将 num 的数据类型替换为 Object 类型，而替换了 T 的数据类型我们称之为<code>原始数据类型</code>。</li></ul><p><strong>那么是不是所有的类型参数被擦除后都以 Object 类进行替换呢？</strong></p><ul><li>答案是否定的，大部分情况下，类型参数 T 被擦除后都会以 Object 类进行替换；而有一种情况则不是，那就是使用到了 extends 和 super 语法的<code>有界类型参数</code>（即<code>泛型通配符</code>）。</li></ul><p>在现实编码中，确实有这样的需求，希望泛型能够处理<code>某一类型范围内</code>的类型参数，比如某个泛型类和它的子类，为此 Java 引入了<code>泛型通配符</code>这个概念。</p><blockquote><ol><li><!--?--> ：被称作无限定的通配符。**代表了任何一种数据类型。**</li><li><!--? extends T--> ：被称作有上界的通配符。 **逻辑上表示类型参数的范围是 T 和 T 的子类。**</li><li><!--? super T--> ：被称作有下界的通配符。 **逻辑上表示类型参数的范围是 T 和 T 的超类。**</li></ol></blockquote><ul><li><p>Object 本身也算是一种数据类型，但却不能代表任何一种数据类型，所以 ArrayList&lt; Object &gt; 和 ArrayList<!--?-->的含义是不同的，前者类型是 Object，也就是继承树的最高父类，而后者的类型完全是未知的；ArrayList<!--?--> 是 ArrayList&lt; Object &gt; 逻辑上的父类。</p></li><li><p>ArrayList&lt; Integer &gt; 和 ArrayList&lt; Number &gt; 之间不存在继承关系。而引入上界通配符的概念后，我们便可以在逻辑上将 ArrayList&lt;? extends Number&gt; 看做是 ArrayList&lt; Integer &gt; 的父类，<strong>但实质上它们之间没有继承关系。</strong></p></li><li><p>ArrayList&lt;? super Integer&gt; 在逻辑上表示为 Integer 类以及 Integer 类的所有父类，它可以代表 ArrayList&lt; Integer&gt;、ArrayList&lt; Number &gt;、 ArrayList&lt; Object &gt;中的某一个集合，但实质上它们之间没有继承关系。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">T</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 默认构造器，不用管</span><span class="token keyword">private</span> <span class="token class-name">Number</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用到了 extends 语法的类型参数 T 被擦除后会替换为 Number 而不再是 Object。</li><li>extends 和 super 是一个<strong>限定类型参数边界的</strong>语法，extends 限定 T 只能是 Number 或者是 Number 的<strong>子类</strong>。 也就是说，在创建 Caculate 类对象的时候，尖括号 &lt;&gt; 中只能传入 Number 类或者 Number 的子类的数据类型，所以在创建 Caculate 类对象时无论传入什么数据类型，Number 都是其父类，于是可以使用 Number 类作为 T 的原始数据类型，进行类型擦除并替换。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>泛型信息被擦除了，如何保证我们在集合中只添加指定的数据类型的对象呢？</p><ul><li>其实在创建一个泛型类的对象时， Java 编译器是先检查代码中传入 &lt; T &gt; 的<strong>数据类型，并记录下来</strong>，然后再对代码进行编译，<code>编译的同时进行类型擦除</code>；如果需要对被擦除了泛型信息的对象进行操作，<strong>编译器会自动将对象进行类型转换。</strong></li></ul><blockquote><p>可以把泛型的类型安全检查机制和类型擦除想象成演唱会的验票机制：以 ArrayList&lt; Integer&gt; 泛型集合为例。</p><p>当我们在创建一个 ArrayList&lt; Integer &gt; 泛型集合的时候，ArrayList 可以看作是演唱会场馆，而&lt; T &gt;就是场馆的验票系统，Integer 是验票系统设置的门票类型；<br>当验票系统设置好为&lt; Integer &gt;后，只有持有 Integer 门票的人才可以通过验票系统，进入演唱会场馆（集合）中；若是未持有 Integer 门票的人想进场，则验票系统会发出警告（编译器报错）。<br>在通过验票系统时，门票会被收掉（类型擦除），但场馆后台（JVM）会记录下观众信息（泛型信息）。<br>进场后的观众变成了没有门票的普通人（原始数据类型）。但是，在需要查看观众的信息时（操作对象），场馆后台可以找到记录的观众信息（编译器会自动将对象进行类型转换）。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericType</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> arrayInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置验票系统   </span>        arrayInteger<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 观众进场，验票系统验票，门票会被收走（类型擦除）</span>        <span class="token class-name">Integer</span> n <span class="token operator">=</span> arrayInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取观众信息，编译器会进行强制类型转换</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>擦除 ArrayList&lt; Integer &gt; 的泛型信息后，get() 方法的返回值将返回 Object 类型，但编译器会自动插入 Integer 的强制类型转换。也就是说，编译器把 get() 方法调用翻译为两条字节码指令：</p><ul><li>对原始方法 get() 的调用，返回的是 Object 类型；</li><li>将返回的 Object 类型强制转换为 Integer 类型；</li></ul><p><strong>项目中哪里用到了泛型</strong></p><ul><li><strong>自定义接口通用返回结果</strong> <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li><li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li><li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射 (Reflection) 是 Java 的特征之一，它允许<strong>运行中的 Java 程序获取自身的信息</strong>，并且可以操作类或对象的内部属性。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p><p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。</p><p><strong>使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码），一切反射的操作都是从类对象开始</strong></p><p>反射就是把java类中的各种成分映射成一个个的Java对象</p><blockquote><p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p></blockquote><img src="/2024/06/15/java/20170513133210763" alt="img" style="zoom:80%;"><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>运行时动态获取类的信息</strong>：在编写代码时，对于类的信息是必须在编译时确定的，但在运行时，有时需要根据某些条件，动态获取某个类的信息，这时就可以使用Java中的反射机制。</li><li>动态生成对象：反射机制可以在<strong>运行时生成对象</strong>，这样就可以根据参数的不同，动态的创建不同的类的实例对象。</li><li>动态调用方法：通过反射机制可以调用类中的方法，不论这些方法是否是公共的，也不论这些方法的参数个数和类型是什么，反射机制都具有这样的能力。</li><li>动态修改属性：利用反射机制可以获取到类中的所有成员变量，并可以对其进行修改。</li><li>实现动态代理：利用反射机制可以实现代理模式，通过代理对象完成原对象对某些方法的调用，同时也可以在这些方法的调用前后做一些额外的处理。</li></ul><p>Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。<strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p><p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p><p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p><h3 id="获取class对象"><a href="#获取class对象" class="headerlink" title="获取class对象"></a>获取class对象</h3><p>Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//  知道具体类的情况下可以使用 -- 类名.class</span><span class="token class-name">Class</span> alunbarClass <span class="token operator">=</span> <span class="token class-name">TargetObject</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment">//  通过 Class.forName()传入类的全路径获取</span><span class="token class-name">Class</span> alunbarClass1 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.javaguide.TargetObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  通过对象实例instance.getClass()获取</span><span class="token class-name">TargetObject</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TargetObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Class</span> alunbarClass2 <span class="token operator">=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  通过类加载器xxxClassLoader.loadClass()传入类路径获取</span><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"cn.javaguide.TargetObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 反射实例化 -- 对象.newInstance()</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.javaguide.TargetObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TargetObject</span> targetObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TargetObject</span><span class="token punctuation">)</span> targetClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>获得类中属性相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getField(String name)</td><td align="left">获得某个公有的属性对象</td></tr><tr><td align="left">getFields()</td><td align="left">获得所有公有的属性对象</td></tr><tr><td align="left">getDeclaredField(String name)</td><td align="left">获得某个属性对象</td></tr><tr><td align="left">getDeclaredFields()</td><td align="left">获得所有属性对象</td></tr></tbody></table><ul><li><strong>获得类中注解相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getAnnotation(Class annotationClass)</td><td align="left">返回该类中与参数类型匹配的公有注解对象</td></tr><tr><td align="left">getAnnotations()</td><td align="left">返回该类所有的公有注解对象</td></tr><tr><td align="left">getDeclaredAnnotation(Class annotationClass)</td><td align="left">返回该类中与参数类型匹配的所有注解对象</td></tr><tr><td align="left">getDeclaredAnnotations()</td><td align="left">返回该类所有的注解对象</td></tr></tbody></table><ul><li><strong>获得类中构造器相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getConstructor(Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类中与参数类型匹配的公有构造方法</td></tr><tr><td align="left">getConstructors()</td><td align="left">获得该类的所有公有构造方法</td></tr><tr><td align="left">getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类中与参数类型匹配的构造方法</td></tr><tr><td align="left">getDeclaredConstructors()</td><td align="left">获得该类所有构造方法</td></tr></tbody></table><ul><li><strong>获得类中方法相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类某个公有的方法</td></tr><tr><td align="left">getMethods()</td><td align="left">获得该类所有公有的方法</td></tr><tr><td align="left">getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类某个方法</td></tr><tr><td align="left">getDeclaredMethods()</td><td align="left">获得该类所有方法</td></tr></tbody></table><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ul><li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><h3 id="JDK序列化"><a href="#JDK序列化" class="headerlink" title="JDK序列化"></a>JDK序列化</h3><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Builder</span><span class="token annotation punctuation">@ToString</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcRequest</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1905122041950251207L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> requestId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> interfaceName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> methodName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameters<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> paramTypes<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">RpcMessageTypeEnum</span> rpcMessageTypeEnum<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列化号 <code>serialVersionUID</code> 属于版本控制的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。</p><blockquote><p><code>static</code> 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而，<code>serialVersionUID</code> 是一个特例，<code>serialVersionUID</code> 的序列化做了特殊处理。当一个对象被序列化时，<code>serialVersionUID</code> 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。</p></blockquote><p><strong>如果有些字段不想进行序列化怎么办？</strong></p><p>对于不想进行序列化的变量，可以使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：<strong>阻止实例中那些用此关键字修饰的的变量序列化</strong>；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，<strong>在反序列化后变量值将会被置成类型的默认值</strong>。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h3><p>Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language * * @author shuang.kou * @createTime 2020年05月13日 19:29:00 */</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KryoSerializer</span> <span class="token keyword">implements</span> <span class="token class-name">Serializer</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Kryo</span><span class="token punctuation">&gt;</span></span> kryoThreadLocal <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">Kryo</span> kryo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Kryo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kryo<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">RpcResponse</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kryo<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> kryo<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ByteArrayOutputStream</span> byteArrayOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token class-name">Output</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Output</span><span class="token punctuation">(</span>byteArrayOutputStream<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Kryo</span> kryo <span class="token operator">=</span> kryoThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Object-&gt;byte:将对象序列化为byte数组</span>            kryo<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>            kryoThreadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> output<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SerializeException</span><span class="token punctuation">(</span><span class="token string">"Serialization failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ByteArrayInputStream</span> byteArrayInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token class-name">Input</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Input</span><span class="token punctuation">(</span>byteArrayInputStream<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Kryo</span> kryo <span class="token operator">=</span> kryoThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// byte-&gt;Object:从byte数组中反序列化出对象</span>            <span class="token class-name">Object</span> o <span class="token operator">=</span> kryo<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>            kryoThreadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> clazz<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SerializeException</span><span class="token punctuation">(</span><span class="token string">"Deserialization failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">InputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Number of remaining bytes:"</span>            <span class="token operator">+</span> fis<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回输入流中可以读取的字节数。</span>    <span class="token keyword">int</span> content<span class="token punctuation">;</span>    <span class="token keyword">long</span> skip <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The actual number of bytes skipped:"</span> <span class="token operator">+</span> skip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The content read from file:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>content <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。</span>        <span class="token comment">// 如果未读取任何字节，则代码返回 -1 ，表示文件结束</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将ascii码转为读到的字符</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>输出：    <span class="token class-name">Number</span> of remaining bytes<span class="token operator">:</span><span class="token number">11</span><span class="token class-name">The</span> actual number of bytes skipped<span class="token operator">:</span><span class="token number">2</span><span class="token class-name">The</span> content read from file<span class="token operator">:</span><span class="token class-name">JavaGuide</span><span class="token comment">// 新建一个 BufferedInputStream 对象</span><span class="token class-name">BufferedInputStream</span> bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取文件的内容并复制到 String 对象中            读取输入流所有字节</span><span class="token class-name">String</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bufferedInputStream<span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileInputStream</span> fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//必须将fileInputStream作为构造参数才能使用</span><span class="token class-name">DataInputStream</span> dataInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span>fileInputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以读取任意具体的类型数据</span>dataInputStream<span class="token punctuation">.</span><span class="token function">readBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataInputStream<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataInputStream<span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ObjectInputStream 用于从输入流中读取 Java 对象（反序列化），ObjectOutputStream 用于将对象写入到输出流(序列化)。</span><span class="token class-name">ObjectInputStream</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"object.data"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">MyClass</span> object <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyClass</span><span class="token punctuation">)</span> input<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileOutputStream</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token string">"JavaGuide"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    output<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将数组写入到输出流，等价于 write(b, 0, b.length)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 字节缓冲输出流</span><span class="token class-name">FileOutputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span>fileOutputStream<span class="token punctuation">)</span><span class="token comment">// 输出流</span><span class="token class-name">FileOutputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">DataOutputStream</span> dataOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span>fileOutputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出任意数据类型</span>dataOutputStream<span class="token punctuation">.</span><span class="token function">writeBoolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataOutputStream<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 序列化，将对象写入到输出流</span><span class="token class-name">ObjectOutputStream</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Guide哥"</span><span class="token punctuation">,</span> <span class="token string">"JavaGuide作者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>output<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程比较耗时；</li><li>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</li><li>所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</li></ul><p>例如，如果你想从<code>InputStream</code>中读取字符，你需要考虑字符的编码方式。如果字符使用UTF-8编码，一个字符可能由一个或多个字节组成。因此，直接使用<code>InputStream</code>的<code>read()</code>方法可能无法完整地读取一个字符，因为它一次只读取一个字节。</p><p>要正确地从<code>InputStream</code>中读取字符，你可以使用<code>Reader</code>类及其子类，如<code>InputStreamReader</code>。<code>Reader</code>是字符输入流，专门用于读取字符。<code>InputStreamReader</code>是一个桥接类，它可以将字节流转换为字符流，同时指定字符编码。</p><blockquote><p>1，ASCII码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字度节的空间。</p><p>2，UTF-8编码：一个英文字符等于一个字节，<strong>一个中文（含繁体）等于三个字节</strong>。中文标点占三个字节，英文标点占一个字节</p><p>3，Unicode编码：<strong>一个英文等于两个字节</strong>，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节</p><p>4，GBK：英文占 1 字节，中文占 2 字节。</p></blockquote><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 字节流转换为字符流的桥梁</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InputStreamReader</span> <span class="token keyword">extends</span> <span class="token class-name">Reader</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 用于读取字符文件</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileReader</span> <span class="token keyword">extends</span> <span class="token class-name">InputStreamReader</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileReader</span> fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> content<span class="token punctuation">;</span>    <span class="token keyword">long</span> skip <span class="token operator">=</span> fileReader<span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The actual number of bytes skipped:"</span> <span class="token operator">+</span> skip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The content read from file:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>content <span class="token operator">=</span> fileReader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 字符流转换为字节流的桥梁</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutputStreamWriter</span> <span class="token keyword">extends</span> <span class="token class-name">Writer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 用于写入字符到文件</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileWriter</span> <span class="token keyword">extends</span> <span class="token class-name">OutputStreamWriter</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Writer</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    output<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"你好，我是Guide。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>IO 操作是很消耗性能的，<strong>缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作</strong>，提高流的传输效率。</p><p>字节缓冲流这里采用了<strong>装饰器模式</strong>来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 新建一个 BufferedInputStream 对象</span><span class="token class-name">BufferedInputStream</span> bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，<strong>字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</strong></p><p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span><span class="token keyword">class</span> <span class="token class-name">BufferedInputStream</span> <span class="token keyword">extends</span> <span class="token class-name">FilterInputStream</span> <span class="token punctuation">{</span>    <span class="token comment">// 内部缓冲区数组</span>    <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token keyword">byte</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 缓冲区的默认大小</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_BUFFER_SIZE</span> <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">;</span>    <span class="token comment">// 使用默认的缓冲区大小</span>    <span class="token keyword">public</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> in<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> <span class="token constant">DEFAULT_BUFFER_SIZE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 自定义缓冲区大小</span>    <span class="token keyword">public</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> in<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Buffer size &lt;= 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字节缓冲输出流</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token string">"JavaGuide"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p><code>System.out</code> 实际是用于获取一个 <code>PrintStream</code> 对象，<code>print</code>方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。</p><p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p><h3 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h3><p>这里要介绍的随机访问流指的是<strong>支持随意跳转到文件的任意位置进行读写</strong>的 <code>RandomAccessFile</code> 。</p><p><code>RandomAccessFile</code> 的构造方法如下，我们可以指定 <code>mode</code>（读写模式）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span><span class="token keyword">public</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">,</span> <span class="token class-name">String</span> mode<span class="token punctuation">)</span>    <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 私有方法</span><span class="token keyword">private</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">,</span> <span class="token class-name">String</span> mode<span class="token punctuation">,</span> <span class="token keyword">boolean</span> openAndDelete<span class="token punctuation">)</span>  <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">{</span>  <span class="token comment">// 省略大部分代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">RandomAccessFile</span> randomAccessFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 内容ABCDEFG</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取之前的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">",当前读取到的字符"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，读取之后的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><span class="token comment">// 指针当前偏移量为 6</span>randomAccessFile<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取之前的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">",当前读取到的字符"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，读取之后的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7</span><span class="token comment">// 从偏移量 7 的位置开始往后写入字节数据</span>randomAccessFile<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'H'</span><span class="token punctuation">,</span> <span class="token char">'I'</span><span class="token punctuation">,</span> <span class="token char">'J'</span><span class="token punctuation">,</span> <span class="token char">'K'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 文件内容变为 ABCDEFGHIJK</span><span class="token comment">// 指针当前偏移量为 0，回到起始位置</span>randomAccessFile<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取之前的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">",当前读取到的字符"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，读取之后的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p><strong>我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间</li></ol><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会<strong>一直阻塞，直到内核把数据拷贝到用户空间</strong>。</p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h2 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h2><p>Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 <strong>对于高负载、高并发的（网络）应用，应使用 NIO</strong> 。Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。<strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是<strong>基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</strong></p><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法<strong>，这种语法对编程语言的功能并没有影响</strong>。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要<strong>先通过编译器进行解糖</strong>，也就是在程序<strong>编译阶段将其转换成 JVM 认识的基本语法</strong>。这也侧面说明，Java 中<strong>真正支持语法糖的是 Java 编译器</strong>而不是 JVM。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。</p><p>Java 中最常用的语法糖主要有<strong>泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式</strong>等。</p><p>增强for循环：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Student</span> stu <span class="token operator">:</span> students<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stu<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        students<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>会抛出<code>ConcurrentModificationException</code>异常。</p><p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p><p>所以 <code>Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 <code>Iterator</code> 本身的方法<code>remove()</code>来删除对象，<code>Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。</p><img src="/2024/06/15/java/java-collection-hierarchy.png" alt="Java 集合框架概览" style="zoom:80%;"><ul><li><code>List</code>: 存储的元素是有序的、可重复的。</li><li><code>Set</code>: 存储的元素不可重复的。</li><li><code>Queue</code>: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><code>ArrayList</code> 的底层是数组队列，相当于<strong>动态数组</strong>。与 Java 中的数组相比，它的<strong>容量能动态增长</strong>。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以<strong>减少递增式再分配的数量</strong>。</p><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>List</code> : 表明它是一个列表，支持<strong>添加、删除、查找</strong>等操作，并且可以<strong>通过下标进行访问</strong>。</p></li><li><p><code>RandomAccess</code> ：这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p></li><li><p><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</p></li><li><p><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</p></li></ul><p><strong>ArrayList 插入和删除元素的时间复杂度</strong></p><p>对于插入：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要<strong>扩容时，则需要执行一次 O(n) 的操作</strong>将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。</li></ul><p>对于删除：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。</li></ul><h5 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h5><p>初始化时，默认无参构造函数给<code>elementData</code>（保存ArrayList数据的数组）赋值<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA={}</code>，也就是一个默认大小0的空实例。在第一次添加数据的时候才会真正分配容量<code>DEFAULT_CAPACITY = 10</code>。此后添加第2，3，，，一直到10个元素，<code>minCapacity - elementData.length &gt; 0</code>都不成立，也就是现有的Object数组的长度都大于需要的最小数组长度，所以不会扩容。到第11个元素时，进入<code>grow</code>方法扩容，新的容量<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>也就是原始大小的1.5倍。</p><p>此外，外部方法<code> ensureCapacity</code>可以供调用者手动传入<code> minCapacity</code>，这个值会在<code>grow</code>方法中与<code>newCapacity</code>比较， 如果1.5倍的<code>old </code>仍然小于需要的<code>minCapacity</code>，则更新<code>newCapacity</code>为<code>minCapacity</code>。</p><p>如果新容量大于 <code>MAX_ARRAY_SIZE</code>,进入(执行) <code>hugeCapacity()</code> 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p><h4 id="LinkeadList"><a href="#LinkeadList" class="headerlink" title="LinkeadList"></a>LinkeadList</h4><p><code>LinkedList</code> 是一个基于双向链表实现的集合类，经常被拿来和 <code>ArrayList</code> 做比较。</p><img src="/2024/06/15/java/bidirectional-linkedlist.png" alt="双向链表" style="zoom:80%;"><p>不过，我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好。</p><p><strong>LinkedList 为什么不能实现 RandomAccess 接口？</strong></p><p><code>RandomAccess</code> 是一个<strong>标记</strong>接口，用来表明<strong>实现该接口的类支持随机访问</strong>（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，<strong>内存地址不连续，只能通过指针来定位，不支持随机快速访问</strong>，所以不能实现 <code>RandomAccess</code> 接口。</p><p><code>LinkedList</code> 的类定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>  <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</p><p>阅读过 <code>ArrayList</code> 的源码我们就知道，<code>ArrayList</code> 同样继承了 <code>AbstractList</code> ， 所以 <code>LinkedList</code> 会有大部分方法和 <code>ArrayList</code> 相似。</p><p><code>LinkedList</code> 实现了以下接口：</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有<strong>双端队列</strong>的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li></ul><p><code>LinkedList</code> 中的元素是通过 <code>Node</code> 定义的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">E</span> item<span class="token punctuation">;</span><span class="token comment">// 节点值</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span> <span class="token comment">// 指向的下一个节点（后继节点）</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span> <span class="token comment">// 指向的前一个节点（前驱结点）</span>    <span class="token comment">// 初始化参数顺序分别是：前驱结点、本身节点值、后继节点</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LinkedList</code> 中有一个无参构造函数和一个有参构造函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建一个空的链表对象</span><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="核心机制-1"><a href="#核心机制-1" class="headerlink" title="核心机制"></a>核心机制</h5><p>在定位第idx个元素时，调用node(index)方法，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。</p><p><code>unlink(x)</code> 方法的逻辑如下：</p><ol><li>首先获取待删除节点 x 的前驱和后继节点；</li><li>判断待删除节点是否为头节点或尾节点： <ul><li>如果 x 是头节点，则将 first 指向 x 的后继节点 next</li><li>如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev</li><li>如果 x 不是头节点也不是尾节点，执行下一步操作</li></ul></li><li>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</li><li>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</li><li>将待删除节点 x 的元素置空，修改链表长度。</li></ol><h4 id="ArrayList-vs-LinkedList"><a href="#ArrayList-vs-LinkedList" class="headerlink" title="ArrayList vs LinkedList"></a>ArrayList vs LinkedList</h4><ul><li><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是<strong>不同步的</strong>，也就是不保证线程安全；</p><ul><li>当多个线程同时对ArrayList进行修改操作时，可能会导致数据不一致或者出现异常。这是因为ArrayList的内部结构不是线程安全的，它<strong>没有提供对并发修改的支持</strong>。例如，当一个线程正在向ArrayList中添加元素，而另一个线程同时在删除元素，就有可能导致<strong>索引越界或者元素丢失</strong>的问题。</li><li>推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</li></ul></li><li><p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）</p></li><li><p><strong>插入和删除是否受元素位置的影响：</strong></p><ul><li><code>ArrayList</code> 采用<strong>数组</strong>存储，所以插入和删除元素的时间复杂度<strong>受元素位置的影响</strong>。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li><code>LinkedList</code> 采用<strong>链表</strong>存储，所以在头尾插入或者删除元素<strong>不受元素位置的影响</strong>（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要<strong>先移动到指定位置</strong>再插入和删除。</li><li>总结：ArrayList查询O(1)，开头或指定位置插入删除O(n)。LinkedList查询O(n)，插入删除自身操作O(1)，所以在中间特定位置插入删除整体O(n)</li></ul></li><li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><ul><li>LinkedList是双向链表，不能根据下标直接取元素；ArrayList是动态数组，所以支持快速随机访问。</li></ul></li><li><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 <strong>list 列表的结尾会预留一定的容量空间</strong>，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为<strong>要存放直接后继和直接前驱</strong>以及数据）。</p></li></ul><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>在 JDK1.5 之前，如果想要使用<strong>并发安全</strong>的 <code>List</code> 只能选择 <code>Vector</code>。而 <code>Vector</code> 是一种老旧的集合，已经被淘汰。<code>Vector</code> 对于增删改查等方法基本都加了 <strong><code>synchronized</code><strong>，这种方式虽然能够保证同步，但这相当于对整个 <code>Vector</code> 加上了一把大锁，使得</strong>每个方法执行的时候都要去获得锁，导致性能非常低下</strong>。</p><p>JDK1.5 引入了 <code>Java.util.concurrent</code>（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 <code>List</code> 实现就是 <code>CopyOnWriteArrayList</code> 。</p><blockquote><p>对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该<strong>允许多个线程同时访问 <code>List</code> 的内部数据</strong>，毕竟对于读取操作来说是安全的。</p></blockquote><p>为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的<strong>读取操作是完全无需加锁的</strong>。<strong>写入操作也不会阻塞读取操作</strong>，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。</p><p><code>CopyOnWriteArrayList</code>名字中的“Copy-On-Write”即写时复制，简称 COW，是线程安全的核心。</p><blockquote><p>写入时复制（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同<strong>获取相同的指针指向相同的资源</strong>，直到某个调用者试图<strong>修改资源</strong>的内容时，<strong>系统才会真正复制一份专用副本（private copy）给该调用者</strong>，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p></blockquote><p>当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值给底层数组的引用，替换掉旧的数组，这样就可以保证写操作不会影响读操作了。写时复制机制非常<strong>适合读多写少</strong>的并发场景，能够极大地提高系统的并发性能。</p><p><strong>缺点：</strong></p><ul><li>内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。</li><li>写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。</li><li>数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。</li></ul><h5 id="核心机制-2"><a href="#核心机制-2" class="headerlink" title="核心机制"></a>核心机制</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token keyword">extends</span> <span class="token class-name">Object</span><span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span><span class="token punctuation">{</span>  <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现list，randomaccess，cloneable，serializable，和arraylist一样</p><p><code>CopyOnWriteArrayList</code> 的 <code>add()</code>方法有三个版本：</p><ul><li><code>add(E e)</code>：在 <code>CopyOnWriteArrayList</code> 的尾部插入元素。</li><li><code>add(int index, E element)</code>：在 <code>CopyOnWriteArrayList</code> 的指定位置插入元素。</li><li><code>addIfAbsent(E e)</code>：如果指定元素不存在，那么添加该元素。如果成功添加元素则返回 true。</li></ul><p>这里以<code>add(E e)</code>为例进行介绍：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    <span class="token comment">// 加锁</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取原来的数组</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 原来数组的长度</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 元素放在新数组末尾</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token comment">// array指向新数组</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment">// 解锁</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>add</code>方法内部用到了 <code>ReentrantLock</code> 加锁，保证了同步，避免了多线程写的时候会复制出多个副本出来。锁被<code>final</code>修饰保证了锁的内存地址肯定不会被修改，并且，释放锁的逻辑放在 <code>finally</code> 中，可以保证锁能被释放。</li></ul><ul><li><code>CopyOnWriteArrayList</code> 中并没有类似于 <code>ArrayList</code> 的 <code>grow()</code> 方法扩容的操作。</li></ul><p><strong>读取元素</strong>：<code>CopyOnWriteArrayList</code> 的读取操作是基于内部数组 <code>array</code> 并没有发生实际的修改，因此在读取操作时不需要进行同步控制和锁操作，可以保证数据的安全性。这种机制下，多个线程可以同时读取列表中的元素。不过，<code>get</code>方法是弱一致性的，<strong>在某些情况下可能读到旧的元素值。</strong>（比如，线程1读数据，线程2写数据，线程1取值，此时取值就是旧的值）</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><strong>Comparable 和 Comparator 的区别</strong></p><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 <code>song</code> 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 <code>Comparator</code> 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// void sort(List list),按自然排序的升序排序</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collections.sort(arrayList):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 定制排序的用法</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span><span class="token comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span><span class="token comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// set, get methods</span>    <span class="token comment">/**     * T重写compareTo方法实现按年龄来排序     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Person</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">&gt;</span> o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">&lt;</span> o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="无序性和不可重复性"><a href="#无序性和不可重复性" class="headerlink" title="无序性和不可重复性"></a><strong>无序性和不可重复性</strong></h4><ul><li>无序性不等于随机性 ，无序性是指<strong>存储的数据在底层数组中</strong>并非按照数组索引的顺序添加 ，而是根<strong>据数据的哈希值决定</strong>的。<ul><li>所以HashSet/HashMap是无序的，而LinkedHashSet通过链表维护了插入和取出的顺序，是有序的</li></ul></li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h4 id="HashSet、LinkedHashSet-和-TreeSet"><a href="#HashSet、LinkedHashSet-和-TreeSet" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet"></a>HashSet、LinkedHashSet 和 TreeSet</h4><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。<ul><li>不安全的原因是因为HashMap不是线程安全的。在HashSet中，底层源码，其实就是一个HashMap，HashMap的key为HashSet中的值，而value为一个Object对象常量。</li></ul></li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><p><strong>HashSet如何检查重复</strong></p><blockquote><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p></blockquote><p>在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="ArrayDeque-与-LinkedList"><a href="#ArrayDeque-与-LinkedList" class="headerlink" title="ArrayDeque 与 LinkedList"></a>ArrayDeque 与 LinkedList</h4><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于<strong>可变长的数组和双指针</strong>来实现，而 <code>LinkedList</code> 则通过<strong>链表</strong>来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，<strong>但 <code>LinkedList</code> 支持。</strong></li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过**均摊后的插入操作依然为 O(1)**。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li><li>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</li></ul><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是<strong>优先级最高的元素先出队</strong>。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了<strong>二叉堆</strong>的数据结构来实现的，底层使用<strong>可变长的数组</strong>来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 <strong>O(logn)</strong> 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是<strong>非线程安全</strong>的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><code>BlockingQueue</code> （阻塞队列）是一个<strong>接口</strong>，继承自 <code>Queue</code>。<code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><p><strong>实现类：</strong></p><p>Java 中常用的阻塞队列实现类有以下几种：</p><ol><li><code>ArrayBlockingQueue</code>：使用<strong>数组</strong>实现的有界阻塞队列。<strong>在创建时需要指定容量大小</strong>，并支持公平和非公平两种方式的锁访问机制。</li><li><code>LinkedBlockingQueue</code>：使用<strong>单向链表</strong>实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code>Integer.MAX_VALUE</code>。和<code>ArrayBlockingQueue</code>不同的是， 它仅支持<strong>非公平</strong>的锁访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的<strong>无界</strong>阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</li><li><code>SynchronousQueue</code>：<strong>同步队列</strong>，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：<strong>延迟队列</strong>，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li></ol><h4 id="ArrayBlockingQueue-和-LinkedBlockingQueue"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue"></a>ArrayBlockingQueue 和 LinkedBlockingQueue</h4><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 是 Java 并发包中常用的两种阻塞队列实现，它们都是<strong>线程安全</strong>的。它们之间存在下面这些区别：</p><ul><li><strong>底层实现</strong>：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li><li><strong>是否有界</strong>：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也<strong>可以指定</strong>队列大小，从而成为有界的。</li><li><strong>锁是否分离</strong>： <code>ArrayBlockingQueue</code>中的锁是没有分离的，即<strong>生产和消费用的是同一个锁</strong>；<code>LinkedBlockingQueue</code>中的锁是分离的，即**生产用的是<code>putLock</code>，消费是<code>takeLock</code>**，这样可以防止生产者和消费者线程之间的锁争夺。</li><li><strong>内存占用</strong>：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。这意味着，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p><strong>JDK1.8 之前</strong></p><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><p><strong>JDK1.8 之后</strong></p><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64，那么会选择先进行数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><img src="/2024/06/15/java/jdk1.8_hashmap.png" alt="jdk1.8之后的内部结构-HashMap" style="zoom:80%;"><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token comment">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">362498820763181265L</span><span class="token punctuation">;</span>    <span class="token comment">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">// 最大容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token comment">// 默认的负载因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment">// 桶中结构转化为红黑树对应的table的最小容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment">// =====存储元素的数组，总是2的幂次倍=====</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token comment">// 一个包含了映射中所有键值对的集合视图</span>    <span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entrySet<span class="token punctuation">;</span>    <span class="token comment">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment">// 负载因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Node节点类，继承自 Map.Entry&lt;K,V&gt;</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span><span class="token comment">//键</span>       <span class="token class-name">V</span> value<span class="token punctuation">;</span><span class="token comment">//值</span>       <span class="token comment">// 指向下一个节点-&gt;链式结构</span>       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>       <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 树节点类 -- 红黑树</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">;</span>  <span class="token comment">// 父</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> left<span class="token punctuation">;</span>    <span class="token comment">// 左</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> right<span class="token punctuation">;</span>   <span class="token comment">// 右</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span>    <span class="token comment">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>           <span class="token comment">// 判断颜色</span>        <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> val<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 返回根节点</span>        <span class="token keyword">final</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>loadFactor 负载因子</strong><ul><li>loadFactor 负载因子是控制<strong>数组存放数据的疏密程度</strong>，loadFactor 越趋近于 1，那么 数组中能存放的数据(entry)也就越多（要达到临界值<strong>threshold = capacity * loadFactor</strong>的时候才会扩容），也就越密，也就是会让链表的长度增加（因为要很久才扩容，这段数组本身很密，冲突的数据也多，链表就长），loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</li><li><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</li><li>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li></ul></li></ul><h5 id="核心机制-3"><a href="#核心机制-3" class="headerlink" title="核心机制"></a>核心机制</h5><p>put方法插入元素：如果定位到的数组位置没有元素 就直接插入。</p><p>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 桶中已经存在元素（处理hash冲突）</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>        <span class="token comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">// 判断插入的是否是红黑树节点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 不是红黑树节点则说明为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span>                    <span class="token comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span>                    <span class="token comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 记录e的value</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>resize 方法</strong></p><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><p><strong>HashMap 为什么线程不安全</strong></p><p>JDK1.7 及之前版本，在多线程环境下，<code>HashMap</code> 扩容时会造成<strong>死循环和数据丢失</strong>的问题。</p><p>数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。</p><p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有<strong>数据覆盖</strong>的风险。</p><p>举个例子：</p><ul><li>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</li><li>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</li><li>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</li></ul><h4 id="HashMap-vs-HashTable"><a href="#HashMap-vs-HashTable" class="headerlink" title="HashMap vs HashTable"></a>HashMap vs HashTable</h4><ul><li><p><strong>线程是否安全：</strong> <strong><code>HashMap</code> 是非线程安全的</strong>，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p></li><li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>对 Null key 和 Null value 的支持：</strong> <strong><code>HashMap</code> 可以存储 null 的 key 和 value</strong>，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。（ConcurrentHashMap也不支持存储null）</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。**<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。<strong>② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其</strong>扩充为 2 的幂次方大小**（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说=== <strong><code>HashMap</code> 总是使用 2 的幂作为哈希表的大小</strong>==。</p><ul><li>Hash函数的算法设计：<strong>取余</strong>(%)操作中如果除数是 2 的幂次则<strong>等价于</strong>与其除数减一的与(&amp;)操作（也就是说 <code>hash%length==hash&amp;(length-1)</code>的前提是 length 是 2 的 n 次方；）。并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</li></ul></li><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树</strong>（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</strong>），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</p></li></ul><h4 id="HashMap-vs-TreeMap"><a href="#HashMap-vs-TreeMap" class="headerlink" title="HashMap vs TreeMap"></a>HashMap vs TreeMap</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p><code>NavigableMap</code> 接口提供了丰富的方法来探索和操作键值对，可以对集合元素进行<strong>搜索</strong>:</p><ol><li><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位<strong>大于、小于、大于等于、小于等于给定键</strong>的最接近的键值对。</li><li><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</li><li><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</li><li><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素。</li></ol><p>这些方法都是基于<strong>红黑树</strong>数据结构的属性实现的，红黑树保持平衡状态，从而保证了搜索操作的时间复杂度为 O(log n)，这让 <code>TreeMap</code> 成为了处理<strong>有序集合搜索问题</strong>的强大工具。</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><p><strong>综上，相比于<code>HashMap</code>来说， <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</strong></p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="1-7版本"><a href="#1-7版本" class="headerlink" title="1.7版本"></a>1.7版本</h5><p>1.7版本：Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code> 组合，而每一个 <code>Segment</code> 是一个类似于 <code>HashMap</code> 的结构，所以<strong>每一个 <code>HashMap</code> 的内部可以进行扩容</strong>。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> <strong>默认支持最多 16 个线程并发。</strong></p><img src="/2024/06/15/java/java7_concurrenthashmap.png" alt="Java 7 ConcurrentHashMap 存储结构" style="zoom:80%;"><p>在 Java 7 中 ConcurrentHashMap 的<strong>初始化</strong>逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 <code>concurrencyLevel</code> 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li><li>寻找并发级别 <code>concurrencyLevel</code> 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 <code>segmentShift</code> 偏移量，这个值为【容量 = 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li><li>记录 <code>segmentMask</code>，默认是 ssize - 1 = 16 -1 = 15.</li><li><strong>初始化 <code>segments[0]</code><strong>，</strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩容。</li></ol><p><strong>========put========</strong></p><p><code>ConcurrentHashMap</code> 在**put **一个数据时的处理流程：</p><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 <code>Segment</code>。</p></li><li><p>如果指定位置的 <code>Segment</code> 为空，则初始化这个 <code>Segment</code>.</p><p><strong>初始化 Segment 流程：</strong></p><ol><li>检查计算得到的位置的 <code>Segment</code> 是否为 null.</li><li>为 null 继续初始化，使用 <code>Segment[0]</code> 的容量和负载因子创建一个 <code>HashEntry</code> 数组。</li><li>再次检查计算得到的指定位置的 <code>Segment</code> 是否为 null.</li><li>使用创建的 <code>HashEntry</code> 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 <code>Segment</code> 是否为 null，使用 CAS 在这个位置赋值为 <code>Segment</code></li></ol></li><li><p><strong><code>Segment.put</code> 插入 key,value 值。</strong></p><p>由于 <code>Segment</code> 继承了 <code>ReentrantLock</code>，所以 <code>Segment</code> 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p><code>tryLock()</code> 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p></li><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 <code>HashEntry</code> 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 <code>HashEntry</code> 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p><p>如果这个位置上的 <strong><code>HashEntry</code> 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接头插法插入。</li></ol><p>如果这个位置上的 <strong><code>HashEntry</code> 存在</strong>：</p><ol><li>判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li><li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。 <ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表头插法插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p></li></ol></li></ol><p><strong>========扩容rehash========</strong></p><p><code>ConcurrentHashMap</code> 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 <code>index+ oldSize</code>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><p><strong>===========get=========</strong></p><ol><li>计算得到 key 的存放的segment的对应HashEntry数组位置。</li><li>遍历指定位置的链表查找相同 key 的 value 值。</li></ol><h5 id="1-8版本"><a href="#1-8版本" class="headerlink" title="1.8版本"></a>1.8版本</h5><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><img src="/2024/06/15/java/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）" style="zoom: 80%;"><p><strong>==========初始化==========</strong></p><p><code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> （sizeControl 的缩写），它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化，其他线程需要<strong>自旋等待</strong></li><li>-N 说明 table 正在进行扩容，高 16 位表示扩容的标识戳，低 16 位减 1 为正在进行扩容的线程数</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Initializes table, using the size recorded in sizeCtl. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment">// 让出 CPU 使用权，自旋等待</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lost initialization race; just spin</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">;</span>                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>==========put===========</strong></p><ol><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足(桶里有数据，数组不需要扩容），则利用 synchronized 锁写入数据，写入时判断结构是链表还是红黑树，执行对应的插入操作。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</li></ol><p><strong>==========get===========</strong></p><ol><li>根据 hash 值计算node数组位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，使用find查找。</li><li>如果是链表，遍历查找之。</li></ol><h5 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h5><ul><li><p>JDK1.8之前：首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。<code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。**<code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁**，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p></li><li><p>JDK1.8之后：<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <strong><code>Node + CAS + synchronized</code></strong> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p><p>Java 8 中，锁粒度更细，<code>synchronized</code> <strong>只锁定当前链表或红黑二叉树的首节点</strong>，这样<strong>只要 hash 不冲突，就不会产生并发</strong>，就不会影响其他 Node 的读写，效率大幅提升。</p></li></ul><p>总结：1.7中使用segment分段锁，锁范围较大，最大并发数为segment数量，默认是16。1.8中使用Node+CAS+synchronized，只锁定链表或红黑树的头节点，锁粒度更细，最大并发数是node数组的大小。</p><h4 id="ConcurrentHashMap-vs-Hashtable"><a href="#ConcurrentHashMap-vs-Hashtable" class="headerlink" title="ConcurrentHashMap vs Hashtable"></a>ConcurrentHashMap vs Hashtable</h4><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，<strong>数组+链表/红黑二叉树</strong>。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p></li><li><p><strong>实现线程安全的方式</strong>（重要）：</p><ul><li><p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割<strong>分段</strong>(<code>Segment</code>，分段锁)，<strong>每一把锁只锁容器其中一部分数据</strong>，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p></li><li><p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是<strong>直接用 <code>Node</code> 数组+链表+红黑树</strong>的数据结构来实现，并发控制使用 <strong><code>synchronized</code> 和 CAS</strong> 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是**优化过且线程安全的 <code>HashMap</code>**，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p></li><li><p><strong>Hashtable(同一把锁) <strong>:使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入</strong>阻塞或轮询</strong>状态，如使用 put 添加元素，<strong>另一个线程不能使用 put 添加元素，也不能使用 get</strong>，竞争会越来越激烈效率越低。</p></li></ul></li></ul><img src="/2024/06/15/java/image-20240619175017147.png" alt="image-20240619175017147" style="zoom:80%;"><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p><code>LinkedHashMap</code> 是 Java 提供的一个集合类，它继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条<strong>双向链表</strong>，使得具备如下特性:</p><ol><li>支持遍历时会<strong>按照插入顺序</strong>有序进行迭代。–<code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序。因此，当使用迭代器迭代元素时，元素的顺序与它们最初插入的顺序相同。</li><li>支持按照元素<strong>访问</strong>顺序<strong>排序</strong>,适用于<strong>封装 LRU 缓存</strong>工具。–<code>LinkedHashMap</code> 可以通过构造函数中的 <code>accessOrder</code> 参数指定按照访问顺序迭代元素。当 <code>accessOrder</code> 为 true 时，每次访问一个元素时，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</li><li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。</li></ol><p><code>LinkedHashMap</code> 逻辑结构如下图所示，它是在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。</p><img src="/2024/06/15/java/linkhashmap-structure-overview.png" alt="LinkedHashMap 逻辑结构" style="zoom:67%;"><h5 id="核心机制-4"><a href="#核心机制-4" class="headerlink" title="核心机制"></a>核心机制</h5><ul><li><p><code>LinkedHashMap</code> 的<strong>节点内部类 <code>Entry</code></strong> 基于 <code>HashMap</code> 的基础上，增加 <code>before</code> 和 <code>after</code> 指针使节点具备双向链表的特性。</p></li><li><p><code>HashMap</code> 的树节点 <code>TreeNode</code> 继承了具备双向链表特性的 <code>LinkedHashMap</code> 的 <code>Entry</code>。</p></li></ul><p>总结：Entry类是LinkedHashMap中的节点类，充当HashMap中Node类的作用。</p><p>HashMap 的节点集合 Node则仅包含kv对和下一个元素指针，避免使用HashMap的时候也出现无关的双向链表元素。</p><p>TreeNode用于在内部链表转化为红黑树的时候使用，继承enry类来获取双向链表指针。但是这样做，也使得使用 <code>HashMap</code> 时的 <code>TreeNode</code> 多了两个没有必要的引用。对于这个问题,引用作者的一段注释，作者们认为<strong>在良好的 <code>hashCode</code> 算法时，<code>HashMap</code> 转红黑树的概率不大。就算转为红黑树变为树节点，也可能会因为移除或者扩容将 <code>TreeNode</code> 变为 <code>Node</code>，所以 <code>TreeNode</code> 的使用概率不算很大，对于这一点资源空间的浪费是可以接受的。</strong></p><img src="/2024/06/15/java/map-hashmap-linkedhashmap.png" alt="LinkedHashMap 和 HashMap 之间的关系" style="zoom: 50%;"><h4 id="LinkedHashMap-vs-HashMap"><a href="#LinkedHashMap-vs-HashMap" class="headerlink" title="LinkedHashMap vs HashMap"></a>LinkedHashMap vs HashMap</h4><p><code>LinkedHashMap</code> 和 <code>HashMap</code> 都是 Java 集合框架中的 Map 接口的实现类。它们的最大区别在于<strong>迭代元素的顺序</strong>。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照<strong>插入顺序或访问顺序</strong>迭代元素的功能。此外，<code>LinkedHashMap</code> 内部维护了一个<strong>双向链表，</strong>用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 的插入性能可能会比 <code>HashMap</code> 略低，但它提供了更多的功能并且<strong>迭代效率相较于 <code>HashMap</code> 更加高效</strong>。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位。线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>（<strong>JDK1.8 之后的元空间</strong>）资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为<strong>轻量级进程</strong>。</p><p><strong>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p><p>私有：</p><p><strong>程序计数器</strong>：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。计数器私有是为了各线程之间切换，便于恢复到正确的执行位置。</p><p><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储===局部变量表、操作数栈、常量池引用===等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>为了<strong>保证线程中的===局部变量===不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><p>公有：</p><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的<strong>对象</strong> (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p><p>================================================</p><ul><li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li><li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li></ul><p><strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p><p>线程模型：线程模型是用户线程和内核线程之间的关联方式。</p><ol><li>一对一（一个用户线程对应一个内核线程）</li><li>多对一（多个用户线程映射到一个内核线程）</li><li>多对多（多个用户线程映射到多个内核线程）</li></ol><p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul><li><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><ul><li>在操作系统层面，线程有 <strong>READY 和 RUNNING</strong> 状态；而在 JVM 层面，只能看到 RUNNABLE 状态， Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。JVM没有区分这两种状态，时分（time-sharing）多任务（multi-task）操作系统架构通常都是用“时间分片”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，<strong>一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态）</strong>，也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</li></ul></li><li><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需<strong>要依靠其他线程的通知</strong>才能够返回到运行状态。（等待状态，表示该线程需要等待其他线程做出一些特定动作如通知或中断）</p></li><li><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p></li><li><p>当线程进入 <code>synchronized</code> 方法/块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法/块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。、</p></li><li><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p></li></ul><img src="/2024/06/15/java/640.png" alt="Java 线程状态变迁图" style="zoom:80%;"><p><strong>线程上下文切换：</strong>保存当前线程的上下文（线程运行过程中的条件和状态），留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。线程切换可能发生在这些场景：<strong>主动让出 CPU</strong>，比如调用了 sleep(), wait() 等。<strong>时间片用完</strong>，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。调用了阻塞类型的<strong>系统中断</strong>，比如请求 IO，线程被阻塞。被终止或<strong>结束运行</strong>。</p><h4 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h4><p><strong>Thread#sleep() 方法和 Object#wait() 方法</strong>：都可以暂停线程的执行。区别是sleep是让当前线程休眠一会，之后就会自动恢复，所以不会释放锁。而wait（）对应线程生命周期中的等待状态，目的是线程之间的通信和交互，需要释放锁等待其他线程通知才能回到运行状态。<code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</p><ul><li><code>wait()</code> 是让获得<strong>对象锁</strong>的线程实现等待，会自动释放当前线程占有的对象锁。<strong>每个对象（<code>Object</code>）都拥有对象锁</strong>，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要<strong>操作对应的对象</strong>（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</li><li><code>sleep()</code> 是让当前<strong>线程</strong>暂停执行，不涉及到对象类，也不需要获得对象锁。所以定义在Thread中。</li></ul><p>关于run和start：调用 <code>start()</code> 方法启动线程并使线程进入就绪状态，会执行线程的相应准备工作，然后<strong>自动执行 <code>run()</code> 方法</strong>的内容。如果开发者手动直接执行 <code>run()</code> 方法的话，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，不会以多线程的方式执行。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是多线程或多进程并发编程中的一种常见问题，它发生在<strong>两个或多个线程（或进程）相互等待对方释放资源</strong>的情况下，导致它们都无法继续执行下去的状态。这种情况下，每个线程都在等待某个资源，而同时也拥有一些资源。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 1</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 2</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li><strong>请求与保持</strong>/占有并等待条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>非抢占条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>预防死锁：</p><p>1.破坏占有并等待条件：一次性申请所有资源；</p><p>2.破坏非抢占条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p>3.破坏循环等待条件：按顺序申请资源，反序释放资源</p><p>避免死锁：</p><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是Java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色在。<code>volatile</code> 关键字可以保证变量的可见性， <strong>所谓可见性，是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更</strong>。如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是<strong>共享且不稳定</strong>的，每次使用它都到<strong>主存</strong>中进行读取。<code>volatile</code> 关键字能保证数据的可见性，<strong>但不能保证数据的原子性</strong>。<code>synchronized</code> 关键字两者都能保证。</p><p><strong>JMM规定了所有的变量都存储在主内存中</strong>。普通变量不能保证内存可见性。而volatile则保证了<strong>可见性和有序性</strong>。</p><ul><li>当<strong>写</strong>一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值<strong>立即刷新回主内存中</strong>。</li><li>当<strong>读</strong>一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存<strong>中读取最新共享变量</strong>。</li></ul><p>有序性，即<strong>禁止指令重排序</strong>。在对volatile变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><ul><li>重排序是指编译器和处理器为了优化程序性能<strong>面对指令序列进行重新排序</strong>的一种手段，有时候会改变程序予以的先后顺序。（但重排后的指令绝对不能改变原有串行语义）<ul><li>不存在数据依赖关系，可以重排序；</li><li>存在数据依赖关系，禁止重排序。</li></ul></li></ul><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p><ul><li><strong>读屏障</strong>(Load Memory Barrier) ：在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据。</li><li><strong>写屏障</strong>(Store Memory Barrier) ：在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中。</li></ul><p>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。一句话：<strong>对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读，也叫写后读。</strong></p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//类对象加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。使用volatile修饰，就能禁止指令重排。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><blockquote><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p></blockquote><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用<strong>版本号机制或 CAS 算法</strong>）。</p><p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><blockquote><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p></blockquote><p>理论上来说：</p><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以<strong>避免频繁失败和重试影响性能</strong>，悲观锁的<strong>开销是固定的</strong>。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以<strong>避免频繁加锁影响性能</strong>。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是<strong>用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</strong></p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p><p>CAS 涉及到三个操作数：<strong>V</strong>：要更新的变量值(Var)；<strong>E</strong>：预期值(Expected)；<strong>N</strong>：拟写入的新值(New)</p><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。（和版本号机制思想一致）</p><p>问题：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>解决方案：在变量前面追加上<strong>版本号或者时间戳</strong>。<code>AtomicStampedReference</code> 类的 <code>compareAndSet()</code> 方法就是首先检查当前<strong>引用</strong>是否等于预期引用，并且当前<strong>标志</strong>是否等于预期标志，如果<strong>全部相等</strong>，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>另一个问题：<strong>循环时间长开销大</strong>。CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升。</p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是<strong>多个线程之间访问资源的同步性</strong>，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。因为早期锁依赖于操作系统底层mutex lock实现，Java线程要映射到操作系统原生线程之上，也就是挂起或唤醒线程进行线程上下文切换时，<strong>都需要从用户态转换成内核态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。（JDK18 中，偏向锁已经被彻底废弃）锁主要存在四种状态，依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，他们会随着竞争的激烈而逐渐升级。注意<strong>锁可以升级不可降级</strong>，这种策略是为了提高获得锁和释放锁的效率。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 修饰实例方法，给当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 。</span><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//业务代码</span><span class="token punctuation">}</span><span class="token comment">// 修饰静态方法，当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。</span><span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//业务代码</span><span class="token punctuation">}</span><span class="token comment">// 修饰代码块，对括号里指定的对象/类加锁：synchronized(object)或synchronized(类.class)</span><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//业务代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>synchronized 关键字底层原理属于 JVM 层面的东西。</p><p><strong>同步语句块</strong></p><p><code>synchronized</code> <strong>同步语句块</strong>的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>同步方法</strong></p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。<strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong>JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h4 id="synchronized-vs-volatile"><a href="#synchronized-vs-volatile" class="headerlink" title="synchronized vs volatile"></a>synchronized vs volatile</h4><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个<strong>互补</strong>的存在，而不是对立的存在！</p><ul><li><code>volatile</code> 关键字是线程同步的<strong>轻量级</strong>实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字<strong>只能用于变量</strong>而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><code>volatile</code> 关键字能保证<strong>数据的可见性</strong>，但不能保证数据的原子性。<code>synchronized</code> 关键字<strong>两者都能保证</strong>。</li><li><code>volatile</code>关键字主要用于解决<strong>变量在多个线程之间的可见性</strong>，而 <code>synchronized</code> 关键字解决的是<strong>多个线程之间访问资源的同步性</strong>。</li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个<strong>可重入且独占</strong>式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了<strong>轮询、超时、中断、公平锁和非公平锁</strong>等高级功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>ReentrantLock</code> 里面有一个**内部类 <code>Sync</code>**，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。<code>ReentrantLock</code> 的底层就是由 AQS 来实现的。</p><img src="/2024/06/15/java/reentrantlock-class-diagram.png" alt="img" style="zoom: 50%;"><p><strong>公平锁</strong> : 锁被释放之后，<strong>先申请的线程先得到锁</strong>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，<strong>上下文切换更频繁</strong>。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，<strong>cpu唤醒阻塞线程的开销会很大</strong>。</li></ul><p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。<strong>性能更好</strong>，但可能会导致某些线程永远无法获取到锁。</p><ul><li>非公平锁比公平锁效率高的原因主要在于<strong>减少了线程切换和同步操作的次数</strong>。</li><li>当线程在运行期间直接抢占到锁资源时，不需要进行“执行现场保存和恢复”的操作，从而能够更快地执行业务代码。相比之下，如果一个就绪态的线程想要获得锁资源，首先需要恢复现场，之后争抢锁（可能成功也可能失败），这个过程浪费了大量的CPU资源，只有在获取锁成功后才能继续执行业务代码。因此，非公平锁在效率上优于公平锁，主要原因就在于是否需要进行现场恢复和不同态之间的切换。<strong>非公平锁减少了线程挂起的几率</strong>，后来的线程有一定几率逃离被挂起的开销。</li></ul><h3 id="synchronized-vs-ReentrantLock"><a href="#synchronized-vs-ReentrantLock" class="headerlink" title="synchronized vs ReentrantLock"></a>synchronized vs ReentrantLock</h3><ul><li><p>两者都是可重入锁。<strong>可重入锁</strong> 也叫<strong>递归锁</strong>，指的是<strong>线程可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，<strong>如果是不可重入锁的话，就会造成死锁。</strong></p><ul><li>可重入锁主要用在线程需要多次进入临界区代码时，需要使用可重入锁。</li><li>每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会<strong>记下锁的持有线程</strong>，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以<strong>再次拿到这个锁，同时计数器会递增</strong>；当线程<strong>退出同步代码块时，计数器会递减</strong>，如果计数器为 0，则释放该锁。</li></ul></li><li><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是<strong>这些优化都是在虚拟机层面实现的，并没有直接暴露给我们</strong>。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以<strong>通过查看它的源代码，来看它是如何实现的</strong>。</p></li><li><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够<strong>中断等待锁的线程</strong>的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说<strong>正在等待的线程可以选择放弃等待，改为处理其他事情。</strong><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能<strong>等到拿到锁以后才能进行其他的逻辑处理</strong>。 <code>synchronized</code> 就属于是不可中断锁。</li></ul></li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而**<code>synchronized</code>只能是非公平锁**。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。<ul><li><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现<strong>多路通知功能</strong>也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，</strong>在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知” ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而**<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例<strong>，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而</strong><code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。**</li></ul></li></ul></li></ul><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个<strong>可重入的读写锁</strong>，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantReadWriteLock</span>        <span class="token keyword">implements</span> <span class="token class-name">ReadWriteLock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ReadWriteLock</span> <span class="token punctuation">{</span>    <span class="token class-name">Lock</span> <span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Lock</span> <span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。<strong>读锁是共享锁，写锁是独占锁</strong>。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。<code>ReentrantReadWriteLock</code> 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</p><p>在<strong>读多写少</strong>的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能。</p><ul><li><strong>共享锁</strong>：一把锁可以被多个线程同时获得。</li><li><strong>独占锁</strong>：一把锁只能被一个线程获得。</li></ul><p>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</p><p><strong>在线程持有读锁的情况下，该线程不能取得写锁。</strong>在线程持有写锁的情况下，该线程可以继续获取读锁。</p><p><strong>当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</strong></p><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，<strong>不可重入且不支持条件变量</strong> <code>Condition</code>。</p><p><code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。<code>StampedLock</code> 通过 CLH 队列进行线程的管理，通过同步状态值 <code>state</code> 来表示锁的状态和类型。</p><p><code>StampedLock</code> 提供了三种模式的读写控制模式：读锁、写锁和乐观读。</p><ul><li><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是<strong>不可重入</strong>的。</li><li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</li><li><strong>乐观读</strong>：<strong>允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</strong></li></ul><p><code>StampedLock</code> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是<code>StampedLock</code>不可重入的原因。</p><p><strong>StampedLock比ReentrantReadWriteLock性能更好，主要体现在以下几个方面：</strong><br>1、增加乐观读功能，减少写线程饥饿现象出现</p><p>​当线程尝试获取乐观读锁时，StampedLock 会检查当前是否有写锁被持有。如果没有，它会增加一个读锁计数器并返回一个 stamp（通常是当前状态的一个快照）。乐观读锁不会阻塞其他读线程或写线程，但可能在写线程获得锁后读取到不一致的数据。</p><p>2、StampedLock要比ReentrantReadWriteLock消耗小</p><p>3、StampedLock增加了更多的无锁操作，使线程间阻塞减少到最小。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，拥有自己的私有数据（专属本地变量）。如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的<strong>每个线程都会有这个变量的本地副本</strong>，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而<strong>避免了线程安全问</strong>题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p><p>泛型：<a href="https://blog.csdn.net/weixin_45395059/article/details/126006369">Java 中的泛型（两万字超全详解）_java 泛型-CSDN博客</a></p><p>反射：<a href="https://blog.csdn.net/weixin_74268571/article/details/131345164">Java反射详解-CSDN博客</a></p><p>volatile：<a href="https://blog.csdn.net/m0_49183244/article/details/125493673">Java中的volatile_java volatile-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM</title>
      <link href="/2024/05/21/ssm/"/>
      <url>/2024/05/21/ssm/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>Spring 5.X版本模块：</p><img src="/2024/05/21/ssm/1.png" alt="Spring5.x主要模块"><table><thead><tr><th align="left"><strong>功能模块</strong></th><th align="left"><strong>功能介绍</strong></th></tr></thead><tbody><tr><td align="left">Core Container</td><td align="left">核心容器，<strong>主要提供 IoC 依赖注入功能的支持</strong>。在 Spring 环境下使用任何功能都必须基于 <strong>IOC 容器</strong>。</td></tr><tr><td align="left">AOP&amp;Aspects</td><td align="left">面向切面编程</td></tr><tr><td align="left">Testing</td><td align="left">提供了对 junit 或 TestNG 测试框架的整合。</td></tr><tr><td align="left">Data Access/Integration</td><td align="left">提供了对数据访问/集成的功能。</td></tr><tr><td align="left">Spring MVC</td><td align="left">提供了面向Web应用程序的集成功能。</td></tr></tbody></table><h4 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h4><ul><li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong>：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong>：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul><li><strong>spring-aspects</strong>：该模块为与 AspectJ 的集成提供支持。</li><li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li><li><strong>spring-instrument</strong>：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li></ul><h4 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access/Integration"></a>Data Access/Integration</h4><ul><li><strong>spring-jdbc</strong>：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li><strong>spring-tx</strong>：提供对事务的支持。</li><li><strong>spring-orm</strong>：提供对 Hibernate、JPA、iBatis 等 ORM（对象关系映射） 框架的支持。</li><li><strong>spring-oxm</strong>：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li></ul><h4 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h4><ul><li><strong>spring-web</strong>：对 Web 功能的实现提供一些最基础的支持。</li><li><strong>spring-webmvc</strong>：提供对 Spring MVC 的实现。</li><li><strong>spring-websocket</strong>：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li><strong>spring-webflux</strong>：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li></ul><h4 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h4><ul><li><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</li></ul><h4 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h4><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="==Spring IOC=="></a>==Spring IOC==</h3><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是<strong>将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</strong>(对象创建控制权由程序转移到外部)。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><ul><li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。IOC容器的作用：</p><ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为==Bean==</li><li>IOC容器中放的就是一个个的Bean对象</li></ul><p>当IOC容器中创建好service和dao对象后，程序能正确执行么?</p><ul><li>不行，因为service运行需要依赖dao对象</li><li>IOC容器中虽然有service和dao对象，但是service对象和dao对象没有任何关系</li><li>需要把dao对象交给service,也就是说<strong>要绑定service和dao对象之间的关系</strong></li></ul><p>像这种在容器中建立对象与对象之间的绑定关系就要用到<strong>DI依赖注入</strong></p><ul><li><p>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入</p></li><li><p>如业务层需要依赖数据层，service就要和dao建立依赖关系</p></li></ul><p>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:==充分解耦==，具体实现靠:</p><ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul><blockquote><p>总结：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种具体实现。</p></blockquote><h3 id="IOC在Spring中的实现"><a href="#IOC在Spring中的实现" class="headerlink" title="IOC在Spring中的实现"></a>IOC在Spring中的实现</h3><p>resources下添加spring配置文件applicationContext.xml，并完成bean的配置</p><img src="/2024/05/21/ssm/1629734336440.png" alt="1629734336440" style="zoom: 67%;"><h4 id="bean基础配置-id与class"><a href="#bean基础配置-id与class" class="headerlink" title="bean基础配置(id与class)"></a>bean基础配置(id与class)</h4><p>对于bean的基础配置，在前面的案例中已经使用过:</p><pre class="line-numbers language-none"><code class="language-none">&lt;bean id="" class=""/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下</p><img src="/2024/05/21/ssm/image-20210729183500978.png" alt="image-20210729183500978" style="zoom: 50%;"><ul><li><p>bean依赖注入的ref属性指定bean，必须在容器中存在</p><img src="/2024/05/21/ssm/1629771744003.png" alt="1629771744003" style="zoom: 67%;"></li></ul><h4 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h4><p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p><p>就需要研究下<code>bean的实例化过程</code>，在这块内容中主要解决两部分内容，分别是</p><ul><li>bean是如何创建的</li><li>实例化bean的三种方式，<code>构造方法</code>,<code>静态工厂</code>和<code>实例工厂</code></li></ul><h5 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h5><blockquote><p>Spring 底层默认通过反射技术<strong>调用组件类的无参构造器</strong>来创建组件对象，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出异常。</p></blockquote><p>将类配置到Spring容器</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写运行程序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppForInstanceBook</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span>             <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BookDao</span> bookDao <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BookDao</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类中提供构造函数测试</p><p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">BookDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao constructor is running ...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数。将构造函数改成private测试，运行程序，能执行成功,说明内部走的依然是构造函数,能访问到类中的私有构造方法,显而易见Spring底层用的是反射。</p><h5 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h5><p>在spring的配置文件application.properties中添加以下内容:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>orderDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.factory.OrderDaoFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getOrderDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>class:工厂类的类全名</p><p>factory-mehod:具体工厂类中创建对象的方法名</p><p>对应关系如下图:</p><img src="/2024/05/21/ssm/image-20210729195248948.png" alt="image-20210729195248948" style="zoom:80%;"><p>在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppForInstanceOrder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">OrderDao</span> orderDao <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">OrderDao</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"orderDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，这些操作必不可少。这种方式一般是用来兼容早期的一些老系统，所以==了解为主==。</p><h5 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h5><p>在spring的配置文件中添加以下内容:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.factory.UserDaoFactory<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getUserDao<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userFactory<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实例化工厂运行的顺序是:</p><ul><li><p>创建实例化工厂对象,对应的是第一行配置</p></li><li><p>调用对象中的方法来创建bean，对应的是第二行配置</p><ul><li><p>factory-bean:工厂的实例对象</p></li><li><p>factory-method:工厂对象中的具体创建对象的方法名,对应关系如下:</p><img src="/2024/05/21/ssm/image-20210729200203249.png" alt="image-20210729200203249" style="zoom:80%;"></li></ul></li></ul><p>factory-mehod:具体工厂类中创建对象的方法名</p><p>(2)在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppForInstanceUser</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span>             <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">UserDao</span> userDao <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserDao</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例工厂实例化的方式就已经介绍完了，配置的过程还是比较复杂，所以Spring为了简化这种配置方式就提供了一种叫<code>FactoryBean</code>的方式来简化开发。</p><h5 id="FactoryBean的使用"><a href="#FactoryBean的使用" class="headerlink" title="FactoryBean的使用"></a>FactoryBean的使用</h5><p>具体的使用步骤为:</p><p>(1)创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDaoFactoryBean</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserDao</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//代替原始实例工厂中创建对象的方法</span>    <span class="token keyword">public</span> <span class="token class-name">UserDao</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回所创建类的Class对象</span>    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">UserDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)在Spring的配置文件中进行配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.factory.UserDaoFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(3)AppForInstanceUser运行类不用做任何修改，直接运行</p><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><ol><li>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</li></ol><ul><li>在bean中定义引用类型属性，并<strong>提供可访问的==set==方法</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">BookDao</span> bookDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBookDao</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span> bookDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bookDao <span class="token operator">=</span> bookDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置中使用==property==标签==ref==属性注入引用类型对象</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.imipl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.注入简单数据类型：和引用类型类似</p><blockquote><p>1.在BookDaoImpl类中声明对应的简单数据类型的属性</p><p>2.为这些属性提供对应的setter方法</p><p>3.在applicationContext.xml中配置</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> databaseName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> connectionNum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setConnectionNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> connectionNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>connectionNum <span class="token operator">=</span> connectionNum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token class-name">String</span> databaseName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>databaseName <span class="token operator">=</span> databaseName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token operator">+</span>databaseName<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>connectionNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置文件中使用property标签注入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>databaseName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>connectionNum<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookService</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">BookDao</span> bookDao<span class="token punctuation">;</span>    <span class="token comment">// 利用构造器传参</span>    <span class="token keyword">public</span> <span class="token class-name">BookServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span> bookDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bookDao <span class="token operator">=</span> bookDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book service save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标签<constructor-arg>中</constructor-arg></p><ul><li><p>name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。</p></li><li><p>ref属性指向的是spring的IOC容器中其他bean对象。</p></li></ul><p><strong>注入简单数据类型</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> databaseName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> connectionNum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">BookDaoImpl</span><span class="token punctuation">(</span><span class="token class-name">String</span> databaseName<span class="token punctuation">,</span> <span class="token keyword">int</span> connectionNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>databaseName <span class="token operator">=</span> databaseName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>connectionNum <span class="token operator">=</span> connectionNum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token operator">+</span>databaseName<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>connectionNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>databaseName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>connectionNum<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>666<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变</li><li>这两块存在紧耦合，具体该如何解决?</li></ul><p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，大家都以了解为主。</p><p>方式一:删除name属性，添加type属性，按照类型注入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种方式可以解决构造函数形参名发生变化带来的耦合问题</li><li>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</li></ul><p>方式二:删除type属性，添加index属性，按照索引下标注入，下标从0开始</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种方式可以解决参数类型重复问题</li><li>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</li></ul><p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul><li>强制依赖指对象在创建的过程中必须要注入指定的参数</li></ul></li><li>可选依赖使用setter注入进行，灵活性强<ul><li>可选依赖指对象在创建过程中注入的参数可有可无</li></ul></li></ol><h4 id="依赖自动装配"><a href="#依赖自动装配" class="headerlink" title="依赖自动装配"></a>依赖自动装配</h4><p>IoC容器根据bean所依赖的资源<strong>在容器中自动查找并注入到bean中的过程称</strong>为自动装配</p><p>自动装配只需要修改applicationContext.xml配置文件即可:</p><p>(1)将<code>&lt;property&gt;</code>标签删除</p><p>(2)在<code>&lt;bean&gt;</code>标签中添加autowire属性</p><p>首先来实现按照类型注入的配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byType<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意事项:==</p><ul><li>需要注入属性的类中<strong>对应属性的setter方法不能省略</strong></li><li><strong>被注入的对象必须要被Spring的IOC容器管理</strong></li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li></ul><p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要<strong>按照名称注入</strong>，配置方式为:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byName<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意事项:==</p><ul><li><p><strong>按照名称注入中的名称指的是什么?</strong></p><img src="/2024/05/21/ssm/1629806856156.png" alt="1629806856156" style="zoom:80%;"><ul><li>bookDao是private修饰的，外部类无法直接方访问</li><li>外部类只能通过属性的set方法进行访问</li><li>==========<strong>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名</strong>=============<ul><li>为什么是去掉set首字母小写?</li><li>这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名</li></ul></li><li>所以按照名称注入，其实是和对应的set方法有关，但是<strong>如果按照标准起名称，属性名和set对应的名是一致的</strong></li></ul></li><li><p>如果按照名称去找对应的bean对象，<strong>找不到则注入Null</strong></p></li><li><p>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</p></li></ul><p>两种方式介绍完后，以后用的<strong>更多的是==按照类型==注入。</strong></p><p>最后对于依赖注入，需要注意一些其他的配置特征:</p><ol><li>自动装配<strong>用于引用类型依赖注入</strong>，因为被注入的对象必须要被Spring的IOC容器管理，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中<strong>相同类型的bean唯一</strong>，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中<strong>具有指定名称的bean</strong>，因<strong>变量名与配置耦合，不推荐使用</strong></li><li>自动装配优先级低于setter注入与构造器注入，<strong>同时出现时自动装配配置失效</strong></li></ol><h4 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h4><p>下面的配置方式，都是在bookDao的bean标签中使用<property>进行注入</property></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注入数组类型数据"><a href="#注入数组类型数据" class="headerlink" title="注入数组类型数据"></a>注入数组类型数据</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>array<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>100<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>200<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>300<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注入Map"><a href="#注入Map" class="headerlink" title="注入Map"></a>注入Map</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>country<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>china<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>province<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>henan<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>kaifeng<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注入Properties类型数据"><a href="#注入Properties类型数据" class="headerlink" title="注入Properties类型数据"></a>注入Properties类型数据</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>properties<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>props</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>country<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>china<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>province<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>henan<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>kaifeng<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>props</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BeanFactory-与-FactoryBean-的区别"><a href="#BeanFactory-与-FactoryBean-的区别" class="headerlink" title="BeanFactory 与 FactoryBean 的区别"></a>BeanFactory 与 FactoryBean 的区别</h3><p><strong>BeanFactory</strong></p><ul><li><p>BeanFactory<strong>定义了IOC容器的最基本形式</strong>，并提供了IOC容器应遵守的的最基本的接口，也就是SpringIOC所遵守的最底层和最基本的编程规范。</p></li><li><p>它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。在Spring代码中，BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，都是附加了某种功能的实现。</p></li><li><p>BeanFactory</p><ul><li>使用BeanFactory创建的容器是延迟加载</li><li>使用ApplicationContext创建的容器是立即加载</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">BeansException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">ResolvableType</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token constant">FACTORY_BEAN_PREFIX</span> <span class="token operator">=</span> <span class="token string">"&amp;"</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> var1<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isTypeMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">ResolvableType</span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isTypeMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAliases</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>FactoryBean</strong></p><ul><li>一般情况下，Spring通过反射机制利用的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案.</li><li>Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean的形式</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">T</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在该接口中还定义了以下3个方法：</p><ul><li>T getObject()返回由FactoryBean创建的Bean实例，如果isSingleton()返回true，则该实例会放到Spring容器中单实例缓存池中；</li><li>boolean isSingleton()：返回由FactoryBean创建的Bean实例的作用域是singleton还是prototype；</li><li>Class getObjectType()：返回FactoryBean创建的Bean类型。当配置文件中的class属性配置的实现类是FactoryBean时，通过getBean()方法返回的不是FactoryBean本身，而是FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。<br>例：如果使用传统方式配置下面Car的时，Car的每个属性分别对应一个元素标签。</li></ul><h3 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h3><p><strong>创建 Bean 的实例</strong>：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</p><p><strong>Bean 属性赋值/填充</strong>：为 Bean 设置相关属性和依赖，例如<code>@Autowired</code> 等注解注入的对象、<code>@Value</code> 注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</p><p><strong>Bean 初始化</strong>： </p><ul><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li><strong>给bean对象设置属性</strong>：如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li><strong>bean对象初始化之前操作</strong>：如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 <code>init-method</code> 属性，执行指定的方法。</li><li><strong>bean对象初始化之后操作</strong>：如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法。</li></ul><p><strong>销毁 Bean</strong>：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。 </p><ul><li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li></ul><img src="/2024/05/21/ssm/spring-bean-lifestyle.png" alt="img" style="zoom:80%;"><h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。</p><h4 id="注解开发定义bean（2-5）"><a href="#注解开发定义bean（2-5）" class="headerlink" title="注解开发定义bean（2. 5）"></a>注解开发定义bean（2. 5）</h4><p><strong>步骤1:删除原XML配置</strong></p><p>将配置文件中的<code>&lt;bean&gt;</code>标签删除掉</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>步骤2:Dao上添加注解</strong></p><p>在BookDaoImpl类上添加<code>@Component</code>注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意:@Component注解不可以添加在接口上，因为接口是无法创建对象的。==</p><p>XML与注解配置的对应关系:</p><img src="/2024/05/21/ssm/1629990315619.png" alt="1629990315619" style="zoom:80%;"><p><strong>步骤3:配置Spring的注解包扫描</strong></p><p>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明:</strong></p><p>component-scan</p><ul><li>component:组件,<strong>Spring将管理的bean视作自己的一个组件</strong></li><li>scan:扫描</li></ul><p>base-package<strong>指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</strong></p><ul><li>包路径越多[如:com.itheima.dao.impl]，扫描的范围越小速度越快</li><li>包路径越少[如:com.itheima],扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下[如:com.itheima]即可。</li></ul><h4 id="纯注解开发（3-0）"><a href="#纯注解开发（3-0）" class="headerlink" title="纯注解开发（3.0）"></a>纯注解开发（3.0）</h4><p>实现思路：将配置文件applicationContext.xml删除掉，使用类来替换。</p><ul><li><p>Java类（SpringConfig）替换Spring核心配置文件（ApplicationContext）</p><img src="/2024/05/21/ssm/1630029254372.png" alt="1630029254372" style="zoom:80%;"></li><li><p>@Configuration注解用于设定当前类为配置类</p></li><li><p>@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</p><pre class="line-numbers language-none"><code class="language-none">@ComponentScan({com.itheima.service","com.itheima.dao"})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 加载配置文件初始化容器</span><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 加载配置类初始化容器</span><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="注解相关问题"><a href="#注解相关问题" class="headerlink" title="注解相关问题"></a>注解相关问题</h3><h4 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些"></a>将一个类声明为 Bean 的注解有哪些</h4><ul><li><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</li></ul><p>通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是<strong>在@Component注解的基础上起了三个新的名字</strong>。</p><p>对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。</p><p>注意：虽然它们<strong>本质上一样</strong>，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。</p><h4 id="Component-和-Bean-的区别是什么"><a href="#Component-和-Bean-的区别是什么" class="headerlink" title="@Component 和 @Bean 的区别是什么"></a>@Component 和 @Bean 的区别是什么</h4><ul><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。**<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。**</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的<strong>自定义性更强</strong>，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我<strong>们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</strong></li></ul><p><code>@Bean</code>注解使用示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码相当于下面的 xml 配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transferService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.acme.TransferServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>@Bean注解的作用是将方法的返回值制作为Spring管理的一个bean对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">DataSource</span> <span class="token function">dataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">DruidDataSource</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DruidDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/spring_db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ds<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意:不能使用<code>DataSource ds = new DruidDataSource()</code></strong></p><p>因为DataSource接口中没有对应的setter方法来设置属性。</p><h4 id="注入-Bean-的注解有哪些"><a href="#注入-Bean-的注解有哪些" class="headerlink" title="注入 Bean 的注解有哪些"></a>注入 Bean 的注解有哪些</h4><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th>Annotation</th><th>Package</th><th>Source</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td><code>org.springframework.bean.factory</code></td><td>Spring 2.5+</td></tr><tr><td><code>@Resource</code></td><td><code>javax.annotation</code></td><td>Java JSR-250</td></tr><tr><td><code>@Inject</code></td><td><code>javax.inject</code></td><td>Java JSR-330</td></tr></tbody></table><p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p><h4 id="Autowired-和-Resource-的区别是什么"><a href="#Autowired-和-Resource-的区别是什么" class="headerlink" title="@Autowired 和 @Resource 的区别是什么"></a>@Autowired 和 @Resource 的区别是什么</h4><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会<strong>优先根据接口类型去匹配并注入 Bean</strong> （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> <strong>当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了</strong>，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p><strong>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。</strong>就比如说下面代码中的 <code>smsService</code> 就是我这里所说的名称，这样应该比较好理解了吧。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// smsService 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><span class="token comment">// smsServiceImpl1 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还是建议通过 <code>@Qualifier</code> 注解来显式指定名称而不是依赖变量的名称。</p><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p><p>简单总结一下：</p><ul><li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li><li><strong><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用</strong>。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li></ul><p>为什么不需要set方法：</p><ul><li>@Autowired可以写在属性上，也可也写在setter方法上，最简单的处理方式是<code>写在属性上并将setter方法删除掉</code></li><li>为什么setter方法可以删除呢?<ul><li><strong>自动装配基于反射设计创建对象并通过暴力反射为私有属性进行设值</strong></li><li>普通反射只能获取public修饰的内容</li><li><strong>暴力反射除了获取public修饰的内容还可以获取private修改的内容</strong></li><li>所以此处无需提供setter方法</li></ul></li></ul><h3 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h3><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p><p><strong>步骤1：resource下准备properties文件</strong></p><p>jdbc.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">name</span><span class="token punctuation">=</span><span class="token value attr-value">itheima888</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>步骤2: 使用注解加载properties配置文件</strong></p><p>在配置类上添加<code>@PropertySource</code>注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.itheima"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token string">"jdbc.properties"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤3：使用@Value读取配置文件中的内容</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Repository</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${name}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bean作用范围"><a href="#bean作用范围" class="headerlink" title="bean作用范围"></a>bean作用范围</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 <strong>bean 默认都是单例的</strong>，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，<strong>连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</strong></li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application/global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml 方式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>singleton<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注解方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">personPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bean-是线程安全的吗"><a href="#Bean-是线程安全的吗" class="headerlink" title="Bean 是线程安全的吗"></a>Bean 是线程安全的吗</h3><p>Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。</p><p>我们这里以最常用的两种作用域 prototype 和 singleton 为例介绍。几乎所有场景的 Bean 作用域都是使用默认的 singleton ，重点关注 singleton 作用域即可。</p><blockquote><p>prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。<strong>如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。</strong></p><p>不过，大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p></blockquote><p>对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：</p><ol><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="==Spring AOP=="></a>==Spring AOP==</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它是通过预编译方式和运行期动态代理方式实现在<strong>不修改源代码的情况下给程序动态统一添加额外功能</strong>的一种技术。</p></li><li><p>OOP(Object Oriented Programming)面向对象编程</p></li><li><p>作用：在不修改原始设计的基础上为其进行功能增强。利用Aop可以对业务逻辑的<strong>各个部分进行隔离</strong>，从而使得业务逻辑各个部分之间的**<code>耦合度</code>降低<strong>，提高程序的</strong>可重用性**，同时提高可开发效率</p></li></ul><blockquote><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些<strong>与业务无关，却为业务模块所共同调用的逻辑或责任</strong>（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是<strong>基于动态代理</strong>的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p></blockquote><img src="/2024/05/21/ssm/230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess"><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p><strong>1.横切关注点</strong></p><p>从每个方法中抽取出来的<strong>同一类非核心业务</strong>。在同一个项目中，我们可以使用多个横切关注点对相关的方法进行多个不同方面的增强。</p><p>这个概念不是语法层面天然存在的，而是<strong>根据附加功能的逻辑上的需要</strong>：有十个附加功能，就有十个横切关注点。</p><p><strong>2.通知</strong></p><p>每一个横切关注点上<strong>要做的事情</strong>都需要写一个方法来实现，这样的方法就叫<strong>通知方法</strong>。</p><ul><li><p>前置通知：在被代理的目标方法前执行</p></li><li><p>返回通知：在被代理的目标方法成功结束后执行（寿终正寝）</p></li><li><p>异常通知：在被代理的目标方法异常结束后执行（死于非命）</p></li><li><p>后置通知：在被代理的目标方法最终结束后执行（盖棺定论）</p></li><li><p>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</p></li></ul><p><strong>3.切面</strong></p><p>封装通知方法的类</p><p><strong>4.目标</strong></p><p>被代理的目标对象</p><p><strong>5.代理</strong></p><p>向目标对象应用通知之后创建的代理对象</p><p><strong>6.连接点</strong></p><p>这也是一个纯逻辑概念，不是语法定义的。</p><ul><li>把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。</li><li><strong>程序执行过程中的任意位置</strong>，粒度为执行方法、抛出异常、设置变量等</li></ul><img src="/2024/05/21/ssm/23.png" alt="23" style="zoom: 67%;"><p><strong>7.切入点</strong></p><p>定位连接点的方式。（<strong>匹配连接点的式子</strong>）</p><p>如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。</p><p>Spring 的 AOP 技术可以通过切入点定位到特定的连接点。切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。<br>连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是<strong>连接点的方法就不一定要被增强，所以可能不是切入点。</strong></p><h3 id="基于注解的AOP"><a href="#基于注解的AOP" class="headerlink" title="基于注解的AOP"></a>基于注解的AOP</h3><p>案例设定：测算接口执行效率，但是这个案例稍微复杂了点，我们对其进行简化。</p><p>简化设定：在方法执行前输出当前系统时间。</p><blockquote><p>1.导入坐标(pom.xml)</p><p>2.制作连接点(原始操作，Dao接口与实现类)</p><p>3.制作共性功能(通知类与通知)</p><p>4.定义切入点</p><p>5.绑定切入点与通知关系(切面)</p></blockquote><ul><li><p>pom.xml添加Spring依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.2.10.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加BookDao和BookDaoImpl类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Repository</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao update ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建Spring的配置类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.itheima"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写App运行类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BookDao</span> bookDao <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>我们要使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能。</p><h4 id="AOP实现"><a href="#AOP实现" class="headerlink" title="AOP实现"></a>AOP实现</h4><p><strong>步骤1:添加依赖</strong></p><p>pom.xml</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.aspectj<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aspectjweaver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.9.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤2:定义接口与实现类</strong></p><pre class="line-numbers language-none"><code class="language-none">环境准备的时候，BookDaoImpl已经准备好，不需要做任何修改<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>步骤3:定义通知类和通知</strong></p><p>通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类名和方法名没有要求，可以任意。</p><p><strong>步骤4:定义切入点</strong></p><p>BookDaoImpl中有两个方法，分别是save和update，我们<strong>要增强的是update方法</strong>，该如何定义呢?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明:</strong></p><ul><li>切入点定义<strong>依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</strong></li><li>execution及后面编写的内容，后面会有章节专门去学习。</li></ul><p><strong>步骤5:制作切面</strong></p><p>切面是用来描述通知和切入点之间的关系，如何进行关系的绑定?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span><span class="token comment">// 设置切入点方法</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span><span class="token comment">// 设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行==位置==</strong></p><img src="/2024/05/21/ssm/1630148447689.png" alt="1630148447689" style="zoom:80%;"><p><strong>说明:</strong>@Before翻译过来是之前，也就是说<strong>通知会在切入点方法执行之前执行，</strong>除此之前还有其他四种类型，后面会讲。</p><p><strong>步骤6:将通知类配给容器并标识其为切面类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token comment">// 设置当前类为AOP切面类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤7:开启注解格式AOP功能</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.itheima"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token comment">// 开启注解格式AOP功能</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤8:运行程序</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BookDao</span> bookDao <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到在执行update方法之前打印了系统时间戳，说明对原始方法进行了增强，AOP编程成功。</p><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul><li>切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类/接口名.方法名(参数) 异常名）</li></ul><p>对于这个格式，我们不需要硬记，通过一个例子，理解它:</p><pre class="line-numbers language-none"><code class="language-none">execution(public User com.itheima.service.UserService.findById(int))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>public:访问修饰符,还可以是public，private等，可以省略</li><li>User：返回值，写返回值类型</li><li>com.itheima.service：包名，多级包使用点连接</li><li>UserService:类/接口名称</li><li>findById：方法名</li><li>int:参数，直接写参数的类型，多个类型用逗号隔开</li><li>异常名：方法定义中抛出指定异常，可以省略</li></ul><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>我们使用通配符描述切入点，主要的目的就是简化之前的配置，具体都有哪些通配符可以使用?</p><ul><li><p><code>*</code>:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><pre class="line-numbers language-none"><code class="language-none">execution（public * com.itheima.*.UserService.find*(*))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p></li><li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p><pre class="line-numbers language-none"><code class="language-none">execution（public User com..UserService.findById(..))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法</p></li><li><p><code>+</code>：专用于匹配子类类型</p><pre class="line-numbers language-none"><code class="language-none">execution(* *..*Service+.*(..))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个使用率较低，描述子类的，咱们做JavaEE开发，继承机会就一次，使用都很慎重，所以很少用它。*Service+，表示所有以Service结尾的接口的子类。</p></li></ul><h5 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h5><ul><li>描述切入点通**==常描述接口==**，而不描述实现类,如果描述到实现类，就出现紧耦合了</li><li>访问控制修饰符针对接口开发均采用public描述（**==可省略访问控制修饰符描述==**）</li><li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述</li><li>**==包名==<strong>书写</strong>==尽量不使用..匹配==**，效率过低，常用*做单个包描述匹配，或精准匹配</li><li>**==接口名/类名==<strong>书写名称与模块相关的</strong>==采用*匹配==**，例如UserService书写成*Service，绑定业务层接口名</li><li>**==方法名==<strong>书写以</strong>==动词==<strong>进行</strong>==精准匹配==*<em>，名词采用</em>匹配，例如getById书写成getBy*,selectAll书写成selectAll</li><li>参数规则较为复杂，根据业务方法灵活调整</li><li>通常**==不使用异常==<strong>作为</strong>==匹配==**规则</li></ul><h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><img src="/2024/05/21/ssm/1630166147697.png" alt="1630166147697" style="zoom:80%;"><p>(1)前置通知，追加功能到方法执行前,类似于在代码1或者代码2添加内容</p><p>(2)后置通知,追加功能到方法执行后,不管方法执行的过程中有没有抛出异常都会执行，类似于在代码5添加内容</p><p>(3)返回后通知,追加功能到方法执行后，只有方法正常执行结束后才进行,类似于在代码3添加内容，如果方法执行抛出异常，返回后通知将不会被添加</p><p>(4)抛出异常后通知,追加功能到方法抛出异常后，只有方法执行出异常才进行,类似于在代码4添加内容，只有方法抛出异常后才会被添加</p><p>(5)环绕通知,环绕通知功能比较强大，它可以追加功能到方法执行的前后，这也是比较常用的方式，它可以实现其他四种通知类型的功能，具体是如何实现的，需要我们往下学习。</p><p><strong>各种通知</strong></p><p>如果我们使用环绕通知的话，要根据原始方法的返回值来设置环绕通知的返回值，具体解决方案为:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(int com.itheima.dao.BookDao.select())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"pt2()"</span><span class="token punctuation">)</span><span class="token comment">// 返回后通知</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterReturning</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"afterReturning advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"pt2()"</span><span class="token punctuation">)</span>    <span class="token comment">// 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">aroundSelect</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> pjp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"around before advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//表示对原始操作的调用</span>        <span class="token class-name">Object</span> ret <span class="token operator">=</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"around after advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明:</strong></p><p>​为什么返回的是Object而不是int的主要原因是Object类型更通用。</p><p>​在环绕通知中是可以对原始方法返回值就行修改的。</p><h3 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h3><p><strong>流程1:Spring容器启动</strong></p><ul><li>容器启动就需要去加载bean,哪些类需要被加载呢?</li><li><strong>需要被增强的类，如:BookServiceImpl</strong></li><li><strong>通知类，如:MyAdvice</strong></li><li>注意此时<strong>bean对象还没有创建成功</strong></li></ul><p><strong>流程2:读取所有切面配置中的切入点</strong></p><ul><li><p>上面这个例子中有两个切入点的配置，但是第一个<code>ptx()</code>并没有被使用，所以不会被读取。</p><img src="/2024/05/21/ssm/1630151682428.png?lastModify=171635275" alt="1630151682428" style="zoom: 67%;"></li></ul><p><strong>流程3:初始化bean</strong></p><p>判定bean对应的<strong>类中的方法是否匹配到任意切入点</strong></p><ul><li>注意第1步在容器启动的时候，bean对象还没有被创建成功。</li><li>要被实例化bean对象的类中的方法和切入点进行匹配</li><li>匹配失败，创建原始对象,如<code>UserDao</code><ul><li>匹配失败说明不需要增强，直接调用原始对象的方法即可。</li></ul></li><li>匹配成功，<strong>创建原始对象（==目标对象==）的==代理==对象,如:<code>BookDao</code></strong><ul><li>匹配成功说明需要对其进行增强</li><li>对哪个类做增强，这个类对应的对象就叫做目标对象</li><li>因为<strong>要对目标对象进行功能增强，而采用的技术是动态代理，所以会为其创建一个代理对象</strong></li><li>最终运行的是<strong>代理对象的方法</strong>，在该方法中会对原始方法进行功能增强</li></ul></li></ul><p><strong>流程4:获取bean执行方法</strong></p><ul><li>获取的bean是原始对象时，调用方法并执行，完成操作</li><li>获取的bean是代理对象时，<strong>根据代理对象的运行模式运行原始方法与增强的内容</strong>，完成操作</li></ul><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><p>在上面介绍AOP的工作流程中，我们提到了两个核心概念，分别是:</p><ul><li>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</li><li>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li></ul><p>上面这两个概念比较抽象，简单来说，</p><p>目标对象就是要增强的类[如:BookServiceImpl类]对应的对象，也叫原始对象，不能说它不能运行，只能说它在运行的过程中对于要增强的内容是缺失的。</p><p>SpringAOP是在不改变原有设计(代码)的前提下对其进行增强的，它的底层采用的是<strong>代理模式</strong>实现的，所以要对原始对象进行增强，就需要对原始对象创建代理对象，<strong>在代理对象中的方法把通知[如:MyAdvice中的method方法]内容加进去，就实现了增强,这就是我们所说的代理(Proxy)。</strong></p><h3 id="AOP的优点"><a href="#AOP的优点" class="headerlink" title="AOP的优点"></a>AOP的优点</h3><ol><li><p><strong>模块化</strong>: AOP可以将横向关注点与纵向业务逻辑分离，从而实现模块化，使代码更加清晰易懂，易于维护和扩展；</p></li><li><p><strong>可重用性</strong>: AOP可以将横向关注点作为独立的模块，从而使这些模块可以被多个应用程序共用，提高代码的可重用性；</p></li><li><p><strong>简化代码</strong>: AOP可以用比传统方法更少的代码来实现同样的功能，从而简化代码，提高代码的可读性和可维护性；</p></li><li><p><strong>提高程序的灵活性</strong>: AOP可以通过将横向关注点独立出来，使得程序的各个模块之间的耦合度降低，从而提高程序的灵活性，便于进行功能扩展和修改；</p></li><li><p><strong>提高程序的安全性</strong>: AOP<strong>可以通过将安全控制与业务逻辑分离，提高程序的安全性，减少潜在的安全漏洞。</strong></p></li></ol><hr><p>可以使用@Order注解来控制切面的顺序。在同一个方法上应用多个切面时，可以为每个切面添加不同的@Order值，值越小的切面将先执行，值越大的切面将后执行。如果没有指定@Order值，则默认优先级为0。</p><h3 id="拦截器和aop的区别"><a href="#拦截器和aop的区别" class="headerlink" title="拦截器和aop的区别"></a>拦截器和aop的区别</h3><p>拦截器和AOP在以下四个方面存在区别：</p><blockquote><p>定义和用途：拦截器是一种<strong>设计模式</strong>，拦截器可以在方法调用之前、之后或异常发生时插入额外的逻辑，常见于各种编程语言和框架，如Java的Servlet过滤器、Spring的拦截器等。在Java中，拦截器通常与AOP框架结合使用。拦截器可以在<strong>方法级别或类级别</strong>进行配置，并按照一定的顺序依次执行。</p><p>AOP是一种<strong>编程范式</strong>，旨在通过<strong>将跨越多个对象和层的功能（称为“切面”）从业务逻辑中解耦出来，实现横切关注点的复用</strong>。AOP可以在不修改原始代码的情况下，将切面应用于一个或多个目标对象，以增加特定功能，例如<strong>日志记录、事务管理、性能监控</strong>等。</p><p>拦截对象：拦截器主要针对<strong>URL</strong>进行拦截，而AOP针对的是<strong>具体的代码</strong>，能够实现更加复杂的业务逻辑。</p><p>灵活性：AOP更加灵活，可以对方法进行拦截，也可以对类进行拦截，而拦截器只能对特定的URL或者action进行拦截。</p><p>实现方式：拦截器和AOP都是使用<strong>代理模式</strong>实现，但AOP还包含一种特殊的代理，即CGLib代理。这种代理可以针对类进行代理，而不仅仅是对接口进行代理。</p></blockquote><p>总结来说，拦截器和AOP在定义和用途、拦截对象、灵活性和实现方式上存在区别。拦截器主要用于过滤和拦截特定URL或action，而AOP主要用于解耦和复用横切关注点。</p><h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别"></a>Spring AOP 和 AspectJ AOP 有什么区别</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>SpringMVC是一种<strong>基于Java实现MVC模型</strong>的轻量级Web框架，隶属于Spring框架的一部分，对Servlet进行了封装。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC 是<strong>模型(Model)、视图(View)、控制器(Controller)<strong>的简写，其核心思想是通过将</strong>业务逻辑、数据、显示</strong>分离来组织代码。</p><img src="/2024/05/21/ssm/image-20210809181452421.png" alt="img"><blockquote><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><p>MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p></blockquote><h3 id="SpringMVC-的核心组件"><a href="#SpringMVC-的核心组件" class="headerlink" title="SpringMVC 的核心组件"></a>SpringMVC 的核心组件</h3><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p><ul><li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h3 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h3><img src="/2024/05/21/ssm/de6d2b213f112297298f3e223bf08f28.png" alt="img"><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li><li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><h3 id="Spring-框架用到了哪些设计模式"><a href="#Spring-框架用到了哪些设计模式" class="headerlink" title="Spring 框架用到了哪些设计模式"></a>Spring 框架用到了哪些设计模式</h3><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h3 id="Spring循环依赖-三级缓存"><a href="#Spring循环依赖-三级缓存" class="headerlink" title="Spring循环依赖-三级缓存"></a>Spring循环依赖-三级缓存</h3><p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%86%E8%A7%A3%E5%90%97-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%86%E8%A7%A3%E5%90%97-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3</a></p><p>Spring 框架通过使用三级缓存来解决这个问题，确保即使在循环依赖的情况下也能正确创建 Bean。</p><p>Spring 中的三级缓存其实就是三个 Map，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 一级缓存</span><span class="token comment">/** Cache of singleton objects: bean name to bean instance. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 二级缓存</span><span class="token comment">/** Cache of early singleton objects: bean name to bean instance. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 三级缓存</span><span class="token comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>一级缓存（singletonObjects）</strong>：存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。一般情况我们获取 Bean 都是从这里获取的，但是并不是所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。</p><p><strong>二级缓存（earlySingletonObjects）</strong>：存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中<code>ObjectFactory</code>产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用<code>ObjectFactory#getObject()</code>都是会产生新的代理对象的。</p><p><strong>三级缓存（singletonFactories）</strong>：存放<code>ObjectFactory</code>，<code>ObjectFactory</code>的<code>getObject()</code>方法（最终调用的是<code>getEarlyBeanReference()</code>方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。</p></blockquote><p>接下来说一下 Spring 创建 Bean 的流程：</p><ol><li>先去 <strong>一级缓存 <code>singletonObjects</code></strong> 中获取，存在就返回；</li><li>如果不存在或者对象正在创建中，于是去 <strong>二级缓存 <code>earlySingletonObjects</code></strong> 中获取；</li><li>如果还没有获取到，就去 <strong>三级缓存 <code>singletonFactories</code></strong> 中获取，通过执行 <code>ObjectFacotry</code> 的 <code>getObject()</code> 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。</li></ol><p>解决循环依赖的流程如下：</p><ul><li>当 Spring 创建 A 之后，发现 A 依赖了 B ，又去创建 B，B 依赖了 A ，又去创建 A；</li><li>在 B 创建 A 的时候，那么此时 A 就发生了循环依赖，由于 A 此时还没有初始化完成，因此在 <strong>一二级缓存</strong> 中肯定没有 A；</li><li>那么此时就去三级缓存中调用 <code>getObject()</code> 方法去获取 A 的 <strong>前期暴露的对象</strong> ，也就是调用上边加入的 <code>getEarlyBeanReference()</code> 方法，生成一个 A 的 <strong>前期暴露对象</strong>；</li><li>然后就将这个 <code>ObjectFactory</code> 从三级缓存中移除，并且将前期暴露对象放入到二级缓存中，那么 B 就将这个前期暴露对象注入到依赖，来支持循环依赖。</li></ul><blockquote><p><strong>最后总结一下 Spring 如何解决三级缓存</strong>：</p><p>在三级缓存这一块，主要记一下 Spring 是如何支持循环依赖的即可，也就是如果发生循环依赖的话，就去 <strong>三级缓存 <code>singletonFactories</code></strong> 中拿到三级缓存中存储的 <code>ObjectFactory</code> 并调用它的 <code>getObject()</code> 方法来获取这个循环依赖对象的前期暴露对象（虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了），并且将这个前期暴露对象放到二级缓存中，这样在循环依赖时，就不会重复初始化了！</p><p>不过，这种机制也有一些缺点，比如增加了内存开销（需要维护三级缓存，也就是三个 Map），降低了性能（需要进行多次检查和转换）。并且，还有少部分情况是不支持循环依赖的，比如非单例的 bean 和<code>@Async</code>注解的 bean 无法支持循环依赖。</p></blockquote><h4 id="Lazy能解决循环依赖吗"><a href="#Lazy能解决循环依赖吗" class="headerlink" title="@Lazy能解决循环依赖吗"></a>@Lazy能解决循环依赖吗</h4><p><code>@Lazy</code> 用来标识类是否需要懒加载/延迟加载，可以作用在类上、方法上、构造器上、方法参数上、成员变量中。</p><p>Spring Boot 2.2 新增了全局懒加载属性，开启后全局 bean 被设置为懒加载，需要时再去创建。</p><p>配置文件配置全局懒加载：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#默认false</span><span class="token key attr-name">spring.main.lazy-initialization</span><span class="token punctuation">=</span><span class="token value attr-value">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编码的方式设置全局懒加载：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SpringApplication</span> springApplication<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">Start</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>springApplication<span class="token punctuation">.</span><span class="token function">setLazyInitialization</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>springApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如非必要，尽量不要用全局懒加载。<strong>全局懒加载会让 Bean 第一次使用的时候加载会变慢，并且它会延迟应用程序问题的发现</strong>（当 Bean 被初始化时，问题才会出现）。</p><p>如果一个 Bean 没有被标记为懒加载，那么它会在 Spring IoC 容器启动的过程中被创建和初始化。如果一个 Bean 被标记为懒加载，那么<strong>它不会在 Spring IoC 容器启动时立即实例化，而是在第一次被请求时才创建</strong>。这可以帮助减少应用启动时的初始化时间，也可以用来解决循环依赖问题。</p><p>循环依赖问题是如何通过<code>@Lazy</code> 解决的呢？这里举一个例子，比如说有两个 Bean，A 和 B，他们之间发生了循环依赖，那么 A 的构造器上添加 <code>@Lazy</code> 注解之后（延迟 Bean B 的实例化），加载的流程如下：</p><ul><li>首先 Spring 会去创建 A 的 Bean，创建时需要注入 B 的属性；</li><li>由于在 A 上标注了 <code>@Lazy</code> 注解，因此 <strong>Spring 会去创建一个 B 的代理对象，将这个代理对象注入到 A 中的 B 属性；</strong></li><li>之后开始执行 B 的实例化、初始化，在注入 B 中的 A 属性时，此时 A 已经创建完毕了，就可以将 A 给注入进去。</li></ul><p>通过 <code>@Lazy</code> 就解决了循环依赖的注入， <strong>关键点就在于对 A 中的属性 B 进行注入时，注入的是 B 的代理对象，因此不会循环依赖。</strong></p><p>之前说的发生循环依赖是因为在对 A 中的属性 B 进行注入时，注入的是 B 对象，此时又会去初始化 B 对象，发现 B 又依赖了 A，因此才导致的循环依赖。</p><p>一般是不建议使用循环依赖的，但是如果项目比较复杂，可以使用 <code>@Lazy</code> 解决一部分循环依赖的问题。</p><h2 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h2><ul><li><p>==REST==（Representational State Transfer），表现形式状态转换,它是一种<strong>软件架构==风格==</strong></p><p>当我们想表示一个网络资源的时候，可以使用两种方式:</p><ul><li>传统风格资源描述形式<ul><li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li><li><code>http://localhost/user/saveUser</code> 保存用户信息</li></ul></li><li>REST风格描述形式<ul><li><code>http://localhost/user/1</code> </li><li><code>http://localhost/user</code></li></ul></li></ul></li></ul><p>传统方式一般是一个请求url对应一种操作，这样做不仅麻烦，也不安全。查看REST风格的描述，你会发现请求地址变的简单了，并且光看请求URL并不是很能猜出来该URL的具体功能</p><p>所以REST的优点有:</p><ul><li><strong>隐藏资源的访问行为</strong>，无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul><p>根据REST风格对资源进行访问称为==RESTful==。</p><h3 id="传递路径参数"><a href="#传递路径参数" class="headerlink" title="传递路径参数"></a>传递路径参数</h3><p>前端发送请求的时候使用:<code>http://localhost/users/1</code>,路径中的<code>1</code>就是我们想要传递的参数。</p><p>后端获取参数，需要做如下修改:</p><ul><li>修改@RequestMapping的value属性，将其中修改为<code>/users/{id}</code>，目的是和路径匹配</li><li>在方法的形参前添加@PathVariable注解：绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应</li></ul><img src="/2024/05/21/ssm/1630506231379.png" alt="1630506231379" style="zoom:80%;"><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token comment">//设置当前请求方法为PUT，表示REST风格中的修改操作</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/users"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">PUT</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user update..."</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'user update'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>将请求路径更改为<code>/users</code></p><ul><li>访问该方法使用 PUT: <code>http://localhost/users</code></li></ul></li><li><p>访问并携带参数:</p><img src="/2024/05/21/ssm/1630506507096.png" alt="1630506507096" style="zoom:80%;"></li></ul><p>关于接收参数，我们学过三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>,这三个注解之间的区别和应用分别是什么?</p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h3 id="RESTful快速开发"><a href="#RESTful快速开发" class="headerlink" title="RESTful快速开发"></a>RESTful快速开发</h3><p>做完了RESTful的开发，你会发现==好麻烦==，麻烦在哪?</p><img src="/2024/05/21/ssm/1630507339724.png" alt="1630507339724" style="zoom:80%;"><p>问题1：每个方法的@RequestMapping注解中都定义了访问路径/books，重复性太高。</p><p>问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。</p><p>问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。</p><p>对于上面所提的这三个问题，具体该如何解决?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span> <span class="token comment">// 设置当前控制器类为RESTful风格，等价于@Controller + ReponseBody</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">)</span><span class="token comment">// 将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookController</span> <span class="token punctuation">{</span>    <span class="token comment">//@RequestMapping(method = RequestMethod.POST)</span>    <span class="token annotation punctuation">@PostMapping</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book save..."</span> <span class="token operator">+</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book save'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(value = "/{id}",method = RequestMethod.DELETE)</span>    <span class="token comment">// 使用@GetMapping  @PostMapping  @PutMapping  @DeleteMapping代替requestmapping</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book delete..."</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book delete'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(method = RequestMethod.PUT)</span>    <span class="token annotation punctuation">@PutMapping</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book update..."</span> <span class="token operator">+</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book update'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(value = "/{id}",method = RequestMethod.GET)</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book getById..."</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book getById'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(method = RequestMethod.GET)</span>    <span class="token annotation punctuation">@GetMapping</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book getAll..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book getAll'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h3><p>分模块开发：将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享。</p><img src="/2024/05/21/ssm/1630768869208.png" alt="1630768869208" style="zoom: 50%;"><p>对于项目的拆分，大致会有如下几个步骤:</p><p>(1) 创建Maven模块</p><p>(2) 书写模块代码：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。拆分方式可以按照功能拆也可以按照模块拆。</p><p>(3)通过maven指令安装模块到本地仓库(install 指令)，在不同模块间引入依赖</p><p>团队内部开发需要发布模块功能到团队内部可共享的仓库中(私服)</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>依赖是具有传递性的:</p><img src="/2024/05/21/ssm/1630853726532.png" alt="1630853726532" style="zoom: 50%;"><p>**说明:**A代表自己的项目；B,C,D,E,F,G代表的是项目所依赖的jar包；D1和D2 E1和E2代表是相同jar包的不同版本</p><p>(1) A依赖了B和C,B和C有分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递</p><p>(2) 依赖传递有直接依赖和间接依赖</p><ul><li>相对于A来说，A直接依赖B和C,间接依赖了D1,E1,G，F,D2和E2</li><li>相对于B来说，B直接依赖了D1和E1,间接依赖了G</li><li>直接依赖和间接依赖是一个相对的概念</li></ul><p>(3)因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题，Maven是如何解决冲突的?</p><p>如果想避免传递依赖：</p><p><strong>方案1-可选依赖</strong>：可选依赖指对外隐藏当前所依赖的资源—不透明<optional>true</optional></p><p><strong>方案2-排除依赖</strong>：排除依赖指主动断开依赖的资源，被排除的资源无需指定版本—不需要</p><h3 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h3><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li>所谓聚合：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的”空”工程（有且仅有一个pom文件）</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建<ul><li>当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。</li></ul></li></ul><p>聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>所谓继承：描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</li><li>作用：简化配置；减少版本冲突</li></ul><p>步骤1:创建一个空的Maven项目并将其打包方式设置为pom</p><p>步骤2:在子项目中设置其父工程</p><p>步骤3:优化子项目共有依赖导入问题（将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中）</p><p>步骤4:优化子项目依赖版本问题</p><p><strong>父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</strong>。</p><p>聚合和继承的作用:</p><ul><li>聚合用于快速构建项目，对项目进行管理</li><li>继承用于快速配置和管理子项目中所使用jar包的版本</li></ul><p>聚合和继承的相同点:</p><ul><li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>聚合与继承均属于设计型模块，并无实际的模块内容</li></ul><p>聚合和继承的不同点:</p><ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul><h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3><ul><li><p>父工程中定义多环境</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profiles</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>环境名称<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">&gt;</span></span>value<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activation</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activation</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">&gt;</span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profiles</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用多环境(构建过程)</p><pre class="line-numbers language-none"><code class="language-none">mvn 指令 -P 环境定义ID[环境定义中获取]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p><code>SpringBoot</code> 是由Pivotal团队提供的全新框架，其设计目的是用来==简化==Spring应用的==初始搭建==以及==开发过程==。</p><p>原始 <code>Spring</code> 环境搭建和开发存在以下问题：</p><ul><li>配置繁琐</li><li>依赖设置繁琐</li></ul><p><code>SpringBoot</code> 程序优点恰巧就是针对 <code>Spring</code> 的缺点</p><ul><li>自动配置。这个是用来解决 <code>Spring</code> 程序配置繁琐的问题</li><li>起步依赖。这个是用来解决 <code>Spring</code> 程序依赖设置繁琐的问题</li><li>辅助功能（内置服务器,…）。我们在启动 <code>SpringBoot</code> 程序时既没有使用本地的 <code>tomcat</code> 也没有使用 <code>tomcat</code> 插件，而是使用 <code>SpringBoot</code> 内置的服务器。</li></ul><img src="/2024/05/21/ssm/image-20210911172200292.png" alt="image-20210911172200292" style="zoom:80%;"><h3 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h3><p>我们使用 <code>Spring Initializr</code>  方式创建的 <code>Maven</code> 工程的的 <code>pom.xml</code> 配置文件中自动生成了很多包含 <code>spring-boot-starter</code> 的依赖，如下图</p><img src="/2024/05/21/ssm/image-20210918220338109.png" alt="image-20210918220338109" style="zoom: 80%;"><p>从上面的文件中可以看到指定了一个父工程，我们进入到父工程，发现父工程中又指定了一个父工程，如下图所示</p><img src="/2024/05/21/ssm/image-20210918220855024.png" alt="image-20210918220855024" style="zoom:80%;"><p>再进入到该父工程中，在该工程中我们可以看到配置内容结构如下图所示</p><img src="/2024/05/21/ssm/image-20210918221042947.png" alt="image-20210918221042947" style="zoom:80%;"><p>在 <code>properties</code> 中我们找 <code>servlet</code>  和 <code>mysql</code> 的版本如下图</p><img src="/2024/05/21/ssm/image-20210918221511249.png" alt="image-20210918221511249" style="zoom:80%;"><blockquote><p>上图中的 <code>properties</code> 标签中定义了各个技术软件依赖的版本，避免了我们在使用不同软件技术时考虑版本的兼容问题。</p><p><code>dependencyManagement</code> 标签是进行依赖版本锁定，但是并没有导入对应的依赖；如果我们工程需要那个依赖只需要引入依赖的 <code>groupid</code> 和 <code>artifactId</code> 不需要定义 <code>version</code>。</p></blockquote><p>而 <code>build</code> 标签中也对插件的版本进行了锁定，如下图</p><img src="/2024/05/21/ssm/image-20210918221942453.png" alt="image-20210918221942453" style="zoom:80%;"><p>看完了父工程中 <code>pom.xml</code> 的配置后不难理解我们工程的的依赖为什么都没有配置 <code>version</code>。</p><p>在我们创建的工程中的 <code>pom.xml</code> 中配置了如下依赖</p><img src="/2024/05/21/ssm/image-20210918222321402.png" alt="image-20210918222321402" style="zoom:80%;"><p>进入到该依赖，查看 <code>pom.xml</code> 的依赖会发现它引入了如下的依赖</p><img src="/2024/05/21/ssm/image-20210918222607469.png" alt="image-20210918222607469" style="zoom:80%;"><p>里面引入了 <code>spring-web</code> 和 <code>spring-webmvc</code> 的依赖，这就是为什么我们的工程中没有依赖这两个包还能正常使用 <code>springMVC</code> 中的注解的原因。</p><p>而依赖 <code>spring-boot-starter-tomcat</code> ，从名字基本能确认内部依赖了 <code>tomcat</code>，所以我们的工程才能正常启动。</p><p>==结论：以后需要使用技术，只需要引入该技术对应的起步依赖即可==</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><a href="https://blog.csdn.net/dreamstar613/article/details/90265078">https://blog.csdn.net/dreamstar613/article/details/90265078</a></p><img src="/2024/05/21/ssm/image-20240531092335394.png" alt="image-20240531092335394" style="zoom:80%;"><h2 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h2><p>MybatisPlus(简称MP)是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提供效率。</p><p>MP是MyBatis的一套增强工具，它是在MyBatis的基础上进行开发的，我们虽然使用MP但是底层依然是MyBatis的东西，也就是说我们也可以在MP中写MyBatis的内容。</p><p>官方文档：<a href="https://baomidou.com/introduce/">https://baomidou.com/introduce/</a></p><p>MP的特性:</p><ul><li>无侵入：只做增强不做改变，引入它不会对现有工程产生影响。</li><li>损耗小：启动即会自动注入基本CURD，性能基本无损耗，直接面向对象操作。</li><li>强大的CRUD操作：内置通用Mapper、通用Service，仅仅通过少量配置即可实现单表大部分CRUD操作，更有强大的条件构造器，满足各类使用需求。</li><li>支持Lambda形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错。</li><li>支持主键自动生成：支持多达4种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题。</li><li><strong>支持ActiveRecord模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作。</li><li>支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）。</li><li>内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎。</li><li>内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询。分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库。</li><li>内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询。</li><li>内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作。</li></ul><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>Lombok常见的注解有:</p><ul><li>@Setter:为模型类的属性提供setter方法</li><li>@Getter:为模型类的属性提供getter方法</li><li>@ToString:为模型类的属性提供toString方法</li><li>@EqualsAndHashCode:为模型类的属性提供equals和hashcode方法</li><li><strong>==@Data:是个组合注解，包含上面的注解的功能==</strong></li><li>==@NoArgsConstructor:提供一个无参构造函数==</li><li>==@AllArgsConstructor:提供一个包含所有参数的构造函数==</li></ul><h3 id="标准数据层开发"><a href="#标准数据层开发" class="headerlink" title="标准数据层开发"></a>标准数据层开发</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 插入一条记录</span><span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 entity 条件，删除记录</span><span class="token keyword">int</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除（根据ID 批量删除）</span><span class="token keyword">int</span> <span class="token function">deleteBatchIds</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">COLLECTION</span><span class="token punctuation">)</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> idList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 ID 删除，传入id</span><span class="token keyword">int</span> <span class="token function">deleteById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 columnMap 条件，删除记录</span><span class="token keyword">int</span> <span class="token function">deleteByMap</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">COLUMN_MAP</span><span class="token punctuation">)</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 whereEntity 条件，更新记录</span><span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">ENTITY</span><span class="token punctuation">)</span> <span class="token class-name">T</span> entity<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> updateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 ID 修改，传入的是entity</span><span class="token keyword">int</span> <span class="token function">updateById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">ENTITY</span><span class="token punctuation">)</span> <span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据条件，查询记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectList</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 查询，传入id</span><span class="token class-name">T</span> <span class="token function">selectById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span> <span class="token comment">// 查询（根据 columnMap 条件）</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectByMap</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">COLUMN_MAP</span><span class="token punctuation">)</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectMaps</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录。注意： 只返回第一个字段的值</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectObjs</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录（并分页）</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectPage</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录（并分页）</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectMapsPage</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询总记录数</span><span class="token class-name">Integer</span> <span class="token function">selectCount</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DQL编程"><a href="#DQL编程" class="headerlink" title="DQL编程"></a>DQL编程</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">Mybatisplus02DqlApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testGetAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 模拟页面传递过来的查询数据</span>        <span class="token class-name">UserQuery</span> uq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        uq<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        uq<span class="token punctuation">.</span><span class="token function">setAge2</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">LambdaQueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> lqw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LambdaQueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查询指定字段，对应语句 SELECT id,name,age FROM user</span>        lqw<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果前端传来的age2属性不为空，则添加 where age &lt; xx 的条件</span>        <span class="token comment">// 类名::方法名的lambda表达式获取查询条件，避免自己写"age"出错</span>        lqw<span class="token punctuation">.</span><span class="token function">lt</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">!=</span>uq<span class="token punctuation">.</span><span class="token function">getAge2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">,</span> uq<span class="token punctuation">.</span><span class="token function">getAge2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lqw<span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">!=</span>uq<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">,</span> uq<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 聚合和分组查询，不能用lambda</span>        lqw<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"count(*) as count,tel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lqw<span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span><span class="token string">"tel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/**         * condition ：条件，返回boolean，         当condition为true，进行排序，如果为false，则不排序         * isAsc:是否为升序，true为升序，false为降序         * columns：需要操作的列，这里是按id降序         */</span>        lqw<span class="token punctuation">.</span><span class="token function">orderBy</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> userList <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>lqw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MP只是对MyBatis的增强，如果MP实现不了，我们可以直接在DAO接口中使用MyBatis的方式实现</p><h3 id="映射兼容"><a href="#映射兼容" class="headerlink" title="映射兼容"></a>映射兼容</h3><p><strong>问题1:表字段与编码属性设计不同步</strong></p><p>当表的列名和模型类的属性名发生不一致，就会导致数据封装不到模型对象。</p><p>MP给我们提供了一个注解<code>@TableField</code>,使用该注解可以实现<strong>模型类属性名和表的列名之间的映射</strong>关系</p><p><strong>问题2:编码中添加了数据库中未定义的属性</strong></p><p>当模型类中多了一个数据库表不存在的字段，就会导致生成的sql语句中在select的时候查询了数据库不存在的字段，程序运行就会报错，错误信息为:  ==Unknown column ‘多出来的字段名称’ in ‘field list’==</p><p>具体的解决方案用到的还是<code>@TableField</code>注解，它有一个属性叫<code>exist</code>，设置该字段是否在数据库表中存在，如果设置为false则不存在，生成sql语句查询的时候，就不会再查询该字段了。</p><p><strong>问题3：采用默认查询开放了更多的字段查看权限</strong></p><p>查询表中所有的列的数据，就可能把一些敏感数据查询到返回给前端，这个时候我们就需要<strong>限制哪些字段默认不要进行查询</strong>。解决方案是<code>@TableField</code>注解的一个属性叫<code>select</code>，该属性设置默认是否需要查询该字段的值，true(默认值)表示默认查询该字段，false表示默认不查询该字段。</p><p><strong>问题4:表名与编码开发设计不同步</strong></p><p>该问题主要是表的名称和模型类的名称不一致，导致查询失败，这个时候通常会报如下错误信息:==Table ‘databaseName.tableNaem’ doesn’t exist==,翻译过来就是数据库中的表不存在。解决方案是使用MP提供的另外一个注解<code>@TableName</code>来设置表与模型类之间的对应关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@TableName</span><span class="token punctuation">(</span><span class="token string">"tbl_user"</span><span class="token punctuation">)</span><span class="token comment">// 映射数据库名</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"pwd"</span><span class="token punctuation">,</span>select<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">// 映射数据库表字段pwd，默认不要查询</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> tel<span class="token punctuation">;</span>    <span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>exist<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">// 表中不存在的字段</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> online<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DML编程"><a href="#DML编程" class="headerlink" title="DML编程"></a>DML编程</h3><h4 id="id生成"><a href="#id生成" class="headerlink" title="id生成"></a>id生成</h4><table><thead><tr><th>名称</th><th>@TableId</th></tr></thead><tbody><tr><td>类型</td><td>==属性注解==</td></tr><tr><td>位置</td><td>模型类中用于表示主键的属性定义上方</td></tr><tr><td>作用</td><td>设置当前类中主键属性的生成策略</td></tr><tr><td>相关属性</td><td>value(默认)：设置数据库表主键名称<br>type:设置主键属性的生成策略，值查照IdType的枚举值</td></tr></tbody></table><p> @TableId(type = IdType.AUTO) – 自增</p><ul><li>NONE: 不设置id生成策略</li><li>INPUT:用户手工输入id</li><li>ASSIGN_ID:雪花算法生成id(可兼容数值型与字符串型)</li><li>ASSIGN_UUID:以UUID生成算法作为id生成策略</li><li>其他的几个策略均已过时，都将被ASSIGN_ID和ASSIGN_UUID代替掉。</li></ul><p>对比：</p><ul><li>NONE: 不设置id生成策略，MP不自动生成，约等于INPUT,所以这两种方式都需要用户手动设置，但是手动设置第一个问题是容易出现相同的ID造成主键冲突，为了保证主键不冲突就需要做很多判定，实现起来比较复杂</li><li>AUTO:数据库ID自增,这种策略适合在数据库服务器只有1台的情况下使用,不可作为分布式ID使用</li><li>ASSIGN_UUID:可以在分布式的情况下使用，而且能够保证唯一，但是生成的主键是32位的字符串，长度过长占用空间而且还不能排序，查询性能也慢</li><li>ASSIGN_ID:可以在分布式的情况下使用，生成的是Long类型的数字，可以排序性能也高，但是生成的策略和服务器时间有关，如果修改了系统时间就有可能导致出现重复主键</li></ul><h4 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h4><p><strong>模型类主键策略设置</strong></p><p>对于主键ID的策略已经介绍完，但是如果要在项目中的每一个模型类上都需要使用相同的生成策略，如：</p><img src="/2024/05/21/ssm/1631245676125-1717399291442.png" alt="1631245676125" style="zoom:80%;"><p>确实是稍微有点繁琐，我们能不能在某一处进行配置，就能让所有的模型类都可以使用该主键ID策略呢?</p><p>答案是肯定有，我们只需要在配置文件中添加如下内容:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>    <span class="token key atrule">id-type</span><span class="token punctuation">:</span> assign_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成后，每个模型类的主键ID策略都将成为assign_id.</p><p><strong>数据库表与模型类的映射关系</strong></p><p>MP会默认将模型类的类名名首字母小写作为表名使用，假如数据库表的名称都以<code>tbl_</code>开头，那么我们就需要将所有的模型类上添加<code>@TableName</code>，如:</p><img src="/2024/05/21/ssm/1631245757169-1717399327044.png" alt="1631245757169" style="zoom:80%;"><p>配置起来还是比较繁琐，简化方式为在配置文件中配置如下内容:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>    <span class="token key atrule">table-prefix</span><span class="token punctuation">:</span> tbl_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置表的前缀内容，这样MP就会拿 <code>tbl_</code>加上模型类的首字母小写，就刚好组装成数据库的表名。</p><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><p><strong>@TableLogic</strong></p><table><thead><tr><th>名称</th><th>@TableLogic</th></tr></thead><tbody><tr><td>类型</td><td>==属性注解==</td></tr><tr><td>位置</td><td>模型类中用于表示删除字段的属性定义上方</td></tr><tr><td>作用</td><td>标识该字段为进行逻辑删除的字段</td></tr><tr><td>相关属性</td><td>value：逻辑未删除值<br>delval:逻辑删除值</td></tr></tbody></table><h3 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h3><h4 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>com<span class="token punctuation">.</span>baomidou<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>mybatis<span class="token operator">-</span>plus<span class="token operator">-</span>generator<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">3.5</span><span class="token number">.6</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于代码生成器用到了模板引擎，请自行引入您喜好的模板引擎。MyBatis-Plus Generator 支持如下模板引擎：</p><ul><li>VelocityTemplateEngine(Default)</li><li>FreemarkerTemplateEngine</li><li>BeetlTemplateEngine</li><li>EnjoyTemplateEngine</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>velocity<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>velocity<span class="token operator">-</span>engine<span class="token operator">-</span>core<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">2.3</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码生成类"><a href="#代码生成类" class="headerlink" title="代码生成类"></a>代码生成类</h5><p>在 CodeGenerator 中的 main 方法中直接添加生成器代码，并进行相关配置，然后直接运行即可生成代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">FastAutoGenerator</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">,</span> <span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">)</span>        <span class="token comment">// 全局配置</span>            <span class="token punctuation">.</span><span class="token function">globalConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                builder<span class="token punctuation">.</span><span class="token function">author</span><span class="token punctuation">(</span><span class="token string">"baomidou"</span><span class="token punctuation">)</span> <span class="token comment">// 设置作者</span>                        <span class="token punctuation">.</span><span class="token function">enableSwagger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 开启 swagger 模式</span>                        <span class="token punctuation">.</span><span class="token function">outputDir</span><span class="token punctuation">(</span><span class="token string">"D://"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指定输出目录</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token comment">// 数据源配置</span>            <span class="token punctuation">.</span><span class="token function">dataSourceConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span>                    builder<span class="token punctuation">.</span><span class="token function">typeConvertHandler</span><span class="token punctuation">(</span><span class="token punctuation">(</span>globalConfig<span class="token punctuation">,</span> typeRegistry<span class="token punctuation">,</span> metaInfo<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> typeCode <span class="token operator">=</span> metaInfo<span class="token punctuation">.</span><span class="token function">getJdbcType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token constant">TYPE_CODE</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>typeCode <span class="token operator">==</span> <span class="token class-name">Types</span><span class="token punctuation">.</span><span class="token constant">SMALLINT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment">// 自定义类型转换</span>                            <span class="token keyword">return</span> <span class="token class-name">DbColumnType</span><span class="token punctuation">.</span><span class="token constant">INTEGER</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">return</span> typeRegistry<span class="token punctuation">.</span><span class="token function">getColumnType</span><span class="token punctuation">(</span>metaInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token comment">// 包配置</span>            <span class="token punctuation">.</span><span class="token function">packageConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span>                    builder<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token string">"com.baomidou.mybatisplus.samples.generator"</span><span class="token punctuation">)</span> <span class="token comment">// 设置父包名</span>                            <span class="token punctuation">.</span><span class="token function">moduleName</span><span class="token punctuation">(</span><span class="token string">"system"</span><span class="token punctuation">)</span> <span class="token comment">// 设置父包模块名</span>                            <span class="token punctuation">.</span><span class="token function">pathInfo</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonMap</span><span class="token punctuation">(</span><span class="token class-name">OutputFile</span><span class="token punctuation">.</span>xml<span class="token punctuation">,</span> <span class="token string">"D://"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 设置mapperXml生成路径</span>            <span class="token punctuation">)</span>        <span class="token comment">// 策略配置</span>            <span class="token punctuation">.</span><span class="token function">strategyConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span>                    builder<span class="token punctuation">.</span><span class="token function">addInclude</span><span class="token punctuation">(</span><span class="token string">"t_simple"</span><span class="token punctuation">)</span> <span class="token comment">// 设置需要生成的表名</span>                            <span class="token punctuation">.</span><span class="token function">addTablePrefix</span><span class="token punctuation">(</span><span class="token string">"t_"</span><span class="token punctuation">,</span> <span class="token string">"c_"</span><span class="token punctuation">)</span> <span class="token comment">// 设置过滤表前缀</span>            <span class="token punctuation">)</span>        <span class="token comment">// 模板引擎</span>            <span class="token punctuation">.</span><span class="token function">templateEngine</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FreemarkerTemplateEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 使用Freemarker引擎模板，默认的是Velocity引擎模板</span>            <span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Service-Interface"><a href="#Service-Interface" class="headerlink" title="Service Interface"></a>Service Interface</h3><p>IService是 MyBatis-Plus 提供的一个通用 Service 层接口，它封装了常见的 CRUD 操作，包括插入、删除、查询和分页等。通过继承 IService 接口，可以快速实现对数据库的基本操作，同时保持代码的简洁性和可维护性。</p><p><strong>IService 接口中的方法命名遵循了一定的规范，如 get 用于查询单行，remove 用于删除，list 用于查询集合，page 用于分页查询，这样可以避免与 Mapper 层的方法混淆。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token keyword">extends</span> <span class="token class-name">IService</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserDao</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 插入一条记录（选择字段，策略插入）</span><span class="token keyword">boolean</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 插入（批量）</span><span class="token keyword">boolean</span> <span class="token function">saveBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 插入（批量）</span><span class="token keyword">boolean</span> <span class="token function">saveBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">,</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*  根据实体对象的主键 ID 进行判断，存在则更新记录，否则插入记录。 */</span><span class="token comment">// TableId 注解属性值存在则更新记录，否则插入一条记录</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdate</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据updateWrapper尝试更新，否则继续执行saveOrUpdate(T)方法</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdate</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> updateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 批量修改插入</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdateBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 批量修改插入</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdateBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">,</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 queryWrapper 设置的条件，删除记录</span><span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 删除</span><span class="token keyword">boolean</span> <span class="token function">removeById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 columnMap 条件，删除记录</span><span class="token keyword">boolean</span> <span class="token function">removeByMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 删除（根据ID 批量删除）</span><span class="token keyword">boolean</span> <span class="token function">removeByIds</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> idList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span><span class="token keyword">boolean</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> updateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 whereWrapper 条件，更新记录</span><span class="token keyword">boolean</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">T</span> updateEntity<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> whereWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 选择修改</span><span class="token keyword">boolean</span> <span class="token function">updateById</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据ID 批量更新</span><span class="token keyword">boolean</span> <span class="token function">updateBatchById</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据ID 批量更新</span><span class="token keyword">boolean</span> <span class="token function">updateBatchById</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">,</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 查询</span><span class="token class-name">T</span> <span class="token function">getById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last("LIMIT 1")</span><span class="token class-name">T</span> <span class="token function">getOne</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录</span><span class="token class-name">T</span> <span class="token function">getOne</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">,</span> <span class="token keyword">boolean</span> throwEx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">V</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询所有</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询列表</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询（根据ID 批量查询）</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">listByIds</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> idList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询（根据 columnMap 条件）</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">listByMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询所有列表</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">listMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询列表</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">listMaps</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询全部记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询全部记录</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询全部记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询全部记录</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 无条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">page</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">page</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 无条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">pageMaps</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">pageMaps</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询总记录数</span><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询总记录数</span><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自3.4.3.2开始,返回值修改为long</span><span class="token comment">// 查询总记录数</span><span class="token keyword">long</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询总记录数</span><span class="token keyword">long</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员SSM：<a href="https://www.bilibili.com/video/BV1Fi4y1S7ix/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1Fi4y1S7ix/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>JavaGuide：<a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></p><p>spring中BeanFactory和FactoryBean的区别：<a href="https://blog.csdn.net/dongyang2019/article/details/113725058">https://blog.csdn.net/dongyang2019/article/details/113725058</a></p><p>Nan-ying’s blog：<a href="https://nan-ying.github.io/2023/07/10/Spring/#%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A6%82%E5%BF%B5">https://nan-ying.github.io/2023/07/10/Spring/#%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A6%82%E5%BF%B5</a></p><p>牛客高启盛同学资料：<a href="https://github.com/viego1999/JavaWxy">https://github.com/viego1999/JavaWxy</a></p><p>MybatisPlus官方文档：<a href="https://baomidou.com/guides/data-interface/">https://baomidou.com/guides/data-interface/</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评</title>
      <link href="/2024/05/13/hei-ma-dian-ping/"/>
      <url>/2024/05/13/hei-ma-dian-ping/</url>
      
        <content type="html"><![CDATA[<h1 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h1><h2 id="MySQL表"><a href="#MySQL表" class="headerlink" title="MySQL表"></a>MySQL表</h2><ul><li>tb_user：用户表</li><li>tb_user_info：用户详情表</li><li>tb_shop：商户信息表</li><li>tb_shop_type：商户类型表</li><li>tb_blog：用户日记表（达人探店日记）</li><li>tb_follow：用户关注表</li><li>tb_voucher：优惠券表</li><li>tb_voucher_order：优惠券的订单表</li></ul><h2 id="当前模型"><a href="#当前模型" class="headerlink" title="当前模型"></a>当前模型</h2><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的是HTTP协议，可以实现<strong>基于Lua直接绕开tomcat访问redis</strong>，也可以作为<strong>静态资源服务器</strong>，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p><p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们<strong>在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群对外提供更好的服务。</strong></p><h2 id="用户鉴权"><a href="#用户鉴权" class="headerlink" title="用户鉴权"></a>用户鉴权</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>cookie 是一个非常具体的东西，指的就是<strong>浏览器里面能永久存储</strong>的一种数据，仅仅是浏览器实现的一种数据存储功能。</p><p>cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。</p><p>由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p><p><strong>Cookie 技术主要用于：</strong></p><ul><li>身份验证：保存用户登录状态，实现持久登录。</li><li>会话管理：追踪用户的会话信息，例如购物车内容。</li><li>个性化设置：存储用户偏好设置，以提供个性化的用户体验。</li></ul><p>Cookie 的相关操作和属性可以通过 JavaScript 的 document.cookie 对象进行访问和修改。可以设置 Cookie 的<strong>过期时间、作用域、路径</strong>等属性，以控制其有效性和访问范围。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session（会话）是一种<strong>在服务器端存储用户状态和数据的机制</strong>。它通过在服务器端创建一个唯一的会话标识（通常是一个 Session ID），并将该标识发送给客户端，实现在不同的请求中跟踪和管理用户的状态。</p><p>当用户访问一个网站时，服务器会为该用户创建一个会话，并将会话 ID 存储在 Cookie 中，或者通过其他方式将其发送给客户端。客户端的浏览器会自动在后续的请求中<strong>将会话 ID 发送给服务器，在服务器端找到对应的会话数据。</strong></p><p>会话数据存储在服务器端的临时存储区域，通常是在服务器的内存中或在数据库中。服务器会根据会话 ID 来检索和更新相应的数据，从而实现用户状态的管理和维护。</p><p><strong>Session 技术的主要作用：</strong></p><ul><li>身份验证：存储用户登录信息和权限，实现用户认证。</li><li>会话管理：追踪用户的操作和活动，在请求之间保持连续性。</li><li>数据存储：存储用户数据，例如购物车、表单数据等。</li></ul><p>需要注意的是，为了保护用户数据的安全性和隐私，开发人员应采取适当的安全措施：</p><ul><li>使用安全的传输协议（如 HTTPS）来保护会话数据在网络传输中的安全性。</li><li>针对会话 ID 的保护，包括生成安全的随机会话 ID、设置合适的过期时间，以及通过 HttpOnly 和 Secure 标志来防止跨站脚本攻击和会话劫持。</li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>Token（令牌）是一种<strong>在身份验证和授权中使用的字符串</strong>，用于验证客户端的身份和权限。它作为客户端和服务器之间进行安全通信的一种方式，来确保用户的身份和访问权限。</p><p>Token 的主要特点是它是<strong>无状态</strong>的，<strong>即服务器不需要在存储设备中维护任何信息</strong>。服务器在生成 Token 后，将其发送给客户端，客户端在以后的请求中将 Token 作为身份凭证发送给服务器。服务器通过验证 Token 的有效性，来确认客户端的身份和权限。</p><p>Token 的生成和验证过程一般包含以下步骤：</p><ul><li>客户端向服务器发送身份验证请求，通常是提供用户名和密码。</li><li>服务器验证客户端提供的身份信息，并生成一个 Token。</li><li>服务器将生成的 Token 发送给客户端，客户端将其保存。</li><li>客户端在以后的请求中将 Token 添加到请求头中，作为身份凭证。</li><li>服务器在接收到请求时，验证 Token 的有效性和权限，并相应地处理请求。</li></ul><p><strong>Token 的主要作用：</strong></p><ul><li>身份验证：通过 Token 来验证客户端的身份，替代传统的基于会话的身份验证机制，不需要在服务器端存储会话信息，减轻服务器的负担。</li><li>授权：服务器可以根据 Token 中的信息来判断客户端的权限，决定是否允许相应的操作。</li><li>单点登录（SSO）：Token 可以在不同的应用程序之间共享，实现用户的单点登录功能。</li></ul><p>Token 可以有不同的类型和格式，常见的包括 JSON Web Token（JWT）、OAuth 2.0 的访问令牌等。同时，Token 也可以通过加密和签名等方式来保证其安全性。</p><h2 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h2><h3 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h3><blockquote><p>1、用户提交手机号<br>2、校验手机号是否合法<br>3、生成验证码<br>4、将生成的验证码保存到session中，用于后续的验证<br>5、发送验证码给用户</p></blockquote><p><strong>接口地址</strong>:<code>/user/code</code></p><p><strong>请求方式</strong>:<code>POST</code></p><p><strong>请求数据类型</strong>:<code>application/json</code></p><p><strong>请求参数</strong>:</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>请求类型</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>phone</td><td></td><td>query</td><td>true</td><td>string</td><td></td></tr><tr><td>session</td><td></td><td>query</td><td>true</td><td>HttpSession</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">{</span><span class="token string-property property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string-property property">"errorMsg"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token string-property property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token string-property property">"total"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="登录-注册"><a href="#登录-注册" class="headerlink" title="登录/注册"></a>登录/注册</h3><blockquote><p>1、提交手机号和验证码<br>2、校验验证码<br>3、根据手机号查询数据库信息<br>4、用户存在就保存到session，否则就创建新用户并保存到数据库，最后也保存到session中</p></blockquote><p><strong>接口地址</strong>:<code>/user/login</code></p><p><strong>请求方式</strong>:<code>POST</code></p><p><strong>请求数据类型</strong>:<code>application/json</code></p><p><strong>请求参数</strong>:</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>请求类型</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>loginForm</td><td>loginForm</td><td>body</td><td>true</td><td>LoginFormDTO</td><td>LoginFormDTO</td></tr><tr><td>  code</td><td></td><td></td><td>false</td><td>string</td><td></td></tr><tr><td>  password</td><td></td><td></td><td>false</td><td>string</td><td></td></tr><tr><td>  phone</td><td></td><td></td><td>false</td><td>string</td><td></td></tr><tr><td>session</td><td></td><td>query</td><td>true</td><td>HttpSession</td><td></td></tr></tbody></table><h3 id="校验登录状态-拦截器"><a href="#校验登录状态-拦截器" class="headerlink" title="校验登录状态-拦截器"></a>校验登录状态-拦截器</h3><p>首先我们要知道怎么基于session进行校验，session是基于cookie的（每一个session的id都会保存到cookie中），当用户访问的时候会携带cookie，所以我们可以根据cookie中的session_id来查询session中是否有这个用户：</p><blockquote><p>1、用户发送请求并携带cookie<br>2、从session中获取用户<br>3、判断用户是否存在：<br>（1）没有这个用户就拦截<br>（2）有这个用户就保存用户信息到ThreadLocal用于登录缓存（ThreadLocal是一个线程域对象，<strong>每一个请求到达服务都会是一个独立线程，直接保存到本地变量会出现并发修改的安全问题，而ThreadLocal会将数据保存到每个线程内部，在线程内部创建一个Map来进行保存</strong>），保存完后就放行该用户即可</p></blockquote><p>基于session校验需要<strong>在跨各种组件和页面的时候都访问session，编写重复的校验代码</strong>，增加了访问session的开销。所以使用ThreadLocal，使得每一个线程只需要访问一次session。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MvcConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoginInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span>   <span class="token comment">// 白名单</span>                        <span class="token string">"/shop/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/shop-type/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/voucher/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/upload/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/blog/hot"</span><span class="token punctuation">,</span>                        <span class="token string">"/user/code"</span><span class="token punctuation">,</span>                        <span class="token string">"/user/login"</span>                <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取客户端请求传进来的session</span>        <span class="token class-name">HttpSession</span> session <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取user</span>        <span class="token class-name">Object</span> user <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 用户不存在，拦截，返回401状态码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 用户存在session中，保存到localthread，放行</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">UserDTO</span><span class="token punctuation">)</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 线程执行后移除用户</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">removeUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="集群的session共享问题"><a href="#集群的session共享问题" class="headerlink" title="集群的session共享问题"></a>集群的session共享问题</h3><p><strong>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同Tomcat服务时导致数据丢失的问题。</strong><br>这是因为我们为了我们将来系统的<strong>高并发性</strong>，就需要<strong>水平拓展，形成负载均衡的集群</strong>，<strong>每个Tomcat都会有一个对应的session。当我们在某一台Tomcat上进行登录以后，第二次登录的时候，要是被负载均衡到了另一台Tomcat，就会造成没办法获得之前登录时的session，就没办法再做验证了。</strong><br>这个问题听起来好像也挺容易解决，如果每台Tomcat都互相拷贝，保存相同的数据，那肯定就不至于发生如上的问题，但是这样的解决方式太浪费空间了，而且拷贝的过程还是比较费时的，如果这时候已经有访问请求，就可能会出现数据不一致的情况。<br>因此，我们的session信息共享的解决方案应该满足以下特点：<br><strong>1、数据共享</strong><br>2、内存存储<br>3、key-value结构<br>这时候我们就回到了Redis了，我们知道Redis是独立于Tomcat的，单独进行存储，且任何一台Tomcat都可以访问到Redis，因此可以实现数据共享</p><h4 id="基于Redis实现共享session"><a href="#基于Redis实现共享session" class="headerlink" title="基于Redis实现共享session"></a>基于Redis实现共享session</h4><h5 id="发送验证码-1"><a href="#发送验证码-1" class="headerlink" title="发送验证码"></a>发送验证码</h5><p>验证码保存到redis中，Redis的结构是key-value的，且value是很多种类型的，在这里我们选择最简单的String类型即可。</p><blockquote><p>一个需要考虑的问题是key的选取，在session中我们选用了“code”来作为key，但在这里却不行。这是因为<strong>每一个不同的浏览器在发送请求的时候都会有一个不同的独立的session，也就是说Tomcat的内部维护了很多的session，互相之间是不会干扰的</strong>。但是Redis是一个共享的内存空间，如果直接使用key会造成<strong>覆盖</strong>，所以我们不能直接选用“code”来作为key。因此我们可以<strong>用手机号作为key（因为同一账号同一时刻仅在一个平台登录）。</strong></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">sendCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> phone<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 校验手机号，正则，不合法则返回错误信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">RegexUtils</span><span class="token punctuation">.</span><span class="token function">isPhoneInvalid</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"手机号格式错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 生成验证码</span>    <span class="token class-name">String</span> code <span class="token operator">=</span> <span class="token class-name">RandomUtil</span><span class="token punctuation">.</span><span class="token function">randomNumbers</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保存验证码到redis，用phone为key，限制有效期5min</span>    <span class="token comment">//        session.setAttribute("code", code);  这个是存到session</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">LOGIN_CODE_KEY</span><span class="token operator">+</span>phone<span class="token punctuation">,</span> code<span class="token punctuation">,</span> <span class="token constant">LOGIN_CODE_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送验证码，调用第三方平台</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"发送验证码："</span> <span class="token operator">+</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="验证码登录与注册"><a href="#验证码登录与注册" class="headerlink" title="验证码登录与注册"></a>验证码登录与注册</h5><p>最终的用户信息不再保存到session中，而是保存都Redis中去了，同样要考虑key跟value的选择：<br>（1）value的选取：我们要保存的是用户的信息，这是一个对象。我们用Hash结构是最合适的。<br>（2）key的选取：这里并不建议用phone作为key，而是<strong>以随机token（服务器生成的令牌）为key来存储用户数据</strong>，因为<strong>这里的token要存到前端，使用手机号为key不安全，容易泄露。</strong></p><p>在之前我们校验登录状态的时候，是从cookie中获取session再得到用户信息，而现在我们校验登录的时候<strong>要访问的凭证就是这个随机token了</strong>，但Tomcat不会将这个token自动写到浏览器上面。所以我们<strong>把数据保存到Redis以后还需要手动的把token返回到前端</strong>，流程就得修改：</p><blockquote><p>1、提交手机号和验证码<br>2、校验验证码<br>3、根据手机号查询用户信息<br>4、<strong>用户保存到Redis</strong><br>5、<strong>返回token给客户端（重要一步）</strong></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">LoginFormDTO</span> loginForm<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> phone <span class="token operator">=</span> loginForm<span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 校验手机号</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">RegexUtils</span><span class="token punctuation">.</span><span class="token function">isPhoneInvalid</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"手机号格式错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 校验验证码，从redis中获取验证码</span>    <span class="token comment">//        Object cacheCode = session.getAttribute("code");</span>    <span class="token class-name">String</span> cacheCode <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">LOGIN_CODE_KEY</span> <span class="token operator">+</span> phone<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> code <span class="token operator">=</span> loginForm<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 不一致，报错</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheCode <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>cacheCode<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"验证码错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 一致，查数据库tb_user</span>    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"phone"</span><span class="token punctuation">,</span> phone<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 不存在，创建新用户</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        user <span class="token operator">=</span> <span class="token function">createUserWithPhone</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 保存用户信息DTO(id，昵称，头像信息)到redis，需要生成token</span>    <span class="token class-name">String</span> token <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">UserDTO</span> userDTO <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token class-name">UserDTO</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将user对象转为map类型，拆分所有字段，以哈希结构存到redis里 -- 对象中的数据类型都应该是string</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> userMap <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">beanToMap</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 将Java对象（Bean）转换为Map类型</span>                                                     <span class="token class-name">CopyOptions</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 对象转换时的配置项</span>                                                     <span class="token punctuation">.</span><span class="token function">setIgnoreNullValue</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>   <span class="token comment">// 是否忽略空值，当源对象的值为null时，true: 忽略而不注入此值，false: 注入null</span>                                                     <span class="token punctuation">.</span><span class="token function">setFieldValueEditor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">,</span> fieldValue<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> fieldValue<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 对转换过程中的字段值进行编辑处理，对象值转为string</span>    <span class="token class-name">String</span> user_token <span class="token operator">=</span> <span class="token constant">LOGIN_USER_KEY</span> <span class="token operator">+</span> token<span class="token punctuation">;</span>    <span class="token comment">// 这里long id直接转string会报错</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>user_token<span class="token punctuation">,</span> userMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置token有效期（超过30分钟没有访问就删除）</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>user_token<span class="token punctuation">,</span> <span class="token constant">LOGIN_USER_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//        session.setAttribute("user", BeanUtil.copyProperties(user, UserDTO.class));</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/05/13/hei-ma-dian-ping/image-20240515164315155.png"><h5 id="校验登录状态"><a href="#校验登录状态" class="headerlink" title="校验登录状态"></a>校验登录状态</h5><p>我们不再是从浏览器中的cookie指定的session来获取用户信息，而是以随机token为key来从Redis中获取信息，流程如下：</p><blockquote><p>1、用户发送请求并<strong>携带token</strong><br>2、从Redis中获取用户（以随机token为key）<br>3、判断用户是否存在：<br>（1）没有这个用户就拦截<br>（2）有这个用户就保存用户信息到ThreadLocal，并放行</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token comment">// 这个拦截器类不是由spring管理的，所以需要手动构造stringRedisTemplate而不能用依赖注入</span>    <span class="token comment">// 通过调用该类的spring类注入stringRedisTemplate，然后传递参数到拦截器来完成构造</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">LoginInterceptor</span><span class="token punctuation">(</span><span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取客户端请求头传进来的token</span>        <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        HttpSession session = request.getSession();</span>        <span class="token comment">// token为空或仅包含空白字符</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 基于token构造redis中存的用户信息的key</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_KEY</span> <span class="token operator">+</span> token<span class="token punctuation">;</span>        <span class="token comment">// 基于token获取redis中存的user</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> userMap <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 用户不存在，拦截，返回401状态码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>userMap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">UserDTO</span> userDTO <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">fillBeanWithMap</span><span class="token punctuation">(</span>userMap<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 用户存在，保存到localthread，放行</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新过期时间 -- 也就是每次访问新的页面，进行拦截器判断，更新过期时间</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 线程执行后移除用户</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">removeUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="解决状态登录刷新的问题——登录拦截器的优化"><a href="#解决状态登录刷新的问题——登录拦截器的优化" class="headerlink" title="解决状态登录刷新的问题——登录拦截器的优化"></a>解决状态登录刷新的问题——登录拦截器的优化</h5><p>上述代码实现完还有一点小问题，之前的拦截器并不会拦截掉一切路径，而是所有需要登录的路径，那么会出现一个问题：我们的首页并不需要登录就可以直接访问，那么<strong>已经登录过的用户一直在首页进行操作，拦截器中的登录状态并不会刷新，就可能造成明明一直在操作系统，却被视为不算是在登录状态。</strong><br>解决方法是<strong>再加上一个拦截器，用户的请求要先经过这个拦截器，这个拦截器会拦截一切的路径，所以我们可以在这个拦截器里面进行token有效期的刷新操作：</strong></p><blockquote><p>1、获取token<br>2、查询Redis的用户<br>3、保存到ThreadLocal<br>4、刷新token有效期<br>5、放行</p></blockquote><p>这样的话，一切的请求都会触发刷新的操作。那么<strong>之前的拦截器只需要查询ThreadLocal的用户，存在则继续，不存在则拦截。</strong></p><p>新的拦截一切的拦截器做用户校验，存到threadlocal并放行一切：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取客户端请求头传进来的token</span>    <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// token为空或仅包含空白字符，直接放行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 基于token构造redis中存的用户信息的key</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_KEY</span> <span class="token operator">+</span> token<span class="token punctuation">;</span>    <span class="token comment">// 基于key获取redis中存的user</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> userMap <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用户不存在，直接放行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>userMap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">UserDTO</span> userDTO <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">fillBeanWithMap</span><span class="token punctuation">(</span>userMap<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用户存在，保存到localthread，更新放行</span>    <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新过期时间</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>旧的拦截器只检查threadlocal有没有用户：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token comment">// 在login拦截器中只需要校验threadlocal里面有没有存用户，没有则拦截</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="==商户查询缓存=="></a>==商户查询缓存==</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h3><p>缓存：数据交换的缓冲区（Cache），是<strong>存储数据的临时地方，读写性能高。</strong>俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">例<span class="token number">1</span><span class="token operator">:</span><span class="token class-name">Static</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 本地用于高并发例<span class="token number">2</span><span class="token operator">:</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token constant">USER_CACHE</span> <span class="token operator">=</span> <span class="token class-name">CacheBuilder</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 用于redis等缓存例<span class="token number">3</span><span class="token operator">:</span><span class="token class-name">Static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 本地缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;</p><p>我们的浏览器有浏览器缓存，在浏览器未命中数据，就会在tomcat的应用层缓层中取数据，再没有命中的话就去数据库进行查询检索。<br><strong>缓存的作用：</strong><br>1、降低后端负载<br>2、提高读写效率，降低响应时间<br><strong>缓存的成本：</strong><br>1、数据的一致性成本<br>2、代码维护成本（解决一致性问题的时候带来的代码复杂）<br>3、运维的成本</p><h3 id="商户查询添加缓存"><a href="#商户查询添加缓存" class="headerlink" title="商户查询添加缓存"></a>商户查询添加缓存</h3><p>如果直接查数据库，逻辑是这样的。速度慢</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryShopById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//这里是直接查询数据库</span>    <span class="token keyword">return</span> shopService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改成缓存，用string类型存商户json信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 查缓存，若存在直接返回，不存在就查数据库</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 存在店铺信息，反序列化json为bean对象并返回</span>            <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span>  <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 查数据库</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>shop <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"店铺不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 数据库中存在，将店铺信息序列化为json字符串，存储到redis缓存中</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="商户类型序列缓存"><a href="#商户类型序列缓存" class="headerlink" title="商户类型序列缓存"></a>商户类型序列缓存</h3><p>shopTypeController</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"list"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//        List&lt;ShopType&gt; typeList = typeService</span>    <span class="token comment">//                .query().orderByAsc("sort").list();</span>    <span class="token keyword">return</span> typeService<span class="token punctuation">.</span><span class="token function">queryShopTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shopTypeServiceImpl</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShopTypeServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShopTypeMapper</span><span class="token punctuation">,</span> <span class="token class-name">ShopType</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">IShopTypeService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryShopTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 要返回的商户列表</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShopType</span><span class="token punctuation">&gt;</span></span> typeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 存到redis中的商户类型list，是商户这个类型的json字符串的list集合</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisTypeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查询redis缓存</span>        <span class="token class-name">Long</span> size <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOPTYPE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 缓存有数据就返回</span>            redisTypeList <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOPTYPE_KEY</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 利用stream流和map将string类型的json list转换为bean list</span>            typeList <span class="token operator">=</span> redisTypeList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token class-name">ShopType</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>typeList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 缓存没有，查数据库，存缓存，返回</span>        typeList <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orderByAsc</span><span class="token punctuation">(</span><span class="token string">"sort"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>typeList <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> typeList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"不存在商户类型数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查到的bean list通过stream流转为string list，存到缓存</span>        redisTypeList <span class="token operator">=</span> typeList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>shopType<span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>shopType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPushAll</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOPTYPE_KEY</span><span class="token punctuation">,</span> redisTypeList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>typeList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>上面的作用模型可能会造成数据一致性问题，当我们对数据库进行修改的时候，缓存并没有同步进行修改，页面在缓存中获取数据的时候，其实并不是最新的数据。这肯定是不允许的。</p><p>下面是缓存更新策略：</p><table><thead><tr><th></th><th align="center">内存淘汰</th><th align="center">超时剔除</th><th align="center">主动更新</th></tr></thead><tbody><tr><td>说明</td><td align="center">不用自己维护，利用Redis的内存淘汰机制，<strong>内存不足时自动淘汰部分数据</strong>，下次查询时更新缓存</td><td align="center">给缓存数据添加TTL时间，<strong>到期后自动删除缓存</strong>。下次查询即可实现缓存的更新</td><td align="center">自己编写业务逻辑，在修改数据库的同时，更新缓存</td></tr><tr><td>一致性</td><td align="center">差</td><td align="center">一般</td><td align="center">好</td></tr><tr><td>维护成本</td><td align="center">无</td><td align="center">低</td><td align="center">高</td></tr></tbody></table><p>上述的策略选择要根据具体的业务场景：<br>1、低一致性需求/数据很少更新：使用内存淘汰机制。例如店铺类型的查询缓存。<br>2、高一致性需求：<strong>主动更新，以超时剔除作兜底方案。例如店铺详情查询的缓存。</strong></p><h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p>1、<strong>Cache Aside Pattern（最常用）</strong> – 由缓存的调用者，在更新数据库的同时更新缓存<br>2、<strong>Read/Write Through Pattern</strong> – 缓存与数据库整合为一个<strong>服务</strong>，由服务来维护一致性（调用者不知道服务内部）。调用者调用该服务无需关注一致性问题。但这种服务的成本肯定是很高的。<br>3、<strong>Write Behind Caching Pattern（写回）</strong> – 调用<strong>者只操作缓存</strong>，<strong>由其它线程异步的将缓存数据持久化到数据库</strong>，保证最终一致。<br>比如我们一直对缓存进行更新，更新10次以后轮到这个线程工作，就维护一下数据库的数据为更新10次后的数据，中途的其他9次更新操作根本不重要，这样的<strong>性能显然是很高的</strong>。这种方式当然也有很大问题，比如<strong>长期的数据不一致、缓存宕机造成的严重后果</strong>等。</p><p>操作缓存和数据库时要考虑如下几个问题：</p><ul><li>删除缓存还是更新缓存？ <ul><li>更新缓存：每次更新数据库都更新缓存，<strong>无效写操作较多</strong>。（写多读少的情况，假设更新100次数据，读1次数据，这边会有100次无效更新缓存）</li><li>删除缓存：<strong>更新数据库时让缓存失效，查询时再更新缓存</strong>（<strong>更优</strong>） 。（写多读少时，更新100次也只需要删一次缓存，避免无效写操作）</li></ul></li><li>如何保证缓存和数据库的操作的同时成功或失败？（原子性） <br>- 单体系统：<strong>事务控制</strong>，将缓存与数据库操作放在一个事务 <br>- 分布式系统：利用TCC等<strong>分布式事务方案</strong> </li><li>先操作缓存还是先操作数据库？（线程安全） <br>- 先删除缓存，再操作数据库 <br>- 先操作数据库，再删除缓存 - 由于 redis 的速度远比MySQL要快，所以方案二为优选</li></ul><p><strong>先删缓存再操作数据库的线程安全问题：</strong>正常情况如左图，两个线程得到的数据一致。异常情况下如果线程2（读操作）在线程1写数据库之前查缓存，就会使得缓存与数据库不同步。因为写MySQL数据库操作比查Redis缓存操作慢，所以异常情况很容易发生。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516121851596.png" style="zoom:80%;"><p><strong>先操作数据库再删缓存的线程安全问题</strong>：正常情况如左图。异常情况如右图。异常情况发生条件是（1）线程并行（2）缓存失效（3）在线程1（读操作）查数据库过程中，线程2完成了更新数据库和删缓存两个操作。由于MySQL写数据比查数据慢，在微秒级别内完成更新数据库和删除缓存概率很低。所以这个方式更好。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516122155989.png" alt="image-20240516122155989" style="zoom:80%;"><h3 id="总结Redis读写策略"><a href="#总结Redis读写策略" class="headerlink" title="总结Redis读写策略"></a>总结Redis读写策略</h3><p>读操作：</p><ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li></ul><p>写操作：</p><ul><li><strong>先写数据库，然后再删除缓存</strong></li><li>要确保数据库与缓存操作的原子性</li></ul><h2 id="商铺缓存与双写一致"><a href="#商铺缓存与双写一致" class="headerlink" title="商铺缓存与双写一致"></a>商铺缓存与双写一致</h2><p>现在我们要给查询商铺的缓存添加<strong>主动更新</strong>和<strong>超时剔除</strong>策略。<br>修改ShopController的业务逻辑满足：<br>（1）根据id查询店铺，没命中就查数据库，然后写入缓存，<strong>并设置超时时间</strong><br>（2）根据id<strong>修改</strong>店铺，<strong>先操作数据库，再删除缓存</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span>  <span class="token comment">// 通过事务控制数据库和缓存操作的原子性</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Shop</span> shop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Long</span> id <span class="token operator">=</span> shop<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"店铺不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新数据库</span>    <span class="token function">updateById</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 删除缓存</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="缓存穿透、雪崩、击穿"><a href="#缓存穿透、雪崩、击穿" class="headerlink" title="缓存穿透、雪崩、击穿"></a>缓存穿透、雪崩、击穿</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透</strong>是指<strong>客户端请求的数据在缓存和数据库中都不存在</strong>，这样缓存永远不会生效，这些请求都会打到数据库。不断发起这样的请求，给数据库带来巨大压力。过程即：<br>（1）客户端访问Redis，未命中（2）接着访问数据库，未命中<br>这样的话，如果有人恶意多线程地访问不存在的内容，可能就把我们的系统弄垮了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>1、缓存空对象：</strong><br>（1）客户端请求Redis，未命中<br>（2）接着访问数据库，未命中<br>（3）<strong>数据库将空值null缓存到Redis里</strong><br>这样如果继续访问的话，<strong>就会访问Redis了，不会一直去对数据库造成攻击</strong>，尽管访问Redis以后返回的内容是NULL。<br><strong>优点</strong>：实现简单，维护方便<br><strong>缺点</strong>：<strong>额外内存消耗</strong>（每次进行不同的访问，都创建null，不过设置TTL可以解决）；可能<strong>造成短期的不一致</strong>（设置为NULL之后，数据库真的新增了这个数据，不过设置TTL可以有效缓解这种情况的出现概率）</p><p><strong>2、布隆过滤：</strong><br>这其实是一种算法，它<strong>在客户端与Redis交互之间加了一个布隆过滤器</strong>：<br>（1）用户请求布隆过滤器，<strong>不存在就直接拒绝</strong><br>（2）存在的话就放行，让客户端去访问Redis，有就返回，没有就访问数据库<br>布隆过滤器存储的一系列的二进制位，<strong>这种二进制数是先对数据库数据进行某种哈希运算以后再转成二进制存储到布隆过滤器的</strong>，具体原理可以自行查询，这种算法实现方式决定了<strong>过滤器存在概率性</strong>：如果过滤器返回<strong>不存在</strong>，那就是不存在；如果返回<strong>存在</strong>，那就不一定了。</p><p><strong>优点</strong>：<strong>内存占用较少</strong>，没有多余key<br><strong>缺点</strong>：实现复杂（不过Redis里面存在，可以简化开发）；存在<strong>误判可能</strong>。</p><p>因为布隆过滤器存在误判，所以我们的开发过程中，会选择<strong>缓存空对象</strong>的方式来解决缓存穿透。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516130239055.png" alt="image-20240516130239055"><p><strong>缓存穿透的其他解决方案：</strong></p><ul><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="解决商铺查询的缓存穿透问题"><a href="#解决商铺查询的缓存穿透问题" class="headerlink" title="解决商铺查询的缓存穿透问题"></a>解决商铺查询的缓存穿透问题</h3><p>1、我们需要在之前业务流程环节中增加缓存空对象的环节，即可解决，也就是根据id查询数据库的时候，判断商铺不存在之后，不再直接结束，而是将空值写入Redis。<br>2、那么我们之后的查询，可以在缓存中查询出null值，因此我们的查询就需要对查询出来的值进行判断，不是空值的话才能返回商铺信息到前端。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516214714449.png" alt="image-20240516214714449" style="zoom:80%;"><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩</strong>是指在同一时段<strong>大量的缓存key同时失效或者Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</p><p>正常情况下，大量请求会到达Redis，少数请求到达数据库。而Redis一旦宕机，或者Redis中的大量key都因为TTL到期而失效了，这时候的很多请求都会指向数据库。<br>针对这个问题，我们可以提出一些解决方案：<br>1、给不同的key的<strong>TTL添加随机值</strong>，避免大量的key在同一个小时段内失效<br>2、利用<strong>Redis集群</strong>提高服务的可用性（Redis哨兵机制可以实现服务的监控，<strong>发现宕机的主Redis，就可以立刻将从Redis替代上去</strong>），这个内容相对比较高级，在之后讲。<br>3、给<strong>缓存业务添加降级限流策略（微服务部分）</strong>（如果整个集群的Redis全部都宕机了，我们可以提前做容错处理，当这些Redis都失效的时候，我们要<strong>及时的拒绝请求</strong>，防止大量请求到达数据库）<br>4、给业务添加<strong>多级缓存</strong></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>也叫作热点key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><blockquote><p>我们可以这么理解，网站中有一些内容是非常的重要的，很可能<strong>在同一时段被多个用户给同时访问，也就是高并发访问</strong>，而这个<strong>被高并发访问的key失效了，这时候访问就会到达数据库</strong>，大量请求到达数据库是很危险的，很容易造成缓存雪崩。<br>即便数据库比较坚强，也有可能用户进行访问的内容是很复杂的，可能涉及到了多表查询，也可能其转换到Redis中进行存储的时候需要进行一系列的业务。当缓存重建业务复杂的时候，如此大的请求在那一瞬间给数据库带来的冲击是非常巨大的。</p></blockquote><p>缓存击穿问题，有两种比较主流的解决方法：<br>1、互斥锁<br>2、逻辑过期</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>1、当第一个线程<strong>未命中缓存</strong>的时候，<strong>获取互斥锁，直到这个线程查询数据库完，并且重建了缓存数据并存入Redis，才能释放互斥锁；</strong><br>2、后面的线程在缓存数据存入Redis的过程中，同样会发生查询Redis未命中的情况，那么这些线程无法获得互斥锁，只能进行<strong>休眠，休眠一段时间后再重试，直到锁被解开</strong>（Redis中已经有数据了）。</p><h4 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><p>缓存击穿会出现的原因，其实无非就是TTL到期，Redis失效了，因此我们可以<strong>不给其设置TTL</strong>。但是我们该如何知道key过期了呢？我们要给这个key设置一个逻辑过期，类似：</p><table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>wxj:user:1</td><td>{name:“Jack”, age:21, expire:151467}</td></tr></tbody></table><p>这里的expire不是TTL，而是我们添加到Redis之前设定的，用<strong>代码逻辑来进行维护</strong>。</p><p>那么这个key一旦存储到了Redis里面，没有任何干预的情况下是永不过期的。</p><p>也就是说有线程在查询缓存的时候，代码逻辑里发现<strong>逻辑时间过期了，我们也直接把旧数据返还给客户端</strong>，同时数据更新交给另一个线程去做。此时有更多线程要查缓存，因为拿不到锁所以直接返回旧数据，避免了等待。</p><p>毕竟已经是高并发，一时的旧数据在很多时候也能接受，在我看来这是一种牺牲策略，客户端无须等待新数据到来，当然了，<strong>旧数据迟早要进行修改，但数据的更新操作完全可以交给其他线程，这样可以提高效率</strong>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>解决方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>互斥锁</td><td>没有额外内存消耗；保持一致性；实现简单</td><td>线程要等待，性能受影响；可能死锁</td></tr><tr><td>逻辑过期</td><td>线程无需等待，性能较好</td><td><strong>不保证一致性</strong>；有<strong>额外内存消耗</strong>；实现复杂</td></tr></tbody></table><img src="/2024/05/13/hei-ma-dian-ping/image-20240516215835297.png" alt="image-20240516215835297" style="zoom:80%;"><h3 id="解决商铺查询的缓存击穿问题"><a href="#解决商铺查询的缓存击穿问题" class="headerlink" title="解决商铺查询的缓存击穿问题"></a>解决商铺查询的缓存击穿问题</h3><h4 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>加互斥锁。获取锁与释放锁的方法定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 利用redis setnx - 向Redis中添加一个key，只用当key不存在的时候才添加并返回1</span>    <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 直接返回flag的话，拆箱可能拿到空指针</span>    <span class="token keyword">return</span> <span class="token class-name">BooleanUtil</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整合了缓存穿透和缓存击穿的代码。和前面的代码相比主要是在没有命中缓存，且没有存储空值的情况下，<strong>在查数据库前要先获取互斥锁。防止多个线程同时打到数据库。</strong>拿到锁以后查了数据库同步重建缓存返回数据，也就是<strong>这个线程的任务完成后，才能释放锁给其他线程用</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Shop</span> <span class="token function">queryWithMutex</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 查缓存，若存在直接返回，不存在就查数据库</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>    <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 存在店铺信息，反序列化json为bean对象并返回</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>  shop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果没有命中缓存。命中空值，也就是shopJson是“” 空字符串，而非null，返回错误</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shopJson <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// ====== 没缓存，没空值，需要查数据库 -- 查之前先尝试获取互斥锁，拿到锁以后才能查数据库 ======</span>    <span class="token class-name">String</span> lockKey <span class="token operator">=</span> <span class="token string">"lock:shop:"</span> <span class="token operator">+</span> id<span class="token punctuation">;</span> <span class="token comment">// 每个商户都对应一个锁</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断是否获取成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">// 失败则休眠并重试（递归）</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 单位：ms</span>            <span class="token comment">// 如果担心递归造成爆栈，可以用循环，一样的</span>            <span class="token keyword">return</span> <span class="token function">queryWithMutex</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 拿到了锁，查数据库</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 模拟重建的延时，测试用</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>shop <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 空值有效期相对更短</span>            stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token constant">CACHE_NULL_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 数据库中存在，将店铺信息序列化为json字符串，存储到redis缓存中，并添加超时剔除</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">CACHE_SHOP_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放锁</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Jmeter做并发测试，设定并发量为1000。配置好路径和接口。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516223930023.png" alt="image-20240516223930023" style="zoom: 80%;"><p>运行完以后打开查看结果树：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516224240314.png" alt="image-20240516224240314" style="zoom:80%;"><p>打开汇总报告可以看到我们的吞吐量为204</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516224424100.png" alt="image-20240516224424100" style="zoom:80%;"><p>如此大的数据量打下去，但是我们的日志显示我们的数据库只执行了一次的查询语句：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516224134785.png" alt="image-20240516224134785" style="zoom:80%;"><p>说明我们已经使用互斥锁成功避免了缓存击穿。</p><h4 id="逻辑过期-1"><a href="#逻辑过期-1" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><p>其实通常情况，因为是热点key，一般都是会出现在Redis里面的，且因为我们没有设置TTL，所以热点key是一定会一直存在的，但为了严谨起见，还是在判定缓存未命中的时候返回空。</p><p>主要流程：</p><blockquote><p>1、我们判断一下缓存是否逻辑过期了，如果没有过期，我们直接返回信息到客户端即可<br>2、如果缓存逻辑过期了，这个线程就尝试获取互斥锁，<strong>如果获取成功，说明它是第一个访问Redis的这个过期key的线程</strong>，那么这个线程要做2件事：<br>（1）返回这个旧数据给客户，虽然数据是旧的，但是这是一种暂时的牺牲<br>（2）<strong>开辟新的线程来进行缓存数据的重建，重建完毕就释放这个互斥锁</strong><br>3、除了第2种情况说的这个线程，其他线程<strong>在知道自己访问的数据过期之后，获取互斥锁都会失败，那么这时候只需要直接返还数据给客户就好了</strong>，可能是旧数据，也可能是新数据（第一个线程释放锁或者缓存数据重建成功了）</p></blockquote><img src="/2024/05/13/hei-ma-dian-ping/image-20240517164654459.png" alt="image-20240517164654459"><p>首先我们要对Shop类增加逻辑过期时间这样一个字段，一种方案是<strong>直接添加，这种会违背开闭原则</strong>，一种是可以<strong>新增加一个类</strong>，并且类中包含了逻辑过期时间expireTime，但是该怎么把这个属性添加到Shop里面呢？可以让Shop继承这个类，就可以获得这个类中的属性，但同样会修改Shop这个类的源代码，同样违背开闭原则，所以最好的方法就<strong>是用关联来代替继承：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisData</span> <span class="token punctuation">{</span>    <span class="token comment">/**     *  万能的逻辑过期数据类     */</span>    <span class="token keyword">private</span> <span class="token class-name">LocalDateTime</span> expireTime<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>商铺查询逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 线程池</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ExecutorService</span> <span class="token constant">CACHE_REBUILD_EXECUTOR</span> <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Shop</span> <span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 查缓存，若不存在直接返回空</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>    <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 命中，将json反序列化为对象，判断过期时间。</span>    <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">RedisData</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取到的redisdata存的数据本质是jsonobject类型</span>    <span class="token class-name">JSONObject</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JSONObject</span><span class="token punctuation">)</span> redisData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">LocalDateTime</span> expireTime <span class="token operator">=</span> redisData<span class="token punctuation">.</span><span class="token function">getExpireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 没过期直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>expireTime<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token comment">// 过期了重建缓存，尝试获取互斥锁</span>    <span class="token class-name">String</span> lockKey <span class="token operator">=</span> <span class="token constant">LOCK_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span> <span class="token comment">// 每个商户都对应一个锁</span>    <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断是否获取成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">// 失败说明已经有别的线程处理了，不需要再尝试重建</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 拿到了锁，开启独立线程重建缓存</span>    <span class="token constant">CACHE_REBUILD_EXECUTOR</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token comment">// 为了便于测试缓存重建机制设置20秒逻辑缓存</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">saveShop2Redis</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token number">20L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment">//释放锁</span>            <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> shop<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Jmeter测试，100个线程，1s执行完。查看idea后台，可以发现我们只执行了一次重构，说明只有一个线程操作了数据库，其他返回的在重建前是旧数据，重建完是新数据。这也证明了逻辑过期方法会造成短暂的数据不一致的情况。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240517172349168.png" alt="image-20240517172349168" style="zoom:80%;"><h2 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h2><p>基于StringRedisTemplate封装一个缓存工具类，可以满足以下的需求：<br>1、将<strong>任意</strong>Java对象序列化为json并<strong>存储在string类型的key</strong>中，并且可以设置TTL过期时间。— 存储对象<br>2、将任意Java对象序列化为json并存储在string类型的key中，并且可以<strong>设置逻辑过期时间</strong>，用于处理缓存击穿问题。— 存储逻辑过期对象<br>3、根据<strong>指定的key查询</strong>缓存，并反序列化为<strong>指定类型</strong>，利用<strong>缓存空值</strong>的方式解决缓存穿透问题。— 取对象<br>4、根据指定的key查询缓存，并反序列化指定类型，需要利用<strong>逻辑过期解决缓存击穿</strong>问题。— 取逻辑过期对象<br>1+3：存储普通对象；2+4：存储热点数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CacheClient</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">CacheClient</span><span class="token punctuation">(</span><span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 将任意Java对象序列化为json并存储在string类型的key中</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 带逻辑过期的存储方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWithLogicalExpire</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 逻辑过期类</span>        <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        redisData<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置逻辑过期时间</span>        redisData<span class="token punctuation">.</span><span class="token function">setExpireTime</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">plusSeconds</span><span class="token punctuation">(</span>unit<span class="token punctuation">.</span><span class="token function">toSeconds</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>redisData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 解决缓存穿透，这里用泛型接收任意类型id和对象类型，以便返回对应类型bean     * 参数：key的前缀，对应对象的id，以及对象类型     * 这里的id也同样是泛型，因为没办法保证用户传过来的id类型是Int还是Long或者其他     * 如果redis不存在，需要查询数据库，通用的函数根本不知道从数据库的哪张表进行查询（如果写到service可以利用mybatis-plus getById查对应类型），这里要自行传入 -- 函数式编程     * Function&lt;T, R&gt;表示有参数有返回值的类型，“dbFallback”表示数据库降级逻辑，代表查询Redis失败后要去做的后备方案     */</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">,</span> ID<span class="token punctuation">&gt;</span></span> <span class="token class-name">R</span> <span class="token function">queryWithPassThrough</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyPrefix<span class="token punctuation">,</span> <span class="token class-name">ID</span> id<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> dbFallback<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> keyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>json <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 传入的函数，参数T=id，返回值R为对象类型</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> dbFallback<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//不存在，返回错误</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//存一个null到Redis中，避免缓存穿透</span>            stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//存在，写入Redis，直接用set方法</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> r<span class="token punctuation">,</span> time<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//返回</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//逻辑过期解决缓存击穿问题</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ExecutorService</span> <span class="token constant">CACHE_REBUILD_EXECUTOR</span> <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">R</span> <span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyPrefix<span class="token punctuation">,</span> <span class="token class-name">String</span> lockKeyPrefix<span class="token punctuation">,</span> <span class="token class-name">ID</span> id<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> dbFallback<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> keyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断redis中是否存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 未命中，直接返回</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 命中，先把json反序列化成对象</span>        <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> <span class="token class-name">RedisData</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">JSONObject</span> data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JSONObject</span><span class="token punctuation">)</span> redisData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取到对象类型的r</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">LocalDateTime</span> expireTime <span class="token operator">=</span> redisData<span class="token punctuation">.</span><span class="token function">getExpireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断是否过期，未过期直接返回r</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>expireTime<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> r<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 已过期，缓存重建。尝试获取互斥锁。互斥锁key由参数传递</span>        <span class="token class-name">String</span> lockKey <span class="token operator">=</span> lockKeyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//判断是否获取锁成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isLock<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//成功获取锁，开启独立线程来实现缓存重建，用线程池来做</span>            <span class="token constant">CACHE_REBUILD_EXECUTOR</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment">//查询数据库，这里依旧使用函数式编程</span>                    <span class="token class-name">R</span> r1 <span class="token operator">=</span> dbFallback<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//写入Redis</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setWithLogicalExpire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> r1<span class="token punctuation">,</span> time<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment">//释放锁</span>                    <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//没有拿到锁，直接返回信息</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// opsForValue里面没有真正的setNx，而是setIfAbsent，表示如果不存在就执行set</span>        <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">BooleanUtil</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工具类调用"><a href="#工具类调用" class="headerlink" title="工具类调用"></a>工具类调用</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 缓存穿透</span>    <span class="token comment">// Shop shop = queryWithPassTrough(id);</span>    <span class="token comment">// 缓存击穿 -- 互斥锁</span>    <span class="token comment">// Shop shop = queryWithMutex(id);</span>    <span class="token comment">// 缓存击穿 -- 逻辑过期</span>    <span class="token comment">// Shop shop = queryWithLogicalExpire(id);</span>    <span class="token comment">// 封装的工具类，解决缓存穿透</span>    <span class="token comment">// Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span>    <span class="token comment">// 封装的工具类，解决缓存击穿</span>    <span class="token class-name">Shop</span> shop <span class="token operator">=</span> cacheClient<span class="token punctuation">.</span><span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOP_KEY</span><span class="token punctuation">,</span> <span class="token constant">LOCK_SHOP_KEY</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">::</span><span class="token function">getById</span><span class="token punctuation">,</span> <span class="token number">10L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shop <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"商铺不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="==优惠券秒杀=="></a>==优惠券秒杀==</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><p>每个店铺都可以发布优惠券（代金券），当用户抢购的时候，就会生成订单并且保存到tb_voucher_order这张表中：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tb_voucher_order<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>user_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'下单的用户id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>voucher_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'购买的代金券id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>pay_type<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span> <span class="token keyword">COMMENT</span> <span class="token string">'支付方式 1：余额支付；2：支付宝；3：微信'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>status<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span> <span class="token keyword">COMMENT</span> <span class="token string">'订单状态，1：未支付；2：已支付；3：已核销；4：已取消；5：退款中；6：已退款'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'下单时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>pay_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'支付时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>use_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'核销时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>refund_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'退款时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，我们的主键ID没有使用自增长，这是因为如果使用数据库自增ID就会存在一些问题：<br>1、ID的规律性太明显，容易让别人猜测到信息（比如商城在一天时间内，卖出了多少单）<br>2、受单表数据量的限制（<strong>订单可能数据非常大，可能会分多表进行存储</strong>，但表的自增长相互之间不受影响，所以不同表之间可能会出现ID相同的情况，也就是说这种时候会违背ID的唯一性，这显然是不可以的）<br><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：<strong>1、唯一性  2、高可用  3、高性能  4、递增性  5、安全性</strong></p><p>除了第5点，Redis及其数据结构已经可以直接满足前4点的要求了，为了增加ID的安全性，不要直接使用Redis自增的数值，而是拼接一些其他信息，最终我们将ID组成定义为64位的二进制数，分别是<strong>1位符号位，31位时间戳，32位序列号。</strong></p><h4 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisIdWorker</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token comment">/**     * 开始时间戳由main函数运行得到     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token constant">BEGIN_TIMESTAMP</span> <span class="token operator">=</span> <span class="token number">1716076800L</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 序列号的位数：32bit，秒内的计数器，支持每秒产生2^32个不同ID     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">nextId</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyPrefix<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//获得当前时间</span>        <span class="token class-name">LocalDateTime</span> now <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> nowSecond <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">toEpochSecond</span><span class="token punctuation">(</span><span class="token class-name">ZoneOffset</span><span class="token punctuation">.</span><span class="token constant">UTC</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//生成时间戳：31bit，以秒为单位，可以使用69年</span>        <span class="token keyword">long</span> timestamp <span class="token operator">=</span> nowSecond <span class="token operator">-</span> <span class="token constant">BEGIN_TIMESTAMP</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 接下来生成序列号         * 我们的key的设置除了加上icr表示是自增长的，还需要在最后拼接一个日期字符串         * 这是因为我们的序列号上限是2^32，并不大，如果每天的key都是一样的，这是很有可能超过上限的         * 在后面拼接一个日期字符串，可以保证每一天的key都是不一样的，而且一天内也基本不可能到达2^32的上限         * 这样做还有一个好处，我们以后可以根据每天或者每月来查看value值，起到统计效果         */</span>        <span class="token comment">//获取当前日期，精确到天</span>        <span class="token class-name">String</span> date <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"yyyy:MM:dd"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> count <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token string">"icr:"</span> <span class="token operator">+</span> keyPrefix <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//拼接并返回，这里灵活用位运算</span>        <span class="token keyword">return</span> timestamp <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">|</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//定义时间为2024年5月19日00:00:00</span>        <span class="token class-name">LocalDateTime</span> time <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将时间变成变成秒数的形式</span>        <span class="token keyword">long</span> second <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">toEpochSecond</span><span class="token punctuation">(</span><span class="token class-name">ZoneOffset</span><span class="token punctuation">.</span><span class="token constant">UTC</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//在这里运行出来的时间作为BEGIN_TIMESETAMP</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全局唯一ID生成策略"><a href="#全局唯一ID生成策略" class="headerlink" title="全局唯一ID生成策略"></a>全局唯一ID生成策略</h3><ul><li>UUID：优点使用简单，不依赖其他组件，不影响数据库扩展；缺点数据库索引效率低，太过于无意义.用户不友好，空间占用大，集群环境容易重复</li><li>Redis自增：优点利用redis操作原子性的特征,可以保证在并发的时候不会重复，拓展性强,可以方便的结合业务进行处理；缺点增加一侧网络开销 需要对reids服务实现高可用</li><li>snowflake算法：优点性能较优,速度快 无需第三方依赖,实现也简单 可以根据实际情况调整和拓展算法,方便灵活；缺点依赖时间机器,如果发生回拨会导致生成id重复</li><li>数据库自增：优点无需编码，性能也过得去，索引友好；缺点大表不能做水平分表,否则插入删除易出现问题，依赖前期规划,拓展麻烦 依赖mysql内部维护自增锁,高并发下插入数据影响性能</li></ul><h3 id="秒杀数据表"><a href="#秒杀数据表" class="headerlink" title="秒杀数据表"></a>秒杀数据表</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券，平价券可以任意购买，而特价券需要秒杀抢购，表关系如下</p><p>tb_voucher（平价与秒杀券都有）：优惠券基本信息（金额，规则等）:上面的type可以表示标识出是平价券还是特价券，如果是特价券我们也需要一些特定的信息，因此我们会专门拓展出一张表。<br>tb_seckill_voucher（对应秒杀券）：优惠券库存、开始抢购时间、结束抢购时间（特价券需要此表）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tb_voucher<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>shop_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'商铺id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>title<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'代金券标题'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>sub_title<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'副标题'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>rules<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'使用规则'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>pay_value<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'支付金额，单位是分。例如200代表2元'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>actual_value<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'抵扣金额，单位是分。例如200代表2元'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>type<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span> <span class="token keyword">COMMENT</span> <span class="token string">'0,普通券；1,秒杀券'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>status<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span> <span class="token keyword">COMMENT</span> <span class="token string">'1,上架; 2,下架; 3,过期'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tb_seckill_voucher<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>voucher_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'关联的优惠券的id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>stock<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'库存'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>begin_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'生效时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>end_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'失效时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>voucher_id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_general_ci <span class="token keyword">COMMENT</span> <span class="token operator">=</span> <span class="token string">'秒杀优惠券表，与优惠券是一对一关系'</span> ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h3><p>在VoucherController中提供一个接口，调用就可以实现添加普通券。mapper中普通券除了定义对应tb_voucher的内容，还添加了库存、生效时间和失效时间字段。这样添加普通券和添加秒杀券都可以通过这个类传递对象，传递过来以后如果是普通券，这几个字段默认exsit=false（也就是没有该字段到数据库表的映射），直接利用VoucherServiceImpl的save方法保存即可。如果是秒杀券，就首先save到tb_voucher，再对库存、生效时间、失效时间等手动保存，利用seckillVoucherService添加到tb_seckill_voucher表。也就实现了通过前端一次传递，就在后端保存两张表的信息，简化代码逻辑。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519145646945.png" alt="image-20240519145646945" style="zoom:80%;"><h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><p><strong>接口地址</strong>:<code>/voucher-order/seckill/{id}</code></p><p><strong>请求方式</strong>:<code>POST</code></p><p><strong>请求参数</strong>:</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>请求类型</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>id</td><td>优惠券id</td><td>path</td><td>true</td><td>integer(int64)</td><td></td></tr></tbody></table><p><strong>返回值</strong>：订单id</p><p>基础功能实现（不考虑并发）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span>  <span class="token comment">// 涉及多表操作，添加事务以便回滚</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">seckillVoucher</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 查询优惠券</span>    <span class="token class-name">SeckillVoucher</span> voucher <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀券不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 判断时间区间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getBeginTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀尚未开始！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀已经结束！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 判断库存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 扣减库存</span>    <span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 创建订单</span>    <span class="token class-name">VoucherOrder</span> voucherOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VoucherOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> orderId <span class="token operator">=</span> redisIdWorker<span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token string">"order"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    voucherOrder<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 从threadlocal中取用户id</span>    <span class="token class-name">Long</span> userId <span class="token operator">=</span> <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>userId <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"用户未登录！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    voucherOrder<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>    voucherOrder<span class="token punctuation">.</span><span class="token function">setVoucherId</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保存订单</span>    <span class="token function">save</span><span class="token punctuation">(</span>voucherOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回订单id</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h2><p>以上代码存在线程安全问题。高并发场景下会有库存超卖 – 在库存为1的时候，多个线程同时查询库存，得到库存1，后面的线程读到的都是脏数据。</p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：</p><p><strong>悲观锁</strong>：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保<strong>线程串行执行</strong>。（Synchronized、Lock等）</p><p><strong>乐观锁</strong>：认为线程安全问题不一定会发生，因此<strong>不加锁</strong>，只是<strong>在更新数据时去判断有没有其它线程对数据做了修改</strong>。（如果没有修改，那就是安全的；<strong>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常</strong>）</p><p>显然乐观锁的性能会好很多，但是实现起来会更复杂，我们要处理好关键的一点，那就是更新数据的时候，该<strong>如何去判断有没有其它线程对数据做了修改</strong>。</p><p>乐观锁的实现方式有2种方法（其实思想相同）：<br><strong>1、版本号法：</strong><br>给数据增加一个字段version，初始值为1，每次我们<strong>要修改库存量之前都需要先查询库存量与版本号</strong>，然后线程执行SQL语句，执行SQL语句必须要确定数据库中的这条数据的版本号就是查询出来的版本号，<strong>如果不相同说明有其他线程修改了数据</strong>，导致当前数据的版本号与之前查询的不一样：<br><strong>2、CAS法</strong><br>上面的方法加一个版本号其实是一种标识，但是我们不一定要借助version，实际上我们可以<strong>直接依靠库存量来做标识</strong>，在对数据库进行修改的时候，我们要首先判断当前数据的库存量与之前线程查询出来的库存量是否相同，不相同则说明发生线程安全问题，不能修改</p><h3 id="乐观锁解决超卖"><a href="#乐观锁解决超卖" class="headerlink" title="乐观锁解决超卖"></a>乐观锁解决超卖</h3><p>我们选用CAS法来解决超卖，根据上述思想，我们只需要在SQL语句那增加一个判断库存量的条件：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 扣减库存</span><span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"stock"</span><span class="token punctuation">,</span> voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用Jmeter测试发现200个线程抢100张票，只卖出了20+张票。</p><p><strong>问题</strong>：假设stock=100，当线程查询出来的stock与数据库的stock不一致的时候，并不能说明票卖完了，只能说明其他线程抢先了票。理论上库存量大概率不为0，该线程还是应该要能够实现买票操作，但全都因为查询的stock与数据库不一致导致有大量线程买票失败。</p><p><strong>修改</strong>：只需要查询数据库中的stock是否大于0即可。— <code>.gt("stock", 0)</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token string">"stock"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// /where id = ? and stock &gt; 0</span>    <span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新测试发现能够正好下单100份秒杀券。</p><blockquote><p>但是这不代表乐观锁就是完美的，很显然代码逻辑中要操作数据库，大量的线程就会给数据库带来压力，仅仅使用乐观锁在更高并发的场景下还是不太够的。</p></blockquote><h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单。</p><p>解决：只需要判断当前尝试抢优惠券的线程，其用户id在订单表中是否已经存在了，如果存在则不允许下单。</p><p>这里仍然会有多线程问题，由于这段逻辑不涉及数据库更新而是要插入数据，所以<strong>加悲观锁</strong>。这里锁放在函数内部，因为如果在方法上加锁，那么不管是哪个用户来下单都变成串行了，所以我们需要在内部调用synchronized，并指定锁定对象为userId。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoucherOrderServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">VoucherOrderMapper</span><span class="token punctuation">,</span> <span class="token class-name">VoucherOrder</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">IVoucherOrderService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">ISeckillVoucherService</span> seckillVoucherService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">RedisIdWorker</span> redisIdWorker<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">seckillVoucher</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 查询优惠券</span>        <span class="token class-name">SeckillVoucher</span> voucher <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀券不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 判断时间区间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getBeginTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀尚未开始！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀已经结束！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 判断库存</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Transactional</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">createVoucherOrder</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从threadlocal中取用户id</span>        <span class="token class-name">Long</span> userId <span class="token operator">=</span> <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * userId值一样的，我们用同一把锁，即为同一个用户的多线程访问加锁。         * 但是每个请求一来，我们的id对象都是全新的（toString得到的是新的string对象）         * 所以要加上intern()方法，从字符串常量池中返回字符串的规范表示，保证多个请求访问一个用户字符串时得到的是同样的地址         */</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>userId<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 查询用户是否已经下单了对应优惠券</span>            <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"user_id"</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"用户已经购买！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 没买过，扣减库存</span>            <span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token string">"stock"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 创建订单</span>            <span class="token keyword">long</span> orderId <span class="token operator">=</span> redisIdWorker<span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token string">"order"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">VoucherOrder</span> voucherOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VoucherOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            voucherOrder<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>            voucherOrder<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>            voucherOrder<span class="token punctuation">.</span><span class="token function">setVoucherId</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 保存订单</span>            <span class="token function">save</span><span class="token punctuation">(</span>voucherOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回订单id</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意一个细节，<strong>上面代码还是会发生并发安全问题：</strong></p><blockquote><p>我们这边的整个函数已经是被Spring托管了，所以<strong>事务的提交会在函数执行完毕之后</strong>，也就是说我们会<strong>先释放锁，再提交事务</strong>，当我们事务还没有提交完成，<strong>修改数据还没写入数据库，却又有其他线程进来了</strong>，再次发生线程并发问题。</p></blockquote><h3 id="事务与锁顺序"><a href="#事务与锁顺序" class="headerlink" title="事务与锁顺序"></a>事务与锁顺序</h3><p>所以，锁的范围太小了，我们应该要把整个函数都锁起来。这样就是<strong>先获取锁，提交事务，再释放锁。</strong></p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519174917100.png" alt="image-20240519174917100"><h3 id="事务生效问题"><a href="#事务生效问题" class="headerlink" title="事务生效问题"></a>事务生效问题</h3><p>直接调用createVoucherOrder方法是不行的，因为它相当于调用了this.createVoucherOrder，然而当前类并不是代理对象，这会导致Sping代理失效。</p><blockquote><p>Spring的事务是通过AOP来实现的，只有通过代理对象调用<code>@Transactional</code>注解的对象方法时，事务才会生效，也就是直接调用<code>createVoucherOrder()</code>方法事务才会生效，调用<code>seckillVoucher()</code>方法后间接调用<code>createVoucherOrder()</code>方法事务是不会生效的。因为这次调用并不是通过代理对象来实现的。</p></blockquote><img src="/2024/05/13/hei-ma-dian-ping/image-20240519175418682.png" alt="image-20240519175418682"><p>所以我们要先获得当前对象的代理对象，然后再去调用这个函数（这个函数也要创建在service接口中，表明它属于代理对象能调用的方法）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>userId<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">IVoucherOrderService</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IVoucherOrderService</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要引入依赖：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">&lt;dependency<span class="token punctuation">&gt;</span>        &lt;groupId<span class="token punctuation">&gt;</span>org.aspectj&lt;/groupId<span class="token punctuation">&gt;</span>        &lt;artifactId<span class="token punctuation">&gt;</span>aspectjweaver&lt;/artifactId<span class="token punctuation">&gt;</span>&lt;/dependency<span class="token punctuation">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>并且在启动类中需要暴露代理对象：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519180101176.png" alt="image-20240519180101176" style="zoom:80%;"><p>使用Jmeter测试，同一用户200个线程，最终只插入一条数据。问题解决。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519222713031.png" alt="image-20240519222713031" style="zoom:80%;"><h2 id="集群下的线程并发安全问题"><a href="#集群下的线程并发安全问题" class="headerlink" title="集群下的线程并发安全问题"></a>集群下的线程并发安全问题</h2><p>现在已经通过加锁解决一人一单问题安全，但是这只能解决单机情况的，集群模式依旧不行。</p><p>利用idea模拟集群模式，复制一个新的服务，设置端口8082（program arguments）</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519225432012.png" alt="image-20240519225432012" style="zoom:80%;"><p>重启形成2个机子的集群：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519231204101.png" alt="image-20240519231204101"><p>修改nginx的conf目录下的nginx.conf文件，配置反向代理、负载均衡：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519230039737.png" alt="image-20240519230039737" style="zoom:80%;"><p>最后重新加载一下Nginx：<code>nginx.exe -s reload</code></p><p>最后访问网址，并连续刷新2次：</p><blockquote><p><a href="http://localhost:8080/api/voucher/list/1">http://localhost:8080/api/voucher/list/1</a></p></blockquote><p>查看后台可以发现两个启动服务都可以接受到信息，因为api（8080）包括了8081与8082，访问是以<strong>轮询</strong>的方式进行的。这样就实现了负载均衡。</p><p>测试：需要在锁那里打个断点，并且在postman里面分别抢券（都用同一个用户）来进行优惠券抢购，可以发现只用1个用户信息，数据库中却少了2张券，说明又一次发生了并发问题。</p><blockquote><p>我们部署另外一台Tomcat，这是<strong>锁的锁监视器</strong>，<strong>其监视的内容和之前锁中的监视器内容是不一样的</strong>，那么新Tomcat的线程获取锁就会成功（获取的userId.toString()是不一样的，不理解的可以去看toString方法的源码），并成功的操作数据库，因此才会造成线程并行问题。<br>如下图，线程1、3发生了线程安全问题。因此我们只能保证单个JVM下的线程安全，却无法保证集群中多个JVM的线程安全，我们需要在集群中加锁，也就是<strong>分布式锁</strong>，将在后续讲解。</p></blockquote><img src="/2024/05/13/hei-ma-dian-ping/image-20240519231759949.png" alt="image-20240519231759949" style="zoom:80%;"><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="==分布式锁=="></a>==分布式锁==</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><strong>JVM内</strong>的线程之间可以用<strong>锁</strong>实现互斥，synchronized锁只能保证单个JVM内部的多个线程之间互斥，不能保证多JVM下多进程的互斥。因为每个JVM都只有一个锁监视器，但是多个JVM就会有多个锁监视器，导致多个线程获取到锁，从而发生线程安全问题。<br>因此，要实现互斥，可以<strong>让多个JVM都共用一个锁监视器</strong>，这样让JVM与JVM之间、每个JVM的线程之间都共用这个锁，就不会发生线程安全问题了。</p><p>由此引出<strong>分布式锁</strong>的定义：<strong>满足分布式系统或集群模式下多进程可见并且互斥的锁。</strong><br>需要满足的特点：多进程可见、互斥、高可用、高性能、安全性</p><h3 id="不同实现方式对比"><a href="#不同实现方式对比" class="headerlink" title="不同实现方式对比"></a>不同实现方式对比</h3><table><thead><tr><th></th><th>MySQL</th><th>Redis</th><th>Zookeeper</th></tr></thead><tbody><tr><td>互斥</td><td>本身的互斥锁机制</td><td>利用互斥命令setnx</td><td>利用节点的唯一性和有序性实现互斥</td></tr><tr><td>高可用</td><td>好</td><td>好</td><td>好</td></tr><tr><td>高性能</td><td>一般</td><td>好</td><td>一般</td></tr><tr><td>安全性</td><td>断开连接，自动释放锁</td><td>利用锁超时时间，到时释放</td><td>临时节点，断开连接自动释放</td></tr></tbody></table><h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul></li></ul><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可。（解决缓存击穿的互斥锁方案就用了）</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520153020729.png" alt="image-20240520153020729"><h3 id="实现分布式锁版本1"><a href="#实现分布式锁版本1" class="headerlink" title="实现分布式锁版本1"></a>实现分布式锁版本1</h3><p>直接在utils包下创建ILock接口与SimpleRedisLock 类，这个内容和之前的差不多</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleRedisLock</span> <span class="token keyword">implements</span> <span class="token class-name">ILock</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_PREFIX</span> <span class="token operator">=</span> <span class="token string">"lock:"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">// 不同业务有不同的锁，业务name即为锁的name</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SimpleRedisLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//获取线程表示</span>        <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取锁</span>        <span class="token class-name">Boolean</span> success <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                <span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> threadId <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">,</span> timeoutSec<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//防止拆箱操作，不能直接返回success</span>        <span class="token keyword">return</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着修改我们的下单业务的impl，改变之前的加锁逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建锁对象，key需要加上用户id，因为不同的用户无所谓，只有同一个用户才要锁起来，因此要指定好用户id</span><span class="token class-name">SimpleRedisLock</span> simpleRedisLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleRedisLock</span><span class="token punctuation">(</span><span class="token string">"order:"</span> <span class="token operator">+</span> userId<span class="token punctuation">,</span> stringRedisTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isLock <span class="token operator">=</span> simpleRedisLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">1200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取锁失败，由于是对一个人限制锁，所以获取失败直接返回</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"不允许重复下单！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token class-name">IVoucherOrderService</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IVoucherOrderService</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>    simpleRedisLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>集群下测试：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520155946888.png" alt="image-20240520155946888" style="zoom:80%;"><img src="/2024/05/13/hei-ma-dian-ping/image-20240520160019728.png" alt="image-20240520160019728" style="zoom:80%;"><h2 id="Redis分布式锁误删问题"><a href="#Redis分布式锁误删问题" class="headerlink" title="Redis分布式锁误删问题"></a>Redis分布式锁误删问题</h2><p><strong>情况：</strong>持有锁的线程<strong>在锁的内部出现了阻塞，导致他的锁自动释放</strong>，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，<strong>线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑</strong>，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p><strong>解决方案：</strong>解决方案就是在每个线程释放锁的时候，<strong>去判断一下当前这把锁是否属于自己，如果不属于自己，则不进行锁的删除</strong>，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前<strong>这把锁不是属于自己，于是不进行删除锁逻辑，</strong>当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><img src="/2024/05/13/hei-ma-dian-ping/1653385920025.png" alt="1653385920025" style="zoom:80%;"><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>根据上述的分析，我们需要修改一下分布式锁，使得满足：<br>1、在获取锁时存入线程标识</p><blockquote><p>在这里增加了UUID来作为线程的标识，不再使用线程自己的ID了，这是因为虽然每个JVM的线程都是递增的，每个JVM内部之间的都会维护线程的唯一ID，但是不同的JVM之间还是会产生冲突，因此让JVM自己去维护线程的ID，会导致不同JVM之间的ID冲突。<br>事实上，也可以用UUID来表示不同的JVM，用线程ID来区分JVM内部的线程，两者拼接在一块。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 增加线程标识的前缀</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、在释放锁时限获取锁中的线程标识，判断是否与当前线程标识一致（一致才可释放）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//获取线程表示</span>    <span class="token class-name">String</span> threadId <span class="token operator">=</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取锁</span>    <span class="token class-name">Boolean</span> success <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>        <span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> threadId <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">,</span> timeoutSec<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//防止拆箱操作，不能直接返回success</span>    <span class="token keyword">return</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取线程表示</span>    <span class="token class-name">String</span> threadId <span class="token operator">=</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取线程中的id，判断是否一致</span>    <span class="token class-name">String</span> redisId <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>redisId<span class="token punctuation">)</span><span class="token punctuation">)</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h2><p>上述的方式已经可以解决业务阻塞导致的误删操作，但是还会有一些问题：</p><blockquote><p>如果我们阻塞的不是业务，而是业务执行完了，并且<strong>判断锁标识成功，即将释放锁的时候发生的阻塞</strong>（这种阻塞不是业务阻塞，而可能是JVM内部的垃圾回收机制异常导致阻塞），这时候还会发生新的问题。<br>如果被阻塞的时间足够长，导致锁的TTL到期了，一旦释放，其他线程又开始乘虚而入，成功获取锁，执行业务。<br>这时候，被阻塞的线程恢复正常了，但是因为已经进行锁标识的逻辑判断了，这时候被阻塞的线程就可以完成这个释放锁的操作，再次造成误删问题。</p></blockquote><p>分析一下问题发生的原因，之所以会出现这种情况，主要原因是<strong>锁标识的逻辑判断与锁的释放操作，是两个不同的操作，不满足原子性，所以当在两个操作之间发生了阻塞，那么线程并发问题依旧会出现。</strong><br>所以，我们必须要保证<strong>判断锁标识</strong>的动作与<strong>释放锁</strong>的动作必须得保证<strong>原子性</strong>。</p><h2 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h2><p>想到原子性，我们很容易就想到MySQL中的事务，但是Redis中的事务却不太一样<strong>，Redis事务虽然能保障原子性，但是无法保证事务的一致性</strong>。Redis事务的操作是一系列的批处理，是在最终一次性执行的，必须要有乐观锁来做判断，会麻烦很多。</p><p>Lua语言能够保证原子性，是因为它在执行原子操作时会将其他线程或进程阻塞，直到该操作完成。</p><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AF%AD%E6%B3%95%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，语法如下：</a></p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'命令名称'</span><span class="token punctuation">,</span> <span class="token string">'key'</span><span class="token punctuation">,</span> <span class="token string">'其它参数'</span><span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我们要执行set name jack，则脚本是这样：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">#</span> 执行 set name jackredis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'jack'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">#</span> 先执行 set name jackredis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'Rose'</span><span class="token punctuation">)</span><span class="token operator">#</span> 再执行 get name<span class="token keyword">local</span> name <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token operator">#</span> 返回<span class="token keyword">return</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写好脚本以后，需要用Redis命令来调用脚本</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">EVAL script numkeys key… arg…<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，要执行redis.call(‘set’, ‘name’, ‘jack’)这个脚本。0表示key类型的参数的个数</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">EVAL “<span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>‘set’<span class="token punctuation">,</span> ‘name’<span class="token punctuation">,</span> ‘jack’<span class="token punctuation">)</span>” <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数 – 1代表key类型的参数有一个，也就是紧接着的name，会放入KEYS[1]，而Rose则放入ARGV[1]中</p><img src="/2024/05/13/hei-ma-dian-ping/1653392438917.png" alt="1653392438917"><h3 id="Java调用Lua脚本改造分布式锁"><a href="#Java调用Lua脚本改造分布式锁" class="headerlink" title="Java调用Lua脚本改造分布式锁"></a>Java调用Lua脚本改造分布式锁</h3><p>在resources下新建Lua文件：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- 锁中的线程标识与当前线程一致</span><span class="token keyword">if</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">then</span>    <span class="token comment">-- 释放锁</span>    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'del'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment">-- 不一致则什么也不做</span><span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在impl中增加静态变量，防止每次调用unLock函数都要重新调用Lua脚本。修改unLock函数，调用Lua脚本。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520171239197.png" alt="image-20240520171239197"><h2 id="分布式锁-Redisson"><a href="#分布式锁-Redisson" class="headerlink" title="==分布式锁-Redisson=="></a>==分布式锁-Redisson==</h2><p>基于setnx的分布式锁存在下面的问题：<br><strong>1、不可重入</strong>：同一个线程无法多次获取同一把锁（当同一个线程内，方法A获取了锁，然后调用方法B，方法B中没办法获取同一把锁）<br><strong>2、不可重试</strong>：获取锁只尝试一次就返回false，没有重试机制<br><strong>3、超时释放</strong>：虽然可以避免死锁，但如果业务耗时很长，也会导致锁释放，会再次发生线程安全问题<br><strong>4、主从一致性问题</strong>：若Redis提供了主从集群，主从同步存在延迟。当主节点宕机时，从节点充当主节点。如果从节点没有同步主节点中的锁数据，即没有锁标识，则会让其他节点拿到锁</p><p>Redisson是一个在Redis基础上实现的<strong>分布式工具集合</strong>，提供了很多分布式服务，包含了各种分布式锁的实现。</p><h3 id="Redisson快速入门"><a href="#Redisson快速入门" class="headerlink" title="Redisson快速入门"></a>Redisson快速入门</h3><p>引入依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.23.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置客户端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedissonConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RedissonClient</span> <span class="token function">redissonClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//配置</span>        <span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//添加Redis地址，这里添加的是单点的地址，也可以使用config.userClusterServer()来添加集群的地址</span>        config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"redis://ip:6379"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建客户端</span>        <span class="token keyword">return</span> <span class="token class-name">Redisson</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Redisson的分布式锁：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520185500237.png" alt="image-20240520185500237" style="zoom:80%;"><p>订单业务中的修改：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建锁对象，key需要加上用户id，因为不同的用户无所谓，只有同一个用户才要锁起来，因此要指定好用户id</span><span class="token comment">//        SimpleRedisLock simpleRedisLock = new SimpleRedisLock("order:" + userId, stringRedisTemplate);</span><span class="token comment">//        boolean isLock = simpleRedisLock.tryLock(1200);</span><span class="token comment">// 获取锁（可重入），指定锁的名称</span><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock:order:"</span> <span class="token operator">+</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>…………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Redisson的可重入锁原理"><a href="#Redisson的可重入锁原理" class="headerlink" title="Redisson的可重入锁原理"></a>Redisson的可重入锁原理</h2><img src="/2024/05/13/hei-ma-dian-ping/image-20240520192526025.png" alt="image-20240520192526025" style="zoom:80%;"><p>我们需要找到一种数据结构，能够<strong>在一个key里面获取多个东西</strong>——Hash：</p><p>Hash结构（hset）的KEY对应的VALUE包含了field与value，因此我们可以<strong>让KEY对应锁名称，让field对应线程标识，让value位置记录锁的重入次数</strong>（初始为0）。</p><p>因此，发生上述情况的时候，虽然线程的标识是相同的，但我们可以<strong>将重入次数+1，代表第二次获取锁，这时候整体的VALUE是不相同的。</strong><br>需要注意的是，method2执行完毕以后不能直接释放这个key对应的锁，因为这样的话会导致method1没有执行完毕就被删掉了，解决的方法是让重入次数-1，只有<strong>所有业务都执行完了（重入次数=0）的时候才能真正释放。</strong><br>这样我们的流程就会发生变化（哈希结构没有直接的EX来设置有效期）：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520193101664.png" alt="image-20240520193101664"><p>用Lua脚本来保证代码的原子性，而Lua代码获取锁与释放锁的逻辑已经是保存到RedissonLock类中了，我们只需要直接调用tyrLock与unlock方法就行。</p><blockquote><p>总结：Redisson的可重入原理的核心就是因为我们使用了hash结构，记录了获取锁的线程以及可重用的次数</p></blockquote><h2 id="Redisson的锁重试和WatchDog机制"><a href="#Redisson的锁重试和WatchDog机制" class="headerlink" title="Redisson的锁重试和WatchDog机制"></a>Redisson的锁重试和WatchDog机制</h2><p>redisson在尝试获取锁的时候，如果传了时间参数，就不会在获取锁失败时立即返回失败，而是会进行重试。</p><ul><li><p><strong>waitTime：</strong>是<strong>最大等待时间</strong>，如果使用 <strong>tryLock()</strong> 的时候，<strong>有传参数</strong>表明是<strong>可重试的锁</strong>；反之，不是！</p></li><li><p><strong>leaseTime</strong>：超时释放时间，默认是-1，建议不要设定，Redisson<strong>看门狗机制</strong>可以进行<strong>锁续约</strong></p></li></ul><h3 id="锁重试"><a href="#锁重试" class="headerlink" title="锁重试"></a>锁重试</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>tryLock()</strong> ：里面实现了<strong>重试机制</strong>。通过<strong>消息订阅</strong>和<strong>信号量机制</strong>，避免了 <strong>while(true)</strong> 让其一直无效尝试，避免了<strong>CPU空转问题</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token comment">// 转成毫秒，后面都是以毫秒为单位</span>    <span class="token keyword">long</span> time <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前时间</span>    <span class="token keyword">long</span> current <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 线程ID-线程标识</span>    <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 尝试获取锁，返回锁的剩余过期时间（对应获取锁的lua脚本的返回值） tryAcquire() ==========!!!</span>    <span class="token class-name">Long</span> ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果上面尝试获取锁返回的是null，表示成功；如果返回的是时间则表示失败。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 剩余等待时间 = 最大等待时间 -（用现在时间 - 获取锁前的时间）</span>    time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> current<span class="token punctuation">;</span>    <span class="token comment">// 剩余等待时间 &lt; 0 失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 再次获取当前时间</span>    current <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ==================重试逻辑，但不是简单的直接重试！==================</span>    <span class="token comment">// subscribe是订阅的意思，订阅锁的释放事件</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">&gt;</span></span> subscribeFuture <span class="token operator">=</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待一段时间，看是否能获取到锁的释放事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 如果等待超时，则取消订阅并获取锁失败，返回false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            subscribeFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token comment">// 取消订阅</span>                    <span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscribeFuture<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 获取锁失败</span>        <span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// =======循环重试=======</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// 减去已经消耗的时间</span>        time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> current<span class="token punctuation">;</span>        <span class="token comment">// 如果还有剩余等待时间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token comment">// 获取当前时间戳</span>                <span class="token keyword">long</span> currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 再次尝试获取锁，返回锁的剩余过期时间</span>                ttl <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果锁成功获取</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 减去已经消耗的时间</span>                time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> currentTime<span class="token punctuation">;</span>                <span class="token comment">// 如果等待时间已经用完，则获取锁失败，返回false</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 根据剩余时间尝试获取锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">&gt;=</span> <span class="token number">0L</span> <span class="token operator">&amp;&amp;</span> ttl <span class="token operator">&lt;</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 这里采用====信号量机制=======，等待释放锁的线程释放锁</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">)</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                        <span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>ttl<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">// 如果这个ttl时间比当前线程尝试获取锁的时间还长</span>                    <span class="token comment">// 那么就直接等待尝试获取锁的时间</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">)</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                        <span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 减去已经消耗的时间</span>                time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> currentTime<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果还有剩余等待时间，则继续尝试获取锁</span>            <span class="token comment">// 如果等待时间已经用完，则获取锁失败，返回false</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 如果等待时间已经用完，则获取锁失败，返回false</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment">// 释放订阅</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscribeFuture<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在 tryLock() 中调 tryAcquire() 执行获取锁的操作</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Long</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 尝试以异步方式获取锁的剩余过期时间。 * @param waitTime 等待时间 * @param leaseTime 锁的租期时间 * @param unit 时间单位 * @param threadId 当前线程ID * @return 表示剩余过期时间的Future对象 */</span><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 锁自动释放时间为默认的-1，所以会走else。如果设定了释放时间，走if</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leaseTime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_LONG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// leaseTime我们没有传，这里设定默认值（看门狗）30s</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> ttlRemainingFuture <span class="token operator">=</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span>            commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCfg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_LONG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在获取剩余过期时间的异步结果完成后，执行回调、回调函数 ttlRemaining：剩余有效期，e：异常</span>    ttlRemainingFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ttlRemaining<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 剩余有效期为null，表示获取锁成功！</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlRemaining <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 锁续约</span>            <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ttlRemainingFuture<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 把 leaseTime锁释放时间 记录成一个本地的成员变量</span>    internalLockLeaseTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取锁成功返回nil（空），失败返回时间，锁的剩余有效期（pttl是以毫秒为单位）</span>    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> command<span class="token punctuation">,</span>            <span class="token string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return nil; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return nil; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"return redis.call('pttl', KEYS[1]);"</span><span class="token punctuation">,</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="超时续约"><a href="#超时续约" class="headerlink" title="超时续约"></a>超时续约</h3><p><strong>那么此时还有一个问题，如果当前持有锁的线程业务阻塞了，TTL到期了别其它线程获取到了锁，那么此时就会有安全问题了</strong></p><p>而Redisson是通过看门狗来解决这个问题的</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 更新锁的有效期 * @param threadId 当前线程ID */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 这个entry里主要存储了两个东西，一个是更新锁释放时间的定时任务，还有一个就是线程ID</span>    <span class="token class-name">ExpirationEntry</span> entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExpirationEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将entry添加到ConcurrentHashMap中，如果是第一次添加则会返回null</span>    <span class="token comment">// 保证每次重入拿到的是同一个extry</span>    <span class="token class-name">ExpirationEntry</span> oldEntry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEntry <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 将当前线程ID添加到旧的entry中</span>        oldEntry<span class="token punctuation">.</span><span class="token function">addThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token comment">// 如果旧的条目为null，说明是第一次添加该条目</span>        <span class="token comment">// 将当前线程ID添加到map中</span>        entry<span class="token punctuation">.</span><span class="token function">addThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 第一次来，就需要创建的更新释放时间的定时任务</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 续约锁的过期时间。 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取锁的过期续约条目</span>    <span class="token class-name">ExpirationEntry</span> ee <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果续约条目不为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ee <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建一个定时任务，用于===定时执行续约操作===</span>        <span class="token class-name">Timeout</span> task <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newTimeout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Timeout</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                <span class="token comment">// 获取锁的过期续约条目</span>                <span class="token class-name">ExpirationEntry</span> ent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果续约条目不为null</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 获取第一个等待续约的线程ID</span>                    <span class="token class-name">Long</span> threadId <span class="token operator">=</span> ent<span class="token punctuation">.</span><span class="token function">getFirstThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 如果线程ID不为null</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 异步执行续约操作</span>                        <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 在续约操作完成后执行回调</span>                        future<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment">// 如果续约操作出现异常，则记录日志</span>                                <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Can't update lock "</span> <span class="token operator">+</span> <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" expiration"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token comment">// 如果更新超时时间成功，继续递归更新超时时间</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>internalLockLeaseTime <span class="token operator">/</span> <span class="token number">3L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新间隔为看门狗时间的1/3也就是30秒</span>        <span class="token comment">// 将定时任务设置到续约条目中</span>        ee<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看一下释放锁的源码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 异步释放锁。 * @param threadId 当前线程ID * @return 表示释放结果的Future对象 */</span><span class="token keyword">public</span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">unlockAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 创建一个Promise对象，用于表示释放结果</span>    <span class="token class-name">RPromise</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedissonPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 异步执行内部的解锁操作</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unlockInnerAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在解锁操作完成后执行回调</span>    future<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>opStatus<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token comment">// 取消锁的自动更新释放时间</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果解锁操作出现异常</span>            <span class="token comment">// 设置Promise为失败状态，并将异常作为失败原因</span>            result<span class="token punctuation">.</span><span class="token function">tryFailure</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>opStatus <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果操作状态为null，说明锁未被当前线程持有</span>            <span class="token comment">// 设置Promise为失败状态，并抛出IllegalMonitorStateException异常</span>            <span class="token class-name">IllegalMonitorStateException</span> cause <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token string">"attempt to unlock lock, not locked by current thread by node id: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">+</span> <span class="token string">" thread-id: "</span> <span class="token operator">+</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">tryFailure</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 否则，解锁成功</span>            <span class="token comment">// 设置Promise为成功状态</span>            result<span class="token punctuation">.</span><span class="token function">trySuccess</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回表示释放结果的Future对象</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>取消自动更新锁的释放时间方法</p><p>EXPIRATION_RENEWAL_MAP对应上面添加更新任务，这个Map里存的是一个个ExpirationEntry，ExpirationEntry里主要包含定时更新锁释放时间的任务和线程ID</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 取消锁的过期续约。 * @param threadId 要取消续约的线程ID，如果为null，则表示取消所有线程的续约 */</span><span class="token keyword">void</span> <span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span><span class="token class-name">Long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取锁的过期续约任务</span>    <span class="token class-name">ExpirationEntry</span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果过期续约任务不为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 如果线程ID不为null，则移除指定线程的续约</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            task<span class="token punctuation">.</span><span class="token function">removeThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 如果线程ID为null，或者任务已经没有任何线程在续约</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> task<span class="token punctuation">.</span><span class="token function">hasNoThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 获取任务的定时器任务</span>            <span class="token class-name">Timeout</span> timeout <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">getTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果定时器任务不为null，则取消定时器任务</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                timeout<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 从过期续约映射中移除该任务</span>            <span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>首先线程来获<strong>尝试获取锁（调用Lua脚本）</strong>，判断Lua脚本的返回值TTL是否为NULL（为剩余释放时间说明获取失败）</p></li><li><p>ttl为空说明获取成功，判断锁的释放时间是否设置，<strong>为-1表示未设置，则开启看门狗（看门狗的释放锁时间为30秒）</strong></p></li><li><p>如果自己设置了锁的释放时间则不会启用开门狗，也就是是<strong>不会自动更新释放时间</strong></p></li><li><p>如果获取TTL<strong>不为null说明锁被其他线程给占用了</strong>，被占用就去判断当前线程的剩余等待时间是否大于0</p></li><li><p>剩余等待时间不大于0则说明等待超时直接返回false表示获取锁失败</p></li><li><p>剩余等待时间大于0则<strong>订阅等待锁的释放信号</strong>，等待别的线程的剩余释放时间</p></li><li><p>如果<strong>别的线程的释放时间大于等于当前获取锁线程的最大等待时间，则当前线程直接等待最大等待时间</strong></p></li><li><p>等待完毕后判断等待时间是否超时，是则返回false获取锁失败</p></li><li><p>没有超时则继续尝试获取锁</p></li></ul><img src="/2024/05/13/hei-ma-dian-ping/image-20240520194740741.png" alt="image-20240520194740741"><p>Redisson分布式锁原理：<br>1、可重入：利用hash结构记录线程id和重入次数<br>2、可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制<br>3、超时续约：利用watchDog，每隔一段时间（releaseTime/3），重置超时时间</p><h2 id="Redisson锁的MutiLock原理"><a href="#Redisson锁的MutiLock原理" class="headerlink" title="Redisson锁的MutiLock原理"></a>Redisson锁的MutiLock原理</h2><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，<strong>哨兵会发现主机宕机，并且选举一个slave变成master</strong>，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><img src="/2024/05/13/hei-ma-dian-ping/1653553998403.png" alt="1653553998403" style="zoom: 50%;"><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，<strong>每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功</strong>，假设现在某个节点挂了，那么他去获得锁的时候，<strong>只要有一个节点拿不到，都不能算是加锁成功</strong>，就保证了加锁的可靠性。</p><img src="/2024/05/13/hei-ma-dian-ping/1653554055048.png" alt="1653554055048" style="zoom: 50%;"><p>那么MutiLock 加锁原理是什么呢？</p><p>当我们去设置了多个锁时，redission<strong>会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁</strong>，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，<strong>那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</strong></p><img src="/2024/05/13/hei-ma-dian-ping/1653553093967.png" alt="1653553093967"><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>1）不可重入Redis分布式锁：</p><p>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示<br>缺陷：不可重入、无法重试、锁超时失效</p><p>2）可重入的Redis分布式锁：</p><p>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待<br>缺陷：redis宕机引起锁失效问题</p><p>3）Redisson的multiLock：</p><p>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功<br>缺陷：运维成本高、实现复杂</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员Redis部分资料</p><p>Cookie、Session、Token概念、区别、如何实现：<a href="https://blog.csdn.net/weixin_44369049/article/details/132062232">https://blog.csdn.net/weixin_44369049/article/details/132062232</a></p><p>CSDN博主布布要成为最负责的男人笔记：<a href="https://blog.csdn.net/m0_52380556?type=blog">https://blog.csdn.net/m0_52380556?type=blog</a></p><p>redisson：<a href="https://blog.csdn.net/weixin_53946852/article/details/137270519">https://blog.csdn.net/weixin_53946852/article/details/137270519</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DepGraph: Towards Any Structural Pruning</title>
      <link href="/2024/05/13/depgraph-towards-any-structural-pruning/"/>
      <url>/2024/05/13/depgraph-towards-any-structural-pruning/</url>
      
        <content type="html"><![CDATA[<h1 id="DepGraph-Towards-Any-Structural-Pruning"><a href="#DepGraph-Towards-Any-Structural-Pruning" class="headerlink" title="DepGraph: Towards Any Structural Pruning"></a>DepGraph: Towards Any Structural Pruning</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>结构化剪枝通过从神经网络中<strong>删除结构化分组的参数</strong>来实现模型加速。然而，参数分组模式在不同的模型中存在很大差异，这使得特定于体系结构的修剪器<strong>依赖于手工设计的分组方案，无法推广到新的体系结构中</strong>。</p><p>本工作在结构化剪枝的<strong>自动化上做了改进</strong>，提出了一种非深度图算法DepGraph，实现了<strong>架构通用的结构化剪枝</strong>，适用于CNNs,，Transformers, RNNs, GNNs等网络。DepGraph能够显式地建模层之间的依赖关系，并对耦合参数进行综合剪枝。自动地分析复杂的结构耦合，从而正确地移除参数实现网络加速。基于DepGraph算法，作者开发了PyTorch结构化剪枝框架 Torch-Pruning。不同于依赖Masking实现的“模拟剪枝”，该框架能够<strong>实际地移除参数和通道，降低模型推理成本</strong>。在DepGraph的帮助下，研究者和工程师无需再与复杂的网络结构斗智斗勇，可以轻松完成复杂模型的一键剪枝。</p><p>本文在几个架构和任务包括ResNe (X)t，DenseNet，MobileNet，VIT，GAT，DGCNN，LSTM上进行广泛评估。并证明提出的方法始终产生令人满意的性能。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>模型部署优化：通过减小模型大小，提高推理速度等，使得模型能够成功部署在各个硬件之中去并且实时有效的运作</p><h3 id="模型剪枝"><a href="#模型剪枝" class="headerlink" title="模型剪枝"></a>模型剪枝</h3><p>深度学习网络模型从卷积层到全连接层存在着大量冗余的参数，大量神经元激活值趋近于0，将这些神经元去除后可以表现出同样的模型表达能力，这种情况被称为过参数化，而对应的技术则被称为模型剪枝。</p><p>Dropout和DropConnect代表着非常经典的模型剪枝技术。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/3e76176a7a84934ac3c2773f8ce98490.png" alt="img" style="zoom:80%;"><p>Dropout中随机的将一些<strong>神经元的输出置零</strong>，这就是<strong>神经元剪枝</strong>。DropConnect则随机的将一些<strong>神经元之间的连接置零</strong>，使得<strong>权重连接矩阵变得稀疏</strong>，这便是<strong>权重连接剪枝</strong>。它们就是最细粒度的剪枝技术，只是这个操作仅仅发生在训练中，对最终的模型不产生影响，因此没有被称为模型剪枝技术。</p><p>当然，模型剪枝不仅仅只有对神经元的剪枝和对权重连接的剪枝，根据粒度的不同，至少可以粗分为4个粒度。</p><ul><li>细粒度剪枝(fine-grained)：即对连接或者神经元进行剪枝，它是粒度最小的剪枝。</li><li>向量剪枝(vector-level)：它相对于细粒度剪枝粒度更大，属于对<strong>卷积核内部(intra-kernel)的剪枝</strong>。</li><li>核剪枝(kernel-level)：即<strong>去除某个卷积核</strong>，它将丢弃对输入通道中对应计算通道的响应。</li><li>滤波器剪枝(Filter-level)：对<strong>整个卷积核组进行剪枝</strong>，会造成推理过程中输出特征通道数的改变。</li></ul><blockquote><p>细粒度剪枝(fine-grained)，向量剪枝(vector-level)，核剪枝(kernel-level)方法在参数量与模型性能之间取得了一定的平衡，但是<strong>网络的拓扑结构本身发生了变化</strong>，需要专门的算法设计来支持这种稀疏的运算，被称之为<strong>非结构化剪枝</strong>。</p><p>而滤波器剪枝(Filter-level)只改变了<strong>网络中的滤波器组和特征通道数目</strong>，所获得的模型不需要专门的算法设计就能够运行，被称为<strong>结构化剪枝</strong>。除此之外还有对整个网络层的剪枝，它可以被看作是滤波器剪枝(Filter-level)的变种，即所有的滤波器都丢弃。</p></blockquote><p>Google在《To prune, or not to prune: exploring the efficacy of pruning for model compression》[1]中探讨了具有同等参数量的稀疏大模型和稠密小模型的性能对比，在图像和语音任务上表明<strong>稀疏大模型普遍有更好的性能</strong>。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>首先训练一个大模型至最佳性能。</li><li>对模型的权重进行分析，去除那些对模型输出影响最小的权重。</li><li>对经过剪枝的模型重新进行微调，以恢复因剪枝造成的性能下降。</li></ul><h3 id="模型量化"><a href="#模型量化" class="headerlink" title="模型量化"></a>模型量化</h3><p>我们知道为了保证较高的精度，大部分的科学运算都是采用浮点型进行计算，常见的是32位浮点型和64位浮点型，即float32和double64。</p><p>对于深度学习模型来说，<strong>乘加计算量是非常大的</strong>，往往需要GPU等专用的计算平台才能实现实时运算，这对于端上产品来说是不可接受的，而模型量化是一个有效降低计算量的方法。</p><p><strong>量化，即将网络的权值，激活值等从高精度转化成低精度的操作过程</strong>，例如将32位浮点数转化成8位整型数int8，同时我们期望转换后的模型准确率与转化前相近。</p><p>模型量化可以带来几方面的优势，如下。</p><p>(1) 更小的模型尺寸。以8bit量化为例，与32bit浮点数相比，我们可以<strong>将模型的体积降低为原来的四分之一，</strong>这对于模型的存储和更新来说都更有优势。</p><p>(2) 更低的功耗。移动8bit数据与移动32bit浮点型数据相比，前者比后者高4倍的效率，而在一定程度上内存的使用量与功耗是成正比的。</p><p>(3) 更快的计算速度。相对于浮点数，大多数处理器都支持8bit数据的更快处理，如果是二值量化，则更有优势。</p><h3 id="知识蒸馏"><a href="#知识蒸馏" class="headerlink" title="知识蒸馏"></a>知识蒸馏</h3><p>一般地，大模型往往是单个复杂网络或者是若干网络的集合，拥有良好的性能和泛化能力，而小模型因为网络规模较小，表达能力有限。<strong>利用大模型学习到的知识去指导小模型训练</strong>，使得小模型具有与大模型相当的性能，但是参数数量大幅降低，从而可以实现模型压缩与加速，就是知识蒸馏与迁移学习在模型优化中的应用。Hinton等人最早在文章“Distilling the knowledge in a neural network”中提出了知识蒸馏这个概念，其核心思想是一旦复杂网络模型训练完成，便可以用另一种训练方法<strong>从复杂模型中提取出来更小的模型</strong>，因此知识蒸馏框架通常包含了一个大模型(被称为teacher模型)，和一个小模型(被称为student模型)。</p><p>具体的方法是在训练小模型时，在损失函数中添加额外的损失函数，损失函数的添加方式有以下几种：</p><p><strong>1.输出层的差异损失</strong>：这种方法是对比学生网络和教师网络在输出层上的概率分布之间的差异；</p><p><strong>2.隐藏层的相似度损失（余弦相似度损失）</strong>：这种方法是对比学生网络和教师网络在隐藏层的相似度差异；</p><p><strong>3.中间层的回归损失（均方误差，mse）</strong>：计算学生网络和教师网络在中间层的均方误差</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>边缘计算应用需要深度神经网络的压缩。在众多的网络压缩范式中，剪枝已经被证明是高效和实用的。网络剪枝的目标是<strong>从给定的网络中去除冗余参数，以使模型更轻量化，并潜在地加快推理速度。</strong>主流剪枝方法大致可分为两类：结构化剪枝和非结构化剪枝。</p><ul><li>结构化剪枝：通过从物理上去除分组参数来改变神经网络的结构；</li><li>非结构化剪枝：对部分权值进行调零，而不修改网络结构。</li></ul><p>在实践中非结构化剪枝能够直接地实现并且天然适用于各种网络，但它通常需要专门的人工智能加速器或软件来实现模型加速。而结构化剪枝不依赖于特定的人工智能加速器或软件来减少内存消耗和计算成本，应用更广泛。</p><p>挑战1：</p><p>深度神经网络建立在大量的基本模块之上，如卷积、标准化或激活，然而这些模块，无论参数化或未参数化，都是通过复杂的连接内在耦合的。因此，<strong>即使我们试图从CNN中只删除一个channel（如图1a），我们必须同时处理它对所有层的相互依赖关系</strong>。（这张图中，残差连接需要两个conv的参数来共享channel，所以修改conv2需要同时修改conv1，BN1，BN2）</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240513144816132.png" style="zoom:80%;"><p>（<em>图1：来自不同层的参数在跨网络架构中本质上是相互依赖的，这迫使多个层必须同时被修剪。本文引入了一个通用的方案，称为依赖图，以显式地解释这种依赖，并以全自动的方式对任意架构执行修剪。</em>）</p><ul><li>依赖性不仅出现在残差结构中，在现代模型中可能是无限复杂的。现有的结构化剪枝方案都依赖于个案分析，也就是<strong>针对于特定的网络</strong>。虽然效果好但费时费力且不能推广。</li><li>本文模型为了跟踪不同层之间的依赖关系，<strong>将依赖链分解并建模为一个递归过程</strong>，这自然可以归结为<strong>在图中寻找最大连通分量</strong>的问题，并且可以通过图遍历来实现O (N)复杂度。具体来说，对于网络中要修剪的层，可以将其作为根来触发相邻耦合层上的修剪，然后继续以被触发层为起点递归重复触发过程。通过这样做，可以全面收集所有耦合层以进行修剪。</li></ul><p>挑战2：</p><p>在结构剪枝中，分组层同时被修剪，这期望<strong>同一组中所有被删除的参数都是不重要的</strong>。这样的话，由于和其他层之间的关联，在单层中的参数重要性就不能反映真实情况。在不同的层上估计的重要性很可能是非加性的，有时甚至是相互矛盾的，这使得很难选择真正不重要的组来进行修剪。</p><p>为了解决这个问题，本文利用DepGraph的依赖建模能力设计了一个“分组级别”的重要性标准，该准则学习组内的一致稀疏性，以便可以安全地删除那些归零的层，而不会造成太多的性能损失。通过依赖建模，在实验中表明了一个简单的L2范数准则可以达到与现代方法相当的性能。</p><p>总之，本文的贡献是针对任何结构修剪的通用修剪方案，称为依赖图（DepGraph），它允许自动参数分组，并有效地提高了各种网络架构（包括CNN、RNN、GNN和Vision Transformer）上结构修剪的可推广性。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul><li><p>剪枝：剪枝算法的设计空间包括一系列方面，包括<strong>剪枝方案、参数选择、层稀疏性和训练技术</strong>。近年来，人们引入了许多稳健的标准，如基于幅度的标准和基于梯度的标准。另一种类型的方法通过稀疏训练来区分不重要的参数，稀疏训练将一些参数推到零以进行修剪。与那些静态标准相比，稀疏训练更可能找到不重要的参数，但由于需要网络训练，因此需要更多的计算资源。最近，还进行了一项综合性研究，以评估各种标准的效果，并提供一个公平的基准。</p></li><li><p>修剪分组参数：依赖性建模是任何结构修剪的关键和前提步骤，因为它涉及同时删除由于复杂的网络架构而在结构上彼此耦合的参数。剪枝分组参数的概念从结构剪枝的早期就已被研究。例如，<strong>当修剪两个连续卷积层时，修剪第一层内的卷积核会导致在后续层中去除与该滤波器相关的核</strong>。最近，已经提出了一些试点工作来解决层之间的复杂关系，并利用分组属性来提高结构修剪性能。</p><p>不幸的是，现有的技术仍然依赖于经验规则或预定义的架构模式，这使得它们在所有结构剪枝应用程序中都不够通用。在本研究中，我们提出了一种解决这一挑战的通用方法，证明了解决参数依赖性有效地推广了广泛网络的结构剪枝，从而在多个任务上获得令人满意的性能。</p></li></ul><h2 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h2><h3 id="神经网络的依赖性"><a href="#神经网络的依赖性" class="headerlink" title="神经网络的依赖性"></a>神经网络的依赖性</h3><p>不失一般性，在全连接层开发本文方法。从由三个连续层组成的线性神经网络开始，如图2 (a)所示，分别由二维<strong>权重矩阵</strong>wl、wl+1和wl+2参数化。这种简单的神经网络可以通过<strong>去除神经元的结构</strong>修剪而变得轻量化。在这种情况下，很容易发现参数之间存在一些依赖关系，表示为wl⇔wl+1, 这<strong>迫使二者同时被修剪</strong>。具体而言，为了修剪连接wl和wl+1的第k个神经元，将移除wl [k, :]和wl+1[:, k]。</p><blockquote><p>当我们希望通过剪枝某个神经元（高亮表示）实现加速时，与该神经元相连的多组参数需要被同时移除，<strong>这些参数就组成了结构化剪枝的最小单元，通常称为组（Group）</strong>。然而，在不同的网络架构中，参数的分组方式通常千差万别。图2（b）-（d）分别可视化了残差结构、拼接结构、以及降维度结构所致的参数分组情况，这些结构甚至可以互相嵌套，从而产生更加复杂的分组模式。</p></blockquote><p>通过手动设计和模型特定的方案来处理层依赖性，以逐个案例的方式手动分析所有这些依赖关系是很难的，更不用说简单的依赖关系可以嵌套或组合成更任意复杂的模式。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240513160026964.png"><p>（<em>图2：在不同的结构中具有相互依赖性的分组参数。必须同时修剪所有突出显示的参数。</em>）</p><p>为了解决结构修剪中的依赖问题，在本文工作中引入了依赖关系图，它为依赖关系建模提供了一种通用的、全自动的机制。</p><h3 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h3><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>为了实现结构化剪枝，首先需要根据层之间的相互依赖关系进行分组。形式上，目标是找到一个分组矩阵G∈R^L*L，其中L是一个待修剪网络的深度，Gij=1表示第i层和第j层之间存在依赖关系。令Diag(G)=1^1×L来保证自依赖。使用分组矩阵，很容易<strong>找到所有与第i层相互依赖的耦合层</strong>，即找到组：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240513161232441.png"><p>然而，由于现代深度网络可能由<strong>数千层复杂的连接</strong>组成，从神经网络中估计分组模式并不简单，他可能产生一个<strong>大而复杂的分组矩阵G</strong>。在这个矩阵中，Gij不仅由第i层和第j层决定，而且还受到它们之间的中间层的影响。这种非局部隐式关系在大多数情况下都不能用简单的规则来处理。为了克服这一挑战，作者没有直接估计分组矩阵G，而是<strong>提出了一种等效但易于估计的依赖建模方法，即依赖图，从中可以有效地推导出G</strong>。</p><h4 id="依赖图-1"><a href="#依赖图-1" class="headerlink" title="依赖图"></a>依赖图</h4><p>考虑一个分组g = {w1, w2, w3}，其中存在依赖关系w1⇔w2，w2⇔w3和1⇔w3。可以观察到<strong>冗余依赖</strong>（例如w1到w3可以通过w1w2，w2w3来推出传递依赖）。首先，我们以w1为起点，并检查它对其他层的依赖性，例如w1⇔w2。此时w2作为新的起点以递归扩展依赖，触发w2⇔w3，<strong>这个递归过程最终以一个传递关系结束</strong>，w1⇔w2⇔w3。在这种情况下，我们只需要两个依赖关系来描述组g中的关系。类似地，第3.2节中讨论的分组矩阵对于依赖关系建模也是冗余的，因此可以在保留相同信息的同时，压缩成更少的边和更紧凑的形式。</p><p><strong>一种新的图D测量相邻层之间的局部相互依赖性，称为依赖图，可以作为分组矩阵G的有效约简。</strong></p><p><strong>依赖图只记录具有直接连接的相邻层之间的依赖关系。</strong>他具有和G一样的顶点，但是有尽可能少的边。形式上，D被构造为，对于所有的Gij = 1，在顶点i和j之间存在一条路径。因此，Gij可以通过检验D中顶点i和j之间的路径的存在来得到。</p><h4 id="网络分解"><a href="#网络分解" class="headerlink" title="网络分解"></a>网络分解</h4><p>在层级之间构建依赖图在实践中可能存在问题。一些基本层，如全连接层，可能有两种不同的修剪方案，如w[k, : ]和w[ : , k]，它们<strong>分别压缩输入和输出的维度</strong>（如前面图2所示，同样的全连接层，要考虑两种剪枝）。此外，网络还包含<strong>非参数化的操作，如跳跃连接</strong>，这也会影响层[40]之间的依赖性。</p><p>对于一个卷积层而言，我们可以对参数的不同维度进行独立的修剪，从而分别剪枝输入通道或者输出通道。然而，上述的依赖图D却无法对这一现象进行建模。为此，我们提出了一种更细粒度的模型描述符，<strong>将网络F（x；w）分解为更精细、更基本的组件</strong>，记为F = {f1，f2，…，fL}，其中每个组件f表示（1）一个参数层如卷积层 或者（2）一个非参数操作如残差连接。<strong>关注层的输入和输出之间的关系而不是在层之间建模</strong>。具体地说，将分量fi的输入和输出分别表示为𝑓𝑖−和𝑓𝑖+。对于任何网络，最终的分解都可以形式化为F = {𝑓1−，𝑓1+，…，𝑓L−，𝑓L+}。这种表示法更容易进行依赖关系建模，并允许<strong>对同一层使用不同的剪枝方案。</strong></p><h4 id="依赖建模"><a href="#依赖建模" class="headerlink" title="依赖建模"></a>依赖建模</h4><p>利用这种符号，我们将神经网络重新定义为方程2，其中可以识别出两种主要的依赖类型，即层间依赖和层内依赖，如下所示：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240516144322342.png" alt="image-20240516144322342" style="zoom:80%;"><p><strong>符号↔表示两个相邻层之间的连通性。</strong>对这两个依赖关系的检查产生了简单但通用的<strong>依赖关系建模规则</strong>：</p><ul><li><p>层间依赖性：依赖性fi−⇔fj+持续出现在连接层中，其中𝑓𝑖−↔𝑓j+。由于一个层的输出和下一层的输入对应的是同一个中间特征（Feature），这就导致两者需要被同时剪枝。例如在通道剪枝中，“某一层的的输出通道剪枝”和“相邻后续层的输入通道剪枝”是等价的。</p></li><li><p>层内依赖性：在神经网络中，我们可以把各种层分为两类：第一类层的输入输出可以独立地进行剪枝，分别拥有不同的剪枝布局（pruning scheme），记作 𝑠𝑐ℎ(𝑓𝑖+) 或者 𝑠𝑐ℎ(𝑓𝑖−) 。例如对于全连接层的2D参数矩阵 𝑤 ，可以得到 𝑤[𝑘,:] 和 𝑤[:,𝑘] 两种不同的布局。这种情况下，输入 𝑓𝑖− 和输出 𝑓𝑖+ 在依赖图中是相互独立、非耦合的；而另一类层输入输出之间存在耦合，例如逐元素运算、Batch Normalization等。他们的参数（如果有）仅有一种剪枝布局，且同时影响输入输出的维度。如果 𝑓𝑖− 和 𝑓𝑖+ 共享相同的修剪方案，则存在依赖 𝑓𝑖− ⇔ 𝑓𝑖+ ，用𝑠𝑐ℎ(𝑓𝑖-) =𝑠𝑐ℎ(𝑓𝑖+) 表示。实际上，相比于复杂的参数耦合类型，深度网络中的层类型是非常有限的，我们可以预先定义不同层的剪枝布局来确定图中的依赖关系。</p></li></ul><p>正式定义如下的依赖关系建模：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240517110026498.png" alt="image-20240517110026498" style="zoom:80%;"><p>其中 ∨ 和 ∧ 分别表示逻辑”OR“和“AND”。第一项检查由<strong>网络连接引起的层间依赖关系</strong>，而第二项检查由<strong>层输入和输出之间的共享剪枝方案所引入的层内依赖关系。</strong></p><p>我们在算法1和算法2中总结了依赖图构建和参数分组的过程，其中参数分组是一个递归的连通分量（Connected Component）搜索问题，可以通过简单深度(DFS)或者宽度(BFS)优先搜索实现。算法2简要描述了这一过程，即以某个节点i作为起始分组g，找到依赖图D中与之相连的新节点j，合并入当前组，直到不存在新的联通节点为止。此处省略了分组的去重处理。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240517112155305.png" alt="image-20240517112155305" style="zoom:80%;"><p>将上述算法应用于一个具体的残差结构块，我们可以得到如下可视化结果。在具体剪枝时，以任意一个节点作为起始点，例如以 𝑓4+ 作为起点，递归地搜索能够访问到的所有其他节点，并将它们归入同一个组进行剪枝。值得注意的是，卷积网络由于输入输出使用了不同的剪枝布局（ 𝑠𝑐ℎ(𝑓4−)≠𝑠𝑐ℎ(𝑓4+) ），在依赖图中其输入输出节点间不存在层内依赖，但是由于skip连接 𝑓7 的存在，递归搜索过程中 𝑓4−和 𝑓4+ 会被分入同一组，即他们依旧需要被同时裁剪。其他层例如Batch Normalization的输入输出则存在简单的层内依赖。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240517105422995.png" alt="image-20240517105422995" style="zoom:80%;"><p>图3。层分组是通过在DepGraph上递归传递实现的（从f4+开始）</p><h3 id="组级别剪枝"><a href="#组级别剪枝" class="headerlink" title="组级别剪枝"></a>组级别剪枝</h3><p>依赖图的一个重要作用是<strong>参数自动分组</strong>，从而实现任意架构的模型剪枝。实际上，依赖图的自动分组能力还可以帮助设计<strong>组级别剪枝（Group-level Pruning）</strong>。在结构化剪枝中，属于同一组的参数会被同时移除，这一情况下需要保证这些被移除参数是“一致冗余”的，如果这些参数中包含对网络预测至关重要的参数，那么移除这些参数难免会损伤性能。</p><p>一个重要问题<strong>是如何在涉及多个耦合层的情况下评估分组参数的重要性程度</strong>。在本节中，作者利用一个简单的norm-based标准来建立一个实用的组级剪枝方法。给定一个参数组g = {w1，w2，…，w|g|}，现有的标准如<strong>L2-norm重要性可以对每一个w产生独立的分数</strong>。估计组重要性的一种自然方法是计算一个聚合分数I(g)=每层分数的求和。但独立估计的各层重要性程度是非加性的，且由于分布和大小的散度而毫无意义。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240605144536610.png" alt="image-20240605144536610"><p>为了使这个简单的聚合能够作用于重要性估计，我们<strong>提出了一种稀疏训练方法来在组级别上稀疏参数</strong>（如图4(c)），这些零化的组就可以安全地从网络中移除。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524101302850.png" alt="image-20240524101302850" style="zoom:80%;"><p>如图4 (c)所示，目标是<strong>学习所有分组层之间的一致稀疏性，同时将某些维度归零为零。</strong>作者<strong>将分组参数扁平化并合并为一个大的参数矩阵（也就是对于分组中的每一层，获取到特定通道的独立的参数组重要性后，展平，然后添加到分组重要性list，构成二维矩阵），其中检索所有属于第k个可调维数的参数，就像CNN块的第k个通道一样</strong>。现在，<strong>一致的稀疏性可以通过一个简单的加权收缩来促进</strong>（采用一个L2正则项，通过赋予参数组的不同正则权重 𝛾 来进行组稀疏化）</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524104156855.png" alt="image-20240524104156855" style="zoom:80%;"><p>其中k用于<strong>可剪枝参数的切片</strong>（Slicing），用于定位当前参数内<strong>第k组参数子矩阵</strong>，上述稀疏算法会得到<strong>k组不同程度稀疏的耦合参数</strong>，我们选择整体L2 norm最小的耦合参数进行剪枝。我们使用一个可控的指数策略来确定γk如下：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524104920144.png" alt="image-20240524104920144" style="zoom:80%;"><p>经过稀疏训练后，作者进一步使用了一个相对分数<img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524105432943.png" alt="image-20240524105432943" style="zoom: 67%;">来识别和删除不重要的参数。</p><p>实际上，依赖图还可以用于设计各种更强大的<strong>组剪枝方法</strong>，但由于稀疏训练、重要性评估等技术并非DepGraph的主要内容，这里也就不再赘述。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>本文主要关注分类任务，在各种数据集上进行广泛的实验，如用于图像分类的CIFAR和ImageNet，用于图形分类的PPI，用于三维分类的ModelNet，用于文本分类的AGNews。使用模型如概要所述。为了进行ImageNet实验，使用了Torchvision 的现成模型作为原始模型。修剪后，所有模型都将按照与预训练阶段相似的协议进行微调，使用更小的学习率和更少的迭代。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>CIFAR是一个小型的图像数据集，被广泛用于验证剪枝算法的有效性。</p><p>我们利用DepGraph和一致性稀疏构建了一个非常简单的剪枝器，能够在这两种数据集上取得不错的性能。 当然，我们在Imagenet上并没有达到SOTA，因为我们的目标在于通用性而非特定架构上的性能。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524110639744.png" alt="image-20240524110639744" style="zoom:80%;"><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524113933711.png" alt="image-20240524113933711"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="一致性稀疏"><a href="#一致性稀疏" class="headerlink" title="一致性稀疏"></a>一致性稀疏</h4><p>在分析实验中，首先我们首先评估了一致性稀疏和逐层独立稀疏的差异，结论符合3.3中的分析，即<strong>逐层算法无法实现依赖参数的一致稀疏</strong>。例如下图中绿色的直方图表示传统的逐层稀疏策略，相比于本文提出的一致性稀疏，其整体稀疏性表现欠佳。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524114128417.png" alt="image-20240524114128417" style="zoom:80%;"><h4 id="分组策略"><a href="#分组策略" class="headerlink" title="分组策略"></a>分组策略</h4><p>我们同样对分组策略进行了评估，我们考虑了<strong>无分组（No Grouping）、卷积分组（Conv-only）和全分组（Full Grouping）</strong>三种策略：无分组对参数进行独立稀疏；卷积分组只考虑卷积层而忽略其他参数化的层；全分组将所有参数化的层进行一致性稀疏。实验表明全稀疏在得到更优的结果同时，剪枝的稳定性更高，不容易出现过度剪枝的情况（性能显著下降）。</p><p>另外剪枝的稀疏度如何分配也是一个重要问题，我们测试了算法在<strong>逐层相同稀疏度（Uniform Sparsity）和可学习稀疏度（Learned Sparsity）</strong>下的表现。可学习稀疏度根据稀疏后的参数L2 Norm进行全局排序，从而决定稀疏度。<strong>这一方法假设参数冗余并不是平均分布在所有层的</strong>，对不同层应用了不同的剪枝率，因此一般情况下可以取得更好的性能，这类方法通常也称为全局剪枝（Global Pruning）。但与此同时，<strong>可学习的稀疏度存在过度剪枝风险，即在某一层中移除过多的参数</strong>。下图中可以看到VGG网络出现了过度剪枝的问题，导致Learned Sparsity效果显著低于Uniform Sparsity。在实际应用中，还是需要根据具体网络、评估指标的特点选择合适的稀疏度分配策略。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240601163320807.png" alt="image-20240601163320807" style="zoom:80%;"><h5 id="可学习稀疏度"><a href="#可学习稀疏度" class="headerlink" title="可学习稀疏度"></a>可学习稀疏度</h5><p>层的稀疏性也是剪枝的一个重要因素，它决定了剪枝神经网络的最终结构。表2提供了关于层稀疏性的一些结果。本研究主要关注两种稀疏性，即逐层相同稀疏性和可学习稀疏性。在相同稀疏性的情况下，由于假设了冗余参数通过网络均匀分布，所以对不同的层采用相同的剪枝比。然而，图5中之前的实验表明，不同的层并不是相同的。在大多数情况下，可学习的稀疏性优于均匀的稀疏性，尽管有时它可能会过度修剪某些层，导致精度下降。</p><h5 id="DepGraph的通用性"><a href="#DepGraph的通用性" class="headerlink" title="DepGraph的通用性"></a>DepGraph的通用性</h5><p>表2中的结果也证明了我们的框架的通用性，它能够处理各种卷积神经网络。此外，我们强调我们的方法与DenseNet和GoogleNet兼容，它们包含密集的连接和并行结构。</p><h4 id="依赖图可视化"><a href="#依赖图可视化" class="headerlink" title="依赖图可视化"></a>依赖图可视化</h4><p>由于参数分组的复杂过程，修剪大型神经网络是一个相当大的挑战。然而，通过利用深度图，可以毫不费力地得到所有的耦合群。下图中我们可视化了DenseNet-121、ResNet-18、ViT-Base的依赖图和递归推导得到的分组矩阵，可以发现不同网络的参数依赖关系是复杂且各不相同的。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240601165302830.png" alt="image-20240601165302830" style="zoom:80%;"><h4 id="非图像模型结构化剪枝"><a href="#非图像模型结构化剪枝" class="headerlink" title="非图像模型结构化剪枝"></a>非图像模型结构化剪枝</h4><p> 深度模型不仅仅只有CNN和transformer，我们还对其他架构的深度模型进行了初步验证，包括用于文本分类的LSTM，用于3D点云分类的DGCNN以及用于图数据的GAT，我们的方法都取得了令人满意的结果。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240601165426443.png" alt="image-20240601165426443" style="zoom:80%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提出了一种面向任意架构的结构化剪枝技术DepGraph，极大简化了剪枝的流程。目前，我们的框架已经覆盖了Torchvision模型库中95%的模型，涵盖分类、分割、检测等任务。总体而言，本文工作是第一次尝试开发一种可应用于多种架构（CNNs, RNNs, GNNs, and Transformers）的通用算法。此外，当前大多数剪枝算法都是针对单层设计的，我们的工作为将来“组级别剪枝”的研究提供了一些有用的基础资源。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="权值剪枝器（Magnitude-Pruner）"><a href="#权值剪枝器（Magnitude-Pruner）" class="headerlink" title="权值剪枝器（Magnitude Pruner）"></a>权值剪枝器（Magnitude Pruner）</h3><p>MagnitudePruner是一种利用权值大小定位冗余参数的经典算法，相关技术发表于“Pruning Filters for Efficient ConvNets”一文。作者讨论了一种神经网络中最基础的依赖关系（卷积和残差连接）</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240604114918956.png" alt="image-20240604114918956"><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240604115208636.png" alt="image-20240604115208636"><h4 id="tp实现"><a href="#tp实现" class="headerlink" title="tp实现"></a>tp实现</h4><p>类tp.importance.Importance要求我们实现一个非常简单的接口__call__，其中输入参数是一个group，它包含了多个相互耦合的层。该函数的输出则是一个<strong>一维的重要性得分向量</strong>，其含义是每个通道的重要性，因此他的维度和通道数通常是相同的。由于输入的Group通常会包含多个可剪枝层，因此我们<strong>首先对这些层进行独立的重要性计算，然后通过求平均值得到最终结果</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch_pruning <span class="token keyword">as</span> tp<span class="token keyword">class</span> <span class="token class-name">MyMagnitudeImportance</span><span class="token punctuation">(</span>tp<span class="token punctuation">.</span>importance<span class="token punctuation">.</span>Importance<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> group<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 1. 首先定义一个列表用于存储分组内==每一层==的重要性</span>        group_imp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token comment"># 2. 迭代分组内的各个层，对Conv层计算重要性</span>        <span class="token keyword">for</span> dep<span class="token punctuation">,</span> idxs <span class="token keyword">in</span> group<span class="token punctuation">:</span> <span class="token comment"># idxs是一个包含所有可剪枝索引的列表，用于处理DenseNet中的局部耦合的情况</span>            layer <span class="token operator">=</span> dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span>module <span class="token comment"># 获取 nn.Module</span>            prune_fn <span class="token operator">=</span> dep<span class="token punctuation">.</span>handler    <span class="token comment"># 获取 剪枝函数</span>            <span class="token comment"># 3. 这里我们简化问题，仅计算卷积输出通道的重要性</span>            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>layer<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">)</span> <span class="token keyword">and</span> prune_fn <span class="token operator">==</span> tp<span class="token punctuation">.</span>prune_conv_out_channels<span class="token punctuation">:</span>                w <span class="token operator">=</span> layer<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">[</span>idxs<span class="token punctuation">]</span><span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 用索引列表获取耦合通道对应的参数，并展开成2维</span>                local_norm <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 计算==每个通道参数子矩阵的 L1 Norm==</span>                group_imp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>local_norm<span class="token punctuation">)</span> <span class="token comment"># 将其保存在列表中</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>group_imp<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span> <span class="token comment"># 跳过不包含卷积层的分组</span>        <span class="token comment"># 4. 按通道计算平均重要性</span>        group_imp <span class="token operator">=</span> torch<span class="token punctuation">.</span>stack<span class="token punctuation">(</span>group_imp<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> group_imp <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于每个Group，我们计算了其中卷积层输出通道的重要性，然后求平均值得到最终的评估结果。基于上述代码，一个MagnitudePruner实际上已经完成了，但是参数修剪由谁来执行呢？Torch-Pruning库定义了一个元剪枝器tp.pruner.MetaPruner，能够帮助我们完成除了重要性评估之外的所有工作。因此，我们现在可以开始执行剪枝了。为了增加难度，这里我们对一个DenseNet模型进行剪枝：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> torchvision<span class="token punctuation">.</span>models <span class="token keyword">import</span> densenet121<span class="token keyword">import</span> torch_pruning <span class="token keyword">as</span> tpmodel <span class="token operator">=</span> densenet121<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>example_inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token comment"># 1. 使用我们上述定义的重要性评估</span>imp <span class="token operator">=</span> MyMagnitudeImportance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 2. 忽略无需剪枝的层，例如最后的分类层</span>ignored_layers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> m <span class="token keyword">in</span> model<span class="token punctuation">.</span>modules<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">)</span> <span class="token keyword">and</span> m<span class="token punctuation">.</span>out_features <span class="token operator">==</span> <span class="token number">1000</span><span class="token punctuation">:</span>        ignored_layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token comment"># DO NOT prune the final classifier!</span><span class="token comment"># 3. 初始化剪枝器</span>iterative_steps <span class="token operator">=</span> <span class="token number">5</span> <span class="token comment"># 迭代式剪枝，重复5次Pruning-Finetuning的循环完成剪枝。</span>pruner <span class="token operator">=</span> tp<span class="token punctuation">.</span>pruner<span class="token punctuation">.</span>MetaPruner<span class="token punctuation">(</span>    model<span class="token punctuation">,</span>    example_inputs<span class="token punctuation">,</span> <span class="token comment"># 用于分析依赖的伪输入</span>    importance<span class="token operator">=</span>imp<span class="token punctuation">,</span> <span class="token comment"># 重要性评估指标</span>    iterative_steps<span class="token operator">=</span>iterative_steps<span class="token punctuation">,</span> <span class="token comment"># 迭代剪枝，设为1则一次性完成剪枝</span>    ch_sparsity<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token comment"># 目标稀疏性，这里我们移除50%的通道 ResNet18 = {64, 128, 256, 512} =&gt; ResNet18_Half = {32, 64, 128, 256}</span>    ignored_layers<span class="token operator">=</span>ignored_layers<span class="token punctuation">,</span> <span class="token comment"># 忽略掉最后的分类层</span><span class="token punctuation">)</span><span class="token comment"># 4. Pruning-Finetuning的循环</span>base_macs<span class="token punctuation">,</span> base_nparams <span class="token operator">=</span> tp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>count_ops_and_params<span class="token punctuation">(</span>model<span class="token punctuation">,</span> example_inputs<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>iterative_steps<span class="token punctuation">)</span><span class="token punctuation">:</span>    pruner<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 执行裁剪，本例子中我们每次会裁剪10%，共执行5次，最终稀疏度为50%</span>    macs<span class="token punctuation">,</span> nparams <span class="token operator">=</span> tp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>count_ops_and_params<span class="token punctuation">(</span>model<span class="token punctuation">,</span> example_inputs<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"  Iter %d/%d, Params: %.2f M =&gt; %.2f M"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> iterative_steps<span class="token punctuation">,</span> base_nparams <span class="token operator">/</span> <span class="token number">1e6</span><span class="token punctuation">,</span> nparams <span class="token operator">/</span> <span class="token number">1e6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"  Iter %d/%d, MACs: %.2f G =&gt; %.2f G"</span><span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> iterative_steps<span class="token punctuation">,</span> base_macs <span class="token operator">/</span> <span class="token number">1e9</span><span class="token punctuation">,</span> macs <span class="token operator">/</span> <span class="token number">1e9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># finetune your model here</span>    <span class="token comment"># finetune(model)</span>    <span class="token comment"># ...</span><span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Slimming剪枝器"><a href="#Slimming剪枝器" class="headerlink" title="Slimming剪枝器"></a>Slimming剪枝器</h3><p>在上文中，我们介绍了如何快速实现一个简单的权值剪枝算法，它直接作用于模型的参数上，选取那些相对较小的参数进行裁剪。然而，实际上<strong>一个模型中的各个参数权值大小可能非常接近，因此我们难以直接根据参数大小来判断其重要性</strong>。针对这一问题，于ICCV2017会议上发表的slimming算法提出了一种经典的解决方案：利用Batch Normalization的scale参数完成重要性评估。</p><p>…………</p><h2 id="LLM剪枝"><a href="#LLM剪枝" class="headerlink" title="LLM剪枝"></a>LLM剪枝</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>LLM压缩与传统网络压缩区别：</p><ol><li><p><strong>模型规模：</strong>第一个主要差异来自LLM的巨大参数量，这导致许多侧重训练（Training-heavy）的压缩方案，例如知识蒸馏[1]变得较为困难.</p></li><li><p><strong>海量训练语料</strong>：许多LLMs经历了1万亿甚至更大规模的tokens上的训练[3]，这导致许多依赖于原始数据或收集替代数据的方案变得尤其昂贵。</p></li><li><p><strong>任务无关的模型压缩：</strong>现有的压缩算法通常针对单一、特定的任务进行压缩，而LLMs是很优秀的多任务处理器，在压缩过程中我们不希望折损LLM的通用性和多功能性。</p></li></ol><p>我们需要一种能够避免大规模重新训练、且能保持模型原有能力的压缩方法。现有的较为可行的两种方案是【模型量化】和【网络剪枝】<strong>。</strong>其中模型量化侧重于降低推理阶段的存储开销以及提升计算速度，而网络剪枝则移除部分参数实现压缩，两种方案可以相互结合达到最优性能。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240605165433575.png" alt="image-20240605165433575" style="zoom:80%;"><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><p><strong>1.训练语料库规模巨大</strong>：以往的压缩方法严重依赖于训练语料库。LLM已经将语料库规模升级到1万亿token。巨大的存储需求和漫长的传输时间使数据集难以获取。</p><p><strong>2.修建后的LLM的后训练时间巨大</strong>：现有的方法需要大量的时间来后训练生成的小模型。例如，在TinyBERT中的一般蒸馏大约需要14 GPU天。即使是后训练特定任务的BERT压缩模型也需要大约33小时。随着llm的模型和语料库的大小迅速增加，这一步骤必然会消耗更长的时间。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>遵循常规的剪枝流程，LLM-Pruner包含三个步骤：发现阶段，估计阶段，恢复阶段。</p><p>(1) 发现阶段：这一步聚焦于识别LLM内部相互依赖的结构，这些相互依赖的结构需要被同时移除已确保剪枝后结构的正确性。</p><p>(2) 估计阶段：一旦耦合结构被分组，第二步就包含估计每个组对模型总体性能的贡献，并决定要剪枝的组。</p><p>(3) 恢复阶段：这一步涉及到快速的后训练，用于缓解由于结构删除而可能引起的性能降级。</p><h4 id="依赖分组"><a href="#依赖分组" class="headerlink" title="依赖分组"></a>依赖分组</h4><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240605170758309.png" alt="image-20240605170758309" style="zoom:80%;"><p>Ni指向Nj，且Nj入度为1。则Nj依赖于Ni。</p><p>Nj唯一依赖于Ni，则Ni与Nj在同一组</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240606144246633.png" alt="image-20240606144246633" style="zoom:80%;"><p>图2: LLaMA中耦合结构的示例。我们简化了每层的神经元以清晰地展示依赖组。剪枝的起始神经元被铃图案所标记，这一操作会导致具有依赖性的权重被剪枝（虚线），并继续传播到耦合神经元（虚线圆圈）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>CVPR 2023 | DepGraph 通用结构化剪枝：<a href="https://zhuanlan.zhihu.com/p/619146631">https://zhuanlan.zhihu.com/p/619146631</a></p><p>模型加速｜CNN与ViT模型都适用的结构化剪枝方法（一）：<a href="https://developer.aliyun.com/article/1231617">https://developer.aliyun.com/article/1231617</a></p><p>【深度学习之模型优化】模型剪枝、模型量化、知识蒸馏概述：<a href="https://blog.csdn.net/qq_51831335/article/details/126660743">https://blog.csdn.net/qq_51831335/article/details/126660743</a></p><p>Torch-Pruning | 轻松实现结构化剪枝算法： <a href="https://zhuanlan.zhihu.com/p/619482727">https://zhuanlan.zhihu.com/p/619482727</a></p><p>YOLOv8模型剪枝实战： <a href="https://www.bilibili.com/video/BV1iA4m1F7zf/?vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1iA4m1F7zf/?vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>NeurIPS 2023 | LLM-Pruner: 大语言模型的结构化剪枝： <a href="https://zhuanlan.zhihu.com/p/630902012">https://zhuanlan.zhihu.com/p/630902012</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 压缩 </tag>
            
            <tag> 推理加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2024/05/11/redis/"/>
      <url>/2024/05/11/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>使用阿里云hit账号数据库，密码首字母大写</p><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li><strong>单线程</strong>，每个命令具备原子性</li><li>低延迟，速度快（<strong>基于内存</strong>、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p>NoSql</p></li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json</p><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。也称为<strong>非关系型数据库</strong>。</p><p>sql vs nosql：</p><ul><li><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：<strong>字段名、字段数据类型、字段约束</strong>等等信息，插入的数据必须遵守这些约束。而NoSql则对数据库格式没有严格约束，往往<strong>形式松散，自由</strong>。可以是键值型，也可以是文档型或者图格式。</p></li><li><p>传统数据库的表与表之间往往存在关联，例如外键。而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  name<span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>  orders<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>       id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>       item<span class="token operator">:</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">"荣耀6"</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token number">4999</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>       id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>       item<span class="token operator">:</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">"小米11"</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token number">3999</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><img src="/2024/05/11/redis/AzaHOTF.png" style="zoom:67%;"></li><li><p>传统关系型数据库能满足事务ACID的原则。而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现<strong>基本的一致性</strong>。</p></li></ul><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><img src="/2024/05/11/redis/1.png" style="zoom: 67%;"><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的<strong>磁盘IO</strong>，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是<strong>依赖于内存来操作，内存的读写速度会非常快</strong>，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以<strong>将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展</strong>。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h2 id="初识redis"><a href="#初识redis" class="headerlink" title="初识redis"></a>初识redis</h2><h3 id="linux启动"><a href="#linux启动" class="headerlink" title="linux启动"></a>linux启动</h3><h4 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h4><p>安装完成后，在任意目录输入redis-server命令即可启动Redis</p><img src="/2024/05/11/redis/v7xWsqC.png" style="zoom:67%;"><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h4 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf</p><p>我们先将这个配置文件备份一份：</p><pre class="line-numbers language-none"><code class="language-none">cp redis.conf redis.conf.bck<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>然后修改redis.conf文件中的一些配置：</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><span class="token key attr-name">bind</span> <span class="token value attr-value">0.0.0.0</span><span class="token comment"># 守护进程，修改为yes后即可后台运行</span><span class="token key attr-name">daemonize</span> <span class="token value attr-value">yes </span><span class="token comment"># 密码，设置后访问Redis必须输入密码</span><span class="token key attr-name">requirepass</span> <span class="token value attr-value">123321</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis的其它常见配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 监听的端口</span><span class="token key attr-name">port</span> <span class="token value attr-value">6379</span><span class="token comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><span class="token key attr-name">dir</span> <span class="token value attr-value">.</span><span class="token comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><span class="token key attr-name">databases</span> <span class="token value attr-value">1</span><span class="token comment"># 设置redis能够使用的最大内存</span><span class="token key attr-name">maxmemory</span> <span class="token value attr-value">512mb</span><span class="token comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><span class="token key attr-name">logfile</span> <span class="token value attr-value">"redis.log"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>启动Redis：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入redis安装目录 </span><span class="token builtin class-name">cd</span> /usr/local/src/redis-6.2.6<span class="token comment"># 启动</span>redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>停止服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><span class="token comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span>redis-cli <span class="token parameter variable">-u</span> <span class="token number">123321</span> <span class="token function">shutdown</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512130026010.png" style="zoom:67%;"><h4 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h4><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/systemd/system/redis.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容如下：</p><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>然后重载系统服务：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们可以用下面这组命令来操作redis了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动</span>systemctl start redis<span class="token comment"># 停止</span>systemctl stop redis<span class="token comment"># 重启</span>systemctl restart redis<span class="token comment"># 查看状态</span>systemctl status redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行下面的命令，可以让redis开机自启：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Redis桌面客户端"><a href="#Redis桌面客户端" class="headerlink" title="Redis桌面客户端"></a>Redis桌面客户端</h3><h4 id="命令行客户端"><a href="#命令行客户端" class="headerlink" title="命令行客户端"></a>命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-cli <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>commonds<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的<strong>IP地址</strong>，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p><strong>不指定commond时，会进入<code>redis-cli</code>的交互控制台</strong></p><img src="/2024/05/11/redis/OYYWPNo.png" style="zoom:80%;"><h4 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h4><p>RedisDesktopManager：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><p>Redis默认有20个仓库，编号从0至19.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><img src="/2024/05/11/redis/image-20240512133415507.png" style="zoom:67%;"><h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h2><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><img src="/2024/05/11/redis/8tli2o9.png" style="zoom:67%;"><p>官方文档与数据类型分组：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></p><img src="/2024/05/11/redis/image-20240512133753203.png" style="zoom:67%;"><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">keys *查看当前库所有key exits key  判断某个key是否存在 <span class="token builtin class-name">type</span> key  查看key是什么类型 del key删除指定的key数据 unlink key根据value选择非阻塞删除（仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作） expire key <span class="token number">10</span>  为给定的key设置过期时间（10s） ttl key查看还有多少秒过期：-1表示永不过期，-2表示已经过期 <span class="token keyword">select</span>切换数据库 dbsize查看当前数据库的key数量 flushdb清空当前库 flushall  通杀全部库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  添加或修改键值对（key存在时，set覆盖旧值） get <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  查询对应键值 append <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  将给定的value追加到原值的末尾 strlen <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  获得值的长度 setnx <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  只有key不存在时，设置key值 incr <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  将key中储存的数字值增1，只能对数字值操作，如果为空，新增值为1incrby <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> xx 让一个整型的key自增并指定步长，例如：incrby num <span class="token number">2</span> 让num值自增2incrbyfloat <span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span> xx 让一个浮点型的key自增并指定步长decr <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  将key中储存的数字值建减1，只能对数字值操作，如果为空，新增值为-1 incrby / decrvy <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>步长<span class="token operator">&gt;</span>  将key中储存的数字值增减，自定义步长 mset <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……  批量添加一个或多个 key-value 对 mget <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span>……  批量获取一个或多个value msetnax  <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……  同时设置一个或多个key-value对，当且仅当所有给定key都不存在 getrange <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>起始位置<span class="token operator">&gt;</span><span class="token operator">&lt;</span>结束位置<span class="token operator">&gt;</span>  获得值的范围，类似java中的substring，前包，后包 setrange <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>起始位置<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  用<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>覆写<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>所存储的字符串值，从起始位置开始（索引从0开始） setex <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>过期时间<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  设置键值的同时，设置过期时间（单位：秒） getset <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  以新换旧，设置了新值的同时获得旧值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="key结构"><a href="#key结构" class="headerlink" title="key结构"></a>key结构</h4><p>Redis没有类似MySQL中的Table的概念，我们该如何区分<strong>不同类型的key</strong>呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分：Redis的key允许<strong>有多个单词形成层级结构，多个单词之间用’:’隔开</strong>，格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">项目名:业务名:类型:id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样我们就可以把不同类型的数据区分开了。从而<strong>避免了key的冲突问题。</strong></p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以<strong>将对象序列化为JSON字符串后存储：</strong></p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><img src="/2024/05/11/redis/image-20240512143035672.png" style="zoom:80%;"><p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p><img src="/2024/05/11/redis/image-20240512143224071.png" style="zoom:80%;"><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便；Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。</p><img src="/2024/05/11/redis/VF2EPt0.png"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hset <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  给<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>集合中的<span class="token operator">&lt;</span>filed<span class="token operator">&gt;</span>键赋值<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>，可以添加也可以修改 hget <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span>  从<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>集合<span class="token operator">&lt;</span>field<span class="token operator">&gt;</span>取出value hmset <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……  批量设置hash的值hmget <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token punctuation">..</span>.  批量获取hash的field的值 hexits <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>filed<span class="token operator">&gt;</span>  查看哈希表key中，给定域field是否存在 hkeys <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  列出该hash集合key的所有field hvals <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  列出该hash集合的所有value hincrby <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span><span class="token operator">&lt;</span>increment<span class="token operator">&gt;</span>  为哈希表key中的域field的值加上增量（自增自减）并指定步长 hsetnx <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  将哈希表key中的域field的值设置为value，当且仅当域field不存在hgetall <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> 获取一个hash类型的key中的所有的field和value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512144509760.png" style="zoom:80%;"><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li><strong>有序</strong></li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lpush / rpush <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span>……  从左边/右边插入一个或多个值 lpop / rpop <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  从左边/右边移除并返回第一个值，没有则返回null rpoplpush <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>  从<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>列表右边移除一个值，插到<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>列表左边 lrange <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>start<span class="token operator">&gt;</span><span class="token operator">&lt;</span>stop<span class="token operator">&gt;</span>  按照索引下标获得元素（从左到右） eg：lrange mylist <span class="token number">0</span> <span class="token parameter variable">-1</span>  <span class="token number">0</span>左边第一个，-1右边第一个（0 <span class="token parameter variable">-1</span> 表示获取所有） lindex <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>index<span class="token operator">&gt;</span>  按照索引下标获得元素（从左到右） llen <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  获得列表长度 linsert <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> before <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span><span class="token operator">&lt;</span>newvalue<span class="token operator">&gt;</span>  在<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>后面插入<span class="token operator">&lt;</span>newvalue<span class="token operator">&gt;</span>插入值 lrem <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>n<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  从左起删除n个vlaue（从左到右） lset <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>index<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  将列表key下标为index的值替换成value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">LPUSH <span class="token function">users</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>RPUSH <span class="token function">users</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>结果是users中包含 <span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>LRANGE <span class="token function">users</span> <span class="token number">1</span> <span class="token number">2</span>结果是<span class="token punctuation">[</span><span class="token string">"1"</span>,<span class="token string">"4"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li><strong>元素不可重复</strong></li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sadd <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……将一个或多个元素加入到集合key中，已经存在的元素将被忽略srem <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……删除集合中的指定元素 smembers <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>取出该集合的所有值 sismember <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>判断集合<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>是否包含该<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>值，有1，没有0 scard <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>返回该集合的元素个数 spop <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>随机从该集合中吐出一个值 srandmember <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>n<span class="token operator">&gt;</span>随机从该集合中取出n个值，不会从集合中删除 smove <span class="token operator">&lt;</span>source<span class="token operator">&gt;</span><span class="token operator">&lt;</span>destination<span class="token operator">&gt;</span>value把集合中的一个值从一个集合移动到另一额集合 sinter<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>返回两个集合的交集元素 sunion <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>返回两个集合的并集元素 <span class="token function">sdiff</span> <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>返回两个集合的差集元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sadd s1 a b c<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> smembers s1<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"c"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"b"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"a"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> srem s1 a<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>    <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SISMEMBER s1 a<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>    <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SISMEMBER s1 b<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>    <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SCARD s1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SortedSet（Zset）"><a href="#SortedSet（Zset）" class="headerlink" title="SortedSet（Zset）"></a>SortedSet（Zset）</h3><p>Redis的SortedSet是一个<strong>可排序的set集合</strong>，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于<strong>score属性对元素排序</strong>，底层的实现是<strong>一个跳表（SkipList）加 hash表</strong>。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><pre class="line-numbers language-none"><code class="language-none">zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;……  将一个或多个member元素及其score值加入到有序集key中，若已存在则覆盖score值 zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]  返回有序集key中，下标在strart到stop之间的元素（带WITHSCORES，可以让分数一起返回） zrangebyscore key min max [withscores][limit offset count]  返回有序集key中，所有score值介于min和max之间的成员(从小到大) zrevrangebyscore key max min [withscores][limit offet count]  同上，从大到小排序 zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;  让sorted set中的指定元素自增，步长为指定的increment值 zrem &lt;key&gt;&lt;value&gt;  删除该集合下，指定元素value zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;  统计该集合，分数区间内的元素个数 zrank &lt;key&gt;&lt;value&gt;  返回该值在集合中的排名，从0开始zscore &lt;key&gt;&lt;value&gt; 获取sorted set中的指定元素的score值zcard &lt;key&gt; 获取sorted set中的元素个数ZDIFF.ZINTER.ZUNION：求差集.交集.并集<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>将班级的下列学生得分存入Redis的SortedSet中：</p><p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p><p>并实现下列功能：</p><ul><li>删除Tom同学</li><li>获取Amy同学的分数</li><li>获取Rose同学的排名</li><li>查询80分以下有几个学生</li><li>给Amy同学加2分</li><li>查出成绩前3名的同学</li><li>查出成绩80分以下的所有同学</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ZADD studs <span class="token number">85</span> Jack <span class="token number">89</span> Lucy <span class="token number">82</span> Rose <span class="token number">95</span> tom <span class="token number">78</span> Jerry <span class="token number">92</span> Amy <span class="token number">76</span> Miles<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512152116142.png" style="zoom:80%;"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zrem studs tomzrank studs Rose排名2zrevrank studs Rose排名3（倒数4）zcount studs <span class="token number">0</span> <span class="token number">80</span>结果2人zincrby studs <span class="token number">2</span> Amy结果94.0分zrange studs <span class="token number">0</span> <span class="token number">2</span>结果<span class="token punctuation">[</span><span class="token string">"Miles"</span>,<span class="token string">"Rose"</span>,<span class="token string">"Jerry"</span><span class="token punctuation">]</span>zrangebyscore studs <span class="token number">0</span> <span class="token number">80</span>结果<span class="token punctuation">[</span><span class="token string">"Miles"</span>,<span class="token string">"Jerry"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><pre class="line-numbers language-none"><code class="language-none">setbit &lt;key&gt;&lt;offset&gt;&lt;value&gt;  设置Bitmaps中某个偏移量的值（0或1）（offset：偏移量从0开始） getbit &lt;key&gt;&lt;offset&gt;  获取Bitmaps中某个偏移量的值 bitcount &lt;key&gt;[start end]  统计字符串从start字节到end字节比特值为1的量 bitop and(or/not/xor) &lt;destkey&gt; [key] 复合操作，可以做多个bitmaps的交集(and)、并集(or)、非(not)、异或(xor)操作并将结果保存在destkey中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><pre class="line-numbers language-none"><code class="language-none">pfadd &lt;key&gt;&lt;element&gt;[element……]  添加指定元素到HyperLogLog中 pfcount &lt;key&gt; [key……]  计算HLL的近似基数，可以计算多个HLL（比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可） pfmerge &lt;destkey&gt;&lt;sourcekey&gt;[sourcekey……]  将一个或多个HLL合并后的结果存储在另一个HLL中（比如每月活跃用户可以使用每天的活页用户来合并计算可得）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><pre class="line-numbers language-none"><code class="language-none">geoadd &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;&lt;member&gt;[longitude lattitude member……] 添加地理位置（经度、维度、名称） geopos &lt;key&gt;&lt;member&gt;[member……]  获得指定地区的坐标值 geodist &lt;key&gt;&lt;member1&gt;&lt;member2&gt; [m|km|ft|mi]  获取两个位置之间的直线距离 georadius &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;radius m|km|ft|mi以给定的经纬度为中心，找出某一半径内的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p>其中Java客户端也包含很多：</p><img src="/2024/05/11/redis/image-20240512153303012.png"><p>标记为*的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而<strong>SpringDataRedis又对这两种做了抽象和封装</strong>，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是<strong>在Redis基础上实现了分布式的可伸缩的java数据结构</strong>，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h3 id="Jedis客户端"><a href="#Jedis客户端" class="headerlink" title="Jedis客户端"></a>Jedis客户端</h3><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> redisTest <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Jedis</span> jedis<span class="token punctuation">;</span>    <span class="token annotation punctuation">@BeforeEach</span>    <span class="token keyword">void</span> <span class="token function">setUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 建立连接</span>        jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"ip"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 选择库</span>        jedis<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 存入数据</span>    <span class="token class-name">String</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"虎哥"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result = "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取数据</span>    <span class="token class-name">String</span> name <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 插入hash数据</span>    jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hgetAll</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>释放资源</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@AfterEach</span><span class="token keyword">void</span> <span class="token function">tearDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>jedis <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="jedis连接池"><a href="#jedis连接池" class="headerlink" title="jedis连接池"></a>jedis连接池</h4><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisConnectionFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">JedisPool</span> jedisPool<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token comment">// 配置连接池</span>        <span class="token class-name">JedisPoolConfig</span> poolConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 最大空闲连接</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMinIdle</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 最小空闲连接</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 没有连接时，最多等待1000ms</span>        <span class="token comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span>        jedisPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>poolConfig<span class="token punctuation">,</span> <span class="token string">"ip"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Jedis</span> <span class="token function">getJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了<strong>对不同Redis客户端的整合（Lettuce和Jedis）</strong></li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><img src="/2024/05/11/redis/UFlNIV0.png" style="zoom:80%;"><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- spring-data-redis--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--common-pool--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--Jackson依赖--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h4><p>application.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># REDIS (RedisProperties)</span><span class="token comment"># Redis数据库索引（默认为0）</span><span class="token key attr-name">spring.data.redis.database</span><span class="token punctuation">=</span><span class="token value attr-value">0</span><span class="token comment"># Redis服务器地址</span><span class="token key attr-name">spring.data.redis.host</span><span class="token punctuation">=</span><span class="token value attr-value">ip</span><span class="token comment"># Redis服务器连接端口</span><span class="token key attr-name">spring.data.redis.port</span><span class="token punctuation">=</span><span class="token value attr-value">6379</span><span class="token comment"># Redis服务器连接密码（默认为空）</span><span class="token key attr-name">spring.data.redis.password</span><span class="token punctuation">=</span><span class="token value attr-value">pwd</span><span class="token comment"># 连接池最大连接数（使用负值表示没有限制）</span><span class="token key attr-name">spring.data.redis.jedis.pool.max-active</span><span class="token punctuation">=</span><span class="token value attr-value">8</span><span class="token comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><span class="token key attr-name">spring.data.redis.jedis.pool.max-wait</span><span class="token punctuation">=</span><span class="token value attr-value">1000</span><span class="token comment"># 连接池中的最大空闲连接</span><span class="token key attr-name">spring.data.redis.jedis.pool.max-idle</span><span class="token punctuation">=</span><span class="token value attr-value">8</span><span class="token comment"># 连接池中的最小空闲连接</span><span class="token key attr-name">spring.data.redis.jedis.pool.min-idle</span><span class="token punctuation">=</span><span class="token value attr-value">0</span><span class="token comment"># 连接超时时间（毫秒）</span><span class="token key attr-name">spring.data.redis.timeout</span><span class="token punctuation">=</span><span class="token value attr-value">5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注入RedisTemplate，测试"><a href="#注入RedisTemplate，测试" class="headerlink" title="注入RedisTemplate，测试"></a>注入RedisTemplate，测试</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">SpringRedisApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 写入string</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"胡歌"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取string数据</span>        <span class="token class-name">Object</span> name <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> name <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h4><p><strong>RedisTemplate默认采用JDK的序列化工具，可以接收任意Object作为值写入Redis，序列化为字节形式，在redis中可读性很差且内存占用大。</strong><br>修改默认的序列化方式为jackson</p><p>我们可以自定义RedisTemplate的序列化方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> connectionFactory<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 创建RedisTemplate对象</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置连接工厂</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建JSON序列化工具</span>        <span class="token class-name">GenericJackson2JsonRedisSerializer</span> jsonRedisSerializer <span class="token operator">=</span>             <span class="token keyword">new</span> <span class="token class-name">GenericJackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置Key的序列化</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置Value的序列化</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512170814734.png" style="zoom:80%;"><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><img src="/2024/05/11/redis/image-20240512170944012.png"><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，<strong>其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</strong></p><h4 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h4><p>为了<strong>节省内存空间</strong>，我们可以<strong>不使用JSON序列化器来处理value，而是统一使用String序列化器</strong>，要求<strong>只能存储String类型的key和value</strong>。当需要存储Java对象时，<strong>手动完成对象的序列化和反序列化。</strong></p><p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">RedisStringTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 写入一条String数据</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"verify:phone:13600527634"</span><span class="token punctuation">,</span> <span class="token string">"124143"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取string数据</span>        <span class="token class-name">Object</span> name <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// JSON序列化工具</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ObjectMapper</span> mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testSaveUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">JsonProcessingException</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建对象</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"虎哥"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 手动序列化</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写入数据</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user:200"</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取数据</span>        <span class="token class-name">String</span> jsonUser <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user:200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 手动反序列化</span>        <span class="token class-name">User</span> user1 <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>jsonUser<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user1 = "</span> <span class="token operator">+</span> user1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user:400"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"虎哥"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user:400"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> entries <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token string">"user:400"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"entries = "</span> <span class="token operator">+</span> entries<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员redis：<a href="https://www.bilibili.com/video/BV1cr4y1671t/?p=16&amp;spm_id_from=pageDriver&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1cr4y1671t/?p=16&amp;spm_id_from=pageDriver&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>redis常用命令：<a href="https://blog.csdn.net/weixin_49851451/article/details/134311296">https://blog.csdn.net/weixin_49851451/article/details/134311296</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UrbanGPT: Spatio-Temporal Large Language Models</title>
      <link href="/2024/04/30/urbangpt-spatio-temporal-large-language-models/"/>
      <url>/2024/04/30/urbangpt-spatio-temporal-large-language-models/</url>
      
        <content type="html"><![CDATA[<h1 id="UrbanGPT-Spatio-Temporal-Large-Language-Models"><a href="#UrbanGPT-Spatio-Temporal-Large-Language-Models" class="headerlink" title="UrbanGPT: Spatio-Temporal Large Language Models"></a>UrbanGPT: Spatio-Temporal Large Language Models</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><strong>时空预测旨在对不断变化的动态城市场景进行预测和洞察，涵盖了时间和空间两个维度。</strong>它的目的是预测城市生活的不同方面的未来模式、趋势和事件，包括交通运输、人口流动和犯罪率等。尽管大量研究都致力于开发神经网络技术来准确预测时空数据，但需要注意的是，<strong>许多方法严重依赖于有足够的标记数据来生成精确的时空表示</strong>。不幸的是，<strong>数据稀缺</strong>的问题在实际的城市感知场景中是普遍存在的。在某些情况下，从下游场景中收集任何标记数据变得具有挑战性，这进一步加剧了问题。因此，有必要建立一个时空模型，能够在不同的时空学习场景中表现出强大的泛化能力。</p><p>受大语言模型（LLMs）的显著成就的启发，我们的目标是<strong>创建一个时空LLM，能够在广泛的下游城市任务中表现出特殊的泛化能力。</strong>为了实现这一目标，我们提出了UrbanGPT，它无缝地<strong>集成了一个时空依赖编码器与指令微调范式</strong>。这种集成使llm能够理解复杂的时间和空间相互依赖，促进在数据稀缺下进行更全面和准确的预测。为了验证我们的方法的有效性，我们在各种公共数据集上进行了广泛的实验，包括不同的时空预测任务。结果一致表明，我们的UrbanGPT，以其精心设计的架构，始终优于最先进的基准模型。这些发现突出了为时空学习建立大型语言模型的潜力，特别是在标记数据稀缺的零样本场景中。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>时空预测的动机源于对准确预测和获取城市环境动态本质的渴望。通过对时间和空间上不断变化的动态进行分析和理解，时空预测使我们能够预测未来城市生活各个方面的模式、趋势以及各种事件。这在城市计算领域至关重要，因为预测交通模式可以优化交通流量、减少拥堵，增强整体城市流动性[17,30]。此外，预测人口流动有助于有效的城市规划和资源分配[6,19]。再者，预测犯罪的能力可以极大地提高公共安全[31]。时空预测在塑造更智能、更高效的城市方面扮演着关键角色，最终提升城市生活质量。</p><p>在时空预测领域常用的各种神经网络架构是十分重要的。这些架构旨在捕捉和建模数据中空间和时间维度之间复杂的关系。其中一种广泛采用的架构是卷积神经网络（CNN）[14, 38, 44]，它通过对输入数据应用卷积滤波器，可以有效地提取空间特征。另一类时空神经网络是循环神经网络（RNN）系列[1, 33, 42]。这些时空RNN非常适合通过维护一个可以随时间保留信息的记忆状态来实现时间依赖关系的捕捉。最近，图神经网络（GNNs）在时空预测中的应用急剧增加[35, 39, 46]。<strong>GNNs在建模数据中的复杂空间关系方面表现出色，其中每个节点对应一个空间位置，边捕捉它们之间的连接关系。</strong></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>挑战1：标注数据稀缺，数据无法迁移到新场景，重新训练开销巨大</strong>：虽然时空神经网络技术已被证明非常有效，但它们严重依赖于大量标记数据以生成准确的预测。实际城市场景中普遍存在数据稀缺问题，例如，由于成本高昂，在整个城市空间部署传感器来监控全市交通量或空气质量是不切实际的。此外，<strong>现有模型在应对新地区或城市预测任务时不具备良好的泛化能力，需重新训练以生成时空表征。</strong></p><p><strong>挑战2：LLMs和现有时空模型缺乏零样本场景下的泛化能力：</strong>如图1所示，大语言模型LLaMA可根据输入文本对流量模式进行推断。然而，它在处理具有复杂时空依赖性的<strong>数字时间序列数</strong>据方面的局限性有时会导致相反的预测结果。另一方面，预训练的基线模型能够很好地编码时空依赖关联。然而，<strong>它可能会由于对源数据集的过拟合导致其在零样本场景下表现不佳。</strong></p><p><strong>挑战3：如何将LLMs的出色推理能力扩展到时空预测场景</strong>：时空数据的独特特征与LLMs中所编码的知识之间存在差距，如何减少这一差距进而建立在广泛的城市任务中具有出色的泛化能力时空大语言模型是一项重大挑战。</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><p><strong>（1） 据我们所知，这是首次尝试</strong>开发一种能够在不同数据集上预测各种城市现象的时空大语言模型，尤其是在训练样本受限的情况下。</p><p><strong>（2）提出了时空预测模型UrbanGPT</strong>：我们提出了UrbanGPT，一种专门针对时空预测而定制的大型语言模型。UrbanGPT的核心是<strong>一种新的时空指令调整范式</strong>，它寻求将时间和空间的复杂依赖关系与llm的知识空间相结合。</p><ul><li>在我们的UrbanGPT框架中，我们首先合并了一个<strong>时空依赖编码器</strong>，它<strong>利用了一个多层的时间卷积网络以捕捉时间动态。</strong></li><li>然后，我们的模型涉及到<strong>对齐文本和时空信息</strong>，以使语言模型能够有效地注入时空上下文信号。这是通过使用一个<strong>轻量级对齐模块</strong>来实现的。其结果是，通过整合来自文本和时空领域的有价值的信息，生成更具表达性的语义表示</li><li><strong>通过将时空依赖编码器无缝集成到指令微调范式中，有效地将时空上下文与大语言模型相结合。</strong></li></ul><p>为了展示我们提出的模型的优越的预测性能，我们将其与大型语言模型（LLaMA- 70B）和时空图神经网络（STGCN）进行了比较。</p><ul><li>大型语言模型LLaMA可以从输入的文本中有效地推断出流量模式。然而，<strong>它在处理具有复杂时空依赖性的数字-时间序列数据方面具有局限性，有时会导致相反的交通趋势预测。</strong></li><li>另一方面，预先训练的基线模型显示了对时空依赖性的强烈理解。然而，<strong>它可能会对源数据集进行过拟合，并且在零样本场景下表现不佳，这表明它对现有时空预测模型的泛化能力有限</strong>。</li><li>相比之下，我们提出的模型实现了对特定领域的时空知识和语言建模能力的和谐集成。这使我们能够在数据匮乏的情况下做出更准确和可靠的预测</li></ul><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318132230618.png" alt="image-20240318132230618" style="zoom:80%;"><p>图1：与大型语言模型（LLaMA-70B）和时空图神经网络（STGCN）相比，该模型在零样本交通流预测场景中具有优越的预测性能。</p><p><strong>(3) 在现实世界数据上进行的大量实验</strong>证明了本文提出的UrbanGPT在零样本时空学习场景中具有出色的泛化能力。这些发现突显了该模型的强大泛化能力，表明它在准确预测和理解时空模式方面的有效性，即使在零样本场景下也是如此。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="时空数据-Spatio-Temporal-Data"><a href="#时空数据-Spatio-Temporal-Data" class="headerlink" title="时空数据 Spatio-Temporal Data."></a>时空数据 <strong>Spatio-Temporal Data</strong>.</h3><p><strong>时空数据</strong>可以表示为三维张量<strong>：X∈R^𝑅×𝑇×𝐹</strong>。张量中的每个元素<strong>X𝑟、𝑡、𝑓</strong>都对应于在第𝑟个区域的第𝑡个时间间隔上的第𝑓个特征的值。</p><ul><li>考虑预测一个城市地区的出租车交通模式。在这种情况下，数据可以表示从𝑡到𝑡−1的给定时间段（例如，30分钟的间隔）内，特定区域（例如，第𝑟个空间区域）内出租车的流入和流出。‘</li></ul><h3 id="时空预测-Spatio-Temporal-Forecasting"><a href="#时空预测-Spatio-Temporal-Forecasting" class="headerlink" title="时空预测 Spatio-Temporal Forecasting"></a>时空预测 <strong>Spatio-Temporal Forecasting</strong></h3><p><strong>时空预测</strong>：在时空预测任务中，一个常见的场景是利用历史数据来预测未来的趋势。具体来说，其目标是根据从前面的𝐻步骤中获得的信息来预测下一个𝑃时间步长的数据。</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318153916911.png" alt="image-20240318153916911"><p>函数𝑓（·）代表了一个利用历史数据进行有效训练的时空预测模型。时空预测任务主要可分为两大类：</p><ul><li><strong>回归预测</strong>，包括预测交通流量或出租车需求等连续值；</li><li><strong>分类预测</strong>，其目标是分类犯罪发生预测等事件。</li></ul><p>为了优化函数f，基于时空场景的具体特征使用了不同的损失函数</p><h3 id="时空零样本学习-Zero-Shot-Learning"><a href="#时空零样本学习-Zero-Shot-Learning" class="headerlink" title="时空零样本学习 Zero-Shot Learning"></a>时空零样本学习 <strong>Zero-Shot Learning</strong></h3><p>尽管目前的时空学习方法是有效的，但它们在有效地推广到各种下游时空学习场景时经常遇到困难。在本研究中，我们的重点是解决时空零样本场景的挑战，我们的目标是<strong>学习下游时空预测数据集或任务里没见过的数据</strong>。这可以正式定义如下：</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318155213668.png"><p>在这个特殊的场景中，预测函数𝑓ˆ（·）负责预测以前没有遇到过的下游任务的时空数据˜X。需要注意的是，模型𝑓ˆ（·）并不是针对目标数据进行专门训练的。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318210558121.png"><p>图2：所提出的时空语言模型UrbanGPT的总体架构。</p><h3 id="时空依赖编码器"><a href="#时空依赖编码器" class="headerlink" title="时空依赖编码器"></a>时空依赖编码器</h3><ul><li><p>集成一个包含多层次时间卷积网络（ a multi-level temporal convolutional network.）的时空编码器来增强大型语言模型在时空上下文中捕获时间依赖性的能力。</p></li><li><p>具体来说，我们的时空编码器由两个关键组件组成：<strong>门控扩散（空洞）卷积层（</strong>a gated dilated convolution layer ）和<strong>多层次关联注入层</strong>（a multi-level correlation injection layer）</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318201003133.png"></li><li><p>初始化时空嵌入：Er∈R^T×d。这种嵌入是通过一个线性层来增强原始数据X而获得的。</p></li><li><p>为了解决梯度消失的问题，我们使用了一个E𝑟切片，表示为Er‘，由扩张的卷积核的大小决定。<strong>该切片用于执行残差操作。</strong></p></li><li><p>使用<strong>一维扩散卷积核</strong>W¯k，<img src="https://latex.csdn.net/eq?%5Cbar%7B%5Ctextbf%7BW%7D%7D_g%5Cin%5Cmathbb%7BR%7D%5E%7BT_g%5Ctimes%20d_%7Bin%7D%5Ctimes%20d_%7Bout%7D%7D" alt="\bar{\textbf{W}}_g\in\mathbb{R}^{T_g\times d_{in}\times d_{out}}">编码时间关联，相应偏置项bk，bg属于R^dout。Sigmoid激活函数δ用于控制多层卷积运算的信息保留程度。在进行门控时间扩张卷积层编码后，我们能够有效地捕获<strong>多个时间步长中的时间依赖性</strong>，从而生成时间表示。</p></li><li><p><strong>这些表示包含不同级别的时间依赖关系</strong>，反映了各种具有粒度感知的<strong>时间演化模式</strong>。为了保留这些信息模式，我们引入了一个多层次关联注入层</p></li></ul><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318202940267.png"><ul><li>其中Ws∈R^Ts×dout×d′out是形如W¯k的卷积核，经过L层编码后，我们<strong>使用一个简单的非线性层融合门控扩散卷积层和多层次关联注入层的结果</strong>，<strong>最终的时空依赖性表征表示为</strong>Ψ~∈R^R×T×d</li><li>为了处理下游可能出现的各种城市场景集，本文提出的时空编码器在<strong>建模空间相关性时独立于图结构</strong>。因为在零样本预测环境中，实体之间的空间关系可能是未知的或难以确定的。通过不依赖于显式的图结构，我们的编码器可以有效地处理广泛的城市场景，在这些场景中，空间相关性和依赖性可能会发生变化，或者很难预先定义。这种灵活性使我们的模型能够适应并表现良好，确保其在广泛的城市环境中的适用性。</li></ul><h3 id="时空指令微调"><a href="#时空指令微调" class="headerlink" title="时空指令微调"></a>时空指令微调</h3><h4 id="时空文本对齐"><a href="#时空文本对齐" class="headerlink" title="时空文本对齐"></a>时空文本对齐</h4><ul><li>为了<strong>使语言模型能够有效地理解时空模式，对齐文本信息和时空信息是至关重要的。这种对齐允许融合不同模态，从而产生信息更丰富的表示</strong>。</li><li>通过整合来自文本和时空领域的上下文特征，我们可以<strong>捕获互补信息</strong>，提取更具表达力和意义的更高层次的语义表示。为了实现这一目标，我们使用了一个<strong>轻量级的对齐模块来投影时空依赖表示˜Ψ</strong>。这个投影涉及到使用线性层参数W𝑝∈R^𝑑×𝑑𝐿和b𝑝∈R^𝑑𝐿，其中𝑑𝐿表示语言模型（llm）中常用的隐藏维度。</li><li>所得到的投影，表示为H∈R^𝑅×𝐹×𝑑𝐿，在指令中使用特殊的标记表示为： <st_start>，<st_his>，…，<st_his>，<st_end>。在这里，<st_start>和<st_end>作为标识时空的开始和结束的标识符。<strong>这些标识符可以通过扩展其词汇量来包含在大语言模型中</strong>。占位符<st_his>表示时空标记，并<strong>对应于隐藏层中的投影H</strong>。通过使用该技术，该模型获得了<strong>识别时空依赖性</strong>的能力，从而提高了其在城市场景中成功执行时空预测任务的熟练程度。</st_his></st_end></st_start></st_end></st_his></st_his></st_start></li></ul><h4 id="时空提示词（prompt）指令"><a href="#时空提示词（prompt）指令" class="headerlink" title="时空提示词（prompt）指令"></a>时空提示词（prompt）指令</h4><ul><li><p>在时空预测的场景中，<strong>时间和空间信息都包含了有价值的语义细节</strong>，有助于模型理解特定上下文的时空模式。例如，清晨和高峰时间段的交通流量有很大的不同，并且商业区和住宅区之间的交通模式也存在差异。因此，<strong>将时间和空间信息表示为提示文本对时空预测任务是有益的</strong>。</p></li><li><p>我们利用大语言模型的文本理解能力来编码这些信息。在UrbanGPT框架中，我们<strong>集成了多粒度的时间信息和空间细节，作为大语言模型的指令输入</strong>。</p><ul><li>时间信息包括一周的日期和时间，一天的时间等因素。</li><li>而<strong>区域信息包括城市、行政区域和附近的兴趣点（POI）数据等</strong>，如图3所示。</li><li>通过合并这些不同的元素，UrbanGPT能够<strong>识别和理解复杂的时空环境下不同区域和时段的时空模式</strong>，从而增强其零样本推理能力。</li></ul></li></ul><p>时空信息指令文本的设计如图3所示。图3：编码时间和位置感知信息的时空提示指令的说明。</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318210901930.png"><h4 id="LLM的时空指令微调"><a href="#LLM的时空指令微调" class="headerlink" title="LLM的时空指令微调"></a>LLM的时空指令微调</h4><p>使用指令微调LLMs以生成文本格式的时空预测存在两个挑战。</p><ul><li>首先，<strong>时空预测通常依赖于数值数据，其结构和模式与语言模型擅长处理的自然语言不同，后者侧重于语义和句法关系</strong>。</li><li>其次，<strong>LLMs通常使用多分类损失进行预训练以预测词汇，从而得到潜在结果的概率分布。而回归任务则需要连续值分布。</strong><ul><li>也就是说llm是一个词一个词的预测，而回归任务需要直接得到一组连续的数值分布</li></ul></li></ul><p>为了解决这些挑战，UrbanGPT采用了一种不同的策略，===<strong>不直接预测未来的时空值，而是生成辅助预测过程的预测标记</strong>（token）===。</p><p><strong>这些标记随后通过回归层，将隐藏表示映射为生成更准确的预测值</strong>：</p><p><strong>（STLlama  409-433）</strong></p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318211556936.png"><p>预测结果，记为ˆY𝑟，𝑓∈R^𝑃，使用<strong>线性整流激活函数（ReLU），用𝜎表示</strong>。<strong>预测标记的隐藏表示，表示为Γ𝑟，𝑓∈R^𝑑𝐿</strong>，<strong>作为大型语言模型（LLMs）词汇表中的一个新术语被引入</strong>。回归层使用权重矩阵W1∈R𝑑‘×𝑑𝐿、W2∈R𝑑’×𝑑𝐿和W3∈R𝑃×2𝑑‘表示，其中[·，·]表示连接操作。**虽然预测token的概率分布保持相对稳定，但其隐藏的表征包含了丰富的时空上下文属性，从而捕获了动态的时空相互依赖性。这使得我们的模型能够通过利用这些上下文信息来提供精确的预测。</p><h3 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h3><ul><li>在基线模型[1,7]的基础上，我们采用<strong>绝对误差损失作为回归损失函数</strong>。这种选择使我们能够有效地处理各种城市场景中的预测。</li><li>此外，我们引入了一个分类损失作为一个联合损失，以满足不同的任务需求。</li><li>为了确保最佳的性能，我们的模型会<strong>根据特定的任务输入来优化不同的损失</strong>。例如，我们对交通流量预测等任务使用回归损失，而对犯罪预测等任务使用分类损失。这种方法使我们的模型能够有效地解决每个任务所带来的独特挑战</li></ul><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240318224114032.png" alt="image-20240318224114032" style="zoom: 67%;"><p>这里，𝑦𝑖表示来自ˆY的一个样本，𝑁表示样本总数，计算为𝑅、𝑇和𝐹的乘积。我们在我们的模型中使用了各种损失函数，包括Lc–二元交叉熵损失；L𝑟表示回归损失，以及在我们的时空语言模型中采用的交叉熵损失。为了从预测中获取概率分布，我们使用了用𝛿表示的sigmoid激活函数。这些损失函数在我们的模型中都扮演着特定的角色，使我们能够根据需要有效地处理分类、回归和语言建模任务。</p><h3 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h3><p>超参数设置。时间编码器中膨胀卷积核的参数设置如下：𝑑𝑖𝑛、𝑑𝑜𝑢𝑡、𝑑‘𝑜𝑢𝑡均设置为32，膨胀因子为1。对于我们的预测任务，我们的目标是基于之前的12个步骤来预测数据的下一个12个步骤。历史记录长度（𝐻）和预测记录长度（𝑃）均设置为12。投影层参数配置为𝑑设置为64，𝑑𝐿设置为4096。最后，将回归层的隐层参数𝑑‘设置为128。</p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>关键问题：</p><ul><li>RQ1：UrbanGPT在不同的零样本时空预测任务中的性能和泛化能力是什么？</li><li>RQ2：与现有的时空模型相比，UrbanGPT在经典监督场景中的表现如何？</li><li>RQ3：提出的关键组件为提高我们的UrbanGPT模型的能力带来了哪些具体的贡献？</li><li>RQ4：所提出的模型能否稳健地处理不同时空模式的预测情景？</li></ul><h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><ul><li><p>为了评估所提出的模型在预测不同城市计算场景的时空模式方面的有效性，我们使用四个不同的数据集进行了实验：纽约出租车、纽约自行车、纽约犯罪和芝加哥出租车。</p></li><li><p><strong>为了便于分析，我们根据经纬度信息将城市划分为类似网格的区域。</strong>在特定的时间间隔内，我们汇总了每个区域的统计测量值。</p></li><li><p>例如，这涉及到计算区域A30分钟周期内的出租车流入和流出的数量，或确定区域B一天内的盗窃事件的数量。此外，利用不同区域的纬度和经度，兴趣点（POIs）数据可以通过地图服务提供的api获得。</p></li></ul><p>纽约市的出租车数据集包含263个区域，每个区域的面积约为3公里x3公里。该数据集的时间采样间隔为30分钟。纽约自行车和纽约犯罪数据集包括2162个地区，每个地区都由一个1公里x1公里的网格代表。纽约自行车的采样间隔也是30分钟，而纽约犯罪的采样间隔是1天。所有数据集涵盖了纽约市从2016年1月1日至2021年12月31日的时间段。芝加哥出租车数据集包括77个区域，每个区域的长度约为4公里x4公里。该数据集包括从2021年1月1日至2021年12月31日期间的所有出租车数据，时间采样间隔为30分钟。</p><h4 id="评估协议"><a href="#评估协议" class="headerlink" title="评估协议"></a>评估协议</h4><p>为了研究大型语言模型在分析不同地区的不同时空数据方面的能力，我们选择了来自纽约市不同地区的出租车、自行车和犯罪数据的一个子集作为我们的训练集。</p><p><strong>零样本学习场景：</strong>我们通过预测来自纽约市甚至芝加哥那些<strong>在训练阶段未见过的地区的未来时空数据</strong>来评估模型的性能。</p><p><strong>监督学习场景：</strong>我们使用来自训练集相同区域的未来数据来评估该模型。</p><ul><li><p><strong>回归任务</strong>：我们在所有基线模型上保持了一致的训练和测试方法。</p></li><li><p>在涉及犯罪数据的<strong>分类任务</strong>时，我们使用二元交叉熵作为损失函数对模型进行训练和测试。</p></li></ul><p>我们的实验是使用稳健的vicuna-7b [49]作为UrbanGPT的基础大型语言模型进行的。关于我们的方法和实验设置的更全面的理解，请参阅附录中的详细信息。</p><h4 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h4><ul><li><p>对于回归任务，我们使用MAE（平均绝对误差）和RMSE（均方根误差）作为评价度量。这些指标量化了预测结果和实际标签之间的差异，较低的值表明优越的性能[11,48]。</p></li><li><p>在分类任务的情况下，我们使用召回率和Macro-F1作为评估指标来评估绩效。召回度量了模型正确识别积极实例的能力，而Macro-F1是一个综合的性能度量，它结合了精度和召回率，提供了分类精度[10,29]的总体度量。</p></li></ul><h4 id="基线模型"><a href="#基线模型" class="headerlink" title="基线模型"></a>基线模型</h4><p>我们与10个高级模型进行了彻底的比较：</p><p>（1）在基于rnn的时空预测方法类别中，我们将我们提出的方法与AGCRN [1]、DMVSTNET [38]和ST-LSTM [32]进行了比较。这些方法利用rnn进行建模和预测。</p><ul><li>ST-LSTM[32]：它结合了长短期记忆来捕获时空数据中的时间依赖性。</li><li>AGCRN[1]：rnn被用来捕获时间相关性，允许表示随着时间的推移的进化模式。</li><li>DMVSTNET[38]：在这种方法中，rnn被用来有效地建模时间依赖关系，捕获随时间演变的模式。此外，利用卷积网络和全连接层来捕获局部空间相关性，并建立有意义的空间关系。</li></ul><p>（2）基于gnn的时空模型主要利用图神经网络来捕获空间相关性，并整合时间编码器来捕获时空关系。我们与这类模型进行了比较，包括GWN [36]，MTGNN [35]，STSGCN [25]，TGCN [46]，和STGCN [41].</p><ul><li>GWN[36]：它结合了一个可学习的图结构和一维卷积来有效地学习时空依赖关系。</li><li>MTGNN[35]：它利用一个可学习的图结构来建模多元的时间相关性。MTGNN使用一维膨胀卷积来生成时间表示。</li><li>TGCN[46]：该模型结合了图神经网络（GNNs）进行空间相关建模和递归神经网络（RNNs）进行时间相关建模。</li><li>STGCN[41]：它分别使用门控时间卷积和gnn来建模时间和空间依赖性。</li><li>STSGCN[25]：它引入了一个时空图的构造来学习相邻时间步长之间的空间相关性。</li></ul><p>（3）在基于注意的时空模型类别中，该方法采用注意机制来建模时空相关性。我们在这一类中比较的模型是ASTGCN [7]和STWA [5]。</p><ul><li>ASTGCN[7]：该方法采用注意机制来捕获多粒度的时间相关特征。</li><li>STWA[5]：该模型将个性化的时间和空间参数纳入注意模块，允许对动态时空相关性的建模</li></ul><h3 id="零样本预测性能（RQ1）"><a href="#零样本预测性能（RQ1）" class="headerlink" title="零样本预测性能（RQ1）"></a>零样本预测性能（RQ1）</h3><h4 id="相同城市内未见区域的预测"><a href="#相同城市内未见区域的预测" class="headerlink" title="相同城市内未见区域的预测"></a>相同城市内未见区域的预测</h4><p>跨区域场景需要使用来自城市内某些区域的数据来<strong>预测模型没有遇到的其他区域的未来情况</strong>。通过对模型在跨区域预测中的表现的全面分析，我们可以注意到三个重要的观察结果：</p><p><strong>（1）优越的零样本预测性能。</strong>表1中的结果突出了所提出的模型在不同数据集上的<strong>回归和分类任务</strong>中的卓越性能，超过了零样本预测中的基线模型。UrbanGPT的成功可以归因于两个关键因素。</p><ul><li><strong>时空-文本对齐。</strong>时空上下文信号与语言模型的文本理解能力的对齐对模型成功起着关键作用。这种融合使模型能够有效地<strong>利用从时空信号中编码的城市动态和由大语言模型提供的对文本上下文的全面理解</strong>，从而扩展了模型在零样本场景的预测能力。</li><li><strong>时空指令微调。</strong>自适应调整过程使LLMs能够有效地整合指令中的关键信息，增强其对空间和时间因素之间复杂关系和依赖性的理解。 通过将时空指令微调与时空依赖编码器无缝合并， UrbanGPT成功地保留了<strong>通用且可转移的时空知识</strong>，进而实现零样本场景中的精确预测。</li></ul><p><strong>（2）增强了对城市语义的理解。</strong>城市语义提供了对多样的空间和时间特性的重要见解。所提出的方法在各种数据集上对模型进行训练，<strong>丰富其对不同时段和地理位置的时空动态的理解。</strong>相比之下，<strong>基准模型往往优先考虑编码时空依赖关系，忽视了区域、时段和数据类别之间的语义差异。</strong>通过将全面的语义信息注入UrbanGPT中，我们显著增强了其在先前未见的区域中进行准确零样本预测的能力。</p><p><strong>（3）稀疏数据场景中的性能提升。</strong>稀疏数据环境中预测时空模式是具有挑战性的，因为<strong>当数据点稀缺时，模型容易出现过拟合</strong>。在预测犯罪等情况下，数据通常是稀疏的，在这一条件下，基线在跨区域预测任务中表现困难，导致召回率低，表明可能存在过拟合的问题。为了克服这个限制，我们的模型<strong>通过使用有效的时空指令微调范式，将时空学习与大语言模型相结合。通过融入丰富的语义见解，所提出的方法增强了模型的时空表示能力，使其能够有效处理稀疏数据，并实现改进的预测准确性。</strong></p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319140723091.png"><h4 id="跨城市预测任务"><a href="#跨城市预测任务" class="headerlink" title="跨城市预测任务"></a>跨城市预测任务</h4><p>为评估模型在跨城市预测任务中的性能，我们对芝加哥出租车数据集进行了测试（该数据集没有出现在训练阶段）。如图4所示，结果显示模型在每个时间步长都始终优于比较方法，这说明UrbanGPT能够对跨城市知识进行有效的转移。通过整合时空编码器与时空指令微调范式，模型有效地捕获了普遍及特殊的时空模式。此外，通过考虑不同的地理信息和时间因素以及学到的转移知识，模型具备将相似功能区域和历史时期所表现出的时空模式进行关联的能力，使其能够做出更准确的预测。</p><ul><li><strong>多步预测的一致性</strong>：我们的模型<strong>在每个时间步长上始终优于比较方法</strong>。值得注意的是，它在短期和长期的时空预测中都保持了显著的优势，证明了我们提出的模型在跨城市预测场景中的鲁棒性。</li><li><strong>跨城市有效知识迁移</strong>：芝加哥出租车数据集预测结果验证了我们的模型在跨城市场景中的优越能力。这种增强可以<strong>归因于时空编码器与时空指令调整范式的集成。</strong>通过合并这些组件，我们的模型有效地<strong>捕获了通用的和可转移的时空模式</strong>，使它能够做出准确的预测。此外，<strong>通过考虑不同的地理信息和时间因素以及学习到的知识转移，我们的模型成功地关联了相似功能区和历史时期的时空模式。</strong></li></ul><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319143415576.png"><h3 id="典型有监督预测任务（RQ2）"><a href="#典型有监督预测任务（RQ2）" class="headerlink" title="典型有监督预测任务（RQ2）"></a>典型有监督预测任务（RQ2）</h3><p>本节研究了我们的UrbanGPT在端到端监督预测场景中的预测能力，如表2所示。</p><ul><li><strong>增强的长期预测能力</strong>：我们利用时间间隔跨度更广的测试数据集来测试模型在长期时空预测中的有效性。例如，使用2017年的数据训练模型，并使用2021年的数据进行评估。结果表明，我们的UrbanGPT在基线相比具有显著的优势，突显了其<strong>长期时间跨度场景的卓越泛化能力</strong>。此特性<strong>减少了频繁重新训练或增量更新的需要</strong>，使模型更符合实际应用。此外，实验还证实，<strong>加入额外的文本知识不会阻碍模型性能或引入噪声</strong>，从而进一步验证了利用大型语言模型增强时空预测任务的可行性。</li><li><strong>空间语义理解</strong>：准确捕捉空间相关性在时空预测领域至关重要。传统的方法通常使用<strong>图网络或注意机制</strong>来分析这些相关性。缺乏专门的空间相关模块的模型，如LSTM，在忽视空间环境时往往表现不佳。相比之下，我们的模型通过<strong>在文本输入中集成广泛的地理和感兴趣点（POIs）数据来弥补了显式空间编码器的缺失</strong>。<strong>这种方法使模型能够在更高的语义层次上理解具有相似功能的区域的共享特征。因此，它推导出不同功能区之间的关联模式，并有效地代表了不同区域之间的相互联系。</strong></li></ul><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319143505846.png" alt="image-20240319143505846" style="zoom:80%;"><h3 id="消融研究（RQ3）"><a href="#消融研究（RQ3）" class="headerlink" title="消融研究（RQ3）"></a>消融研究（RQ3）</h3><p>本节研究了不同关键组件对模型性能的影响，如图5所示。我们严格的测试主要围绕着使用纽约市出租车数据集的零样本场景展开。通过我们的分析，我们将不同模块所提供的好处提炼为四个关键点。</p><p><strong>(1) 时空上下文的影响</strong>：-STC。从指示文本中移除时空信息后出现了性能衰减，这可能由于<strong>缺乏时间信息</strong>，<strong>使得模型仅依赖于时空编码器来编码与时间相关的特征和执行预测任务</strong>。此外，空间信息的缺失阻碍了模型捕捉空间相关性的能力，使得分析不同区域的不同时空模式具有挑战性。</p><p><strong>(2) 使用多个数据集进行指令微调的影响</strong>：-Multi。我们仅在NYC-taxi数据集进行训练。由于<strong>缺乏不同的城市指标的信息，限制了模型充分揭示城市时空动态的能力</strong>。通过整合来自多个来源的不同时空数据，模型可以有效地捕获不同地理位置的独特特征及演化的时空模式。</p><p><strong>(3) 时空编码器的影响</strong>：-STE。我们从模型中移除了时空编码器。结果表明，时空编码器的缺失<strong>显著地阻碍了大语言模型在时空预测场景中的预测性能</strong>。这强调了所提出的时空编码器在提高模型的预测能力方面所发挥的关键作用。</p><p><strong>(4) 指令微调中的回归层</strong>：T2P。我们直接指示UrbanGPT以文本格式生成其预测。次优的性能表现主要是由于训练过程中依赖于多类损失来进行优化，导致<strong>模型的概率输出和时空预测所需的连续值分布之间的不匹配</strong>。为了弥补这一差距，我们在模型中加入了一个回归预测器，显著提高了它在回归任务生成更精确的数值预测的能力。</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319145301101.png" alt="image-20240319145301101" style="zoom:80%;"><h3 id="模型鲁棒性研究（RQ4）"><a href="#模型鲁棒性研究（RQ4）" class="headerlink" title="模型鲁棒性研究（RQ4）"></a>模型鲁棒性研究（RQ4）</h3><p>在本节中，我们将重点评估我们的UrbanGPT在不同时空模式场景下的稳健性。<strong>我们根据数值变化的大小对区域进行分类，</strong>如在特定时间段内的出租车流量。<strong>较低的方差表明稳定的时间模式，而较高的方差表明时空模式多样化的地段，如活跃商业区或人口稠密地区。</strong>如图6所示，大多模型在方差较低的区域表现良好，因为这些区域的时空模式相对稳定。然而，基线在方差较高的区域中表现不佳，特别是在方差处于 (0.75, 1.0] 范围的区域，这一限制可能源自<strong>基线模型在零样本场景下难以推断未见区域的复杂时空模式</strong>。在实际应用中，<strong>人口密集或繁华区域的准确预测对于城市治理至关重要</strong>，例如交通灯控制和安全调度。UrbanGPT在(0.75, 1.0]区间表现出显着的性能提升，突显了所提出方法的强大的零样本预测能力。</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319152953670.png" alt="image-20240319152953670" style="zoom:80%;"><h3 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h3><p>在我们的案例研究中，我们彻底评估了几个大型语言模型（llm）的零样本时空预测。我们强调了这些模型在直接从数字地理序列数据中理解时空模式方面所面临的挑战。相比之下，我们展示了我们提出的UrbanGPT框架在捕获通用时空模式方面的特殊性能，以及它在各种零样本时空预测场景中有效推广的能力。</p><p>结果表明，各种llm能够基于这些指令生成预测，从而突出了提示设计的有效性。<strong>例如，ChatGPT依赖于历史平均值，而不是在其预测中明确地组合时间或空间数据。Llama-2-70b分析了特定的时间段和区域，但它在编码数值时间序列依赖性方面遇到了挑战，导致了次优的预测性能。另一方面，Claude-2.1有效地总结和分析了历史数据，利用高峰时段模式和兴趣点来实现更准确的交通趋势预测。</strong></p><p>我们提出的UrbanGPT通过一个时空指令调优范式，无缝地将时空上下文信号与大型语言模型（llm）的推理能力集成起来。这种整合导致了预测数值和时空趋势的显著改进。</p><p>表3：我们用所提供的instruction测试了不同llm对纽约市自行车流量的零样本预测</p><img src="/2024/04/30/urbangpt-spatio-temporal-large-language-models/image-20240319170828390.png" alt="image-20240319170828390" style="zoom:80%;"><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p><strong>深度时空预测模型。</strong>深度时空预测方法由于其出色的性能而在深度学习中获得了突出的地位。这些模型通常由两个组成部分组成：<strong>时间依赖建模和空间相关编码。</strong>早期的模型，如D-LSTM [42]和ST-resnet [44]，使用rnn和卷积网络来建模时间和空间依赖性。图神经网络（GNNs）被证明是空间相关建模的一种自然拟合，就像在STGCN [41]和DCRNN [13]等模型中所看到的那样，它们利用了基于节点距离的图结构。可学习的区域级图结构[35,36]和动态时空图网络[8,47]等技术进一步增强了空间相关建模。</p><p>此外，研究人员还探索了诸如多尺度时间学习[33]和多粒度时间学习[7]来编码时间依赖性的方法。这些策略能够捕获诸如长期和短期相关性以及周期性等特征。这些进步有助于时空预测的进展。然而，值得注意的是，这些研究大多数是为监督环境量身定制的，有限的研究和发展集中在零样本时空预测。这是一个需要进一步探索的重要领域。</p><p><strong>时空预训练。</strong>时空预训练技术最近受到了广泛的研究关注。这些技术主要关注于<strong>生成式[15,23]和对比式[45]预训练模型</strong>，以提高下游任务的预测性能。对少样本学习场景[12,18]的训练前微调框架也进行了广泛的探索，<strong>旨在通过对齐源数据和目标数据来提高知识的可转移性。</strong>然而，这些方法需要对目标数据进行训练或微调，并且缺乏零样本预测能力。在这项工作中，我们通过提出UrbanGPT来解决下游城市场景中数据稀缺的挑战。我们的模型展示了在各种场景中很好地泛化的能力，减轻了对目标数据进行广泛训练或微调的需要。</p><p><strong>大型语言模型。</strong>大型语言模型[3,20]的出现由于其在<strong>文本理解和推理</strong>等任务中前所未有的机器性能而引起了广泛的关注。这些模型已经成为一个热点话题，展示了从智能算法发展到人工智能的发展潜力。开源的大型语言模型，如Llama [27,28]、Vicuna [49]和ChatGLM [43]已经发布，导致研究人员探索它们在各个领域的应用，<strong>通过这些模型中的领域知识来增强迁移学习能力。</strong>在计算机视觉领域，研究人员将多模态大型语言模型与即时学习方法相结合，以实现下游任务[24,50,51]的零样本预测。此外，大型语言模型在图推理[2,4,26]和推荐[9,22,34]中的能力已被广泛研究。然而，在时空预测领域，利用大型语言模型进行零样本时空预测任务仍未得到很大程度的探索</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们提出了UrbanGPT，一种时空大型语言模型，以很好地推广到不同的城市场景。为实现时空上下文信号与LLMs无缝对齐，本文引入了一种时空指令微调范式。这赋予UrbanGPT在各种类型的城市数据中学习通用和可迁移的时空模式的卓越能力。大量实验分析展示了UrbanGPT架构及其关键组件的卓越有效性。</p><p>然而，需要注意的是，虽然结果是令人鼓舞的，但在未来的研究中仍然存在待解决的限制。作为第一步，我们积极收集更多种类的城市数据，以增强和完善UrbanGPT在更广泛的城市计算领域的能力。此外，理解UrbanGPT的决策过程也是重要的。虽然该模型表现出卓越的性能，但提供可解释性同样重要。未来的研究也将集中于赋予UrbanGPT模型解释其预测的能力。</p><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="训练UrbanGPT"><a href="#训练UrbanGPT" class="headerlink" title="训练UrbanGPT"></a>训练UrbanGPT</h3><h4 id="准备预训练checkpoint"><a href="#准备预训练checkpoint" class="headerlink" title="准备预训练checkpoint"></a>准备预训练checkpoint</h4><blockquote><p>checkpoint文件包含的内容很多，比如：模型参数、优化器状态、训练进度等信息。checkpoint文件的主要作用是在训练过程中保存模型状态，以便在训练过程中发生中断或结束后能够恢复模型的状态，或者在推断时使用已经训练好的模型参数。</p></blockquote><p>UrabnGPT基于以下优秀的现有模型进行训练。请按照指示准备checkpoint：</p><ul><li><p><code>Vicuna</code>:<br>准备我们的基本模型Vicuna，它是一个指令微调过的的chatbot，也是我们实现中的base model。</p><p>请下载权重<a href="https://github.com/lm-sys/FastChat#model-weights">here</a>.  我们通常使用具有7B参数的v1.5和v1.5-16k模型。您应该更新vicuna中的config.json，例如，v1.5-16k中的Json ‘可以在<a href="https://huggingface.co/datasets/bjdwh/checkpoints/blob/main/train_config/config.json">config.json</a>中找到。</p></li><li><p><code>Spatio-temporal Encoder</code>:<br>我们使用一个简单的基于TCN的时空编码器对时空依赖进行编码。通过典型的<strong>多步时空预测任务</strong>对<a href="./checkpoints/st_encoder/pretrain_stencoder.pth">st_encoder</a>的权值进行预训练。</p></li><li><p><code>Spatio-temporal Train Data</code>:<br>我们利用由纽约市出租车、自行车和犯罪数据组成的预训练数据，包括时空统计、记录的时间戳和有关区域兴趣点(poi)的信息。这些数据被组织在<a href="https://huggingface.co/datasets/bjdwh/ST_data_urbangpt/tree/main/train_data">train_data</a>中。请下载并放在。/UrbanGPT/ST_data_urbangpt/train_data 下。</p></li></ul><h4 id="指令微调"><a href="#指令微调" class="headerlink" title="指令微调"></a>指令微调</h4><ul><li><strong>Start tuning:</strong> 在上述步骤之后，您可以通过在<a href="urbangpt_train.sh">urbangpt_train.sh</a>中填充空白来开始指令调优。示例：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># to fill in the following path to run our UrbanGPT!</span><span class="token assign-left variable">model_path</span><span class="token operator">=</span>./checkpoints/vicuna-7b-v1.5-16k<span class="token assign-left variable">instruct_ds</span><span class="token operator">=</span>./ST_data_urbangpt/train_data/multi_NYC.json<span class="token assign-left variable">st_data_path</span><span class="token operator">=</span>./ST_data_urbangpt/train_data/multi_NYC_pkl.pkl<span class="token assign-left variable">pretra_ste</span><span class="token operator">=</span>ST_Encoder<span class="token assign-left variable">output_model</span><span class="token operator">=</span>./checkpoints/UrbanGPTwandb offlinepython <span class="token parameter variable">-m</span> torch.distributed.run <span class="token parameter variable">--nnodes</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--nproc_per_node</span><span class="token operator">=</span><span class="token number">8</span> <span class="token parameter variable">--master_port</span><span class="token operator">=</span><span class="token number">20001</span> <span class="token punctuation">\</span>    urbangpt/train/train_mem.py <span class="token punctuation">\</span>    <span class="token parameter variable">--model_name_or_path</span> <span class="token variable">${model_path}</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--version</span> v1 <span class="token punctuation">\</span>    <span class="token parameter variable">--data_path</span> <span class="token variable">${instruct_ds}</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--st_content</span> ./TAXI.json <span class="token punctuation">\</span>    <span class="token parameter variable">--st_data_path</span> <span class="token variable">${st_data_path}</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--st_tower</span> <span class="token variable">${pretra_ste}</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--tune_st_mlp_adapter</span> True <span class="token punctuation">\</span>    <span class="token parameter variable">--st_select_layer</span> <span class="token parameter variable">-2</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--use_st_start_end</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--bf16</span> True <span class="token punctuation">\</span>    <span class="token parameter variable">--output_dir</span> <span class="token variable">${output_model}</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--num_train_epochs</span> <span class="token number">3</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--per_device_train_batch_size</span> <span class="token number">4</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--per_device_eval_batch_size</span> <span class="token number">4</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--gradient_accumulation_steps</span> <span class="token number">1</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--evaluation_strategy</span> <span class="token string">"no"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--save_strategy</span> <span class="token string">"steps"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--save_steps</span> <span class="token number">2400</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--save_total_limit</span> <span class="token number">1</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--learning_rate</span> 2e-3 <span class="token punctuation">\</span>    <span class="token parameter variable">--weight_decay</span> <span class="token number">0</span>. <span class="token punctuation">\</span>    <span class="token parameter variable">--warmup_ratio</span> <span class="token number">0.03</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--lr_scheduler_type</span> <span class="token string">"cosine"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--logging_steps</span> <span class="token number">1</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--tf32</span> True <span class="token punctuation">\</span>    <span class="token parameter variable">--model_max_length</span> <span class="token number">2048</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--gradient_checkpointing</span> True <span class="token punctuation">\</span>    <span class="token parameter variable">--lazy_preprocess</span> True <span class="token punctuation">\</span>    <span class="token parameter variable">--report_to</span> wandb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="评估UrbanGPT"><a href="#评估UrbanGPT" class="headerlink" title="评估UrbanGPT"></a>评估UrbanGPT</h3><h4 id="准备-Checkpoints-and-Data"><a href="#准备-Checkpoints-and-Data" class="headerlink" title="准备 Checkpoints and Data"></a>准备 Checkpoints and Data</h4><ul><li>**Checkpoints: **您可以尝试通过使用自己的模型或我们发布的检查点来评估UrbanGPT。</li><li><strong>Data:</strong> 我们为纽约出租车数据拆分测试集，并为评估创建指令数据。请参阅[评估]<a href="https://huggingface.co/datasets/bjdwh/ST_data_urbangpt%EF%BC%89">https://huggingface.co/datasets/bjdwh/ST_data_urbangpt）</a></li></ul><span id="Running Evaluation"><h4 id="运行Evaluation"><a href="#运行Evaluation" class="headerlink" title="运行Evaluation"></a>运行Evaluation</h4><p>您可以通过在[urbangpt_eval.sh]（urbangpt_eval.sh）填充空白开始第二阶段tuning。下面是一个示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># to fill in the following path to evaluation!</span><span class="token assign-left variable">output_model</span><span class="token operator">=</span>./checkpoints/tw2t_multi_reg-cla-gird<span class="token assign-left variable">datapath</span><span class="token operator">=</span>./ST_data_urbangpt/NYC_taxi_cross-region/NYC_taxi.json<span class="token assign-left variable">st_data_path</span><span class="token operator">=</span>./ST_data_urbangpt/NYC_taxi_cross-region/NYC_taxi_pkl.pkl<span class="token assign-left variable">res_path</span><span class="token operator">=</span>./result_test/cross-region/NYC_taxi<span class="token assign-left variable">start_id</span><span class="token operator">=</span><span class="token number">0</span><span class="token assign-left variable">end_id</span><span class="token operator">=</span><span class="token number">51920</span><span class="token assign-left variable">num_gpus</span><span class="token operator">=</span><span class="token number">8</span>python ./urbangpt/eval/run_urbangpt.py --model-name <span class="token variable">${output_model}</span>  <span class="token parameter variable">--prompting_file</span> <span class="token variable">${datapath}</span> <span class="token parameter variable">--st_data_path</span> <span class="token variable">${st_data_path}</span> <span class="token parameter variable">--output_res_path</span> <span class="token variable">${res_path}</span> <span class="token parameter variable">--start_id</span> <span class="token variable">${start_id}</span> <span class="token parameter variable">--end_id</span> <span class="token variable">${end_id}</span> <span class="token parameter variable">--num_gpus</span> <span class="token variable">${num_gpus}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="扩张卷积"><a href="#扩张卷积" class="headerlink" title="扩张卷积"></a>扩张卷积</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DilatedInception</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cin<span class="token punctuation">,</span> cout<span class="token punctuation">,</span> dilation_factor<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>DilatedInception<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tconv <span class="token operator">=</span> nn<span class="token punctuation">.</span>ModuleList<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 创建一个列表以容纳多个卷积层</span>        self<span class="token punctuation">.</span>kernel_set <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>  <span class="token comment"># 不同的卷积核大小</span>        cout <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>cout<span class="token operator">/</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>kernel_set<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 计算每个卷积的输出通道数</span>        <span class="token keyword">for</span> kern <span class="token keyword">in</span> self<span class="token punctuation">.</span>kernel_set<span class="token punctuation">:</span>            <span class="token comment"># 添加具有不同卷积核大小和扩张率的卷积层，一维扩散卷积核</span>            self<span class="token punctuation">.</span>tconv<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>cin<span class="token punctuation">,</span> cout<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">,</span> dilation<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> dilation_factor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 使用定义的层执行卷积操作</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>kernel_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tconv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>kernel_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>   <span class="token comment"># 沿最后一个维度切片张量</span>        x <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>x<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>                 <span class="token comment"># 沿着通道维度拼接张量</span>        <span class="token keyword">return</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ST-Encoder-前向传播"><a href="#ST-Encoder-前向传播" class="headerlink" title="ST_Encoder 前向传播"></a>ST_Encoder 前向传播</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">:</span>    inputs <span class="token operator">=</span> source    <span class="token comment"># 转置维度以进行正确的卷积操作</span>    inputs <span class="token operator">=</span> inputs<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># (batch_size, feature_dim, num_nodes, input_window)</span>    <span class="token keyword">assert</span> inputs<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>input_window<span class="token punctuation">,</span> <span class="token string">'input sequence length not equal to preset sequence length'</span>    <span class="token comment"># 输入扩展到最大感受野，扩展部分填充0</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>input_window <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>receptive_field<span class="token punctuation">:</span>        inputs <span class="token operator">=</span> nn<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>pad<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>receptive_field<span class="token operator">-</span>self<span class="token punctuation">.</span>input_window<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    x <span class="token operator">=</span> self<span class="token punctuation">.</span>start_conv<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>     <span class="token comment"># 将输入张量进行卷积操作，输出特征图的通道数为 residual_channels=32，</span>    skip <span class="token operator">=</span> self<span class="token punctuation">.</span>skip0<span class="token punctuation">(</span>F<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dropout<span class="token punctuation">,</span> training<span class="token operator">=</span>self<span class="token punctuation">.</span>training<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 三层卷积</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>layers<span class="token punctuation">)</span><span class="token punctuation">:</span>        residual <span class="token operator">=</span> x  <span class="token comment"># 记录当前块输入作为残差</span>        filters <span class="token operator">=</span> self<span class="token punctuation">.</span>filter_convs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 普通卷积操作</span>        filters <span class="token operator">=</span> torch<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>filters<span class="token punctuation">)</span>  <span class="token comment"># 应用tanh激活函数</span>        gate <span class="token operator">=</span> self<span class="token punctuation">.</span>gate_convs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 执行门控卷积操作</span>        gate <span class="token operator">=</span> torch<span class="token punctuation">.</span>sigmoid<span class="token punctuation">(</span>gate<span class="token punctuation">)</span>  <span class="token comment"># 应用sigmoid激活函数，映射到0，1范围，进行门控</span>        x <span class="token operator">=</span> filters <span class="token operator">*</span> gate  <span class="token comment"># 使用门控机制进行特征调整---张量积，逐元素相乘，抑制噪声</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dropout<span class="token punctuation">,</span> training<span class="token operator">=</span>self<span class="token punctuation">.</span>training<span class="token punctuation">)</span>  <span class="token comment"># 执行dropout操作</span>        s <span class="token operator">=</span> x        s <span class="token operator">=</span> self<span class="token punctuation">.</span>skip_convs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>  <span class="token comment"># 跳跃连接中的卷积操作</span>        skip <span class="token operator">=</span> s <span class="token operator">+</span> skip  <span class="token comment"># 计算跳跃连接的输出</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>residual_convs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 执行残差卷积操作</span>        x <span class="token operator">=</span> x <span class="token operator">+</span> residual<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment"># 添加残差并更新当前块输入</span>    <span class="token comment"># 跳跃连接  负责多层次关联注入</span>    skip <span class="token operator">=</span> self<span class="token punctuation">.</span>skipE<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> skip    x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>skip<span class="token punctuation">)</span>    x_emb <span class="token operator">=</span> x<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span>    x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>end_conv_1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    x <span class="token operator">=</span> self<span class="token punctuation">.</span>end_conv_2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">return</span> x<span class="token punctuation">,</span> x_emb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="STLlama-前向传播"><a href="#STLlama-前向传播" class="headerlink" title="STLlama 前向传播"></a>STLlama 前向传播</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        input_ids<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>LongTensor <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        attention_mask<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        past_key_values<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>List<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        inputs_embeds<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        use_cache<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        output_attentions<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        output_hidden_states<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        st_data_x<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        st_data_y<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        region_start<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>        region_end<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>        return_dict<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Union<span class="token punctuation">[</span>Tuple<span class="token punctuation">,</span> BaseModelOutputWithPast<span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token comment"># HACK: replace back original embeddings for LLaVA pretraining</span>    orig_embeds_params <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token string">'orig_embeds_params'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>    <span class="token comment"># if orig_embeds_params is not None:</span>    <span class="token comment">#     orig_embeds_params = orig_embeds_params[0]</span>    <span class="token comment">#     with torch.no_grad():</span>    <span class="token comment">#         self.get_input_embeddings().weight.data[:-2] = orig_embeds_params[:-2].data</span>    <span class="token comment"># 检查是否有传入的嵌入 inputs_embeds，如果没有则通过 embed_tokens 方法将输入的 input_ids 转换成嵌入表示。</span>    <span class="token keyword">if</span> inputs_embeds <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        inputs_embeds <span class="token operator">=</span> self<span class="token punctuation">.</span>embed_tokens<span class="token punctuation">(</span>input_ids<span class="token punctuation">)</span>    <span class="token comment"># 检查是否需要将多个 st_data_x 和 st_data_y 进行拼接</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>st_data_x<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>        st_data_x <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>st_data_x<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        st_data_y <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>st_data_y<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    st_tower <span class="token operator">=</span> self<span class="token punctuation">.</span>get_st_tower<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 如果 st_tower 不为空，且输入数据的长度不为1或者处于训练模式，同时 st_data_x 也不为空，则进行时空信息的处理。</span>    <span class="token keyword">if</span> st_tower <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>input_ids<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>training<span class="token punctuation">)</span> <span class="token keyword">and</span> st_data_x <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">type</span><span class="token punctuation">(</span>st_data_x<span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token builtin">list</span><span class="token punctuation">:</span>            <span class="token comment"># variable length images</span>            <span class="token comment"># 将 st_data_x 输入到 st_tower 中，得到时空编码的结果 STE_out，同时将 st_data_y 输入到 st_tower 中得到时空编码标签的结果 STE_lbls_out</span>            pre_STE<span class="token punctuation">,</span> STE_out <span class="token operator">=</span> st_tower<span class="token punctuation">(</span>st_data_x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            _<span class="token punctuation">,</span> STE_lbls_out <span class="token operator">=</span> st_tower<span class="token punctuation">(</span>st_data_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> STE_out<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token comment"># 根据指定的 region_start 和 region_end 对 STE_out（时空编码信息） 进行切片得到区域选择输出 region_select_out。</span>                region_select_out <span class="token operator">=</span> STE_out<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>region_end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>bfloat16<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            pre_STE<span class="token punctuation">,</span> STE_out <span class="token operator">=</span> st_tower<span class="token punctuation">(</span>st_data_x<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            _<span class="token punctuation">,</span> STE_lbls_out <span class="token operator">=</span> st_tower<span class="token punctuation">(</span>st_data_y<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            region_select_out <span class="token operator">=</span> STE_out<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>region_end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>bfloat16<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>pre_STE <span class="token operator">=</span> pre_STE        <span class="token comment"># ===========将 region_select_out 经过线性层 st_projector 处理得到投影的结果 st_projector_out。==========</span>        st_projector_out <span class="token operator">=</span> self<span class="token punctuation">.</span>st_projector<span class="token punctuation">(</span>region_select_out<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        new_input_embeds <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># new_stpre_embeds = []</span>        cur_st_idx <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 遍历输入的 input_ids 和对应的 inputs_embeds。</span>        <span class="token keyword">for</span> cur_input_ids<span class="token punctuation">,</span> cur_input_embeds <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>input_ids<span class="token punctuation">,</span> inputs_embeds<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># if st_tower.config.use_st_start_end:</span>            <span class="token comment"># 根据 st_tower 的配置信息，找到对应的起始标记和结束标记位置，然后根据这些位置和时空特征的投影结果，更新输入嵌入表示。</span>            cur_st_features <span class="token operator">=</span> st_projector_out<span class="token punctuation">[</span>cur_st_idx<span class="token punctuation">]</span>            cur_st_features <span class="token operator">=</span> cur_st_features<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>cur_st_features<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment"># 根据时空特征来划分patch</span>            num_patches <span class="token operator">=</span> cur_st_features<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token comment"># 判断开始标记和结束标记数量要一致</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_input_ids <span class="token operator">==</span> st_tower<span class="token punctuation">.</span>config<span class="token punctuation">.</span>st_start_token<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span>                    cur_input_ids <span class="token operator">==</span> st_tower<span class="token punctuation">.</span>config<span class="token punctuation">.</span>st_end_token<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"The number of st start tokens and st end tokens should be the same."</span><span class="token punctuation">)</span>            st_start_tokens <span class="token operator">=</span> torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>cur_input_ids <span class="token operator">==</span> st_tower<span class="token punctuation">.</span>config<span class="token punctuation">.</span>st_start_token<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token comment"># st_end_tokens = torch.where(cur_input_ids == st_tower.config.st_end_token)[0]</span>            <span class="token keyword">if</span> st_start_tokens<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">:</span>   <span class="token comment"># 标记&gt;=3</span>                st_start_token_pos1 <span class="token operator">=</span> st_start_tokens<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                st_start_token_pos2 <span class="token operator">=</span> st_start_tokens<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                st_start_token_pos3 <span class="token operator">=</span> st_start_tokens<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>                self<span class="token punctuation">.</span>st_start_id0 <span class="token operator">=</span> st_start_token_pos1                self<span class="token punctuation">.</span>st_start_id1 <span class="token operator">=</span> st_start_token_pos3                <span class="token keyword">if</span> cur_input_ids<span class="token punctuation">[</span>                    st_start_token_pos1 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> st_tower<span class="token punctuation">.</span>config<span class="token punctuation">.</span>st_end_token<span class="token punctuation">:</span>                    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"The st end token should follow the st start token."</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> orig_embeds_params <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    <span class="token comment"># 根据这些位置和时空特征的投影结果，更新输入嵌入表示（拼接文本embedding张量+时空特征投影结果，只有start到end位置参与梯度更新）</span>                    cur_new_input_embeds <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>cur_input_embeds<span class="token punctuation">[</span><span class="token punctuation">:</span>st_start_token_pos1<span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                      <span class="token comment"># 时空特征前后拼接原始input embed的start与end位置，start之前和end之后的用detach</span>                                                      <span class="token comment"># 创建离断版本 将这些元素从计算图中分离出来，使得它们不参与梯度计算，从而防止对它们的修改影响到之后的反向传播过程</span>                                                      cur_input_embeds<span class="token punctuation">[</span>st_start_token_pos1<span class="token punctuation">:</span>st_start_token_pos1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_st_features<span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos1 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>st_start_token_pos1 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos1 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">:</span>st_start_token_pos2<span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos2<span class="token punctuation">:</span>st_start_token_pos2 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos2 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">:</span>st_start_token_pos3<span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos3<span class="token punctuation">:</span>st_start_token_pos3 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos3 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    cur_new_input_embeds <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>cur_input_embeds<span class="token punctuation">[</span><span class="token punctuation">:</span>st_start_token_pos1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_st_features<span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>st_start_token_pos1 <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                     dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>                cur_st_idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>   <span class="token comment"># 一组标记，流程和上面一样</span>                st_start_token_pos <span class="token operator">=</span> st_start_tokens<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                self<span class="token punctuation">.</span>st_start_id0 <span class="token operator">=</span> st_start_token_pos                num_patches <span class="token operator">=</span> cur_st_features<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                <span class="token keyword">if</span> cur_input_ids<span class="token punctuation">[</span>st_start_token_pos <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> st_tower<span class="token punctuation">.</span>config<span class="token punctuation">.</span>st_end_token<span class="token punctuation">:</span>                    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"The st end token should follow the st start token."</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> orig_embeds_params <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    cur_new_input_embeds <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>cur_input_embeds<span class="token punctuation">[</span><span class="token punctuation">:</span>st_start_token_pos<span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>st_start_token_pos<span class="token punctuation">:</span>st_start_token_pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_st_features<span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>st_start_token_pos <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>                                                      st_start_token_pos <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    cur_new_input_embeds <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>cur_input_embeds<span class="token punctuation">[</span><span class="token punctuation">:</span>st_start_token_pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                      cur_st_features<span class="token punctuation">,</span>                                                      cur_input_embeds<span class="token punctuation">[</span>st_start_token_pos <span class="token operator">+</span> num_patches <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                     dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>                cur_st_idx <span class="token operator">+=</span> <span class="token number">1</span>            new_input_embeds<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_new_input_embeds<span class="token punctuation">)</span>        <span class="token keyword">assert</span> cur_st_idx <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>st_projector_out<span class="token punctuation">)</span>        <span class="token comment"># 输入embedding替换为缝合了时空编码信息的embedding</span>        inputs_embeds <span class="token operator">=</span> torch<span class="token punctuation">.</span>stack<span class="token punctuation">(</span>new_input_embeds<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># 调用llama的前向传播过程，解码输入信息</span>    <span class="token keyword">return</span> <span class="token builtin">super</span><span class="token punctuation">(</span>STLlamaModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>forward<span class="token punctuation">(</span>        input_ids<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> attention_mask<span class="token operator">=</span>attention_mask<span class="token punctuation">,</span> past_key_values<span class="token operator">=</span>past_key_values<span class="token punctuation">,</span>        inputs_embeds<span class="token operator">=</span>inputs_embeds<span class="token punctuation">,</span> use_cache<span class="token operator">=</span>use_cache<span class="token punctuation">,</span>        <span class="token comment"># 隐层也要输出，所以有这个参数</span>        output_attentions<span class="token operator">=</span>output_attentions<span class="token punctuation">,</span> output_hidden_states<span class="token operator">=</span>output_hidden_states<span class="token punctuation">,</span>        return_dict<span class="token operator">=</span>return_dict    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="主体模型-前向传播"><a href="#主体模型-前向传播" class="headerlink" title="主体模型 前向传播"></a>主体模型 前向传播</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 对时空信息的处理，包括时空特征的提取、投影和整合，以及更新输入嵌入表示后的模型正常前向传播过程</span>  <span class="token comment"># 根据分类和回归损失对STLlama的时空相关部分进行梯度更新</span>  <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>          self<span class="token punctuation">,</span>          input_ids<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>LongTensor <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 输入标记的ID</span>          attention_mask<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 注意力遮罩</span>          past_key_values<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>List<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 过去的键值</span>          inputs_embeds<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 输入的嵌入表示</span>          labels<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 标签（用于计算损失）</span>          use_cache<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 是否使用缓存</span>          output_attentions<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 输出注意力权重</span>          output_hidden_states<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 输出隐藏状态</span>          st_data_x<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 时序数据</span>          st_data_y<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 时序数据的标签</span>          <span class="token comment"># x和y要送入STLlama执行时空编码，编码后经过线性层 st_projector 处理得到投影的结果，然后将其与文本嵌入拼接形成新的嵌入，送入大模型</span>          region_start<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment"># 区域开始位置</span>          region_end<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment"># 区域结束位置</span>          return_dict<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token comment"># 是否返回字典形式的输出</span>  <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Union<span class="token punctuation">[</span>Tuple<span class="token punctuation">,</span> CausalLMOutputWithPast<span class="token punctuation">]</span><span class="token punctuation">:</span>      output_attentions <span class="token operator">=</span> output_attentions <span class="token keyword">if</span> output_attentions <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>output_attentions      output_hidden_states <span class="token operator">=</span> <span class="token punctuation">(</span>          output_hidden_states <span class="token keyword">if</span> output_hidden_states <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>output_hidden_states      <span class="token punctuation">)</span>      return_dict <span class="token operator">=</span> return_dict <span class="token keyword">if</span> return_dict <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>use_return_dict      <span class="token comment"># STllama解码器的输出包括(dec_features, layer_state, dec_hidden, dec_attn)</span>      outputs <span class="token operator">=</span> self<span class="token punctuation">.</span>model<span class="token punctuation">(</span>          input_ids<span class="token operator">=</span>input_ids<span class="token punctuation">,</span>          attention_mask<span class="token operator">=</span>attention_mask<span class="token punctuation">,</span>          past_key_values<span class="token operator">=</span>past_key_values<span class="token punctuation">,</span>          inputs_embeds<span class="token operator">=</span>inputs_embeds<span class="token punctuation">,</span>          use_cache<span class="token operator">=</span>use_cache<span class="token punctuation">,</span>          output_attentions<span class="token operator">=</span>output_attentions<span class="token punctuation">,</span>          output_hidden_states<span class="token operator">=</span>output_hidden_states<span class="token punctuation">,</span>          return_dict<span class="token operator">=</span>return_dict<span class="token punctuation">,</span>          st_data_x<span class="token operator">=</span>st_data_x<span class="token punctuation">,</span>          st_data_y<span class="token operator">=</span>st_data_y<span class="token punctuation">,</span>          region_start<span class="token operator">=</span>region_start<span class="token punctuation">,</span>          region_end<span class="token operator">=</span>region_end      <span class="token punctuation">)</span>      feature_nums <span class="token operator">=</span> <span class="token number">2</span>      hidden_states <span class="token operator">=</span> outputs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># STllama解码的隐层</span>      batch_size <span class="token operator">=</span> hidden_states<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token comment"># =========通过自定义的回归层对hidden_state投影及预测部分做回归预测，然后比较和label之间的误差，</span>      <span class="token comment"># 同时融合大模型隐层预测的结果logits的误差，综合回归+分类+文本生成误差，更新梯度===========</span>      <span class="token comment"># 隐层做全连接得到最终st_pre结果</span>      <span class="token keyword">if</span> labels <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>          <span class="token comment"># 从 hidden_states 中切片出start-end对应的部分（分别是待预测序列，预测表征序列），并将其转换成训练表征 st_pre_embs1 和 st_pre_embs2。</span>          <span class="token comment"># 对 st_pre_embs1 和 st_pre_embs2 分别进行线性变换和relu激活函数操作，得到 st_pre_out1 和 st_pre_out2。</span>          st_pre_embs1 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>                         self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id0 <span class="token operator">+</span> feature_nums <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> feature_nums<span class="token punctuation">,</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>          <span class="token comment"># # [4, 1, 2, 4096]--&gt;[4, 1, 2, 128]</span>          st_pre_out1 <span class="token operator">=</span> self<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>st_pred_linear_1<span class="token punctuation">(</span>st_pre_embs1<span class="token punctuation">)</span><span class="token punctuation">)</span>          st_pre_embs2 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>                         self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id1 <span class="token operator">+</span> feature_nums <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> feature_nums<span class="token punctuation">,</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>          <span class="token comment"># # [4, 1, 2, 4096]--&gt;[4, 1, 2, 128]</span>          st_pre_out2 <span class="token operator">=</span> self<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>st_pred_linear_3<span class="token punctuation">(</span>st_pre_embs2<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment"># 将 st_pre_out1 和 st_pre_out2 拼接起来，并经过另一个线性变换得到最终结果 st_pre_final。</span>          <span class="token comment"># # [4, 1, 2, 256]--&gt;[4, 1, 2, 12]</span>          st_pre_final <span class="token operator">=</span> self<span class="token punctuation">.</span>st_pred_linear_2<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>st_pre_out1<span class="token punctuation">,</span> st_pre_out2<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment"># # [4, 1, 2, 12]--&gt;[4, 1, 12, 2]</span>          st_pre_final <span class="token operator">=</span> st_pre_final<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>   <span class="token comment"># 测试，而非训练</span>          self<span class="token punctuation">.</span>st_pre_res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>hidden_states<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment"># 线性层，lm_head将隐层特征映射到词表</span>      logits <span class="token operator">=</span> self<span class="token punctuation">.</span>lm_head<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span>      loss <span class="token operator">=</span> <span class="token boolean">None</span>      <span class="token keyword">if</span> labels <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>  <span class="token comment"># 训练过程</span>          <span class="token comment"># Shift so that tokens &lt; n predict n</span>          shift_logits <span class="token operator">=</span> logits<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span>          shift_labels <span class="token operator">=</span> labels<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment"># Flatten the tokens</span>          loss_fct <span class="token operator">=</span> CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># fct，交叉熵</span>          rec_loss <span class="token operator">=</span> scaler_mae_loss<span class="token punctuation">(</span>scaler<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> mask_value<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>    <span class="token comment">#MAE</span>          bce_loss <span class="token operator">=</span> BCEWithLogitsLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>          shift_logits <span class="token operator">=</span> shift_logits<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>vocab_size<span class="token punctuation">)</span>          shift_labels <span class="token operator">=</span> shift_labels<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>          <span class="token comment"># Enable model/pipeline parallelism</span>          shift_labels <span class="token operator">=</span> shift_labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>shift_logits<span class="token punctuation">.</span>device<span class="token punctuation">)</span>          <span class="token comment"># 处理标签</span>          <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>st_data_y<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>              st_data_y <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>st_data_y<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>              labels_stpre <span class="token operator">=</span> st_data_y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>region_end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">:</span>feature_nums<span class="token punctuation">]</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>                  torch<span class="token punctuation">.</span>bfloat16<span class="token punctuation">)</span>              task_type_all <span class="token operator">=</span> st_data_y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>              labels_stpre <span class="token operator">=</span> st_data_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>region_end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">:</span>feature_nums<span class="token punctuation">]</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>                  torch<span class="token punctuation">.</span>bfloat16<span class="token punctuation">)</span>              task_type_all <span class="token operator">=</span> st_data_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> region_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>          regress_idx_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          classificate_idx_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          regress_result_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          classificate_result_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>              task_type <span class="token operator">=</span> task_type_all<span class="token punctuation">[</span>i<span class="token punctuation">]</span>              <span class="token comment"># classification</span>              <span class="token keyword">if</span> task_type <span class="token operator">==</span> <span class="token number">3</span> <span class="token keyword">or</span> task_type <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>                  classificate_idx_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                  regress_result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st_pre_final<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                  classificate_result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st_pre_final<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span>              <span class="token comment"># regression</span>              <span class="token keyword">else</span><span class="token punctuation">:</span>                  regress_idx_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                  classificate_result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st_pre_final<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                  regress_result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st_pre_final<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span>          regress_result <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>regress_result_list<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>          classificate_result <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>classificate_result_list<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>          <span class="token comment"># 回归损失--MAE</span>          loss_regress <span class="token operator">=</span> rec_loss<span class="token punctuation">(</span>regress_result<span class="token punctuation">,</span> labels_stpre<span class="token punctuation">)</span>          labels_classificate <span class="token operator">=</span> labels_stpre          labels_classificate<span class="token punctuation">[</span>labels_classificate <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>          labels_classificate<span class="token punctuation">[</span>labels_classificate <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>          <span class="token comment"># 分类损失bce</span>          loss_classificate <span class="token operator">=</span> bce_loss<span class="token punctuation">(</span>classificate_result<span class="token punctuation">,</span> labels_classificate<span class="token punctuation">)</span>          <span class="token comment"># 综合损失</span>          loss <span class="token operator">=</span> loss_fct<span class="token punctuation">(</span>shift_logits<span class="token punctuation">,</span> shift_labels<span class="token punctuation">)</span> <span class="token operator">+</span> loss_regress <span class="token operator">+</span> loss_classificate      <span class="token keyword">if</span> <span class="token keyword">not</span> return_dict<span class="token punctuation">:</span>          <span class="token comment"># print('not return dict')</span>          output <span class="token operator">=</span> <span class="token punctuation">(</span>logits<span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token operator">+</span> outputs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>          <span class="token keyword">print</span><span class="token punctuation">(</span>loss<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token punctuation">(</span>loss<span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token operator">+</span> output <span class="token keyword">if</span> loss <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> output      <span class="token keyword">return</span> CausalLMOutputWithPast<span class="token punctuation">(</span>          loss<span class="token operator">=</span>loss<span class="token punctuation">,</span>          logits<span class="token operator">=</span>logits<span class="token punctuation">,</span>          past_key_values<span class="token operator">=</span>outputs<span class="token punctuation">.</span>past_key_values<span class="token punctuation">,</span>          hidden_states<span class="token operator">=</span>outputs<span class="token punctuation">.</span>hidden_states<span class="token punctuation">,</span>          attentions<span class="token operator">=</span>outputs<span class="token punctuation">.</span>attentions<span class="token punctuation">,</span>      <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="评估-1"><a href="#评估-1" class="headerlink" title="评估"></a>评估</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@ray<span class="token punctuation">.</span>remote</span><span class="token punctuation">(</span>num_gpus<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@torch<span class="token punctuation">.</span>inference_mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">eval_model</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> prompt_file<span class="token punctuation">,</span> start_idx<span class="token punctuation">,</span> end_idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># load prompting file</span>    <span class="token comment"># prompt_file = load_prompting_file(args.prompting_file)</span>    <span class="token comment"># Model</span>    disable_torch_init<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># model_name = os.path.expanduser(args.model_name)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'start loading'</span><span class="token punctuation">)</span>    <span class="token comment"># 加载预训练的tokenizer，用于对输入文本进行编码</span>    tokenizer <span class="token operator">=</span> AutoTokenizer<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>args<span class="token punctuation">.</span>model_name<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'finish loading'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'start loading'</span><span class="token punctuation">)</span>    <span class="token comment"># 加载预训练的时空语言模型</span>    model <span class="token operator">=</span> STLlamaForCausalLM<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>args<span class="token punctuation">.</span>model_name<span class="token punctuation">,</span> torch_dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>bfloat16<span class="token punctuation">,</span> use_cache<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                                                  low_cpu_mem_usage<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 设置时空依赖编码器</span>    model<span class="token punctuation">.</span>set_st_tower<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'finish loading'</span><span class="token punctuation">)</span>    <span class="token comment"># 根据模型配置，调整tokenizer的词汇表，添加时空相关的特殊标记。</span>    use_st_start_end <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>config<span class="token punctuation">,</span> <span class="token string">"use_st_start_end"</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>    tokenizer<span class="token punctuation">.</span>add_tokens<span class="token punctuation">(</span><span class="token punctuation">[</span>DEFAULT_ST_PATCH_TOKEN<span class="token punctuation">]</span><span class="token punctuation">,</span> special_tokens<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> use_st_start_end<span class="token punctuation">:</span>        tokenizer<span class="token punctuation">.</span>add_tokens<span class="token punctuation">(</span><span class="token punctuation">[</span>DEFAULT_ST_START_TOKEN<span class="token punctuation">,</span> DEFAULT_ST_END_TOKEN<span class="token punctuation">]</span><span class="token punctuation">,</span> special_tokens<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    st_tower <span class="token operator">=</span> model<span class="token punctuation">.</span>get_model<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_tower    <span class="token comment"># 配置编码器</span>    st_config <span class="token operator">=</span> st_tower<span class="token punctuation">.</span>config    st_config<span class="token punctuation">.</span>st_patch_token <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>convert_tokens_to_ids<span class="token punctuation">(</span><span class="token punctuation">[</span>DEFAULT_ST_PATCH_TOKEN<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 配置中的token使用对应词汇在词表中的id</span>    st_config<span class="token punctuation">.</span>use_st_start_end <span class="token operator">=</span> use_st_start_end    <span class="token keyword">if</span> use_st_start_end<span class="token punctuation">:</span>        st_config<span class="token punctuation">.</span>st_start_token<span class="token punctuation">,</span> st_config<span class="token punctuation">.</span>st_end_token <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>convert_tokens_to_ids<span class="token punctuation">(</span>            <span class="token punctuation">[</span>DEFAULT_ST_START_TOKEN<span class="token punctuation">,</span> DEFAULT_ST_END_TOKEN<span class="token punctuation">]</span><span class="token punctuation">)</span>    res_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'total: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token builtin">len</span><span class="token punctuation">(</span>prompt_file<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>st_data_path<span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>        st_data_all <span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span>    error_i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> idx<span class="token punctuation">,</span> instruct_item <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span>prompt_file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 使用load_st加载时空数据，包括时空标记长度、时空数据x和y的编码信息、时空区域的起始和结束位置等</span>        <span class="token comment"># prompt file对应的instruct item：NYC_taxi.json</span>        <span class="token comment"># st_data：pkl文件，存储已经训练好的时序编码信息</span>        st_dict <span class="token operator">=</span> load_st<span class="token punctuation">(</span>idx<span class="token punctuation">,</span> instruct_item<span class="token punctuation">,</span> st_data_all<span class="token punctuation">)</span>        st_token_len <span class="token operator">=</span> st_dict<span class="token punctuation">[</span><span class="token string">'st_token_len'</span><span class="token punctuation">]</span>        st_data_x <span class="token operator">=</span> st_dict<span class="token punctuation">[</span><span class="token string">'st_data_x'</span><span class="token punctuation">]</span>        st_data_y <span class="token operator">=</span> st_dict<span class="token punctuation">[</span><span class="token string">'st_data_y'</span><span class="token punctuation">]</span>        region_start <span class="token operator">=</span> st_dict<span class="token punctuation">[</span><span class="token string">'region_start'</span><span class="token punctuation">]</span>        region_end <span class="token operator">=</span> st_dict<span class="token punctuation">[</span><span class="token string">'region_end'</span><span class="token punctuation">]</span>        <span class="token comment"># 自然语言问题从instruct_item中提取</span>        qs <span class="token operator">=</span> instruct_item<span class="token punctuation">[</span><span class="token string">"conversations"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"value"</span><span class="token punctuation">]</span>        replace_token <span class="token operator">=</span> DEFAULT_ST_PATCH_TOKEN <span class="token operator">*</span> st_token_len        replace_token <span class="token operator">=</span> DEFAULT_ST_START_TOKEN <span class="token operator">+</span> replace_token <span class="token operator">+</span> DEFAULT_ST_END_TOKEN        qs <span class="token operator">=</span> qs<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>DEFAULT_STHIS_TOKEN<span class="token punctuation">,</span> replace_token<span class="token punctuation">)</span>        qs <span class="token operator">=</span> qs<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>DEFAULT_STPRE_TOKEN<span class="token punctuation">,</span> replace_token<span class="token punctuation">)</span>        <span class="token comment"># if "v1" in args.model_name.lower():</span>        <span class="token comment">#     conv_mode = "stchat_v1"</span>        <span class="token comment"># else:</span>        <span class="token comment">#     raise ValueError('Don\'t support this model')</span>        conv_mode <span class="token operator">=</span> <span class="token string">"stchat_v1"</span>        <span class="token keyword">if</span> args<span class="token punctuation">.</span>conv_mode <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> conv_mode <span class="token operator">!=</span> args<span class="token punctuation">.</span>conv_mode<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[WARNING] the auto inferred conversation mode is {}, while `--conv-mode` is {}, using {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>                conv_mode<span class="token punctuation">,</span> args<span class="token punctuation">.</span>conv_mode<span class="token punctuation">,</span> args<span class="token punctuation">.</span>conv_mode<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            args<span class="token punctuation">.</span>conv_mode <span class="token operator">=</span> conv_mode        conv <span class="token operator">=</span> conv_templates<span class="token punctuation">[</span>args<span class="token punctuation">.</span>conv_mode<span class="token punctuation">]</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        conv<span class="token punctuation">.</span>append_message<span class="token punctuation">(</span>conv<span class="token punctuation">.</span>roles<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> qs<span class="token punctuation">)</span>  <span class="token comment"># 为用户角色添加qs问题</span>        conv<span class="token punctuation">.</span>append_message<span class="token punctuation">(</span>conv<span class="token punctuation">.</span>roles<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>        prompt <span class="token operator">=</span> conv<span class="token punctuation">.</span>get_prompt<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 对prompt编码</span>        inputs <span class="token operator">=</span> tokenizer<span class="token punctuation">(</span><span class="token punctuation">[</span>prompt<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 输入张量</span>        input_ids <span class="token operator">=</span> torch<span class="token punctuation">.</span>as_tensor<span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>input_ids<span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 停用词</span>        stop_str <span class="token operator">=</span> conv<span class="token punctuation">.</span>sep <span class="token keyword">if</span> conv<span class="token punctuation">.</span>sep_style <span class="token operator">!=</span> SeparatorStyle<span class="token punctuation">.</span>TWO <span class="token keyword">else</span> conv<span class="token punctuation">.</span>sep2        keywords <span class="token operator">=</span> <span class="token punctuation">[</span>stop_str<span class="token punctuation">]</span>        stopping_criteria <span class="token operator">=</span> KeywordsStoppingCriteria<span class="token punctuation">(</span>keywords<span class="token punctuation">,</span> tokenizer<span class="token punctuation">,</span> input_ids<span class="token punctuation">)</span>        <span class="token keyword">with</span> torch<span class="token punctuation">.</span>inference_mode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 大模型解码，生成预测文本tokens的id序列</span>            output_ids <span class="token operator">=</span> model<span class="token punctuation">.</span>generate<span class="token punctuation">(</span>                input_ids<span class="token punctuation">,</span>                <span class="token comment"># st_data=st_data_x,</span>                st_data_x<span class="token operator">=</span>st_data_x<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                st_data_y<span class="token operator">=</span>st_data_y<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                region_start<span class="token operator">=</span>region_start<span class="token punctuation">,</span>                region_end<span class="token operator">=</span>region_end<span class="token punctuation">,</span>                do_sample<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                <span class="token comment"># do_sample=False,</span>                <span class="token comment"># temperature=0.2,</span>                temperature<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span>                <span class="token comment"># max_new_tokens=1024,</span>                max_new_tokens<span class="token operator">=</span><span class="token number">256</span><span class="token punctuation">,</span>                stopping_criteria<span class="token operator">=</span><span class="token punctuation">[</span>stopping_criteria<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment"># 找到自定义的special token</span>            start_inx <span class="token operator">=</span> torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>output_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">32001</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            end_inx <span class="token operator">=</span> torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>output_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">32002</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token comment"># 获取隐层状态</span>            hidden_states <span class="token operator">=</span> model<span class="token punctuation">.</span>get_st_pre_res<span class="token punctuation">(</span><span class="token punctuation">)</span>            hidden_states <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>hidden_states<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>            model<span class="token punctuation">.</span>reset_st_pre_res<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 将tokens解码为输出结果</span>            batch_size <span class="token operator">=</span> hidden_states<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            feature_nums <span class="token operator">=</span> <span class="token number">2</span>            st_pre_embs1 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>                           model<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>model<span class="token punctuation">.</span>model<span class="token punctuation">.</span>st_start_id0 <span class="token operator">+</span> feature_nums <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                           <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> feature_nums<span class="token punctuation">,</span> model<span class="token punctuation">.</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>            <span class="token comment"># 通过一个线性层获取结果</span>            st_pre_out1 <span class="token operator">=</span> model<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>model<span class="token punctuation">.</span>st_pred_linear_1<span class="token punctuation">(</span>st_pre_embs1<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> start_inx<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> hidden_states<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> start_inx<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> feature_nums<span class="token punctuation">:</span>                    st_pre_embs2 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> start_inx<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>start_inx<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> feature_nums<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'========error========'</span><span class="token punctuation">)</span>                    error_i <span class="token operator">=</span> error_i <span class="token operator">+</span> <span class="token number">1</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span>error_i<span class="token punctuation">)</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span>hidden_states<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> start_inx<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                    st_pre_embs2 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span>feature_nums<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'========error========'</span><span class="token punctuation">)</span>                error_i <span class="token operator">=</span> error_i <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>error_i<span class="token punctuation">)</span>                st_pre_embs2 <span class="token operator">=</span> hidden_states<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span>feature_nums<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>            st_pre_embs2 <span class="token operator">=</span> st_pre_embs2<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> feature_nums<span class="token punctuation">,</span> model<span class="token punctuation">.</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>            st_pre_out2 <span class="token operator">=</span> model<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>model<span class="token punctuation">.</span>st_pred_linear_3<span class="token punctuation">(</span>st_pre_embs2<span class="token punctuation">)</span><span class="token punctuation">)</span>            st_pre_final <span class="token operator">=</span> model<span class="token punctuation">.</span>st_pred_linear_2<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>st_pre_out1<span class="token punctuation">,</span> st_pre_out2<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            st_pre_final <span class="token operator">=</span> st_pre_final<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>            st_pre_infolow <span class="token operator">=</span> st_pre_final<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>            st_pre_outfolow <span class="token operator">=</span> st_pre_final<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>        x_in<span class="token punctuation">,</span> y_in <span class="token operator">=</span> st_data_x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">:</span>region_end<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> st_data_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">:</span>region_end<span class="token punctuation">,</span>                                                                           <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>        x_out<span class="token punctuation">,</span> y_out <span class="token operator">=</span> st_data_x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">:</span>region_end<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> st_data_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> region_start<span class="token punctuation">:</span>region_end<span class="token punctuation">,</span>                                                                             <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>        input_token_len <span class="token operator">=</span> input_ids<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        n_diff_input_output <span class="token operator">=</span> <span class="token punctuation">(</span>input_ids <span class="token operator">!=</span> output_ids<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span>input_token_len<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> n_diff_input_output <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'[Warning] </span><span class="token interpolation"><span class="token punctuation">{</span>n_diff_input_output<span class="token punctuation">}</span></span><span class="token string"> output_ids are not the same as the input_ids'</span></span><span class="token punctuation">)</span>        <span class="token comment"># outputs = tokenizer.batch_decode(output_ids[:, input_token_len:], skip_special_tokens=True)[0]</span>        outputs <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_decode<span class="token punctuation">(</span>output_ids<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> input_token_len<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> skip_special_tokens<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        outputs <span class="token operator">=</span> outputs<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> outputs<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span>stop_str<span class="token punctuation">)</span><span class="token punctuation">:</span>            outputs <span class="token operator">=</span> outputs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token builtin">len</span><span class="token punctuation">(</span>stop_str<span class="token punctuation">)</span><span class="token punctuation">]</span>        outputs <span class="token operator">=</span> outputs<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        res_data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>            <span class="token punctuation">{</span><span class="token string">"id"</span><span class="token punctuation">:</span> instruct_item<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"res"</span><span class="token punctuation">:</span> outputs<span class="token punctuation">,</span> <span class="token string">"x_in"</span><span class="token punctuation">:</span> x_in<span class="token punctuation">,</span> <span class="token string">"x_out"</span><span class="token punctuation">:</span> x_out<span class="token punctuation">,</span> <span class="token string">"y_in"</span><span class="token punctuation">:</span> y_in<span class="token punctuation">,</span> <span class="token string">"y_out"</span><span class="token punctuation">:</span> y_out<span class="token punctuation">,</span>             <span class="token string">"st_pre_infolow"</span><span class="token punctuation">:</span> st_pre_infolow<span class="token punctuation">,</span> <span class="token string">"st_pre_outfolow"</span><span class="token punctuation">:</span> st_pre_outfolow<span class="token punctuation">}</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>osp<span class="token punctuation">.</span>join<span class="token punctuation">(</span>args<span class="token punctuation">.</span>output_res_path<span class="token punctuation">,</span> <span class="token string">'arxiv_test_res_{}_{}.json'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>start_idx<span class="token punctuation">,</span> end_idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fout<span class="token punctuation">:</span>            json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>res_data<span class="token punctuation">,</span> fout<span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> res_data    <span class="token comment"># with open(args.output_res_path, "w") as fout:</span>    <span class="token comment">#     json.dump(res_data, fout, indent=4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></span>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 时间序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2024/04/26/mysql/"/>
      <url>/2024/04/26/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><img src="/2024/04/26/mysql/image-20240426154008919.png" alt="image-20240426154008919" style="zoom: 80%;"><blockquote><p><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</p><p><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</p><p><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</p><p><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</p></blockquote><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><ul><li><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p></li><li><p>NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p></li><li><p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p></li></ul><img src="/2024/04/26/mysql/sql-nosql-tushi.png" alt="img"><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p><p><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</p><p><strong>可扩展性：</strong> NoSQL 数据库通常被设计为<strong>通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</strong></p><p><strong>高性能：</strong> NoSQL 数据库<strong>针对特定的数据模型和访问模式进行了优化</strong>，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</p><p><strong>强大的功能：</strong> NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</p><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ul><li>关系型数据库（RDB，Relational Database）就是一种<strong>建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</strong>关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</li><li>关系型数据库中，我们的数据都被存放在了各种二维表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</li><li>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</li></ul><p>目前主流的<strong>关系型数据库管理系统</strong>的市场占有率排名如下：</p><img src="/2024/04/26/mysql/image-20240426154125989.png" alt="image-20240426154125989"><ul><li>Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。</li><li>MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。</li><li>SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。</li><li>PostgreSQL：开源免费的中小型数据库。</li><li>DB2：IBM公司的大型收费数据库产品。</li><li>SQLLite：嵌入式的微型数据库。Android内置的数据库以及微信本地的聊天记录存储采用的就是该数据库。</li><li>MariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、另外一个衍生产品，与MySQL数据库有很好的兼容性。</li></ul><h3 id="关系型-vs-非关系型"><a href="#关系型-vs-非关系型" class="headerlink" title="关系型 vs 非关系型"></a>关系型 vs 非关系型</h3><img src="/2024/04/26/mysql/image-20240426163636208.png" alt="image-20240426163636208"><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一<strong>标准</strong> 。</p><p>1). SQL语句可以单行或多行书写，以分号结尾。</p><p>2). SQL语句可以使用空格/缩进来增强语句的可读性。</p><p>3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</p><p>4). 注释：单行注释：– 注释内容 或 # 注释内容多行注释：/* 注释内容 */</p><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL</p><img src="/2024/04/26/mysql/image-20240426170912537.png" alt="image-20240426170912537" style="zoom: 80%;"><h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">--------------数据库操作---------------------</span><span class="token keyword">show</span> <span class="token keyword">databases</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 当前数据库</span><span class="token keyword">create</span> <span class="token keyword">database</span> <span class="token punctuation">[</span> <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token keyword">exists</span> <span class="token punctuation">]</span> 数据库名 <span class="token punctuation">[</span> <span class="token keyword">default</span> <span class="token keyword">charset</span> 字符集 <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token keyword">collate</span> 排序规则 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">database</span> <span class="token punctuation">[</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> <span class="token punctuation">]</span> 数据库名 <span class="token punctuation">;</span><span class="token keyword">use</span> 数据库名 <span class="token punctuation">;</span><span class="token comment">-----------------表操作---------------------</span><span class="token keyword">show</span> <span class="token keyword">tables</span><span class="token punctuation">;</span><span class="token keyword">desc</span> 表名 <span class="token punctuation">;</span> <span class="token comment">#查看表结构</span><span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> 表名 <span class="token punctuation">;</span><span class="token comment"># 查询指定表的建表语句</span><span class="token keyword">create</span> <span class="token keyword">table</span> emp<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token keyword">comment</span> <span class="token string">'编号'</span><span class="token punctuation">,</span>    workno <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'工号'</span><span class="token punctuation">,</span>    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'姓名'</span><span class="token punctuation">,</span>    gender <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'性别'</span><span class="token punctuation">,</span>    age <span class="token keyword">tinyint</span> <span class="token keyword">unsigned</span> <span class="token keyword">comment</span> <span class="token string">'年龄'</span><span class="token punctuation">,</span>    idcard <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'身份证号'</span><span class="token punctuation">,</span>    entrydate <span class="token keyword">date</span> <span class="token keyword">comment</span> <span class="token string">'入职时间'</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'员工表'</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> 字段名 类型 <span class="token punctuation">(</span>长度<span class="token punctuation">)</span> <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 注释 <span class="token punctuation">]</span> <span class="token punctuation">[</span> 约束 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment"># 添加字段</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> emp <span class="token keyword">ADD</span> nickname <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'昵称'</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">MODIFY</span> 字段名 新数据类型 <span class="token punctuation">(</span>长度<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 修改字段类型</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型 <span class="token punctuation">(</span>长度<span class="token punctuation">)</span> <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 注释 <span class="token punctuation">]</span> <span class="token punctuation">[</span> 约束 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> emp CHANGE nickname username <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'昵称'</span><span class="token punctuation">;</span> <span class="token number">1</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> 字段名<span class="token punctuation">;</span> <span class="token comment"># 删除字段</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">RENAME</span> <span class="token keyword">TO</span> 新表名<span class="token punctuation">;</span><span class="token comment"># 修改表名</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> 表名<span class="token punctuation">;</span><span class="token comment"># 删除表</span><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">;</span><span class="token comment"># 删除指定表, 并重新创建表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><table><thead><tr><th>类型</th><th>大小</th><th>有符号(SIGNED)范围</th><th>无符号(UNSIGNED)范围</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1byte</td><td>(-128,127)</td><td>(0,255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2bytes</td><td>(-32768,32767)</td><td>(0,65535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3bytes</td><td>(-8388608,8388607)</td><td>(0,16777215)</td><td>大整数值</td></tr><tr><td>INT/INTEGER</td><td>4bytes</td><td>(-2147483648  2147483647)</td><td>(0,4294967295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8bytes</td><td>(-2^63,2^63-1)</td><td>(0,2^64-1)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4bytes</td><td>(-3.402823466 E+38,  3.402823466351 E+38)</td><td>0和(1.175494351 E-38,3.402823466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8bytes</td><td>(-1.7976931348623157  E+308,  1.7976931348623157  E+308)</td><td>0和  (2.2250738585072014  E-308,  1.7976931348623157  E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td></td><td>依赖于M(精度)和D(标度）的值</td><td>依赖于M(精度)和D(标度)的值</td><td>小数值(精确定 点数)</td></tr></tbody></table><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><img src="/2024/04/26/mysql/image-20240505120222157.png" alt="image-20240505120222157"><p><strong>char是定长字符串</strong>，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char性能更好。</p><h4 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h4><img src="/2024/04/26/mysql/image-20240505124939337.png"><h3 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a>DML 数据操作语言</h3><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token punctuation">(</span>字段名<span class="token number">1</span><span class="token punctuation">,</span> 字段名<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment"># 批量添加</span><span class="token keyword">insert</span> <span class="token keyword">into</span> employee<span class="token punctuation">(</span>id<span class="token punctuation">,</span>workno<span class="token punctuation">,</span>name<span class="token punctuation">,</span>gender<span class="token punctuation">,</span>age<span class="token punctuation">,</span>idcard<span class="token punctuation">,</span>entrydate<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'Itcast'</span><span class="token punctuation">,</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'123456789012345678'</span><span class="token punctuation">,</span><span class="token string">'2000-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> 表名 <span class="token keyword">SET</span> 字段名<span class="token number">1</span> <span class="token operator">=</span> 值<span class="token number">1</span> <span class="token punctuation">,</span> 字段名<span class="token number">2</span> <span class="token operator">=</span> 值<span class="token number">2</span> <span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">[</span> <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token keyword">update</span> employee <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'小昭'</span> <span class="token punctuation">,</span> gender <span class="token operator">=</span> <span class="token string">'女'</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 表名 <span class="token punctuation">[</span> <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token keyword">delete</span> <span class="token keyword">from</span> employee <span class="token keyword">where</span> gender <span class="token operator">=</span> <span class="token string">'女'</span><span class="token punctuation">;</span><span class="token comment"># 删除一条数据</span><span class="token keyword">delete</span> <span class="token keyword">from</span> employee<span class="token punctuation">;</span><span class="token comment"># 删除所有员工数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL 数据查询语言"></a>DQL 数据查询语言</h3><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>字段列表<span class="token keyword">FROM</span>表名列表<span class="token keyword">WHERE</span>条件列表<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>分组字段列表<span class="token keyword">HAVING</span>分组后条件列表<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>排序字段列表<span class="token keyword">LIMIT</span>分页参数<span class="token keyword">SELECT</span> 字段<span class="token number">1</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token keyword">AS</span><span class="token punctuation">)</span> 别名<span class="token number">1</span> <span class="token punctuation">]</span> <span class="token punctuation">,</span> 字段<span class="token number">2</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token keyword">AS</span><span class="token punctuation">)</span> 别名<span class="token number">2</span> <span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> 表名<span class="token punctuation">;</span><span class="token comment"># 别名，as可以省略</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> 字段列表 <span class="token keyword">FROM</span> 表名<span class="token punctuation">;</span><span class="token comment"># 去除重复记录</span><span class="token comment"># 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</span><span class="token keyword">select</span> workaddress<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> address_count <span class="token keyword">from</span> emp <span class="token keyword">where</span> age <span class="token operator">&lt;</span> <span class="token number">45</span> <span class="token keyword">group</span> <span class="token keyword">by</span> workaddress <span class="token keyword">having</span> address_count <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表名 <span class="token keyword">LIMIT</span> 起始索引<span class="token punctuation">,</span> 查询记录数 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>where与having区别</li><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li><li><strong>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</strong></li></ul><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><img src="/2024/04/26/mysql/image-20240505180928668.png" alt="image-20240505180928668" style="zoom:80%;"><h3 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL 数据控制语言"></a>DCL 数据控制语言</h3><p>DCL英文全称是<strong>Data Control Language</strong>(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment"># 查询用户</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 User代表的是访问该数据库的用户名。在MySQL中<strong>需要通过Host和User来唯一标识一个用户。</strong></p><img src="/2024/04/26/mysql/image-20240505181311834.png"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'密码'</span><span class="token punctuation">;</span><span class="token comment"># 创建用户</span><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span> IDENTIFIED <span class="token keyword">WITH</span> mysql_native_password <span class="token keyword">BY</span> <span class="token string">'新密码'</span> <span class="token punctuation">;</span><span class="token comment"># 修改密码</span><span class="token keyword">DROP</span> <span class="token keyword">USER</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span> <span class="token punctuation">;</span><span class="token comment"># 删除用户主机名可以使用 % 通配。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><img src="/2024/04/26/mysql/image-20240505181611707.png" alt="image-20240505181611707" style="zoom: 67%;"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span> <span class="token punctuation">;</span><span class="token comment"># 查询权限</span><span class="token keyword">GRANT</span> 权限列表 <span class="token keyword">ON</span> 数据库名<span class="token punctuation">.</span>表名 <span class="token keyword">TO</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span><span class="token punctuation">;</span><span class="token comment"># 授予权限</span><span class="token keyword">REVOKE</span> 权限列表 <span class="token keyword">ON</span> 数据库名<span class="token punctuation">.</span>表名 <span class="token keyword">FROM</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span><span class="token punctuation">;</span><span class="token comment"># 撤销权限</span><span class="token keyword">show</span> grants <span class="token keyword">for</span> <span class="token string">'heima'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span class="token keyword">grant</span> <span class="token keyword">all</span> <span class="token keyword">on</span> itcast<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">to</span> <span class="token string">'heima'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span class="token comment"># 授予 'heima'@'%' 用户itcast数据库所有表的所有操作权限</span><span class="token keyword">revoke</span> <span class="token keyword">all</span> <span class="token keyword">on</span> itcast<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">'heima'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>多个权限之间，使用逗号分隔</p></li><li><p>授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><img src="/2024/04/26/mysql/image-20240507140710177.png" alt="image-20240507140710177" style="zoom: 67%;"><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><img src="/2024/04/26/mysql/image-20240507141021752.png" alt="image-20240507141021752" style="zoom: 67%;"><p>通过数据库的函数，生成一个六位数的随机验证码。</p><p>思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> lpad<span class="token punctuation">(</span><span class="token function">round</span><span class="token punctuation">(</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000000</span> <span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><img src="/2024/04/26/mysql/image-20240507141208167.png" alt="image-20240507141208167" style="zoom:67%;"><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><img src="/2024/04/26/mysql/image-20240507141452210.png" alt="image-20240507141452210" style="zoom:67%;"><p>需求: 查询emp表的员工姓名和工作地址 (北京/上海 —-&gt; 一线城市 , 其他 —-&gt; 二线城市)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span>    name<span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token keyword">case</span> workaddress <span class="token keyword">when</span> <span class="token string">'北京'</span> <span class="token keyword">then</span> <span class="token string">'一线城市'</span> <span class="token keyword">when</span> <span class="token string">'上海'</span> <span class="token keyword">then</span> <span class="token string">'一线城市'</span> <span class="token keyword">else</span>    <span class="token string">'二线城市'</span> <span class="token keyword">end</span> <span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token string">'工作地址'</span><span class="token keyword">from</span> emp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p><p>目的：保证数据库中数据的正确、有效性和完整性。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><img src="/2024/04/26/mysql/image-20240507143454084.png" alt="image-20240507143454084" style="zoom:80%;"><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><p>示例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tb_user<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">COMMENT</span> <span class="token string">'ID唯一标识'</span><span class="token punctuation">,</span>    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">COMMENT</span> <span class="token string">'姓名'</span> <span class="token punctuation">,</span>    age <span class="token keyword">int</span> <span class="token keyword">check</span> <span class="token punctuation">(</span>age <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> age <span class="token operator">&lt;=</span> <span class="token number">120</span><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'年龄'</span> <span class="token punctuation">,</span>    <span class="token keyword">status</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">'1'</span> <span class="token keyword">COMMENT</span> <span class="token string">'状态'</span><span class="token punctuation">,</span>    gender <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'性别'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/04/26/mysql/image-20240507143712836.png" alt="image-20240507143712836" style="zoom:80%;"><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">(</span>    字段名 数据类型<span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">[</span><span class="token keyword">CONSTRAINT</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>外键名称<span class="token punctuation">]</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>外键字段名<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> 主表 <span class="token punctuation">(</span>主表列名<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> 外键名称 <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>外键字段名<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> 主表 <span class="token punctuation">(</span>主表列名<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> emp <span class="token keyword">add</span> <span class="token keyword">constraint</span> fk_emp_dept_id <span class="token keyword">foreign</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>dept_id<span class="token punctuation">)</span> <span class="token keyword">references</span> dept<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> 外键名称<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/04/26/mysql/image-20240507144123244.png" style="zoom:80%;"><h4 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除/更新行为"></a>删除/更新行为</h4><p>添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行为有以下几种:</p><img src="/2024/04/26/mysql/image-20240507144346915.png" style="zoom:80%;"><p>语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> 外键名称 <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>外键字段<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span>主表名 <span class="token punctuation">(</span>主表字段名<span class="token punctuation">)</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CASCADE</span> <span class="token keyword">ON</span> <span class="token keyword">DELETE</span> <span class="token keyword">CASCADE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>执行多表查询，使用逗号分隔多张表，如： select * from emp , dept;  得到两表的<strong>笛卡尔积组合结果</strong></p><img src="/2024/04/26/mysql/image-20240507145729379.png" style="zoom:80%;"><p>在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。</p><p>select * from emp , dept where emp.dept_id = dept.id;</p><p>这种情况下，由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件没有查询到，也就不会显示在结果中。</p><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>连接查询<ul><li>内连接：相当于查询A、B<strong>交集部分</strong>数据–分为隐式内连接和显示内连接</li><li>外连接：</li><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li><li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 隐式内连接</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token punctuation">,</span> 表<span class="token number">2</span> <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token comment"># 显示内连接</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token punctuation">[</span> <span class="token keyword">INNER</span> <span class="token punctuation">]</span> <span class="token keyword">JOIN</span> 表<span class="token number">2</span> <span class="token keyword">ON</span> 连接条件 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token comment"># eg:</span><span class="token keyword">select</span> emp<span class="token punctuation">.</span>name <span class="token punctuation">,</span> dept<span class="token punctuation">.</span>name <span class="token keyword">from</span> emp <span class="token punctuation">,</span> dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> dept<span class="token punctuation">.</span>id <span class="token punctuation">;</span><span class="token keyword">select</span> e<span class="token punctuation">.</span>name<span class="token punctuation">,</span> d<span class="token punctuation">.</span>name <span class="token keyword">from</span> emp e <span class="token keyword">inner</span> <span class="token keyword">join</span> dept d <span class="token keyword">on</span> e<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token comment"># 左外连接</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token keyword">LEFT</span> <span class="token punctuation">[</span> <span class="token keyword">OUTER</span> <span class="token punctuation">]</span> <span class="token keyword">JOIN</span> 表<span class="token number">2</span> <span class="token keyword">ON</span> 条件 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span> <span class="token comment"># 右外连接</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token keyword">RIGHT</span> <span class="token punctuation">[</span> <span class="token keyword">OUTER</span> <span class="token punctuation">]</span> <span class="token keyword">JOIN</span> 表<span class="token number">2</span> <span class="token keyword">ON</span> 条件 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span> <span class="token comment"># 自连接</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表A 别名A <span class="token keyword">JOIN</span> 表A 别名B <span class="token keyword">ON</span> 条件 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token comment"># eg： 查询员工 及其 所属领导的名字</span><span class="token keyword">select</span> a<span class="token punctuation">.</span>name <span class="token punctuation">,</span> b<span class="token punctuation">.</span>name <span class="token keyword">from</span> emp a <span class="token punctuation">,</span> emp b <span class="token keyword">where</span> a<span class="token punctuation">.</span>managerid <span class="token operator">=</span> b<span class="token punctuation">.</span>id<span class="token punctuation">;</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表A <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">UNION</span> <span class="token punctuation">[</span> <span class="token keyword">ALL</span> <span class="token punctuation">]</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表B <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>对于联合查询的多张表的<strong>列数必须保持一致，字段类型也需要保持一致</strong>。</p></li><li><p><strong>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</strong></p></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> column1 <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> column1 <span class="token keyword">FROM</span> t2 <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。</p><p>eg：查询在 “方东白” 入职之后的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> entrydate <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">select</span> entrydate <span class="token keyword">from</span> emp <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'方东白'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p><img src="/2024/04/26/mysql/image-20240507152223041.png" style="zoom:80%;"><p> eg：查询比 财务部 所有人工资都高的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> salary <span class="token operator">&gt;</span> <span class="token keyword">all</span> <span class="token punctuation">(</span> <span class="token keyword">select</span> salary <span class="token keyword">from</span> emp <span class="token keyword">where</span> dept_id <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> dept <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'财务部'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p><p>eg：查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> <span class="token punctuation">(</span>salary<span class="token punctuation">,</span>managerid<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> salary<span class="token punctuation">,</span> managerid <span class="token keyword">from</span> emp<span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'张无忌'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>子查询返回的结果是多行多列，这种子查询称为表子查询。</p><p>eg：查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> <span class="token punctuation">(</span>job<span class="token punctuation">,</span>salary<span class="token punctuation">)</span> <span class="token operator">in</span> <span class="token punctuation">(</span> <span class="token keyword">select</span> job<span class="token punctuation">,</span> salary <span class="token keyword">from</span> emp <span class="token keyword">where</span> name <span class="token operator">=</span><span class="token string">'鹿杖客'</span> <span class="token operator">or</span> name <span class="token operator">=</span> <span class="token string">'宋远桥'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>eg：查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> e<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> entrydate <span class="token operator">&gt;</span> <span class="token string">'2006-01-01'</span><span class="token punctuation">)</span> e <span class="token keyword">left</span><span class="token keyword">join</span> dept d <span class="token keyword">on</span> e<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> d<span class="token punctuation">.</span>id <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务 是一组操作的集合，它是一个不可分割的工作单位</strong>，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>我们只需要在业务逻辑执行之前开启事务，执行完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。</p><h3 id="控制事务"><a href="#控制事务" class="headerlink" title="控制事务"></a>控制事务</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 设置事务提交方式</span><span class="token keyword">SELECT</span> @<span class="token variable">@autocommit</span> <span class="token punctuation">;</span><span class="token keyword">SET</span> @<span class="token variable">@autocommit</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span><span class="token comment"># 开启事务</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span> 或 <span class="token keyword">BEGIN</span> <span class="token punctuation">;</span><span class="token comment"># 提交事务</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token comment"># 回滚事务</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p><p>上述就是事务的四大特性，简称ACID。<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的。</strong></p><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><h4 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="脏读（Dirty read）"></a>脏读（Dirty read）</h4><p> 赃读：一个事务读到另外一个事务还没有提交的数据。（A写数据，没提交就被B读）</p><blockquote><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那<strong>第二个事务读取到的就是脏数</strong>据，这也就是脏读的由来。</p></blockquote><img src="https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading-C1rL9lNt.png" alt="脏读" style="zoom:80%;"><h4 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="丢失修改（Lost to modify）"></a>丢失修改（Lost to modify）</h4><p>（AB都读数据，然后同时写，造成写覆盖）</p><blockquote><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p></blockquote><img src="https://javaguide.cn/assets/concurrency-consistency-issues-missing-modifications-D4pIxvwj.png" alt="丢失修改" style="zoom:80%;"><h4 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="不可重复读（Unrepeatable read）"></a>不可重复读（Unrepeatable read）</h4><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。（B在一个事务内多次读数据，A在这个区间写数据，导致B读到不同数据）</p><blockquote><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p></blockquote><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-unrepeatable-read-RYuQTZvh.png" alt="不可重复读" style="zoom:80%;"><h4 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="幻读（Phantom read）"></a>幻读（Phantom read）</h4><p> 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。</p><p>（B在一个事务内多次读数据，A在这个区间内新增数据，导致B前后读到新增的数据）</p><blockquote><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p></blockquote><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-phantom-read-D-ETycCp.png" alt="幻读" style="zoom:80%;"><ul><li><strong>不可重复读的重点是内容修改或者记录减少</strong>比如多次读取一条记录发现其中某些记录的值被修改；</li><li><strong>幻读的重点在于记录新增</strong>比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是<strong>解决幻读和不可重复读的方案不一样</strong>。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种</p><ul><li><p><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p></li><li><p><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p></li><li><p><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p></li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 查看事务隔离级别</span><span class="token keyword">SELECT</span> @<span class="token variable">@TRANSACTION_ISOLATION</span><span class="token punctuation">;</span><span class="token comment"># 设置事务隔离级别  事务隔离级别越高，数据越安全，但是性能越低。</span><span class="token keyword">SET</span> <span class="token punctuation">[</span> <span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span> <span class="token punctuation">]</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> { <span class="token keyword">READ</span> <span class="token keyword">UNCOMMITTED</span> <span class="token operator">|</span><span class="token keyword">READ</span> <span class="token keyword">COMMITTED</span> <span class="token operator">|</span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span> <span class="token operator">|</span> <span class="token keyword">SERIALIZABLE</span> }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><img src="/2024/04/26/mysql/体系结构.jpg" style="zoom:80%;"><p><strong>1). 连接层</strong></p><p>最上层是一些<strong>客户端和链接服务</strong>，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于<strong>连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了<strong>线程池</strong>的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p><strong>2). 服务层</strong></p><p>第二层架构主要完成大多数的<strong>核心服务功能</strong>，如<strong>SQL接口</strong>，并完成<strong>缓存的查询，SQL的分析和优化，部分内置函数的执行</strong>。所有跨存储引擎的功能也在这一层实现，如 <strong>过程、函数</strong>等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p><strong>3). 引擎层</strong></p><p>存储引擎层， <strong>存储引擎真正的负责了MySQL中数据的存储和提取</strong>，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的<strong>索引是在存储引擎层实现</strong>的。</p><p><strong>4). 存储层</strong></p><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)<strong>存储在文件系统</strong>之上，并完成<strong>与存储引擎的交互</strong>。</p><p>存储引擎架构：</p><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，<strong>插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h3 id="存储引擎介绍"><a href="#存储引擎介绍" class="headerlink" title="存储引擎介绍"></a>存储引擎介绍</h3><p><strong>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。</strong>存储引擎是<strong>基于表的</strong>，而不是基于库的，所以存储引擎也可被称为<strong>表类型</strong>。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎(InnoDB)。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> engines<span class="token punctuation">;</span><span class="token comment"># 查询当前数据库支持的存储引擎</span><span class="token comment"># 建表时指定存储引擎</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">(</span>字段<span class="token number">1</span> 字段<span class="token number">1</span>类型 <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 字段<span class="token number">1</span>注释 <span class="token punctuation">]</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>字段n 字段n类型 <span class="token punctuation">[</span><span class="token keyword">COMMENT</span> 字段n注释 <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span> <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 表注释 <span class="token punctuation">]</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</p><ul><li>DML操作遵循ACID模型，支持<strong>事务</strong>；InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</li><li><strong>行级锁，提高并发访问性能；</strong>– InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li><li>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code>。</li></ul><p>文件：xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p><h5 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h5><img src="/2024/04/26/mysql/image-20240507165406280.png"><ul><li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是<strong>表空间文件</strong>，在表空间中可以包含多个Segment段。</li><li>段 : 表空间是由各个段组成的， 常见的段有<strong>数据段、索引段、回滚段</strong>等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</li><li>区 : 区是表空间的<strong>单元结构</strong>，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</li><li>页 : 页是组成区的最小单元，<strong>页也是InnoDB 存储引擎磁盘管理的最小单元</strong>，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行 : InnoDB 存储引擎是面向行的，也就是说<strong>数据是按行进行存放的</strong>，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。</li></ul><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>MyISAM是MySQL早期的默认存储引擎。<strong>不支持事务，不支持外键；支持表锁，不支持行锁。最大的缺陷就是崩溃后无法安全恢复。</strong></p><p>xxx.sdi：存储表结构信息xxx.MYD: 存储数据xxx.MYI: 存储索引</p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作临时表或缓存使用。</p><p>内存存放； hash索引（默认）</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><img src="/2024/04/26/mysql/image-20240507171837044.png" alt="image-20240507171837044" style="zoom:80%;"><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用<strong>对事务的完整性有比较高的要求，在并发条件下要求数据的一致性</strong>，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li><li>MyISAM ： 如果应用是<strong>以读操作和插入操作为主</strong>，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于<strong>临时表及缓存</strong>。MEMORY的缺陷就是<strong>对表的大小有限制，太大的表无法缓存在内存</strong>中，而且无法保障数据的安全性。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着<strong>满足特定查找算法</strong>的数据结构，这些数据结构<strong>以某种方式引用（指向）数据</strong>， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><img src="/2024/04/26/mysql/image-20240507172545744.png" alt="image-20240507172545744" style="zoom:80%;"><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><img src="/2024/04/26/mysql/image-20240507172740796.png" style="zoom:80%;"><p>不同的存储引擎对于索引结构的支持情况：</p><img src="/2024/04/26/mysql/image-20240507173002960.png" style="zoom:80%;"><p>我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li><p>顺序插入时，会形成一个链表，查询性能大大降低。</p></li><li><p>大数据量情况下，层级较深，检索速度慢。</p></li></ul><p>此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树。但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：大数据量情况下，层级较深，检索速度慢。</p><p>在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree。在详解B+Tree之前，先来介绍一下B-Tree。</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>B-Tree，B树是一种<strong>多路平衡查找树</strong>，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：</p><img src="/2024/04/26/mysql/image-20240507222040839.png"><p>插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。</p><img src="/2024/04/26/mysql/image-20240507223005789.png" style="zoom:80%;"><p>特点：</p><ul><li><p>5阶的B树，每一个节点最多存储4个key，对应5个指针。</p></li><li><p>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</p></li><li><p>在B树中，非叶子节点和叶子节点都会存放数据。</p></li></ul><p>一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：</p><ul><li>根结点至少有两个子女；</li><li>每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1；</li><li>除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ &lt;= k &lt;= m ；</li><li>所有的叶子结点都位于同一层。</li></ul><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p><img src="/2024/04/26/mysql/image-20240507223154029.png" alt="image-20240507223154029" style="zoom:80%;"><p>与B树对比：</p><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;<strong>B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</strong></li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 <strong>B+树的范围查询，只需要对链表进行遍历即可。</strong></li></ul><p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p><p>MySQL中优化之后的B+Tree：在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p><img src="/2024/04/26/mysql/image-20240507235942534.png"><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p><blockquote><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其<strong>数据文件本身就是索引文件</strong>。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></blockquote><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><img src="/2024/04/26/mysql/image-20240508002143227.png"><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p>A. Hash索引只能用于对等比较(=，in)，<strong>不支持范围查询（between，&gt;，&lt; ，…）</strong></p><p>B. <strong>无法利用索引完成排序操作</strong></p><p>C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p><blockquote><p>MySQL 的 InnoDB 存储引擎不直接支持常规的哈希索引，但是，InnoDB 存储引擎中存在一种特殊的“自适应哈希索引”（Adaptive Hash Index），自适应哈希索引并不是传统意义上的纯哈希索引，而是结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的每个哈希桶实际上是一个小型的 B+Tree 结构。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。</p></blockquote><p><strong>为什么InnoDB存储引擎选择使用B+tree索引结构?</strong></p><p>A. 相对于二叉树，层级更少，搜索效率高；</p><p>B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致<strong>一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</strong></p><p>C. 相对Hash索引，B+tree支持范围匹配及排序操作；</p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><h4 id="按照数据结构维度划分"><a href="#按照数据结构维度划分" class="headerlink" title="按照数据结构维度划分"></a>按照数据结构维度划分</h4><ul><li>BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</li><li>哈希索引：类似键值对的形式，一次即可定位。</li><li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><h4 id="按照底层存储方式角度划分"><a href="#按照底层存储方式角度划分" class="headerlink" title="按照底层存储方式角度划分"></a>按照底层存储方式角度划分</h4><ul><li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，<strong>InnoDB 中的主键索引就属于聚簇索引。</strong></li><li>聚集索引选取规则:<ul><li>如果存在主键，主键索引就是聚集索引。如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ul></li><li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，索引结构的叶子节点关联的是对应的主键。<strong>二级索引(辅助索引)就属于非聚簇索引</strong>。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。<ul><li>聚集索引的叶子节点下挂的是这一行的数据 。</li><li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li></ul></li></ul><p>接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。</p><img src="/2024/04/26/mysql/image-20240508163939785.png" alt="image-20240508163939785" style="zoom:80%;"><ul><li>由于是根据name字段进行查询，所以先根据name=’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</li><li>最终拿到这一行的数据，直接返回即可。</li></ul><blockquote><p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p></blockquote><h4 id="按照应用维度划分"><a href="#按照应用维度划分" class="headerlink" title="按照应用维度划分"></a>按照应用维度划分</h4><ul><li>主键索引：针对于表中主键创建的索引。默认自动创建。加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li>普通索引：仅加速查询。快速定位特定数据。又叫常规索引</li><li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。避免同一个表中某数据列中的值重复，唯一索引可以有多个。</li><li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><h4 id="MySQL-8-x-中实现的索引新特性"><a href="#MySQL-8-x-中实现的索引新特性" class="headerlink" title="MySQL 8.x 中实现的索引新特性"></a>MySQL 8.x 中实现的索引新特性</h4><ul><li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是<strong>在索引中可以包含函数或者表达式。</strong></li></ul><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建（唯一/全文）索引</span><span class="token keyword">CREATE</span> <span class="token punctuation">[</span> <span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token punctuation">]</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>index_col_name<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment"># 查看索引</span><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> table_name <span class="token punctuation">;</span><span class="token comment"># 删除索引</span><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- session 是查看当前会话 ;</span><span class="token comment">-- global 是查询全局数据 ;</span><span class="token keyword">SHOW</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">STATUS</span> <span class="token operator">LIKE</span> <span class="token string">'Com_______'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/04/26/mysql/image-20240508165617129.png"><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p><p>不建议开启，因为开启会带来一定的性能影响</p><img src="/2024/04/26/mysql/image-20240508165730121.png"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 开启慢查询日志，只对当前数据库生效，并且重启数据库后失效</span><span class="token keyword">set</span> <span class="token keyword">global</span> slow_query_log <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment"># 设置阈值</span><span class="token keyword">set</span> long_query_time <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment"># 得到返回记录集最多的10 个SQL</span><span class="token punctuation">.</span><span class="token operator">/</span>mysqldumpslow <span class="token operator">-</span>s r <span class="token operator">-</span>t <span class="token number">10</span> <span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>mysql<span class="token operator">/</span>logs<span class="token operator">/</span>slow<span class="token punctuation">.</span>log<span class="token comment"># 得到访问次数最多的10 个SQL</span><span class="token punctuation">.</span><span class="token operator">/</span>mysqldumpslow <span class="token operator">-</span>s c <span class="token operator">-</span>t <span class="token number">10</span> <span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>mysql<span class="token operator">/</span>logs<span class="token operator">/</span>slow<span class="token punctuation">.</span>log<span class="token comment"># 得到按照时间排序的前10 条里面含有左连接的查询语句</span><span class="token punctuation">.</span><span class="token operator">/</span>mysqldumpslow <span class="token operator">-</span>s t <span class="token operator">-</span>t <span class="token number">10</span> <span class="token operator">-</span>g <span class="token string">"left join"</span> <span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>mysql<span class="token operator">/</span>logs<span class="token operator">/</span>slow<span class="token punctuation">.</span>log<span class="token comment"># 另外建议在使用这些命令时结合| 和more 使用，否则有可能出现爆屏情况</span><span class="token punctuation">.</span><span class="token operator">/</span>mysqldumpslow <span class="token operator">-</span>s r <span class="token operator">-</span>t <span class="token number">10</span> <span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>mysql<span class="token operator">/</span>logs<span class="token operator">/</span>slow<span class="token punctuation">.</span>log <span class="token operator">|</span> more<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 直接在select语句之前加上关键字 explain / desc</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2024/04/26/mysql/image-20240508214501370.png" style="zoom:80%;"><p>Explain 执行计划中各个字段的含义:</p><img src="/2024/04/26/mysql/image-20240508214613100.png" style="zoom:80%;"><h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。<strong>最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，或者中间使用了范围查询，索引将会部分失效(后面的字段索引失效)。</strong></p><p>索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p><p>举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子。</p><img src="/2024/04/26/mysql/image-20240508214330139.png" alt="image-20240508214330139" style="zoom:67%;"><p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因<strong>为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引。</strong></p><h5 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h5><ul><li>建立联合索引（a，b，c）时，实际相当于建立了（a），（b），（c）三个索引</li><li>全值匹配时，无论顺序abc还是cba，在查询时都使用到了联合索引。这是因为MySQL中有查询优化器explain，所以sql语句中字段的顺序不需要和联合索引定义的字段顺序相同，查询优化器会判断纠正这条SQL语句以什么样的顺序执行效率高，最后才能生成真正的执行计划。<ul><li>explain对这种查询的结果显示为type=ref，表示非唯一性索引扫描，返回匹配某个单独值的所有行。</li><li>注意这种情况下，最左侧必须是<strong>等值匹配</strong>，因为只有左边等值情况下，右边条件才有序</li></ul></li><li>匹配最左边的1个或多个列时，也是ref，能够利用联合索引。</li><li>如果中间跳过几个字段，那么只能索引到有序的位置为止。</li><li>如果匹配到b或者bc这种条件（跳过最左边），explain也显示用了abc，<strong>但type是index</strong><ul><li>index：这种类型表示是<strong>mysql会对整个该索引进行扫描</strong>。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引</li><li>它虽然使用了联合索引，但是它是对整个索引树进行了扫描，正好匹配到该索引，与最左匹配原则无关，一般只要是某联合索引的一部分，但又不遵循最左匹配原则时，都可能会采用index类型的方式扫描，但它的效率远不如最左匹配原则的查询效率高</li></ul></li></ul><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ul><li><strong>索引列运算</strong>：不要在索引列上进行运算操作， 索引将失效。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#  当根据phone字段进行等值匹配查询时, 索引生效。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">'17799990015'</span><span class="token punctuation">;</span><span class="token comment">#  当根据phone字段进行函数运算操作之后，索引失效。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> substring<span class="token punctuation">(</span>phone<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">'15'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>字符串不加引号</strong>：字符串类型字段使用时，不加引号，索引将失效。（如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。）</li></ul><img src="/2024/04/26/mysql/image-20240508221636173.png"><ul><li><strong>模糊查询</strong>：如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">'软件%'</span><span class="token punctuation">;</span><span class="token comment">#  下面的失效</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">'%工程'</span><span class="token punctuation">;</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">'%工%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>or连接条件</strong>：用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 由于age没有索引，所以即使id、phone有索引，索引也会失效。当or连接的条件，左右两侧字段都有索引时，索引才会生效。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">'17799990017'</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>数据分布影响</strong>：如果MySQL评估使用索引比全表更慢，则不使用索引。</li></ul><blockquote><p>MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，<strong>如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</strong></p></blockquote><h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">use</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">'软件工程'</span><span class="token punctuation">;</span><span class="token comment"># ignore index ： 忽略指定的索引。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">ignore</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">'软件工程'</span><span class="token punctuation">;</span><span class="token comment"># force index ： 强制使用索引。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">'软件工程'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ <strong>覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</strong></p><blockquote><p>在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 <strong>如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了</strong>，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。</p></blockquote><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。****</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">index</span> idx_xxxx <span class="token keyword">on</span> table_name<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment"># 为tb_user表的email字段，建立长度为5的前缀索引。</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_email_5 <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>email<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>前缀长度</strong>：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><pre class="line-numbers language-none"><code class="language-none">select count(distinct email) / count(*) from tb_user ;# 前缀为5情况下索引选择性select count(distinct substring(email,1,5)) / count(*) from tb_user ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/04/26/mysql/image-20240509162814392.png" style="zoom:80%;"><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p>1). 针对于数据量较大，且查询比较频繁的表建立索引。</p><p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p><p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p><p>6). 要控制索引的数量，索引并不是多多益善，<strong>索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</strong></p><p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>如果我们需要一次性往数据库表中<strong>插入多条记录</strong>，可以从以下三个方面进行优化。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方案1，批量插入</span><span class="token keyword">Insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 方案2，手动控制事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token comment"># 方案3，主键顺序插入，性能要高于乱序插入</span>主键乱序插入 : <span class="token number">8</span> <span class="token number">1</span> <span class="token number">9</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">15</span> <span class="token number">89</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">3</span>主键顺序插入 : <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">15</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">89</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h4><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。</p><img src="/2024/04/26/mysql/image-20240510111007454.png"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</span><span class="token comment">-- 客户端连接服务端时，加上参数 -–local-infile</span>mysql –<span class="token operator">-</span><span class="token keyword">local</span><span class="token operator">-</span><span class="token keyword">infile</span> <span class="token operator">-</span>u root <span class="token operator">-</span>p<span class="token comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><span class="token keyword">set</span> <span class="token keyword">global</span> local_infile <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">-- 执行load指令将准备好的数据，加载到表结构中</span><span class="token keyword">load</span> <span class="token keyword">data</span> <span class="token keyword">local</span> <span class="token keyword">infile</span> <span class="token string">'/root/sql1.log'</span> <span class="token keyword">into</span> <span class="token keyword">table</span> tb_user <span class="token keyword">fields</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">','</span> <span class="token keyword">lines</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p><strong>数据组织方式</strong>：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接。</p><h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p><p>主键顺序插入时，直接从磁盘中申请页，逐个写入即可。乱序插入时，假如1#，2#页已经写满，存放如下数据。</p><img src="/2024/04/26/mysql/image-20240510112438937.png"><p>此时插入id=50的记录时，</p><img src="/2024/04/26/mysql/image-20240510112619060.png" style="zoom:80%;"><p>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。</p><h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><p>目前表中已有数据的索引结构(叶子节点)如下</p><img src="/2024/04/26/mysql/image-20240510112833127.png"><img src="/2024/04/26/mysql/image-20240510112916942.png" style="zoom:80%;"><img src="/2024/04/26/mysql/image-20240510113018365.png" alt="image-20240510113018365" style="zoom:80%;"><p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p><h4 id="索引设计优化"><a href="#索引设计优化" class="headerlink" title="索引设计优化"></a>索引设计优化</h4><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><p>MySQL的排序，有两种方式：</p><p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后<strong>在排序缓冲区sort buffer中完成排序操作</strong>，所有<strong>不是通过索引直接返回排序结果的排序都叫 FileSort 排序</strong>。</p><p>Using index : 通过<strong>有序索引顺序扫描直接返回有序数据</strong>，这种情况即为 using index，不需要额外排序，操作效率高。</p><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。</p><p><strong>order by优化原则:</strong></p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。</p><p>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p><p>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</p><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><p>A. 在分组操作时，可以通过索引来提高效率。</p><p>B. 分组操作时，索引的使用也是满足最左前缀法则的。</p><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><img src="/2024/04/26/mysql/image-20240510114353842.png"><p>当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p>优化思路: 一般分页查询时，通过创建 <strong>覆盖索引</strong> 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_sku t <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> tb_sku <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">2000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> a <span class="token keyword">where</span> t<span class="token punctuation">.</span>id <span class="token operator">=</span> a<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p><p>InnoDB 引擎就麻烦了，它执行 count(<em>) 的时候，*<em>需要把数据一行一行地从引擎里面读出来，然后累积计数。</em></em></p><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：<strong>自己计数(可以借助于redis这样的数据库进行</strong>,但是如果是带条件的count又比较麻烦了)。</p><img src="/2024/04/26/mysql/image-20240510114710602.png" style="zoom:80%;"><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，所以尽量使用 count(*)。</p><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</strong></p><p>例如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</span><span class="token keyword">update</span> course <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'javaEE'</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> <span class="token comment"># 当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低。</span><span class="token keyword">update</span> course <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'SpringBoot'</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'PHP'</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="视图、存储过程、触发器"><a href="#视图、存储过程、触发器" class="headerlink" title="视图、存储过程、触发器"></a>视图、存储过程、触发器</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图（View）是一种<strong>虚拟存在</strong>的表。视图中的数据并不在数据库中实际存在，<strong>行和列数据来自定义视图的查询中使用的表</strong>，并且是在使用视图时<strong>动态生成</strong>的。</p><p>通俗的讲，视图只保存了查询的<strong>SQL逻辑</strong>，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建</span><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token operator">OR</span> <span class="token keyword">REPLACE</span><span class="token punctuation">]</span> <span class="token keyword">VIEW</span> 视图名称<span class="token punctuation">[</span><span class="token punctuation">(</span>列名列表<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token keyword">SELECT</span>语句 <span class="token punctuation">[</span> <span class="token keyword">WITH</span> <span class="token punctuation">[</span><span class="token keyword">CASCADED</span> <span class="token operator">|</span> <span class="token keyword">LOCAL</span> <span class="token punctuation">]</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span> <span class="token punctuation">]</span><span class="token comment"># 查询</span>查看创建视图语句：<span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> 视图名称<span class="token punctuation">;</span>查看视图数据：<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 视图名称 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token comment"># 修改</span>方式一：<span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token operator">OR</span> <span class="token keyword">REPLACE</span><span class="token punctuation">]</span> <span class="token keyword">VIEW</span> 视图名称<span class="token punctuation">[</span><span class="token punctuation">(</span>列名列表<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token keyword">SELECT</span>语句 <span class="token punctuation">[</span> <span class="token keyword">WITH</span> <span class="token punctuation">[</span> <span class="token keyword">CASCADED</span> <span class="token operator">|</span> <span class="token keyword">LOCAL</span> <span class="token punctuation">]</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span> <span class="token punctuation">]</span>方式二：<span class="token keyword">ALTER</span> <span class="token keyword">VIEW</span> 视图名称<span class="token punctuation">[</span><span class="token punctuation">(</span>列名列表<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token keyword">SELECT</span>语句 <span class="token punctuation">[</span> <span class="token keyword">WITH</span> <span class="token punctuation">[</span> <span class="token keyword">CASCADED</span> <span class="token operator">|</span> <span class="token keyword">LOCAL</span> <span class="token punctuation">]</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span> <span class="token punctuation">]</span><span class="token comment"># 删除</span><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> 视图名称 <span class="token punctuation">[</span><span class="token punctuation">,</span>视图名称<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h4><p>1). 简单</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。<strong>那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</strong></p><p>2). 安全</p><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只<strong>能查询和修改他们所能见到的数据</strong></p><p>3). 数据独立</p><p>视图可帮助用户<strong>屏蔽真实表结构变化带来的影响</strong>。</p><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程是<strong>事先经过编译并存储在数据库中的一段 SQL 语句的集合</strong>，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是<strong>数据库 SQL 语言层面的代码封装与重用。</strong></p><ul><li><p>封装，复用 —————-&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p></li><li><p>可以接收参数，也可以返回数据 ——–&gt; 再存储过程中，可以传递参数，也可以接收返回值。</p></li><li><p><strong>减少网络交互</strong>，效率提升 ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> 存储过程名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> 参数列表 <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token comment">-- SQL语句</span><span class="token keyword">END</span> <span class="token punctuation">;</span><span class="token comment"># 调用</span><span class="token keyword">CALL</span> 名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> 参数 <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 查看</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>ROUTINES <span class="token keyword">WHERE</span> ROUTINE_SCHEMA <span class="token operator">=</span> <span class="token string">'xxx'</span><span class="token punctuation">;</span> <span class="token comment">-- 查询指定数据库的存储过程及状态信息</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> 存储过程名称 <span class="token punctuation">;</span> <span class="token comment">-- 查询某个存储过程的定义</span><span class="token comment"># 删除</span><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> 存储过程名称<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p><p><strong>系统变量</strong> 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token punctuation">[</span> <span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span> <span class="token punctuation">]</span> VARIABLES <span class="token punctuation">;</span> <span class="token comment">-- 查看所有系统变量</span><span class="token keyword">SHOW</span> <span class="token punctuation">[</span> <span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span> <span class="token punctuation">]</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'......'</span><span class="token punctuation">;</span> <span class="token comment">-- 可以通过LIKE模糊匹配方式查找变量</span><span class="token keyword">SELECT</span> @@<span class="token punctuation">[</span><span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span><span class="token punctuation">]</span> 系统变量名<span class="token punctuation">;</span> <span class="token comment">-- 查看指定变量的值</span><span class="token keyword">SET</span> <span class="token punctuation">[</span> <span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span> <span class="token punctuation">]</span> 系统变量名 <span class="token operator">=</span> 值 <span class="token punctuation">;</span>  <span class="token comment">-- 设置系统变量，如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。</span><span class="token keyword">SET</span> @@<span class="token punctuation">[</span><span class="token keyword">SESSION</span> <span class="token operator">|</span> <span class="token keyword">GLOBAL</span><span class="token punctuation">]</span>系统变量名 <span class="token operator">=</span> 值 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>用户定义变量</strong> 是用户根据需要自己定义的变量，<strong>用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以</strong>。其作用域为当前连接。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 赋值 方式1</span><span class="token keyword">SET</span> <span class="token variable">@var_name</span> <span class="token operator">=</span> expr <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token variable">@var_name</span> <span class="token operator">=</span> expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token keyword">SET</span> <span class="token variable">@var_name</span> :<span class="token operator">=</span> expr <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token variable">@var_name</span> :<span class="token operator">=</span> expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token comment"># 方式2</span><span class="token keyword">SELECT</span> <span class="token variable">@var_name</span> :<span class="token operator">=</span> expr <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token variable">@var_name</span> :<span class="token operator">=</span> expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span class="token keyword">SELECT</span> 字段名 <span class="token keyword">INTO</span> <span class="token variable">@var_name</span> <span class="token keyword">FROM</span> 表名<span class="token punctuation">;</span><span class="token comment"># 使用</span><span class="token keyword">SELECT</span> <span class="token variable">@var_name</span> <span class="token punctuation">;</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>局部变量</strong> 是根据需要定义的在局部生效的变量，访问之前，<strong>需要DECLARE声明</strong>。可用作存储过程内的<strong>局部变量和输入参数</strong>，局部变量的范围是在其内声明的BEGIN … END块。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> 变量名 变量类型 <span class="token punctuation">[</span><span class="token keyword">DEFAULT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span>  <span class="token comment">-- 变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</span><span class="token keyword">SET</span> 变量名 <span class="token operator">=</span> 值 <span class="token punctuation">;</span><span class="token keyword">SET</span> 变量名 :<span class="token operator">=</span> 值 <span class="token punctuation">;</span><span class="token keyword">SELECT</span> 字段名 <span class="token keyword">INTO</span> 变量名 <span class="token keyword">FROM</span> 表名 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="if案例"><a href="#if案例" class="headerlink" title="if案例"></a>if案例</h4><p>根据定义的分数score变量，判定当前分数对应的分数等级。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">procedure</span> p3<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> score <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">58</span><span class="token punctuation">;</span>    <span class="token keyword">declare</span> result <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> score <span class="token operator">&gt;=</span> <span class="token number">85</span> <span class="token keyword">then</span>    <span class="token keyword">set</span> result :<span class="token operator">=</span> <span class="token string">'优秀'</span><span class="token punctuation">;</span>    <span class="token keyword">elseif</span> score <span class="token operator">&gt;=</span> <span class="token number">60</span> <span class="token keyword">then</span>    <span class="token keyword">set</span> result :<span class="token operator">=</span> <span class="token string">'及格'</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token keyword">set</span> result :<span class="token operator">=</span> <span class="token string">'不及格'</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span>    <span class="token keyword">select</span> result<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token keyword">call</span> p3<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>IN ：该类参数作为输入，也就是需要调用时传入值 默认</p><p>OUT ：该类参数作为输出，也就是该参数可以作为返回值</p><p>INOUT ：既可以作为输入参数，也可以作为输出参数</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> 存储过程名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token operator">IN</span><span class="token operator">/</span><span class="token keyword">OUT</span><span class="token operator">/</span><span class="token keyword">INOUT</span> 参数名 参数类型 <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token comment">-- SQL语句</span><span class="token keyword">END</span> <span class="token punctuation">;</span><span class="token comment"># 案例</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> p4<span class="token punctuation">(</span><span class="token operator">in</span> score <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">out</span> result <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">begin</span><span class="token keyword">if</span> score xxxx<span class="token keyword">end</span><span class="token punctuation">;</span><span class="token comment">-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明</span><span class="token keyword">call</span> p4<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token variable">@result</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token variable">@result</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，</span>执行statement_list2， 否则就执行 statement_list<span class="token keyword">CASE</span> case_value    <span class="token keyword">WHEN</span> when_value1 <span class="token keyword">THEN</span> statement_list1    <span class="token punctuation">[</span> <span class="token keyword">WHEN</span> when_value2 <span class="token keyword">THEN</span> statement_list2<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">[</span> <span class="token keyword">ELSE</span> statement_list <span class="token punctuation">]</span><span class="token keyword">END</span> <span class="token keyword">CASE</span><span class="token punctuation">;</span><span class="token comment">-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list</span><span class="token keyword">CASE</span>    <span class="token keyword">WHEN</span> search_condition1 <span class="token keyword">THEN</span> statement_list1    <span class="token punctuation">[</span><span class="token keyword">WHEN</span> search_condition2 <span class="token keyword">THEN</span> statement_list2<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">[</span><span class="token keyword">ELSE</span> statement_list<span class="token punctuation">]</span><span class="token keyword">END</span> <span class="token keyword">CASE</span><span class="token punctuation">;</span><span class="token comment">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span><span class="token keyword">WHILE</span> 条件 <span class="token keyword">DO</span><span class="token keyword">SQL</span>逻辑<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span><span class="token comment">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><span class="token keyword">REPEAT</span>    <span class="token keyword">SQL</span>逻辑<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    UNTIL 条件<span class="token keyword">END</span> <span class="token keyword">REPEAT</span><span class="token punctuation">;</span><span class="token punctuation">[</span>begin_label:<span class="token punctuation">]</span> <span class="token keyword">LOOP</span>    <span class="token keyword">SQL</span>逻辑<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">END</span> <span class="token keyword">LOOP</span> <span class="token punctuation">[</span>end_label<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">LEAVE</span> label<span class="token punctuation">;</span> <span class="token comment">-- 退出指定标记的循环体</span><span class="token keyword">ITERATE</span> label<span class="token punctuation">;</span> <span class="token comment">-- 直接进入下一次循环</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> 游标名称 <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> 查询语句 <span class="token punctuation">;</span><span class="token keyword">OPEN</span> 游标名称 <span class="token punctuation">;</span> <span class="token comment">-- 打开游标</span><span class="token keyword">FETCH</span> 游标名称 <span class="token keyword">INTO</span> 变量 <span class="token punctuation">[</span><span class="token punctuation">,</span> 变量 <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token comment">-- 获取游标记录</span><span class="token keyword">CLOSE</span> 游标名称 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h4><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> handler_action <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> condition_value <span class="token punctuation">[</span><span class="token punctuation">,</span> condition_value<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> statement <span class="token punctuation">;</span>handler_action 的取值：    <span class="token keyword">CONTINUE</span>: 继续执行当前程序    <span class="token keyword">EXIT</span>: 终止执行当前程序condition_value 的取值：    SQLSTATE sqlstate_value: 状态码，如 <span class="token number">02000</span>    SQLWARNING: 所有以<span class="token number">01</span>开头的SQLSTATE代码的简写    <span class="token operator">NOT</span> FOUND: 所有以<span class="token number">02</span>开头的SQLSTATE代码的简写    SQLEXCEPTION: 所有没有被SQLWARNING 或 <span class="token operator">NOT</span> FOUND捕获的SQLSTATE代码的简写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> 存储函数名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> 参数列表 <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">RETURNS</span> <span class="token keyword">type</span> <span class="token punctuation">[</span>characteristic <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token keyword">BEGIN</span>    <span class="token comment">-- SQL语句</span>    <span class="token keyword">RETURN</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>characteristic说明：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li></ul><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是与表有关的数据库对象，指<strong>在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合</strong>。触发器的这种特性可以协助应用在数据库端确保<strong>数据的完整性, 日志记录 , 数据校验</strong>等操作 。</p><p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><img src="/2024/04/26/mysql/image-20240510163048010.png" style="zoom:67%;"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建触发器</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_nameBEFORE<span class="token operator">/</span><span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span><span class="token operator">/</span><span class="token keyword">UPDATE</span><span class="token operator">/</span><span class="token keyword">DELETE</span><span class="token keyword">ON</span> tbl_name <span class="token keyword">FOR EACH ROW</span> <span class="token comment">-- 行级触发器</span><span class="token keyword">BEGIN</span>trigger_stmt <span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span class="token keyword">SHOW</span> TRIGGERS <span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token punctuation">[</span>schema_name<span class="token punctuation">.</span><span class="token punctuation">]</span>trigger_name <span class="token punctuation">;</span> <span class="token comment">-- 如果没有指定 schema_name，默认为当前数据库 。</span><span class="token comment"># 案例：通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加,修改 , 删除 ;</span><span class="token keyword">create</span> <span class="token keyword">trigger</span> tb_user_insert_trigger <span class="token keyword">after</span> <span class="token keyword">insert</span> <span class="token keyword">on</span> tb_user <span class="token keyword">for each row</span><span class="token keyword">begin</span>    <span class="token keyword">insert</span> <span class="token keyword">into</span> user_logs<span class="token punctuation">(</span>id<span class="token punctuation">,</span> operation<span class="token punctuation">,</span> operate_time<span class="token punctuation">,</span> operate_id<span class="token punctuation">,</span> operate_params<span class="token punctuation">)</span>    <span class="token keyword">VALUES</span>    <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'insert'</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> new<span class="token punctuation">.</span>id<span class="token punctuation">,</span> concat<span class="token punctuation">(</span><span class="token string">'插入的数据内容为:    id='</span><span class="token punctuation">,</span>new<span class="token punctuation">.</span>id<span class="token punctuation">,</span><span class="token string">',name='</span><span class="token punctuation">,</span>new<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">', phone='</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> <span class="token string">', email='</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token string">',    profession='</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>profession<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token comment"># 修改数据 的触发器</span><span class="token keyword">create</span> <span class="token keyword">trigger</span> tb_user_update_trigger <span class="token keyword">after</span> <span class="token keyword">update</span> <span class="token keyword">on</span> tb_user <span class="token keyword">for each row</span><span class="token keyword">begin</span>    <span class="token keyword">insert</span> <span class="token keyword">into</span> user_logs<span class="token punctuation">(</span>id<span class="token punctuation">,</span> operation<span class="token punctuation">,</span> operate_time<span class="token punctuation">,</span> operate_id<span class="token punctuation">,</span> operate_params<span class="token punctuation">)</span>    <span class="token keyword">VALUES</span>    <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'update'</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> new<span class="token punctuation">.</span>id<span class="token punctuation">,</span>    concat<span class="token punctuation">(</span><span class="token string">'更新之前的数据: id='</span><span class="token punctuation">,</span>old<span class="token punctuation">.</span>id<span class="token punctuation">,</span><span class="token string">',name='</span><span class="token punctuation">,</span>old<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">', phone='</span><span class="token punctuation">,</span>    old<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> <span class="token string">', email='</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token string">', profession='</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span>profession<span class="token punctuation">,</span>    <span class="token string">' | 更新之后的数据: id='</span><span class="token punctuation">,</span>new<span class="token punctuation">.</span>id<span class="token punctuation">,</span><span class="token string">',name='</span><span class="token punctuation">,</span>new<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">', phone='</span><span class="token punctuation">,</span>    NEW<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> <span class="token string">', email='</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token string">', profession='</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>profession<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token comment"># 删除</span><span class="token keyword">create</span> <span class="token keyword">trigger</span> tb_user_delete_trigger <span class="token keyword">after</span> <span class="token keyword">delete</span> <span class="token keyword">on</span> tb_user <span class="token keyword">for each row</span><span class="token keyword">begin</span>    <span class="token keyword">insert</span> <span class="token keyword">into</span> user_logs<span class="token punctuation">(</span>id<span class="token punctuation">,</span> operation<span class="token punctuation">,</span> operate_time<span class="token punctuation">,</span> operate_id<span class="token punctuation">,</span> operate_params<span class="token punctuation">)</span>    <span class="token keyword">VALUES</span>    <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'delete'</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span>id<span class="token punctuation">,</span>    concat<span class="token punctuation">(</span><span class="token string">'删除之前的数据: id='</span><span class="token punctuation">,</span>old<span class="token punctuation">.</span>id<span class="token punctuation">,</span><span class="token string">',name='</span><span class="token punctuation">,</span>old<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">', phone='</span><span class="token punctuation">,</span>    old<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> <span class="token string">', email='</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token string">', profession='</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span>profession<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="锁"><a href="#锁" class="headerlink" title="锁***"></a>锁***</h2><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong>在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何<strong>保证数据并发访问的一致性、有效性</strong>是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><ul><li><p><strong>全局锁</strong>：锁定数据库中的所有表。全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。其典型的使用场景是<strong>做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性</strong>。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span> <span class="token punctuation">;</span><span class="token comment">-- 加全局锁</span>mysqldump <span class="token operator">-</span>uroot –p1234 itcast <span class="token operator">&gt;</span> itcast<span class="token punctuation">.</span><span class="token keyword">sql</span><span class="token comment">-- 数据备份</span><span class="token keyword">unlock</span> <span class="token keyword">tables</span> <span class="token punctuation">;</span><span class="token comment">-- 释放锁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump <span class="token comment">--single-transaction -uroot –p123456 itcast &gt; itcast.sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><blockquote><p>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且<strong>由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作</strong>。</p><p>因为在可重复读的隔离级别下，<strong>即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View</strong>，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p><p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会<strong>在备份数据库之前先开启事务</strong>。这种方法只适用于<strong>支持「可重复读隔离级别的事务」</strong>的存储引擎。</p><p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p><p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p></blockquote><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><ul><li><p><strong>表级锁</strong>：每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>表级锁主要分为：表锁，元数据锁，意向锁</p></li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>对于表锁，分为两类：<strong>表共享读锁（read lock）</strong>–只阻塞写，<strong>表独占写锁（write lock）</strong>–阻塞读写</p><p>语法：<strong>加锁：lock tables 表名… read/write。</strong><strong>释放锁：unlock tables</strong> / 客户端断开连接 。</p><p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p><h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>meta data lock , 元数据锁，简写MDL。</p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性。</strong></p><p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，<strong>某一张表涉及到未提交的事务时，是不能够修改这张表的表结构</strong>的。在MySQL5.5中引入了MDL，<strong>当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</strong></p><p>常见的SQL操作时，所添加的元数据锁：</p><img src="/2024/04/26/mysql/image-20240510171058496.png" style="zoom:80%;"><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p><blockquote><p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p></blockquote><p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL <strong>写锁等待，会阻塞后续该表的所有 CRUD 操作。</strong></p><p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>为了避免DML在执行时，加的<strong>行锁与表锁的冲突</strong>，在InnoDB中引入了意向锁，<strong>使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</strong></p><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢：</p><p>1.首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁</p><p>2.当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会<strong>从第一行数据，检查到最后一行数据，效率较低。</strong></p><p>有了意向锁之后 :</p><p>1.客户端一，在执行DML操作时，会对涉及的行<strong>加行锁</strong>，同时也会对<strong>该表</strong>加上<strong>意向锁</strong>。</p><p>2.而其他客户端，在对这张表加表锁的时候，会<strong>根据该表上所加的意向锁来判定是否可以成功加表锁</strong>，而不用逐行判断行锁情况了。</p><p>分类：</p><ul><li><p><strong>意向共享锁(IS):</strong> 由语句<strong>select … lock in share mode</strong>添加 。 与 <strong>表锁共享锁 (read)兼容</strong>，与<strong>表锁排他锁</strong>(write)互斥。</p></li><li><p><strong>意向排他锁(IX):</strong> 由insert、update、delete、select…<strong>for update</strong>添加 。与<strong>表锁共享锁(read)及排他锁(write)都互斥</strong>，<strong>意向锁之间不会互斥。</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//先在表上加上意向共享锁，然后对读取的记录加共享锁</span><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span><span class="token comment">//先表上加上意向独占锁，然后对读取的记录加独占锁</span><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。</strong>（也就是说，意向锁只用于处理行锁与表锁冲突的情况）</p><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p></blockquote><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> object_schema<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span>lock_mode<span class="token punctuation">,</span>lock_data <span class="token keyword">from</span> performance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><ul><li><strong>行级锁</strong>：每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中</li></ul><p>InnoDB的数据是基于索引组织的，<strong>行锁是通过对索引上的索引项加锁来实现的</strong>，而不是对记录加的锁。对于行级锁，主要分为以下三类：（行锁感觉叫记录锁更清晰）</p><img src="/2024/04/26/mysql/image-20240510173950346.png" style="zoom:80%;"><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p></li><li><p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p></li></ul><p>共享锁和共享锁兼容，其他情况（共享与排他，排他与排他）不兼容。</p><p>普通的 select 语句是不会对记录加锁的，因为它属于<strong>快照读</strong>。如果要在查询时对记录加行锁，可以使用下面这两个方式（lock in share mode和for update，前面意向锁也有提到，这个语句会先加意向锁再加S/X锁），这种<strong>查询会加锁</strong>的语句称为<strong>锁定读</strong>。</p><img src="/2024/04/26/mysql/image-20240511095420544.png" style="zoom:80%;"><blockquote><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。</p></blockquote><p>示例：</p><img src="/2024/04/26/mysql/image-20240511110015133.png"><p>在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？原因就是因为此时，客户端一，<strong>根据name字段进行更新时，name字段是没有索引的，如果没有索引，此时行锁会升级为表锁</strong>(因为行锁是对索引项加的锁，而name没有索引)。</p><h4 id="间隙锁-临键锁"><a href="#间隙锁-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h4><p>Gap Lock 称为间隙锁，只存在于</p><p>可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><blockquote><p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以<strong>同时持有包含共同间隙范围的间隙锁</strong>，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。</p></blockquote><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><blockquote><p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p></blockquote><ul><li><p>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</p><img src="/2024/04/26/mysql/image-20240511110551714.png"></li><li><p>索引上的等值查询(<strong>非唯一普通索引</strong>)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</p><p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引<strong>查询值为18的数据，并加上共享锁</strong>，我们是只锁定18这一行就可以了吗？ 并不是，因为是<strong>非唯一索引，这个结构中可能有多个18的存在</strong>，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会<strong>对18加临键锁，并对29之前的间隙加锁。</strong></p><img src="/2024/04/26/mysql/image-20240511110923868.png" alt="image-20240511110923868" style="zoom:80%;"><img src="/2024/04/26/mysql/image-20240511111206605.png"><p><strong>间隙锁（X,GAP），行锁（X,REC_NOT_GAP），临键锁（X）</strong></p></li><li><p>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p><p>查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：[19]，(19,25]，(25,+∞]</p><p>所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。</p><img src="/2024/04/26/mysql/image-20240511111948747.png"></li></ul><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/gap%E9%94%81.drawio.png" alt="img"></p><p>当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个<strong>插入意向锁</strong>，然后将锁的状态设置为<strong>等待状态</strong>（PS：MySQL 加锁时，是先<strong>生成锁结构，然后设置锁的状态</strong>，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p><p>如果说间隙锁锁住的是一个区间，那么<strong>「插入意向锁」锁住的就是一个点</strong>。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p><p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员MySQL：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?vd_source=8f6745987f6d9c4a333570852e433d6c">https://www.bilibili.com/video/BV1Kr4y1i7ru/?vd_source=8f6745987f6d9c4a333570852e433d6c</a></p><p>JavaGuide：<a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></p><p>最左前缀匹配原则：<a href="https://blog.csdn.net/yuanchangliang/article/details/107798724">https://blog.csdn.net/yuanchangliang/article/details/107798724</a></p><p>小林coding：<a href="https://xiaolincoding.com/mysql/lock/mysql_lock.html">https://xiaolincoding.com/mysql/lock/mysql_lock.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2024/04/26/jdbc/"/>
      <url>/2024/04/26/jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>JDBC（Java Database Connectivity）是Java语言中用于与数据库通信的一种API，它允许Java应用程序通过标准的数据库访问方法与各种关系型数据库进行交互，例如MySQL、Oracle、SQL Server等。</li><li>JDBC为访问不同的数据库提供了统一的接口，使开发人员能够编写Java程序以执行SQL查询、更新数据库记录。为使用者屏蔽了细节问题。</li></ul><p>本质：</p><ul><li>官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包。<strong>（数据库驱动提供JDBC的实现类）</strong></li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</li></ul><p>优点：</p><ul><li><strong>跨数据库兼容性</strong>：各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发。可随时替换底层数据库，访问数据库的Java代码基本不变。</li><li><strong>安全性</strong>：JDBC提供了一种安全的数据库访问机制，可以防止SQL注入等安全问题。通过使用预编译语句和参数化查询等技术，可以有效地防止恶意用户对数据库进行攻击。</li></ul><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//1. 注册驱动</span>        <span class="token comment">// Class.forName("com.mysql.jdbc.Driver");</span>        <span class="token comment">//2. 获取连接</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://127.0.0.1:3306/db1"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">"1234"</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3. 定义sql</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"update account set money = 2000 where id = 1"</span><span class="token punctuation">;</span>        <span class="token comment">//4. 获取执行sql的对象 Statement</span>        <span class="token class-name">Statement</span> stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5. 执行sql</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//受影响的行数</span>        <span class="token comment">//6. 处理结果</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//7. 释放资源</span>        stmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><p>DriverManager（驱动管理类）作用：</p><ul><li>注册驱动</li></ul><img src="/2024/04/26/jdbc/registerDriver.png" alt="driver"><p>我们使用的注册驱动代码为</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为MySQL提供的Driver类源码调用了DriverManager.registerDriver。</p><img src="/2024/04/26/jdbc/driver.png" alt="driver" style="zoom:67%;"><p>在该类中的静态代码块中已经执行了 <code>DriverManager</code> 对象的 <code>registerDriver()</code> 方法进行驱动的注册了，那么我们只需要加载 <code>Driver</code> 类，该静态代码块就会执行。而<code>Class.forName("com.mysql.jdbc.Driver");</code> 就可以加载 <code>Driver</code> 类。</p><blockquote><p>==提示：==</p><ul><li>MySQL 5之后的驱动包，可以省略注册驱动的步骤</li><li>自动加载jar包中META-INF/services/java.sql.Driver文件中的驱动类</li></ul></blockquote><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>Connection（数据库连接对象）作用：获取执行 SQL 的对象；管理事务</p><h4 id="获取执行对象"><a href="#获取执行对象" class="headerlink" title="获取执行对象"></a>获取执行对象</h4><p>普通执行SQL对象–statement</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//3. 定义sql</span>String <span class="token keyword">sql</span> <span class="token operator">=</span> <span class="token string">"update account set money = 3000 where id = 1"</span><span class="token punctuation">;</span><span class="token comment">//4. 获取执行sql的对象 Statement</span>Statement stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span>createStatement<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 执行sql</span><span class="token keyword">int</span> count <span class="token operator">=</span> stmt<span class="token punctuation">.</span>executeUpdate<span class="token punctuation">(</span><span class="token keyword">sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>预编译SQL的执行SQL对象：防止SQL注入</p><ul><li><p>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p></li><li><p>例如普通statement如果使用字符串拼接构造SQL  <code>String sql = "select * from stu where name='" + name + "'";</code>  在name中传入<code>"lucy" or name="郭麒麟"</code>，此时就会改变原有的SQL，查询到两条语句。也就是SQL注入漏洞</p></li><li><p>可以使用<code>PreparedStatement</code>来实现数据库操作，它的特点是：使用占位符<code>?</code>表示SQL语句中的参数，通过<code>set</code>方法为SQL语句传入参数</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">public</span> static void queryPrepare<span class="token punctuation">(</span>String name<span class="token punctuation">)</span> throws SQLException {    <span class="token comment">// 预编译SQL，SQL语句中的参数值，使用？占位符替代</span>    ptmt <span class="token operator">=</span> conn<span class="token punctuation">.</span>prepareStatement<span class="token punctuation">(</span><span class="token string">"select * from stu where name=?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ptmt<span class="token punctuation">.</span>setString<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 打印预编译后的SQL语句</span>    System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span>println<span class="token punctuation">(</span>ptmt<span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用这个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。</span>    rs <span class="token operator">=</span> ptmt<span class="token punctuation">.</span>executeQuery<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token keyword">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> {        StringBuilder sb <span class="token operator">=</span> new StringBuilder<span class="token punctuation">(</span><span class="token string">"[id="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rs<span class="token punctuation">.</span>getLong<span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", name="</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span>getString<span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", age="</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span>getInt<span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", class_id="</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span>getLong<span class="token punctuation">(</span><span class="token string">"class_id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span>println<span class="token punctuation">(</span>sb<span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>==小结：==</p><ul><li>在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li><li>执行时就不用再进行这些步骤了，速度更快</li><li>如果sql模板一样，则只需要进行一次检查、编译</li></ul></blockquote><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><p>MySQL事务管理的操作：</p><ul><li>开启事务 ： BEGIN; 或者 START TRANSACTION;</li><li>提交事务 ： COMMIT;</li><li>回滚事务 ： ROLLBACK;</li></ul><p>Connection接口中定义了3个对应的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// ============开启事务==========</span>    conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//5. 执行sql</span>    <span class="token keyword">int</span> count1 <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//受影响的行数</span>    <span class="token comment">//6. 处理结果</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//5. 执行sql</span>    <span class="token keyword">int</span> count2 <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//受影响的行数</span>    <span class="token comment">//6. 处理结果</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ============提交事务==========</span>    <span class="token comment">//程序运行到此处，说明没有出现任何问题，则需求提交事务</span>    conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// ============回滚事务==========</span>    <span class="token comment">//程序在出现异常时会执行到这个地方，此时就需要回滚事务</span>    conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p></li><li><p>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</p></li><li><p>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li><p>好处</p><ul><li>资源重用：在需要时分配和回收资源</li><li>降低连接的建立和关闭开销，提升系统响应速度</li><li>限制并发连接数，便于管理和维护，避免数据库连接遗漏</li></ul></li></ul><p><strong>其他八股见Java基础数据库连接池部分</strong></p><p>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。</p><p>而数据库使用了数据库连接池后，就能达到Connection对象的复用，如下图</p><img src="/2024/04/26/jdbc/数据库连接池.png" alt="数据库连接池" style="zoom:80%;"><p>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。</p><h3 id="Driud连接池"><a href="#Driud连接池" class="headerlink" title="Driud连接池"></a>Driud连接池</h3><p>Druid（德鲁伊）连接池是阿里巴巴开源的数据库连接池项目。使用步骤：</p><blockquote><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件</li><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ul></blockquote><p>现在通过代码实现，首先需要先将druid的jar包放到项目下的lib下并添加为库文件</p><img src="/2024/04/26/jdbc/Driud导入.png" alt="image-20210725212911980" style="zoom:80%;"><p>项目结构如下：</p><img src="/2024/04/26/jdbc/Driud结构.png" alt="image-20210725213210091" style="zoom:80%;"><p>编写配置文件如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">driverClassName</span><span class="token punctuation">=</span><span class="token value attr-value">com.mysql.jdbc.Driver</span><span class="token key attr-name">url</span><span class="token punctuation">=</span><span class="token value attr-value">jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true</span><span class="token key attr-name">username</span><span class="token punctuation">=</span><span class="token value attr-value">root</span><span class="token key attr-name">password</span><span class="token punctuation">=</span><span class="token value attr-value">1234</span><span class="token comment"># 初始化连接数量</span><span class="token key attr-name">initialSize</span><span class="token punctuation">=</span><span class="token value attr-value">5</span><span class="token comment"># 最大连接数</span><span class="token key attr-name">maxActive</span><span class="token punctuation">=</span><span class="token value attr-value">10</span><span class="token comment"># 最大等待时间</span><span class="token key attr-name">maxWait</span><span class="token punctuation">=</span><span class="token value attr-value">3000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用druid的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DruidDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//3. 加载配置文件</span>        <span class="token class-name">Properties</span> prop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        prop<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"jdbc-demo/src/druid.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4. 获取连接池对象</span>        <span class="token class-name">DataSource</span> dataSource <span class="token operator">=</span> <span class="token class-name">DruidDataSourceFactory</span><span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5. 获取数据库连接 Connection</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取到了连接后就可以继续做其他操作了</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>Java持久层框架是在Java语言中用于与数据库交互的重要工具。它们提供了一种简便的方式来管理数据的持久性。在Java开发过程中，持久层框架可以大大简化数据访问的过程，并且提供了一些额外的功能，如事务管理和缓存机制。</p><ul><li>Hibernate是一个持久层的ORM的框架。允许开发者将Java类和数据库表之间进行映射，使得开发者可以直接操作Java对象，而不用关心底层数据库的细节</li><li>javaBean - config.xml –数据库(三者映射)</li><li>Hibernate 能够自动生成 SQL 语句并自动执行，实现对数据库进行操作，整个过程完全不需要人工干预，大大降低了开发成本。</li></ul><p><strong>Hibernate的优点：</strong></p><ol><li>简化JDBC的编程.</li><li>修改了实体类，不需要修改源代码.</li><li>轻量级的框架.</li><li>支持lazy，可以让你的数据只在需要的时候被加载</li><li>提供HQL（Hibernate Query Language），可以完全把查询映射到模型</li></ol><img src="/2024/04/26/jdbc/hibernate.png" alt="img" style="zoom:80%;"><p>流程说明:首先创建Configuration类的实例，并通过它来读取并解析配置文件hibernate.cfg.xml。然后创建SessionFactory读取解析映射文件信息，并将Configuration对象中的所有配置信息拷贝到SessionFactory内存(一级缓存级别)中。接下来，打开Session，让SessionFactory提供连接，并开启一个事务，之后创建对象，向对象中添加数据，通过session.save()方法完成向数据库中保存数据的操作。最后提交事务，并关闭资源。</p><p><strong>缺点：</strong></p><ol><li><strong>性能问题：</strong> 在大规模数据操作和复杂查询时，Hibernate的性能可能不如手动编写的SQL语句高效，需要开发者针对具体情况进行优化。</li><li><strong>学习成本：</strong> 对于初学者来说，学习和掌握Hibernate框架需要一定的时间和精力，尤其是理解ORM的概念和工作原理。</li><li><strong>对于特定场景的限制：</strong>hibernate将数据库与开发者隔离了，开发者不需要关注数据库是Oracle还是MySQL，hibernate来帮你生成查询的sql语句，但在某些特定场景下可能无法满足需求，需要开发者考虑是否需要自定义实现或者选择其他技术。</li></ol><img src="/2024/04/26/jdbc/hibernate缺点.png" alt="image-20240427153359661" style="zoom: 67%;"><h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><p>JPA，全称是：Java PersistenceAPI。是SUN公司推出的一套<strong>基于ORM的规范</strong>。hibernate框架中提供了JPA的实现（但是，JPA规范的实现仅仅是Hibernate的一部分）。JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。JPA框架中支持大数据集、事务、并发等容器级事务。</p><p>Spring Data JPA为Java Persistence API（JPA）提供了实现。它简化了通过JPA访问数据库的开发工作，提供了很多CRUD的快捷操作，还提供了如分页、排序、复杂查询、自定义查询（JPQL）等功能，Spring Data JPA底层也是依赖于Hibernate来实现的，Spring Data JPA拥有标准化、简单易用、面向对象等优势，并且Spring将EntityManager 的创建与销毁、事务管理等代码抽取出来，并由Spring统一进行管理。</p><h3 id="JPA搭建"><a href="#JPA搭建" class="headerlink" title="JPA搭建"></a>JPA搭建</h3><p>maven依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>springboot配置</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">spring</span><span class="token punctuation">:</span><span class="token key attr-name">  application</span><span class="token punctuation">:</span><span class="token comment">    #应用名称</span><span class="token key attr-name">    name</span><span class="token punctuation">:</span> <span class="token value attr-value">spring-data-jpa</span><span class="token key attr-name">  datasource</span><span class="token punctuation">:</span><span class="token comment">    #你的数据库密码</span><span class="token key attr-name">    password</span><span class="token punctuation">:</span> <span class="token value attr-value">123456</span><span class="token comment">    #你的数据库地址</span><span class="token key attr-name">    url</span><span class="token punctuation">:</span> <span class="token value attr-value">jdbc:mysql://localhost:3306/spring_test?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</span><span class="token comment">    #数据库用户名</span><span class="token key attr-name">    username</span><span class="token punctuation">:</span> <span class="token value attr-value">root</span><span class="token comment">    #数据库驱动名称</span><span class="token key attr-name">    driver-class-name</span><span class="token punctuation">:</span> <span class="token value attr-value">com.mysql.cj.jdbc.Driver #配置MySQL的驱动程序类</span><span class="token comment">    #指定连接池类型</span><span class="token key attr-name">    type</span><span class="token punctuation">:</span> <span class="token value attr-value">com.zaxxer.hikari.HikariDataSource</span><span class="token comment">    #数据库连接池的配置</span><span class="token key attr-name">    hikari</span><span class="token punctuation">:</span><span class="token comment">      #客户端等待连接池连接的最大毫秒数</span><span class="token key attr-name">      connection-timeout</span><span class="token punctuation">:</span> <span class="token value attr-value">30000</span>         ……<span class="token comment">      #连接池的名称</span><span class="token key attr-name">  pool-name</span><span class="token punctuation">:</span> <span class="token value attr-value">SpringDataJPAHikariCP</span><span class="token comment">  #jpa相关配置</span><span class="token key attr-name">  jpa</span><span class="token punctuation">:</span><span class="token key attr-name">    hibernate</span><span class="token punctuation">:</span><span class="token comment">      #DDL:用于定义数据库的三层结构，包括外模式、概念模式、内模式及其相互之间的映像，定义数据的完整性，安全控制等约束</span><span class="token key attr-name">      ddl-auto</span><span class="token punctuation">:</span> <span class="token value attr-value">none #什么也不做</span><span class="token comment">      #其他可选值</span><span class="token comment">      #create: 每次运行应用程序时，都会重新创建表，所以，数据都会丢失</span><span class="token comment">      #create-drop:每次运行程序时会创建表结构，然后程序结束时清空数据</span><span class="token comment">      #update: 每次运行程序没有表时会创建表，如果对象改变会更新表结构，原有数据不会清除，只会更新</span><span class="token comment">      #validate: 运行程序会校验数据与数据库的字段类型是否相同，字段不同会报错</span><span class="token comment">    #打印执行的sql及参数</span><span class="token key attr-name">    show-sql</span><span class="token punctuation">:</span> <span class="token value attr-value">true</span><span class="token comment">    # 关闭懒加载配置，否则会报错</span><span class="token key attr-name">    open-in-view</span><span class="token punctuation">:</span> <span class="token value attr-value">false</span><span class="token key attr-name">    properties</span><span class="token punctuation">:</span><span class="token key attr-name">      hibernate</span><span class="token punctuation">:</span><span class="token comment">        #输出sql语句</span><span class="token key attr-name">        show_sql</span><span class="token punctuation">:</span> <span class="token value attr-value">true</span><span class="token comment">        #格式化输出的sql，否则会一行显示</span><span class="token key attr-name">        format_sql</span><span class="token punctuation">:</span> <span class="token value attr-value">true</span><span class="token key attr-name">server</span><span class="token punctuation">:</span><span class="token comment">  #指定服务端口号</span><span class="token key attr-name">  port</span><span class="token punctuation">:</span> <span class="token value attr-value">8008</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JPA简单查询"><a href="#JPA简单查询" class="headerlink" title="JPA简单查询"></a>JPA简单查询</h3><h4 id="Repository的编写"><a href="#Repository的编写" class="headerlink" title="Repository的编写"></a><strong>Repository的编写</strong></h4><p>JPA中，我们只需要定义一个接口就可以轻松地操作数据库，这个接口要继承JpaRepository接口，这里需要指定两个泛型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BannerRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一个泛型是实体类的类型，第二个泛型是主键的类型。</p><h4 id="JPA简单条件查询"><a href="#JPA简单条件查询" class="headerlink" title="JPA简单条件查询"></a><strong>JPA简单条件查询</strong></h4><p>JPA要求 我们按照一定的规则进行命名就可以进行一些简单的查询，下面我们开始编写第一个JPA方法。</p><p>我们可以定义如下的方法，按照字面上的理解就是，通过查询Banner通过Id，参数是bannerId，也可以通过其他字段来进行查询，IDE会给出提示，我们仅仅需要编写一个这样的方法JPA就会自动的完成查询工作，当前方法中返回的Java8中的Optional对象，也可以直接返回Banner实体类，在一些业务场景下，返回的结果集可能是多个实体对象，这时要用List来进行接收。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BannerRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 查询banner 通过bannerId     *     * @param bannerId bannerId     * @return banner 详细信息     */</span>    <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">&gt;</span></span> <span class="token function">findBannerById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> bannerId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a><strong>多条件查询</strong></h4><p>如果通过多个条件进行查询，如通过名称和描述进行查询，JPA也支持这种查询方式，我们只需要将条件用and进行连接，这里的条件的属性名称与个数要与参数的位置和个数一一对应。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>Banner <span class="token function">findBannerByNameAndDescription</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> description<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>JPA几乎实现了MySQL所有的查询关键字，第一个查询是通过Equals关键字来查询名称相同和价格相等的商品，第二个查询是通过GreaterThanEqual关键字来查询名称相同价格大于等于给定价格的商品。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*** 查询商品列表通过名称和价格*/</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findByNameAndPriceEquals</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*** 查询商品列表并且价格大于等于指定的价格*/</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findByNameAndPriceGreaterThanEqual</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a><strong>排序与分页</strong></h4><p>JPA还提供了对排序和分页的支持，只需要在查询方法的入参中加入Sort对象作为入参，就可以实现排序功能，实现分页功能需要将Pageable作为入参就可以实现分页功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token class-name">Sort</span> sort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="JPA复杂查询"><a href="#JPA复杂查询" class="headerlink" title="JPA复杂查询"></a><strong>JPA复杂查询</strong></h3><h4 id="自定义JPQL"><a href="#自定义JPQL" class="headerlink" title="自定义JPQL"></a>自定义JPQL</h4><p>如果JPA规范定义的查询关键字不能满足需求的话，就可以使用@Query自定义查询的JPQL。</p><blockquote><p>第一个自定义简单查询</p></blockquote><p>查询最大id的商品信息，nativeQuery属性表示，是否使用原生SQL，目前使用的JPQL并不是原生的，该属性默认是false，默认可以不写就是使用JPQL查询，这里要注意的是查询使用的表名是实体类，而不是数据表。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**  * 查询id值最大的商品信息  */</span><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SELECT g from Goods g WHERE id = (SELECT max(id) FROM Goods)"</span><span class="token punctuation">,</span> nativeQuery <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token class-name">Goods</span> <span class="token function">getMaxIdGoods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种传递参数的方式：通过参数名来进行传递，通过@Param注解来指定参数名称，在JPQL中使用:参数名的方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">"SELECT g FROM Goods g WHERE name= :name and price &gt;= :price"</span><span class="token punctuation">)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findGoodsBySecondParam</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"price"</span><span class="token punctuation">)</span> <span class="token class-name">BigDecimal</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="JPA原生查询"><a href="#JPA原生查询" class="headerlink" title="JPA原生查询"></a><strong>JPA原生查询</strong></h4><p>之前我们使用的自定义查询都是使用JPQL来进行查询，下面将演示使用原生SQL来进行查询，如下查询所有的商品信息，前面已经介绍过，nativeQuery用来标志当前查询是一条原生SQL。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SELECT * FROM goods"</span><span class="token punctuation">,</span> nativeQuery <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Goods</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAllNativeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么如果我们想要拿到原生查询的部分结果，那么我们就需要使用Map来进行接收。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SELECT name, price FROM goods"</span><span class="token punctuation">,</span> nativeQuery <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">getGoodsNameAndPriceNativeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员JDBC原理+实战：<a href="https://www.bilibili.com/video/BV1s3411K7jH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1s3411K7jH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>JDBC连接如何防止SQL注入：<a href="https://blog.csdn.net/u014454538/article/details/108952103">https://blog.csdn.net/u014454538/article/details/108952103</a></p><p>Java持久层框架整理：<a href="https://blog.csdn.net/jiamingTu/article/details/106298092">https://blog.csdn.net/jiamingTu/article/details/106298092</a></p><p>为什么90%的开发者放弃使用Hibernate，而选择MyBatis：<a href="https://www.zhihu.com/question/532452772">https://www.zhihu.com/question/532452772</a></p><p>JPA入门：<a href="https://zhuanlan.zhihu.com/p/519013984">https://zhuanlan.zhihu.com/p/519013984</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持久层 </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Survey of Large Language Models</title>
      <link href="/2024/04/24/a-survey-of-large-language-models/"/>
      <url>/2024/04/24/a-survey-of-large-language-models/</url>
      
        <content type="html"><![CDATA[<h1 id="大模型综述"><a href="#大模型综述" class="headerlink" title="大模型综述"></a>大模型综述</h1><p><strong>参考博客：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/630203554">https://zhuanlan.zhihu.com/p/630203554</a></p><p><a href="https://www.cnblogs.com/David-deng/p/17786107.html">https://www.cnblogs.com/David-deng/p/17786107.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/662673023">https://zhuanlan.zhihu.com/p/662673023</a></p><p><a href="https://blog.csdn.net/qq_41185868/article/details/131565801">https://blog.csdn.net/qq_41185868/article/details/131565801</a></p><p><a href="https://mp.weixin.qq.com/s/yIsHsZL2Kbav0LvTUry_dg">https://mp.weixin.qq.com/s/yIsHsZL2Kbav0LvTUry_dg</a></p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>语言模型的四个发展阶段：</p><h3 id="统计语言模型（SLM）"><a href="#统计语言模型（SLM）" class="headerlink" title="统计语言模型（SLM）"></a>统计语言模型（SLM）</h3><p>20世纪90年代，学术界对于统计语言模型(SLM)的研究开始兴起。</p><p><strong>基于马尔可夫假设建立词预测模型</strong>，例如根<strong>据最近的上下文预测下一个词</strong>，例如bigram 和 trigram 语言模型。</p><ul><li>bi-gram语言模型：当前词出现的概率只与上一个词出现的概率相关</li><li>tri-gram语言模型：当前词出现的概率只与上两个词出现的概率相关</li></ul><p>SLM 已被广泛应用于提高信息检索（IR） 和自然语言处理（NLP）任务。</p><p>问题：<strong>维数灾难.需要估计指数级数量的转换概率</strong>，因此很难准确估计高阶语言模型。因此，设计专门的平滑策略，如回退估计和古德图灵估计.</p><h3 id="神经语言模型-NLM"><a href="#神经语言模型-NLM" class="headerlink" title="神经语言模型(NLM)"></a>神经语言模型(NLM)</h3><p>通过神经网络，如循环神经网络（RNN），来<strong>描述单词序列的概率</strong>。在聚合上下文特征（即分布式词向量）的条件下构建词预测函数。</p><p><strong>word2vec  提出了构建一个简化的浅层神经网络来学习分布式单词表示的方法.</strong></p><p>这些研究开创了<strong>将语言模型用于表示学习（超越词序列建模）的应用</strong></p><h3 id="预训练语言模型-PLM"><a href="#预训练语言模型-PLM" class="headerlink" title="预训练语言模型 (PLM)"></a>预训练语言模型 (PLM)</h3><p>ELMo被提出<strong>通过预训练</strong>一个双向 LSTM（biLSTM）<strong>网络</strong>（而不是学习固定的词表示）<strong>来捕捉上下文感知的词表示，然后根据特定的下游任务微调 biLSTM 网络</strong>。</p><p>进一步，<strong>基于自注意力机制的高度并行化 Transformer 架构</strong> [22]，BERT [23] 作为双向语言模型，在大规模无标签语料库上使用专门设计的预训练任务。这些<strong>预训练的上下文感知词表示作为通用语义特征非常有效</strong>，其极大地提高了 NLP 任务的性能。</p><p>确立了“预训练和微调”学习范式。已经建立了大量关于 PLM 的研究，这些研究引入了不同的架构 [24, 25]（例如 GPT-2 [26] 和 BART [24]）或改进的预训练策略 [27–29]。在这个范式中，通常需要对 PLM进行微调以适配不同的下游任务。</p><h3 id="大语言模型-LLM"><a href="#大语言模型-LLM" class="headerlink" title="大语言模型(LLM)"></a>大语言模型(LLM)</h3><p>扩展 PLM（例如扩展模型大小或数据大小）通常会提高下游任务的模型性能（即遵循扩展法则 [30]）。许多研究通过训练越来越大的 PLM（例如 1750 亿参数的 GPT-3 和 5400 亿参数的 PaLM）来探索性能极限。</p><p>大规模的 PLM 与较小的 PLM表现出不同的行为，并在解决一系列复杂任务中展示了惊人的能力（称为涌现能力）。</p><p>例如，GPT-3 可以通过上下文学习（in-context learning, ICL）来解决小样本任务，而 GPT-2 则表现不佳。</p><p>研究界将这些大规模的 PLM 命名为“大语言模型”</p><p>通常，大型语言模型（LLM）是指包含数千亿（或更多）参数的语言模型，这些参数是在大量文本数据上训练的，例如模型 GPT-3、PaLM、Galactica 和 LLaMA。具体来说，LLM 建立在 Transformer 架构之上，其中多头注意力层堆叠在一个非常深的神经网络中。现有的 LLM 主要采用与小语言模型类似的模型架构（即 Transformer）和预训练目标（即语言建模）。作为主要区别，LLM 在很大程度上扩展了模型大小、预训练数据和总计算量（扩大倍数）。他们可以更好地理解自然语言，并根据给定的上下文（例如 prompt）生成高质量的文本。这种容量改进可以用标度律进行部分地描述，其中性能大致遵循模型大小的大幅增加而增加。然而根据标度律，某些能力（例如，上下文学习）是不可预测的，只有当模型大小超过某个水平时才能观察到。</p><h3 id="LLM-vs-PLM"><a href="#LLM-vs-PLM" class="headerlink" title="LLM vs PLM"></a>LLM vs PLM</h3><ul><li><p>wikipedia：大语言模型 (英语：large language model，LLM) 是一种语言模型，由具有许多参数（通常数十亿个权重或更多）的人工神经网络组成，使用自监督学习或半监督学习对大量未标记文本进行训练。大型语言模型在2018年左右出现，并在各种任务中表现出色。</p></li><li><p>本综述的观点：大语言模型是指包含数千亿（或更多）参数的Transformer语言模型，这些模型是在大规模文本数据上进行训练的，例如GPT-3，PaLM，Galactica 和 LLaMA。</p></li><li><p>我的理解：</p><ul><li>通过上面的回答我们可以看出，现在的研究中并没有对于多大的模型才能算作大语言模型有一个确切的定义。通常大语言模型一般拥有数十亿或者更多的参数。</li><li>对于本综述的观点我并不是非常的认可。因为我们知道 LLaMA 2 拥有三个版本，参数量分别是7B、13B和70B，没有达到综述中的千亿参数的规模，但是 LLaMA 2 还是被大家公认为是一个预训练的大语言模型。</li></ul></li></ul><p>1.<strong>LLM具有涌现能力(emergent abilities)：这是llm能解决复杂任务的关键</strong></p><p>2.LLM 将彻底改变人类开发和使用人工智能算法的方式。</p><p>3.LLM 的发展不再明确区分研究和工程。训练 LLM 需要在大规模数据处理和分布式并行训练方面具有丰富的实践经验，研究人员需要与工程人员合作。</p><h3 id="LLM机遇与挑战"><a href="#LLM机遇与挑战" class="headerlink" title="LLM机遇与挑战"></a>LLM机遇与挑战</h3><h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><p>ChatGPT 和 GPT-4 的出现促使人们重新思考通用人工智能（AGI）的可能性。</p><p>在 NLP 领域，LLM 可以在一定程度上作为通用语言任务解决器，研究范式已经转向使用 LLM。在 IR 领域，传统搜索引擎正受到通过 AI 聊天机器人（即 ChatGPT）搜索新信息的挑战。在计算机视觉（CV）领域，研究人员试图开发类似 ChatGPT 的视觉-语言模型，以更好地为多模态对话提供服务。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>其基本原理尚未得到充分探索。</strong></p><p><strong>涌现能力的出现难以解释。研究界缺乏对 LLM 优越能力的关键因素进行深入、详细的研究调查</strong></p><p>研究界很难训练出有能力的 LLM。由于计算资源的巨大需求，为了研究训练 LLM 的各种策略的效果，进行重复、消融研究的成本非常高</p><p>将 LLM 与人类价值观或偏好保持一致是具有挑战的。</p><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2.概述"></a>2.概述</h2><h3 id="2-1背景"><a href="#2-1背景" class="headerlink" title="2.1背景"></a>2.1背景</h3><p>为了对 LLM 的工作原理有一个快速的了解，本部分将介绍 LLM 的基本背景，包括扩展法则、涌现能力和关键技术。</p><h4 id="扩展法则-Scaling-Laws"><a href="#扩展法则-Scaling-Laws" class="headerlink" title="扩展法则 Scaling Laws"></a>扩展法则 Scaling Laws</h4><p><strong>现有的llm采用与小型语言模型类似的Transformer体系结构和预训练目标（例如，语言建模），但大幅度扩展了模型规模、数据规模和总计算量（数量级）。</strong></p><p>扩展可以大幅提高 LLM 的模型能力<strong>，因此，建立一个定量的方法来描述扩展效应是有意义的</strong>。</p><p>两个代表性工作：</p><p>（1）KM scaling law：2020年，Kaplan等人（OpenAI团队）首次提出建模模型参数和三个主要因素（即模型大小N、数据集大小D、训练计算量C）之间的幂律关系。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231023174256702.png" alt="image-20231023174256702"><p>其中L(·)表示使用纳特（nats：在信息论中，nats是自然对数的单位，用于度量信息量或信息熵。它是以自然对数的底数e为基础，表示信息的相对量——from ChatGPT）<strong>表示的交叉熵损失</strong>。这三个定律是在一些假设(例如，一个因素的分析不应该受到其他两个因素的瓶颈)下，通过拟合不同数据大小(22M到23B个tokens)、模型大小(768M到1.5B个非嵌入参数)和训练计算的模型性能得出的。<br>这里，Nc、Dc和Cc分别以非嵌入参数的数量、训练tokens的数量和FP天数来衡量。<br>（2）Chinchilla Scaling law：作为另一项具有代表性的研究，Hoffmann等人（谷歌DeepMind团队）提出了一种缩放定律的替代形式，以指导LLM的计算优化训练。</p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231023174356210.png" alt="image-20231023174356210"></p><p>其中 <em>E</em> = 1*.<em>69</em>, A* = 406*.<em>4</em>, B* = 410*.<em>7，</em>α* = 0*.<em>34 和 <em>β</em> = 0</em>.<em>28。通过在约束条件 <em>C</em> <em>≈</em> 6</em>ND* 下优化损失 <em>L</em>(<em>N, D</em>)，他们展示了将计算预算最优地分配给模型大小和数据大小的方法（如下）：</p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231023174428643.png" alt="image-20231023174428643"></p><p>随着给定计算预算的增加，<strong>KM 扩展法则更偏向于将更大的预算分配给模型大小，而 Chinchilla 扩展法则则认为模型大小和数据大小应该以相同的比例增加</strong>，即在公式 (3)中的 <em>a</em> 和 <em>b</em> 取相近的值。</p><h4 id="涌现能力-emergent-abilities"><a href="#涌现能力-emergent-abilities" class="headerlink" title="涌现能力 emergent abilities"></a>涌现能力 emergent abilities</h4><p>涌现：在小型模型中不存在但在大型模型中产生的能力。这是区别 LLM 与先前 PLM 的最显著特征之一</p><p>LLM 的三种典型涌现能力和具备这种能力的代表性模型：</p><h5 id="上下文学习-In-context-learning"><a href="#上下文学习-In-context-learning" class="headerlink" title="上下文学习 In-context learning"></a>上下文学习 In-context learning</h5><p>为语言模型提供一个自然语言指令和/或几个任务示例，它就可以通过完成输入文本的单词序列的方式来为测试实例生成预期的输出，而无需额外的训练或梯度更新。这种能力还取决于具体的下游任务。</p><p>在 GPT系列模型中，1750 亿的 GPT-3 模型在一般情况下表现出强大的 ICL 能力，但 GPT-1 和 GPT-2 模型则没有。然</p><h5 id="指令遵循-Instruction-following"><a href="#指令遵循-Instruction-following" class="headerlink" title="指令遵循 Instruction following"></a>指令遵循 Instruction following</h5><p>微调 基于自然语言描述来格式化的多任务混合数据集。对于没见过的按照指令的形式描述的任务，LLMs可以在做得很好。</p><p>通过指令微调，LLM 能够在没有使用显式示例的情况下遵循新的任务指令，因此它具有更好的泛化能力。</p><h5 id="逐步推理Step-by-step-reasoning"><a href="#逐步推理Step-by-step-reasoning" class="headerlink" title="逐步推理Step-by-step reasoning"></a>逐步推理Step-by-step reasoning</h5><p>通过使用思维链（Chain-of-Thought, CoT）提示策略 [32]，LLM 可以通过利用包含中间推理步骤的提示机制来解决复杂推理任务</p><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><h5 id="Scaling-扩展"><a href="#Scaling-扩展" class="headerlink" title="Scaling 扩展"></a>Scaling 扩展</h5><p>在Transformer语言模型中存在明显的缩放效应:更大的模型/数据大小和更多的训练计算通常会导致模型能力的改进。<br>此外，由于计算预算通常是有限的，因此可以使用缩放定律来进行计算效率更高的计算资源分配。<br>例如，Chinchilla(具有更多的训练tokens)通过在相同的计算预算下增加数据规模超过了其对应模型Gopher(具有更大的模型大小)。<br>然而，应该注意的是，数据缩放应该伴随着仔细的清理过程，因为预训练数据的质量在模型能力中起着关键作用。</p><h5 id="Training-训练"><a href="#Training-训练" class="headerlink" title="Training 训练"></a>Training 训练</h5><p>为了支持分布式训练，已经发布了几个优化框架来促进并行算法的实现和部署，例如DeepSpeed和Megatron-LM。<br>此外，优化技巧对于训练稳定性和模型性能也很重要，例如重新启动以克服训练损失尖峰和混合精度训练。<br>最近，GPT-4提出开发特殊的基础设施和优化方法，用小得多的模型可靠地预测大型模型的性能。</p><h5 id="Ability-Eliciting-能力引导"><a href="#Ability-Eliciting-能力引导" class="headerlink" title="Ability Eliciting 能力引导"></a>Ability Eliciting 能力引导</h5><p>作为一种技术方法，设计合适的任务指令或特定的上下文学习策略来诱导这种能力是有用的。<br>例如，思维链提示，即通过中间推理步骤以解决复杂的推理任务，已被证明是有用的。<br>此外，我们还可以对LLMs进行指令微调，用自然语言表达任务描述，提高LLMs对不曾见过的任务的泛化能力。</p><h5 id="Alignment-Tuning-对齐微调"><a href="#Alignment-Tuning-对齐微调" class="headerlink" title="Alignment Tuning 对齐微调"></a>Alignment Tuning 对齐微调</h5><p>有必要使 LLM 与人类价值观保持一致，例如有用性、诚实性和无害性。</p><p>为此，InstructGPT设计了一种有效的调优方法，使llm能够遵循预期的指令，该方法利用了带有人类反馈的强化学习技术（RLHF）。<br>ChatGPT确实是在与InstructGPT类似的技术基础上开发的，其在产生高质量、无害的回复方面显示出强大的对齐能力，例如，拒绝回答侮辱性的问题。</p><h5 id="Tool-Manipulation-工具操作"><a href="#Tool-Manipulation-工具操作" class="headerlink" title="Tool Manipulation 工具操作"></a>Tool Manipulation 工具操作</h5><p>从本质上讲，LLMs在大量纯文本语料库上被训练为文本生成器，因此在不能最好地以文本形式表达的任务(例如，数值计算)上表现不佳。此外，它们的能力也局限于预训练数据，例如，无法获取最新信息。为了解决这些问题，最近提出的一种技术是使用外部工具来弥补LLMs的不足。<br>例如，LLMs可以利用计算器进行精确计算，利用搜索引擎检索未知信息。最近，ChatGPT启用了使用外部插件(现有或新创建的应用程序)的机制，这被类比为LLMs的“眼睛和耳朵”。这种机制可以广泛扩展 LLM 的能力范围。</p><h3 id="2-2技术演进"><a href="#2-2技术演进" class="headerlink" title="2.2技术演进"></a>2.2技术演进</h3><img src="/2024/04/24/a-survey-of-large-language-models/image-20231106143336059.png" alt="image-20231106143336059" style="zoom:80%;"><p>GPT模型的基本原理是通过语言建模将世界知识压缩为仅含解码器的Transformer模型，从而恢复（或记忆）世界知识的语义，并充当通用任务求解器。成功的两个关键点是 (1)只训练解码器的Transformer语言模型，可以准确地预测下一个词  (2) 扩大语言模型的规模</p><h5 id="早期探索阶段"><a href="#早期探索阶段" class="headerlink" title="早期探索阶段"></a>早期探索阶段</h5><p>随着 Transformer 的出现，OpenAI开发了两个初始的 GPT 模型，即GPT-1和GPT-2</p><p>GPT表示生成式预训练（<em>Generative Pre-Training</em>）。GPT-1是基于生成式、仅解码器的Transformer架构开发的，采用了无监督预训练和有监督微调的混合方法。</p><p>GPT-2采用与GPT-1类似的架构，将参数尺度增加到1.5B，使用大型网页数据集WebText进行训练。它试图通过无监督语言建模来执行任务，而无需使用标记数据进行显式的微调。为了推动这种方法，他们引入了多任务求解的概率形式，即<em>p</em>(<em>output</em>*|*<em>input, task</em>)（类似的方法已在 [75] 中采用），它在给定输入和任务信息的条件下预测输出。为了对该条件概率建模，自然语言文本可以自然地用作为格式化输入、输出和任务信息的统一方式。通过这种方式，解决任务的过程可以被视为生成解决方案文本的单词预测问题。</p><p>由于(特定于任务的)监督目标与无监督(语言建模)目标相同，但只在序列的一个子集上进行评估，因此无监督目标的全局最小值也是监督目标的全局最小值(对于各种任务)。</p><p>对这个主张的基本理解是，每个 NLP 任务可以被视为基于世界文本的子集的单词预测问题。因此，如果模型训练后具有足够能力以复原世界文本，无监督语言建模可以解决各种任务。</p><h5 id="能力飞跃"><a href="#能力飞跃" class="headerlink" title="能力飞跃"></a>能力飞跃</h5><p>尽管GPT-2旨在成为一个“无监督多任务学习器”，但与监督微调的最先进方法相比，它的总体性能较差。<br>虽然它的模型尺寸相对较小，但它在下游任务中进行了广泛的微调，特别是对话任务。在GPT-2的基础上，GPT-3通过扩展(几乎相同的)生成预训练架构展示了关键的能力飞跃。<br>GPT-3扩展到175B参数，并引入上下文学习(ICL)的概念，它以少样本或零样本的方式利用LLM。</p><p>LLM 的预训练和使用在 ICL 下有着相同的语言建模范式：预训练预测给定上下文条件下的后续文本序列，而 ICL 预测正确的任务解决方案，该解决方案可以被格式化为给定任务描述和示范下的文本序列。</p><h5 id="能力增强"><a href="#能力增强" class="headerlink" title="能力增强"></a>能力增强</h5><p>OpenAI 探索了两种主要方法来进一步改进 GPT-3 模型，即使用代码数据进行训练以及与人类偏好的对齐</p><p><strong>使用代码数据进行训练：</strong></p><p>原始的GPT-3模型(在纯文本上预训练)的局限在于缺乏复杂任务的推理能力，例如补全代码和解决数学问题。<br>为了增强这种能力，OpenAI于2021年7月引入了Codex，这是一个在大型GitHub代码语料库上进行微调的GPT模型。它证明了Codex可以解决非常困难的编程问题，并且在解决数学问题时也可以显著提高性能。<br>此外，2022年1月报道了一种用于训练文本和代码嵌入的对比方法，该方法被证明可以改进一系列相关任务(即线性探测分类、文本搜索和代码搜索)。<br>实际上，GPT-3.5模型是基于基于代码的GPT模型(即code-davinci-002)开发的，这表明对代码数据的训练是提高GPT模型的建模能力，特别是推理能力的一个非常有用的实践。<br>此外，也有人推测，对代码数据进行训练可以大大提高LLMs的思维链提示能力，但这仍值得进一步研究，需要更彻底的验证。</p><p><strong>与人类对齐</strong><br>OpenAI对人类偏好的相关研究可以追溯到2017年(或更早):OpenAI博客上发表了一篇题为“从人类偏好中学习”的博客文章，描述了一项应用强化学习(RL)从人类标注的偏好比较中学习的工作。(类似于InstructGPT的图6中对齐算法中的reward-training步骤)。<br>这篇RL文章发布不久后，PPO的文章（Proximal Policy Optimization)于2017年7月发表，目前已成为从人类偏好中学习的基础强化学习算法。<br>随后在2020年1月，使用上述RL算法对GPT-2进行了微调，该算法利用人类偏好来提高GPT-2在NLP任务上的能力。同年，另一项研究以类似的方式训练了一个优化人类偏好的摘要模型。<br>在这些前期工作的基础上，2022年1月InstructGPT被提出，用于改进GPT-3模型的人类对齐，该模型正式建立了一种<strong>基于人类反馈的三阶段强化学习(RLHF)算法</strong>。请注意，OpenAI的论文和文档中似乎很少使用“instruction tuning”的措辞，取而代之的是对人类示例的有监督微调(即RLHF算法的第一步)。<br>除了提高指令遵循能力外，RLHF算法在减轻LLMs产生有害或有毒内容的问题上特别有用，这是LLMs在实践中安全部署的关键。</p><p>这些增强技术导致改进后的GPT-3模型具有更强的能力，OpenAI将其称为GPT-3.5模型。</p><h5 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h5><p><strong>chatgpt</strong></p><p>ChatGPT的训练方式与InstructGPT类似，但专门针对对话能力进行了优化。</p><p>他们报告了ChatGPT和InstructGPT在数据收集设置上的训练差异:人工生成的对话(扮演用户和人工智能的角色)与InstructGPT数据集以对话格式相结合，用于训练ChatGPT。</p><p>拥有丰富的知识库，擅长解决数学问题，准确追踪多轮对话中的上下文，并与人类的价值观保持一致以确保被安全使用。支持插件机制，这进一步扩展了ChatGPT与现有工具或应用程序的能力。</p><p><strong>GPT-4</strong></p><p>GPT-4于2023年3月发布，将文本输入扩展到多模态信号。</p><p>由于经过为期六个月的迭代对齐（在RLHF训练中加入了额外的安全奖励信号），GPT-4对于具有恶意或挑衅的提问的响应更加安全。例如，他们引入了一种称为红队评估（<em>red teaming</em>）的机制来减少有害或生成有毒内容的可能性。他们引入了一种称为可预测扩展（<em>predictablescaling</em>）的新机制，可以使用模型训练期间一小部分的计算量来准确预测最终性能。</p><p>从工程的角度来看，OpenAI采用了一种迭代部署策略，通过遵循五阶段的开发和部署生命周期来开发模型和产品，以有效降低使用模型带来的潜在风险。</p><h2 id="3-大模型资源"><a href="#3-大模型资源" class="headerlink" title="3.大模型资源"></a>3.大模型资源</h2><p>考虑到技术问题的挑战和计算资源的巨大需求，开发或复现LLM 绝非易事。一种可行的方法是在现有的 LLM 的基础上进行开发，即重复使用公开可用的资源进行增量开发或实验研究。在本节中，我们简要整理了用于开发 LLM 的公开可用的资源，包括公开的模型检查点（或 API）、语料库和代码库。</p><h3 id="3-1公开的模型检查点或API"><a href="#3-1公开的模型检查点或API" class="headerlink" title="3.1公开的模型检查点或API"></a>3.1公开的模型检查点或API</h3><p><strong>百亿参数模型</strong></p><p>除LLaMA(最大版本包含65B个参数)和NLLB(最大版本包含54.5B个参数)外，该类模型的参数尺度大多在10B - 20B之间。</p><p>Flan-T5 (11B版本)可以作为研究指令调优（instruction tuning）的首选模型，因为它从三个方面探索指令调优：增加任务数量，缩放模型大小，以及使用思维链提示数据进行微调。<br>此外，CodeGen (11B版本)作为一种为生成代码而设计的自回归语言模型，可以认为是探索代码生成能力的一个很好的候选。它还引入了一个专门针对多轮程序合成的新基准MTPB，由115个专家生成的问题组成。为了解决这些问题，LLMs需要掌握足够的编程知识(如数学、数组操作和算法)。<br>对于多语言任务，mT0 (13B版本)可能是一个很好的候选模型，它已经对具有多语言提示的多语言任务进行了微调。<br>此外，PanGu-α在基于深度学习框架MindSpore开发的中文下游任务中，在零样本或少样本设置中表现良好。（注意PanGu-α有多个版本，最大有200B参数，公开的最大版本是13B）。由于LLaMA的开放性和有效性，它已经引起了研究界的极大关注，许多努力都致力于对其不同的模型版本进行微调或持续预训练，以实现新的模型或工具。<br>通常，这种规模的预训练模型需要数百甚至数千个gpu或tpu。例如，GPT-NeoX-20B使用12台超微服务器，每台服务器配备8个NVIDIA A100-SXM4-40GB gpu，而LLaMA在其原始出版物中使用2,048个A100-80G gpu。</p><p><strong>千亿参数模型</strong></p><p>在跨语言泛化研究中，BLOOM (176B版本)和BLOOMZ (176B版本)可以作为基础模型，因为它们在多语言语言建模任务中的能力。<br>在这些模型中，OPT-IML已经使用指令进行了调优，这可能是研究指令调优效果的良好候选者。<br>这种规模的模型通常需要数千个gpu或tpu来训练。例如，OPT (175B版本)使用992个A100-80GB GPU，而GLM (130B版本)使用96个NVIDIA DGX-A100 (8x40G) GPU节点的集群。</p><p><strong>公共API</strong></p><p>OpenAI为GPT-3系列模型提供了七个主要接口：ada、babbage、curie、davinci (GPT-3系列中最强大的版本)、text-ada-001、text-babbage-001和text-curie-001。其中，前四个接口可以在OpenAI的主机服务器上进一步微调。babbage、curie和davinci分别对应于GPT-3 (1B)、GPT-3 (6.7B)和GPT-3 (175B)模型。<br>此外，还有两个与Codex相关的api，称为code-cushman-001 (Codex (12B)的强大多语言版本)和code-davinci-002。<br>此外，GPT-3.5系列包括一个基础模型code-davinci-002和三个增强版本，即text-davinci-002, text-davinci-003和GPT-3.5-turbo-0301。值得注意的是，gpt-3.5-turbo-0301是调用ChatGPT的接口。<br>最近，OpenAI也为GPT-4发布了相应的api，包括gpt-4、gpt-4-0314、gpt-4-32k和gpt-4-32k-0314。<br>api详细用法见：<a href="https://link.zhihu.com/?target=https://platform.openai.com/docs/models/overview">https://platform.openai.com/doc</a></p><h3 id="3-2常用语料库"><a href="#3-2常用语料库" class="headerlink" title="3.2常用语料库"></a>3.2常用语料库</h3><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231106164749415.png" alt="image-20231106164749415"></p><h4 id="books"><a href="#books" class="headerlink" title="books"></a>books</h4><p>BookCorpus–小规模模型（如 GPT和 GPT-2）中常用的数据集，包括超过 11,000 本电子书，涵盖广泛的主题和类型（如小说和传记）。另一个大规模的书</p><p>籍语料库是 Gutenberg，它有超过 70,000 本文学作品，包括小说、散文、诗歌、戏剧、历史、科学、哲学和其他公共领域的作品。它是目前最大的开源书籍集合之一，被用于训练 MT-NLG 和 LLaMA。</p><h4 id="CommonCrawl"><a href="#CommonCrawl" class="headerlink" title="CommonCrawl"></a><strong>CommonCrawl</strong></h4><p> <strong>CommonCraw 是最大的开源网络爬虫数据库之一</strong>，包含百万亿字节级的数据量，已被广泛用作LLMs训练。</p><p>由于web数据中普遍存在噪声和低质量的信息，因此在使用前需要对数据进行预处理。现有工作中常用的过滤数据集有四种：C4、CCStories、CC-News和RealNews。C4包括五个变体，即en (806G)， en.noclean (6T)、realnewslike (36G)、web-textlike (17G)和multilingual (38T)。en版本已被用于T5、LaMDA、Gopher和UL2的预训练。multilingual C4，也称为mC4，已在mT5中使用。</p><h4 id="Reddit-Links"><a href="#Reddit-Links" class="headerlink" title="Reddit Links"></a>Reddit Links</h4><p>Reddit是一个社交媒体平台，用户可以提交链接和文本帖子，其他人可以通过“赞”或“贬”对这些帖子进行投票。WebText 就是一个著名的基于 Reddit 的语料库，它由 Reddit 上高赞的链接组成，但尚未公开。作为替代，有一个易于获取的开源替代品叫做 OpenWebText。</p><h4 id="Wikipedia"><a href="#Wikipedia" class="headerlink" title="Wikipedia"></a>Wikipedia</h4><p>维基百科是一个在线百科全书，包含大量关于不同主题的高质量文章。通常情况下，维基百科的纯英文过滤版本在大多数LLMs中被广泛使用(例如GPT-3， LaMDA和LLaMA)。维基百科有多种语言版本，因此它可以在多语言环境中使用。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>代码数据有两个主要来源：包括开源许可证的公共代码库（例如 GitHub）和与代码相关的问答平台（例如 StackOverflow）。</p><p>Google 公开发布了 BigQuery 数据集，其中包括各种编程语言的大量开源许可证代码片段，是一个典型的代码数据集。</p><p>CodeGen 使用的 BIGQUERY是 BigQuery 数据集的一个子集，用于训练多语言版本的CodeGen（CodeGen-Multi）。</p><h4 id="others"><a href="#others" class="headerlink" title="others"></a>others</h4><p>The Pile是一个大规模、多样化、开源的文本数据集，有超过 800GB 数据，内容包括书籍、网站、代码、科学论文和社交媒体平台等。它由 22 个多样化的高质量子集构成。The Pile数据集广泛应用于不同参数规模的模型中，如GPT-J (6B)、CodeGen (16B)、MegatronTuring NLG (530B)。<br>此外，ROOTS由各种较小的数据集(总共1.61 TB的文本)组成，涵盖59种不同的语言(包括自然语言和编程语言)，被用来训练BLOOM。</p><p><strong>给出了三个代表性LLMs的预训练语料库：</strong><br>（1）GPT-3 (175B)：在一个包含300B个tokens的混合数据集上进行训练，包括CommonCrawl、WebText2、Books1、Books2和Wikipedia。<br>（2）PaLM (540B)：使用780B tokens的预训练数据集，这些数据来自社交媒体对话、过滤的网页、书籍、Github、多语言维基百科和新闻。<br>（3）LLaMA：从各种来源提取训练数据，包括CommonCrawl, C4 , Github, Wikipedia, books, ArXiv和StackExchange。LLaMA (6B)和LLaMA (13B)的训练数据大小为1.0T tokens，LLaMA (32B)和LLaMA (65B)的训练数据大小为1.4T tokens。</p><h3 id="3-3代码库资源"><a href="#3-3代码库资源" class="headerlink" title="3.3代码库资源"></a>3.3代码库资源</h3><p>（1）Transformers是一个开源Python库，用于使用Transformer架构构建模型，由Hugging Face开发和维护。方便使用和定制各种预训练模型。<br>（2）DeepSpeed是微软开发的深度学习优化库(与PyTorch兼容)，已被用于训练多个LLMs，如MT-NLG和BLOOM。它为分布式训练提供了各种优化技术的支持，例如内存优化(ZeRO技术、梯度检查点)和流水线并行。<br>（3）Megatron-LM是NVIDIA开发的用于训练大规模语言模型的深度学习库。它还为分布式训练提供了丰富的优化技术，包括模型和数据并行、混合精度训练和FlashAttention。这些优化技术可以大大提高训练效率和速度，实现高效的跨GPU分布式训练。<br>（4）JAX是谷歌开发的用于高性能机器学习算法的Python库，允许用户轻松地在硬件加速(例如GPU或TPU)下对数组执行计算。它可以在各种设备上进行有效的计算，并且还支持一些功能，例如自动微分和即时编译。<br>（5）colossal-AI是由HPC-AI Tech开发的用于训练大规模AI模型的深度学习库。它是基于PyTorch实现，并支持丰富的并行训练策略集合。此外，它还可以使用PatrickStar提出的方法优化异构内存管理。最近，一个名为ColossalChat的类chatgpt的模型已经公开发布了两个版本(7B和13B)，它是基于LLaMA使用colossal-ai开发的。<br>（6）BMTrain是OpenBMB开发的用于分布式训练大规模参数模型的高效库，强调代码简洁、低资源、高可用性。BMTrain已经将几个常见的LLM(例如，Flan-T5和GLM)合并到其ModelCenter中，开发人员可以直接使用这些模型。<br>（7）FastMoE是MoE(即混合专家)模型的专门训练库。它是基于PyTorch开发的，在设计中优先考虑效率和用户友好性。FastMoE简化了将Transformer模型转换为MoE模型的过程，并在训练期间支持数据并行和模型并行。<br>除了上述库资源外，现有的深度学习框架(如PyTorch、TensorFlow、MXNet、PaddlePaddle、MindSpore和OneFlow)也提供了对并行算法的支持，并行算法通常用于训练大规模模型。</p><h2 id="4-预训练"><a href="#4-预训练" class="headerlink" title="4.预训练"></a>4.预训练</h2><p>预训练为 LLM 的能力奠定了基础。通过在大规模语料库上进行预训练，LLM 可以获得基本的语言理解和生成能力。</p><h3 id="4-1数据收集"><a href="#4-1数据收集" class="headerlink" title="4.1数据收集"></a>4.1数据收集</h3><img src="/2024/04/24/a-survey-of-large-language-models/image-20231120151109467.png" alt="image-20231120151109467" style="zoom:80%;"><h4 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h4><p>预训练语料库的来源可以广义地分为两种类型：通用文本数据和专用文本数据。</p><p>通用文本数据，如网页、书籍和对话文本等，其由于规模大、多样性强且易于获取的特点，被大多数 LLM 所利用，这可以增强 LLM 的语言建模和泛化能力。</p><p><strong>通用文本数据</strong>：</p><p>之前的工作从网络中爬取了大量的数据，如CommonCrawl。抓取的web数据往往既包含高质量的文本(如Wikipedia)，也包含低质量的文本(如垃圾邮件)，因此对网页进行过滤和处理以提高数据质量非常重要。</p><p>对话数据可以增强 LLM 的对话能力，并可能改善 LLM 在问答任务上的表现 。由于在线对话数据通常涉及多个参与者之间的讨论，因此一种有效的处理方法是将对话转换为树状结构，其中话语与它所响应的话语相关联。过度引入对话数据来训练 LLM 可能会导致一个潜在的风险：<strong>陈述性指令和直接疑问句被错误地认为是对话的开始，从而导致指令的有效性下降。</strong></p><p>书籍提供了更正式的长文本，这对于 LLM <strong>学习语言知识、建模长期依赖关系以及生成叙述性和连贯的文本</strong>具有潜在的好处。为了获取开源图书数据，现有研究通常采用Books3和Bookcorpus2数据集，这两个数据集在Pile数据集中都有。</p><p><strong>专用文本数据</strong>：</p><p>专用数据通常对LLMs执行下游任务有用，包括多语言文本、科学文本、代码。整合多语言语料库可以增强模型的多语言的理解和生成能力。例如，BLOOM和PaLM在其预训练语料库中分别制作了涵盖46种和122种语言的多语言数据。</p><p><strong>通过在大量科学文本上进行预训练，LLM 可以在科学和推理任务中取得出色的性能。</strong>为了构建科学语料库，现有的工作主要是收集arXiv论文、科学教科书、数学网页以及其他相关的科学资源。由于科学领域中数据的复杂性，例如数学符号和蛋白质序列，通常需要特定的标记化（tokenization）和预处理技术来将这些不同格式的数据转换为可以由语言模型处理的统一形式。</p><p>一般来说，两种类型的代码语料库通常用于预训练LLM。第一个来源是编程问答社区，如Stack Exchange。第二个来源是开源软件仓库，如GitHub，它们收集代码数据(包括注释和文档字符串)以供使用。</p><p>与自然语言文本相比，代码以编程语言的格式呈现，对应着长距离依赖和准确的执行逻辑。最近的一项研究还推测，<strong>训练代码可能是复杂推理能力（例如 CoT 能力）的来源。此外，将推理任务格式化为代码的形式还可以帮助 LLM 生成更准确的结果。</strong></p><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><h5 id="质量过滤"><a href="#质量过滤" class="headerlink" title="质量过滤"></a>质量过滤</h5><p>为删除收集到的语料库中的低质量数据，现有的工作通常采用两种方法：（1）基于分类器的方法，和（2）基于启发式的方法。</p><p>前者通常训练一个二元分类器，<strong>将高质量数据(例如，维基百科页面)作为正实例，将样本候选数据作为负实例</strong>，并预测衡量每个数据示例质量的分数。</p><p>问题：<strong>基于分类器的方法可能会删除方言、口语和社会语言的高质量文本，从而可能导致有偏见的预训练语料库，并减少语料库的多样性</strong>。</p><p>第二种方法，BLOOM和Gopher等几项研究采用了基于启发式的方法，通过一套精心设计的规则来消除低质量的文本，这些规则可以总结如下：<br>a）基于语言的过滤。<strong>如果LLM主要用于某些语言的任务，则可以过滤其他语言的文本。</strong><br>b）基于度量的过滤。关于生成文本的<strong>评估指标</strong>，例如，<strong>困惑度，可以用来检测和删除不自然的句子。</strong><br>c）基于统计的过滤。语料库的统计特征，例如：如标点分布、字数比、句子长度等，可以用来衡量文本质量，过滤低质量数据。<br>d）基于关键词过滤。基于特定的关键词集合，可以识别和删除文本中<strong>嘈杂或无用的元素，如HTML标记、超链接、样板和冒犯性词语。</strong></p><h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><p>语料库中的重复数据会降低语言模型的多样性，这可能导致训练过程变得不稳定，从而影响模型的性能。特别地，去重可以在不同的粒度上执行，包括句子级、文档级和数据集级的去重。</p><p>a）在句子级别，应<strong>删除含有重复单词</strong>和短语的低质量句子，因为它们可能会在语言建模中引入重复的模式。<br>b）在文档层面，现有的研究大多**依靠文档之间表面特征的重叠比例(**如word和n-gram overlap)来检测和去除内容相似的重复文档。<br>c）为了避免数据集污染问题，通过从训练集中删除可能的重复文本，防止训练集和评估集之间的重叠也至关重要。</p><h5 id="隐私去除"><a href="#隐私去除" class="headerlink" title="隐私去除"></a>隐私去除</h5><p>需要从预训练语料库中删除可识别个人信息（PII）。一种直接有效的方法是采用基于规则的方法，例如关键字识别，来检测和删除 PII，例如姓名、地址和电话号码。此外，LLM 在隐私攻击下的脆弱性可能归因于预训练语料库中存在的重复 PII 数据。因此，去重也可以在一定程度上降低隐私风险。</p><h5 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h5><p>将原始文本分割成词序列，随后用作 LLM 的输入。</p><p>使用<strong>专门为预训练语料库设计的分词器</strong>可能会更加有效，特别是对于由多种领域、语言和格式组成的语料库。</p><p>最近的几个 LLM 使用<strong>SentencePiece为预训练语料库训练定制化的分词器</strong>。同时<strong>利用字节级的 <em>Byte Pair Encoding (BPE)</em> 算法来确保分词后的信息不会丢失</strong> </p><h4 id="数据对llm的影响"><a href="#数据对llm的影响" class="headerlink" title="数据对llm的影响"></a>数据对llm的影响</h4><p>（1）混合来源<br>通过对来自不同来源的混合文本数据进行预训练，LLMs可以获得广泛的知识，并可能表现出强大的泛化能力。当混合不同的数据源时，需要仔细设置预训练数据的分布，因为这也可能影响LLMs在下游任务上的性能。<br>Gopher对数据分布进行消融实验，考察混合源对下游任务的影响。<br>在LAMBADA数据集上的实验结果表明，增加图书数据的比例可以提高模型从文本中捕获长期依赖关系的能力，增加C4数据集的比例可以提高C4验证数据集的性能。然而，作为一个副作用，对某一领域的过多数据进行训练会影响LLMs在其他领域的泛化能力。<br>（2）预训练数据的数量<br>对于模型性能来说，在数据规模方面也观察到与模型规模相似的扩展法则。最近的一项研究表明，由于预训练数据不足，许多现有的LLM遭受次优训练。<br>通过广泛的实验，进一步证明了在给定的计算预算下，以相同的规模增加模型大小和数据大小可以得到计算效率更高的模型(即Chinchilla模型)。最近，LLaMA表明，在更多的数据和更长的训练时间下，较小的模型也可以获得良好的性能。<br>（3）预训练数据的质量<br>最近的研究，如T5、GLaM和Gopher，研究了数据质量对下游任务性能的影响。通过比较在过滤和未过滤的语料库上训练的模型的性能，他们得出了相同的结论，即在清洗过的数据上预训练LLMs可以提高性能。更具体地说，数据的重复可能会导致“双下降现象”（指性能最初恶化，随后得到改善），甚至可能会使训练过程不稳定。</p><h3 id="4-2架构"><a href="#4-2架构" class="headerlink" title="4.2架构"></a>4.2架构</h3><h4 id="主流架构"><a href="#主流架构" class="headerlink" title="主流架构"></a>主流架构</h4><p>现有 LLM 的主流架构可以大致分为三种类型，即编码器-解码器、因果解码器和前缀解码器。</p><p><strong>编码器-解码器架构</strong></p><p>传统 Transformer 模型是建立在编码器-解码器架构上，<strong>由两个 Transformer 块分别作为编码器和解码器</strong>。编码器采用堆叠的多头自注意层对输入序列进行编码以生成其潜在表示，而解码器对这些表示进行交叉注意并自回归地生成目标序列。</p><p>目前，只有少数LLM 是基于编码器-解码器架构构建的，例如 Flan-T5。</p><p><strong>因果解码器架构</strong></p><p>因果解码器架构采用单向注意力掩码，以确保每个输入 token 只能关注过去的 token 和它本身。输入和输出 token 通过解码器以相同的方式进行处理。</p><p>作为这种架构的代表性语言模型，GPT 系列模型是基于因果解码器架构开发的。</p><p>到目前为止，因果解码器已被各种现有LLMs广泛采用作为LLMs的架构，如OPT、BLOOM和Gopher。</p><p><strong>前缀解码器架构</strong></p><p>前缀解码器架构（也称非因果解码器架构）修正了因果解码器的掩码机制，使其能够对前缀 token 执行双向注意力，并仅对生成的 token 执行单向注意力。</p><p>前缀解码器可以双向编码前缀序列并自回归地逐个预测输出 token，其中在编码和解码过程中共享相同的参数。</p><p>基于前缀解码器架构的现有代表性 LLM 包括 GLM-130B和 U-PaLM。</p><p>对于这三种类型的架构，我们还可以考虑通过混合专家(MoE)缩放来扩展它们，其中每个输入的神经网络权重子集被稀疏激活，例如Switch Transformer和GLaM。研究表明，通过增加专家数量或总参数大小，可以观察到实质性的性能改进。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231120183205440.png" alt="image-20231120183205440" style="zoom:80%;"><h4 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h4><p>自 Transformer推出以来，已经提出了各种改进方法来提高其训练稳定性、性能和计算效率。在这部分中，我们将讨论Transformer 的四个主要部分的相应配置，包括标准化、位置编码、激活函数、注意力和偏置。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231121162112958.png" alt="image-20231121162112958" style="zoom:80%;"><h5 id="标准化（归一化）"><a href="#标准化（归一化）" class="headerlink" title="标准化（归一化）"></a>标准化（归一化）</h5><p>训练不稳定是预训练 LLM 的一个难题。为了缓解这个问题，<strong>层标准化 (Layer Norm, LN) 被广泛应用于Transformer 架构中</strong>。</p><p>Sandwich-LN在pre-LN的基础上，在剩余连接之前增加了额外的LN，以避免值爆炸。然而，研究发现，<strong>Sandwich-LN有时不能稳定训练LLMs，可能导致训练的崩溃。</strong><br>最近，人们提出了几种先进的规范化技术来替代LN。在Gopher和Chinchilla中，由于RMS Norm在训练速度和性能上的优势，采用了RMS Norm。与LN相比，DeepNorm在训练稳定性方面表现出了更好的能力，和后标准化一起被 GLM-130B 采用。</p><p>此外，<strong>在嵌入层之后增加一个LN也可以稳定LLMs的训练。然而，它往往会导致显著的性能下降，在最近的几个LLMs中已经被移除。</strong></p><h5 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h5><p>为了获得良好的性能，在前馈网络中也需要设置合适的激活函数。在现有的 LLM 中，广泛使用 GeLU 激活函数。</p><p>在现有LLMs中，GeLU激活被广泛使用。此外，在最新的LLMs(如PaLM和LaMDA)中，也使用了GLU激活的变体，特别是SwiGLU和GeGLU变体，在实践中往往取得更好的性能。然而，与GeLU相比，它们在前馈网络中需要额外的参数(约50%)。</p><h5 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h5><p>由于 Transformer 中的自注意模块具有置换不变性，因此需要使用位置编码来注入绝对或相对位置信息以建模序列。在经典的 Transformer 中有两种绝对位置编码的变体，即正弦函数和学习的位置编码，后者通常在 LLM 中使用。</p><p>不同于绝对位置编码，相对位置编码根据键和查询之间的偏移量生成嵌入，因此它可以在比训练期间看到的序列更长的序列上表现良好，即外推。ALiBi使用基于键和查询之间距离的惩罚来偏差注意力得分。实证结果表明，与其他位置嵌入相比，该方法具有更好的零样本泛化和更强的外推能力。此外，通过基于绝对位置设置特定的旋转矩阵，RoPE中键和查询之间的分数可以通过相对位置信息计算出来，这对长序列建模很有用。因此，RoPE在一些最新的LLMs中被广泛采用。</p><h5 id="注意力机制和偏置"><a href="#注意力机制和偏置" class="headerlink" title="注意力机制和偏置"></a>注意力机制和偏置</h5><p>除了原始 Transformer 中的全自注意力机制，GPT-3 采用了更低计算复杂度的稀疏注意力机制，即分解注意力。为了有效且高效地建模更长的序列，研究者们尝试引入特殊的注意力模式或考虑显存访问（即 FlashAttention）。</p><p>此外，与原始 Transformer一样，大多数 LLM 在每个线性层和层标准化中保留了偏置</p><h4 id="预训练任务"><a href="#预训练任务" class="headerlink" title="预训练任务"></a>预训练任务</h4><p>对于训练 LLM，有两个常用的预训练任务，即语言建模和去噪自编码。</p><h6 id="语言建模"><a href="#语言建模" class="headerlink" title="语言建模"></a><strong>语言建模</strong></h6><p>Language Modeling(LM) 语言建模任务(LM)是预训练Decoder-only的LLMs最常用的目标，例如GPT3和PaLM。给定一个token 序列 x = *{x1, . . . , xn}*，LM 任务旨在基于序列中前面的 token x&lt;i，自回归地预测目标 token <em>xi</em>。通常的训练目标是最大化以下似然函数：</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231121180748353.png" alt="image-20231121180748353" style="zoom:80%;"><p>由于大多数语言任务可以转换为基于输入的预测问题来解决，因此这些仅包含解码器的 LLM 可能具有优势，可以隐式地学习如何以统一的 LM 方式完成这些任务。一些研究还表明，仅包含解码器的 LLM 可以通过自回归地预测下一个token 而自然地迁移到某些任务中，而无需微调。</p><p>LM的一个重要变体是前缀语言建模任务，它是为预训练具有前缀解码器架构的模型设计的。在计算前缀语言模型的损失时，将不使用随机选择的前缀内的 token。由于模型预训练涉及的序列中 token 较少，因此在使用相同数量的预训练 token 时，前缀语言模型的性能往往略低于传统语言模型任务 </p><h6 id="去噪自编码"><a href="#去噪自编码" class="headerlink" title="去噪自编码"></a><strong>去噪自编码</strong></h6><img src="/2024/04/24/a-survey-of-large-language-models/image-20231121180955197.png" alt="image-20231121180955197" style="zoom:80%;"><p>通过使用语言模型目标进行预训练，因果解码器架构似乎可以实现更优越的零样本和小样本泛化能力。在没有进行多任务微调的情况下，因果解码器比其他架构具有更好的零样本性能。通过扩展模型大小、数据集大小和总计算量，可以大幅提高因果解码器的性能 </p><h3 id="4-3模型训练"><a href="#4-3模型训练" class="headerlink" title="4.3模型训练"></a>4.3模型训练</h3><h4 id="优化设置"><a href="#优化设置" class="headerlink" title="优化设置"></a>优化设置</h4><h5 id="批量训练Batch-Training"><a href="#批量训练Batch-Training" class="headerlink" title="批量训练Batch Training"></a>批量训练Batch Training</h5><p>对于语言模型的预训练，现有的研究通常将<strong>批量大小（batch size）</strong>设置为较大的数字（如 2,048 个例子或 400 万个 token），以提高训练的稳定性和吞吐量。像 GPT-3 和 PaLM 这样的LLM 引入了一种新的策略，即<strong>在训练过程中动态增加批量大小，最终达到百万级别</strong>。具体而言，GPT-3 的批量大小从 3.2万逐渐增加到 320 万个 token。实证结果表明，动态调整批量大小的策略可以有效地稳定 LLM 的训练过程。</p><h5 id="学习率Learning-Rate"><a href="#学习率Learning-Rate" class="headerlink" title="学习率Learning Rate"></a>学习率Learning Rate</h5><p>现有的LLMs通常在预训练期间采用类似的预热（warm-up）和衰减（decay）策略的学习率调度计划。具体地说，在最初的0.1%到0.5%的训练步骤中，采用线性预热策略linear warm-up schedule，逐步将学习率提高到最大值，范围约为5 × 10^−5到1 × 10^−4(例如:GPT-3为6 × 10^−5)。然后在后续步骤中采用余弦衰减策略，逐渐将学习率降低到其最大值的10%左右，直到训练损失收敛。</p><h5 id="优化器Optimizer"><a href="#优化器Optimizer" class="headerlink" title="优化器Optimizer"></a>优化器Optimizer</h5><p>Adam优化器和AdamW优化器被广泛用于训练LLMs(例如GPT3)，它们基于一阶梯度优化的低阶矩的自适应估计。通常，它的超参数设置如下：<em>β</em>1 = 0*.<em>9，</em>β<em>2 = 0</em>.<em>95 和 <em>ϵ</em> = 10</em>−*8。</p><p>同时，Adafactor优化器也被用于训练LLMs(例如PaLM和T5)，这是Adam优化器的一个变体，专门用于在训练过程中节省GPU。</p><h5 id="稳定训练Stabilizing-the-Training"><a href="#稳定训练Stabilizing-the-Training" class="headerlink" title="稳定训练Stabilizing the Training"></a>稳定训练Stabilizing the Training</h5><p>在LLMs预训练过程中，往往存在训练不稳定性问题，可能导致模型崩溃。为了解决这个问题，会广泛使用权重衰减（weight decay）和梯度裁剪（gradient clipping）。通常将梯度裁剪的阈值设置为 1*.<em>0，将权重衰减率设置为 0</em>.*1。<br>然而，随着LLMs规模的扩大，也更容易出现训练损失尖峰，导致训练不稳定。为了缓解这个问题，PaLM和OPT使用了一种简单的策略，即从发生突增之前的一个检查点重新开始训练过程，并跳过可能导致问题的数据。此外，GLM发现嵌入层的异常梯度通常会导致突增，并提出缩小嵌入层梯度以缓解这个问题。</p><h4 id="可扩展的训练技术"><a href="#可扩展的训练技术" class="headerlink" title="可扩展的训练技术"></a>可扩展的训练技术</h4><p>扩展训练需要解决两个主要的技术问题是提高训练吞吐量以及将更大的模型加载到显存中。现有工作中有几种广泛使用的方法来解决上述两个挑战，即 3D 并行、ZeRO 和混合精度训练。</p><h5 id="3D并行"><a href="#3D并行" class="headerlink" title="3D并行"></a>3D并行</h5><p>3D并行实际上是三种常用的并行训练技术的组合，即数据并行、流水线并行和张量并行。</p><p>【数据并行】<br>是提高训练吞吐量的最基本方法之一。它复制模型参数和优化器状态到多个GPU上，然后将整个训练语料库分配到这些GPU。这样，每个GPU只需要处理为其分配的数据，并执行前向和后向传播以获得梯度。将进一步聚合不同GPU上计算的梯度以获得整个批次的梯度，以更新所有GPU中的模型。<br>通过这种方式，由于梯度的计算是在不同的 GPU 上独立执行的，数据并行机制是高度可扩展的，从而能够增加 GPU 的数量以提高训练吞吐量的方式。此外，这种技术在实现中很简单，大多数现有的流行的深度学习库已经实现了数据并行性，例如 TensorFlow 和 PyTorch。<br>【流水线并行】<br>流水线并行旨在将 LLM 的不同层分布在多个 GPU 中。特别是，在 Transformer 模型的情况下，流水线并行将连续的层加载到同一个 GPU 上，以降低在 GPU 之间传输计算的隐藏状态或梯度的成本。<br>为了减少流水线并行中的这些气泡（bubble overhead），GPipe和PipeDream提出了填充多批次数据和异步梯度更新以提高流水线效率的技术。<br>【张量并行】<br>张量并行也是一种常用的技术，旨在分解LLM进行多gpu加载。与流水线并行不同，张量并行侧重于分解 LLM 的张量（参数矩阵）。<br>对于LLM中的矩阵乘法操作Y = XA，参数矩阵A可以按列分解为A1和A2，那么该操作可以表示为Y=[XA1, XA2]。通过在不同的GPU上放置矩阵A1和A2，矩阵乘法操作将在两个GPU上并行调用，最终结果可以通过跨GPU通信组合两个GPU的输出来获得。<br>目前，张量并行已在几个开源库中得到支持，例如Megatron-LM，并且可以扩展到高维张量。此外，Colossal-AI也实现了高维张量的张量并行，并提出了序列并行，特别是对于序列数据，可以进一步分解Transformer模型的注意力操作。</p><h5 id="ZeRO"><a href="#ZeRO" class="headerlink" title="ZeRO"></a>ZeRO</h5><p>DeepSpeed库提出的ZeRO技术侧重于数据并行中的内存冗余问题。<br>如前所述，数据并行要求每个GPU存储LLM的相同副本，包括模型参数、模型梯度和优化器参数。然而，并非所有上述数据都需要在每个GPU上保留，这会导致内存冗余问题。<br>为了解决这个问题，ZeRO 技术旨在在每个GPU上只保留一小部分数据，而在需要时可以从其他GPU中检索其余数据。<br>具体来说，ZeRO 提供了三个解决方案，具体取决于数据的三部分如何存储，即优化器状态分区、梯度分区和参数分区。实证结果表明，前两个解决方案不会增加通信开销，第三个解决方案增加了大约 50% 的通信开销，但节省了与 GPU 数量成比例的内存。<br>PyTorch 实现了与 ZeRO 类似的技术，称为 FSDP。</p><h5 id="混合精度训练"><a href="#混合精度训练" class="headerlink" title="混合精度训练"></a>混合精度训练</h5><p>在以前的PLM(例如，BERT)中，32位浮点数，也称为FP32，主要用于预训练。近年来，为了预训练非常大的语言模型，一些研究已经开始利用16位浮点数(FP16)，这减少了内存使用和通信开销。<br>然而，现有工作发现 FP16 可能会导致计算精度损失，这会影响最终的模型性能。为了缓解这种情况，使用了一种称为Brain Floating Point (BF16) 的替代方案进行训练，它分配比 FP16 更多的指数位和更少的重要位。对于预训练，BF16 在表示精度上通常比 FP16 表现更好。</p><h5 id="总体训练建议"><a href="#总体训练建议" class="headerlink" title="总体训练建议"></a>总体训练建议</h5><p>在实践中，上述训练技术，尤其是 3D 并行，通常用于提高训练吞吐量和大型模型加载。例如，研究人员结合了 8 路数据并行、4 路张量并行和 12 路流水线并行，可以在 384张A100 GPU 上训练 BLOOM。<br>目前，DeepSpeed、Colossal-AI和Alpa等开源库可以很好地支持三种并行训练方法。为了减少内存冗余，ZeRO、FSDP 和激活重计算技术也可用于训练 LLMs，这些已经集成到 DeepSpeed、PyTorch 和 Megatron-LM 中。<br>此外，还可以利用BF16等混合精度训练技术来提高训练效率，减少GPU内存使用，尽管需要硬件(如A100 GPU)必要的支持。<br>预测模型性能和检测异常问题会非常有用，GPT-4 最近引入了一种新的机制，叫做predictable scaling，建立在深度学习堆栈上，能够使用更小的模型预测大型模型，这对于开发 LLM 可能非常有用。<br>除了上述训练策略外，提高使用LLMs的推理速度也很重要。通常，量化技术在推理阶段被广泛用于降低LLMs的时间和空间成本。<br>对于模型量化，一种流行的选择是INT8-量化。此外，一些研究工作试图开发更积极的INT4量化方法。在这些开源LLMs中，BLOOM、GPT-J和GLM发布了相应的量化模型副本。</p><h2 id="5-适配微调"><a href="#5-适配微调" class="headerlink" title="5.适配微调"></a>5.适配微调</h2><p>我们主要介绍两种适配预训练LLMs的方法，即指令微调（Instruction tuning）和对齐微调（Alignment tuning）。前一种方法主要旨在增强（或解锁）LLM 的能力，而后一种方法旨在将 LLM 的行为与人类值或偏好对齐。此外，我们还将讨论快速模型适应的Efficient tuning。</p><h3 id="5-1指令微调"><a href="#5-1指令微调" class="headerlink" title="5.1指令微调"></a>5.1指令微调</h3><p>本质上，<strong>指令调优是在自然语言形式的格式化实例集合上微调预训练的LLMs</strong>的方法，这与监督微调和多任务提示训练高度相关。</p><p>需要收集或构建指令格式（instruction-formatted）的实例。然后，我们使用这种格式的实例以有监督的方式微调LLM（例如使用seq2seq的损失进行训练）。指令微调后，LLM 可以展现出泛化到未见过任务的卓越能力。</p><h4 id="格式化实例"><a href="#格式化实例" class="headerlink" title="格式化实例"></a>格式化实例</h4><p>指令格式的实例由任务描述（称为instruction）、输入输出对(input-output pair)和少量演示(demonstration)（可选）组成。</p><p>通过收集来自不同领域（例如文本摘要、文本分类和翻译）的实例来创建有监督的多任务训练数据集。</p><p>具体来说，使用人类撰写的任务描述来增广带标注的数据集，这些描述通过解释任务目标来指导LLM 理解任务。例如，在图 5（b）中，每个问答任务的实例都添加了一个任务描述“请回答下列问题”。<strong>在指令微调之后，LLM 可以通过遵循任务描述很好地泛化到其他未见过的任务上 [28, 62, 64]。特别地，指令被证明是影响 LLM 任务泛化能力的关键因素</strong>。</p><p>关键因素：</p><p>增加指令：大量研究已经证明扩大任务数量可以极大地提高 LLM 的泛化能力。但任务数量达到一定水平时，模型性能的提升变得微不足道。将某些任务的实例数量进一步增加（例如数百个）可能会潜在地导致过拟合并影响模型性能</p><p>设计格式：指令的格式设计也是影响 LLM 泛化性能的一个重要因素。通常来说，我们可以向现有数据集的输入-输出对添加任务描述和可选的示例，其中任务描述是 LLM理解任务的最关键部分。<strong>将其他部分（例如避免事项、原因和建议）添加到指令中对 LLM 的性能提升十分轻微，甚至会产生不利的影响</strong></p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204162206898.png" alt="image-20231204162206898"></p><h5 id="格式化任务数据集"><a href="#格式化任务数据集" class="headerlink" title="格式化任务数据集"></a>格式化任务数据集</h5><p>格式化任务数据集。在提出指令调优之前，一些早期的研究[266,273,274]从不同的任务范围（如文本摘要、文本分类和翻译）中收集实例，以创建有监督的多任务训练数据集。作为指令调优实例的主要来源，使用自然语言任务描述将这些多任务训练数据集格式化非常方便。具体来说，最近的工作[28,61,62,79]用<strong>人工编写的任务描述来增强已标记的数据集，它通过解释任务目标来指示llm来理解任务</strong>。例如，在图9(a)中，为问答任务中的每个示例添加了一个任务描述“请回答这个问题”。在指令调优之后，llm可以通过遵循其任务描述[28,62,64]来很好地推广到其他不可见的任务。特别是，已经证明了指令是LLMs [62]任务泛化能力的关键因素：通过在标记的数据集上对模型进行微调，去掉任务描述，它会导致模型性能的急剧下降。为了更好地为inst生成带有标记的实例</p><h5 id="格式化人类需求"><a href="#格式化人类需求" class="headerlink" title="格式化人类需求"></a>格式化人类需求</h5><p>尽管大量的训练实例已经通过添加指令进行格式化，但它们<strong>主要来自公共的 NLP 数据集</strong>，任务描述缺乏多样性或与人类真实需求不匹配。为了解决这个问题， InstructGPT建议<strong>采用真实用户提交给 OpenAI API 的 查询作为任务描述</strong>。用户查询以自然语言表示，很适合引导出 LLM 遵循指令的能力。此外，为了丰富任务的多样性，<strong>标注者还要为真实生活中的任务编写指令，包括开放式生成、开放式问答、头脑风暴和聊天等。然后让另一组标注人员直接按照将这些指令作为输出进行回答</strong>。最后，<strong>将指令（即采集的用户查询）和期望的输出（即人工编写的答案）配对作为一 个训练实例。</strong></p><p>InstructGPT 还将这些以自然语言格式化的真实世界任务用于对齐微调（在第 5.2 节中讨论）。</p><p><strong>进一步地，GPT-4 [45] 还设计了潜在高风险的指令，并监督微调模型拒绝这些指令以确保安全。</strong></p><h5 id="格式化合成数据。"><a href="#格式化合成数据。" class="headerlink" title="格式化合成数据。"></a>格式化合成数据。</h5><p>为了减少人工注释或人工收集的负担，人们提出了几种半自动化的方法[129]来构建实例，通过将现有的实例输入到llm中，以合成不同的任务描述和实例。如图9(c)所示，自指导方法只需要大约100个实例作为初始任务池。然后，<strong>他们从池中随机选择几个实例作为演示，并提示一个LLM生成新的指令和相应的输入-输出对。在进行质量和多样性过滤之后，新生成的实例将被添加到任务池中。因此，该合成方法是生成llm的大规模指令数据的一种有效而经济的方法。</strong></p><p>总的来说：</p><p>指令多样性似乎比实例数量更重要，因为表现良好的 InstructGPT [61] 和 Alpaca [220] 使用的指令（或实例）比 Flan 系列的 LLM [62, 64] 数量更少但更加多样化。</p><p>此外，邀请标注者构建人类真实需求的任务比使用特定数据集的任务更有用。</p><h4 id="指令微调策略"><a href="#指令微调策略" class="headerlink" title="指令微调策略"></a>指令微调策略</h4><p>与预训练不同，因为只需要使用较<strong>少数量的实例</strong>进行训练，指令微调通常更加高效。<strong>指令微调可以被视为一个有监督的训练过程</strong>，其优化过程与预训练有一些不同，比如训练目标函数（如序列到序列的损失）和优化参数设置（如更小的批量大小和学习率）。</p><p><strong>平衡数据分布：</strong>由于指令微调涉及多种任务的混合，因此在微调过程中平衡不同任务的比例非常重要。一种广泛使用的方法是实例比例混合策略，即将所有数据集合并，然后从混合数据集中按比例采样每种实例。此外，根据最近的研究发现，提高高质量数据集（例如 FLAN和 P3）的采样比例通常可以带来性能提升。同时，在指令微调期间通常会设置一个最大容量，以限制数据集中可以包含的最大实例数，这是为了防止较大的数据集挤占整个采样集合。在实践中，根据不同的数据集，最大容量通常设置为几千或几万个实例。</p><p><strong>结合指令微调和预训练：</strong>为了使微调过程更加有效和稳定， OPT-IML在指令微调期间加入了预训练数据，这可以看作是对模型的正则化（regularization）。此外，一些研究并没有使用单独的两阶段训练过程（预训练和指令微调），而是尝试混合使用预训练数据（即纯文本）和指令微调数据（即指令格式数据），用多任务学习的方式从头训练模型。具 体而言，GLM-130B和 Galactica将指令格式数据集作为预训练语料库的一小部分来预训练 LLM，这有可能同时获得预训练和指令微调的优势。</p><h3 id="5-2对齐微调"><a href="#5-2对齐微调" class="headerlink" title="5.2对齐微调"></a>5.2对齐微调</h3><p>LLM 在多个自然语言处理任务上展示出了惊人的能力，但是, 这些模型有时可能表现出预期之外的行为，<strong>例如编造虚假信息、追求不准确的目标，以及产生有害的、误导性的和有偏见的表达</strong>。对于 LLM 而言, <strong>模型参数的预训练使用了语言建模的目标，即用单词预测进行预训练，但这没有考虑到人类的价值观或偏好。</strong>为了避免这些预期外的行为，一些研究提出了<strong>人类对齐</strong>，使得 LLM 的行为能够符合人类期望。但是, 与原先的预训练和适配微调（例如指令微调）相比, <strong>对齐微调需要考虑的标准（例如有用性, 诚实性和无害性）十分不同</strong>。已有研究表明<strong>对齐微调可能会在某种程度上损害 LLM 的通用能力</strong>，这在相关研究中被称为<strong>对齐税</strong>。</p><p>对齐的标准：我们选取三个具有代表性的对齐标准（即有用性、诚实性、无害性）</p><p>无害性：无害性要求模型生成的语言不得是冒犯性或歧视性的。</p><h4 id="人类反馈的收集"><a href="#人类反馈的收集" class="headerlink" title="人类反馈的收集"></a>人类反馈的收集</h4><p><strong>标注人员的选择：</strong>InstructGPT通过评估标注人员与研究人员之间意图的一致性来选择标注人员。具体而言，研 究人员首先标注少量的数据，然后衡量他们自己和标注人员之间的标注一致性。选择一致性最高的标记者继续后续的标注工作。</p><p><strong>人类反馈的收集：</strong>1）基于<strong>排序</strong>的方法：引 入了 Elo 评分系统 ，通过一一比较所有候选输出结果来生成 一个偏好排序。候选输出的排序将用于调整模型更倾向的输出，从而产生更可靠和更安全的结果。 2）基于问题的方法：通过回答研究人员设计的特定问题，标注人员可以提供更详细的反馈，这些问题能够覆盖不同的对齐标准以及其他对 LLM 的约束条件。特别地，在 WebGPT中，为了帮助模型从检索到的文档中过滤和利 用相关信息，标注人员需要回答关于检索到的文档对于回答给定输入是否有帮助的选择题。 3）基于规则的方法：Sparrow不仅选择了标注人员挑选的最佳回复，<strong>还设计了一系列规则来测试模型生成的回复是否符合有用、正确和 无害的对齐标准</strong>。</p><p>通过这种方式，可以获得两种人类反馈数据：（1）通过成对比较模型生成的输出的质量来获得回复偏好反馈，以及（2）通过收集来自人类标注者的评估（即，指示生成的输出在多大程度上违反了规则的分数）来获得规则违反反馈。</p><p>GPT-4 利用一组（基于 GPT-4 本身的）<strong>零样本分类器作为基于规则的奖励模型，可以自动地确定模型生成的输出是否违反了一组人类编写的规则。</strong></p><h4 id="基于人类反馈的强化学习"><a href="#基于人类反馈的强化学习" class="headerlink" title="基于人类反馈的强化学习"></a>基于人类反馈的强化学习</h4><p>为了使 LLM 与人类价值观保持一致，人们提出了基于人类反馈的强化学习（ <em>Reinforcement Learning from Human Feedback</em>， RLHF），使用收集到的人类反馈数据对 LLM 进行微调，有助于改进对齐的指标。RLHF 采用强化学习（RL）算法（例如，近端策略优化（Proximal Policy Optimization, PPO））通过学习奖励模型使 LLM 适配人类反馈。</p><p><strong>基于人类反馈的强化学习系统：</strong> RLHF 系统主要包括三个关键组件：要对齐的 <strong>PLM</strong>、从人类反馈中学习的<strong>奖励模型</strong>，以 及训练 LM 的 <strong>RL 算法</strong>。具体来说，PLM 通常是一个生成模 型，它使用现有的 PLM 参数进行初始化。例如，OpenAI 在其 第一个主流的 RLHF 模型 InstructGPT [61] 中使用 1750 亿 参数量的 GPT-3。此外，<strong>奖励模型（RM）</strong> 提供（学习得到的）指导信号，这些信号反映了人类对 LM 生成的文本的偏好，通常以标量值的形式表示。奖励模型通 常具有两种形式：经过微调的 LM 或使用人类偏好数据重新 训练的 LM。</p><p><strong>基于人类反馈的强化学习的关键步骤</strong>：下图说明了 RLHF 的 整个三步过程，具体如下所述。</p><p><strong>1） 监督微调：</strong>为了使 LM 具有初步执行所需行为的能力， 通常需要收集一个包含输入提示（指令）和所需输出的有监督数据集，以对 LM 进行微调。<strong>这些提示和输出可以在确保任务多样性的情况下由人工标注人员针对某些特定任务编写</strong>。例 如，InstructGPT 要求人工标注者编写提示（例如，“列出五个关于我如何重拾对职业热情的想法”）和一些生成式任 务（如开放域问答、头脑风暴、聊天和重写）的期望输出。</p><p>请注意，在特定设置或场景中，第一步是可选的。</p><p><strong>2）训练奖励模型：</strong>第二步是使用人类反馈的数据<strong>训练RM。</strong> 具体来说，我们向 LM 中输入采样的提示（来自监督数据集 或人类生成的提示），以生成一定数量的输出文本，然后邀请 人工标注员为这些输入-输出对标注偏好。标注过程可以以多种形式进行，常见的做法是对生成的候选文本进行排序标注， 这样可以减少因标注者不同带来的差异。最后，训练 RM 预测人类偏好的输出。<strong>在 InstructGPT 中，标注员将模型生成 的输出从最好到最差进行排名，然后训练 RM（即 60 亿参数 量的 GPT-3）来预测排名。</strong></p><p><strong>3）强化学习微调：</strong>在这一步骤中，LM 的对齐微调可以被 形式化为 RL 问题。在这种情况中，RL 问题的策略（policy） 由 PLM 给出（将提示作为输入并返回输出文本），行动空间 （action space）是 LM 的词表，状态（state）是目前生成的 token 序列，奖励（reward）则由 RM 提供。为了避免 LM 显著偏离初始（微调前）的模型，通常在奖励函数中纳入一项 惩罚项。例如，InstructGPT 在使用 PPO 算法对抗 RM 来 优化 LM 时，<strong>对于每个输入提示，InstructGPT 计算当前 LM 和初始 LM 生成的结果之间的 KL 散度作为惩罚项</strong>。值得注 意的是，可以通过多次迭代第二步和最后一步来更好地对齐LLM。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204145938232.png" alt="image-20231204145938232" style="zoom:67%;"><h3 id="5-3参数高效微调方法"><a href="#5-3参数高效微调方法" class="headerlink" title="5.3参数高效微调方法"></a>5.3参数高效微调方法</h3><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204150735410.png" alt="image-20231204150735410"></p><p>参数高效微调（parameter-efficient fine-tuning）是一个重要的课题，旨在减少可训练参数的数量，同时尽可能保持良好的性能</p><h4 id="Adapter-Tuning"><a href="#Adapter-Tuning" class="headerlink" title="Adapter Tuning"></a>Adapter Tuning</h4><p>Adapter tuning将小型神经网络模块（称为适配器）融入Transformer模型。为了实现适配器模块，提出了一种bottleneck架构，该架构首先将原始特征向量压缩到较小的维度（然后进行非线性变换），然后将其恢复到原始维度。<br>Adapter模块将集成到每个Transformer层中，通常在Transformer层的两个核心部分（即注意力层和前馈层）中的每一个之后使用串行插入。作为替代方案，并行Adapter也可以用在Transformer层中，其中它相应地将两个Adapter模块与注意力层和前馈层并行放置。<br>在微调过程中，Adapter模块将根据特定的任务目标进行优化，而原始语言模型的参数在此过程中被冻结。</p><h4 id="Prefix-Tuning"><a href="#Prefix-Tuning" class="headerlink" title="Prefix Tuning"></a>Prefix Tuning</h4><p>前缀调优为语言模型中的每个Transformer层预先排列一系列前缀，这些前缀是一组可训练的连续向量。这些前缀向量是特定于任务的，可以被视为虚拟token embedding。<br>为了优化前缀向量，已经提出了一种重参数化技巧，通过学习一个MLP函数将一个较小的矩阵映射到前缀的参数矩阵，而不是直接优化前缀。已经证明，这个技巧对稳定训练是有用的。优化后，映射函数将被丢弃，只保留导出的前缀向量，以提高特定任务的性能。<br>由于只训练前缀参数，因此可以实现参数高效的模型优化。与前缀调优类似，p-tuning v2将layer-wise的prompt向量融合到Transformer架构中，专门用于自然语言理解，该架构还利用多任务学习来联合优化共享prompt。</p><h4 id="Prompt-Tuning"><a href="#Prompt-Tuning" class="headerlink" title="Prompt Tuning"></a>Prompt Tuning</h4><p>与prefix tuning不同，prompt tuning主要侧重于在输入层融入可训练的提示向量。<br>根据离散提示方法，它通过包含一组soft prompt tokens（以自由形式或前缀形式）来增强输入文本，然后采用提示增强输入来解决特定的下游任务。P-tuning提出了一种结合context、prompt和target tokens的自由形式，可以应用于自然语言理解和生成的架构。他们通过双向LSTM进一步学习soft prompt tokens的表示。另一种代表性的方法名为prompt tuning，直接在输入前加前缀提示。在训练过程中，根据特定任务的监督，只学习prompt embedding。<br>然而，由于该方法在输入层仅包括少量可训练参数，已经发现其性能在很大程度上取决于底层语言模型的模型能力。<br>这里的Prompt Tuning专门指的只在输入层包含prompt tokens的方法。</p><p><strong>Low-Rank Adaptation（LoRA）</strong><br>LoRA对每个密集层的更新矩阵施加了低秩约束，以减少适配下游任务的可训练参数。<br>考虑优化参数矩阵W的情况。更新过程可以用一般形式写成：W← W+∆W。LoRA的基本思想是冻结原始矩阵W∈Rm×n，同时通过低秩分解矩阵逼近参数更新∆W，即∆W=A·B^T，其中A∈Rm×k和B∈Rn×k是任务适配的可训练参数，r &lt;&lt; min(m，n)是降低的秩。<br>LoRA的主要优点是它可以在很大程度上节省内存和存储使用（例如，VRAM）。此外，只能保留单个大模型副本，同时保留许多特定于任务的低秩分解矩阵，以适应不同的下游任务。<br>此外，一些研究还讨论了如何以更原则化的方法设置秩，例如，基于重要性分数的分配和无搜索的最优秩选择。</p><h2 id="6-模型使用"><a href="#6-模型使用" class="headerlink" title="6.模型使用"></a>6.模型使用</h2><p>经过预训练或适配微调之后，使用 LLM 的主要方法是为解决各种任务设计适当的提示策略。一种典型的提示方法是将任务描述和（或）示范（demonstration）以自然语言文本的形式表达的上下文学习（<em>in-context learning, ICL</em>）。此外，采用思维链提示（<em>chain-of-thought prompting</em>）可以通过将一系列中间推理步骤加入提示中来增强 ICL。</p><p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231204151041209.png" alt="image-20231204151041209"></p><h3 id="上下文学习"><a href="#上下文学习" class="headerlink" title="上下文学习"></a>上下文学习</h3><p>此外，ICL 还与指令微调（在5.1中已讨论）有着密切的联系，因为它们都将任务或样例转化为自然语言的形式。然而，指令微调需要微调 LLM来增强适配，而 ICL 仅仅是以提示的方式来使用LLM。指令微调可以提高 LLM 执行目标任务的 ICL 能力，尤其是在零样本设置时（仅使用任务描述）。</p><p>ICL使用格式化的自然语言提示，包括任务描述和/或一些任务示例作为演示。基于任务演示，LLM可以在没有显式梯度更新的情况下识别并执行新任务。<br>（当ICL在GPT-3的论文中被引入时，它最初被定义为任务描述和演示示例的组合，其中任何一个组件都是可有可无的。根据这个定义，当LLM需要只使用任务描述来解决没见过的任务时，它也可以被认为是执行ICL来解决任务，而ICL能力可以通过指令调优来增强。）<br>由于ICL的性能在很大程度上依赖于示范(demonstrations)，因此在提示中正确设计演示是一个重要问题。从三个方面介绍 ICL 的示范设计，即<strong>示范选择、格式和顺序。</strong></p><p><strong>示范选择：</strong> 主要方法有两种，被称作启发式方法和基于 LLM 的方法。</p><p>【启发式方法】<br>一些研究使用基于k-NN的检索器来选择与query语义相关的示例。<br>然而，他们为每个示例单独执行选择，而不是将示例集合作为一个整体进行评估。为了解决这个问题，提出了基于多样性的选择策略，为特定任务选择最具代表性的示例集合。</p><p>【基于LLM的方法】<br>另一路工作是通过使用LLM来选择演示。例如，<strong>LLM可以用于根据添加示例后的性能增益直接测量每个示例的信息性</strong>。此外，EPR提出了一种两阶段检索方法，该方法<strong>首先用无监督方法（例如，BM25）检索类似的样本，然后使用密集检索器（用LLM标注的阳性和阴性样本训练）对它们进行排序。</strong><br>作为一种替代方法，可以将演示选择任务形式化为RL问题，其中LLM作为奖励函数，为训练策略模型提供反馈。由于LLM在文本注释方面表现良好，最近的一些研究在没有人为干预的情况下将LLM本身用作演示生成器。</p><p><strong>格式</strong><br>选择任务样本后，下一步是将它们集成并格式化为LLM的自然语言提示。一个简单的方法是用相应的输入输出对实例化预定义的模板。<br>为了构建更具信息性的模板，最近的研究考虑添加任务描述或通过思维链提示增强LLM的推理能力。<br>为了降低注释成本，提出了一种半自动化方法，即<strong>使用由人工编写的任务描述组成的种子集来指导LLM为新任务生成任务描述。</strong><br>作为两种具有代表性的方法，<strong>Auto-CoT利用带有零样本提示“Let’s think step by step”的LLM来生成中间推理步骤，而least-to-most prompting首先询问LLM以执行问题分解，然后利用LLM根据之前解决的中间答案顺序解决子问题。</strong></p><p><strong>顺序</strong><br><strong>LLM有时会受到近因偏差的影响，即他们倾向于重复接近演示结束的答案</strong>。因此，以合理的顺序安排演示（即任务示例）是很重要的。<br>早期的工作提出了几种启发式方法来快速找到一个好的顺序。例如，<strong>可以直接根据它们与嵌入空间中查询的相似性来组织演示：越相似，越接近结尾。</strong><br>此外，全局和局部熵度量可用于对不同的演示顺序进行评分。<br>为了整合更多的任务信息，最近的一些研究提出<strong>将压缩和传输任务标签所需的代码长度最小化，这受到了信息论的启发</strong>。<br>然而，这些方法需要额外的标注数据作为验证集，以评估特定演示顺序的性能。为消除这种需要，<strong>可以从LLM本身采样验证数据。</strong></p><h4 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h4><p> ICL 的能力随着模型规模的增大而增强。然而，一些研究表明，<strong>小规模的 PLM 也可以通过特别设计的训练任务表现出强大的 ICL 能力。</strong>训练任务的设计是影响 LLM 的 ICL 能力的一个重要因素。</p><p>除了训练任务之外，近期的一些研究还探索了 ICL 与预训练语料之间的关系 [260, 265, 266]；研究表明，ICL 的性能主要<strong>取决于预训练语料的来源而非规模</strong> [266]。另一项研究 [265]深入分析了训练数据分布的影响；他们发现，<strong>当训练数据可以被聚类成许多不常见的类别，而不是均匀分布时，模型会表现出 ICL 的能力。</strong></p><p><strong>LLMs怎样执行ICL</strong><br>在推理阶段，研究人员专注于基于给定的演示来分析ICL能力是如何运行的，因为不涉及显式学习或更新。他们通常从梯度下降的角度进行分析，并将ICL视为隐式微调。<br>在这个框架下，ICL过程可以解释如下：<strong>通过前向计算，LLM生成关于演示的元梯度，并通过注意力机制隐式地执行梯度下降。实验也表明，LLM中的某些注意力头能够执行与任务无关的原子操作（例如，复制和前缀匹配），这与ICL能力密切相关。</strong><br>为了进一步探索ICL的工作机制，一些研究将ICL抽象为一个算法学习过程。具体而言，LLM在预训练期间基本上通过其参数对隐式模型进行编码。通过ICL中提供的例子，LLM可以实现诸如梯度下降之类的学习算法，或者直接计算闭式解，以在前向计算期间更新这些模型。在这个解释框架下，已经表明LLM<strong>可以有效地学习简单的线性函数，甚至可以使用ICL学习一些复杂的函数，如决策树</strong>。</p><img src="/2024/04/24/a-survey-of-large-language-models/image-20231206143337223.png" alt="image-20231206143337223" style="zoom:80%;"><h3 id="思维链提示"><a href="#思维链提示" class="headerlink" title="思维链提示"></a>思维链提示</h3><p>思维链（Chain-of-Thought，CoT）是一种改进的提示策略，用于提高LLM在复杂推理任务中的性能，如算术推理、常识推理和符号推理。CoT没有像ICL那样简单地用输入输出对构建提示，而是结合了中间推理步骤，这些步骤可以将最终输出引入提示。</p><p><strong>小样本思维链 Few-shot CoT</strong><br>Few-shot CoT是ICL的一种特殊情况，它通过融合CoT推理步骤，将每个演示〈input，output〉扩充为〈input，CoT，output〉。<br>【CoT prompt的设计】<br>作为一种直接的方法，<strong>研究表明，使用不同的CoT（即每个问题的多个推理路径）可以有效地提高它们的性能。</strong><br><strong>另一个直观的想法是，具有更复杂推理路径的提示更有可能引发LLM的推理能力，这可以导致生成正确答案的准确性更高。然而，这两种方法都依赖于带标注的CoT数据集。</strong><br>为了克服这一限制，Auto-CoT建议利用Zero-shot-CoT，通过专门提示LLM来生成CoT推理路径，从而消除了手动操作。为了提高性能，Auto-CoT进一步将训练集中的问题划分为不同的聚类，然后选择最接近每个聚类中心的问题，这应该很好地代表训练集中的提问。<br>尽管Few-shot CoT可以被视为ICL的一种特殊提示情况，但与ICL中的标准提示相比，演示的顺序似乎影响相对较小：在大多数任务中，重新排序演示只会导致小于2%的性能变化。<br>【增强的CoT策略】<br>除了丰富上下文信息外，CoT提示还提供了更多选项来推断给定问题的答案。现有的研究主要集中在生成多条推理路径，并试图在得出的答案中找到共识。例如，在生成CoT和最终答案时，提出了self-consistency作为一种新的解码策略。<strong>它首先生成几个推理路径，然后对所有答案进行综合</strong>（例如，通过在这些路径中投票来选择最一致的答案）。self-consistency在很大程度上提高了CoT推理的性能，甚至可以改进一些CoT提示通常比标准提示差的任务（例如，闭书问答和自然语言推理）。<br>此外，作者在[283]中将自一致性策略扩展到更通用的集成框架（扩展到提示上的集成），他们发现<strong>不同的推理路径是提高CoT推理性能的关键。</strong><br>相反，其他研究训练评分模型来测量生成的推理路径的可靠性，或者在自己生成的推理路径上继续训练LLM以提高性能。</p><p><strong>零样本思维链 Zero-shot CoT</strong><br>与Few-shot CoT不同，Zero-shot CoT在prompt中不包括人工标注的任务演示。相反，它直接生成推理步骤，然后使用生成的CoT来导出答案。<br>Zero-shot CoT最早在中[281]提出，其中LLM首先由“Let’s think step by step”提示生成推理步骤，然后由“Therefore, the answer is”提示得出最终答案。他们发现，当模型规模超过一定规模时，这种策略会大大提高性能，但对小规模模型无效，显示出显著的<strong>涌现能力模式</strong>。<br>为了在更多的任务上解锁CoT能力，Flan-T5和Flan-PaLM进一步在CoT标注上执行指令调优，并且改进了在不可见任务上的零样本性能。</p><p>（1）什么时候CoT对LLMs有用<br>由于CoT是一种涌现能力，它只对足够大的模型（例如，通常包含10B或更多的参数）有积极影响，但对小模型没有影响。<br>此外，由于CoT通过中间推理步骤增强了标准提示，因此它主要有效地改进了需要逐步推理的任务，如算术推理、常识推理和符号推理。然而，对于不依赖于复杂推理的其他任务，它可能显示出比标准提示更差的性能，例如GLUE的MNLI-m/mm、SST-2和QQP。<br>（2）为什么LLMs可以执行CoT推理<br>【CoT能力的来源】<br>关于CoT能力的来源，<strong>人们普遍假设它可以归因于对代码的训练，因为在代码上训练的模型显示出强大的推理能力</strong>。从直觉上讲，代码数据通过算法逻辑和编程流程进行了良好的组织，这可能有助于提高LLM的推理性能。然而，<strong>这一假设仍然缺乏消融实验的公开报道证据</strong>（有和没有代码训练）。<br>此外，<strong>指令调优似乎不是获得CoT能力的关键原因</strong>，因为经验表明，对非CoT数据的指令调优并不能提高保持的CoT基准的性能。<br>【prompting组件的作用】<br><strong>CoT提示和标准提示之间的主要区别是在最终答案之前加入了推理路径。</strong><br>因此，一些研究人员调查了推理路径中不同成分的影响。具体而言，最近的一项研究确定了CoT提示中的三个关键组成部分，即<strong>symbols（例如，算术推理中的数字量）、patterns（例如，数学推理中的方程）和text（即，不是符号或模式的其余tokens）</strong>。结果表明，<strong>后两个部分（即patterns和text）对模型性能至关重要，删除其中任何一个都会导致性能显著下降</strong>。然而，<strong>symbols和patterns的正确性似乎并不重要。</strong>此外，<strong>text和patterns之间存在共生关系：text帮助LLM生成有用的patterns，patterns帮助LLM理解任务并生成有助于解决问题的text。</strong>总之，CoT提示为诱导LLM的推理能力提供了一种通用而灵活的方法。也有一些初步尝试将该技术扩展到解决多模态任务和多语言任务。除了将LLM与ICL和CoT直接结合使用外，最近的一些研究还探讨了如何将LLM的能力专门化到特定任务，这被称为模型专门化。例如，[294]中的研究人员通过微调LLM生成的CoT推理路径上的小规模Flan-T5[64]，专门研究LLM的数学推理能力。模型专业化也可用于解决各种任务，如问答、代码合成和信息检索。</p><p>本文最后在一下几个方面，介绍了大语言模型(LLM)的挑战和未来方向：</p><ol><li>理论和原理：<ul><li>挑战：<ul><li>大语言模型(LLM)的运行机制目前还不是非常的明朗，例如：大模型的涌现能力出现的原因。</li><li>大语言模型(LLM)如何通过非常大且深的神经网络分配、组织和利用信息。</li><li>理解、描述和解释大语言模型(LLM)的能力或行为的正式理论和原理仍然缺失。</li></ul></li><li>未来方向：<ul><li>对于大语言模型(LLM)的涌现能力的解释和研究。</li><li>对于大语言模型(LLM)对于信息的利用、分配、组织方式进行研究。</li><li>建立和完善理解、描述和解释大语言模型(LLM)的能力或行为的理论和原理。</li></ul></li></ul></li><li>模型架构：<ul><li>挑战：<ul><li>减少标准自注意力机制所带来的时间复杂度是一个实际应用时重要的考虑因素。</li><li><code>灾难性遗忘</code>一直是神经网络的长期挑战，其对大语言模型(LLM)也有负面影响。</li></ul></li><li>未来方向：<ul><li>研究如何构建大语言模型(LLM)中更高效的<code>Transformer</code>变体十分重要，例如 GPT-3 中已经使用了<code>稀疏注意力</code>。</li><li>考虑将现有架构扩展到更具灵活性的机制或模块，以有效支持数据更新和任务专用化。</li></ul></li></ul></li><li>模型训练：<ul><li>挑战：<ul><li>预训练强大的大语言模型(LLM)需要消耗巨大的算力，并且对<code>数据质量</code>和<code>训练技巧</code>要求很高。</li></ul></li><li>未来方向：<ul><li>开发更系统、经济的预训练方法以优化大语言模型(LLM)变得尤为重要，同时考虑到模型有效性、效率优化和训练稳定性等因素。</li></ul></li></ul></li><li>模型应用：<ul><li>挑战：<ul><li>由于在实际应用中微调的成本非常高，提示已成 为使用大语言模型(LLM)的主要方法，但是提示设计时需要大量人力。</li><li>一些复杂任务（例如形式证明和数值计算）需要特定的知识或逻辑规则，这些规则可能无法用自然语言很好地表达或通过示例演示。</li></ul></li><li>未来方向：<ul><li>研究如何自动生成有用且高校的提示以解决各种任务。</li><li>开发更具信息量和灵活性的任务格式化方法以进行提示非常重要。</li></ul></li></ul></li><li>安全与对齐：<ul><li>挑战：<ul><li>大语言模型(LLM)倾向于产生幻觉， 这些文本看似合理，但可能在事实上是错误的。例如：ChatGPT 刚发布的时候存在”一本正经的胡说八道”的情况。</li><li>现有的方法避免大语言模型(LLM)产生幻觉或者生成一些有毒，有害，有偏见的文本主要是讲人工纳入训练循环 来开发良好对齐的大语言模型(LLM)，并使用人类反馈强化学习(RLHF)。但是这严重依赖专业标注者的高质量人类反馈数据，这使得它在实践中难以适当实施。</li></ul></li><li>未来方向：<ul><li>研究如何避免大语言模型(LLM)产生幻觉或者生成一些有毒，有害，有偏见的文本。</li><li>有必要改进人类反馈强化学习(RLHF)框架以减少人类标注者的工作量，并寻求更高效的、具有保证数据质量的标注方法，例如LLM可以用于辅助标注工作。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> Survey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/23/hello-world/"/>
      <url>/2024/04/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>尽量减少恶意软件的传播</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> init <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">M</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// M - 移除某节点res的收益</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMalwareSpread</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>initial<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minNode <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>graph<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>            init<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            minNode <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minNode<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// System.out.println("i:"+String.valueOf(i)+",size:"+String.valueOf(size));</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">M</span> <span class="token operator">=</span> size<span class="token punctuation">;</span>                res <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>visited<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> minNode <span class="token operator">:</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 计算删除某节点n的收益=从该点扩散到的非initial中点的长度</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> graph<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>init<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ul><li>不支持本地图片</li><li>网络图片测试如下</li></ul><p><img src="https://hexo.io/themes/screenshots/Matery@2x.jpg" alt="Matery"></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
