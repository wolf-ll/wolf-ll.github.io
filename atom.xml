<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wolf-ll&#39;s blog</title>
  
  <subtitle>明日香的笔记</subtitle>
  <link href="http://wolf-ll.github.io/atom.xml" rel="self"/>
  
  <link href="http://wolf-ll.github.io/"/>
  <updated>2025-09-16T07:22:38.621Z</updated>
  <id>http://wolf-ll.github.io/</id>
  
  <author>
    <name>wolf-ll</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LLAMA-VID</title>
    <link href="http://wolf-ll.github.io/2025/09/14/llama-vid/"/>
    <id>http://wolf-ll.github.io/2025/09/14/llama-vid/</id>
    <published>2025-09-14T14:28:20.000Z</published>
    <updated>2025-09-16T07:22:38.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LLAMA-VID"><a href="#LLAMA-VID" class="headerlink" title="LLAMA-VID"></a>LLAMA-VID</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li>在这项工作中，我们提出了一种新颖的方法LLaMA-VID来解决视觉语言模型（VLMs）在视频和图像理解中的token生成挑战。</li><li>当前的VLMs虽然在图像描述和视觉问答等任务上表现出色，但在处理长视频时由于视觉token过多而面临计算负担。</li><li>LLaMA-VID通过用两个不同的token来表示每一帧，即上下文token和内容token，来解决这个问题。</li><li>上下文token<strong>根据用户输入编码整体图像上下文</strong>，而内容token封装了每一帧中的视觉线索。</li><li>这种双token策略显著减少了长视频的负载，同时保留了关键信息。</li><li>通常，LLaMA-VID使现有框架能够支持长达一小时的视频，并通过额外的上下文token提高了其上限。</li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li><p>背景：视觉语言模型（VLM）已经将大模型（LLM）的生成能力扩展到了视觉数据，在图像描述、视觉问答等任务展现出先进性。然而，长视频背景下，需要过多的token来表示连续的帧。计算需求随着视频长度的增加而增加，从而限制了VLM在广泛视频中的实际应用。</p></li><li><p><strong>问题​</strong>​：现有视觉语言模型（VLMs）在处理长视频时面临​<strong>​视觉Token爆炸​</strong>​问题。例如：</p><ul><li><p>单帧图像需32-256个Token（如BLIP-2需32，LLaVA需256）</p></li><li><p>10,000帧视频需超32万Token，超出当前VLMs处理极限（通常上限2-4K Token）</p></li></ul></li><li><p><strong>​后果​</strong>​：计算负担过重，无法支持小时级长视频理解，且传统时间压缩方法（temporal compression）会丢失关键信息。</p></li><li><p><strong>现有方法：</strong>代表性查询（Representative Queries）：通过​<strong>​少量高层语义向量​</strong>​表示整个视频帧，替代原始像素级特征，显著减少Token数量。</p><ul><li><p><strong>​​Video-LLaMA [62]​</strong>​</p><ul><li><p>使用预训练视觉编码器（如BLIP-2）提取帧特征。</p></li><li><p>引入​<strong>​可学习的Query向量​</strong>​（通常32个）与帧特征交互，通过交叉注意力聚合关键信息。</p></li><li><p>仅将Query向量输入LLM（而非所有空间特征），压缩率超​<strong>​90%​</strong>​（如256 Token → 32 Token）。</p></li><li><p><strong>​局限​</strong>​：Query数量固定，无法自适应指令；长视频中语义信息可能丢失。</p></li></ul></li><li><p><strong>​VideoChat [30]​</strong>​</p><ul><li><p><strong>​</strong>设计​<strong>​时空记忆模块​</strong>​，缓存关键帧的Query向量；</p></li><li><p>通过注意力机制检索与当前问题相关的记忆片段。</p></li><li><p><strong>​优势​</strong>​：减少冗余计算，但需预定义查询数量。</p></li></ul></li></ul></li><li><p>现有方法：时序压缩（Temporal Compression），===下面的代表工作原理待确认是否准确===</p><ul><li><p><strong>Video-ChatGPT [39]​</strong>​</p><ul><li><p><strong>​</strong>​<strong>​空间压缩​</strong>​：每帧用ViT提取特征（如16×16网格）；</p></li><li><p><strong>时间压缩​</strong>​：对连续帧特征做​<strong>​3D平均池化​</strong>​（如每4帧合并为1帧）；</p></li><li><p>将压缩后的时空特征输入LLM。</p></li><li><p><strong>​压缩率​</strong>​：若按4:1合并帧，Token数减少​<strong>​75%​</strong>​。</p></li></ul></li><li><p><strong>​Valley [38]​</strong>​</p><ul><li><p><strong>​</strong>使用​<strong>​时间卷积网络（TCN）​</strong>​ 学习帧间依赖；</p></li><li><p>输出关键时间步的特征作为代表（类似视频摘要）。</p></li></ul></li></ul></li><li><p>本文方法：用两个不同的token来表示每一视频帧：上下文标记（context token）和内容标记（content token）。​</p><ul><li><p><strong>​Context Token​</strong>​：基于用户指令动态生成，聚焦与问题相关的全局上下文。</p></li><li><p><strong>​Content Token​</strong>​：编码帧内视觉细节，可根据计算资源调整粒度（视频：1 Token/帧；图像：最高576 Token/帧）。</p></li></ul></li><li><p>首先使用vit提取图像特征，随后利用跨模态设计进行指令引导查询（Bert、Blip2），这些查询承载了用户的交互式意图。</p><ul><li><p>这些查询与设计的上下文注意力模块中先前生成的图像特征交互，得到上下文token。</p></li><li><p>对图像特征进行平均池化，以制定适应不同设置的token，形成内容token。</p></li></ul></li><li><p>例如，采用全局池来保持视频输入的效率，同时通过单个图像输入的更多令牌来保留细节。随后，上下文和内容标记被投影到具有简单线性层的LLM空间中，以进行最终预测。此外，为了更好地支持VLM中长达一小时的视频，我们构建了一个基于指令的数据集，其中包含9K个电影级对话，用于情节推理和细节理解。</p></li><li><p>优势：使用双令牌范式，每个帧只需两个令牌即可有效编码，这使现有的LLM能够支持长视频。另一方面，上下文标记聚合了每个图像的最具信息量的特征，这进一步通过额外的标记扩展了VLM的上限。</p></li></ul><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="LLM"><a href="#LLM" class="headerlink" title="LLM"></a>LLM</h3><p>随着大型语言模型 (LLM) 的发展，自然语言处理 (NLP) 领域取得了巨大的进步。 Transformer [55] 成为一个重要的里程碑，随后的语言模型 [15, 35, 64] 展现出非凡的能力。 GPT [6] 通过利用生成式预训练 Transformer 进行自回归预测，彻底改变了该领域，这被证明是一种强大的语言建模范式。 最近的突破性工作，如 ChatGPT [43]、GPT-4 [44] 和 LLaMA [53]，将界限推向了更远。 这些模型在海量文本数据上进行训练，在复杂的语言任务中展现出非凡的能力。 为了利用预训练 LLM 的潜力，指令调优[56, 45] 是获得高质量输出的关键组成部分。 这种策略广泛应用于开源模型，如 Alpaca [52] 和 Vicuna [13]，它们使用专门设计的指令对改进了 LLaMA [53]。 还有一些研究 [57, 60] 利用 LLM 的推理能力并调用预定义工具来进行视觉应用。 与它们不同，我们在这项工作中收集了包含文本、图像和视频的多模态指令数据，用于增强 LLM 进行长视频处理的能力。</p><h3 id="VLM"><a href="#VLM" class="headerlink" title="VLM"></a>VLM</h3><p>计算机视觉和 NLP 的进步导致了视觉语言模型 (VLM) 的出现，这些模型将视觉模型与语言模型相结合，以进行跨模态理解 [11, 58] 和推理 [19, 37, 27]。 CLIP [46] 和 ALIGN [24] 等开创性的大型视觉语言模型 (VLMs) 将语言模型扩展到了视觉语言任务。 近期的进展表明，人们越来越重视利用大型语言模型 (LLMs) 的能力。 值得注意的是，Flamingo [2] 和 BLIP-2 [29] 利用网络规模的图像-文本对进行跨模态对齐，从而提高了学习性能。 为了进一步挖掘此类预训练模型的潜力，InstructBLIP [14] 和 MiniGPT-4 [65] 基于 BLIP-2 构建了高质量的指令对，并取得了优异的结果。 与此同时，LLaVA [33] 采用了一个简单的线性投影器，该投影器具有少量可学习参数，以对齐 LLaMA 的图像和文本空间。 鉴于定制的指令数据，这种简单的方法展示了强大的能力。 为了支持大型语言模型 (LLMs) 中的视频理解，Video-LLaMA [62] 和 VideoChat [30] 尝试利用 BLIP-2 进行视频嵌入提取，而 Video-ChatGPT [39] 则提出了用于视频特征的时空池化。 但是，鉴于每帧所需的大量符元数量，大型语言模型 (LLMs) 在处理大量的视频序列时遇到了巨大的挑战。 这使得以前的工作无法在大型语言模型 (LLMs) 中表示超过一小时的长时间视频序列。 为了解决这个问题，我们建议用只有 2 个符元来有效地编码每一帧，这支持在现有的大型语言模型 (LLMs) 中进行长时间视频理解。</p><h2 id="LLaMA-VID"><a href="#LLaMA-VID" class="headerlink" title="LLaMA-VID"></a>LLaMA-VID</h2><ul><li><p>架构：通过编码器和解码器生成视觉嵌入和文本引导的特征；上下文标记和内容标记通过定制的标记生成策略进行转换；指令调优旨在释放大型语言模型在图像和视频处理方面的潜力。</p><img src="/2025/09/14/llama-vid/image-20250914223440418.png" alt="image-20250914223440418" style="zoom:67%;"></li><li><p><strong>输入类型</strong>：支持<strong>单张图像</strong>或<strong>视频帧序列</strong>。</p></li><li><p><strong>核心流程</strong>：</p><ol><li><p>视觉编码器（Encoder）：使用预训练ViT（如EVA-G）提取帧特征 <em>Xt</em>∈R^<em>N</em>×<em>C</em>（<em>N</em>=H/p*W/p为图像块的数量，<em>p</em>=14为patch大小，C为嵌入通道数量）。</p></li><li><p>文本解码器（Decoder）：</p><ul><li>基于用户指令生成文本查询向量 <em>Qt</em>∈R^<em>M</em>×<em>C</em>（<em>M</em>为查询数）。</li><li>实现方式：QFormer（默认）或BERT。通过这种方式，文本查询 t 包含与用户指令最相关的突出显示的视觉提示。</li></ul></li><li><p>双Token生成：使用文本查询Qt和视觉嵌入Xt，生成LLM的表示token。</p><ul><li><p><strong>Context Token</strong>：上下文注意力旨在聚合文本指令相关的视觉特征，并将其压缩为一个单一的上下文标记。</p><img src="/2025/09/14/llama-vid/image-20250914223527136.png" alt="image-20250914223527136" style="zoom:80%;"><p>Softmax 函数和 Mean 操作分别沿 N 和 M 维度进行。 与采用 32 个视觉查询作为 LLM 符元 的 QFormer不同，本文仅使用文本查询 t 来聚合对输入指令具有高响应分数的视觉特征。</p></li><li><p><strong>Content Token</strong>：帧内视觉细节。</p></li></ul></li><li><p><strong>投影层</strong>：使用线性投影对齐Et到上下文token。对视觉嵌入采用了<strong>自适应池化策略</strong>来生成内容token。</p><ul><li>当输入单张图像时，我们保持视觉嵌入 t 的原始分辨率，而对于长视频，我们对 t 进行下采样到 1 个符元。 此方法显着减少了 LLM 对每一帧的过载，从而有效地支持长达数小时的视频。</li></ul></li><li><p><strong>LLM预测</strong>：将上下文token和内容token连接标识时间t处的帧，和其他帧一起形成视频序列，送入LLM生成自然语言响应。</p></li></ol></li></ul><img src="/2025/09/14/llama-vid/image-20250914223612362.png" alt="image-20250914223612362" style="zoom:80%;"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 输入: text_q (文本查询), vis_embed (视觉特征)</span><span class="token comment"># 输出: final_token (双Token拼接)</span><span class="token comment"># 1. Context Token生成</span>ctx_embed <span class="token operator">=</span> softmax<span class="token punctuation">(</span>text_q @ vis_embed<span class="token punctuation">.</span>T <span class="token operator">/</span> sqrt<span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">)</span> @ vis_embed  <span class="token comment"># 交叉注意力</span>ctx_embed <span class="token operator">=</span> mean<span class="token punctuation">(</span>ctx_embed<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>                              <span class="token comment"># 压缩为1向量</span>ctx_embed <span class="token operator">=</span> linear_projection<span class="token punctuation">(</span>ctx_embed<span class="token punctuation">)</span>                        <span class="token comment"># 投影到LLM空间</span><span class="token comment"># 2. Content Token生成</span>cur_shape <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sqrt<span class="token punctuation">(</span>vis_embed<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment"># 特征图尺寸 (e.g., 16x16)</span>vis_embed <span class="token operator">=</span> reshape<span class="token punctuation">(</span>vis_embed<span class="token punctuation">,</span> <span class="token punctuation">(</span>B<span class="token punctuation">,</span> cur_shape<span class="token punctuation">,</span> cur_shape<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span>vis_embed <span class="token operator">=</span> avg_pool2d<span class="token punctuation">(</span>vis_embed<span class="token punctuation">,</span> kernel<span class="token operator">=</span>cur_shape<span class="token operator">//</span>n<span class="token punctuation">)</span>  <span class="token comment"># 自适应池化 (n=1 for视频)</span>vis_embed <span class="token operator">=</span> linear_projection<span class="token punctuation">(</span>vis_embed<span class="token punctuation">)</span>                <span class="token comment"># 投影到LLM空间</span><span class="token comment"># 3. Token拼接</span>final_token <span class="token operator">=</span> concat<span class="token punctuation">(</span><span class="token punctuation">[</span>ctx_embed<span class="token punctuation">,</span> vis_embed<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># [ctx; content]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="训练策略"><a href="#训练策略" class="headerlink" title="训练策略"></a>训练策略</h3><p>考虑到训练效率，在这项工作中，我们将训练过程分为三个阶段，即模态对齐、指令调优和长视频调优。</p><p><strong>(1) 阶段1：模态对齐（Modality Alignment）​</strong>​</p><ul><li><p><strong>​目标​</strong>​：对齐视觉特征与语言空间。</p></li><li><p><strong>​数据集​</strong>​：79万高质量多模态对：</p><ul><li><p>55.8万图像-文本对（LLaVA-filtered CC3M）</p></li><li><p>23.2万视频-文本对（WebVid 2.5M采样）</p></li></ul></li><li><p><strong>​训练配置​</strong>​：</p><ul><li><p>冻结：视觉编码器、文本解码器、LLM。</p></li><li><p>优化：Context Attention模块 + 线性投影层。</p></li><li><p>最大Token数：2048。</p></li></ul></li></ul><img src="/2025/09/14/llama-vid/image-20250914223639810.png" alt="image-20250914223639810" style="zoom:80%;"><p><strong>(2) 阶段2：指令微调（Instruction Tuning）​</strong>​</p><ul><li><p><strong>​目标​</strong>​：增强多模态理解与响应能力。</p></li><li><p><strong>​数据集​</strong>​：76.3万指令对：</p><ul><li><p>4万文本对话（ShareGPT）</p></li><li><p>62.5万图像/视频QA（VQA-v2, ScienceQA等）</p></li><li><p>9.8万视频QA（ActivityNet等）</p></li></ul></li><li><p><strong>​训练配置​</strong>​：</p><ul><li><p>解冻文本解码器。</p></li><li><p>优化所有可训练参数（视觉编码器仍冻结）。</p></li><li><p>最大Token数：2048。</p></li></ul></li></ul><img src="/2025/09/14/llama-vid/image-20250914223656486.png" alt="image-20250914223656486" style="zoom:80%;"><p><strong>(3) 阶段3：长视频微调（Long Video Tuning）​</strong>​</p><ul><li><p><strong>​目标​</strong>​：支持小时级视频理解。</p></li><li><p>构建了 15K 个长问答对，包括 9K 个电影场景中的对话和 6K 个从 LongLoRA 中采样的数据用于token扩展。</p></li><li><p><strong>​关键创新​</strong>​：</p><ul><li><p><strong>​上下文扩展​</strong>​：位置插值（Position Interpolation）将LLM上下文窗口从4K → ​<strong>​64K Token​</strong>​。</p></li><li><p><strong>​数据集Long-VideoQA​</strong>​：</p><ul><li><p>来源：400+电影（MovieNet）的剧情梗概（movie synopsis）和剧本（Scripts）。</p></li><li><p>GPT-4/Claude-2生成三类QA</p><table><thead><tr><th align="center"><strong>类型​</strong>​</th><th align="center"><strong>​数量​</strong>​</th><th align="center"><strong>​示例问题​</strong>​</th></tr></thead><tbody><tr><td align="center">视频摘要</td><td align="center">1K</td><td align="center">“生成《泰坦尼克号》的详细剧情摘要”</td></tr><tr><td align="center">剧情级理解（角色/情节）</td><td align="center">4K</td><td align="center">“为何Rose拒绝登救生艇？”</td></tr><tr><td align="center">细节推理</td><td align="center">4K</td><td align="center">“描述Rose返回船舱救Jack的具体动作”</td></tr></tbody></table></li></ul></li><li><p>对于情节级别数据，我们将整个电影梗概作为输入，并利用 GPT-4 [44] 生成与情节和角色相关的 QA 对。 这些包括情节理解、描述、分析、角色关系、个性和行为。 特别地，我们为每部电影生成 5 个与情节相关的对和 5 个与角色相关的对，共计 4K 个情节级别的 QA 数据。 至于细节级别数据，我们将长电影剧本输入 Claude-2 [3]，并为每部电影生成 5 个与情节相关的推理对和 5 个与细节相关的描述，共计 4K 个对。</p></li><li><p><strong>​训练配置​</strong>​：</p><ul><li><p>冻结文本解码器（节省显存）。</p></li><li><p>最大Token数：65536（支持3小时视频）。</p></li></ul></li></ul></li></ul><img src="/2025/09/14/llama-vid/image-20250914223716500.png" alt="image-20250914223716500" style="zoom:80%;"><img src="/2025/09/14/llama-vid/image-20250914223831782.png" alt="image-20250914223831782" style="zoom:80%;"><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><p>在这项工作中，我们默认情况下使用预<strong>训练的 EVA-G [17] 作为视觉编码器，使用 QFormer [14] 作为文本解码器</strong>来实例化模型。 在训练过程中，我们将视觉编码器固定在所有阶段，并将文本解码器以及 LLM 固定在模态对齐阶段，除了表6中没有预训练的 BERT 模块。 遵循 [32] 中的策略，我们使用图3中设计的数据和指令优化可训练参数，在每个阶段运行 1 个 epoch。 对于视频输入，我们以每秒 1 帧的速度提取帧。 所有模型均使用 8×NVIDIA A100 GPU 进行训练。</p><table><thead><tr><th align="center"><strong>组件​</strong>​</th><th align="center"><strong>​配置​</strong>​</th></tr></thead><tbody><tr><td align="center"><strong>​视觉编码器​</strong>​</td><td align="center">EVA-G（ViT-large）预训练模型，输入分辨率224×224 / 336×336，冻结参数</td></tr><tr><td align="center"><strong>​文本解码器​</strong>​</td><td align="center">QFormer（BLIP-2），32个查询向量，阶段2微调时解冻参数</td></tr><tr><td align="center"><strong>​LLM骨干​</strong>​</td><td align="center">Vicuna-7B/13B，阶段1冻结，阶段2/3微调</td></tr><tr><td align="center"><strong>​训练硬件​</strong>​</td><td align="center">8×NVIDIA A100 (80GB)，DeepSpeed Stage 2优化</td></tr><tr><td align="center"><strong>​帧采样策略​</strong>​</td><td align="center">视频统一1 FPS采样，小时级视频最长支持64K Token（≈3小时）</td></tr><tr><td align="center"><strong>​训练时间​</strong>​</td><td align="center">每阶段1 epoch，总训练时间≤2天</td></tr><tr><td align="center"><strong>​Token配置​</strong>​</td><td align="center">视频：2 Tokens/帧（1 Context + 1 Content）；图像：577 Tokens（1+576）</td></tr></tbody></table><p><strong>训练数据集​</strong>​</p><table><thead><tr><th align="center"><strong>​阶段​</strong>​</th><th align="center"><strong>​数据构成​</strong>​</th><th align="center"><strong>​规模​</strong>​</th><th align="center"><strong>​来源​</strong>​</th></tr></thead><tbody><tr><td align="center"><strong>​模态对齐​</strong>​</td><td align="center">图像-文本对</td><td align="center">558K</td><td align="center">LLaVA-filtered CC3M [48]</td></tr><tr><td align="center"></td><td align="center">视频-文本对</td><td align="center">232K</td><td align="center">WebVid 2.5M [5] 采样</td></tr><tr><td align="center"><strong>​指令微调​</strong>​</td><td align="center">文本对话</td><td align="center">40K</td><td align="center">ShareGPT [1]</td></tr><tr><td align="center"></td><td align="center">图像/视频QA</td><td align="center">625K</td><td align="center">VQA-v2 [19], ScienceQA [37], VizWiz [20] 等12个数据集</td></tr><tr><td align="center"></td><td align="center">视频专属QA</td><td align="center">98K</td><td align="center">ActivityNet-QA [7]</td></tr><tr><td align="center"><strong>​长视频微调​</strong>​</td><td align="center"><strong>​Long-VideoQA​</strong>​（自建）</td><td align="center">15K</td><td align="center"><strong>MovieNet [21] 400+电影生成</strong></td></tr><tr><td align="center"></td><td align="center">- 视频摘要（GPT-4生成）</td><td align="center">1K</td><td align="center">每电影1简洁摘要+1详细摘要</td></tr><tr><td align="center"></td><td align="center">- 剧情级QA（角色/情节理解）</td><td align="center">4K</td><td align="center">每电影5情节推理+5角色分析</td></tr><tr><td align="center"></td><td align="center">- 细节级QA（场景/动作描述）</td><td align="center">4K</td><td align="center">Claude-2生成细粒度问题</td></tr><tr><td align="center"></td><td align="center">- 上下文扩展数据</td><td align="center">6K</td><td align="center">LongAlpaca [12]</td></tr></tbody></table><p><strong>评估基准</strong></p><table><thead><tr><th align="center"><strong>​任务类型​</strong>​</th><th align="center"><strong>​数据集​</strong>​</th><th align="center"><strong>​评估指标​</strong>​</th><th align="center"><strong>​挑战点​</strong>​</th></tr></thead><tbody><tr><td align="center"><strong>​视频理解​</strong>​</td><td align="center">MSVD-QA [8]</td><td align="center">准确率（Acc）</td><td align="center">开放域问答，1970视频片段</td></tr><tr><td align="center"></td><td align="center">MSRVTT-QA [58]</td><td align="center">准确率（Acc）</td><td align="center">10K网络视频，多事件推理</td></tr><tr><td align="center"></td><td align="center">ActivityNet-QA [7]</td><td align="center">准确率（Acc）</td><td align="center">长视频时序理解（平均180秒/视频）</td></tr><tr><td align="center"></td><td align="center">Video-ChatGPT [39]</td><td align="center">5维人工评分（Correctness等）</td><td align="center">生成质量评估</td></tr><tr><td align="center"><strong>​图像理解​</strong>​</td><td align="center">GQA [22]</td><td align="center">准确率（Acc）</td><td align="center">场景图推理</td></tr><tr><td align="center"></td><td align="center">MMBench [36]</td><td align="center">准确率（Acc）</td><td align="center">多模态综合能力评测</td></tr><tr><td align="center"></td><td align="center">POPE [31]</td><td align="center">F1分数</td><td align="center">对象幻觉检测</td></tr><tr><td align="center"></td><td align="center">VQAv2 [19]</td><td align="center">准确率（Acc）</td><td align="center">自然图像问答</td></tr><tr><td align="center"></td><td align="center">VizWiz [20]</td><td align="center">准确率（Acc）</td><td align="center">盲人拍摄图像问答</td></tr></tbody></table><hr><h3 id="​实验结果​"><a href="#​实验结果​" class="headerlink" title="​实验结果​"></a><strong>​实验结果​</strong></h3><p>基于视频的基准测试结果：未进行第三阶段长视频微调，仅用​<strong>​2 Tokens/帧​</strong>​即超越所有SOTA，MSVD-QA提升​<strong>​+2.2%​</strong>​。Vicuna-13B进一步改善长视频时序理解（MSRVTT-QA +1.2%）</p><img src="/2025/09/14/llama-vid/image-20250914223952535.png" alt="image-20250914223952535" style="zoom:80%;"><p>视频生成质量评测：在新提出的基于视频的生成性能基准 [39] 上进行了实验。Res.表示图像分辨率。Context Token显著提升​<strong>​指令相关性​</strong>​（Correctness +0.28）和​<strong>​时序一致性​</strong>​（Temporal +0.12）</p><img src="/2025/09/14/llama-vid/image-20250914224021951.png" alt="image-20250914224021951" style="zoom:80%;"><p>基于图像的基准测试结果。LLaMA-VID 不仅可以有效地表示长视频，还可以通过一个额外的上下文token来扩展 VLM 的上限。 在表3中，我们对 8 个广泛采用的基准测试进行了与先进 VLM 的比较。</p><p>所提出的 LLaMA-VID 的通用性，它可以与更强大的基础模型进行扩展。 LLaMA-VID 被证明可以提高 VLM 的上限，尤其是在高效设置中。</p><p><strong>VizWiz​</strong>​（盲人问答）提升​<strong>​+4.2%​</strong>​ → Context Token增强指令适配能力。<strong>VQAv2​</strong>​达到80.0% SOTA → Content Token保留细节提升细粒度理解</p><img src="/2025/09/14/llama-vid/image-20250914224050530.png" alt="image-20250914224050530" style="zoom:80%;"><p>定性结果。在图5中，将 LLaMA-VID 应用于不同类型的数据，包括单张图像、短视频和长电影。 我们用 577 个符元来表示单张图片，用 2 个符元来表示视频。 LLaMA-VID 展示了在不同输入下各种能力。 具体来说，对于单张图片，它专注于细节，并在没有任何文本线索的情况下准确识别人物。 此外，它还能将图像内容与多轮对话中的游戏剧情联系起来。 给定一个简短的预告片视频，LLaMA-VID 会总结整个剧情，并推断出电影名称、制作人和电影类型。 对于一部 3 小时的电影，该模型熟练地描述了故事情节，并展示了与剧情相关的推理和详细理解。</p><img src="/2025/09/14/llama-vid/image-20250914224117173.png" alt="image-20250914224117173" style="zoom:80%;"><h3 id="组件分析"><a href="#组件分析" class="headerlink" title="组件分析"></a>组件分析</h3><p>在本小节中，我们默认情况下使用输入分辨率 224 和每张图片 2 个符元进行消融研究。 在这里，我们主要在基于图像的设置上进行实验，以调查每个组件的有效性。</p><p>生成token类型比较： 没有上下文token，压缩的内容token，无法适应输入指令，导致性能低下。 <strong>与单个内容token相比，指令引导的上下文token在所有数据集上都取得了显著的收益</strong>。 对每张图像使用两个符元，该模型在所有基准测试中取得了最佳性能。</p><img src="/2025/09/14/llama-vid/image-20250914224141334.png" alt="image-20250914224141334" style="zoom:80%;"><p>生成token数量比较：视频场景：压缩至​<strong>​1 Token仅损失2-6%​</strong>​精度，计算开销降至​<strong>​0.8%​</strong>​。图像场景：保持576 Tokens，精度超越LLaVA-1.5</p><img src="/2025/09/14/llama-vid/image-20250914224157860.png" alt="image-20250914224157860" style="zoom:80%;"><p>不同文本解码器的比较：对于 BERT，我们将其随机初始化为一个跨模态解码器，只保留前两层。 对于 QFormer，我们使用预训练的模块并将其固定以进行模态对齐。</p><img src="/2025/09/14/llama-vid/image-20250914224215637.png" alt="image-20250914224215637" style="zoom:80%;"><p>上下文注意力中的响应。探索上下文注意力，在图6中可视化了20个得分最高的区域。具体来说，我们在应用 Softmax 函数之前在 Qt 中绘制前两个查询的归一化热图，该函数用于制定公式 1中的上下文token。 如图6所示，文本引导的查询 t 有效地将注意力集中在与输入问题相关的关键区域。 例如，在第二行，当询问图像是否描绘了一个渔村时，查询 t 更集中于河流沿岸的建筑物和一只海鸥。 这些都是常识中区分渔村的典型特征。 其他例子也证实，设计的上下文注意成功地实现了其在指令引导下构建上下文符元的目标。</p><img src="/2025/09/14/llama-vid/image-20250914224236599.png" alt="image-20250914224236599" style="zoom:80%;"><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们介绍了 LLaMA-VID，这是一种简单而有效的用于 VLM 的token生成方法。 LLaMA-VID 背后的核心概念是用上下文token和内容token来表示图像。 特别地，上下文token是根据输入指令生成的，而内容token是根据图像内容生成的。 根据预算，内容token可以压缩成一个符元，或者不压缩地表示。 它使我们能够表示保留细节的单个图像，并仅使用两个标记有效地对每个视频帧进行编码。 此外，我们构建了一个用于长达一小时的视频理解的指令数据集。 我们在几个基于视频和图像的基准测试上的实验证明了我们方法的优越性。 我们希望 LLaMA-VID 可以作为高效视觉表示的一个强大基准。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LLAMA-VID&quot;&gt;&lt;a href=&quot;#LLAMA-VID&quot; class=&quot;headerlink&quot; title=&quot;LLAMA-VID&quot;&gt;&lt;/a&gt;LLAMA-VID&lt;/h1&gt;&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="论文" scheme="http://wolf-ll.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="MLLM" scheme="http://wolf-ll.github.io/tags/MLLM/"/>
    
    <category term="视频理解" scheme="http://wolf-ll.github.io/tags/%E8%A7%86%E9%A2%91%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>实习记录</title>
    <link href="http://wolf-ll.github.io/2025/09/14/shi-xi-ji-lu/"/>
    <id>http://wolf-ll.github.io/2025/09/14/shi-xi-ji-lu/</id>
    <published>2025-09-14T09:36:59.000Z</published>
    <updated>2025-09-15T06:55:25.055Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="48efbf1bd6764345015c7f351a0e5fce1b4958f80c7d465af0e48fcb6a4af20f">e5e963fdc9daf54d686e4a098ee1ff75389b5e1b07cf2bef315bf3df422a2bd06f41184557abeee841b333b74afc8d9daf345a60fb8603c175140628605fef46d9ec8c76001791ba4082eb2352deebfc8ccddecf806317c1143dd64a02a6f068fed7b5151f553dd141b94eb0d626d24cd06394fad38dcabbef7758a4f619cd6047dbababe145082246b63e84f1928802052452f0e7fa092f55172235f4c4de4e9b72ce06a11a70ecd7cdf8f56353a0b5abff47a2cad9411cf0dad8687ddd2fad0d2658dd88fe5fc2577b0c857b0555118940470d992a292c1f8cdafc40c96d0eb79ca686f86a22f403c9d736d701c9fe71c1d76689e1a83c6c82bd54346f43e035f2fc3710ea25e2f2c87162e49f9ab176db89bc978f8b37487a8d79cc4df3a674e0deada5b6b59e813fc70693bf218c8d673a1212a9da76b8b9fb693546574e08b5c6eaa2a7f1a782696f3117d25238c899d7b075aa42c2e1734b75e72faf735f9cb3d020afd5a6ebdeeb5e5c07c4e57d7b3e2432c03e0ac7e000588083df78b9e10cdacf78b3f9b177614bf0e215ef5d714e05a011add1c4e4d060f67286484486b1ab373bbfdbbd67708e590ebc6da0e3957a696e05aec80355ba083294e9128f97fafc100921326d197aedbf85ee519ea47455c2461d002404112ff1fb6f5adf53e314db2630a7e56851a34e6bcc89c7da903a6f8984d047b462f3f13d92b0678640bc5c74781c2e91b34745b57e6bb8a2e9609ed36559ebfb85bdd4b7dc96813d5a9c0a7e3ab21fdd6d8d2b4beef946bb44aabdd0a3d558086681681e35edf5e15d1f2104c03d18d66ba3e761b2068a13140bbcb0294993a9a1692213538d93109b9a5449e25639571de402502fc23c0c8119ab232754ef7d0633cc15a4e7a01fdf09cbc7ef02b11f55097199ed20f1d1a4797618f204f6444198d2b7be7dfc71e6c746a8ed6662c937882f50c73982fd02e53897ac8653a8ab5b3a3b2d5a62b8eae528a309f495eda1a6dd8516a8efa4cd5f980caddf582e6f8a4819f86e1b144c67de2d5bd12fcdae92742be3d0553212450f43923df2a27e36ba06e33cdc73cb42e0f8d9702e42dc4fe3b96d82a58f599720c81e1dee5306125074688ef02700cbf8b1eb0b847121a30579945e5928dbfb6f15903c125dcc90d77184df57908d1c7dfff2519f89e59083882515d831709e9c8b932e391f8e2f29c5f35bf0877ace5f39ed92abc5e9d60b07a4ed25d5ea77506135e0b272760946ab1abd8e2bc29f510b6eb805f6fd7038583d549d5a82061ced942281990f49e85ebb9e530704063d0e29217ed839c661d4676a5048387e5ec180891692e6f0d3f9e4a0720e6674925b02a4fa96ba079469925b9a2bc19a87f832e88f61b5e317a6478f409f7eb117cf9de9c7d1877c93c01ce31b031ad7ae1016e47018af0338000a384ba6e8084c8251311ab8be5e767078786a3b5b62e91482696e9043b1db3701c230422bbdafcbe8d4e58717b57c8aebf9e0510b2b5ead153eac0baf323f7f32cc5eb178d5af5f332be6d85380f1532080b4af47375448a83b1c0368176dd393dbf76156e17d53f8bb26e0345dc5010ed8d84f8dba39a1e2dcb98af2b12439836600a68a55dd354a29a8522159a4fd507c5da54d7a0bd73c442179d190d00a63490876b7ef1765fca212f6ecef7e5a585d4d61492842e2e4a8f85e4de1d3068e1203adf405f7644d12c71f7818b5476943c8185256d75e5efc988f76546be2a0e8a40f5db9ef6b59b12402c58a1bfa9b40caef34bf8c3c4c7778accf015eace8cd830b15d968f41e87d1d871f341936d217e6be4c196a6cae497017180e10408c6ac26db01664e876f5d58d1bb08fee3fa395e01e10d52af9dd623c926306fc08ddb7d7ef33f210527673d2d2558a9b11ce984d6ae15a5f73db0236dc7296f55d888f0a8926104370375ada16a02bf8109a02b53143ae3079b60563f040f9c3532452c7f690c5b380eaa0f6cde2c110e296e1e795df3519ccf4685f298d81357237eefbf46f0e210e4b2f3a971a378d0ead2eb6ddf190ac34f7634db4b158922d57b295e7310e96ea38f1185d4315c1b3148a66f3528e916befdccfa7d7aa63aba2aa3170c9b135a6e35ab75d20936e3df0189e2bbe55c272703e637a9615db6f072c5c79729e3af5773ba5e56033d3ba1db582f6a3b75920eddfb8d9e694b00cc5dfa4a20ce04d7e69d794a57d723a831c5053486e686e0808f861e95b60889143c282df3702a3ea05f7d55167b66ae301eb218dce6245f850f100b7c66ccda2c66f13667a57286fe4cd84e42c03a8fa6c52ddc63a8d4be7531487bedb632c537400bc234786c94a6668490002d9604c28cb25a2f4ab2ec981fe06b45a89beaca23c5c29c340abcf8bb78337e1c042de1dd386e2d99f96c91d258439058c5553d2006c1a0464f5b6a790da3babc44e425f9a733eb32ebd3727b94dc6419840f40b7a4fc1e408fd1b023748a99ea096f4cbcaa20ddaa6c37aaaa69b3f04bb75f556189d6497338f3ee86964d589748febec6ff7962611da1625959bfe870c27cd8614f4a0a4208cb04ecdbbe593488bfdc3477ae5e855535776a9eaf4a303139e2154a264d856dc8e8335d6c13d5950fe84f661297286e1689dd6133e9f8f1e5d787c1823846984171d623c332590c75341f432d120fd1bacb4db15099b72958f79bb6c561fce3bdc71dcd54ede143a55633813f3584f5d5dc710e236bbadda712d869a5a7e48269560c90990aeccfa97868dc44a2146bd1d2015a2e381bee52162cb3290f1a2f92252d3f9255e0b2b420efe8a99d0cc725079ad1cd57aebf32e9bf2402c4e2645fade0087d1e31192fc24bf92a33b6f3b2064dfaf709ef8ff85b04fc3620b23747d2d01115b8f9ba25cf12d03d7359f5a2abee0eca245df93f44e660e30739950c66a084d91ae5c72c392c2a42e073392d42f1bd024ffb45b92bbe7a336a3dd1aee65b1050523604bf0987e7a298eac3dce008c2bea5a7897be9550af8c61badfe76e6c9129e3041317e4dc275a814251906db96781fd19ed316a7874502a8eef25bb3dd80ff9241ba1a09632bf27dafcfeb46bee8a2261b305989d7d5ed998c0b6225d285871333d61526b7869ab609391ba582768315d081b9031cf709d5b2c72a30524719694530e78f354df2dc0af7c26d6baa836228698c7c1de8662b07d9043c6ebc0c16e00b493238f4f7cd38e921a27a8ab06464327e2d7cb51b0df17bffce32f70881c5ebf0adec980e9090ed175fbf48277660e7d098ae352bdbb9bcb387e84966a6acddf72a8778e083783da05b9949a6f6ee5e1f6545cc2d5b306b202a300a0f19e733968930333e9fd13d2814149364d4c90ab79ff12adbe6720760d7c115f6d280f536f6d37716bb9cf18f4d03481cb65e4d13d001655205b8ff54d8194ec3b25779c239870f64a4a980eafdad836d28e137368c7790bf1a70d87f24171996d062809831762544d1563fb729b8f648b5a67f608e4469dd8f4f905319c4a963d5c74ffcabb52828b5e9a84f9f49d6e57bca6ace5c7feb21a90aefefabfa846bdfa65a93e82d0dc56eee181c0bafb657e2e78d5e8289a2e603f466b61c829f4b5ffed6f1133826742edce0d4605a0c2991d10c6500e5c1ee987dfdad32cc0c243490fd986c2472701db2b1309dce75a464c4208e92c5b9245d12dd2484be1990991c676a0edf561db0c57f1c4905e9f22733bcbeef6d42f4a7d4a443d82b76d76a41195c4ff783d4969f0d9a5daba08067ee9376b9bdbdd15315afd3ab166e7c69386fdbb1a92d50287020c1736ee0d28cd3ee1898b3b32c16fefd330abf1a4e010bed9cd28ed7d6cf7e15745e1a6191c6b630286306db0b83bcfefb877aea318d74b55bf922e874131e9660866c4ca5743cc48c144c11b84ab7c967fb7283a584be8279f46272d46694d97a31d262e0435cfe695b55bf7044dc360ac286daec76fb174e91937fb65f81aa5a66e05e85163cef2f5aea286e69deafebaf1ca3a474f34a90a999ecd7c6545c281226baff77773468b284ec32901d0b80e55e79bb521152426df7d8cdc00a5e1e1c25f19788f8406349b1da97ce34022b1d8ba20c0c556a2c305ba47b88d78e91223a281803e7b721b5f6b6706b8738bb0e58e3fcda568f36beaf4b99c373011f9156ff8fe90f71e96ee039cfe66e6f658e4593235f66de3ca8622a1d157bd4f135ff400cf97d3fc0efbbe11167cb66a562f3af9275ca4f8ff71ee798864402f4a079694078a7c0b99c16b429141c110576db589b8beaef9ee25ddea3d7949f6a936c797c5a074ce88ed7b556cfef4bac884f01966809ebaf9b0d0487b7d0e454162eb4863f330b371b155ba305ed2ee0517132381dbd3a8f08afcd0cbf497b1bc397028a610a1e5372b01ae10dd7fd7165cdb48ccb04d8f7bc74ed5c93aef643535312a0f6354ea755d6b77843201ed8e621d0255c3d1bf59466e02814dc60f99f382168029c9922a0dca810943241e8fc94a4071e21a7358b791d9bef8d986d870258a3276ce35e22c8215c1edb856b77ac683cd1d4a4c6001c44bf5e3fc3815dfc5bdedf23744121726afb43fb4a381b5beb7e232d1072ce5409d3fc5575c7da02dfddc8832483f3c56d3edcb636d63b16381baf6a33b3bd0ab865548fa567286e822f8491471315110958d48e7392baa8cc9af1ef2d9b48df96cdcf3e3b837b6e4f5f81fe530009e7d37ff5bd0b7dad98d50e9304d9ba78c0b787ee8c7b600b6e75345f69922b7b35e86369019a337ff05f6902090fb13ae97ad79bb4d8dd10e98b88ec3efe933aa4c83e9b85bb70439737a4a6524a861f8530926ff104fd6ff18c9401bc30eb171cc56d496224de452c5e0573cefc8f476360d669d9b16998d1df208807c16895872213b11a59443d9d825eb3bb9217ba4a698032625aa8e6ac26c27b5bb205f089ec0d1562049fc232c36d76b611d39f89369bd7a993827cb5d7e88aea2b770ab1ce5da862a57ba51ec8fcef6287db32a090855809af2beeb5a24e2e72c5392739ffff243ce22a8c5f3206b81775b4d2c12529fa3cbcce40c75d3a773265b3fce551563a6ceab21b58aa53cc28ba831fe5c2c99d3de240fc9df4a35eb05fdefe9842b33309cf88a65044fd243c9051a741875be7f5d9dcaed7836963ed3f6cf47d9ab64e04474e3fe5c320d49ba1b6ee212e9ba70d7629c938fec7a59d114a28bda1ecfef6fb2a002333e62ba9c1649dd1aab90460cdacc21d72b692eedf70c1c340cbbd9edaf6389dd96a6e694076f0a3785b136861a782d60b1c47481b82dc629a58c9c2d3ac88e689009ebc6c4535709703e5e750102ac7150dce200285bbd1faffdb87a597f11bcabc0b158bce3a810359d960c77f77b36110f5ca183757383026e1d652774cc647a3daf5536bd0bacd62e477235297b76b1861f62ee9c83b495aca36ba657c1e40d99f068e100ebedc2ea17d52e8c0853425089e4580b8fdc5d94729ab696492bdc78273e965780b8c67b45c0633fdb495e438bbb898fbeb0451564c31ba346659683e1fd1275ec06453a98862f6404be0052842d24f37b888ee770f0ee1a2c594b6f7c013219f89b3670f145bad460dcb64ba46badd3bd638b022bc34afb9adaa7918ce2244b7769036d595ebb06b3c26ed32611fc33c73d6bfca7eefc161ae8a41e57fde5a5a26efe956966f6474c6697f07cf262855eff4b94fe5a6b27e9f62b402caf3d325ce38c13830edf04652424d36e5aaadc04b147136ee6110a149ec6e8c699ed42e3ed45c14e83e8be77713d27f86575bd1d8a609887cfd7100f5f07c0d43820fa22c42cd54972a5358d0a7b7f28856d1dcc11c7b2670e0d01812f1c1be6102d0e6de5929682a247edc1dc6db15e5832a02ca6b17935e7932e44f1851d263321d17d9814f7d8b0c12d0e3f9a2f75a4d66f28a66ca05d70d3decbc9c1c4378bef59bbac101fdead2c550cf2c7c5d696f90458539004a66cb782d63fbfde78c2447c1a31cae80999e0155bf153ca272b537d7009a66a850f1993e199a5197b7c5d17dd01237dc349c63a2d43322a0c26ca79f26fe1b3db7c19c78e28587bc1a46256dd00ff2bdbda107c417db8daf7e836ed4097faed630e80d9ddc6c9cbebdaf87cb15823556302057f5c6f9f34678d58b67865e2aba5cddb34edb7a128d5b157dacaa71a041004430a392cf7b416f97f69f55447cd1e3b8f626b35408d0afa44c96dd516856d90f36d792f2f2d18ba51fa90e6cd80377de7e2d31ad823fbf45cb6be527c42471a0b7d77793ae455e4a81104b4d305fc8c78cf3726771e11f3aed680a49a07e1b6ee015e58b64b7a809aad578b73ca635604be0a4e40b414c401626c6a6082ebc30a5184fe12d58e6c62047976ce85d23225ccacf3a838ab15fc4fceda5ad793f56e55f9dad49604adfd95bee58fe36c12e71efe34255a9261e7800f74eec1591cb74de98d2b87115f550881a8cfaad408ac434cbd19254df14f1c1203430c6c8c6b840f96ef56676b12d5a1b8fb2fb6f802e2570060c3ff88e074f3db504c5f51964c1ba78a18e0f2d5aeeabbc1aa66923b0db0f2738e0f8dd882da1bf35e855384f6715a34e42fc461669d04046063fceaf9c80ed31ff8d306ac32cf5d6d576da66d2436cf192236635f9afc7c097ddd0424ca2974982a1dae763763bb63524467b0fd842c66db9b0efdc3c26597145dd857c3b3cf90d9b94da752092cc48f9293d0f03191c5de2ccfd13d124f12544464eb271be6827fea8287c435266a2c9798634de98b9ed7e160142b04d5db1c49eedd22b028d56f90b9c14a4aa8e1e634693f7b531a7345f86fdb2403e819ecab0889a693eb8df9d553623c81d412f7ba7d5f52af2d99d95cf684af1c667184492ec0f891f3efde44ec8090daf0967a02d49a15512cf65591faf86196f9aa1363c4cd7559b37d5ce325b799c6146529e2a187d3f5115c1d7a15222f470e976b4dd81052db831b58af67cbc8bd30c9cd832ca8c5d727ca550471cbb1698d448d62ffdfe9819f09e0a7fa479699b19ae364f05fc47e4e020c6a5b2e3c322609927e957d08d1f29c3ddd018b2e4a41987b7ffd21f7265d9ee78d9edb7aa51a9608008a2405c4307338567b19c4af849ff81d421b47697b507dbd03af26ccf9cf65b4568e02bb1ce24e7e603dd3960e0a722eb0a4f18397a4c21051b208e903eb7e8afefbc2d48ac860f9e78fd7928adfdee9ce0f97d0f383621184332ae625714360d799a154260068e4ddc0690431ecb31e0df17d55eca0e9ef14ea2e83e765aec8f45b026b382a747755e7b9dfebc5d5a39a0a849f77969866367353254f42ac36109c4b2e053f370ebae450b938e210e9d88d94d68a1a6c1f5e1a1535dfb3828dd42874a60067d80b8b5227b6d5a7ee55af432d4d1914b3e32563bab413a5d591c79ed2847c02f7a25979ea3019ce5e81dde8f11ce8b7cebdc42433bc2e145a209d3bdcbc37f844207657ed25276a37cd4229c2bd3e6b925cab6289c187b3af5d28d6b5a8aa3dac26e8a675523de5c497960d21c5de18abb8777102c2fc840b37bb24f605e3e76a8340ffdeca45f757f636a51181bf6d8f5899bfc4c4b6dffdc259d7cdcaba66f937de6fb07f8d047642908cb2cfe19ed007a987ccb625b84fc75466bf22d211acdcff5ef407f40ff2c70cbc8150c1116895fd9c28aa521c7d002881b2010629d1b64bac393dda036c206ede227580f2bfb6d716dbeb1ebe3b26a667c0a60c4350181bd6ff7ec5c9278269cb7932ff9d61c59d78b6376b9643e40c8a1dc41a036f8fe65cab738344e7512cf043ff28b3b66c2e25a2bd072346ba0b322ef4be09f9f3c491bfb271b3a1cd0c191b4043620502e9a8fc4f667086c98fd39861875983a047a10b3ab24c2a52545028dd90b04b28265528ce1582968b46bd0d080351ddaa3f8e8f6360c0204227cddffc1c6cc66f894a3a639c7baf9348cf0d1b1e310cc9d8a40832a8fcc951f2ff5595110fc1f1a3f142669e04e38f0da6c85797cd01cd0931f4cdc91cd6171850314b7d145e6454aed89b4e8175f3a99c03ac86c1d57340959604a31d20afca04bde593e1c9585e95ace8e10e5bbc6652912722bc0b71b2822a9e321168279b4c4022a8caf6fc0159fc292c29c2831b7a252f48da2125e1d021fb8d1d5e4b707eba0d4c1821b412c4b315bfcaec855b0c27e7f6d7d4c0a6898e8e23bfae30a45ff4e6376e275e7df5e63032282864acd4fec9311d307fae835e1de7e9e89b215d94fed6013e2769da5baf4c6000718b7f7acbe17a5ea41d3fff8c68b7068ecc0c5c6cf7b0fa2c0b6a414ed4fe82c194b7a6e71724927893e329c43e58316746f4e3096cb0f9544879aa6572504b8bdadf73a26d8f7a5d4dd364a82fdc04873b8774984b4a059bc47bc3fd17e536e6a6846bf6092eaadd4cc3ceb0e4c4d9a34e7be0d1f92926b13a6d6d3fa1df93c05c28bd3f46680bccc48d7d61fee4b7582eff7f1dd7d1bfa81f36c0dc4ed2d9d865358d8e9bd3cc6f0d12c0a526464b5165eda802363ec9808a3eb9759783990204d85d2b18d2e990e46b45d36ef10ae98dccfec7b006f61c646305acc29e868163520e0a13bad1d87b9b28d878f36d222fe813b03cd13125309ea1a05e61dd654e942b7b81c5aa4b9a95639607aadc8e0dd6c1a73fe927e4d32fe6d4e90d9e0fc497ce2efb6e3538a7c7d49b34ad673972c841f425fdc5d05593b371c9ac9357fb94bdc2d3818b3f3d362d9f69860f1279d1dca4f3632f4dd1b0b922b412fdcf799d635845bbd7a6505192f010705f8565b9ada7c262e2c23247d1cb05fdcdaa1d4d5d99474b8edeaa8a8b59059e73161676cd1ad75a30c147e69708711114bbd69a3a92c0831b5ec4080dc220bf22004826a87fd296557a1d35483f52d5d23f366cece824fc0e8935d254b380d030496607772dac79b49ef31a144c0c693c80137fd177715ade44d676ea1fba2920331f6487ba393e2747b15af9f770c29c72549dc02faeb8def36ea7877be1c8bd0bf88afd6bd96bd21656931b1dcf283875b0f49759a93be9db12df1b3ad3e0fc7d6427ea11b433e33a1239b9148b2d026b5fd04064cdfeec368ef3c0359cf0c33c94894448c374b02d25365144dda29c3d2ed821509e70e60bf47b9c2c427cddbce6e644af824acddcee38662f91ca3e3cad55e426535b06705c36c567c7d3c2a6e7061cabf4988d61c61cf4b99f71c3ce0dd9e5dd9bf9ea2fea6bf244c9dfcbed84df22c57c51594741d5d6ed68c2a4ea014cba1605cf8766f52a5be3c18bc2df23e8c9d2489a3cbca028d5520bdcd4c1c03c76cf4df80175d445b0e7c2eed2d8386b73f36afabf476e95fb8347db5552e898d638aa1b7ad10775e899260ea9709b6793092d1c0636f305c5088da4a555616e817836d90ddceafca3ceb3ef8ea08cd33e77b32165c1facac49e0b52bae734c9f7d27d3643068a60eaf3b6e9b4fb62f0de5f3cf010db13705ddc084b9f6933628e3b12b6bd3ccb84ec4b392f6d97473c69ef37d1bb6bc33e55c19c454e83af0eefde7096f85a460e68ff5773b5d18f6e80ad832a9e1a14775c2d26a8b252c0cb67244a61235a49c523e9722509149bc739d297e49c154ba9a73bc70bbbfefc1e3d724f9d7ce65bd1282e5d76eb5791f3a6554fd824fa16bf0c8e939384f5590329fc5095177aa53622c1a804fbb6f96b55d8d7ce4b6e3a90ff06f30665f36165aaade536c4cc7adc5ebe555268775ad7525926c3949f35cfbe29b99bbe5f7ddaf98085bd7451968a3c616b3e9cff4712bb5fba88b8289d3c0944575b60608ff87c49779a0bfb0fb9bf0626c21f3a392e8d89d1dbb77de456ca8cd61fc442938d1240b44ad27d6cfa56bb5b797abadca36c7dc4551a5e85bf7ecd21265a53fc342b0304d377eab065671b766f42ac33ab5c62f04f48d2a820ee5e64ffb4fdcc3bc28d7979a784467ab1aa602f72263fbd1e09866aa11e61123d8d3c800d1752946a687e0a5b7ae58f62b79b8faddd94508bca9be938b5147fb82c81e48f1b38bc0716e0bcc995a7d2e91d6bedaa7e3404603ded73fec0f90cf50cc386427e220264481ccb5fb5e1c7507d650df7997a598d2704c1c2f293cdcb127a83e8bd5058c6778e57ddcc2af34611e8da0d5efe4e6fbf319400a2b9f206dd7ce22aa65aed872e88c246c36520a51fcd4d03171a8545269248d8b01cf6c484344d113e54779dcd1ffb93e18cb5d53899fe06bc85b48b48fefc0ea327ce01c29a170c18de881215e3fe5e32b0a1570dfa02937e7a19a87cfa0ed13efd921b144542025de829334355eee483799f12746bd9f2ea5a8f1dfe3a1d1d6570bd1185af4b9a1aede0601773fa47a9eb72752aa2968738931e282957440c9954c776d370609bb451ac1289bde13e78c62c329b1c85a7f36a295c61662cbf6cdf4b2539b40b360d3910afcff83d86e9415c98b58a428b734cd97b68dab41cca7900dd6a0ef51651cc5998a2ae0095445b71110b441e3b0a912ea8ea35c1587f8bb49b4908827e26636f82f6a98b63a4ce935dbe7c74fb2acd9022850375d511c131377fd7dc947f6bd91f948458ccfa36fd146e486ddd0a2d2265bb3fe95194e6109a75077f74b5af4a459fd6b67ac73a4d9cada20afb6fe94276b970dd7a56f61ad6df6dc4f12f7b1d3761589b9adf808e6d714b3830bad687e37c724da9ab571cee01530e9fb47bf075353340e4cc6a0d2ef5e6c4dedf7e2a9780cc7938ce84ffc907c65ee4b6e0b9c50d2a007679f17ebbca419f6eff2209aa56664e00d5517d938cd8478f876f79821f8f152fb629c2c7de9b30ec7a1a5a01e3e592762c14ca85349f29b5cb7392257ea984984c436c93b5cb0a0a78df31d8e79e0d36b7559dee0b3b01f57d834dfbc5e6f663e02b3044bac263b7b3ab843391ce2d546b4fd3e86023ad4329c275f2cce97bf4a9383b8326201725f7feea2e41628c5785ca74bf0a3af439853542d75bba87114d66a1c9a44f626d52e6844a35199c26d4d2384fe60446d9131e78b346cdc59dcfbeb76e12b27521e2838861b9dbff33f6e4f57a04e77bb39f639d72b92755b0959cf3e3f0892e27ef05c19500032fff0f5215af24e16eebbc127ea2626b5f32793fbf04c64ed9f44b7c565a7a58ee745f4483748f6a655d3ac5e4f7984e999ff01de876a6c1111227e7837264142958ff3b6173cff7dc30230dd4de7b48758fccdd10cf217a18c5de0eceacc5b72b10ec8008be863f24a57a6eff5461fe1d2d494b886fab4b4e93ccf8b5c8c0a6e13c1e2acb5a6c6023465c40151e532c1b0b443abd12c5e90d27939785e6fe93ab1c2101d983c0ed4a82a876b69de53f66f898041a2d347bb697f4a0b99e99a4322ae8d36cdca5d081e4566157208ebcae100e6e2382e3e81531cee38016a6aba13e47954efa7483db27e8f076c31556e53c84e5ce52c15ff6f81a141a09e53f62bacb224de0951e9a9a36d2a33a59e3a213391cd8d0663563356b0702e7fb70596086207b58af1b15f82ff6b322aaed2436068b1605eced7171ee89283a5422783ada04f833d229b5aa61e9fa96d94384deacdafc57f8b3723fc9a25e6dc16ba016e83fab1823944dd0e2481dc1b9eb9453ee90a0fce93c1dd57b990970ec5401cca7a63ff1696c9daf22f9de8d02b32740ea0683f6222bba710c0d6c8fa15e52db191e0ffc32e1dcb12229b15fe9b34f7818520e3ade0c99584e340605622e9520c5291903aa9b9c8d2ac3dd259983802506cef7b08d369cf5bbc0947b6900267542c5f724361b2af3e29cc6b0bac4343cca05d27949043a79d66f1d2ba00111e60f2544c0f2c16e93a96da741e36a4c9d1500af56b1bcb3d76b781f1eb906c1a967dbcd7393919bbe5300dcc1349ca53bf4eb4ead4c9f572173fb3800c944b8ecf53e48064a627c48f3ca3e236dedbb596dce67ae764ef19e2d21dc1616704bf25b9b12e68e0a1bed0c4709081280b5cb3bd2f28692737614b9b6aec4c220f0319cd829215998b423a3b87df5d4a745cc93bcf24e353533146fa097309c70e98f63cc0f2a5b0e35991c08635f179ab77acea7848ae07da3135a5590b2a175950639e2e4e1e9105c81d85341b46bf59de7ae38898b53629f92767b8b43a0ad3b3961d1da57f315846d03b4493dce79e72a31e2f9c46f8ac5e7a3f0a8dd25651e3bcac93d3c1f72f3e16951c057dbf6f4f85f5fa1cf7324394549b272b503f9a0d1f42f4c0eef7d2df98b17e9e993d2cba6241e3e24f67740a92e314beaf4b3588be92c4f58a65b3e2601ea9bfb62c66bdf7f9342a0aebdbce9a33d795da7bc36a9016966af83786af463c69f7a1135378812be8ce8c4b4a15a4c6edb5229aef706e0b12ff0372733dd6824a1b84713fb3e042421ec0161d82df1e4dc9769a4142b4dda79bbdcbd1ec939995c7a885eb6bf8ee392472e88c775f954ee7e6b4fe043c7340fab25696c8fdd81f699413338dc84d4bf321be0a15e5fd949e16b5bf5298e767c99a35fc438faf0818d639a6eaf05b87bc2e7717c0a4b3c82fc17c927a6c914f8a0a948af71e78ac04bc0f60224ea26b08bbef5ef9d6463f5c25d87e645972c337357cbdd97f4d841facf51f2606ccfbd1f2ed0a0bf7498e640643c26c30e822ee58c3afcd3b11b93cab1c74d3506530d69d9995b9810180ee584fa3b03a641a7ff9c65c605f90983bae52e117b074bb4333e7319a5d642280944d5cc3a80641831e332ddbfc394b17ce3d1b3ffe33b17457495fdf0a5079e0835ab5395aa027737e38e14fc8955755c1f18b15e421068150ec15cf9bdd456f7fa62d912ff55180d75ba86629b6b3eeb37a42156865ab347caab10c7f97cf524126707f6793287a2ccd9566b82392d6a3eaf61979fa0d8aa28be6d37901c9e9c370a1c72381a0e493ef19be3f05c6eabe2b7d3a362c95cefe386c7a96f1d2120d85cdbef8a2b390f8a0efc79cc1665331455a6057a6718bfe8545b058c6fd0f5eeab59c1bedcd1fea235e20ada140e52cfe2b50d48158af2191ddc2fbe150f11005b19f00ec3204afbed02740cf6c04e15c4a89c98bfe660301ce79ad3a84c698ed86457756422a390897e1820a97328fbd9c388766566ef2bb9ea4c4a6b75f9258e13e15e0609c97aae4705407d859e72e9044bebc84f80f798875910bd691871a56c3505e109edece7edb9a9b8b3b8b32383c1d2f868d0c2a89eed5d758b2f0dac51c885fe1f69bbed71ca097c203c846f70588ee5cce15a625fc1f62e98a20908fa7475a94b6b02c27646ef69ea4d7e17a6b23ec2b4c03c109fbd04d50b3008b18c22e73d8d6010ddc1c71f524731b1a533c7bd60828028953294aa49a7a648905e9d56dcfee7bce728f44c4b17590ab83b3b8a21764d7c7e93058121b8046f900e3ccd754606e4ee219a66bbfc0627407d6dacb2c512ceb4a1df6ed061905b279e7527437ca623ab21fc5b79952b927f9fc40bb71c7094c791698c2fc31e8092b1819173e03066ed18faed9ce4d5ba0eafca0f202673a08de9046b8036d769179a7f20fa92a3c9cd09a6c99146d56adbc767467d580367c9afb2bc07888a0e01f809608dada7524f9068ae28907153f5e15ec579dd50481b694c2091458edfc1cccf2f8c8cf8cdfa7027715f0f5b428eec944d98658385b5d625442b018622ac324518f444cbaee92966f93ec4e5dd340364e80fd81f185be0ffc5e0333de8f6687e53641fa697bf102be43dff37e107b74d851c5b58614a134104dcd539c6a4548c583b223067189ace69aed909f4b821e853c97defc3af0b92296f061d31d5f76fbd4e37889d9a712947996bd5c27773a40cb30196648618156b6af693a9df0b1a4d9b9ffad97e04ec240ac5ed5ae5ae7da4747b8b63a8996ca6b8c4cdfaf5b2b5cac8390e68637a4dd418218addf523f043e69c7c534121474c2954b6d39fb2a0324fc039cef3175c9386405c5d477acc0fb0379226bf066bd2d3f0c54425e6effd5905a9a494cc10728a68a0f8b22267bf43554e3e24ba95515e390d4a16edb7fe53438bf240f4a1e814f22bc05044419aee92aa5c822c78c15d9a7baac940a2b8c5158035dcfa4bc6fbf04d500549734199c1e585f36cf901e47f0089df7836a1be1124adbc03c08d83a767fd27509b43286a95f6c9eba98b6c577747d8c19f2527291364dd05e4dcd794243cb55db3bbfd4fd1cbda52a9d2aa48fe789f17e78ba620f620c1411117022174cc2d5e38a8b95ffc72a94b6fa84ca7ac48a720d4b4d4d4dce0d60cbe07557e11491af57e42e89384c089820d3ad5a5077ccb078085692111bba771bc8074e2e9e385f4d56fad41a3f9c9673c8a550b295d3da66d92074be3eabae3b1b8ed5bdfdc66ffcd91f13a14742722eb035f184e06d94524207f473b24ff3bf48d30358ad81863f15bb61ffa4882363c945c3c408911142c6a49f88b4c3834b708df5318fa112a6dca47432ab465aba422e75f9b87469f396cdc36415f1ff54f34c31de2506d83529485ef13adfd4dad6031356e5b129949d2e8f637e7a855cec4a378098a08b40b3197139950d250596dfa25964dae35f2893496d5cd737bd075f83d85d64798e83573846217bc38351fd06021f51a1f8e509d261d878f2833a3641d6c5be9f8ba74de338087c4703c73026bded35b27f7aa252cf0f3314d0fc2392521a21a5f638a9b85e3d0289ea44cc2a1a29f88b1b6d28e0e4260263bae926a9ff4064eb351638efe3d51fc2b26f02cc6d7c74b95f7f27efe0c514f93ab93847789cb3db2d8b717f813da2a5270b8795aff5e4afea8ebdea4d5a11073a4403783378bd279e6d2debbaa6e3d5978a32bce90392a2c33919a61df6836b8116638bcc9a52e5ee0a2ea38c46c012eec1e2492155d66e5b94c1bcbb23242d72c6816d760e36d5de682a24ca97cc872971114043a10e8b80e4be303fcc82244734ab95c4d5419b8f5807ac0fdac2c99bd15b2aa9c0b6c0878e80ddb3bd5e07fb4ed5d87881b3a9da3c5ddd067046022e46558ba73438dd085bd99c8d5ccc143dd72b9976430e9f41a497dd278dd3c67f089ba983afe9e169aa55cd3e44a6c2b417220a97f404fc331159d0da4fe3e049ffd5e5ed0e150d660659875ba9590d2332aed8d41e21f8642da37ff75e5a3c5b623e609caefbf0040678f0848a4fe6d41538d2bf03acfd6e5a533ef47c1e80d77f06d8ae7545cc4422ce0c6896d3dd5f8de2732c89162e68e0337361fe6e3f4fe73ee035136773cbf317e9531820ef4fb4eb7d9775839c9d2f11a88fddc9c989c2d97785914517fe0e33321e7ba3e91b1c00c3e919e2a90eee6497d8008447ef99acd1d6bb714e23cdce17e84828b6c8604455bff15ccfe8835d4b8ad2eab8d452e6ce0b2121f88ed44d58e9a22a72f18b227e6f19c3c8307c41b1879c1f6a0f65f612b38134545b56ef1cec2564cd675ebd0951c6d9735a9e12192add271f620c1d1b1abb9afd9bfea13cd31e2c8a2f27474a0d8cf3942bc5fef31a6a5c4366c255edcf5b3119e7faaeddad203e0246c54a2e02014c97e5c54aef485477276acc5aa551218fe1119a1a0285e319002934ef2d49c573f9cec6d2692ea0dd6ddfb206cba2e501024eeae2e43a690210b6eb4e83ec17dc7aff19a862c5806ff95f9fc6846b3a367eb467b2338e54fbe99e36710421b32b5e20bb38cf5437afff56ade3be85b4d7c1f134b289fdff2d449a3c1181f510d816c69ff30227a847f9e876e73f296e20c0a19bf246f6e1caef455205b7717254375798c5d8b94da78c82116719e32e697e1a33ea2cbb140a1dba7e8de420f79c85a7c9849f56ebf55eeea9f3f8960c8d2aa964cd4db5b8cff3125338977ded2c312229302759abc3f1c10e4917d531d00e06a050cd68c1e00a5e13fc634bd1130ecece3bc3ed63d49231dca17fda362ea2b16603c033595e6a3123b1c2ff4458e22ce7365215a91c42914b18b3d87d1e5f48c9ab999f53a615b009de3659c4b1c338d37f36d658b58cd856b680689a97d68d439ddac75a4badeced751c1fa4b9b7abfaa867a2703f29b5050eb15591d91653bac6a60e53eccdaeb76a525310bc8c056fab7cecfa6f39c66126814457d76a5775c56849ed08e88592b4663c99295df1d68ebbb9d1e73fed0ae3f41d827b8dca236325f9457abbac7f6b74918b48f8bcae50ac12ff3074159baa0b57bd1b67a62f480cb9e9be6fb77cf8dbd6a8f2054dcd76cac7a80d2fba4de4651494526635f8fe11d278e540e951a6d24a36b551e92eee1716b5cb0193823d56b5ce7e11c047d97f143cdcfe7fa8012949c58698659765caf2d8972df7b8423abf8d018cc32da9f55f1aea8fae1301d4f36f1c64c5c8e91d2488c313b1152d71a86169e63eee4671c9178ece80a544fb7575eebf91bdbe69d83fe92ab1750c435bcbfd2a038fe665f9e1e417204d568212cf24491365b23f47089a3761dd79c8f67170a5c15eca3f24bf5df47b8db3ebdfb40422a71ca3be50957ac268186e0b6483f37a67c6c4895394c7786bef04f65362a85ec38f47d0ed48bbea2834056c4975f999d9a74c389943e77b83f3216ecf9c10b9406fdf9c11628f4eb74d20c0e0a6a93e4d67433604a22a8afcbc595fa6bb0acfd89368ca6bb4fbbbfa7482e5601f5b0dcc626da8caca271b20c7e00df588b94bf1ae27529d90529ea5bd1d3ea8365ec1e7ad7de0ebc905e0f920f5f7779e90995e673a95fca6aaa03b89a9df591114e7970e5cb1ad535536b55c534203047336d9608d6cdedc255754687e4ad561ed62a76cb1d0baebb1de69a1b4834ac70a90f5aa0cda3ef6a8328805ba7192c9cf65c14a770ec1fd5a12a14106afedfe08ff73a37275b74245e8878127487016165dca91503bc1472c77fe9452121a10480837a095aa5ec7f0e8f2017be3348fb8f6e429eed8b255f5bd3626143e3539a6f0b1e7dabdf828ddbc6bd0103e12a0fc61f8f298b58bf62c97ad099609a672b5be08ec47eda8afc9956dca29093d753213157f69e9db3577b656ffdc63d72fdfaadd4fc9e00badc9d0c5de408412dadb405002af9a0b46dc1fdcf1a26d77bb88ce3a123509883022a70165fd008c62232b12eccdc63f05bd577ee358888ecc089ed539fedbc9e3dc9bb3dbe78b74ff61499045edfbfcf81e28d253b1cb46158f4928835b99e446d58afabdec7fb71455e03c4d2830454633fe533939feefb79f3bc9d79e720a91860a81861575f467d226fea433626356a94d7c549050199cacd8b66e1779c606ee49d35b671ab4c2859507e054ab6a2e477a028b9967e5725a564baa1228be749e473f33b7337d18b898aaf6e5c39457b7417d6738a560a7d5e8412c2fcd7be4adf9a3935d07f345b12bb613b8258dd81144fc57a1156f942444fe698d44cb269954421cfd18f479303aafc02c9793d04ec0792ac666329d50e4941c6781103029cf4db598f028f4f480acbfe92b395fc82333b70d7df693aa282f92674e45d32a27008b18540568cbffbc1ced1acd7ad1989a3102f78c166cad2da4151226fde23d5b53b9a4a4df2a36ab6443e69035461192812d4611e720895092c523c640eba60d4f50d4101f3efa6c649e380f99ddc6701a5b67b5b0745a059401cd5bc55390f65a9eb172470a5c71914e85a739fb5fa0967ac92f96e2d993ea0b21c33033222cd70bbf91cbe52d03e0e44af275fdc65101903b31a089d1bdcf0536ebef49b100987091ad327ac6d1ccc1f1ecd9626bcaecb9fbb0fe614d6cb7e4770eca715503208259d76205da0ca608824ee952a08365ce497db74b1e68153fec331754aa0cd938c2abe0723f7c74747501c630cf2fdf6f5ff36e0aaccbd4f506d8b19c40bed8201fd4af8a075a86cd97e7d3222daaac9857ee3e85e09bbed422bc6bcf2feb527d3a4577d62ca100b77963578f8df2d6f15324a548cac4f44abeff671434cc948af4c00fe445d629c16acaf1d2911d6e82093445f6b1b9bfbe71e7686e8c3be294589c234a97ca79984fdb42fe330ae1ff9410039b6b154775dae35d96343272779b15690b636b8fecc1d9899ffb322814809e46a0eaad45a69ea81c58b54f0b882927e4a81ded30a0dbd91ae88945b935880ca2723190a427ae4df287318bf3d801c9f4555bf1490aa8ea32d80414aa9f7fe2a1c2b04ab008ee5ae4563175e5ff37ddca30728fbabe2736431045fac6bb78dbb6102bd688f0ca274d0f924f7e0ac4fad86314196949119a9bb39b9244e6ba1fb12d607967332a948305ef03445cae9c837f92bb01180ee5941c9b49ae3652b010005506302737ae37555644715321e5c7fcde9f1fcb2a3feddbcc1cd7f5ea35ed76d7450d8d2cf5d428d2c1fcc284a94c03f21de06a291ade866bcefdef17e8f0fc60b4b60ce9a5cae793132f9491a3c94078fea112e92187e91184d997efef25afa2d232e6b81adc959fc82ca36659ad9100ae2170491e906ae43c3f5719f5614dfe34fda1c4a1a40e7f0a6ad032a2ce4b35d465b4a9d2340f996c555318630dd5fd095a5f644f24e082c46e3591385087a3ff459cb9922b92a590f9f1e026e69b028c4f871485e2f845aaf17065e1804ea06b826458a7c1c3d03cebb96a1e65492b390b44967a579c1b5de3da71cdb1b6e4c286f05dd0ea2ec4fc5137cc6c7a92c2dcb29e5b7bc8a53513cd3de498bddf0dc8c24b8048f8e8b42a19087c4221d83d57e55e0b406d0240aeaa36c7e59201c81d4192fefee7c0a3f917ef21e3b0c32e76ce742d35c5364a71c0c03c4722007ffc1277aa14d43bda8b5aeb62aea1ac300fdfbf4468c7812bece6218c84e57ab0c96060889883acc80cd2e30c1bff8bb394797b6072d9bd31e43cbc1aa710e05d014a3830f88d956d4fe6164183912a65338f554febbf3801d4799738083998e64d83956a9a479917eb37f38890e5ffdc5d566627229aed56cbeea4d789234f5f4a0269747e2571eabea286aad0df53a542c0c28ec6274d0ff28f3d50649d2c430ad5044cbeb87d9b965231b3f13c46668142ac2df34726ac41d765a4c2b02f2a79af54f513e3b806d252e3fbc6f2af6750297156a154cd8b409bf97b3d0f57d925456fabb88bf96fb87b8d6d3dae6c15e2e0eb1ab0841aa38d5a434c4ed1ad854ba55fdb824a6c6e9654e8996a8e1ca6bb4295140bffc2e46745b9c1e3850b36f14e9d9239c8c14a732bc51fe2ec6306862ce7b2a67f3ad1950f208efceed6679987126f8a4623ef3f3b29609a3643da6db09c74b99eb3b1bd27081b9a4081887abb7960712bffe522f069dec1c06040ec0840189a41a90d55954d91af26b9ba2d7ddfcaabd82448c104bfc3a62a5815c94d0bd02d3586ec922dc152a5b17e9f0d7819a86e54af03d852cda32c589c70f23610d7723251adcc8740cc2be3d2fa7f1883e2a8a140bd3b5afd179a40eb2907b7dece093fcdf2a51da98198330cc742be6d906a3569bef0614cbb76f3e7e1fcd7fc17ce207a8a41cd58e4cd13904407a26a118dce309b6012640c35f812f0cb26d0e37839b16713df67c77a2e900d68696e554de7a24733a4faa237bb6e109fcbe6edad20dedfaf9bcbb8f1818f9d0834261990e6e462dc221717ce9e9c43b1e72b23c0e0e07eea788c3ef8e6f77cd5cb76ffe449125da61ac1d80de403222e25c2b115bfe4d3d6890c4b7744ab722b538b16285faeb0f0e04dcf948599d51da58a261f5e6fb45956c79829c3583ec2f676ce4c2593cbffda2bd4919a89a0ec768532d63e7039788600d4e62b907bc865b4ee4233a795fe54b52f873f609d5b19f7ba9e0f11777332b052f50e10d339123438dc4c7967b217fcde5a9489b4227fe4f18fa2ef20324c328d4e7ff5e02537b469ff85b640d26c67d79ee060888751ad7b5d95fa4a3fb8b81b4fbed2408030b4ca9f6541e163d7f9cbcc318b0a9f8ce96b27d51a2d213a2baa1810b2db380fe45c90bd5d9f9f1168479e791b7c701d86b089bfaa8c9cd03142904439d8d4dbb677018a2bdb64b719683cc9c9074667b68cc21d92150e1f7e3afed721aae26b507294c51eaa50af40f1f6e985fa74d0db6ab9ab87b996ea20a966da7d35910db66c8ea5d5e67f653d94599a03867cd7bf07a04a034e86915ae2bf74d94d22e00e3ba77c75b0d3c8c969aa1ac06d4b4228d970e51405b8f1272105e44874c2eaeabff79bee3745471a2f2cb55b7837f53d7f3aad8ff6b4d323d10e7c65e79aae318c38b887ff5ceedd74a986f31e442149ad72111b510647fd4e3e695605a1fbcec826ae6857e9d1a4d1c4c8f4f5d404b97305cf7b2c02b879d2adafbd7738842f11e05d7bf263b2ceb2b4a1687a1e7db0738c545f33b944fe027ca2256efdc99c122444842b38146044a88c5b1b96283726ab93dbbac3bfeb6518c9a466daaeeb8a1d226bd7a1a3364250847fb650d40c83e732f9b4316eb164ab721b82e88ccb2ea78733021a0daad2ac58eb1cc334b4ca953e9c47cf5e858df7b8b58bb394847199121b65a263158bc6b47795dca54655195b9fd00db571cd57cfdb40fd151340be1e972f510f3463e49db320e17807c353f8edf8781d90962d6cdf0e73151ca504a94ccfe90738d3d428eab168f3654f348df238980c0790557246f0a6b3a5ecd95b6261d3711af9e6586cd49d8d12794aac9defb74d02779a8e7996dd8067ed6999818a3544cd8103bc04b1ed698263b39705d4ed69d6b73f647dadb4d7c514e0c68bf05bf12729d76987628fa48dd9d55421d004603abda5b7ba9a2bfc0750dd701caee1d0a512ab70564771334111d08cedc7918e77d5615c7f25a254c5c1ed0020b3f36feed844384b47ebd41d99da5691f37035c8789f6200428ffa7ce0caa54512320cd36ca38f473bddc8492b9dd59a1ec575f748effabba1f95f083bfb9077217ab5200b396ae23b39c7ddf4faf420d26b8a25db8d5da3730d7c0c43348bfdbeb93faa1a2324f95bc4032988d21af4f2edbaea4d30ff72c7e518599835dfc88a39d225cc3b8e98474e4cf4232b7b0339ce7a5c0416f0b68cc4f76554a19b1653dfee74a16d17ef2a975f9d21cf42e8a5dec06d96896f401e6eb60f94f04e96a8051b1204ba9990f0529ab2dcea1926f5190d048cc5297f31172a688e1feaf033ac9871c6f9638530337bbc4db79d602135db815ac5f09e835dbf1dfa96ee2bc6ba7f36e5bc3bfeb954cad8b49353c4c5bcf1a4dfd369fd8a099af84ad035320f370a919e3ea06e4b22d17e41cb65f37150ec79a3ef190000298e400b2dc5748075c20153f778d8b95f04ae43cf438366bd1d684cb19a44457a48d09819cdd4ac4fe93249c49b3a624331ae0a3500487ab2a9a2e3b62b9fa75d5f8588b67205fae6270ea836fb16d5c284aed8377c589e66f7991c00bb85622d3a242a7a29e21df7a2b28eec86442abf2963928ec7b0cdadccb0087af1fb19d6e0421fa66e5833d743558a5753724ab734ea5eec4afeed8ee39f8c6fef6cb9623aef54d9da4ec78a166d89a0b851bd2d5ba3b9877f659a4961836d1d0114d39d74207cd7db64ca8754fcf2b5f94b03c6caa94b733da69d096b07762baf093816dea69dd20fe7003b0d0b3a4b69d1120f9332398d0918840e9d701b90b30547e42a9e54d18c3c8f41208671ca7fbf69610f91bcf19aeba07c0e27fb130f0764fdc155ec422d9379c84f7ab6fbc0aaac637d2a65ab38848e7994ce7a0e41226b2fcce621b3c8e42e05f0f2cb2ab51c6e931369a89203408e692917cfa43af29439211cded0f46f8a6c517374077cb6f2d006e64ea69789af75f2d50340078c22cacc654418fb9f86b151030e2d8b882d37e7c5af3043907621272336fd5dd1319415b4a348dc59175ea00de4b253e716c7e687ec6eda1983c83b7d53e5e781d2f1fe0bf7e00ff500cb9be7039e20f67ecbed2db79b714b0335b4a84d3d9a7bc3eaa2856808fbed5261e615af28155c4ca25acfd8797dcc7377ae14d9ca52c23738c72d3ae5d8bdb1bb1c7136a277dba699956c24e2e848e3c4cd35808d8b4dcd6c85f9d7e2d9f29afbbdb64c6590cf3ce98e99c7e328f0bcd095e6000d235f87ad1ae0722e102288f96919ae9e4706970441083c0d60cb244891a0f8f7a6d20c6800c1c6bfbfc2dc0c93daabc154be69d883b64435bfc1d15381b1129e0ce3a6d64f1ca171d04214c8ef9d4c0f2be0707a2252dc317f77ab7c5e74024401cd9ae5ef5f157056b1aabfdd6303140379e98578c4253423d36d9bb6279344555fe50a087ad72b2606f5e36b22a61b9de284b1e6f00662f8ceb5ce41c9d5342e7bc7fbcfefca42c5eda41c6e609e8306ab4663e0b6daa1d9da8875fd0f59f896a541c575b21f455cd81979393c7df0fca735b32b51a786c0c85d4f4610c6a83f181dc4e25c7156a80726f9133d44b0a49ad2a966b8afb2a3f4e89d54c5cbdc58fe39488c33c7357c71619bf32b1fcefc1c84816175da3d532986dc6e10fcd936832f2c8e07b2f742813364f811946cde50ace24ddd011d84cb0130374b5bd1e73fff4dfd0446e4a0b934e220e301885661cfdbe4002bc516d1854b7e65050814f336ec9cf55469d9952300fd42debdcb0de5fcc1e52f783bfbf69d2aa657bef43a8f408af975e2abfc05b2024be550e034cecc24c34789e765f94d545a40ead403c6668ed8840d9ab872f4d35a752292447ea3baed19395791e8bf04b6d2e97ec55174081185576c89cef58f41993e74af3ea76a690551fa0c2719e02d0d222d5bb5c9662aed02805d0efdf42a58412b99c5d1868561132f3f4ef0f02b47139c8506c214fa71f44bc19421e7aeee1970aa0bf5f239f21ee72526efc1e6892498b801a0673a7956c9585563a0305218537b188469caccb14c52a92810959d4e39a260510157bc4a7f23ed9c419b584b223d31841b399dfd48f714ca7b70bc6d1469b65aa4607135c1a922b865b63c9ea5a8d030746a6643e8652a325c5d8308223512453a594ee04c23b07f29ac05c679b6386e5e0960fd6f936bd52eab8d9d46a8c810e5f5270e72136dfd8d0618ca1c440b3e32be68a1b5d1100a1e98026d6a04196ef8300c444c59a10ddd743b1f0029e9d9d7f9bb54dc5e0fb598604d5ebb1fe45180dd68cec0731dc8d5051735b61907304b59da7f8993bb00bc535265592016fde815c20acf0d909ae95c981ec64ec3845366efb4906bd22e4357249d9d7039ad99432cb543f962f0b7841d5876bdd1a4562cdca4d370c459a9f854a9576dd4a50a447afaf2dd3a5a34600275bdd0a978fb54143bbfc122a8c81d5391c2e5db37b630e0a54c44626aa25246aca0999b4fad2976db2551d686fa3043a34143f3d60ca7171e606731c6b607650bc051593879d78f517ae995f77fc866ba234e6ab0339d4f9a8b3cb96454d8a2608882d3f8a358965faae7b92818bc72b022edb1eb8e2f93e1a1614e9aea46818e63cc04865a9563bd6ed393cb45c32bd8ddc2c91d749425ac8fc75a5663ea2a08be7ea592fa1546bae8cd80e6bc73de2dcce5d5e1af5fa885a4c4c2aaf450af53d21362121d5fe8211e73d1bf1a60b363d9b528d29cb2e2aa9fe518236dc723b7a7f4716ecca2d2a5997f508366a9fe83a86b6a2abb408ff73221becabc955016bc3cd422d405d08af9964b28cdc5a242128bc085045834ed12b725c569da89f92e0158f8114ba87e828f2a3f11345ea38d6465b398f2323bdfc51583a2d0b4bef61ba0518bac038449d96bbd1a338ccbffcead3befd3c17bbe68462add3eb6f5209617d518d744682b9d4303a0530cb775267a0dcec694a097fb24fbb63d8c522a014d9e613a5c4646d7f49f52a40a2f171a9c98a0567511c3452da2fc1eac397dffcf35f2d1ceeadb1567c71fc0906e9f87eabd292647db6139dc9c025f5077f9dcf421a4fd7c783c2f24e34fecd8f7f36576c827481c54705083acc299405757c9c8511f05254c1c8a3e5d993b2e45316e4c7f403fbc64c1e6809fa22b60ca8a5cab5a4c441bb1593b0625d44082ab44e29255f0b9b2fdc5b4fc9cce6c1777c786f35eb3ac6ae1c208f0cba62ef869f08f837c0aad59011c125b80f755c940221a5b7cf88d807a81cc0c051f7c07e97eb03d3afe21d47f9567f31400a93a2f523076d94202177710a9a52644eda059e0b58d4c2e12069d7d49871e3ff63b7d177b4ecd0a242506ba7e61f59baf09fc53c92075816ed4ce5152ef1bb6f6c439aaef1fd18ee007872e06d77d6e8f7086f7aeedd28dd1801fac298a7ec433f14c9c05cebf62d030790c3dbe9d675038be5b12c3fad709fca36ad92e71824a6f21dad3d7cc7e21c321e3c88245428f7cc51680958fc1e09e56598f3aa4c35669691ea09d0de61be3d00750055a32f7ef27dea43d27c07bd34a6439a1045f40f94a1de5f36ebe1ecd16a33c3e78f5fb91015ef9043295037204df2b3b66ef8b039d4eb595abc63fecc276cf38af3851686994d1cb60dcd5919917f64ee1ee3857c40f68ea7994858b010d9725d8381d4413e7abee236276b419673c104a20da344bfc5664d565cfdb40b3000ad0b9571d2ae3b698fa2f6f372d94b787485ec79f74e6c2a77ab6aa32e76385589ad86c60f04e5ad4e4bf4938a6c74253d14ac1fd63415f04312746c579b457ae4919c076bd3a910775371906b7268331ff050582f5267a37c5b9fa0f6e5a66193aeec9543d5fd3f9750f0fe367ce122a69f4c534167a633077364fe18b0e28ad98bd3d61dd48dcb8287afb34104e0af4c969ac750782be7a478e0982919f160013372dcbb67971dd4f1675becdbaff58f11b4a8f5e8b4d6fa94703b01ceb3691ae5f7218564f020ef7c0d1ce26de2142fd8c1105df176c5e540dddb20d5fceb5b97787dd33595b8b842128fa24738edeb84eb1ecda9b29f4aa4605b7b425e8b8dfe25f8bf04b82e8e6e17a50dadfc6a003537882bf0f8ed5893a87c653a74e59b3a0aca01326fa08e76039723fa43a8929e643b6a702072f225393517c44a3ecf51fbf1c55c8bb73af6ec5676e6ec90cb9326bdb5567303ca640ffbac54bf123246b4674e070b4048a1b6d78f415b94f51308bc2b06f8930729a6f8cc8b69cf578b587ad436b8bbc302437d294d03e067634ee995a9a6974f576a1dad1dfc8397b8b06d0c00b4f5627dd27959a46cf62e6601b08d23b975da98afa20ea006127a18f35c956094cc1fefe65cc1fb88067d17afefcfe281181b65bd6fa029a81b62d57c3257d53f82c5c74f76acb29df659a8752465f420668b5b15fa8540fdd40c46ee7b3b754cd50fb43ed1b6e746dc5e9b34d104268e466fe6d0407ddb0dc18d4246f2666f5cafd0a12be3ea0412ae80d559b53a90a4c6f9a747f8db514732425c41facad36657ab3540c80bd0286a9ff01f1aa977e7dc7c73d3898dae351313300751687d55735e3276b529798edcc419bb41dcd750dcc2a223e36733228cbc1bbc196130e1e36fce94f9406e5b0befa318f58571427f17c65052b4eb1ae3bd5a8659e81afeef518d312b299233a4554d08b1c336a3fa350757ebf289fad5fdfe51cc520a16cf1d6bd86473cab95ba64c394976ce6931d6bae2084f238138b1ef310ffb86c433ed9065293f5a04e0f20cdcc4e43ccf74edce019d15661b0d66ca7837c9ec681c80f1da440c876ae1abb743462a4897111c6e05bccd4afd3e7071fa58d0a54fda643c953a12c7165d25c77fcbfac56faab78ee65ed0bc8fbb161432863bf27e3475cfc39a670e1cd5e5d8e5ce94009f2d8c2b24c24b9e5523f3461f1d36e1dd62dcb493d06d3eefcf0f2d5dfa4e4cef4ffbd4137fdd77abcf632d5e23dbef49d4e6357d406825890c52c23f846456d9c44f282b0171366c82da23cdfb209c89ac6a7e92b6c54da8e765fb8de0111ee6b4bc836a3f096810edbbfe92590bb9260421b169cebab012bfe323f062896bd39c34a393591d2dbb87ea3564d0700be48a6849dda2486864585a4d17c47581fd495380600fdd042fe296edbc51b3c2666449dbcc2f8d0dc9550e41736ae8b9a756ef15a83d23c17dacb82b24810ea5ef8a19a1cd6a060c159cfaae8aea014459bf7f8ac6d396191d714ef9f69b16510ffb0d76f9711d6f094078bb5adf4011a2c54f416a5f180e25aefd498a8389b01d3ea4234c79da164eb91204fdad28de8aadb8c4aa32dd0962fb7a11d5a7fe3de8228182487f85ff72d18f5e7d911c2e9fac0c3d7dbad8671466dd0d4e4396840367664dc495ac4ce431e9825bb4b4514de6ce0b01de390a655cd4a62504dd2f731bfad6d37fb0e34417b89f987239d9472c119a4a22917f83eee7ecec2a20027f65362304a2129afcbdd32894ad24d7266c7160fbba2e9b3607ea200ed5f2061d92709de858ab8c0ea79d918de35feae78ce833db26bf2d8b2d1b2bbb8f5efd3b69581a96097c86f9225accd962322e98cdafc71f6dbd77a7c60cdbb38554b884e3b1f8651ec3ad1a41d9a2d74aeaf26f17e08f84d42ed902d80a233e338a53061a0b475c94135a37be340ba4907c43697a4666982a4571a41d157307c2fe1f4e5c9c060a13baf7df830b0b00226d2908276def740e0945c486b391e93ea2f734b791ab5fdfbcc88189a932b3df3b9ca13ca827b2b0992da0006de954d7ba9a2ccfce4d5c3b5ecec1399e8ba5e49d84eb1c1fb01946cbafae41fb8773cfb357de6579560acca370170f977581ef0e4dc987961cab6773a6aeef51d552763867b36f9969795bebca049879b2aa8f4961810e4de76fb8bfffc81a33ea0ff1bf879a941ec1fe56e8ba6c7ba672b41b61e8d50fc986ce7368d65f7dcb804f55d378671de703ab6b8a685ec6abf885875cdb7c2eb99f3ce69004ddf19aec4c320b4f7b7119ad730dd58ea64f33918d15700518472c8d417dffc06dbac03a69fb7dc212eba5dcd15e4e66685d1525f6ac9540fd615bfc4d79e343b1889993600ed91076503e062310112818a093811bbe415a824f953991e3e01f4e664a3cce4917a85b9366aed33e10c52904578005f37465e329767b9ff3e94932b14ee6f1f490f5a77a8ed18b9d45f7e7d5b3217eda359f6ee77b7bf098c01c6c1157157f7ba7ee2ec6553541c33fe7750547bcf04f7beea1b90ce8c07572040200a9bd008e3bf2f9a709a62184e8fc4dff5d6cf6645e48e9838fb37536160a18cc69c54ddde404df39583facf073d9b9493f0ba6226714cfe177db455d4641cf33e6edb50d91032b152d208dd3969c4361d452c4411d64bc2560ebba0de6e3bb31dc789de68765211661cc789aaa358b30384e884bfd27f47d79b2cf48ba7e09d9a1865e82e82d34ca97247282a34e80d14f55de515d62cc2fb7d26f5a288cd2c1e45adf6a79e624d4a7ded74f242b19708a6fda193f17f2ddfefa73fd310f4eaf417e2888c2cf1932b879de34c2d0257788b504863d481072bfd12301f98fcd8b0ee0137744981935010675b98bedbe285be45e6560f2fac508ed3119767fce1721f0e8dca34696b900be2d4597aab5af1367bb25775caec9de62632192271ee830512e3b7a3b73e8610f4c3e442198c6922538fab2c1249bd502079216fe4f1fb17880186c0565cc493731446d948d2144eed99a0bd92d74c6a6287e2ab2d55fd9accb2fff8fc272e9997aea66da1879421a5e3cd45ade291d94b0ba9a9ba7b041610c9d6eeac1a3cb2411e45a33fc6165341dfe7e3611508d20d4f5b43dacfc9d06b1298b863ef33b02206e4ab261c2126a9cd81f0125ef59ffa20ccbae3729c3f9c017bf7b39a3096c7698ea1f6dafb5c953daedc9f6ab520301b124328345cda90a37868cc859c7bfa8db4a25c669753bff8b37669f2d4d4b7b4c8de3955609433b9ec17c15e1afc7201c42065cbcc552c6ff86559c593d2fb9ecefedf7099990d65ff2d30ec53240c54d5c2d30c4150b0547da105285294bfab8e4c120d65953b6485e245d0703fc82d28d8bebad996819d6aa659bcb792cc78527f6e9d6ff0bce602536ae9d9e54dc30c1b08f464e584037ffd2aca780aa9ad13cddbf9ac5663a414ad6f292eaa209156ff666794951b01d072d00a82a39628b384006b8a31abbdc84ce8453f4c1c06ebec4a64ad725bfc4dd634b14b3ba97d389318f1e9143ddb0fc0b9c89007f08d8affa56b99d51fde5c582af3f202fae84c08b40092f6402b679fbb9248acaa2b1111c27996e37537a929abb6b89fcd5ed679d9727731f2829881def0c255012a0135384b5b2d8bef0bf2285806ec8e6a42887889fb8c160cf2387deec7b4456af834d0d6ee3e2f70b8cbce81736199bf78aeaf53337c54be4441c6ca61268b6978a9509d84c0b31973979ebeb0f0a04d5e7def8cf0b5f5ad620aa27b9ca5518044b7f1145ea2a49fa4a2039a8b67c50223b851c3da9a5d811006e71ffa1b9f5e80dc0bc854fc84e807df1d666f66d3ff03d3c8ffdfa2d57afe044b949333540fb4dd89c9ca986110595bb1420a6dc854340b5c579926983184e7b72d1bd8408bb016290fab3d31aad6f9dc443aa7e1ec5484c9dd2af30a87e3f739188ad532bb4cc4b01ed740b282ad2e6687a09b6b4d6b73ca77e513012800d72b5880b73f124798ddba28f1404e26c2067f9820ba9bcbf4c2315c57e92acf6440a4c8a0ac132f3a3658ad712443cb4b17a6bbde66f29cc2b717c456cf31fc8114e9d482116f5a3f9bd71fdbd27f491494829c36b96c5d04b7161bf96e2334c1ae70dde18b4dc71a21d051fd3a2d229351a84f1a17161e222a08903764798722a03395c92a465de9e067c6d594fb9c3ed46f3e9dd0821c567144c0cbbab6a4e8e33373553abc3659ee173fa99dc0c251b0a6066bbd6810b1fb146ef8adb4922404268fa688c2c8a1183f86221f8e137f96e782242ffa23e4e25e2756819154d527efd888323c203490ffc5bf258b4adc662c604a426f600a944c929eee953dbdb3c2bd940aba836879c475b082d4522d6dcf35523f2c37e2109f24b1373aca6eeecd40c5f6d097462fb3b51bb6fbad91d7bdf114c480b7a6aeaa64a65c2a8cc1ccde325f4f7c61bcc6f43b0dfb876a11d5cbd16c546ce1b4c0027c7cb52fc210317913f66a431158eaebf4933949930bda948da523e9d7dd74961830a1e3e37e879fddbc6280124f6c455dce45eb396f21de962598e3c0da89813f51ffde8262f9d064186960267be6864459486cd92567246eab4f2b86b35e823fe0a22dd3a425cc298c84b49dfa76106d3b868189c53a6665caf254ea9550e32bda8c679ad610ffae20469f7beb88e57308ecde3255b764ff2839dd75a6e102cb3fbf1a05550bac3bdce8c6c2ede3c2153bc39e0aa45c0142638f3025c6ac5b9b25c8a7cbfdcd9ae91cb930128793efb7f18255f2fe42fb91c12585d102aee9b2bddf2bd580cd36e4b0a17ee81ed4ccce6d77a145dd1340690a56c0e80d8de5c7c508f539eddbb5d6b89b5dbe35dc7a7cebef24a3f95430133ef694116a2cb612ce7958b39cfd3a118b1b62602f34c1c324b854d14a88518714c33acdb9db028970b714c362b593bc66aa1cb89287d4103ffe77e984133fecb341f4ac9c05f09578b186b0b1feab0001703b1729b674011f06ad9d875c1c940034f45020a355c980d1b919fb96c9a22285f822a7a852f7461b8ba299e8f85ba61ccb45fb9460d608b8897a1db7ae9adcc7e6d9f8ff544b0a527b58ab25c55926e83f52d50d1ee7a00fc516e00dda16b3cf3b55e0933eeecf94343fb6e8051f3a054fbec3848de81d834d8984cbf0f47be2e3efe84ec5887eae3b92b82fd8ca891ad7ebedb5e647b0cffe058f93e2908868bc76256b027dde697be69bde47b5dd69821c671c7a9b3a3bfec05157b9440f2a4a35a4825d43fe63a1ab8afe637fe3bab5eb37e1b460f33ec6a8eb756e33b29531888fed2103d826780b96f6e2d92a2866c2d4463f0970198ea1a3ec78e08d2bbba87ef5df99840ae4bc3a1dad83eeb2285572608d7eaf6da64c6cb9a46c57afdb36513e1cf406ed5df7cc17a2ca297edee36be85879a87422d2ebefc235f9ab3dfa93ec22230d9498eb930876220fada9a967c56df3f4c17e3f0cfb8676adfbb987785ec0191bfc2b261edbb20455c167bfaee50703aed380f4450328aac4a439ed9b69705dc770700c62b12f48f8816ec59d8eae4230019e97489ffe3a9ffd7c7c902dc5dc3ea8698018b7accbd2550322b182848b3722e9c482cc94e59ff16adc3c94459e890a8d1802fd2820cce645319acf04049caa8fff9221c46bf21347e57a1d130aa0ea6407607fa89055351ef7631ed7f72c64ffd1e8fa80ec07964f95d11a5c9127ed04e301b5db645bd7182b02d9e8ab3d89248c656cded5896f3b6ba24023d4d0c853117729377ed9123c59445e74f6d35af869751df54b4d161e2dabe779d80795c8ef05aa60f4343dfa6d599457d4445f736da9f14b81eb21302acf551e1bf0abccae1c1b80b49e4a5b0a1833f2f61436a7d05569060fdaff3164c6cc1cb21b726881f970ba3842a605c37b608163ce56228e8431f2f685c584657920b351da5f87b895611b7670b49637c16babc0b7787f4f180914fd042944a27d92abf0d0a17dffe9606436fd320e893bec5dd31fdb01ac1db41def58684f151f1211fffd8b75f4cfb5c28090847bca4fa90a417d56d38284746a43d9e80302c48bfd392148ee500909ca02b09bbc540eb5d6f4d91be6f55a311fe96e73425628846bd57b36a5f8239b0a4b0ffc375bf94eb8d703a30fea8717db17351f5db59a9eca3cfff7d4d1cc403b72c68531519f031cbcce4c80ced51839e9bcdb2984b3921a3809ad926f23baa1fd4a4c389f9f0e0cf0e0f38a2779be39561a1ab940f27d85bf59752666412273d4d38d3b2afbd01a4e13092710697ac66b34e2dbeb522dd45e83725e87a67ee33aa6be927c84eeb62ed0b376a7a56609a178b5d91c78503bc070ce4c57aa6cae19556c001fb96cf64094a32b3ee40f85b7f95282dc67eb4955315d85c061c7a65e6cdf8c3955265bd35bb54f506280de9d7d0ff0b1701bbdde7022d8dae1de7bbd09dfa52e80e9ab7cda701576f838d194db79aaf82fb365a5518a695c121e2098f7e24c0af4afb01ed80e6f3a828478797716790a0ac25b2b360c6d56a603ccc1bb892ffd692a590e73b8661b0acb849808ce731ed876006d041673fb9874c7d675e3135056439e01f540621435b43832fea82fc14e62e81678455ac37c9af77f9e2088a85cae22a56be29dcba66adef75c18857d50ca03ac58e78b59ce27e7220b20c61e44899078be2317321904dd42dfc250cb16d2a00d58c9ea051e4c109b726755b017790d7a5a4c699dfad8b165bf223648e7962d0bb9ee1004c2094ac295488b136c09094b8d3c1d834736780e98401d5b5fdb117f540e82805139eafbabe3d2e5b2daa8b7112efcef51459d141cd9c8c8d1813d8e09aaaa181a66796129b4bb05c989a6ec68feb62adbb3bc54b99b6b5b0199cf77cc60a883375c39c1d7abbc6a9763e7945c81d93f72d2b95ede60885c805a9821a2d54c0a4fbdef2facdbf09604b235a120404fe293bf7b600f0604e2cb05d050bd0b20cd150ad3c80c40629c4240a4bbfdf4b11bd9091b0b40888afe6c4c281f0280fb84a570056bc33602ead2634fe8851958ec93c9661f48a2ff5423dd3286ba0a63de9e5a41b23d58c3600073521e9a36292352a4dcd8380b63806f309d83acde9516d52b6d76a021fe2652d5e4cea96b27ca8b532d48ace098f0d8bb2dc0aa219619a70f837d7636e01361b500794f35d8b302b464083359f0cb3efd9997363558bf9e37fa0b5ac2e62f263a4bb4c84cc18b938a755ce821741f136c4d210c085efca49ad63b5b8fafe0346759f4e9124803edff42991d2f632e9b17f11998156512ed978adeac933b5dfec45cbab694737e7a37fe9fbfdc8c2a984d7c2a73725143fb3624ed6dd8de2632c7e506b57da1d811d2ca88d8253d34304944d57eacb0da2be3c4508f01f14b4d9956db35aeafaa942f47403878785d09ccba8271b78bc937844fb55a6f335451a46d5dc82fcf1d831e1cfbf85ebff7ed4c4490aae0b0e26c085c053009398752e6f6dbc817abf9824f6df456ef36002d308c25549bb9a169fdaf045e0187cd875db0b4329c86d875a2c84f805e2746ae3765a07c23aae5051ae40a0bcb3eac370b4b0abc26945b7579ec6897de032d99bef1b3577ab00e269ba7c59c7b11b60ce88c7c195c6ac28115251f7ad8cfee24be1abaff05b10b890a53549a95c6a6bd4ce863cfe3359737de238c540be691c7c4753985a9a83b6e85abe4f785ec8fbb0b189b9e6600d0012416c1625f47814990095ee7ba27d31bb2f78ed8b900f29f0fa568843d859b6999bb4ca72be80e76444920f279223b8e9a967d43a828e60bef5fb30022a74c167d55d4acb1498573330a8f86d3b8b1fd9a943a1c4aac34369282449e4aad0cdaa61e19055c8e781db5f9e69119dbee3440ae7b429bab32825cb513d21e77d4878888e5e45d16d06ea40d9787a8a950753c31295db2aca3476da306d81cbe7d78f95fa3c0116b6e4bcc1ecb98ed14dcd9b48d38c02f42450678fb6b0a9fb0b2d9fced05989477ad933bb2dc07d8281e985684d072916955080fc798d07bc55c94afe0f2341a71464e300d902039287f137275a2759e399417b4e9116f0fa1225b7cdb78a01b6f62b93a7bc1a50692807e325506fb97f2bdb1d4f477d3128e3adaaa7ba508c43404c31ca04f4d48001d7afad3cfa2f2df999b3fc6ec52df56eb181937bc63a0269340cc02059caa15a98623b338af8b69f26d062df556430762bf361ecce815ce62c110aafe2a197e72785794095b3d410e52d16701ecdee84ec993c736c9f03623a0c9211e446df8474ac7408bf210b89d7f664e4cea807122b340f2100e51c38418b779def40c6d498ca5f675c3dff8f6f84d7e0d488f9166c29b34f61ebf99783a4b4e0d6b2b16bd63e931c59bb2efe87a87df287bc9c067a5e3230f49e5bb16ac5d80ed77bf9990a90c115ffd883c321da0f03e4c34c69c74b95a194601db37a75e9346cbf6d84fb2282440dd91186482f6c86a0c8eb3ea9da4fe3d087e833174186f652dfb45e9994beaeac85ff172a0e66aefe0b731906ca72066bd66958898d6a9c11530bfe43938711b68cd663857b5dfb5abaf2a0d55b9062fec8d086bd7279e489d317fa7ce0ab6971933c7e39b10966b5ce339bd947563a453dfa6868d004ed7819b7bc8a3dabceebd0af48eb887bd96e8869d57e50244d61d76e03606d1953a769471c658dc75fd3be59b329efc84fe859ab83fe94e29b8ffd2ecd39d26d8a9f323a7e3a95ca806790c6066c8bde3c2548135a18402ce9b2ab9c554f79bbdda73f1b8c28563751330cfe0f4a155c27c54d6809fd775ab74ff968ffae86300a56312a2b8ce1bdb372571aa11ac641cc8119354cb9542343fad4f224bb40a8a370de9cccfbef68edb2e3c463c62da41aa4dffb1974357cf6240203976118a8400d6b6b07f433c44d0e71c497b1d7be30e1eda5900959dcaa9c156a4dcd6e43b34f3306b7f80d036141b96468a6f8ae5d7db38bf565fa729802e8b000564d6b9e657c9cc783fef4ec9145d31149435836b547bc24a6db77d977d9472affaf0fb6e85f133458737496a20301d523526b3ea80affb9e8aba7aafe3e2d3bb68219569103a35bfaff5d6d95688586c2308db0ac2f7e0be5dcac337fd117879624e2047c2287f5670fc125dba429d1526261f2ca5f2fbac3b53c868bce98004ae370dadedd60f093717041f5da397f1fdc5e2a6daa49146c3bb8cdb89e995bd59490b78fe21f8f696a2b1446bc333882b081331850cd4ccd9c35135165336c131037f4153558aaf36d594fbfcef3126c7a0632c4a031083b2309167b25ddb24e3ced8aa56c7e7470bbc089d00998f0ac6941cff2b180346630e3ad182ecf3fc6bb54da0941e4dbe8c9627a93223933ab2599d20f83b537be6e65af1827ab524ea5bf7a6d127f76bb433df443ec87221be0af2c02d309fd648cc58f75407b2dbfbdcb8dbb7a08b84ed1c6527fc0ecbc6dd3a72c2c2b56257b2eb7324cb89ced2915c0c131fae041dcaed7e2dce65088b3a872993a42faa296c509c2c0b9511e9d5087d76c3ed1791a8e1983d94df80de026f865fae08359002cf92a9fba741a5d6db52d051fd370e7ea9f1cbb010bcdee595aec2f2957059e2f39e1b3a65fa8a82c2d1ac952796d26c5a290186db2db5bc30b61290dab363c3f50d66c6d8ae6dbe11198b97d43cc32dc57283e946d6fc3035114f5d1d1d86167bc4bc813bed0764c088cb23338dec1dccfc54571e7a7762ff3c4549149e9182bb5b5c235931535c68fd9ac2b827b67cc4567c041581bdf4ce4de9c4a7e135cdfb11a1f9f6936c9d490a05ea9bb525844bb6674ce718337c6fa569487277f3af162a721f8ea656b58c23ac9e22105b9e366b291f644e33d9aab952f1ba95343aa4ab4b4824aa436c0067ddefe160299db82385df722cfc73322fc6496d526d61d650652ac002be2bb119f79a883f828d41fe1d4328a5f8ce0194206bce109cdf09b6a79fa9123f9ad9e045f53d90c2b142c79e90c9cdf5996fbec6f7eb607fe8b9dd829572848698e708ae7c5d5f0f6db6e94f7e88f25a2268aa8150b492945067ed7800a30b7c1c643e8a279b8a6b990b348c06b79cf93554bbbd010ad79e898e73c5e4da99c888c439aa5563605ed7f300a61fb73d608b8d1514b0544b20d65a09faaf61edbe540dc1737ffadd56d9331c2f8db5ceb99cc8692da48f59a55bf15070ebd52ea2ad009e4ce6fb47c2b980b9d42dbb510ad54e782f819d156e7718988e8f0cb5e699bf2f9181895ff3d9823e14dea1b446e7a53001d59b5bdea487e4258e58e92d503bef5cea84e29f521a36920c36b53d523bb0cb27d9e1a15f72991c3e621ca5e57206ec88ba0e0d39874f43492f22977162e0b078fc008d97ee095cab8627f5cdbb4a41a3a3c2cb26f53009b35655f9455f58a2710047216d857079499f767e46fbb0962b0cb1972cd6c82b36a9d9046408c82c9db0ac09b7356642117df080a4382472870265f1ba829ab59b216054f2afb113543b96bce896fe9cf7bbb5e1b33462b5dc52d7443db5613336f731de0fe7aed53771135750efd89171a8e609ff03b3b0b1615cc2fbe6a4d00dbfd6064b2ff8f68830eb65b50c9362d3a0105c445624c1f47df8a07359dc98158a923b8a1c74eabe83cc130b525afb2264fa1ce42a6a29c14c90ba09cb5419f9d41949929b938e21e232478eea96b3ff71e17c5c914a106e450de34c671f7c9aeaa34c4e7e2c76f847ef4540d6223cabf94f9e1bfb45058ceb3fa4bc7c2ea51731a6bba94201e2867a43b4590479d073aab782249883b36bce9413d8d2bb018b0123d4952de1f1c191ca49e5589a4188365f6f4b76757dd02cd3aa53405bd93bccfbc740e68d4714b4daea76e0e07861087d004da4d6c0da1f85311ca16549c2cb3a19f43c85e0c588dcdcbebd061865963ac56e1458fc3ffa3dce09b3e3410d6e2003e1b6cc17b4320a73354c99b13eb5d4f19ae2d6dc38e2166e31dd71a31223f832626c6ba60397b1ec564b9feb22ad0455a4a66bfe110e14458327db0aff2f6c6384671e7f3486b39cc7f107998f34bad13fc41fa15f3eef06168e4e6ce7956fa00f3a74b5c7f04421ea55a6cee7aaf705c64b9680cbb0a6094159de1aeb7172497c4558b2a78ff38688b68c183b5d14c8031bd009ae3d217f18f895d13ce84d6d84f6315269ceb78ef45e468afa6090208be2dfd8eeea81f9c664804aa59b02647e0735ac933ef1d671e71f24588672cb042294dc1882a69bff65becf962a8392e9ac4aa7efde23881246e01f3989532072458fd467f169b9a0c81572a32cbfc4b9536dd9d34561e167d720f3fe7b1994afb3333608133d2ec6f62382b9885dfb01726942fb264a3d281c3f63d9d48b9cc71e9faaeed7840619c43f899dc86e4026fcafe716da4a162e9bb38a795fdffaa660e1b5da894d0d4bfed5f436d0a01f10f9547c620a7608e30cf38e89150a48586a5b04d21fd01ad19720ad9d74baa1612fc10790e1a3ce783f4788d2f5a7631deb11ef40cabfacbedabd026c8f41a9ae62496340ccc161ee2483471131bf74e4c0f035bf144830bcd616f883ac8c159017a60ef5d1bb27125a8a01f4dcd92108ddd460765999331b076cee9f7168df2115624d11ef45e3cb51f63ff6663cb5585686e94d6e70262b157ee328c7c5eee935dcabab2a6fd31e5080558cdd7a9596e3ce377dd5da8013e23cbed8257aff7c25eec35e1e3066062e3a6a7363ab659d33b4c9bf9b80a7bf0179ae91ce56057bcc453b2e9d2cca321ef9dd56791cae4df5659b466dea3ecad22042abd5712444ea06577080f155e800a9e087d39dedbf435c0a792467d668d790142c640cca83a74dcf16188acadbe7b6b6d711e56eb6476b837138f0e027fe425090eaab0281c08460f4c06127d8d6df9ad6a24c1dd287c9743f4e24af20b426decf3c856afc5d10731717eed86ca9551cf0cc76c887eadb350a9af3e66c3511a34a88855a4ac31d9ad44d492d0f0e77075c708d69202e414dacad3185cc6f4ee9c7e3f10e6e7337c4e5686d24b05924ce9c71d8c264e3cfdb387bcbdc0a5754e48c1f55c4fb1fcd32d4a7a20fabf4213f769b49d66b0c62b193f6cc94a174002f27aaa9359b348e292463e4355e6693bc6e444ee83451616d5bbad197d624552da30c120f5ffd7f5de356ec3b193926796722418ad1b791e8f7d3dff981edb9a98e8af200f2e9efd2ddcdf68458f3f3983f666718761ce1b0ac9af9512cdc8e18c2110c6224b9c27e7066f0e86f17e9f888dc9c1ec925c77e2f1c97f5b80e75e48daeabb3a986b47fab148801cef3f1e09efcddf37a7ebcdc4a68b1caf5dfc2bb142658d5ad586cd5252a6afb4075f3a5f46328c16a59e42b5f4125d36b12cd7428934b8f4e6cb13131f859d33a16d359e2678e3a938bd260045c195ff95af13992882e47ffb6cc21ebe3924983be5e7c4882402aef8d57d009d98938ffa364de3d8c5bad16e4569af304b72b622e9b1c1fcca1e58f1ff97479cd959e5359f2a1be4e00a5ce359bfe6280e26c4b3e213ff7c07493545525eed01b3e83489130e1ea43d0b129e5e9398b96f3c6192069fc3c1f21555343ee7a0b59e32486ec0867703171687e2ad3b462f3a732cd73dec16a46ea8f033f3151e7e0313b906220593f8be90eb82ce48777bdf28dac94dd76f247aa2300b9913d504a9c4fb39a5e5b9bd36062ef2f78d5bd0ac3cfb74461d618b6f0e94f972e56eefab2d317a768586cabd77727d84e320ad090cf20017b7d2ce71154cec4e70afd59bde8433f65ab2907aa23e96d0ebe417ee5c496e393bbd5e779031dc10456091b9b08bc419f5a4925460e44d4e5dd100fa4acdee7bb9a766142f8a1d819e839c2a6891d203b4022d969ed6ad48ddad4275008a929fbb4f95c37e36a87e8c6f378ca653a29d5a4b90bb58fa085a9600a22b89f3726be432f52d64c17c9d222bee85ffbe14a43252ef80d502edd65f859a563aaa8adf1fa156baab1836a989710ef8a429f5deebaab3a53b19c72c32d168c26ffedcfe152c3470d280e43578ac4461e3a47a7bcc3f51965392b7244c058adadf46fb55045744cfe6144c15022378849cc2f7ce1caa23bf0ed02ad651192a9e8991a3e5f7c14c857e548d3848e82ba30ef31f6a37c11ff8cfbaf0ac0b766295c4ed745adf534530da036ef90e30773d02bd84719d56277605ade39fef71972f5d7caee25aea04c461be7baae511cc31921f71d9765b3cbd119d0c1622293a41449daea873881363e958772cb7467e43e91df1da3a136129fcef8ed24761421baacd7fc1400696cc02b1636b67062fa2c6014c5becb744e8b02c3be53db53bdb4bd50161af56de04047cb5ae47519e50c9692f69e6cb9839db440eddee1ed6a0a3de0b3f3e844a503f37fe72fc45f5a4732f861637af93e46d43fa4dc68c111abda54ba22c52ade86884fcb550ebfdbfdb52c77465c9bb7529fb0cc4ca95bf6be3fabbd358e3a848009513318c29f9a48c57d90c20e506bfd7fe1c587fc7084929332596dd518efb0882b0bf8e2982bcddead53934766dfe5b6a01cfece818de9e8beec939514e0d2302996d20fb5cf02f463021c3db4ea2e5b7a923b3391e5a43b0f1762d38b81e786d7d4afb095d951df7532359a865f9edb562f95778e54904b96edcc8540b5c184f18d06c8e5aa101c5d5f5d2a105faa39cac7222f090592263284f8f8f29aff35e81dea17384432d7a060591e27d07c54786bc2cffffe51081db321eaf1144fc99df400f1fc527c39cf71e00de65b30f607223acdf0cd6d8696843183599678446c5303519ba94d595eafd058c0d58ea9a6612415eeaf1c3f37b524d118e43f6149b0e8f87b42344ff1e15237277bb17a24a824bd444a71c6393255444df507f70772ef7cff293c42f068097dfa8ada05f5cb50d28af6a431c3d48c8fdb1a8950c17d188fb45037b9572769d3df9f984587ed7b0756e307e3957703c37bb396dd6e05641b013e4a54c48d47a0a987101a30e5cdc26a38ca750b666906e73f3dd4d07e4594953be2ab1fe9b1a673a5bfcb0a3169f374d34272e86b15a930d0a3d659b9aaa3f5a6c83b2d90092f836eb8c042cd9439590d3f58ddd8c17a236d5f88500871cf7267e054e1447586120977fcac0c3541ed8ff4d2d6e1bf6166abcbab7acdcc4bbee157ed84263f074db408043a23acf997e1e8fdffc495483461dbbdfb267936d057ff5b0491b267eae3a7f926c2f4adb41562a876c616257a70ee1019b2532c9475d4bf61cacb17539e306f089553546d68f20956412c871b598cc8bc544eb17aebf41fc3b24b30446afc13cf224fe2fb525d4415c60288dbeca8868745b72f8beeca7483d725a467b0ebe837c79ad47a0c245581c19060d88234a494fea4c4a080920bf4ac607f66c8c326e8fa4dfd5896e6a0e86d1d6f0a59c7a4624cc752afd502ea07f35588901da60761de96b72f475a3f0bc64b72cbdfd5f29f428dc311004891325b5e622c16b794ec6b913b1455b4f0e33cc3b582e0d8c387e241ec2bf9dab4d35209c37e8bfcac17a8a23cd506cbd2571ee4325acb4be11e1e36846e581c8575f77e71093fd2d784354872c811f849501e4dbe3328a70a337e9c1187bfd977d9653cca6de29b52fe2c6f3070db47ed85d2f0ffd59a97ddc444e8f56839624014f225b7a4b92037dc1edb1bb06032f4743203d91daa946c683917bc4cd6c20a4106c02f843ccb9ee9d878b6fa2c854cc26b8bf02cf457eba93fad019beddf2db3f9959835a0d23d208d38c1690c5f75672f1304bb1610d3d2a3ef8904fc670704541b75195da0611c060b7dde45dd856affe1dd31b693d87898e1f0149e8772f82af7c5aae8899c0da542fdaddb20c4d2af0381f745b427929f6f2cd3f71e466114748ea45be130dd700565f9ddcabc6a7fef498e9f02ae6113d23e69d6f290268b6d22c784c6919eb90b1a877b140a52c4ce98b6db959b7978968f6088ab7d5e1dde763f596db054ecb3e0518f018cca4b472de139289edd7140bc782310d8d163e4587ee787f5bc3d7d667db34646b7e99afa8d8830969a026ea4edf2faf555423887900c4b718ffc4d2e650e21d28a2edeaca37e6d7fb92dec39fd0e280293fb2a17b3a74201c66b9632a51c638f24b66d4baf3b162bcbc8668f12395cc60551770840c7cad4454296abc5ba3beec64ef49f6d29f90ffb737a2909e4e0e63ae02a0c959513c83bd78bea035a98d1ca92de3ad83c70102f4541c9c021667e0d1a819d504c3f0adce61487fda9cc942792c7d02101c260985f99ba1025cb9c189073a259fab6803a1e7cf7feebe57778196d4d945d558156aefd0670a6201647643a877b2e508ea40b56248dc3df535fb2030a729b27504a71b82d9ebe938a6f486d5e54bd9e72d130d518cc20ffbcf82614d4d5dea4bd7930ee40b283dbd79a574b20edf4b4728e19cdf61c66cb604bb895127b3d2529d80228dd66a83a7ddec35f7cfdabd76db3c61374025eeebe51feec1cbb80ab627e1d34e2487c072b40b3ce0a9831f01302942a7345013a5c019b115cb0c2fae20c4cde7012c18a65020924804fc5736bfb6c8837c84b7dc9b2fea722267cb95198faba159019ca10b6dc8ef58744b5829cda0defbd8e833ba2e888c7c8d0517076a3bf7f0fc7ce10e56f910d8a30391601eb041f06e4ceb753728f53034af9aab728b2768ea573ec31f5cfaaba08e6f2206d2ded0e7637622e2ca0713b4eb2737e4649bce3b629796d456721cf201c3712dd26d88c5d46609bc8ca82d3235d4a3900d76f7f2eb53e72e1a3b62d5fe5d01a1ab85ca5e441866a8c9e20e212e8bc48760b8ecbbe025430a41e833116c9bdfd43ce63b700264e641b78ef9961a4d4c214c67425c5e642e6e9fc635f55c0f274ed146acff7a91965c3208ee070e82886f9ccf0e27a1e8de1d37ab5de55f19686976e2dd90fb096f3a480fd6e33854f98c2b1eb83e0bae01cb987f4667ca6529445c63b2cedd8f5aea924464bcc7ada7e8d058e8fbe2841d0d8d083320bd6fe035a7b3292b9cca3918930a5960dcbd3a911068e76d60e9290a9b4d6193d0fd7b53e59d34b075875084d3401c88cfe07814ea064f013a7001c967233945e27dfbd81dd07f7b03373364a489c3a3ea528e71d4739f5c756d14ecf8997c555d5351792c7d09912f8035fd05de487c177a19682fdd9cc28cb8e7eea5d2578b4f2a8fdfe36ee0d4d6ade71caa3ed7b05e6a3c37ad2b5e904cedebf6c33a6d89d14abb8baa7746ab896908dabf132f5daeb0a53fa0ab2cbbb33242aee3d1c82f2b3413ec80bac5469092fcb5aeb51cd7f6d138be0b4a78da117391cf62f7639b811df8cd1b78af45d136687f34d14cdeb4cbacabdc917b41204cf47eb3d4b28f601ef6c54c2d7e347e17bb5763baa71951a81419a799d26f5ed875e7072f7e724b438cfb172f94066961ce53ffd90c7a19281438b23f1950181bfe2a10b25d443088228260c460eb1657380777f8e58a545ac773c7e46225a91fc4ac6ae3d06d2b8b41a0630d8e2ccd1b07ff1d0c2f78a79e6a3a565bc9a12acef1f7461f697854d8b23e31642d41776ead052b01f13916a8b9efe7a1b1f7fa5c4ff9490be795d1bed5aae73fd3d503e3722139238e0e5b6cab337318c8d70a439fee23a1aa3eb8dbdc53b7fddebe62b9d2965fc3e52b4e9e5336c768c22460638b579d8f5f5eb4c10dda17c6734ab29d59b63f8ceeaca83c716a59bda2bdb733b55520faef28dd7b8114c06bd14a71dcd7e3fecb737b982d6acafe6579dc4c8976c4a2bb61a06defa25a638cc73ff0b982e521212cdb0e10491e80a6c59cf86f32f5f2f2d90db457a5760f05b7ac7590fe9da149f6e7544bc96ed5c668f158f2d072f620669977919f6ab397f9068224ed6a195eadbc03c0ceb725ca97d2a465c01effe8f7d7eab8d6be76a46a4884b7ac7e1b39c1e28efab5143dbb2c0771f29ebeaf19d15c9f89e3a3e485c0385228f885a987d944b93c8d7c4553767444485a2e090a47389544dddb9158aea3a952278344f5c6a6c2ac873eed30f02548ad6fde33737ab02a327937ff5008e8735ef60845d35f852aa724e66cbefee00012290ed8db92627015a7bc699a1e4443bee31dded7cc4e459a409f2fc485eba110777cf7fda4b58a825e8b9f3af2f41fd110e1a024546f7d8de998f2cf95e6b8de68d470d3eb693fb71ad88480816bafd94b2c09a3eb87aa83eddbc6888361c8b121bf961f82874701a9d2e5357c8c18417fc869fca832d571aa96a4c349d24bf57badebc8017b91a0da3ed2f49ee11865ee59d86e00435e46a7889ca6b3f56f67beff2463b95bd82300d7701e9c7e81a141a2c1f0842ccd2109a31dead46327948c98994b94ce047f3529c96a3592122aa1e7f0576af9da5537bc2d917bbc964acea646c3c3c7ff9aa13914f6ea86f5b1b2f8361af36f8b6463b5a51a2abe09833cfd0cf4b8d106a80a5c09d780b6dab42a6ce3170ff662e56f4e20d11be945186a72b13a0c8667450e219aafd58616b7cf7720d1fb338b67048b9d0e1a68a7f2ce9981e14057e4399aec85215bda14dd0d5b5f4ef62734dbc2df7ab9a5ae3585730a80a7d8d43b93b5684d762dd021e359b010ab6aa702ca710b8bbe04810d2737c61b5dd10b623e6254ee963884c02e80e06805e9df7ddc31cd11bfe8e88bb84a6879256e01a65bcca208b181431b2d739ec4508c5ee5bbcba7e0eaa3055f08bb4500a1db1d35c0600b3ef601235fdb2d589c5a10270b4a5f14ae88c1c3fea4a5932215566f538957a619fab0840c8921a2d8d1cff82550a21b239a8ddb5a26f0a18bddda8216a7b8803852bbce781bc754601814199c7a2ebc26ae2522f72ac1e34b6fdc598fcc793a6de0bf7f0b24a46822a6c1d097deeaef03f7dc379a266757fe050cdddfec14b422adb4b169c54d60e9533e5e9c711ad8413649b3432d74d4564345387f8e82980e2e30228c1b3186877da1854bca90c1ebf34376d9b35961011cc5ccebab77a2d9d6d088d2ad9650deb8e3eb7d26db37f05e7eee29473e8addc2be2dea80ba2426ff56764561e56193f0b860d695a2fadc4999498fa05c8d8a3f9b4dbcef2218f53d3837b3a27ae1bf47cb5ff5a2f7a127680d02154cb6334f086f6675357541a8b75e091bd126fd42d19f0985e0b7175f312ddef525e9411890cee70a3cfc3049e6de5a18255b3e018c22a0dcc4063d14fbeab4a7eaab23df51eb1ad4a38c422e7b9d3606d53fcef8c69dff785497510b86beadcfc21e432489dec5ab1c0608019e2a8e7aa46327af037b0f71d83e6b5a0a3bc01073fc5d5fe516c0b9027c9c2481c759099beee1fcc23cabaa14fc0aa571c40db0f6516f7fc7c8b0cd86728a501fabc9013c43d8734081363512b75bd8f8418b97e9e93efea69476627cff8ea9a4ad91ae000c006d0e7f9733bd7a52a50c9c3c80c65c9127eeb562c834128c123ee3a627be9044ed52c11d6a8141805055711c4d97cde8954cd6f302fc24ca1e4fc388578d222029fc4d04995f02eb93f2cd15fdc94d8bdff12ff74ba205c01f6365f51620132bfcef6c27477e91219a85dcc5845c0ed8a87dad216c1abe4a10976933d496f5fba043c7e6aa930a187bc446fddfe2c8f2571e24883cccd9bdcd20e58cc3b6509db2772ef76d35b2b2e5c4a09213cda2677844a8d6ac94c01a59696dfa8bec5d05376cbdbfe5d4ee714a07517dc3e8f75e4aaeca6ee8ef137546c52e61201fb5eae6f78fd646165a88ab90bed020cddb8b3a1affcbc74703e9e791a402a7505ce52c75daffa9d8f71acc8206ef93b1bf678362bd1363794eb5bf1fb6d236e7f31c2f528a925a259e0134eea8b8123db41487418a5580bc1ab88f71232b49264ea2abee5667f77711811e74970213eda3d3febced5997faf2f2581e9bdf9f3ed3361c6c8f5e77aec69361804c7bd759adf5ecdcf702f8df2246625411bda208d213438ff8a48af8c099f2e2032272dc8bcc5fec7c4089f30d97df1f42fc12dae84f2e08a04becbf5e301c8f949d592c71d188bd6f7b5f61c93ea20d658d7eeaafd91ef6118a83ed69e52d143a0030d4ec22244df94fb5554b0849707116c9f5c8be3ac2f81c4e9804ea39b92df7875a982cf2daceb1d7ea3d90849602ecc678ed736a3d62a839e941ab4693b0ffc3a9107a0e84ed49dc4185252048685743ef2b303ad6eedb249862d5bff56f1598d46e8e730065ad057d92854f43356b215cce75b7c9765c2dfafacbba3b99331f6b948e63dde0cfe698d23f4c10348171fc46b78ab4d42fc84a7ac99944036bb95a0132dcda2d706a3c6640488703aa5c7741884135855c5a462f83855f56c9eed98a539e2e3f80d475d6e7e0805100a999fbd7db9fd7ee3e8234ccce6d0fb381ef3ef5976578c7a1ca6a3339323663b5362682c7e8376838832ee33cfe0ae6f64ef64cfc8b17b356b9679539ad13246e51335351013b731379d9d701bd78ece1806de473e9129537740186d55c7042f45d886968b784b656afd4855220ae454cd4cc8ca84a43ab0c06b4b1bb1f5ed4d2ad61bfef27c0fade38433375668ed5fb53ce6730405f9bb3c24ed1a6ab61e1317eab6349b3b54a413efca4c7880dd2f7a29020728444c36328b6be285a5d17beb11eb305909194a62acf1910d8d12d371a21d2134cdf58d99aae3c97958bd4a03b4a70ad7c2d828808f0e3e1d96d719181154f9f53d54c85c616f24ae6e249e39fe46a54e0d7cfd1068901fe989df5dddccd32538fe1a4c25b4d7b4ee136bde52133358834d375849ea77713c18955b1d52b0fdc3a0eb9c9e2de7b1faf9eac8b576bb827be51200b5935a3b3792be82382b5bf7ad8f1cd32c51e44050443af48e8128657d6797224983cc408093556ca56c254e0cb4c4878a9f82fbb3a72dfee3346019b5ddade7c054889fb485e953503771ef7dea14041e1f2aa567253a2d105d552e75fe16f3cd015128cca4e2df0a4b89d3fdbf14f9c953e11c61330f2fb6264a6f1c57b5a7857487c1af1abee68fcefff469aeabff976d7fe0ec410a5ef8a0f0451daf00ed41dd0c4f6de876602fc9e019f97a64bedbbcf5d2210f0cb2468cc066a5fee14e181444cb8afd72a3947d1b75c29ed124c04eface94226818566e660b25d3391dfb1865f5da020d0d0a07d1e3ee5f8135fc1fcdd66d712873474ebff5a6b416972b51888b694be5dc7062df5e3bc2077621fef82d5c0d123e3b96734de2aecf78167b4fba3c731c33497219e210d413480af34d7eb119c165bded673502fd35f3399c1b6055f7ea296738ac7c9ddeea463d70fabfaef77c9526458649327fb59480ad288f62f9d201d8fb699a146ea8d8a130b1a165434619dd6899d086968ae60917d15818fa698985cc9cec8288a55ca55b361e35fc492227d105437805ec77642f33e46d3686e01564f86072b2d0c56a6d24f339cedd1f118441e59c47d4c9683767a16ec34a6750f608d656f4cb569594c709d3bf50b5a524fca597eb06f2d926d4e87c019b9b6ef6d177bb892bb070f35a3c771c0b9bfe4040f851e0013b283c4bb8f4bc34d4b35d881ada3b64e76c6b4ab1affdf0d8431cfa7744b3d2d2b9f6e7acb3968a965c8096c4107c02cfa796fffd245a2a2c372f3284032a07ece740040a7235acce556c5bf984271031b19fe072aeb2368fbeb37672171b435255d3e29d46d74f8d97cfa4fbb1fd95739a3185baf9ad16eb6a238021d00c20fe70b99951ec64038cd7421bb3f2db68902a59e8fe262783be84b0c552733ba71214560500c3d008148acd7e67f0d2a3e32cd733d941bc50c012e1a227395533968c164593092df0dc20dc43389da8629c675bb2a3d469b87e51ab4922c75697a7ccbb8b5e62c44d6b3f2b7c72aee02f4ad87533a861f1d03a35cc450e6d87dfc1a736c1569ab3bfa0ed4c131e9a6fd3d08faf2d0f10a1175a3126345336cda7f66b6f8105f29e42a1ca6361ca5692edec637c43131a2b2ee1253d7a02bcf7cea35f08a0d711384de5f843ce90f72c13a604e41850cf5555cd7709a5e9f20a68feca7b0c2a95435252307c06b87bc166a28036630ee0c39f2961a8d5d21284304b9a448f8abd1122ed4368e73cd2e4aad9ce751a7eeb8e59f187db03f2c15f91d30b0792ded0b7c18967821955cddc20c675d88b1d6711e55df2c6405f07222e9a149e975f005df71359754be8df072f2c31775f93fa40d73d2183ba62f4ec99bb03a4b7aa03375840c75a5d7fec797ff25a2e848ad3d4b2e658a491a08f6ac7e87b1354e4a6ab8e747cce3bed5b8b51a88f11baf4e811815e402f240bfdb72545e4e53008e41dc5f151b81033b5d7a7e0c57578e2172333d21fc3cfacce22f6b1f71df77274df26e42081c59d53eefe31d66f4de8b5dada5c02a5192fc2958f1e9dd291099d6c342773a19531a09e22dad3e2ba07a1a0f38206599002212e69b8a2ee1750564d2d3de87ef91c38501c29b2d5b74929b278dfa6a1e33e7baa2c1d50ae4aaa44773a048fee1a03811af1a653fea5c27039e19f0de3d66dff3beb6dcdac661f159be98000dbd5e82a42f0ce69e2f0f5d0f5108fd47bc491bd83bd7b9c0f790252bc157ca3c541a46f7926c714c0ba1358c7a03353ab278d508b3de65c4a027baa2ba0529a51ac25905ebcaf4a4924d56e4b6445a3d336d5d3e41a71d1e99b86b7eca1e03d15a39e24e475c1a5d4e6f897e3e5300eb28537db6571a8f80ef915b6d4722cba41c413847ea53a479abd31a75966c76973883e65107e54d3fa89e85753919719a013d52c6309ef35031babfffe68664e434906dc4c8d79f9212bba9c0e3a7b78a09d4629cedc72f61d0a73b716808d0837d4b00798dbe24f74fe409f05a1fc2aaea061474ad04bd101087b3f95b8c3668f7189321e89e21575025032057c785380485a4c4aa631d2ba90b37019a87e2dfef5215175b870460221c013345a1a3dc9c017a15f8e6c1a511f9dc3aa0046e3dec0e5cebad701b45788303268d735486192050f5c4cbbf9115745d7101bdf0023e1e5af36eb41d1889e8df74b46b45a8fe18bf14db8cf8018b0ccd3e9160b8801f527364ebf4cea82d10920f1847c53a99bb190457a505d7d5905199dd63a45d8895434c95351d14656e7a1a82cb89e778f3432af374916cab5d752a5a9dce1aa931da96208da6360ec8ee7d9432d1b7ab9e0a647840d9dc23bab61e764e670e0975740efd8dc3e0b49cbe10fac0ed887dc16201682424348703cce582cf7aa73b86fa34d748d4851093f5096b1726c513ec4311ea572b7a9c3dd7cca90dc6b50abcd056003337c85bd87d7c027e5a1e4cf7009c94a6249c29adf25a62f5564a61239ea390414511c195ab3d26922c2df677697e826a2d60cdf50e4500317741d5352fb3a3ba71c9757fd91d7d81c96269ed3cb49128f7211cca4df3f88bc5fcf6abfa45a899350b279c827f3c144b522c03af4076cff08487332f2dc82acc97bd4cb8e17f61dafba0421ec50a932fd46c5e33f9fed537f80d2f77088ba8ec432ae4f1841ccbf047b3e3c324ef8fecfcb8d851d93adebef99e108307a8c3628e2a0e958709367ef148a2b2d591a0be6e10595c3014fcbceb4c407909883593aabee52d96f4069da374d27b15248ef24d408489178adbb0b49ebfe9194eaff2c7e6960ac82cd3c7657702ddb981afdb972f8c865a4cdf621463c735052269e8c2b02c9f9228b3b6265e5f04ebc63e273a3af218bc0136d1a6444a26fdebf3d1daf9b53226728f103868f7a5e3dda7668268a2a863fdacb4af6c6235bb593543d3791639c08b464ffce5befac499df40e53e8419b785abc4180701bcf7d109d1c2f6f2c27c5a5351ecec23ec2a3a23090bbf1327489c1595896eccd0188a2e68d5b102543f1b9d296e9d17c688f51771e1b64f5176c68bec171a67b65120998ed10612ca1122db0b55468a976564dbd764faddee2351b33615806288012ee89f1425d86963eb11ab85afc333e03aeca0134c4aaa8be6d61f41a94fd418b506fb49cd3573e9b0dd3b849646e4acb38801df3d8d46bd45565fbfd6c3a33ddadb404b41d98f15abbf76949ca3ecb184c26efbc57185d9299f7fb136518dcbbab2eb824ca6283ec97b60f89981b42af14d6e79c3360372b9623e82efc0aa671afbf622fa9fe804335077a418789ef5a7f607edb75935ff750f132934c0c50097fc31b869fd3425c8414b71e790496ba7c59be7b56ba0f5382e2410203ee22b9deea706071929b332042cba3640e7686558ae05f08bb624ba8d917822ef6e998bb3193e15809c22ab14f1b145a41cd1f1152cacf115e22fa1afe70579cdeb7042e1668006fab680932be6ad31c9eeaffcb9dc86f6a948624ed335d3719e09fc98b482ca46e25590a2375204403670c380621d7951055cd17ae6ca7ecf4595a4724d0e0ba7780a6b159ff67fd19adfb5aee3f33a87ecb3a723e326bcf6d2c3d25b94d235fcffb187db90cf47d6c87d379483f2e3405308f161ccb415dfdd6be0f4e05db8d9b15a7d967589435c89728d06e926bc4da971a95f0696fb0c45b016fdf35d83aaa5986ef7395b1674abd9b0f1d18d21cfb643934e734c837767bf03da0717aaf04702c72d489ab34940a709ca24e325c1c7eb5e241ec1c7495e6f72eb044a333369bc8a7a53f22a95c6383a480121328bad80c709adb1aed09acd7aba7c074da5184764754ae08f4e3078555314f65edf0d165ba7fa4de72ad76e9534055f359576e41e10d9775a0bfd7fcbdb8829c6342b4cad7b822619f2926ae6badfb12d30ac62ae5a80f2bdbc676a4f1ce147405c1b9513e672e982106a65a3c032c2a4df41f4c383304755e6b18562ba201744f77336b37094c684b06f49c24220ebbe94797a069ddef8ca7a072e653f8e838700b12cc0e6566fa45c532a844387b6b8bde161fa72d53bae31545201b56ccf34a2fca0671244abcdec7fed442725a59600bddb7cebbf3bc9f1d4a545e32842f6d279890ff89b04879165af73681ccba9b68cc82d5db811f2be0940d986ae749491f1dd123f2e342fe4ba231eee66a041c71c64b30b12c457056c6be4a4bd1cbc185311ba280db41f3279682b21b12bfaf4460afda4a439bec9c95cc8768ece8ec674e50ec67cc869a51e5ebb83091a90be50427365f2ea4dbe17b5c55f7922e51670946975a525c4ba6c5410b77bfb51f142494493e15f762f21fd4fa35eebfd282485abdcfef82c0232a506b11cdd0ca272642ff53eb6d80aa25975d74c9e943b76b167cc51ab5bf9f8aaee9495bddf32938e1a574f9c21957475d361826d2c933c28c9b1c85133600e287083e7759ce89ff68a9c12648d2f44197e84175d1cfd63c9d433626cb5c8cace0040a5fc2148591fd25ab24f646b7a47ff2cf0a115e8abbc04ca3628cec0a3f0a9998f72f1460cdeae24ce8839d1c3d52256c9bd9bbf3423e1619e25403fa0bedd22200c4d69f5512be2141dad99f3dd79225f850eb8617cc4340db4a449e78e1a9b0ea79bbab1f73da2344e7d331c639a53bf561a511fae84b457f07bfc9b64bea4e2914e0f74b3aa7e68ec425c68106d10113f3a86a0c7065d25698f9fcdcbfbe41276c2db0035c9310955a1ad27983a1839a6fde7826048365dd2a0559e1d6c3ce85607ccee533ddcad0454f9b677245a2b70ea0ea05b981e780297c04b9ce3367891c58ad6ad3c8afbc3ff3c1d9585ed1160ae4d50d43a7a58819d11ea7ea89e716200fc348e78a3b4f7687a8313ddbd6a029a082d74d386e2fbae83e19b71da152d0c2c151de30457af7c3bb179765c90d3d849342c3f0fa3bf6fc9530b58aac8b1e64212901069ef41f11aa1c5ef96e8a244885c3cf727ddd6a91a7c116649b368c11eca38b808686e88a59b68095180f92fdf94a6006ef56c340523905a08e4776e761fc26f76465ca39b0b433312223c37ea4bdef922b2f5f7c108dc982c58cea713063c8df1b55ad952014836ba40dbb5cb50a4d21bf823101a215d4bbec7131880451c2e81a0519d1993c8e465dd6b443dd43eceb405c1622039aeb2051254361d77600a050f72304596ecb6db3a155eb6680127d9b1fef1a3fe6e04be2642537aa98e4e9264c79763db0a208a79ecae5085e809474f4c086012ae7c67be92950ad9ae62903162502a6152a86a74e94ebd7174e85a201c9ffb6800b4fae48743d9f39ff913f394ea0cccbcb733bc5d799b9e186aa75ea56e72c25336de8d4ed1ad84ea2bca464d709aaa4acee6ac29617eb0fab6ad9bb35d40ab87672f398447b9e2b30814309d04d9ffb3d51d22e48737935003cb2d9a93dcac8c1ae8c7ecc214dc8b67392907c79083ff0c36b2e2c03ee7062142d85cfa583a9e27abe938a2879a0fbb134f00d66bb61c3a4c385f0da8b3109cb448b7daaa2e1f28b3497fb5d5f9a1942fb53818940eeafef94340cd37b60ea7e1762796abe920dae977070e99e8bd044d010969059c52ebf37e2a552fb28507fc3b2d09fc0c07c2e40fcbaba427633feb0c69c838ba2e0583728faae73ceb6d99147d82d084453e6cd5d7220fb4036cb285f614e40d04e574978c3190d987a6f7929d3fb327d5d5663fcf8c039d865e145cc52d5697459fe3e68436e4971e257a62e0621742a2ab371be50aa43b32d944bd3f529e30837e7fee9f10c04c52ee3c075f354fa06c2abd19119bfa5d0f0d0294c4208edf91a177ccd16ecb5301dbf7cfb20ca6d2d45a1d99667e9004abd7e35f4b6d68020b5c0c56e142c13eba55fb1f94173fefd604856652eaf066b24b04762d919eb6b4f679fcd9298aecd3a09411b6a65fce9a6e70730421d143a152a70f04f2aac6d5622d33b676b34eb766037627f9a1b5fccd17666ed224e4ccb8c062190bdf0444a38a6ba6134685bbe4c9c8b851fd25093ef7fc929054ce4f601a0d15beb016e30f3d4dad85c399a08e099fba84349c6573f77b1d468a9c02d527419e30bceb00aaf5c8084ba0b853fdccb44169a44b9d473ab64ffd9f51d86a670ddce581caf1f7d076121e83b0d9c13072ce365d9df81a3a957cf3fd52a7d1b001053e180ec2fd40874e103f08ca97cd548f11739144aa7ce811cbdb15a5174d26a32c516bb395ce1c1cee0220f44c6b4107357e98e5888e75f8983ab7af131537d9db5240ec0af46ea85def47ec9e199e890a777b7266146a8622c7416d1c57e856e1ebf5075c9e1167555abc77b688ddfa009709aeda81a2f4d9b0ce4d926e3658147e0995e931284273dee084d624f6fa7126ceed45a9179816a91acbc654781d9ea5f23dff98ae28322c9325a415cb613a8b3b4b1e61ca1fdee032a1ee58e792e6f0344d5807e107609d695477f83fb5d9985284eb0fc497578333f1a3e799f3f8367fd0e032543cc0526e92173d4e0ba428295b4a35aecd270e9ca815bb2139eb8d4920bf3f557a0d9e2cdc1dac8761ab2b534b6d000e1edc3f772deb3267c4a88af2efd7761ddbe9c5f3087527b5a8878374379cf7a88a67636fa1f3e990a87991b99b7c4d9d484da258ecf7f930dbfc236599ffe6e6339bef08b08dd5000461ba91cd304b6742e3a4b30377bd185e314916a20e31d6b1f77c22e0a33727f51e036b3445c8201f9224b6c4274f77241965225165f4f0c7b69c829597a5eb9cf42132f2f1bb306d94aad2c3a3a06e0bb263bc6a28c5b59d80a5aa1d0e4e7f7125490a6382f030afff2aa94e62b0cf0f109a8cae6b5a07f5f3afdf0c5f2f2b1045a5e2b5418b87efdad07a059ee6307a41998f30eddf99a54b73a4ec4a04248240102fcf2fdee9f77bb0765dc8416b1ec71557fef34a95d852307d668faf085082942e8064cb9c6b513774fe8e677c8a2f15dd19760868c4e28490b2a95e656cdab74eb9131b421ebe6486b8ea35da67f0d758ebfe1172e24f24a8039b8c597772f70e34c6ee0f5ac1f67f27a55464e1561b1483a93f7719020ac00211b83b1d90b63307e3ceaa4ca03c80cf96465a14adb0338b72b7742e2b501f63e8685d0c2e260da7d5e9c2f14501d4607b476c540ee2c1f03a78e5ffe612daab52402f49e389fb54d0633e84f3a637e24192585b7de7faf651ea5f4d733acda58cbe58d828be4f3a1a774831cd1d71b7977cdb8c17948d3cf70aeb7a1680060bcc63f82527da4889b752e6872be1dbca70312ed7625612422d43a49b939b6d3c5918db65a8b2e1b6ec954f15b15264e3c4f23c3ae933f00b6b2b556a36fa6b8779db9c269d0cd228dcfcc63600ad101ed97774ab8bb52f985a6cc9139ecdb52c6e66db2bc7ef29472143c3e8d6ea7176ed14c44aff92cce917aa34d94c33a593435c585f4b83eeeda624f149cb3f9413612f03f201129c9051c52946f6677ce2f45140b225e75709074f3f0e69051eca9c7a71125c7bae3e930268147d0ae852d889895d3be05835399b7ac36bd20d6a51c44a716daa1bfcc212761a35263d54c2f10f3b25ac0f3495f241f587a2b9a9255e06b44ef46f28df5e86b30b1d8e968a9a6ef8b138cbc3ab90924c30253e403a9e82ce6f70e5999d158e9aa3f79b441dd0eabd007b1d41c0606487f362fac5d336c5d1f83de56b0a6cb032e52021a2bc2656f37b66714cc250e551c7cef42958d52028756a2d6f77cb5515da35ec092b159dd74a9cf58d2cdba02ab86677b0bb9fd39afc13cd86d9ddaabfa4cb6fe537ffd436b487c70f68ef7a03c95bc97824578a9bce63d536024a874898e951099e66ff99e4652e49221e3b9e003f596ef39596852d90b050bc24cac734f16344d694a05466dbb73a041a4f6f7d0e70067ff75b76039972ea67ca59ef2e8dc6b5469ef3b4ee1b811c5fcc3f8d04f5a50812bab88d83b00806fd190ffdb6995d7008abaaa4121ab3e2b38f339f84aa988640f92b5cc8c31ded1ee40e265d02f0e42b49c6d1e09b9dd29b056c36cd4dcdc07738467ca49b4537385d8ae6b526ad97b500e0f714166f6fdf6a67dc345b350aa884191faa1f9a7c0f2e8561e5cdcc3f3cc690b355c2624e6d73100cf49959f8888f14d762f8aabae07cb9fcda04a1152e36988e3eb5e3db24cb2e0879b085a7d65b41d96f738c48d2033400018c26b4506d7823629a519520c1794a3634e4405a3a9dc1c908c8a77ebe45c4ef58be8a29628aa18dfba42ac1b61961cdbf894caf0f569c549baa319d482a2f7fe5512c96a825daf2b1a7b7a1f60fd53c0326c09fa927d73214a2b38cafed7c6c007170a537862bddc90c5049cf1d2e1903b3ec939e8d8252259793e2f20258f0572fac95f839f63d7c4d03c4be6b2996230e2e68e9a49e611ce371357aedd9912cef89ddaae2da5ff160ef07b9600809372f188d4d1939dca014d6948e57b6e6aedab07c534bfb48104441f55fad5343cf684836ba07f62ddcc799582749f7fa4188fedae6dc1ec18fd058cdb9e404fc194e838f7f3d3728d5b12289155839e0524fc82c3df942ebf9ffe442bc59a6bafb9d5d9e9a407c30af5061f796c8ab4ea11c6ffa133652d8748710bb291dd0329fbca34c69915be7a4ef536463f31ef30053df0ba9bc2c6c39e8906dd9a808a7ab21645a9babc3861e101425040b39ea61800da4189a1271f6e138a307549f8703b18d700d5b445cc60c23ac2724ebca257afa5cfd71e68a654f807486b7ae6a312d1088f759832c186e44944d4c254b6d79ade3e61527cf2b5a100e75bdc63e78f8ab27b6e1bb11f232628460868352e60169b9b76540b2d267811a956b81e036eaed42be22f458a9058b3c16d32956ed8c2493373ed74d59ffac89a012d1cff762d7b970beeceba53e2344c2b711d6b5c80fe16ce6e14a225a0dc91d4c966b1679917ee2464868a3a283003b76bdc280fa5abba520d6562b3dac8d68ad9bfa91ad1a8600a5ca4c3bccea622ac45f3e440dd6de7237e1a9bed93191778fa5058e664a71bb54324339eb2019d5dfaa69c3aea71b64c63d1a1c5200757e2f81a146270469ef2fad9ad304503c593c42e0ea12132127f401714e9cb35de9cee8c022bf8acd63479bc142de4adc2244beb1e683996f623f4fc8b100ff43fe86ef877e6b4e4eae03e7e99172ddc0c9cb21ccc79ec6f4160c10c1e2d157a6c7b7f11089df587da81c3fb0843f91015711e0607d36cbdf6cd645c1b89b6788716d236a5ad1275baa4adb87e9c8540fd1ff6f02c86085b1e16de55643d071924310ef58e88debd47434eff3640cc878342cf829c8a79c0c7adfe4028636dabd00e8a9330404b9874059213f9f73faf49fc98eae261ac2c0118dc857afd60c4ff16dc0bee39cfade8a99fd84f4a2089976fc4f301028c95c3b2c71341a50238166a0b56ac6a4c811e4f5d96dac9258e0eb8f6ddc7a6bd6cf6f3cac001d03a906aeb9e7de624249d95a860a0ce04ab2952a15a09c1d44d9b78ec630a11acb4946f241d1d6b388c50fddfc00a3e06aa63b49f68cb4b51a558f76bea00294f2cddbebcb507d64d427645fde0bea6036f272ab4dea2585879f00c40391e626eccfb216e1bf929166604c710759f5d698c05a8f340f601dc957ff510ce97fa29ab66d869828e0ac74faab42bf1e89dc4c08d574218ab7ddbced883e2ce5a38349d16cf8fba4d26dc791fd57cdb94a81f5af42de63d5fceae2a05466c6b8b8830c8d4c728e82919c54a05dda6e2defd6218200cc3204beea8d9685e5e09ec1c2ea1054835844e4ae34b512122bf9de4dab1fa02b55829f453fd89d4f7b09edac50d1bd3b896ee5c11b14f46e667d825687bc9bb197d3b8ba6a6a3d0044b20a571522be1207cbe5e049ccb2806f926b086c2541ade06f8e6af067cc6ecc4b52d9af1b9d98588ded06831523887fc19ab0e8f7206e327f7eda1a300a4ab5afd814395e346e9ce1e6e552fbb1a3aef079549849be62fb971dd31892052187499ca332d7e341469049f5b21c5dd353875412a4a5b2096998936cb3541b79f66b1dfe82865c100fd6f824f9e44a166b2b7a954153a6190c5b4074c8a563f8fc7d2a54c3584f3086a4ce8ff38b9b72b2ef91f5318af705c59e34a49852a3b34a4b4efd08aecc8a3b22de57b47292afc3c30c3a3c6aeb682aa332c653063765ad73fac472a243adf354ec8ed6a2a771e6ef0e43272ff9c907c4f9467ad8eb1203a23acc6b994474d67887e56137fc10f73d3d984a051198f4b400ff1707190afa3391de9798707253670a5cdd416509dd97878d660a1e4d6569837ea50795175afaedacc9fcee013cd0deb36f28e9c9704ba203af21bfc3d8b62aacab560e2be7ebcde20fdb732a6999196f9d4206c559bc140b354b17e6a73a6a4e6cbf865a081ae8d02cf65e15a0e3e9101b795af97a4185ab9b0dada78a34ff6b1c3ad984507297ab1850d8b69c3265de0c0dfb88465fd65a0d8ca166b5596918c6853a0e3b15ce6f4c3ebef5262f9312eaaa1660f1118ce9e697240fe8385dca9f22029698dfb1c1d0dba0ab62b7fe2a691a45833f3d87e24f94c0588da4d35ecfbad62298501736f855b4c4f278c722c18deada5c1bd48072453d43436cea7c2cb6141fd9394dadabdd41001edf27e594cb0ca1e050cb8e80a72e254a95b39ff976e914387cc4c7fa4e48084c8a20a400c665db7eccbcaba5123edd59a4b4bf2bcef8dd6f56b3fa0567b0b7d7c6a555f9c6fabb79da5e9a594440be213314ad409f37be13947ca57c9dd912d377dc5afde82e538d1e511fc3a2f7a3885897c0a42e5c5b9add349b0703d1df281f5c2cc150d23dcb64e9177aae11959554ec22de50bd061fc9a044edc80cf18386e8c2c22599e6ee5db03eb4c49b2b76ff510a1c06057e4ee7288f23947a2381b86519f7b1c81a7068432d30b4b218667ff3197f8bfca0b635e7c5faf3aac16fa0bda5accc1ece4582e756140b5de89cfe74cd781abd5c92020387dd517356f468e735d6dd3a5c5aada8792d661be365e6cfe2c0242b3660d83bbb054d4363954b11cd6de7758707521d214587fe4724aefb5bf5ba666f49e71651dbcffa9cd18990a93533a1ad62b336b6d905dcd632ad2918707a4052fe424e26bf40250e8c9dc157b26659dfa77da8f719adf85caed2964788dbf44a72b3653acc71eb2923c62551114e4c99c996cfcb4b840cf1598fb4106b3129491d1ef04048e79913d5f699118bb5829bb71b5027c8a6236c69148dc31c4910159fea9edb467562d9a782eaafd4220ee9199b3c3f16f28f86af967b8a5d4a0173da0e302c0122eb2f4a958744f204d1782b92852114171885a35368c3341a0e4caf997686cd772906da952a569435dafd173e1420d5230b2364d8d80a27f8d92b3a8bf39c629961c8d436aa68f91c4d78c1e9ef641d3fda47e8580e91f569767988d7502c5e32f2ea3fc0a44603710e09bf4b3c33a651c2289669221db0f298601c6f65e826ab0ac89c8d16aa2ec8e3b1da0456e5087520e801517e01f55a252ed9ef6b3f015c1383bb4f41f21a6196acfc2fd0e2db5e5eccaff9aaeb3f230a0c165074efa09d78c52fbc9c59ccaf31f57f5eb816eefc116b1b0a5354786183ab32fd761c09b7d7a225856c38624b8129eba7d1e4634db540a3776c792a8e3589a64fd3ec9589fd3a8b544c7a1ff897f1c898f331e2d2331b0c4f10e9a28b02603172a11e899dd879312ff8766bec8dd8279a62862f1049410e743a652ecc72b9114cf9918a71ec97eaf21de8e60f750c5f86f09802fa99435adabc52cd4a1bbffaa60be990ab5991939d1675b3e5277d2ed9e77bd6b26ef45469aa2d19609f7ca3687ca98a1eae660398ae3bdab2a30f328f02873b71563e07e601b966614ecaad5a888452b56a5989ee581e14d67420f3de907c9866c483c66fc9f64bf62de69d315f3bc1b9b26448c196964080a4ec06113b64f887dc6c6f0586beea3b5e7440add5d9d314a657071e0af9c3f7271e3cfffd1430d33c8940591986cb8452681cada5156ac92ae695463f789e8fcfb7590fd0f3e4924ca5907ad23cdc15e556f74aa42d76e666d0848d5264fa7598b7aa64df11bc3a18ebf7a7d3275b6477d75390e26d683c23b714a5034e921a8d1211be1a0d5023ec997e892f4a2c44c10523366a07b2c4f8b4ca1c526ff9f360d6e444ef273d7b57eba0e67365599e85bdfb9ff1ea6c8636458cb92ccd2c1d5af626f6a4e8e96d261db0caca2589e6fed5d5f6054fb7b5e6f0d8916720ac924f87e8ce998cef5a0d4656646549bee85a3e4e750447c6beffd7180aaf26405709b3c08354763c6e27feb2475ae460f070b09797efe843076490dce8dbad2223e96c1e7e4e655ce01b24ee2a0f2634a9394fccb9ee23247bffb15a5a379339811897566adae034c9ffe2e7db8177440044244a985fc747d9094790ff435173348d4c8846187375bb89a2e1621210bc4840453802cecd3bcd94e8365c1bb868022ecd9184c9a9ee2da616e3890c176b1d532ca014219116bb36bca24565df18e5680fbfabe02c92a5ca923553360a741d125a06a78d806b33011c3a00af6726795acc2e2591483849ea85046409157fccab6447530402ae547ea0637722cff95ea8b0b42ef134942ff3653f0bc13dea48eb6121c71a26ac278bd011f27e7b7ec39f2783f9ad4dc8a22de61cd75d9f1b59538f0fb8a5050bddc9a8cfad71c2b752ffb8bffef622252e7d5a6bd34f9d2115d45a83de8e6a03cfb953c4d25e6ce9fa62a06669067a825193a8b10459ba9309677d3b93a1a0ed0de16a91585f6469fdd021affc00f9c449558d5388d78e99ad363a8693b7484363b48903da047c7c816cc7a293ebf5e7adac2b5c2ebbfe51fa7be472a38bf0ec8274bd379bbd46136dbe70cd2a27483b9d9dd4b1334dfb697eaebd0b871eb33c3ecf0ecaf0ce149068ab52d25a79aac674d609e69c501da69dc82abc0dca57eb230c91647d372777e6430ed031f1f4dc2bcd6a09e33740545d0c0606d8f0396a795b84b69c1631cc9b339b900b3bdaab90224e7ee7a2ad1d8953bd72d0299d3516c805f653881e5299045dc0a9975486babf6804c9afff16b39a9deda0fbea5dd3980b382be82d2c9578a9ad05a5fefe6b0911ff8dabe0d8f9059507de6dc201642856785eccf8e54effe8a54aac515d4ab8787abe7b08e66cc22273f59fcd7f45cd8f53b94b6724b18e188de6d48d3d848607bb7f3860e398b66c7b7101cccdeeaa44c79b7161dde9b71204e016c6966371e18c9e3d7970f3dad7b186354d77b74e3a4caf43e33e0bf8355cb07de35551ef7745769e37c6a1f92c93199a251934dcde486220fc7d6854a614ba3326932061dd04d3717b6252a9d6462384631a11ead7ea259029fe76b3f8f03ce427e7d6b4b797765fb0fe1580e0f9e344518e564fef10b05404573a5518af7ef63bab183db7f15b916de1bcb4b3bc658df0d2213759b70d5e3c60e8efb541a78fb7566e07317526cc6bd60be743dc7fb31103a1fe5a95f38afd8a2bda70b2d77fbde99fe5f8098760f85e5217ea8838b5799c62169c2c3f4ddb49e367bcd388b80a8f9744a0b062f65e4f9889c56ca6c8d2a61ef8057dbaddd8cd820419fe1ce57fe937c23326f68f8da0cee8647c8ba9f123b382cd96cd5b16dde8f7df903964719022603899f5a4acac8a7f3661d145d8ee53a6048f6d0e785df830be7f89a03ee1b17f2caafd1b2e3c4dfc28753816aaed407783e5b078b5369921f5fd0d966868f33c356e1c900d84029866ed6777c43b9b1be50cb793170a43ac389befa6176b1fdb136517bfcd5a1da25b2f441f3f6169759840964b4efd172ce994208348f2c6e219e125c0a56239a476bf50406a239e622d78a39b4158ec623334b924496932dc7af1bb3b580241c61288df1d9de4e88d21ec38664177d259a785bc81993fb4a91b1a642b4002737f71fe45846f7a4060165bb226a5dc7c9daad920ae3796029377a3e5555d731fa7ecbd764910ac7ed3983038ab60fc57e0cbd2d931f06ea66de547b50ea31504cf60c55d8edc5d7810a304b4891b7530fc13072ce33a802145978fc28ad2bdea9e452fd3d8edc65786708176ff12162b299441f7f23ab63f820b6e739cde39423efd3b5788904c45b083628f4277adc080bf3599c1de1121645f2706651b29e29f367d257f323e61849f388d4550c2ed6a9b1a6c55762fef35441d3e2c7c529ba1f209a4f422910245e17fce437ae03cc1b9cdae757c18498c08fe68a622da277265bcd80c6e784ae073bb756048014bebdf43487b72cc905817a07aef6b103f8bf7ff64a75537b0522512b1c8c93c9f60799b6140eb6a9b976dd33557bad415bc2a197ee2a234dd38247451c1f2aa907f46af80ed2bd11b128f97847cee3493c28fda443f8278fb74e4b0019909b9ab3a8c7a5b9d2a2ee0729727c4ea1e0dff793f36289cf9c109e3a74da2d138001a7f81c4964b9dd207a311b66508928a5927eff5c81fbd95752e87cfb642b0c150a7aacf356fb12311540657749d8a92f41045c095bc84e763ae769f1a3308055dcbb953f11934903e115c2411fb50cfe249b2faa3a532145480da41b8a3b5245db5b6de0fd3457db1666df09153b3c7c875ee3a5366b78651f69104d84c0337ec241a7a8a7d14002270a323fc9fb6f5257e425ae531c776c743b50d6f73b5bebe7183d862371abe375ec9bed67b79d8166268097b047bfbcf71a595c562b9cbdcf1dcb33b675e20feddf6fa470765714152d3b4cf4cb4bdbdea4d41fdc36c35ac5c9303c490ca556f8a2e5fcbd71e53b7f689edf5ea715b878e5f4da7649810cc228fad6345d31c72bda7686ff987297cf524d2022771eef7967a86d78d5484f472e13a0a1577d09e9b6369d2d0943f0ba38017f44b5122abc1a586af06bab9b2f9782a69b911f9fe288d27701459806e39f40269f29ce1934d5f0cdfb93aaefe4b2d1cd10f9d20c0f770f63c971c742df4e00c34107f08063a3f37c79db4f8cdd110daefe5d701578f81634bb6bfaaf1c6fa5819f628a119ced7601c07d49edcbe3830d28503b65b5424ef5b8f955b30b6d71ceb4c7a4c232b40b6cfa96960f1712942c0a17dc90b3599c96acd7debbe45059b14f99f50183c87ed878c7e48b10d8b5efbafa5a44233ffa16737e0e1e562487bb9f66fe7b306714a9ce6ff82bad2791cfc092291ed405e387275c30281428ff4d08bd3cc06cf68bf6c05f5201bca4445abaf50f55d36ca6ad6b351e2f0d331c8ddc746bee0cba0986d2198a4175015d45f0bdf93c1b2760abcf257130c8ed71bd77e4f8b05157cb0cd67e6fed6c02a6ea527a605cfc0ef8ded2cc26d7d7036e4592f447637163576eeae4c0e15d189e1ac4667a6d29f55c9312ede28042ab1b82c7c1fd61f9a315e0e1fcccf2f9107198ead97719556648167d7a92ee789c223a86cdea47bfee67e274e68573fc7c250d49e70f4889e0880183e748e777953486719334e3fd6362251b2579181fa1ed137ef316eef229b761fe8ec2987d4a1fb64122d1cc134bf343c9630a501653a4e49a44e7e1ab7b01b32a6329447aaa072f6b57e2d4925739351b97623e8a7d71e7956e64ca26331068f6b7ff686b31943db2e17ca92132bbf484c5fa81b2540bf64b9b98c4f493bf723d35da2560058ba3ca709c7899aa0d0a36b0c1ffaa28d1b742b6f75e81331740e6f013745113eaa45c4bae073e0953bd713884c444d1791030ce412e24489931f9205330ed704ddeda56d6dba970438aa25e09e8faa36d65520f0e87c392b0e3e1e75fb5960b04747b72ed67e3f7ec43adf82370938762dc41e92af67f2cd8094d00ef028a6aa2ee62e3022663682001acaa7c740b67ed427c8a43bb84f06c816af568a117d283cf4c3bc65f541d704d4c12a2696f48df26da49b293bb43c306f7c3090a303eba1ff38fb7a0f3bee953f56ce526aa8ecf6628ceb76a443f51ab573abd9481d9cc544479ad4b796e8b6b30180694acab7eecf0d817d015bb5663ee2bb59bc2bd3ba398617ed180704ef3da83b66cdeba46359ac087c3cd8459b4d3895c7611d731a9338b0d703029790909e08a0536fb259cdb6b62c519b35ba49118e7c9b39fa3701628945e7462aab3afe6bea2310e9436ebdcba3a867cea2bf7a51577837d79aa224b882de2e205753f40a6189e4ab7be709fb484a0f428b984201e173f520febda647fa911b0647d29b002ff20d58772c8db3a34d751bb93f28ab552d4063df82c45705721162c8f86161db2cfb7723c50f293a8ef614bf3911cf30e0b3bb97ee3ef6eeee507a2140d8f00f668de9027de6d2e84391e5112abd2cdfa3d90b8601aea832d55f109152c3fc6b670866975dd5b821b208e5375539dd4dcd00a206584be3c7766d02c95e8f0df5c0b1f47847331d08fa5506ed95a8cfe8e4702842b24830d1ca0d4f87c25215c330eaa3e42b13f8412816f4db1d4506ad75612e38c1affbd3ac23befda0bbc5dad9a3508f7b8f7de00397043fad5bfc2d849ce659abad56085a924089e568108a3df060846d607f4e5f0682cc6a2a8ee432c0d7b2434be9f98b0ea8ac8ad8ac6a389953a5129b774c4ec496b7f04dd504e00a17242df413dd9d3a41cd5ecf2aee76fb142cd7b9baaa7ec9dcaa3f389dbad5d5cfc6a45ac6f1d54b0529e6f5cc0c0bca9a6edaaa81e73186c9cbf3d3cd045646a5aadfea15b237135f9816d1c101393bb3a8972d30eb85125269bf61603cb80b7a2414e649d5cb288b9399017b1c40f460928738993de7ae00bd99d7fc02e39f49a0edaaae26a929b7f6f5a33c60c42d41e68d058e5f94510c7a0923217fe19e567dbf254aedaff79bdd46d03fbc5cadf51d1192269ed17e1875dd2c465c65f0a5e878bf88e0e66d69e493bbc85f016aa56cbe878c920b0e1b29d82539fe4a5e95e2c64eb82fd0e3fbc466de980916ea3cac3ba0057174d406f136b15cbe915a097224fa536c64ec6d32182e54a679ed33ed7599e5f11e01c4d4d6127f14e5c5cbdbebf410b8c59121b9539b91da54e38dce38152813dcf5ef583d829d5268641eb320ef5832680ffe6c7656a415b9161f2cd8742e43782de70b7654e3290af05804503ffcb1e7de0b3754306b97b6972038f6cbf51639b822a5af04c3f897161d036699860334ff323d706e0166ff960d565a75ce5bb4cf795f06de768293155883f2077673fb28e8a33fc26facd163af44297ef949e4db27b6103ed047cb5031cf51c4daf9032c0c0a1e23eff12cb711b024085bb3a05c30a6d9c398865d7c28bba6896284fca247961f2a6a0546b39a75b7d8b88d22f6aa6d9de3909cf0bb3d7078c6fa4d0eff8aec2ef82fe5136a201c91ac08a2fd5397c17dac1e6c46411cb435657c96b022ae60067b3213fe3d908b56180ad056e82a2c70bd2b515919dd7c1d9053afd367d4bc3718f3b66b85537242f728b57d01bf3d7624acf77886780636bee5471d86cf3755ddd4bf5007309bbeb118408ba54e0be89937f37c5a412c8d1984fed2e5698783ecff608680d0cf680178788f7b08078b50edb5b5025b3842e3afdb9c61664ec2a94f8dafef3389bbe0094ef3474d40f4ed4a21bde655ead7648f62f7131b17141942714c616560e72016f9309e3ab628fc0a1ae1f8dd86455606f91700039430c1767805fa9d1b2bd2894145f4b7c49d2610d4f6dc544e90261b085be31a9c36af43e1a2b41515144e4c02dbbc3fa1dd3707313f9a93e31dd2507681cf9a488cb148e7f77541343eea36d62abea625f5268061e905fdcdaed60b466958b15bf9ef6fb5e45288dda5f9bf6ccb790e8ed363af96cf1cd8db9ec05f4bfdd45c995edb23b08aef166e0312cae9f9649625689b5e3c82d3d77e21c42693fb6ae483fa1732800ec479a93e5e7573ced3d122e1755ae8f46aebf32beafbcde72583e48c28596c9ddc58a7d1327bdc424870766d6750ab9dd44872b055d9d762146b5e12aee727350f58d80d64fba0888c22bf97a1d3ba6214333b39e1440cbfc4ff8e6a91c1d717f7cbc455bdea2d644769897f6637acadd7870656fc1ec4ec4dd93c24b137a43206050e4f9514c6b310aa01b7ab01b86440104894d29c2b676526d6ba6205f7d2fb671499eb6a7bf2492a6e1232c9d7f31a410a9536b101a6dd7904482a66982ca3bd02b04c7ded873155835128525672650850b2a26b73a36c2864e7988ebeee5a15c5bc829c2df8a0e97e4dd1bd7c836c9c7f9267b0b6ea4cb25d37e2965661a4b6342546396ef1e5eb14bb775f22f2904709973cc6585c7033f54fc31fa10eba1a5019b83fd0f2234352b6a88cb52d4b6eebf28abe0547ffb0ad978c63a98fead5fc677bdc14de23dac64fb2db3c6600737d876b1a859b1ec819e3b38f6c7bd1be9d34d7ca30d938b8b6c34d778a5eba4e4a4ba12998c3189e31b345315180a027dae71ee86f822cb78f8306215c489e2904c69ed80733a9b5add23d2fc5634a257fca50b02491698f2943f5ac9195117eba79bbb55ab00a2df43cdd3dc8b8c56a31fdc23733f8a4d5777ff432757f2bb839f9b62ddf89c799816f3bbaab6759de1114ab4cc9e7341868833927425258e801635b5be377e05a96f74b98db77737b8c8e914bccb06de381ebbae749c06627aa583036c7f9a8ccc0a944f60a1cd72f55eb65ec3d398ecb7e5f480ef695d2d5758319c0e2dbd4ff49715808519ea4c18f658b560c644ff7b244ef00fa3652615fcd8d13fab42e6c48854afac0bcdd8b2821d2735313f86f335077e421a7f02c9c5f9a337c5ec71257b512bedc8307505585b7e8125e79fd05073b51252952410c995458f2c1c5956ef6a58c0639ceb822cd7d6fee654fe766ab76721a672900e07956f39d389964f1fda300df71143763ce2cdb671f78793eb3e66c76d3901b1a26ca782ee178b0f2ca40ce3f0ee3611b09fe3663983c632ea7d94e5a5ba7b92c878885aca19c7ec8f4367af09bd287dfc2b2fb598c1af8761c9dbb44790ba4bf5102569e1734a87001a4671648ee373aaaad10c186ce59140532b689a82cdb65feee4aab260618e013c6523fd98e729aaa3b08b441e522a6550fb889f8d620b31dc4e61f1e1b8551c9de2fb91516353bb6e75ebcd9d2185f4042b6977fd61409f13805834198ba66290b32b9dbff557156cfc27dcf44b4071b9bc6ee74c03d6de6ed525c1753bb27a6f0b104f5a419e6954741eb3a3e66da300aa12dc439887617c3b9e7603c7d129884c20e06358f74debb101df2c4fb3407d8a2377fc62b5ee2834589ff0ecac99d1b65589c5664b4cd0dd2f30c22fb3ccd0da04fc33cd9137d2c11180974befb668afa60069d56324caac25a7378e8b113b402b6d0260ac5c4bb77bc12ac979e639d2c749e3b951b7e2cc8a2c7cec625d49118401bb87cd722c761759fd39866491867f50dd03b44bc6d33d277cd618bbf63f1f52421e847236900517c8810c17c8c0d0f4f1dc843b44acdd540a6301302e5f2372c67f430714cf0f33f87703aaca1dc572f303f9e83ef7698c3d6e9e1fe698d66c4a3223ca9cb753253c68285d8b481a1c327c3ca5ce21cbd07360ada098cd90a32ed634cb84c3273dc65cde8843a5229673ad46f3b767c5b4a53478f5ad8ac8e78b713a3be9a33acd12e10ee98b2c082b3bd90a32f7afd1cab77fa31f47a5d6bcc97b8c42cd2762143fa317a304fdac7325ce821f27af8ed4e8376df8c0df6c38fb635260e58065e4c5cb449143837bd8b5edfbfd382d9172de0874b98d790cdcbdfb9a2e4ffc5c04f50c6c459f4fb7e4af8ca4a499da3963984ee65885e6a8332c97c3ab4e392b46a3ee41ea5ee3acace6ed2fd7740ef85fed529d4d062997400ea8be756c3cd991027b39adb236a4d840afb6d0f71e259bbffa747cb5bbe3d27dd3318badc7acc2ef2736a9f2b32a61c20f6104e481c4ea70993ed7bbfddf5a09b0a2a94f3b6dd7f325e1446b0e5007c28a5c243e1cf20ef1f5c3208315e0ba3797b81109c9657255fc0541430a22cd5fd9a4b462efa5d5d419f5f87554b7e85e11b0ea8835c85a856e2e16be5ac94b7d3f849964f620719b8a7b9c98f4ff91bc7424b273c87f44543aa0844dd9ef513d04b34aebdf4f761ce09a30f242d5e4f346e0843d10ca6cf191404bcb581e2665982f6e3698e5eea2587278c25efca88be7f5e9c35a293ee40f0f181cb09dd32a5315b49c6177ecdfe2ca032b3b1dd76075cf4a4d762fe13870cd44d65a7d703408ddb4b734b7bc96a8a3adee1fe412771091416e6b2926b55f9a3e8ab2e39e50dec90511d038745bfca3c185aa0aa9eef5f248fd0693b8a40de65c1fd1276831d74c90e89c86f37c7fade31ad65c2b9b6cfe244bf3cea2646d6e54e8bfca434c88b18697df75170a3f212b022c9d48f3859b4b38704889f286503dd479a22eda95808856e343c8664ca4410fce4cbc707bee906d49cb06ca1cc831be37c4adc1f81b55e1104340a93ecc46f349aa149386c58d65bf3937adf0255eb13d0b6ee29e54ce062d56be2a87b86904c06db1ea6e15e538f20db054dc522c5c6fbdac8324743b397f410d4b4ce213503c99937140864fa3b4feb2e4645f9600b2f9514338dce605c0e1a7e797963ae9dd0300a5dee9f1af2922a8a5bbd4c2a42e85bcda3784675e8b751cd9c473cf48dba32869b67611dc75a752100c3816962e7e306d2790cb89eb1fd5ba198f20bea7e9d6fcce41f9d7bf74b3b9e4a61e17fb844b3e02d3135aefbc1d0b58c877df4ba6c104a917b96bdfa3de1ec98ce681c8a764d4a24d1a16729faf2326984a4875b4ea725ea2fac90a94f578ca4702cb95deb1963f3f17797a9997aa366216f6184b7c5252fd9fe874bc23b13bdd180b64b0652b6ae1463d8879e253399eb3337496f47faac77e3ebdaf092a8372b373359c89406c06946277c069697f6db10da222357100c945aba6a04fb111dc5489bfe7da26154f83e3dab7f454a0bc55b114e3d1613831ae158c52fc94ecd52fef56fe2009a85dabb1da75a28cb1b498efd52acb44701ce3586758aa8ce492eebb20b6c25797d4eee3256be0119e9921178e59933035cac5b5f036a604d1e74bad047ad3da7faac95a8f3c7297effc5132fd4d67ffc4ae83ab55148ad70e1244601a37f0878b71c813fb05e8d098dda157e7fad3a9566c2ff7c5ef85444db3d18b900ecd610bfc1f77131c2975fcc5d86e67644cd2216359ff08c4c0a61f450ef1855e50cdeba98682c949b1f9d79e521d4a49c7115d9126108b4ecef90877dca58764dc87bea5005d49638cdf583b085b5027286ff7e367d1fc615765061706e9fea255e9dc2e50af6e65be4d04167c9c22056fd036253ce066d2c084cba1a9ac49f9ff5162ad59460678fdd87715a6306d53d10ade25a0e173e89c775e432890e74c68ef8814fb5d8d41c71fe8cbb6d5139838a20d36071cb82b8228832d97be0de9c023333d2dada47408d836bebcfaaa18bbbeb8314be9e09b71adb245d7dc998dd07d90f1c1dd5288bb09e9963f60342a798be8820ffe35e29349a2bc89820fe482ac39d5e1e6cc3e939087c20bf131ed23a4214185d8978666d45499522c5e1be332966f7192580f6ea62b032cd656fa3f4dc65e8f1f0fdffb8cc881ce01c1afddb693a1fcd25ec83967747bd073872ecb3e5c34dd6e1d28777f7b0c27123d71c0dc8363929fe88460612a639be1120870b340d1501748a367388e0b548c8792b9bd44e7766bc203d05ec6b811956ace7aa3ad2f4665025160c6d2cd5d11509b9bc2143017c3fe75283b7871dc57c1de9c83febd30419e5143092903c940e88c6cb1b8adfa2113e504c58cd26e61b7d28d9fe386ad2dda991eda326b56ae5499f26943aad5e791eb2d439ee2d64982dc1fd60567ae73bf83f533534bff4f2a6d27ae9dedfcda47415d2d166f6a7ebec5978630ffdd8e0fe5c235e0f59b63944a55176ff48ea06cc390d2db68a787c06a209f76a75e447848136626b73515a130a7dc14b48e088d68d281af5b30c71559037eca9e48ed0cf60d746525d73c9c6131079aed8736057716348073c65aa9b4b9ca28dbbee0dcb46cec1909ddad2a170c638fd8c84272817ec895687b2ade208a5dab749971fd6977ac53c6b9013a6adb24c29cf112befdcf1e55a138c6816ea894973e40d1b7260f4e4b681563782a5b94d6c0e22e8f4f8359d7a1e2a29530e2cbff9b85c10817f59b8750d4d32962b44403b2c993e9cce56b4dcebf2a4f2da67bad5eac928da24ad8657e3b04328edac894d51ff1ff7239907adc15d21778fb147a5f1aa4b656aa32bc961a00923db6273f2f6f772437579431b483090c86f079b06b0a56f2f8122ed56e98655d5d48154f6b2e08b1f18e2f3f709d8828138d40780c4c6f6453e70bdb1a14d1dc471dee12c10557927b7ca0dc5437d70b0aa9effe086e6b98445c3541a549993d45675dfd55395938f36b6211ee3b12b6a76e9685836b1705dd30bd0830fedd82499325a9fc3587c74d77fa998f46ec11b1b6f0fed15190cedbec5c8483895840b1b24b45095cf7514f0b2332f3b206572d5a6280a8a67b496165900c01295273391a061a0797691a7277aba5b1c4583a31ed1bc68ea9fb692bdf6c54a509a96f879b7f45659fb3fe2e535ffc8f6d6af5b848bb336673930a489852a726a8e00ff22462f6a1764ac80e8819cf10ebf7f6f6352a23a4bf1752164191ff7565d3038af591f98f6db090880331db484a1a89c81df0f7d2d8bbd6edbe69963696f633008a503dfd7d9164f34ce5fe1c6c821f8e73bbe4b9be7eeb9a0c2442851b9d70b1f72feb5607cb4a302d6f66fa45da0597316c4ef9b68d2aff3c87352d61c775ce9dee5f99409f75ed910788fbadacbc408793d00c5d919fb4ec8e55ac8f319c9e75afcaa173befbd6476ff097edea544e5f33a8f7e75817859e6229735528bf18e999367a5583514da4fd034c3e18c058c2d207e6e67b92acae2405a09deb6c769c383adca62917034721b127b80c0aa5af7461a288a5b7edc981ca5db12ba5dbda609d556b9db6599f801d0c435f22778b72cce205e8b19731bb2673878871ad3147d6ea5e9b97ef5e4b48982e84b15a49a85beb5b90a6707ea9cc6c703dfc718760a84ce73934c77f825258d0a4a3faea664727d9dca474bca218519d6d6cd88a620a865c6665b4bd6af7019e373fb97d818f746adc37af825fee413d3680c579f72e650d762ec9d7d3d4e7a8f85428fbc6beba478ab43f6bfdeeb2204f46230cedbfe68571308c97ae1f1c2ced871b1bdaab0bf5ccd312f8fdbacf9d1e2b9c7d128748b0f4261bde686ebfb504ca648679cd5e52342cd2307f9459f47020dfa92db734e5661f4d92172dd1ca28d67ea039bff407e8014e51f99f0da8f196fdc4199d15732ab38a683f27ba35da2dcb0f0e60ac3363ef2916a2c10d132c0e72a5fa9b6204d96f2150c97897c58f8323fd92d81e12a01b6dfa38ac0853921a514f745a2d368b371ca1e93b56c238957cf72fe151c6060c8c6d3ddda44e006029b0dd774ae7276da4aa54f7fdf7212cd8e152e86c7c88bb1bceb3a51781c8de41c6dc29e83c733b5be8b371034da72c60d4ac8e191eae25aa16e5a7ff46804f4f1c836b623133a85ee50ac9e24f1457033ac7a4df09bdcb07e39fb2c3a7afecbdd5936609a7f5f0ad5452680363439fa2f49e8a79a40f289cefcb1cc8b93c73d19d895db2675a742a0500b8119622e405596b1d05bf088e9f2b6f3fec90d2c9c1bbe819dacd99e8a805325174e1b03b458aff9b4cdf90cb6fc634bc1fa10c56002da444019092c80978f05eeb1239c96295bd495531457e1def4484b373226dd71f9e1bba356eb4d2b133093a2a4b55264d3b9c721fcc067fd86b030e29dd7b8298aa978e288248c436f934764473c97b4335fce66a4e4b338f3dcfabd9889085db1b4f64fb70dfbb4b2c15cefa1a154bba8f35310259cb5c72c0a2b58bf4cac0a84066f3c9fd720242abb7cfb860122d8be3465acc5e8f6b754882054e73927ea2b47e50b137b5d9120849a1fad3618c5fb9bf0b9af944e7570500601518e3731397c0195e3b034c7d234393cf1ff164882f400ccbc07fc64e7a0b7b956c86cbb89b87285e734f6d8dc3aaf48c0665e898e5df599bce62594a08ef4dfec9bfd900892c107458b2de93b806c03e4509da8c19273045bf64afab86267a485349956714347219a891fecf52ae61a146c2e84cbdb80a77ffed28acb0b14e095e4a0f29533163a600e5acbd7955e2c388aaa8bcb43b0401c7b4db15f17bb68dc625ae62dcb9e98506605b688c88743783a5a8ff622d610abdc41a320a8335e475b060a9bd54996ff8f88466785ddf2cab6d076592d25fba17f579f2e0e8c1c8593633cbff8edca170025447ce632cc32236dc6807f458dae2e52aaf72ca7e2e8bf27beb4e4ee7da844d92a1f342edf89807be089569adbc347b7978fbc904186ba5c649177ef7a29d91c84773bddbcfdec05e185c78de04a07871c7d458f8bc859eb4bf526301d0ff264111c4be53e20325a0b611873a0ab5bc0e22c325bac9027bdc4d5c07cfef1a4498723c7f0b5d3ac757be6022dd24999cd092e4ec660482a07df8c7ba8b26e48bf4f2e29db433f6109091b57df03be3204afea5104bd566152fc76c03ac09c75acaae10cffbe03be3c35ebfa3b437237d98e87e43dff53f010ccc13b2170754cdf0309b89561b1808b88cf246504afcfe3ccf6fd1bc59ded7db82932b13b71e688efd0fdc1f16fd2c9b76c8a8e4b9ae19e79b9802e6fea1d0b98bfe605f0e5ff3e2c356fe37d42e9240d1acc071a8eeecb48b45244535301058d1e5913a37a62f0e8eecaea214d4084c08650d28fef86cc3c1a0ab40244c3aef6137a27d480e409639c1ff6111518c7f5bf6f769c1b9c537f6d3da6057d48720f966eedea3dc240a411d42059eea63a6892bde1243d3ee77a4343f22792ab3de6812c6a1a0a7ec43b308e362a4a3dbcb3b49e4c3ec8c834da9b601477265e53d540fbf948a7632152c42bb7b5868f1886cd5616c6903ce8b341b933243f5349ee8387be97108b347ef9b2d7567cbb6b433357b5f6ade48bfad04f85a898b826bb4799f041f6362c0cc2dcb76f97465ba1c5a7f445610666185326d7187257717b89bff70aa8d09dda4288d7d0c5d4fabaa61b817cf552503d91805bedead1e23a27a1554d0ca4d82116b891fcf8fb9185ffab3de00a0dca1bf10158668c3481267d4ab50f9f867a039afb5ee87a5ae91263500cd98d33e2913db0e20af7c45086690a70f546beec47de2f6871a1479bf07f65bd486a008dc7ab8385147a9876d101e78b778ebb1bec884f5a00811d8d24d8e04c353a4475d758019e4e409d096fa7243a2e73509658b7477b18be446901a35cc3a2a3fa07f5ade3e16dc5acde46ce1dbde54111e626bc319e220b2839f4fd8585f2d125a1da93d207fe859171f82593e80a6bf00a2b4c7859ca7ba830edf7743bb692796c5efaee3e16f095719b1bf7e05e95fcad893d908e5055c23d2568bb40b73b241653b181c88e68094ddbd90bd172c116e3f33135c988eee6436a10a1aa40ae1b33b5c9f128783c1ef86e69a24e67abfbb48335ca63b3ab3f8caaa3f145501d90af750ecc1f0211e01be02cd24bce7591a81ddc73f97c817b489a1014591d6773dc3dc50109bb1e202ff26b14e4bed028e44cefd2f8d4620030b69b324b96c028868f846eacd70f99b3d23f26232418570def3320524fdf864f0518c416c292d7d43b5a057a714445d27461a57488e038a0a04e619d5de34cc8505900731949773e24336a05c4e5c354d1812d3ef3d5612a40681951c72c175e28a809b5c7002108ea3bfabb6ac9d00632457ffea67b5aed3cda86b641a3f08cbe9a3481db3005a374d81750dfa30fef294541b3082cd2c15f362908f4dc6f41d9c9a541cf02716602bb78905d4c497a39334820ad25a0bc71651b609fad7a1adf9ab34a560db0421e8c1fd1f38a53a2322e0a0dbeb5e17e486f3b74a2976d6ff4c6f10918a9d8320b323cc4f425a922a18905414cb0f5d9f053f477647af8f26e2ed340141a5634d3031daf47e4eec0437658850317d990437f128a9104fba983ed16a9759e3976bbdbee4ee3af67a9651236e198801014930a66b41b0f106bba4678c95bd221effc0ec1aaceb45e7cc61dca887c1037034c02a5331d896fb92a34312c94de2a51d452985bdd49a684795d0ded1b36d9430c9a4a817c6dee6e9908b5cda2c6346e6361e22a745cc979937355be576d0bffbe3a480951d3964fea28ab4b9bb3c52f91260337772b760626c5d8ec7aec2b7488b07d93c91e9294a86a0f2f7ddef6c5e56101774598db57e22b338a58ad67bc3301ea9cde7f252c3bb3f0d2919111c6feb7d86b594f27788ba2748773aaa7f7097b6b7647f5c9138e48cb310ab6f5993f32cca3d078ac48902e4d72f73fd9db95990135d4c7d76f9b856764890957e3b9a5a5be3f7a442c8e2f777d477ada54b8482fa8a6aa630cb5a10b21a96069884469f948739b5de2e17b573e661bb93acff347488ee96975bb0edb9c31669321b585cce7a52456f58ddb5ec81b8ddc4fb8a4e3aa79eef5e58d4ae20b915631e3ef937ab5d5f1ba4e5a7e2c6e0ac92f1b36935372258b27e38195f6221478eaa9bef3e1984ce970ea4ae91bdebaf8e0ffd2c97d88ff53e49dfc11ea5b4fd99fe5bf555dda2956ac5d40e26c36ddb63364d010da4a141cfe005ddc7882e6469a50fe27622ed4086fda8704ebd02dde7fbc4ea72b3de9448a3608b821ef708d4eb156446fb76eadd7114831cbe2e8412df11a9c942da9ec8c06d2d875ea4ddba21157de06596bb8728ace4e8e08a1d80240e1ea76a2fc16e1fda2f6734d795fbc54d988ae773f4eb36ace45c62eb53178ee8940bf13c6632ec269f7c8a4835eaf457190065817a60863af83e23c5fbc4aa41b0e2b65afed302ca4402bed4f94cbe4c47c5c890c0a3932bb06e6f2546052f7752609c744a6a6a8cf1eb30c642a437633405795af3332e3f77fc01f189d164514cfb0244ff2dace2fda9f43cee8a6b7d23b70b752cc4713c7c15a98e1569bc8b0c00660f544354612a1070e6a888def2f27cac3a973ad955012272431a1f63efcdb41aa45867913a716886bfce91271ddeaa37806d6fc25bc9acda6f5688e7faf3275952f677e4b0640582503ef7e12e45f933523fe024aee71687a301aac013db513f0fe1d1dc50ec61ccf7c3f02f3ecb97f86cd87e36dd170c31f466a1a9b211f36b42d9da7929f1a20477b19079d90d9ba5a170438cf1f5e6555b8b6c878b750c3d9fa582f8caae5ea84342dc69865968fdf7179cfca788e8af9073dc5c1d2f98282f43aa08361b27ea84a5dfe85c8a3210ee793c7e5e86d6ebe0b9ed23975d20d5c53905843de098adaf050bc6dde4381daa932be235e2c7cc1bb90d2af84a8becf696ca04b93a5b32e6bbfd4ebd4b3d4813236191515631ee954e3f27cca036481b0718bc6f521efbd3838155dc94ea209ee7d097c48fa6a30d5c7024754c05599dbda2b50ed33ac46d0337294f3d42b534c934f7102337c191dff6d0e4f87a7699c09e45fd0ba81234c9f01c9349d149c48b8cd8d20354a6ac6c65c8792fd8e6b1412fc1a49275c4c5092566cf6f5cb5ba7a88ac0c08047023569f67a15a907b361ee014eaf6e7c48009f0eb52685370c02418c30a9c3ac6de59f5ae1ce439cd3cb761bc5bb919465eccb14828121ad280d8edc359e6e5b8b38dfb4c9cf2bc9df3dd362f5e1c742bd0f16a0eaeb07c8e81e9af238ae7072ae6dc8c1f99c9048053b33544395cfffa07ffd9601c684e252be23df8bdbc32b57dc9210e7f7a3c316eea440e54737342256e162b59f78c299fa47fadb98320f2b369d907d36b9a9eaa42782dd4c6bd9650fdf9345ee321eeb1bab98567981b8c5b428fb57c265ee4c46fd0e909c568f833c7d3513494fc8bf4b590fb3a81040d8d86a1702316eec584280a6a3043f746ef76a0229134925bada95f1aed78ba658bff33cebee186363c05c0f60a22a6183d795d0b340807f1bb3c156d2d58d8e91efb96ed3d0e84f658731dd0e8938b6e385acf8d490031e6eb8f784b7945566b0280c82831a6e2205e213cd28ebc928a7061fdb423b64ed5db81d496bfc001cb878f9a852dc0d660af285cc1a340663031629a1ed380be372106f9404dcb13805008bd1a2b2957649407683d2109d38d5295a382bac58d28d430f9db22ab7226e4fe509e1137abeeafaf6d6ca271fa398f58441b9b490cf49d560a96930f0030175237081cb87fd65ffd358636210f08b337f527bdce9c44f298817e37d7be43480b2494fea6a76f94f11928fdc0ce32832222553a7eb94af8541c8f301a22f07f3aa08626fbff358924b19d7f58e4ca0a51659aa91ace6ddb0f5aae37a65569b8c58193a3008cd50cd5121818ac4cd0d0cc1cf046fd34c74d5051c1905ee3ce1ce1d7eb7f92adfc0446f6bb75f8429131407580f5d5f0af135cf35c6423f9368be6bea117bb4721e5d596aa681d76b0a8aa63a727a5571707c1dbe63142715c79d69c1a8cd2c575af3a6321a2bb9e19c8f854056cdc8b416245c70c7fac70017dd5ebc7c070ea9ee95edb24b03ce3dee293a04f05058fef3d29cbe82a421bf8d9c98baaec8f75c758a2d2ee99611e0dd966dd6be569532c2b5cb447bf379b67a354ba035af89539b89b6666dea9737f97e27b0f40c2c4513452e62ab3f70880dd728ce538d1fda44a3c834a919ce93c4b4d7b1d5651d5f5272ae934672967c9ac94b679c5e67830e8c00529da18acc2755c0afd3dc758c3674b208b5c4ce9312912bd60fb5dfdc1b04c571c0afc7fc8826fb9734583db3da44f1576578b654c1798687e460ad423104ca215102c1d37521089412ac012a4b348643ad0adfae76ca60fe68624ce3977db98aeee6b015f92a5b7be2537bb8c5fc63eac3e7694f0c144ec7af6ec1711bdfbf911165c75b2cf6a1448a6f6b8f6de5135b536ad2ea96b3d1f06ee83377dae9a4be3b8e2d560f8259b3e02c5502fc0708e22f1fbb5d8aa91fcfdae4273d96ed6d7fdfd021f8507f187b0a21312fff5a6011f64896df476c064b55fa5c271d4afc9b6fef401d00a980200b2092905aa205277b480a3137a076a5441dc66577c89dc262bee0a4d37c476a7e47e915d640f74b06a365fcc0100b5c09eaa7e9ba8ff28ccdac90e879ae526d8f23d2507039eee2ad97f37d5d3aaeb7bd61bc0aae1b82eddcdffc1a67dd12e1f70adbd2628b30bdd6dd9df67a84ba31abcf4771b06adc598c9ea0ff0232cfe9bf7c275c5eed9647779fff363ae9a323cc755a2bd5a63e2503fd25f7f5894d0d3ef990639ab40af36ccb0d2ba4332c5ae2e9ce018ff774d4e4d4b98970dafb7c1567cd8dabd2d0987770d41f00cc2585c25ea5252c00412cbf85e93848628c7e4652b99d3cac704066b62eda07d8df6412bcb2c168dbae61157056357920926481506b0a779ba175a163cbf56b6c126fb54924438fc39d54f1a6cc50e24ddac28faac43d9cf3eee4a658deca646e87a7f1c4c83efc6dbea908ebf216558bc58c2d03c7722783045b331769992cc72c796d739e229e41b47259d8901bc838db2d0521c742f53cdade4702183a728eacd3890736cdb9362dc9e6372d6a8538cc25f2143b01693d2f5c44a35de1a898e70c89b299025daff5e005a5c1d80c215ed921a085a4ca4986e134a3df041a2bf637b29432a02cc482c2b6e9af4b9d0a1c5ecb5e3e33bee070fa56e4e2bc4418da869be1c5426920e5b372cbb77cba54a3bead614e2225cdb040b0dbe42c9dfdea068f15188a7242e90c6c951284c35f73c605c44399a782cf99588ae79709666595be38a70b4dc9b506589080e4dbad7fc39d7a465b46aa2e8d17912bfc7e90cc2fed429c39ae806df1a7ba29ffcd3df828da27cd8b513e898e78558a361c71068659edfec49670a9640180d71a4b9d66b751e000582f05f6bb041c9e54b7e1ff22df1ee3a3e5c55cfccf153fa683aa7580274fb7917b96c750e6d6b9a9b8c27951982dc1d5361dd5aaead643a531a21950ec7a8727ec5391d11f86ec821009d1feb320b946945ae8a4d521e1d38741c9593ba6af535d0702c7eb5904459b3d0b349b18d5d4f9a49404807b4b64e9385bf7f7348546017818ae94118a334fab4179afd78a310a68e5410097053e4bb002a69aa2b1f52c75bfee59fd0305f81240648450d6bb6cea95fb688a0d04b0fe28222f11e9ba6f3f70e01df04cccb03a8fff5c66ee5e283d2f7bbe67308f95544375df06d6bcb693fe6ddccee3642aa70d77a176da7904684fed5a0be61d1ee134cc384300a439ec60a0cabe6dadf0caffd7dc660558e7602970c41ec070369d921c1c2cc8b2212d63e8c48515ff6372b87768553f056f651b05c52a952f596227842a41afddd1a179b45162ab2c4b2b4ced521d7b2c53218bf510f53cf5f5c2d64b122152303a23ccdfb70a314d0ccbe7828af611d126d166d788b87a644b5497a7501de4da9cd340fa5b3e3c1f64325101d87bfbc11abcbcf57e6362e84dccdfc9403619552aad7e9a96e971e75702183890b17651a27ca91daa705dae9616f0492319f67f951365191fd0b30c1fa068fec6c195f45e0a1703dadf70e5298038602c674a083bcc8170cbe2324bcf3d0b5208a0e2835c98107dd7607fb76b49c5624d8cf2e384c6cb8cd738e2239f0f803004d56848343d1f4a4c98cff6a7c18c858a3bb1de7ab11defc4ee44e38713c0651f07280df254cf9075389870a899d1f85e0ea9f69077a3150b672c570e029ce52b46ca7412781cb3ac6716003df907f7b088f2fd37942880bbb2f77ca5bcd047a499c21dd52f963a3408746cd1d815033602122356cafc7cdfe5b4b1a4a6661506084f1e1a5323c80e1e4248598464b136ef551684cd0561e77cebe9603cb45472accd38bae111bf059f3a7142d802792e40a0d90f611ba8b4eea975dfe5d712737c4a1ad6f4651bb9cab9c84b2306bcdde891a397344c1aaa8aef3e82a737e272cababdf5a1a06db991f9d54adafa037702d1fbacb197e0e10efe0d0208ba00c7e7ff6f901191424023b74098b1428886b4cad21a0a06f5a4145dc97007f1b173ae8e1b87c1d54ed785159d1660ca57e4742958d749f408d6aab4b7dc9e6de23e323414c003ea8befe6051c8f9b7949b59cc0a9245967b5817aa27805af8896e1499faf6b3ee60d90a2f8d33c73b8cbae6bdcfc59c08563409a6cd8689d125eee9874520c855bcc1def0c0afeb1490fc3dba342097b1bb943be8165fa1db1f05dfdf41ddcdd1b8c7b667760513772b5633b8b669e1b0aaec2f7a4ad9e98719970a032458efae956f86f5d0051177c0e9e58bbe9e26d05136bfaeca40ea74a08500448fef40bfb51c9935d23d49578a75027dd97a4ed835359ed606efe69c3542eb4c6cbf2c6d9e9179270cc631d9cd552cc757ead56496a9a33f2d6de3949f9f12b7ede6448813f89849ca5f1f9df700032f5316782870b5443ef6ad6f678a05146d5d35146bc8c42c540a2c0bf028d77f3a8a7742d33d90a985f88e2b42d06d1b50f6f9ed131e314797bd3290bf51689555f009899c0ac3276be00d650351a3051dbc970a88677faa5976a84bee23dec16e04c470aeb31f82a7f5b1e80bd891cc5811e9710b76ccb8a4a9517aa44c405d86b6834cf8d3ce93e486f22a41dee975bd557fa39e4b768939d1e8f155535ebec0685b586a2c3935ee370d46b1525c2eaf1ae7f5a4efc785c1e1488bafe0e64234befd3a749f97d76f8a8ece6ac18e31d807f889089c1581f54939aa5e51ab4b540f08b3bf442343e5552ebf01f567302897a51a3c127732cb8b5b9ced6f84526c57a405cd4a72f9e10efe513537400ebe1276c0edd6e3e1da4c0205e63c6bdd1e50785bf635fc9c62a985fab795e6c6d188310f779dea319936c71909ec</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="笔记" scheme="http://wolf-ll.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LLM" scheme="http://wolf-ll.github.io/tags/LLM/"/>
    
    <category term="项目" scheme="http://wolf-ll.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Cross-modal Causal Relation Alignment for VQG</title>
    <link href="http://wolf-ll.github.io/2025/04/01/cross-modal-causal-relation-alignment-for-vqg/"/>
    <id>http://wolf-ll.github.io/2025/04/01/cross-modal-causal-relation-alignment-for-vqg/</id>
    <published>2025-04-01T07:51:00.000Z</published>
    <updated>2025-04-05T06:58:39.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cross-modal-Causal-Relation-Alignment-for-Video-Question-Grounding"><a href="#Cross-modal-Causal-Relation-Alignment-for-Video-Question-Grounding" class="headerlink" title="Cross-modal Causal Relation Alignment for Video Question Grounding"></a>Cross-modal Causal Relation Alignment for Video Question Grounding</h1><h2 id="前置论文"><a href="#前置论文" class="headerlink" title="前置论文"></a>前置论文</h2><p><strong>CausalVLR: A Toolbox and Benchmark for Visual-Linguistic Causal Reasoning</strong></p><p>随着海量异构多模态数据的涌现（图像、视频、语言、音频、多传感器），大型语言模型已在多种视觉与语言任务中展现出优异性能。然而，当前 LLMs 严重依赖对广泛知识分布的拟合，往往<strong>捕捉到跨模态的虚假相关性</strong>，导致其<strong>难以学习反映多模态知识中本质因果关系的可靠思维链（COT）</strong>，从而限制了模型的泛化能力和认知水平。值得庆幸的是，因果推断为解决这一问题提供了新方向——其通过构建鲁棒的表征和模型学习能力，有望帮助开发更可靠、更具认知能力的跨模态模型。</p><p><strong>视觉语言推理旨在理解视觉和语言内容，同时执行各种推理任务</strong>，如视觉问题回答（VQA）、视觉对话、图像/视频caption、医学报告生成。然而，到目前为止，还没有综合的开源框架可用于<strong>因果关系感知的视觉语言推理</strong>。为了提供一个高质量的工具箱和一个统一的基准，本文开发了CausalVLR：一个基于pytorch的开源工具箱和基准，专门为视觉语言的因果推理设计。</p><ul><li><strong>核心问题</strong>：现有大语言模型（LLMs）在多模态任务中依赖虚假相关性，缺乏对因果关系的建模，限制了模型的泛化能力和认知推理能力。</li><li><strong>解决方案</strong>：提出<strong>CausalVLR</strong>，首个开源的视觉-语言因果推理工具箱，整合了多种因果发现与推理方法，支持多模态任务（如VQA、医疗报告生成等），旨在通过因果建模提升模型的鲁棒性和可解释性。</li></ul><img src="/2025/04/01/cross-modal-causal-relation-alignment-for-vqg/image-20250404143929943.png" alt="image-20250404143929943" style="zoom:67%;"><p>CausalVLR 具备以下核心特性：<br>​<strong>​(1) 模块化设计​</strong>​：将视觉-语言推理框架分解为独立组件，支持通过组合不同模块灵活构建定制化框架。<br>​<strong>​(2) 开箱即用的多框架支持​</strong>​：内置主流前沿视觉-语言推理框架，可直接调用。<br>​<strong>​(3) 高效性​</strong>​：所有基础模块与运算均基于GPU实现，确保最优性能。<br>​<strong>​(4) 技术先进性​</strong>​：代码源自因果推断与视觉-语言推理领域经验丰富的HCP-Lab团队，持续迭代优化。</p><p>除提供代码库与基准测试结果外，本文还分享了视觉-语言因果推理的最佳实践与经验，包括对超参数、模型架构及训练策略的系统性消融实验与分析。这些工作旨在推动未来研究，并促进不同方法的对比评估。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><img src="/2025/04/01/cross-modal-causal-relation-alignment-for-vqg/image-20250404152748481.png" alt="image-20250404152748481" style="zoom:67%;"><table><thead><tr><th align="center">任务 (Task)</th><th align="center">算法 (Algorithm)</th><th align="center">对应论文与技术亮点</th></tr></thead><tbody><tr><td align="center"><strong>Causal CoT</strong></td><td align="center">CausalGPT [21]</td><td align="center"><strong>论文</strong>: Ziyi Tang et al. “Towards CausalGPT: A Multi-Agent Approach for Faithful Knowledge Reasoning via Promoting Causal Consistency in LLMs” (arXiv 2023). <strong>技术亮点</strong>: 多智能体协作框架，通过因果一致性评估器（Evaluator）结合反事实推理修正答案，提升思维链的因果逻辑可靠性。</td></tr><tr><td align="center"><strong>VQA</strong></td><td align="center">CMCIR [8; 6]</td><td align="center"><strong>论文</strong>: Yang Liu et al. “Cross-modal Causal Relational Reasoning for Event-level Visual Question Answering” (IEEE TPAMI 2023). <strong>技术亮点</strong>: 跨模态因果干预（前门/后门干预），时空Transformer建模多模态交互，解决事件级VQA中的虚假关联问题。</td></tr><tr><td align="center"><strong>VQA</strong></td><td align="center">VCSR [25]</td><td align="center"><strong>论文</strong>: Yushen Wei et al. “Visual Causal Scene Refinement for Video Question Answering” (ACM MM 2023). <strong>技术亮点</strong>: 基于视觉因果场景分离（CSS模块）和问题引导的时序特征优化（QGR模块），通过前门干预实现视频因果场景发现。</td></tr><tr><td align="center"><strong>Image Captioning</strong></td><td align="center">AAAI2023 [26]</td><td align="center"><strong>论文</strong>: Yang Wu et al. “Scene Graph to Image Synthesis via Knowledge Consensus” (AAAI 2023). <strong>技术亮点</strong>: 基于知识共识的场景图到图像生成，增强图像描述的语义一致性。</td></tr><tr><td align="center"><strong>Medical Report Generation</strong></td><td align="center">VLCI [1]</td><td align="center"><strong>论文</strong>: Weixing Chen et al. “Visual-Linguistic Causal Intervention for Radiology Report Generation” (arXiv 2023). <strong>技术亮点</strong>: 隐式视觉-语言因果前门干预模块（VDM/LDM），结合PLM与MIM预训练，消除医疗报告生成中的跨模态混淆因素。</td></tr><tr><td align="center"><strong>Medical Diagnosis</strong></td><td align="center">TPAMI2023 [4]</td><td align="center"><strong>论文</strong>: Junfan Lin et al. “Towards Causality-aware Inferring: A Sequential Discriminative Approach for Medical Diagnosis” (IEEE TPAMI 2023). <strong>技术亮点</strong>: 因果感知的序列判别框架，优化医疗诊断中的病理推理过程。</td></tr><tr><td align="center"><strong>Model Generalization and Robustness</strong></td><td align="center">CVPR2023 [27]</td><td align="center"><strong>论文</strong>: Yao Xiao et al. “Masked Images are Counterfactual Samples for Robust Fine-tuning” (CVPR 2023). <strong>技术亮点</strong>: 基于掩码图像的反事实微调方法，提升模型对遮挡和噪声的鲁棒性。</td></tr></tbody></table><h4 id="CaCo-CoT"><a href="#CaCo-CoT" class="headerlink" title="CaCo-CoT"></a>CaCo-CoT</h4><p>Towards causalgpt: A multi-agent approach for faithful knowledge reasoning via promoting causal consistency in llms.</p><img src="/2025/04/01/cross-modal-causal-relation-alignment-for-vqg/image-20250404160156490.png" alt="image-20250404160156490" style="zoom:67%;"><ul><li><strong>挑战</strong>：尽管大型语言模型（LLMs）在知识存储和生成方面表现优异，但知识推理能力仍存在显著缺陷，包括知识召回不稳定、推理过程易受干扰（如事实错误、逻辑谬误）。</li><li>现有方法不足<ul><li>自主规划或大量采样推理链效率低下，且未解决中间步骤的推理错误。</li><li>多数投票法可能因模型共同偏见导致错误答案被选中。</li><li><strong>推理步骤的线性依赖（如链式思维CoT）难以处理复杂非线性问题。</strong></li></ul></li></ul><p>CaCo-COT：通过多智能体协作（推理者与评估者）实现因果一致性检查，提升推理忠实性。</p><p><strong>因果一致性思维链（CaCo-CoT）框架</strong>（如图2所示）的贡献如下：</p><ol><li><p><strong>因果一致性验证</strong>：</p><ul><li>推理者（Reasoners）<ol><li><strong>概念解释</strong>：明确问题中的关键术语和原理，减少误解。</li><li><strong>子问题分解</strong>：将复杂问题拆分为逻辑关联的子问题。</li><li><strong>逻辑生成与答案合成</strong>：基于知识生成推理链并得出结论。</li></ol></li></ul><ul><li>引入<strong>评估器（Evaluator）</strong>，通过逐步检查解决方案中的陈述，确保推理过程符合因果逻辑。<ul><li><strong>非因果方向的结构分析</strong>：逆向检查推理链的全局一致性，识别逻辑漏洞。</li><li><strong>反事实矛盾检测</strong>：对原始问题应用反事实答案，检测逻辑矛盾。</li><li><strong>再评估与共识达成</strong>：修正错误或确认最终答案。</li></ul></li></ul></li><li><p><strong>多智能体协作机制</strong>：若多数解决方案通过评估器的因果一致性验证，智能体群组将协作生成<strong>共识答案</strong>。</p></li><li><p><strong>实验验证</strong>：在科学问答与常识推理任务中，CaCo-CoT通过系统实验证明其优于现有方法（如传统思维链和单智能体框架）。</p></li></ol><h4 id="VQA"><a href="#VQA" class="headerlink" title="VQA"></a>VQA</h4><h5 id="CMCIR"><a href="#CMCIR" class="headerlink" title="CMCIR"></a>CMCIR</h5><p>Cross-Modal Causal Relational Reasoning for Event-Level Visual Question Answering, TPAMI, 2023.</p><p>现有视觉问答（VQA）方法存在以下问题：</p><ol><li><strong>跨模态伪相关（Spurious Correlations）</strong>：模型容易学习到视觉与语言模态间的虚假关联。</li><li><strong>事件级推理不足</strong>：缺乏对事件时序性、因果性和动态性的捕捉能力。</li></ol><p>提出首个面向<strong>事件级视觉问答</strong>的因果感知框架CMCIR，通过跨模态因果干预（前门/后门干预）挖掘真实因果结构，消除视觉与语言模态间的虚假关联。</p><ol><li><strong>语言后门干预模块</strong>：基于<strong>语言语义关系</strong>的引导，设计后门因果干预模块，缓解语言模态内的虚假偏差，揭示语言因果依赖。</li><li><strong>局部-全局因果注意力模块（LGCAM）</strong>：通过前门因果干预聚合局部（如物体区域）与全局（如场景）视觉表征，解耦视觉模态的虚假相关性。</li><li><strong>时空Transformer（STT）</strong>：建模视觉（时空特征）与语言（语义）模态的细粒度共现交互，捕捉事件级动态关系。</li><li><strong>视觉-语言特征融合（VLFF）模块</strong>：利用层次化语言语义关系自适应融合跨模态特征，生成全局语义感知的联合表征。</li></ol><p><strong>实验验证</strong>：</p><ul><li>在SUTD-TrafficQA、TGIF-QA、MSVD-QA和MSRVTT-QA数据集上的实验表明，CMCIR在事件级VQA任务中显著优于基线模型。</li><li>消融实验验证了各模块（如LGCAM、STT）对性能提升的贡献。</li></ul><p>VCSR：</p><ol><li><strong>视觉因果场景发现</strong>：提出首个基于<strong>前门因果干预</strong>的视频因果场景发现框架，从视频帧序列中分离因果相关场景与非因果干扰场景。</li><li><strong>因果场景分离器（CSS）</strong>：根据视觉-语言因果相关性，将视频片段划分为因果场景（直接影响答案）与非因果场景，并通过对比学习估计场景分离干预的因果效应。</li><li><strong>问题引导的优化器（QGR）</strong>：基于问题语义优化连续视频帧特征，提取更具代表性的时序片段特征，增强前门干预的鲁棒性。</li></ol><p><strong>实验验证</strong>：</p><ul><li>在视频问答任务中，VCSR在NExT-QA和Causal-VidQA等数据集上达到SOTA性能。</li><li>可视化结果表明，CSS模块能有效定位与问题因果相关的关键场景。</li></ul><h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><p>视频问题定位（VideoQG）要求模型在回答问题的同时，定位支持答案的视频片段，需同时完成视频问答（VideoQA）和时序定位（Temporal Grounding）。然而，现有方法存在以下问题：</p><ol><li><strong>虚假跨模态关联</strong>：模型依赖数据中的统计偏差（如语言/视觉短时关联），而非真实的因果视觉证据。</li><li><strong>弱监督挑战</strong>：标注成本高导致缺乏时间定位标注，现有方法在无标注场景下效果受限，泛化性能差。</li><li><strong>模型幻觉</strong>：大规模视觉语言模型（VLMs）易生成与视频内容无关的答案，影响可靠性。</li></ol><p>本文提出了一种名为<strong>跨模态因果关系对齐</strong>（Cross-modal Causal Relation Alignment, CRA）的新型VideoQG框架，以消除虚假相关性，提高问答与视频时间定位之间的因果一致性。CRA包含三个关键组件：</p><ol><li><strong>高斯平滑定位（Gaussian Smoothing Grounding, GSG）</strong>：通过跨模态注意力估计时间间隔，利用自适应高斯滤波器去噪，生成精确的时间定位。作用：抑制时序噪声，提升关键帧定位鲁棒性。</li><li><strong>跨模态对齐（Cross-Modal Alignment, CMA）</strong>：采用双向对比学习（InfoNCE损失），对齐视频片段与QA特征，增强弱监督下的多模态关联。核心：通过正负样本采样，减少对标注数据的依赖。</li><li><strong>显式因果干预（Explicit Causal Intervention, ECI）</strong>：用于多模态去混杂。<ul><li><strong>视觉模态</strong>：通过前门干预（以视频片段为中介）消除视觉混淆因素。</li><li><strong>语言模态</strong>：通过后门干预（基于语义结构图）阻断语言偏差路径。</li><li><strong>技术亮点</strong>：结合因果推理，提升答案与定位的因果一致性。</li></ul></li></ol><p>在两个VideoQG数据集上进行的大量实验证明了我们的CRA在发现基于视觉定位的内容和实现稳健的问题推理方面的优越性。</p><img src="/2025/04/01/cross-modal-causal-relation-alignment-for-vqg/image-20250405145233164.png" alt="image-20250405145233164" style="zoom: 67%;"><img src="/2025/04/01/cross-modal-causal-relation-alignment-for-vqg/image-20250405145435884.png" alt="image-20250405145435884" style="zoom: 80%;"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>论文：<a href="https://arxiv.org/pdf/2503.07635">https://arxiv.org/pdf/2503.07635</a></p><p>代码：<a href="https://github.com/WissingChen/CRA-GQA/tree/main">https://github.com/WissingChen/CRA-GQA/tree/main</a></p><p><a href="https://blog.csdn.net/weixin_46687145/article/details/146458613">Cross-modal Causal Relation Alignment for Video Question Grounding-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/691410252">TPAMI2023-事件级视觉问答的跨模态因果关系推理 - 知乎</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Cross-modal-Causal-Relation-Alignment-for-Video-Question-Grounding&quot;&gt;&lt;a href=&quot;#Cross-modal-Causal-Relation-Alignment-for-Video-Questi</summary>
      
    
    
    
    <category term="论文" scheme="http://wolf-ll.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="视频理解" scheme="http://wolf-ll.github.io/tags/%E8%A7%86%E9%A2%91%E7%90%86%E8%A7%A3/"/>
    
    <category term="多模态" scheme="http://wolf-ll.github.io/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>TRACE: Temporal Grounding Video LLM</title>
    <link href="http://wolf-ll.github.io/2025/03/25/trace-temporal-grounding-video-llm/"/>
    <id>http://wolf-ll.github.io/2025/03/25/trace-temporal-grounding-video-llm/</id>
    <published>2025-03-25T04:49:42.000Z</published>
    <updated>2025-03-26T09:46:53.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TRACE-TEMPORAL-GROUNDING-VIDEO-LLM-VIA-CAUSAL-EVENT-MODELING"><a href="#TRACE-TEMPORAL-GROUNDING-VIDEO-LLM-VIA-CAUSAL-EVENT-MODELING" class="headerlink" title="TRACE: TEMPORAL GROUNDING VIDEO LLM VIA CAUSAL EVENT MODELING"></a>TRACE: TEMPORAL GROUNDING VIDEO LLM VIA CAUSAL EVENT MODELING</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>视频时序定位能力（VTG）是视频理解模型的一项关键能力，在视频浏览、视频编辑等下游任务中发挥了重要作用。为了能够同时处理各种任务，并实现零样本预测，越来越多的研究开始尝试使用视觉大模型完成VTG任务。然而，目前基于视频llm的方法完全<strong>依赖于自然语言生成，缺乏建模视频中固有的清晰结构的能力</strong>，限制了其处理VTG任务的有效性。为了解决这个问题，本文首先正式介绍了因果事件建模框架，该框架将视频LLM输出表示为<strong>事件序列</strong>，并使用<strong>以前的事件、视频输入和文本指令来预测当前事件</strong>。每个事件由三个部分组成：<strong>时间戳、显著性分数和文本caption</strong>。随后，本文提出了一种新颖的<strong>任务交错（task-interleaved）视频大模型TRACE</strong>，在实践中有效地实现了因果事件建模框架。TRACE会处理视觉帧、时间戳、显著分数和文本作为独立的任务，每个任务都使用不同的编码器和解码头。根据因果事件建模框架的公式，<strong>任务标记以交错的顺序排列</strong>。在各种VTG任务和数据集上进行的大量实验表明，与最先进的视频llm相比，TRACE具有优越的性能。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>视频时序定位（VTG）是视频理解模型的一项重要能力，并已成为一系列下游任务的基础，如时刻检索、密集视频字幕、视频亮点检测和视频摘要。虽然非生成模型<strong>在时刻检索和视频亮点检测方面</strong>表现出色，但它们是<strong>不灵活的、特定于任务的，需要大量的微调</strong>以获得最佳性能。为了应对这些挑战，最近的研究采用视频LLM作为通用模型，<strong>将时间戳信息集成到视觉输入中</strong>，并在VTG任务上对它们进行微调，以提高其性能，促进零样本预测。</p><ul><li><p>非生成模型的局限性</p><ul><li><strong>任务特定性：</strong>需为每类任务（如检索、检测）设计独立架构，无法通过自然语言指令灵活切换任务。例：Moment-DETR只能做时刻检索，无法生成描述或回答视频相关问题。</li><li><strong>微调依赖</strong>：迁移到新任务需重新训练模型头部（如分类层、回归层），数据效率低。</li><li><strong>结构僵化</strong>：输入输出形式固定（如时间戳数值、得分），难以扩展至多模态生成任务。</li></ul></li><li><p>融合时间戳信息的mllm：VideoLLaVA、VTimeLLM、Momentor、Efficient Temporal Extrapolation of Multimodal Large Language Models with Temporal Grounding Bridge、Number it: Temporal grounding videos like flipping manga</p></li><li><p>在长视频内容检索的研究领域中，用户常面临时间线导航效率低下的困境。传统的视频检索方法采用逐帧分析的线性处理策略，如同逐帧查字典，效率低下且泛化能力差。而现有的多模态大模型，虽然泛化能力更强，但是效果仍然差强人意。</p></li></ul><p><strong>视频的固有结构带来的挑战：</strong>目前基于视频LLM的方法依赖于纯自然语言的生成。这种方法<strong>缺乏清晰的结构</strong>，并且<strong>不加选择地混合时间戳和文本caption</strong>等信息。（如图1a所示）相比之下，视频具有一种<strong>超越单纯的文本描述</strong>的内在结构。要准确地描述或从视频中进行推理，仅仅依靠自然语言文本是不够的。相反，相应的<strong>时间戳和显著性分数</strong>也是重要的组成部分。这些元素一起提供了对视频内容的更全面和结构化的理解。因此，当前的视频结构与现有视觉大模型之间的差距损害了模型有效建模视频事件的能力，并潜在地造成了视觉大模型难以在VTG任务上取得令人满意地结果。</p><blockquote><p><strong>总结现有方法缺陷</strong>：</p><ul><li>传统非生成模型（如InternVideo）需针对任务微调，缺乏通用性。</li><li>视频LLM（如VideoChat）生成非结构化文本，无法精确建模时间戳和事件依赖。</li></ul></blockquote><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250325143229754.png" alt="image-20250325143229754" style="zoom: 67%;"><p><strong>因果事件建模方案：</strong>在本文中，我们的主要目标是开发一种新的视频LLM方法<strong>来解决LLM的语言建模与视频固有结构之间的不匹配</strong>问题。具体来说，我们专注于解决两个主要挑战：</p><p>（1）开发一个理论框架，从因果语言建模转向基于结构化的事件建模；<br>（2）基于理论框架构建一个实际的视频LLM，以提供一个有效的解决方案。</p><p>为了实现这一点，我们首先引入了<strong>因果事件建模框架</strong>，其中视频LLM输出被表示为事件序列，每个事件序列包含<strong>时间戳、显著分数和文本caption</strong>。根据视频输入、文本指令和前面的事件来预测下一个事件。为了在实践中有效地实现因果事件建模框架，我们提出了一种<strong>新的任务交错视频LLM</strong>，TRACE–通过因果事件建模进行TempoRAl定位（TempoRAl grounding via Causal Event modeling），如图2所示。TRACE将视觉帧、时间戳、显著分数和文本视为单独的任务，为每个任务使用不同的编码器和解码头，任务标记以交错的方式排序。此外，我们还开发了一种自适应的head-switching方法来改进生成。我们在各种VTG任务中的数值结果显示，与最先进的（SOTA）视频LLM相比，TRACE的性能更好。</p><p>关键贡献：</p><ul><li><p>我们通过一系列事件对视频进行建模，并提出了因果事件建模框架来捕捉视频的固有结构。然后，我们提出了一种新的任务交错视频LLM模型，TRACE，通过对时间戳、显著分数和文本标题的顺序编码/解码来实现因果事件建模框架。</p></li><li><p>我们在多个VTG任务和数据集上进行了全面的实验，以验证TRACE的有效性。结果显示，与SOTA视频llm相比，TRACE有了显著的改善。值得注意的是，TRACE在Youcook2（CIDEr和F1分数）上提高了3.1和4.9%，在召回率（IOU = {0.5,0.7}）上提高了6.5%和3.7%，在QVHighlights上mAP和HIT@1上提高了10.3%和9.2%。此外，TRACE获得了与传统的非生成式和特定于任务的方法相当的性能，突出了视频llm在VTG任务中表现出色的潜力。</p></li></ul><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="视频时间定位"><a href="#视频时间定位" class="headerlink" title="视频时间定位"></a>视频时间定位</h3><p>VTG旨在精确地识别给定视频中的事件的时间戳，包含多个子任务如时刻检索、密集视频字幕、视频亮点检测和视频摘要。对于时刻检索、视频摘要和视频亮点检测等任务，传统的方法主要使用大规模的视频-文本预训练。随后，他们通过合并特定于任务的预测头来对预先训练过的模型进行微调。虽然这些方法已经证明了令人满意的结果，<strong>但它们对于预训练是资源密集型的，缺乏零样本能力，每个模型只能处理一个特定的任务，并且通常需要对许多下游任务进行额外的微调。</strong></p><p>对于密集的视频标注任务，Vid2Seq使用特殊的时间token来表示时间戳。一些方法集成了额外的输入信息，例如来自训练数据集的文本查询，<strong>而其他模型则利用不同的解码头并行解码时间戳和文本标题</strong>（Learning grounded vision-language representation for versatile understanding in untrimmed videos.）。然而，这些架构是专门为密集的视频字幕任务而设计的，不能很容易地适应LLM结构来充分利用预先训练好的LLM的能力，也缺乏零样本能力。</p><h3 id="VTG视觉大模型"><a href="#VTG视觉大模型" class="headerlink" title="VTG视觉大模型"></a>VTG视觉大模型</h3><p>LLM已经显示出了在获取知识和使用零样本方法解决现实世界挑战方面的巨大潜力。近期研究聚焦于整合来自其他模态的知识如视觉和音频以增强LLM的能力。在视觉领域，视频大模型已经成为重要的研究课题。<strong>传统的视频LLM在视频问答、推理和视频字幕等任务上取得了显著的性能改进。然而，这些方法在精确定位视频中的事件时间戳方面遇到了困难。</strong></p><p>TimeChat，VTimeLLM和Hawkeye尝试克服这一挑战，通过在VTG任务数据集上微调大模型。近期LITA引入了快-慢视觉token，并将时间token合并到LLM标记器中。Momentor提出了一个时间编码器来解决时间标记量化错误。VTG-LLM<strong>集成了特殊的时间token和时间位置嵌入</strong>，以提高视频llm理解时间戳的能力。但是，这些方法并没有考虑到视频的固有结构，仍然不能达到令人满意的性能。</p><h2 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h2><p>本节目标是开发一种新的视频LLM，它与视频结构保持一致，解决两个问题：（1）如何<strong>建模</strong>与视频结构良好对齐的<strong>结构化</strong>视频LLM<strong>输出</strong>，以及（2）如何<strong>实现</strong>理论模型。我们首先提出因果事件建模框架来解决“如何建模”。然后，我们引入Trace来解决“如何实现”。</p><h3 id="建模视频的固有结构"><a href="#建模视频的固有结构" class="headerlink" title="建模视频的固有结构"></a>建模视频的固有结构</h3><ul><li>根据事件制定视觉大模型的输出：给定<strong>指令I</strong>和<strong>视觉输入F</strong>，将大模型的输出R表示为一组事件序列{e1, e2, … , ek}，每个事件ek = (tk, sk, ck)，包含<strong>时间戳tk，显著性得分sk，文本标题ck</strong>。总的来说，我们有：</li></ul><p>$$<br>R = {e_1, e_2, … , e_k} = {(t_k, s_k, c_k) | 1 ≤ k ≤ K}<br>$$</p><ul><li>因果事件建模框架：为了有效地利用预先训练过的llm的知识，因果事件建模的设计共享了因果语言模型的潜在直觉，如下所示：</li></ul><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250325161352590.png" alt="image-20250325161352590" style="zoom:67%;"><p>下一个事件ek由文本指令、视觉输入和以前的事件决定。</p><p>我们可以发现，因果事件建模框架与视频结构很好地对齐（图1(a)）： (1)时间戳、显著分数和文本标题在每个事件中依次解码；(2)事件按时间戳排序。</p><ol><li><strong>时间戳生成</strong> <ul><li><strong>输入</strong>: 前序事件序列 <em>e</em>1:<em>k</em>−1、文本指令 <em>I</em>、视频帧 <em>F</em>。</li><li><strong>作用</strong>: 确定当前事件在视频中的时间位置。</li><li><strong>模型实现</strong>: 时间解码头根据视频特征和指令，预测事件开始/结束时间。</li></ul></li><li><strong>显著分数生成</strong> <ul><li><strong>新增依赖</strong>: 当前时间戳 <em>tk</em>（事件定位完成后，评估其重要性）。</li><li><strong>作用</strong>: 量化事件的关键性（如高光片段 vs 普通片段）。</li><li><strong>模型实现</strong>: 分数解码头<strong>结合时间位置和上下文</strong>，输出重要性得分。</li></ul></li><li><strong>文本描述生成</strong> <ul><li><strong>新增依赖</strong>: 显著分数 <em>sk</em>（重要性影响描述生成，如重点事件需详细描述）。</li><li><strong>作用</strong>: 生成自然语言描述，内容受时间和重要性约束。</li><li><strong>模型实现</strong>: 文本解码头基于前两步结果，生成连贯的语义描述。</li></ul></li></ol><blockquote><p><strong>因果语言模型（causal language model），是跟掩码语言模型相对的语言模型，跟transformer机制中的decoder很相似，因果语言模型采用了对角掩蔽矩阵，使得每个token只能看到在它之前的token信息，而看不到在它之后的token，模型的训练目标是根据在这之前的token来预测下一个位置的token。</strong>通常是根据概率分布来计算词之间组合的出现概率，因果语言模型根据所有之前的token信息来预测当前时刻token，所以可以很直接地应用到文本生成任务中。可以理解为encoder-decoder的模型结果使用了完整的transformer结构，但是因果语言模型则只用到transformer的decoder结构(同时去掉transformer中间的encoder-decoder attention，因为没有encoder的结构)。</p></blockquote><table><thead><tr><th align="center"><strong>维度</strong></th><th align="center"><strong>传统语言建模</strong></th><th align="center"><strong>因果事件建模</strong></th></tr></thead><tbody><tr><td align="center"><strong>输入单元</strong></td><td align="center">Token序列（词/子词）</td><td align="center">结构化事件单元（时间戳+分数+文本）</td></tr><tr><td align="center"><strong>生成逻辑</strong></td><td align="center">自回归Token预测</td><td align="center">分阶段条件概率链式生成</td></tr><tr><td align="center"><strong>建模重点</strong></td><td align="center">文本语义连贯性</td><td align="center">时间结构+事件重要性+语义一致性</td></tr><tr><td align="center"><strong>输出结构</strong></td><td align="center">线性文本序列</td><td align="center">带时间戳的多模态事件序列</td></tr><tr><td align="center"><strong>依赖关系</strong></td><td align="center">局部上下文窗口</td><td align="center">全局时间约束与跨事件因果依赖</td></tr></tbody></table><h3 id="Trace：任务交错模型"><a href="#Trace：任务交错模型" class="headerlink" title="Trace：任务交错模型"></a>Trace：任务交错模型</h3><p>在上面的式子中，我们引入了一个正式的因果事件建模框架来解决建模结构化视频LLM输出的挑战。本节说明了用于实现因果事件建模框架的Trace模型的设计（图2）。</p><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250325170933807.png" alt="image-20250325170933807" style="zoom: 50%;"><p>如等式2所示、因果事件建模框架需要对视觉帧(F)、文本（I和ck)、时间戳（tk）和分数（sk）进行编码/解码。因此，TRACE将这些元素视为不同的任务，并使用以下设计来有效地管理它们。</p><ul><li><strong>独立的多任务处理。</strong>为每个任务利用单独的编码器和解码头将任务输入转换为任务标记，并解码任务token到输出。 </li><li><strong>任务交错的序列建模。</strong>任务标记根据等式以交错的方式进行排序并输入到LLM骨干。</li><li><strong>自适应头切换机制。</strong>在生成过程中，我们实现了一个自适应的头切换机制来选择适当的解码头来产生下一个token。</li></ul><h4 id="分离多任务处理"><a href="#分离多任务处理" class="headerlink" title="分离多任务处理"></a>分离多任务处理</h4><p>TRACE由四个独特的任务组成：视觉帧、文本、时间戳和分数。关于文本，我们直接利用LLM主干的文本标注器和LLM头（Mistral-7B-v0.2）。此外，我们还添加了一个特殊的标记&lt;sync&gt;，用于指示文本任务的结束。对其他任务的处理的详细介绍如下。</p><p><strong>时间戳和分数处理：</strong>为了处理时间戳和分数信息，我们使用了两个独立的编码器和解码头，它们都共享相同的架构。具体来说，每个编码器都使用包含13个token的分词器进行初始化： 11个数字标记&lt;0&gt;、···、&lt;9&gt;、&lt;.&gt;。用于表示时间戳/分数，<strong>&lt;sep&gt;标记每个时间戳/分数的结束</strong>，&lt;sync&gt;表示当前任务的结束。token embeddings使用LLM token embeddings进行初始化。</p><p>根据<strong>VTG-LLM</strong>的研究，我们将每个时间戳/分数格式化为相同的长度，包括4个整数部分、1个点和1个分数部分。随后，在时间戳/分数之间插入&lt;sep&gt;，并在每个时间戳/分数输入序列的末尾附加&lt;sync&gt;。例如，时间戳输入[10.23,125.37]将被标记化为以下序列：⟨0⟩⟨0⟩⟨1⟩⟨0⟩⟨.⟩⟨2⟩⟨sep⟩⟨0⟩⟨1⟩⟨2⟩⟨5⟩⟨.⟩⟨4⟩⟨sync⟩。分数用 3 位编码（例：[4.5] →&lt;4&gt;&lt;.&gt;&lt;5&gt;&lt;sync&gt;）</p><ul><li>Vtg-llm: Integrating timestamp knowledge into video llms for enhanced video temporal grounding</li></ul><p><strong>视觉帧处理：</strong>给定一个t帧视频，我们首先使用预先训练的CLIP ViT-L对帧进行编码，每一帧被编码为576个视觉token。随后，我们采用了<strong>基于插槽的压缩</strong>（slot-based compression，也是来自VTG-LLM）来将视觉token的数量减少到每帧8个。此外，为了将时间信息集成到视觉输入中，我们使用时间编码器对每个采样帧的时间戳进行编码，并删除sync和sep令牌，从而为每一帧产生6个时间token。最后，我们将8个视觉标记与6个时间标记连接起来，形成每个帧的<strong>视觉输入</strong>。</p><ul><li>该方法的核心是通过<strong>可学习的插槽向量（Slot Vectors）</strong>与输入token进行注意力交互，计算每个插槽对输入token的权重，最终通过加权平均生成压缩后的token。</li><li><strong>输入分割</strong>：将每帧的视觉token（如24x24=576）视为输入序列。</li><li><strong>Slot初始化</strong>：定义K=8个可训练的slot向量Φ_1到Φ_8，每个维度为d（与token维度相同）。</li><li><strong>注意力权重计算</strong>：对于每个slot k，计算其与所有576个token的相似度（通过点积Φ_k^T z_i），然后通过softmax归一化得到权重。</li><li><strong>Slot生成</strong>：每个slot s_k是权重加权的token之和，即s_k = Σ (softmax(Φ_k^T z_i) * z_i)。</li><li><strong>输出压缩后的token</strong>：最终得到8个slot tokens作为该帧的压缩表示。</li></ul><h4 id="任务交错序列建模"><a href="#任务交错序列建模" class="headerlink" title="任务交错序列建模"></a>任务交错序列建模</h4><p>利用处理后的任务标记，遵循式2构建序列。token序列顺序说明在图3中。</p><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250325195619391.png" alt="image-20250325195619391" style="zoom:67%;"><p><strong>事件间序列顺序：</strong>序列以视觉帧标记F开始，然后是文本指令标记I。对于事件部分，事件标记根据事件的发生时间进行排序，以与因果事件建模公式对齐。</p><p><strong>事件内序列顺序：</strong>对于每个事件，标记按时间标记、分数标记、文本标记顺序排列。因果事件建模框架作为一个专门的自回归模型出现，具有一个独特的序列顺序，与视频结构紧密一致。</p><h4 id="使用切换head"><a href="#使用切换head" class="headerlink" title="使用<sync>切换head"></a>使用&lt;sync&gt;切换head</h4><p>由于TRACE在训练过程中对各种任务使用不同的解码头，<strong>因此在生成过程中根据之前解码的标记选择合适的解码头是至关重要的。</strong>&lt;sync&gt;标记促进了这种选择。如图4所示，TRACE按照时间、分数和文本标记的顺序生成token。sync标记的检测会提示TRACE相应地切换解码头。头部按时间头、分数头、文本头的顺序循环切换。</p><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250325202808506.png" alt="image-20250325202808506" style="zoom:67%;"><h3 id="训练策略"><a href="#训练策略" class="headerlink" title="训练策略"></a>训练策略</h3><p>本节概述了TRACE训练过程，其中包括两个阶段。对于阶段1，任务模块，如视觉压缩层、任务编码器和任务头被训练以初始化。对于阶段2，LLM主干被微调，同时保持任务模块调优。详细的设置和数据集如下所示。</p><p>模型 backbone 基于 Mistral-7B 架构，分两阶段训练：</p><ol><li>第一阶段：<strong>任务模块的初始化。</strong>训练视觉压缩模块 + 任务头（时间、分数、文本头）（每个视频抽取128 帧，学习率 1e-3），冻结视觉编码器和大模型主干。</li><li>第二阶段：<strong>指令微调用于增强VTG能力。</strong>LLM主干和任务模块进行了微调，只有视觉编码器保持固定。对于每个视频，划分为128个clip，每个clip随机抽取1帧，学习率 5e-6。</li></ol><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250325211532532.png" alt="image-20250325211532532" style="zoom:67%;"><p>阶段一用到的数据集：（1）图像和视频caption数据集，用于初始化视觉压缩层的数据集。这组数据集包括Valley、LLaVA_Image、TextVR，以及随机采样的ShareGPT4Video数据集子集。（2）用于任务编码器/头初始化的VTG数据集。我们在这一组中使用了VTG-IT数据集。</p><p>阶段二用到的数据集：（1）VTG指令调优数据集：VTG-IT、ActivityNet Captions、InternVid的子集，得到一组635k的样本。过滤掉低质量的样本，并对VTG-IT-VHD和VTG-IT-VS数据集进行重新注释。（2）视频caption数据集，以保持视觉压缩层的质量。使用了来自第一阶段的部分视频数据，如Valley、TextVR、ShareGPT4Video。这些数据集通过只保留具有相同视频但有不同指令的样本的一个样本来进行压缩，产生284K数据。（3）视频问答数据集，以增强TRACE的推理能力。这一部分使用了VideoChatGPT和NextQA。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h3><p>我们评估了模型在三个不同的任务上的性能：</p><ul><li><p><strong>密集视频caption：</strong>我们使用Youcook2和ActivityNet caption数据集作为评估数据集。评估指标包括CIDEr、METEOR和SODA_c，用于评估caption的质量。这些指标在不同的IoU阈值{0 .3、0.5、0.7、0.9}下取平均值。此外，我们报告f1分数来衡量模型准确定位时间戳的能力。</p></li><li><p><strong>时刻检索：</strong>我们利用Charades-STA测试集进行时刻检索任务，并报告在IOU阈值为0.5和0.7时的召回率。此外，我们还给出了mIOU的结果。</p></li><li><p><strong>视频亮点检测：</strong>我们使用QVHighlight数据集的验证集，报告IOU阈值为0.5和0.75的平均精度（mAP），以及代表得分最高剪辑的HIT@1的命中率。</p></li></ul><table><thead><tr><th align="center"><strong>任务类型</strong></th><th align="center"><strong>评估指标</strong></th></tr></thead><tbody><tr><td align="center"><strong>密集视频描述</strong></td><td align="center">- <strong>CIDEr</strong>：基于n-gram的生成文本与参考描述的语义相似度 - <strong>SODA_c</strong>：故事级时序对齐与内容匹配度 - <strong>F1 Score</strong>：预测时间戳与真实区间的重叠精度</td></tr><tr><td align="center"><strong>时刻检索</strong></td><td align="center">- **R@1 (IoU=0.5/0.7)**：IoU阈值下检索到的正确时刻的召回率</td></tr><tr><td align="center"><strong>视频高光检测</strong></td><td align="center">- <strong>mAP</strong>：平均精度（IoU=0.5/0.75） - <strong>HIT@1</strong>：预测最高分片段是否为真实高光</td></tr></tbody></table><table><thead><tr><th align="center"><strong>数据集</strong></th><th align="center"><strong>任务类型</strong></th><th align="center"><strong>数据规模</strong></th><th align="center"><strong>评估目标</strong></th></tr></thead><tbody><tr><td align="center"><strong>YouCook2</strong></td><td align="center">密集视频描述</td><td align="center">2,000+视频片段</td><td align="center">生成带时间戳的多段视频描述，评估描述质量与时间定位精度</td></tr><tr><td align="center"><strong>Charades-STA</strong></td><td align="center">时刻检索</td><td align="center">6,672个视频-文本对</td><td align="center">根据文本查询定位视频中的事件起止时间点</td></tr><tr><td align="center"><strong>QVHighlights</strong></td><td align="center">视频高光检测</td><td align="center">10,000+视频片段</td><td align="center">预测视频中与文本查询相关的高光片段及显著性评分曲线</td></tr></tbody></table><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>对于一般的任务，如视频字幕、图像字幕和视频QA，数据的回答部分不包括时间戳或分数。因此，使用单个令牌&lt;sync&gt;作为时间戳和分数的占位符，表示这部分响应的空响应。</p><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250326020259042.png" alt="image-20250326020259042" style="zoom:50%;"><p>密集视频字幕任务：密集的视频字幕任务仅包括时间戳和文本字幕响应。因此，我们使用单个&lt;sync&gt;作为分数的占位符。</p><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250326150010871.png" alt="image-20250326150010871" style="zoom:67%;"><p>时刻检索任务：</p><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250326150059685.png" alt="image-20250326150059685" style="zoom:67%;"><p>视频亮点检测任务：</p><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250326150511688.png" alt="image-20250326150511688" style="zoom:67%;"><p>视频摘要：</p><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250326150613441.png" alt="image-20250326150613441" style="zoom:67%;"><h3 id="Trace性能"><a href="#Trace性能" class="headerlink" title="Trace性能"></a>Trace性能</h3><p>优于其他视频LLM的零样本性能。在表2中，我们展示了TRACE与SOTA视频LLM基线相比的零样本性能。</p><ul><li>在CIDEr和F1评分上实现了3.1%和4.9%的性能改进；召回率上6.5%和3.7%的性能提升；mAP 和 HIT@1 指标有10.3% 和 9.2%的性能提升。</li><li>比特定于任务的模型和更大的llm具有更好的性能。作为一种能够处理各种任务的多面手模型，TRACE的性能超过了HawkEye等特定任务的模型</li></ul><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250325234801792.png" alt="image-20250325234801792" style="zoom:67%;"><p>TRACE在ActivityNet Caption数据集上的性能。在表4中，我们展示了TRACE在ActivityNet Caption数据集上的性能。除Momentor外，所有报告的算法都已将ActivityNet Caption数据集作为训练数据的一部分。结果表明，TRACE在时刻检索任务中获得了最好的性能，并在密集视频字幕任务中显示了与VTimeLLM相当的结果。</p><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250326134337514.png" alt="image-20250326134337514" style="zoom:67%;"><h3 id="消融研究"><a href="#消融研究" class="headerlink" title="消融研究"></a>消融研究</h3><ul><li><p>因果事件建模框架提高了VTG任务中的模型性能。在表3的“框架消融研究”部分，我们在没有使用因果事件建模框架的情况下进行了实验。结果表明，采用因果事件建模框架可以显著提高模型的性能，即使采样的视频帧较少，也能获得更好的效果。</p></li><li><p>对不同的任务使用不同的编码器和解码头是获得最佳效果的必要条件。在表3的“w/o独立编码器/头”部分中，我们通过对不同的任务不使用单独的编码器和解码器头来进行消融研究。直接将时间标记和分数标记合并到文本标记化器中。结果表明，<strong>使用共享的编码器/解码头进行因果事件建模框架，显著破坏了llm的预学习知识，导致不相关和无意义的反应。</strong></p></li><li><p>TRACE的性能随着帧数的增加而提高。我们对采样帧的数量进行了消融研究，如表3所示。结果表明：(1)性能随着采样帧数的增加而增强；(2)仅采样8帧时，TRACE的性能优于VTG-LLM和TimeChat等SOTA视频llm，甚至更好，证明了模型结构的有效性</p></li></ul><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250326011535050.png" alt="image-20250326011535050" style="zoom: 67%;"><p>结合InternVid和ActivityNet Captions数据集能够提高TRACE在长视频上的性能。我们通过专门使用VTG-IT作为VTG任务的训练数据来进行消融研究。结果表明，在合并InternVid和ActivityNet Captions数据集时，长视频的性能有所提高，导致Youcook2、QVHighlight和ActivityNet数据集的性能有所提高。相反，在短视频上的性能略有下降（Charades-STA），这表明InternVid和ActivityNet数据集中的注释可能不如短视频注释中的准确。</p><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250326012022583.png" alt="image-20250326012022583" style="zoom:67%;"><h3 id="微调性能"><a href="#微调性能" class="headerlink" title="微调性能"></a>微调性能</h3><p>微调后的TRACE与传统方法的性能比较。</p><ul><li>TRACE的表现显著优于通用基线。TimeChat和VTG-LLM即使在微调后也难以获得令人满意的性能，TRACE从微调中获得显著的好处，并获得明显比通用基线更好的性能。</li><li>TRACE获得了与非生成的任务特定的SOTA模型相当的性能。TRACE在Youcook2获得了新SOTA，在charades-sta数据集上的性能也与非生成模型如InternVideo和VDI等竞争。然而，这些方法不能同时处理各种任务，而且缺乏零样本能力——这是本文TRACE踪的贡献。</li></ul><img src="/2025/03/25/trace-temporal-grounding-video-llm/image-20250326014515350.png" alt="image-20250326014515350" style="zoom:67%;"><h2 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h2><p>本节深入探讨本文提出的因果建模方法，并对以下三个核心概念进行系统性对比与讨论：</p><ol><li><strong>因果语言建模（Causal Language Modeling）</strong><br>因果语言建模是仅解码器架构的大型语言模型（LLMs）的经典范式，已成为当前视频LLMs的基础方法。其核心是通过自回归预测下一个词的概率，建模文本序列的生成过程。</li><li><strong>因果事件建模（Causal Event Modeling）</strong><br>与上述方法不同，本文提出的TRACE框架引入<strong>因果事件建模</strong>。该方法通过事件三元组（event triplets）结构化视频LLMs的响应，为理解视频内容提供新范式。事件三元组可显式表征事件间的因果链，例如“动作A导致状态B，状态B触发事件C”，从而增强模型对视频逻辑的推理能力。</li><li><strong>完全因果关系建模/发现（Complete Causal Relationship Modeling/Discovery）</strong><br>传统视频理解模型侧重于发现与分析视频事件间的复杂关系（如时序依赖、因果链、多事件交互）。这类方法<strong>通过全面建模事件关联性，提供对视频内容更深层次的全局理解。</strong>例如，通过时空图网络建模人物交互，或利用注意力机制捕捉跨帧依赖关系。</li></ol><p>相似之处：因果语言建模和因果事件建模都依赖于仅使用解码器的LLM，它使用视频视觉内容(F)和指令(I)作为输入。然后，这些模型根据I和f的观察结果产生响应。</p><p>区别：输出格式。对于因果语言建模，响应可以看作是一个完整的文本内容，在这里，时间戳、分数和文本都由文本标记表示，并按照自然语言结构进行排序。对于因果事件建模，响应被格式化为一系列的事件三元组。</p><p><strong>关键改进：</strong>我们可以发现，因果事件建模比因果语言建模的关键改进来自于<strong>模型响应的格式。</strong></p><ul><li><p>事件间的关系通过下一个事件预测公式进行建模。</p></li><li><p>事件内的关系，探讨因果关联  ti-&gt;si  和  (ti,si)-&gt;ci。</p></li><li><p><strong>启用独立的时间戳、分数和文本建模。</strong>可以分离时间戳ti、分数si和文本ci的建模，并使用不同的编码器和解码器独立地建模每个组件。由于直接向文本标记器中添加新的标记可能会显著破坏预训练的LLM，这种分解有助于消除这个问题，并且TRACE体系结构保留了处理一般视频理解任务的能力。</p></li></ul><p><strong>通过因果发现模型改进TRACE的潜在方向</strong></p><p>当前视频LLM直接从文本指令和视觉帧生成答案，未显式建模事件间因果关系。<strong>尽管TRACE通过事件三元组（时间戳、分数、文本）改善了这一问题，但其生成仍受限于解码器架构（仅依赖历史事件生成后续三元组）。</strong>未来可通过以下方式结合因果发现模型实现改进：</p><ol><li><strong>将因果发现模型的输出作为视频LLM的输入</strong><ul><li><strong>方法</strong>：将因果图（如Chen et al., 2024c; Li et al., 2020生成的因果图）编码为模型输入。</li><li>原始生成概率：<em>p</em>(<em>R</em>∣<em>F</em>,<em>I</em>)</li><li>改进后概率：<em>p</em>(<em>R</em>∣<em>F</em>,<em>I</em>,<em>C</em>)（其中<em>C</em>为因果图）</li><li><strong>优势</strong>：为模型提供更丰富的上下文，提升回答准确性。</li></ul></li><li><strong>利用因果发现模型构建链式思维（Chain-of-Thought）示例</strong><ul><li><strong>方法</strong>：引导视频LLM先生成因果图，再基于因果图回答问题（类似Jin et al., 2022）。</li><li>联合概率分解：<em>p</em>(<em>C</em>,<em>R</em>∣<em>F</em>,<em>I</em>)=<em>p</em>(<em>C</em>∣<em>F</em>,<em>I</em>)<em>p</em>(<em>R</em>∣<em>C</em>,<em>F</em>,<em>I</em>)</li><li><strong>优势</strong>：显式分离因果推理与答案生成步骤，增强可解释性。</li></ul></li><li><strong>利用因果发现模型修改视觉输入的注意力掩码</strong><ul><li><strong>现状</strong>：现有模型对视觉输入的注意力掩码设计与文本相同，未考虑因果依赖。</li><li><strong>改进方向</strong>：根据因果图调整视觉特征的重要性权重（如抑制无关帧的注意力）。</li><li><strong>价值</strong>：聚焦关键因果事件，减少噪声干扰。</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文旨在解决视频时序定位（VTG）任务中视频结构与视频大语言模型（LLMs）之间的不匹配问题，并提出一种因果事件建模框架及TRACE模型作为解决方案。实验结果表明，TRACE在零样本学习场景下显著优于其他视频LLM基线模型；经过微调后，TRACE相较于传统非生成式及任务专用模型亦展现出竞争力。通过突破现有视频LLM架构的固有局限，TRACE验证了视频LLMs在VTG任务中的潜力，并有望成为未来视频LLMs研究的基石。</p><p><strong>未来研究方向</strong><br>尽管TRACE已取得显著进展，其能力仍可通过以下方向进一步扩展：</p><p><strong>复杂事件关系的建模</strong>：TRACE当前依赖预训练的仅解码器LLMs架构，<strong>仅利用历史事件预测下一事件</strong>，这可能无法充分捕捉复杂的事件关系。改进方案可引入因果发现模型的输出作为补充输入，以增强对视频内容的全局理解。</p><p><strong>多任务标注扩展</strong>：通过融合问答对的时序戳（occurrence timestamps）及问题-答案匹配分数（matching score）至更多视频理解任务的标注中，可显著提升TRACE的整体性能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>论文地址：<a href="https://arxiv.org/pdf/2410.05643">2410.05643</a></p><p>Github：<a href="https://link.zhihu.com/?target=https://github.com/gyxxyg/TRACE">https://github.com/gyxxyg/TRACE</a></p><p><a href="https://zhuanlan.zhihu.com/p/464546351">文本生成系列之因果语言模型 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/30568807976">TRACE：因果事件建模助力视频理解大模型的时间定位能力 - 知乎</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TRACE-TEMPORAL-GROUNDING-VIDEO-LLM-VIA-CAUSAL-EVENT-MODELING&quot;&gt;&lt;a href=&quot;#TRACE-TEMPORAL-GROUNDING-VIDEO-LLM-VIA-CAUSAL-EVENT-MODELING</summary>
      
    
    
    
    <category term="论文" scheme="http://wolf-ll.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="MLLM" scheme="http://wolf-ll.github.io/tags/MLLM/"/>
    
    <category term="视频理解" scheme="http://wolf-ll.github.io/tags/%E8%A7%86%E9%A2%91%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>思路整理</title>
    <link href="http://wolf-ll.github.io/2025/03/08/java-ti-mu-jing-jian/"/>
    <id>http://wolf-ll.github.io/2025/03/08/java-ti-mu-jing-jian/</id>
    <published>2025-03-08T07:39:11.000Z</published>
    <updated>2025-03-15T10:45:33.908Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c8dafcb9886ff53f260648d03a713b4649ca2dec73f2781fe6be88d9ff326893">e5e963fdc9daf54d686e4a098ee1ff75389b5e1b07cf2bef315bf3df422a2bd0687b84da758f553f858dd8273236b6a12e34447723d2f850e9e0001085db18a3ce209614ece04825c3243ceb04ad05a6781c46e27f4c2cfdff264fbf9a9b072bf484448aaf19a1a1562311703254fcfc28d124d7a7caa6ca916dc297f7dd7d3eead948e92234c5ded2c6478354b79bed274b229ac852682b2905a1685dc8f06639f05b9dde049267b55054af88971feba67ba9c2cd1ab95e315aa601bc78648fb78f6dfb79e1913d3991a4e9702f5761be0046e78053e62ed38e2be37de9314eb6854c444a6fa7e5c5852fb55f6bf22d2c6e54b55e54f7aec8456e078db525733023c7d4e9a42bfcc8c6e4e81002060a7323b7e8bdb2d33e2f1de8f9de57f4f42a0c6d058b81ef55150b7128fc36356e0ffed0def115da1cd15671e03a0fab8da8ef3427d10cc072e410320d5ed50961059da23984417ae90d711e5228c6d7d0539794f6b2309df77cdd1b99abaa154cff2254c2a14f5b9475161aa9ccebd087024f55b450d30914ca45580c0d39976dda3e1db0a99424b08fc441ca3ff7335f4a6d5968549c2ea16c733d65b5935ebaefc93e208c48bd990156d994314480c9c0abf4e04c5dff19944a264e19f48337e6f548502fcb51ef5f97380c6f378aabe4df642b89aa83a08e33890a3a859766d603c61fafcbc78667aaa4ad7223bd449dcf025cdead72ef4846e29cf1d20227d0533441f82903403625cce3189a54b65b02668ac9c96b07033877566284c0b390eb224b13fea9c49e2730e776ffe041ab247157c750cfec696a70581201db9f7b57273be5e1206860857d4fbf597d4066c5feba5a3f65899cc197ac9267dcaea758c549e0026ab650d1d712bc2d62c0fae1bc017475af2ebd1090377ca1d4c542fbc2fc5e544e8d1b879bdf644de9084915e57e5cf7f2bd60d0d1d2ee27b91db4351c9308edc3b40e8660942095aa7a25e9569f06d4cd22c6113520832b49ffaa031902826e02132ddf6ad8c1e1aa0a391f8f347e23d17563ce14cc1d4a7841cde122e54e46424ab4560b03ba02510c001f8e339291ba814d320fb0f066eb6456cae1b46c4dd087df3fadfc426595295ec1023f4db83dcc8b1f1bb865ca8d095e7a2669dbdbd00f7770e48d3abc255e993879dc81b3c7e726ac5cb060f4ad129c02859c900a890883659d68b8a701fd9189c60fbc9dd48b7493df7bbbb954e9e3172226c48ae3f68de0b0d8f6e1016de96db178842ab7d91c41e7c1d9fd8770ba7370dc710b5fb01b19166dac9b18a13c8f57c8c3d8d81c59b145f3b6d6ccf0b48c0f7b5cae2cdb4f4c6df00c6e15ea66c1dae3cb337f1de102f706a530a37ea7a7d0adf20d57b9847421504d53f65880d91ce1258a2fddd95688028c00d1e4e46670c7d2695484750ea0a5eff9a82bede6308db4676bdfbcf9f821ceeabea3e8e11729261eb703d57799a3ca56261f1fc4c472ac8a66a229352ecfc7897e5cd46641f60165504006752914eb226d86ed5184272530a0aabca9b1b09fa451c56d29b70dda2a1fc72071bf8451fc739322875b144a992c99d691319a1a5484193096087dc7eb43a1a0266796aeb0cddf37f3f0bc5ce8a7420104f1377990a6869923fcfa36994a2fea07daf52071f30db1d0c05b561d6fa194f472fcded1adf98483d8ac4e3d630d6d63bacb19ba0df18015c18ba0eadc67fe4930cd7cc69b42d335a1da4aa1aa7c1b4b3f944b783fdf436fbf88f365cccd134a0f6709f1d7147938f9294f3da82ec49f1c5c168b691bca0ad7df0e0cca27fe95ee811f13b1147612669faa2911ebc3aa919983558f777f797f811a9f125c6f4f57695df73c85273701ccf39a28c7dc15cd102cbf08557f79e69709c7130e5865e65f75aa69af8a54f0f3de432f03d7a25f019433b0bd3ef42d73414154dbe4ad334adaf797415e3721af238b50a3b4d735ac7751c750673f81174caa1c63230b96ed08fb292f32fa4b25a21b625769da6b0225358db0a89be118909dcf12315a878eef6c67725768a3d87f9feff2232457e52090c52adaba55ac33f8e5d13674f49625b0d7cc6b51b8c8126670aec4d1070950697a7af120a196511cfdc17247d82556e1f861799d5a49281d4638c82ee87c1f38e2a0189997758107e85c716657dc8fb4b58b4b0f56d9aee9e31f2c995f4a0c1eaf5c6482a6cb69f75216a579d347550365a62f6a543a7ed511564b97285fe8b3500add05158fc0607dc7ff2af4680b852487602ab33a934a98dff9ad0ed38c97758888db089af7e88613f6dee17e02b7bff743341956b2d2d48bad360478ddd8826ffb79a5ea2b93343547300ab9a34d5d0b3d787dec095a0eaea8f62b8136405ea5d7dff991af0d506aa515713a6d68e0ef6ea979caae3402b438c87e5985a6adcf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="后端" scheme="http://wolf-ll.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://wolf-ll.github.io/tags/Java/"/>
    
    <category term="项目" scheme="http://wolf-ll.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>项目记录</title>
    <link href="http://wolf-ll.github.io/2025/03/08/xiang-mu-ji-lu/"/>
    <id>http://wolf-ll.github.io/2025/03/08/xiang-mu-ji-lu/</id>
    <published>2025-03-08T01:59:33.000Z</published>
    <updated>2025-09-15T06:55:00.089Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="359018018ac4d5ca113fccc24ad56d599f0cce02b7884751cf497548485c8c6e">e5e963fdc9daf54d686e4a098ee1ff75389b5e1b07cf2bef315bf3df422a2bd0fc830aea3267ddff370848028e638cd0cc8a5b93e53c054afe392e6fc035b81ecb8d06955d75b64f2316e05737625b3a362824a6a241e0d999530f65d7d300144a902f94fe5908b8a5e54165b1d7a230feab21212510e01d715a356a2f151e96ebb5a3f2448f1395e72988531c84d96af7b08e045b73abf074f0c5d8daaf1ed353c2b42667e8a92b75ceb3a5b9a5375ba43109015f85194f4f42e7b19e91fa0261a858dce1cb6956d99bec16c99da519559cb195ad6f91779ba6a017f0f360e5fed06ff9ad7452b8f37b6be51b6120bb3290c6ee9dd1794be748c758f1e569b4ac97bd20ac5b8e2a1247e008c49fa3469b6a274ba877f928948d922ff535c634aa495c7775f27923dc3d25a92d23ba658907d02dc62f16a9cad56399e30a23930c74e3b90c7b57f03c4638da6f748f2fdeef73af8fed030436835fe2f69c01b78def021d356e91b78d66b2fb7d05c9a17dc0cb05a75e9ad801a83751f58ccaecb4f79837066538693b4984a8a0ebb3bfb7a0000dab0c02eb5e3f7783120f0668f34724ab2ddff17fffe869a5154784ad4ddda425294cbfb344586408c261749d13d5a2fe01509a453cdfeaaa18f45b0cbc394588de87f4ee351b0fd6ca0be0a005714177f02803e72fdb25a470c15dab0b1d3f999efe55a28734c46752131d0a3cef289d1bd63559656a6f236172593fb5cf4a80c0e9d704d20c8c5464f26960b89382800c769e9f648f5e9746f6142ceb68b70dc535343813c5960d2beb64a87502c0091f68b70a505120058de8f484ee17b2e14ea3fc83b3d723606ea6485488515125e88d98e452feb02eb678c31065ddc82269357c37cabfe6ed38b4aada988859526b4aad6379b0bf297080f474765c6731742c7f654ff9362634d02705ee55a9028c4e1b4812fa84dc1280239c727d226b3b855ae05130f9195fe7a99f97affd175bc916115fed8b887bdcd5efece6e3cd9e4468294579d4ba1c56636802379533ba6bddbe4e5fc1b1f4f652b13821b0c22c341181b399c499b8d77ec684a9dea42bf65ce48f4bae7ef061fcdf6717039e8e30d972160c7841004501fbd40ecb5553ca5c5b22b1fa4b7f49d8178d7115b900425938dbf837307b71019e2baac16b027398c57edd3f9569311908c278daf6096eb4200117283e7dffa03d077788a2255d8f106a22bc9e4d104de65524661076e2d7b3aa9d9c5eeb0066ad9a48784cd0bb8c82a0539cf344a16a9807e154b10b825ad7eec93372aa1c73fcb6eca88e32e84b65b80325accc795cc45165f0132d8123db86bd883364059f0604a1bfd4d5755e89934a364360401d15a19498a93f42fb42242dfad47921e31200ab84bacdd4f74f010a4597785068c70a3cfd0025104150b9ce336b199bd7b455f9a6487e7966ca947d8359d9974ed70cda032867dbc0545ead28305972bdef8ca9f9990f52567a92d341f70f8813262dda358cda75187bb14f1d1906c6c97c42e517a8904fb13d7d45400ec044ebb4ea9f4a38609cc906ae8028640092602de303c3808926f1576d1fda35259ce16103f532b84fde61af6e3f54f80659ebc2e5f1386fd89efed218fcdf99bd97a37186af7b4475154458b46edff90633782f22904153651b381ccadc5bf908cb1c71a9f14808667a2acf57607dfafadc83830378dabd710ab8d3a4858fbeb6ba7cb0f9db93c53a7118731eae5d52cdc864329732d17abb3e5eabe1256d8c8da30bdf61a463db9e4a0f7c63a2c9af93ff023864292481134a2d96df5f14f0e6569e783c0a11034072de078dcff3010c03bda8d5cc7609b10cb546c85cc35279f60c64a458f9da55880e514a16fc3bcf0218a1286fa4b2cd847fa6676cc27af4708b6e19b655fea10ada8e14207dd303f83bb0f9be9751bd9aedced830e3bde6ff2327e1e6fe9512a374cc681efaef351a70a82492b66ef520facaefe684ed2bbcc0238f42ad50888b46057068490ceebbd1b370cd9ae4cb24764e1d0a0c8ff7299b98ff89fdc416ba7e2b4b5232839f1673ba81ea413b21b2cddfa01ff63971d70a9fac843671d4ae69a4e3e81303fed348866c077c053ca345cadca5568a5b06f0fff7ca9bd6f2f2c70cd744935cb533dd15689739ce6786e24a1aaab23c2f2efecb27a5a03504d367d5a03a49919916e9e6144fe7f5afa1298590d3a18c2ea8a525d6d08458e23fcfde232cd76bd2dd361be351c23835b8951d998fc40e1739b0847460e86f29756f677a7496b1eb1689cfab96585d34e51cdae83c57e1c6e2b1c80dfea99c21f190d36a6ff19f946abb3c10c5fc5575fcedac6f1a438e288be8e35ec54348fcbcde5fb9e7b364492c2fa5834e65a9831b74bd2c1d84670c7797887a34d64c2c0efdc7680b0f5f2a6b6ffafe61df56a16afba79f99a90f5c17bf77b71f0ff1f236a7df6ec84f897a060489f3db127b4499cdca41fabffb7f49ce875ea60e62fec43294b3e2d1dd3beebc40d09391d77bf2559567d6387b5bbff07dd36f1cb2fe1a772d96d998bbcb9067a0072f5b15d994e296479f20e52f18f6fa6c842f6529e1b63f5e669e481853d43dca6587540b41f16333c215e3f2606e5394509f4ec9b4ecbaf7858a454e9d10e44cdaa5d3765408a107b07ad5ed63169e30a13d594054f3451e5fe3ccff2e91c6f68b579ffb0abcb8d15dadf14fdba53101eccf8ad6eabb6b2665125f61ddfc31e151741ca845ecd5f042685a181085f6124af5a4af75cc19edb80219791a8c4cb2cae0ff6996f89ace86b111141434a778b3040cc2ee7b5524852ff1ea99e7bd761c980ea7dcc8fb71c2c7167eb507e8755cd734bc9bcb2d160446421ad4b939faf8e13c105ca121f94c1e28728a3438f03a19a804750f4c0c53c4f45b382cd162bc1828f4c0aedcbb8ad1d1d2818bbc3ac1c5178056d0bf8e490aef825db2b6d31a885d9cb27792ea4c2cfc1b1b618078e88d011f315456b44e27093b0792c0ebf08630375bec7987a49198062683ba34dd9ed5a333d6111b25dd2241b0b4fa05be3dcdff35698976bbd3fe436a5a11e8e8ec317875de154f1255b06f319788ada0052b67171df9fe7837a8e64a6870b3b3740a9441ff9b9d80739ba2016c2c3d67cafcbbb8cb8b195d5bdf47041217edc7606b9a3291c346dbad6c3b0fcffb1f054193a9b8da7c04d319d776a84665455df22806e1bf53ef92c8942b09887b3c5c0e24c0075886a9ac89df014bde63ca678301528878d88ec569f3baf8153bf95147a59907b03db414a9b7392faa08cac370a3e7dabdd059abc9be564c58dd889b6025ed34c5863a9a1266cc075f0a99ca634fac6925ed7ee883234b49ed1bdd84e9fc01dc118e8d918bfa0008f4ed3cbeccdf3268589832834d068fc964109a284fc2546ae75a541c4af1ee70a55cc23e3bdefd396b1190bb9a9b86d9117eaf7fc6ce1bed2a1dbd75ce44573707574d6ef7c91d36d52d2b6b5fcfb37c3dba52261e59b19e4867e2512881b37a3628ac884a86cad0694548557528113125ee434afa5477c4003c4fa98979e601bad3a1e8fe58a48d88f111829be1025213a66c2e633fff901fa6c6ca38091714f9f61b49a48c9a3cb69b8b582a42ce0baabbbcffcb6d52b579ce23349bfecb498d4b3abccfc210ff761ec071e6448ce9185a86405acdcb9969fdaa2faa92d55367d55ac30ae2051809fcde2ee7a0c79f1c31561c16962a1bf5a26d5989973737ad558bba5b8312e18582107c68deb96aa6b273c426a23ac19c485582a5b193601c44a2bd2b6fba04dfbfb986ff9e73055f0a431aea42a1ed79113581ac58b4728e0fff1c310537c6b50611e683dac55b8ad4b40ce5c3150959261d03c2d86cb18943087a6e87b93d63f43726112b6256d622d1fe27860207eb234dc4a2a9fc2a6bf2b5a4146f18b92c77b41347e1e35b7b9db6bca379bac3d700a5d1bfd0d398477d7b1c67673396775a1b63f94ada2ce5ea968a5f3cae5df8f91e60097434557e61cee4b8de73ce420f06c4002bbc7dac58c37866c0bfd4af0c30d94f290fc58f0ec63d51c5b6e5c6d6bf76dc893622c6de160a359da093623a654609d3cd61ae8fab3ece8ed6f455d4ddc8636bd5860f45d9ffab4753e6cb31b4f1e608b4c52373dc3a927a9e06fe9f1f10df033a2fcf27e3ac051d2e62703bfae24fc27977d3c280c540ac6197bd189caf39dc3c66b3ac25c95e5110035e649b22fe59a769d25a987a7f9dd7fa6a2fa497a419d03c5ac9bcd96aeaed5ee3026155f7c23a1c9baba171d19d7b52ddb86d13de5219cf16013c2dbd00567e6224667dfb8cf50b6634205a5af98aec6386ae07af20da61da7b52c3ffb440afcac2581218618f2d74e5148635482a0efb2a9c1524f6e7e0c63b3e2ae54787f95dc92ad17f57343d4a06f93bdf67aab4d3edc6bcaa5dd29d74b705a34eca2565c85bd9eafbfe87c4b7bec8ae286964c971df5cb872a2c9d77f53756764a353874dd7a327e907d79d30aad778e18a1084ceb3982e0b28d09829fa07e76bbb20c4a5f00467232aaf14000c3a9df27b3576d48f31636e0a4cf789688faddee2c1d07358c7c8c07b8b0f971a7040cb612ac845fc4b6d45dba7fd22555f2bb8579a0255c42c52a3405424e96c3101e72ec2e545696670bc7ed4fe6ed3d6f569bdfa0b0bcb5cf967b817d6907e333373cbfb84aeeb2e19d578242084d856d797d7e07d391ff0b2426819bb650a4d2e4707171a172d49a24489fb0cdc84680b842b37f2135b7a9becfcbc03bb083711197d9288fa4b808e68cc172bde4212a241d7c769fdb6dc9e28292a9cf3452ffddb42ca2c5154f9f13cdcf77e2da73e958d1d8da21ef75b8ed758ff4ce086ace66f4d394c89af4c7fd2ca52dae14cd75756c991710247f0ec78795a624c98b277ce9bfecfba67b689f73f203248180ab877d89af65f566692eaf0fd7b40278e97438bfcf091870ac005f8c32d591e68cdbcb588d00b8d4a91fb234e2eaf85018d2e0f42109edf767825a874fb7a97dd8a72d2f1cb79cb2e6dae85b282b30876e00b92edd3e138045b58cd4628959fe214fd496263e39060c032a83ace3e1f203dd4ca03eba90f1c8f29c357c3b53e827769ff3346bd69379e2982af15bca3c0c27b08e12ee3c93e46238487ffa5caff991616b6788b2c77226ddfde8b2ec47815da9e27936bdd55147c249b13378da11cbeb90654adfe2f399801a7e409d9c9a64a3659c396426e32d1229f5ddf717e8a3a9ab05fa41ded07f0634f80f6476a15ec9025acd2284c8a93013a77061666621202fbb7d0de71a186a42de7df12f167f92af0c3cdcea3305932888dea444b15d08b8318a9898408c458f99ceb57115b023b3588303304e51505cc795bb2aa91afbd5e2924609303530e321e9166c7ad6dc42449bc3f1bd67e09c5eccf00cae966377cea48349834aeb1f6fededdcdda6fc1fe4a4d0986f71a5abf7485d59749e89bd04e950d8160b6e7aaf7335ee96f165f64059f3bd2b2208257c104d0a7b5bd63e9a2c251bfc12d74e702ff18908e8df495501b510cc7084d0a5d448655f6ffe32e0ab92345785b67ea68dd776edd17abc3d2b9fd779c2cab4c17ba08d68daff1ba576839bf2641a7ba6e63efcfa5e6ed28935f97d349df8235182b0bbd331ff4211513024741932123e60191d67e547ed665a52416f1ecf7deac82044f368bb30144abb4fcda7fe44f27b233c7a7a2af5d9eea658d8716c7f364e596546ee27d9ccc95c1ab0dd2a5b7b898983e9bee62f3d644499b88811176d4666797e82045d451b464d9cb69de623eed56f1dd3545679d891292dbca073b46c8d0779e5f0b831ca4df88cadb9c305b80416f8338048cdba39567d9c716760d342dedcfd85bd1e26498fe65ffbebbf1cf345a76030d3e0e92946f1ad9d2ce4aaf8e4faa52d8cba3d86c23396d0866602a90225b2d97b31a2f3c030a3cfa4e8aa9ea65dc8021ae002dfff9708c7421053eb582eff6c216fbe8c874f380dbc5909dab681c297fa7cc945a98d0120c295ff65403d528bbc40dd10791c1dbc798e2888fbd878ed5df3fe13579b9868149f49f5eacb89bacbaf574ed755f3f80a8287b58f9d1d033e1b24e8e88cbde4ceee82296efb92d8052be5dfcb20eef26809c81727bd069124fb48eb747343816f322333747143d92dd674cefe3e709cf5fcc725b2fb8f2f1a932eda1986473e376fd1a07c9db58b7fb1ddea709a42d130deb83201c03b2a382f000ea6864fc86c92d57c56a256e5425bc294842c462ca07a13d0a4cbb57173af728ab2234fcba99dbda6a5819cbc73de5d8bb99d5ea60e728147c4c7bd93d32c585c36548133477442398d09a5ddf7ecd1e9ee5285a9a1037db6c1e7f1e61ad24568e49b12d7baf24f3fcd1bb221f710481bcfb56b7e1524dd8ff1d11d31678ad0bec8dcc6c91f49215cb243314becacef3639ca423af32c4ce1c16549134457fad4d89c358879c0b9ef1e1de132813e44d99b0dc2dedccf847a57c21db72f0283482e18fbf364a40854584ac7849389f2f9376ab9e0cf2f66288f299509bdf29a109cb23a65a6dbaa78c9d5b90cd8ca936d7631b738c91fa3dcb9c91eab68587154ca6d672fb3e5f47158d6c720f9e186b1fdd10b0e41f602466f5c41c1a0aa54bf22441144e8d2d952e1150f2c382651e9b397d2b7aee0bb811cbda8154c7369a3274506f7bbc715f8616e981a256c7cec6c0d8cf1bea9872e38eec02a0628f88870f5c14cb3122d8204dc05cb5df71f0553e754b9197bd597902326dcee2dd4d3fbc56ddba9774b6e2adf77f4df0df34cef7c5bb3082b66ea59f28d5cb8f2f98ec0582e8ae789344499b4e570e4bab85c78b4275db004e93fbf99972d9c4a25feacc82912fdb7f17e61b0852eda9d3755ad47f5a4ddbf849e83af9071e02edce31345853c80f39771d73365f898fff32262491cfe453b76c6f3de3c4e8504f150c4ea9ea516a0c47dbc66f5fdbc720772401f8017e76f74164a6c004c813e16850756db5df8704e87d992a52684aeefdaef9580ee8ede3f4e471fcab119631dcafb1dcae084db774fbaa6c942e8918700334ce2a7a89dcbd4855734596531b73413cf546f54dbe9535bcb76a9de46ac29359c18a3a5a2500418dbee1a8716b9870f2527e9030fafa90df291596a2b5ef0a12f115f051a2ab5a11360238d5618a5824e3b9276aac893c069a4dc5da9eae248571db0ab0c971ec3f95637f2bc60029f816d15416796e8ee03e531473fdb0361a5e636463bcbbe23dfe6fcd794631e48b11fc89a369b601b0517183ba4cb01e86d84aaf3450e00dd493031a3932d27bd23adef42ae24ba82555b0744f04fab036f3e3a9738044cdffa25768b6e6da4c2043ffcf3c7780dc974734595db27e8aa9f3b805584c4e3e02a63733be1b479f171eaa30b9387e34e2ccfe5e1583aeb31e75bb94ff8ed4712f5fb32adf9133679cc20673d153aa2c016e954eeb28db449b7e1e553326a31f7becf2826ce4cc8271e0e20e4124691ec26fa7e3562ddd64a8233fb59001e856fdecadd48a0fbfbff9c3e95f6fa377b2ef0918966bfd765b4af3130968fd0b65af9ad940cca0f012af282ca21cff098fe039438a088825378d780fe93f3b19e5f7cf4e54c166e899597c4ebdb35357beb369904420f0d55cdb3d04111cc44d108df6e635d884e783812254964bd9281f09441aa97387836a62910408f78304a2218e25593cf57f0306b4b229a40a60bf7cd92ed2315293508261c5351f2e21d5890a700c50d2110c8afa51b1bbc07c51987f455fc99feeb33ec2a21fca41346ee4ade235dd88e95401a86d843df1c9e4b0a45d8335552df08ae520b5a775a4a97fa23f2433713f48ad66245ad2eaebb10b34cb9b35fbb1506dbcd2f6fc95a85b8f84a11235d168cf3e679461a5dff2d5ae3bd50d937f6bec414ab8e4e427c96e899d503a132c8354e0a3ce999a7a05b8dd364b2d6f81617ade99bb3766c36f5759a51e9e2823f3a0afd847d333bc1f9db254cd1d39be82a47b5031c22aabee6eeb67f4e63c7f0e22bff4d497a710105799260f0bf2f813f4b717d864de4d273783bb41e81d8c9c4ea056f80e9242264e6046e756df61f6d4bfa7fc2f6ccac8ca3ce55ac1f1aa6a8e9197f23659fe5cddaa1fecfc563e35dce9cad931726b970256a0b435bc123b9e8144102d7c37d2e0e983c08208ab18219b9ada987a08eee49c4e5e9df70634e93f48bd39726bf79274dfe4d2705af5435db99309e5a807d6205eccc2b0b5aeb98dc892aa4d17304f5b72a17893d9c2025a01c6b51d560d9cfb40aefb13fb2f022833188e486a33653bb04e9f4eb5388d1d13ce11e872887bf698f5eb51f79ef5424a37ea679f9526092ceaca11aae5893ec543cfafe08177b5a4835ca28c88de9c208360450d0972b8554fb69ec26045b39a4b45065318a3e47b8e63a2afd8b1e14a17710ad80f9dbdc2d097a32618d68611504393a0459c2f0b15005ec9d6cbfda8292a8fac559cf2cfc9553877890e02d8b683d058ec63278480cf63af9c3ae5f7a0017b673fac53e13e47e3a2e8f96351c7b9f58a343bab9aa7ea190f392d30729173b6011163dfaba80db70fd73e070cd1340b978f4a65661086184709539aca492e5fd45bd586ee2f5c28f8d6f4d7b8103bdf857ecbcc1ee35242a1af14e08f6a3736ad8301068fc3e9f03be53856712169890b8cad73f0a5ffbc703521725cf63d021daf147052abd84203ace7127c869d407680b89c06cce7c754a57276e6a608e4281b947a4af6f49fd8ffb4281d316453a117dc2f6c3f9e5bbf86973995b1c34b3f4ce1fa84b2b492138f4297a9817580c77768987281afd974eb1c4cb9411a112da5589b01d79a01db5b54d7687d56a7e385eb1cdbab9678233cb403039dc4aba1120f11ba0df394f6382c131df572faa2911e0defc61eb21fab9e7f34b1a3eeccb8598749dcc2008abd85b05b2d48515d9ff492b9abda1f96606732a13c06d14371e3af51613ae252fa8d12e044c3f666e46ed93cefb73f6a9dee143e216b4ba5e2ac0f1a2b8d79c497971e832cc8623818594f5448bafcfde7198b7ce012ea5d75b8d2cb90434e0ada514b1b937e6a19b0231d3e26afd27236611e1876251534c30e4670a57a1dc2db5af91de420ef5d411875ca54470391a1d799ac440e5cd171879387a7f5660aeffb3ba3f808a3ed74a9ae8a0cd6fa02cffa90cc946cee7b3d3d592291a9e1545ff04948fe152c397902a5aacbeefc51a629e68432f91d57b5080460977e5ce494b61a314f1b868f591c953d3c80d06c0c2dd91f77201efe543dd35268808943035f052e6c47a5f0d872dcb315bf633cf2a9b7ac3b062cb890416cccf0d60248a971619426a0328d0fecb6bbc15e444d3e97e49e8d6694df7ed3a5f09612e50ac10aa2ac5dba5e288ecbc4c1a5f50ff05fafc3d4ca025b72a0d47f432fa59d6250f176683169603dd80d8531d7bfb1f0bf6034b86a3230d7cc1de6d5d00bf34ea990374f86926855e7181086f048ea21ca57f4589ccaf9d90fce7db0fc789fda101586aa0797c9bfa63dff798130e274bd5a839efa3734071b87a30333d4e2de547d972979bbc40aae0469550a1ec71147042f7db08c53c094697694d01f57722ff96eceefd069724544e59201235202860ebdd3cc91724798a09a73f93850df483528a8fd6afb9f544699a4f234985e674907f07ceb767a526ea284efda0afe1a763cd40e5a58d0c3db89bdfb7ac5d5453e4c80d57d8470e168b24d0d369af29c27bc8ca2cbcfbe8c4105a00f399458fd69cb778303be981fed522ce4a6a748dfe66c22b6d1668038a80846ffa76e7c9e7a0dd913c8de75a9893cc9179fa8005ccc766c5d5e9f6c4796080eaf7e77f1bc19cb453e974f27bedc3852c7f96a0e35cb505e4f2dfe94cd8f093596293abc300f5803196bff210ed1c148663f4b5a4113ac0fc6ed4884ac036dbf4db8ed714971f7d637680cbf55e508ade3ac66843d92a2442ec9712a79407b12f7f1232da6da1f7c21c1315688b74339f0194799df6c88c94d8d43d8997a9f48fcb7c4d3ed85f6d88eb68779c7ace487d9e127cba16f8ecdc58c5e882914a0ea515ae8201ceb8232474eb4ca35fc5624f6675cd703c18498aae5754032972b50207190cde3fe2683eefec39773cd6b285eeb90274026849da06e549232efbf42d1317d198c9749130e3a43a427b338871c0ae76e2fb65abafa25f792bed2e03e0d47791ea29a2f6156ceba4d3061398f8d1f2e0e0fcdee4a751093ca0990063994405c82232381b5385c16572d2a083caa0f1e962b45295f1ffa5655ce5a02d819f787119d0d79beb83f0268bc9d8416d17554056640151c75db404ec0aa57d2ad01d7a441fdae45a5b56af68ba94e1f4ac83b0cff68f1e9036d4f4de67d48272290beda5b355d407c0ad2b6381cea881ec578b8c3fc199700cb4efe7466609565d92f32f984397e6fc310b207640f85f475dd4a3f9e913ead34c055ce8f6bae60e87a3a5023b99ea377b9bd174fb9fb2d5f197ba47b9ef40984361f2645c9a2f94b2ee423b8bd71e1f1fe13834d2bc770093f2fe05dc5cc773e6595ca497414e1c93b2f32f0c88070036638b1fec096b39360d23939642f6efef384d63a68b17b93e606195002de1aa12812b0171324e2a9752990b5ca9962a6dc5246345ccee79b49b188a6307bceb672eedaf8c36aaa6402c27a25a5cda363becdd4b3f72eaebce4f4dcfebbde379544e38c66c2cb14aa77ecd117d27d16d1178db11ff1703b21ddd6a3900e2cf55c73feb0b1109b7b2cd64c9c21631ee4e1c95ce31d24497ef4f3b91e23e86e035c9cd5571ed8f223cc6aa217e376248bfa46c7d530c0fe43e617d151b46301a3cd672f5b71a3e91f979a4898936879564b073237c7514de14e5e632d0ff7b04350df689eeb90517522de218600ef2ddc6989e62f1b6e4475a2d802a4dc5899bba5a9ee1b62ad6713289c3a422ff7becd2bfc706a46ac8031a441726b7be7413efd9e6b0028bb3714cd2ae1958f72dfc63170f5ab2712eacff44f36da12be0915053559993529e8ded0fd7df1d0819101b7b327fc0cc35c09f91ccadd07fdf5e238c615d6f10c5dd4dd5f7b75af4955bc811147bc330e101d25cfd27c5cacde9665f31b938be8ff41a532d5969c12cbb9361ce7e8935e053e9e4ce8f86ab87ebc9484558ac7bdb7c722ee5747c93c1226684637a2f9147fb5305d3b777075455174f602cfc7ef80085a79ac51ef8b267e19a212c1bdd0251ea5c4c458bf83f8721ad21dcc29f7bd44dd10488da21f3ab2a3dfacc9cca410ace2270b801e8542c249c0605201995720cc96b8a10f55345e8731afbad99b78252cc25243b500369a1b664d807f1adb1568d2b4ed09153940cb3be2ccc5f67e6271b995c16352443ca98b69dc035c1e4974d04d24dcc1b3243aee6e11a7a06d075159727e37fb79bedcc9f9fe7c501fd917b29aea5d601f196aed2298cfefcc65031716d3eb8329adec9754ff738d89da5d80098fe4a67d06023d76c656bf8e46f874dabcfa743e21ef16c98b3e05a4adcfdf13bdf3f7e04c482608c4eba503a64aca9dc0708a7dc26aa467a98a40155abb249587a41b607bcd43ab768302c2f7191756659108ff5c439f4735a04805113193bc9a58947ea46dcbbda9d8271b92b3e1076ffc1ed23d59178088456f8261203a0144237bad89dce1b240b9b3d21bf7719501ccebdfba6201c8ef02e85c04d39b936408d89e24e694e8d5aade622b3d82734fab9d3ed48e6b553ea0cbe5dc5cc1f2d59ae10a1f61f4b3bfa6b99f37e3cb17cb2699f049cd582e4a5101f85c5c22ec3c5c7e6b5b16661155c717999740ef08c58f0a91ee1f22186b0f71478cccec1e952781793c49a6c25e6c280e5eb1f4f0c14234861e867c712d07ab3b2146ff023a6bfb321aad55cdd3c0f8c9cddf57a2cfbbba1858de4afb4c3a0b4c7f443bb78c77e1b6bfe7f6277732b8b82d414d8fcd69d4707b519a365c63f1da5683ee701fa4b4a0e09712d20e1b8ac05a67fc2173d354d3165b5d4f8993bc6dbcaf89191dc5873e6d1e9af9528091daac8a8a2d6b789a85102e80c25fe441d97eeac3455da9104a32f037ce7da2475c9b7aced59ee2bc02ff32a5989937342dc01d71159beeb0002561444f4e59c93deafa9bb7cc588ac5aba8099c2ec7f88a7954d38952c6c8c1a8c22bf6957278431228c3f2784c10f491255af6f63fea86864cad878438b1905a8148dada58bd61c62cdf635e03ab0c9cc4bd50a8a464e3d599e031c8f3266fc018f40742f3e904d742f5ad8f24833b8f0477fe3c85191b56d20a347e7a9cf1201629af18c45e1d90529bcaf4838d47668f1481f0d1910681e393532916e4109b7d835e96da11344d19af2952b676272600c4e524bd8bbf2f83b03c9e396c8cee54231d504e047ea4eb837e4c609c8d0422a6a23f51fd20b51ac7cb26442a922dd1ced0d55b3bedf4adeca2a1308ec22e28af0a65e8800c15cc7e747243bd446add22a422dc11863243e33c9df8f374515b2b1a412cfd2365af8bb438de57742a0d0b531a98fb67b2bf42ab7d19711d2ca1d7ed49e6fe1881f53c39d641bccef37c324c95cd6608b42c3f44ae7a2d3c9ef4adae30863a77d09b75947a4e4ccb303d10e9b3274b48977505cdafc05f59c8fad55681a92457f50a27006e3a6be2e6e382e7c5295bccbbaa86ec32156110ac36284b1de9180e2e77bd81d0d142bce6ce81f66ffafa694e337db660183c5ef21bb91d60271756800b067b1409c71ebcac701f4ef06796a140f4d31e3eae3366aacd5671d06b5eb8d431e12c7670f67f822720c04915c72fbba3f58e25516900d790fe2dfa52541d365ac08001c34fc039af7c6a678b0c9b8a5f1a0ab636ca4637976491891f8e98adfd4de8a0adf1ab3a63660869659313c467a9bce8c5427b7fa1184970645351a4695d1aa41a8c02d0f2f217962d26b670a363eea720d4c50dc83e5a49c87fa87ae6178a46b704a29beddb00666cfe79d015052167040527fc7d37a2c3be138d0826b7f5ad8ca8abbe6366feddd2c7ae524c90874ddd9a45a8c71a725d2fb4bcb31dc168e9afe20c2e62df26649bac8ae6a2ac7c7bb9ca3319e081c2cc12edb80f924dfcfec382b29910e54a3e7b61ce4c1c4fdea8ab4d419621b311cd0725d1c78e526fa5bb3ce472aa9fed8cfcd1464519dc9ffd344a328d613106379e98d8ade584cd5c6942775aa92f1b115f65e8a08b46b60ee365f8968bbb83006f8e2fd8806c14e9978579130efd5525f1f86fa3365168807cf12364245714b8b88ec688fba46483a6a2feee015bc6486b7beac19b9034e6ecbfcd2c0c2c11c11c63763f9efaf18b8a164fa2e3e11ad2db427be5b06a87afd641a49cf0989f96fdc668c6f31a9c2811f83c1b054732969f2600979de5a6e1d3f774206ae7399a8f83561eb49430faef7de91c1f3d9a31e362da696c973777fad96ce2e59ee6e2bfbfe8f77c56b3547e70e015c20a2db0d0bdb59a55f410f67917c8792fcce353e2181b8765481ff7d78158f5b4a48bed7684943d69f7ef6d3d1fab2e03c1644dd318258c50dd776a01c29e35534f5c458003e94021bb60143884195ba4ac42637068839ff146403394d1faf85a352d077edac9575e195b044541e004b3c0a8f92c9174a8e1b18e1cdc2522b7ac36d778da2a9a6ae73a0ab11a5ba14bad4c0c674ca4fffa7d578fa8f534c22dae7d2fd3c661da36df43bf5afecaf4def1cfc2bee666bef2b9583387fef005368911186c6ca2faaadd71f61db03c32739a7b3368d8f71cd5b8199272f078c9d53529c3ef4dce4f048c93b3ff8ee732721317a56502380a671dab586158c08d64f3fc98c7ebaaf03222b5057cb9807112c822ce17234aaa417b183839fa3e2d22314d0fb235569084d40c8e877230e52d5c2c4cb3b9e94171c96ab1c98de84cb6340ecc7417b7aa7d98e5a03572d499873a4e475f486bbf8b5dca46e4f611d6ad38ce0b8fc7c66556d592e612ea1c8f56736ebfd65a360805c16e7c34aecb0070742843c215f39acf2b1be6a14a9b9e76a9a18872e45b7a38196e3e1d94cd37b54673a6146a6b6c8a9ab62f57c944e0668318f0e738eb339cfd0c434fe23182a640a7c17fb7b29ca7464e488a9fa6819861b6d76a5496f43b4e873e31e5539ad8962fc8ba750c116148657a2ecb7210612a513d8fe745089382a00fbf0f44478791c29b2a3a3f9d9879e2e41b6a1dcebbe68c354918c35de998707a50be5d1ae4d5ab8482cf2a581d0dcdef99e9e3df95630c484c7922b6f7f3fd9c1f5d298feb06fd32768109c4bfdba489b227cb709090ffd47206ebb0899152d393a38d9cff83472e4a5539623b4dda616f266b36aa4bd71826006dae6ea4e58c76d63fc2cec393e3675c916326415767d28d413e436df10779fac0e3790b8364e9a5abc0aa4b87fbca99d238f3608d0e34116aad0e8afda2de162c1f50a5d4822aa66142b57cc818b752eeead8542f6a7e549373cbde94205dec0a4cb18ba1c9afd0f9420ac16c0271c00893631de2288d153f11a96187b3f5271df8eb816a860b22da304f33293d3ad7a342423f019b137e19eb67552f239a52c188a4633ba83663663b17559a24e8e4c5bcd318052bdf0ccc10387eb610e900374ca39facb9333e698091d80d8e0a44adb2ce7f5f27bf2ac1abe255954abb8c85975e03f43c93694c892bf627798c62d9a7908452ae83480200285de142ef8769fe77dd9a64ff482f8c7023f7a2f8bd3bb194e998f25b9047855c0d8d96a0dd3cc871c93e14227e1a6bfc9863a148e35c07fba02834356b7100142cebbef799b358d62b76fe158897cc031990117dc015a86b0a7980fae26f8ccf41f4c2f9d940ca198078119d22695f12abbc4ab6180ede4516f2e0f423c644d182ffc80c55c5ae77568a806240082a92d1f09ba17323378f9ff7f992ca56ded5cab0c89ede216c95d660e2008f5974d4f27f484439e57d63e2388fa039b68a3e0ee4dd0b81db4b811aaa92e78e5efff7bf8d0d04298317f042c8a96e5940f542b42e39fe1498b70edf804fa2e936ce2fdc2efcc77c7ab5da37bafc482d72d1457e0be6ca7b90dc4b62764cb3d3739c8762a204a3dee967d924ccdaa03f9e365a93f7f353811119169a2189eff308ea9b7935db20d288d8a3b4d8bbbd5903e2055b68df8991af8c6936decfc6a21ff12826674ae5cf8941bbcd69ede7d4ca50a44a402830d6b4f1b998047208c3c5ab188f26df88deaa8161de1e31d643d626a216a28c0993eae0a1831ea7c6d18058dbec9edece8b6f3baea26170ea8dc2b104bd9b877746c10b9a1df74e4c304ac8fb344fd5e9d45e126d667fd406fae80cff4ec4fb67e406a343200b48a882b3be8349b0f3cf146f374e60b4a84dd70a5d1ec2af6e14cd52c8af68a828200112c0badc1c5f56002001c8ae3dad02bd3cc4077cf323eab6bf115272797d3f2b6f7017666b2633e50967fadadc7335d67031726d1701192fc3994a821bb9d840a8192099dcc9c2054d868e9aa389a5f95a4689435480b3fbeb53b5d279d6de451d212c36ebfe46bf90d0446b12ce07d3b2029ebced72e6c0379126654da335e6c810b6e3ee5c6d429043e71c012051c27230fa033ec3939bdc75116811c4ea9fa1c965a3e519d5f16ee0b6a307bc1f54cddb08935cd049f2176be5d21a7a342e0b2959500337446bb76c70d3298ace1c37c2a88287229c09dd768e8c346a7820b6894ae08561e85921ae245bde165f96aa6a51ecbf99dc2ebd74a035c3a0aa8aa993d7ee43983fbd016a4d2a0c444aff221cbf60008d5e32c1df290e84a9832f0228e8336a18c8333b4ebba1191845cc86ebcea6a0e2a758cb298412a2c0977e707baaac230a792a159e0d4e2d0159d567ad2be42d0540a988df700d0dabd927871c2053f35b6385ae6a15c9e78ed7ee79564b5d2049a77ac5d36079a2dba5986af6f662e3542e393e7cc48adbee68fb62490e97718d2ff2b3d822538b3d6908c1a56e718cdb0f716de96da67a5e631ca3ef426c4f2fc1013d9c59ed6b4cb7ad06f007fafe8799dcdde9d1e418e69701fab4ea1a484ca2b7c52dc55d0a2f73c1be940bac88eb4caf0cc2d3bd9e722d1768d2733927d0a9bfea710d7327e3fdf7bc80a3a444354b6889733849c685742077f87a6ba9e96687d8a092b570f2e0de6247400e9c5514f73de65ae29c9419010511fe167f6fe3aec4c0b52d9986b55a12674a2fd115fbb014574fc3af22a4f4d5ddece2266777c63ebb20a195c1a170e30fac18d77b9e648646347f2823c951b9d89f082b8a59ac07866449e8bf80f1057bd83b7d78f7a8e8a1727498983e41e1e9ebcd1b448e78042e536d9b8948e932b154b701d07aec08ad7275fedb9770650d17441be6334cf737917751f8fc161e309c200a49a90b2e26471cba92d3b5b712a444babb6a10423ba0a4603335808d684d8ec43394d47a98d0a7fb241b74823c34dca8dfdaf38893011ae72a2530a69397a0cf28c3801e1c826f27bd4d258783d2252f48de7742fb66e25af5cc580a25ed9a2f9f1b2b605fb89b49a661714e17fe947db6b82311c22bcef1266ce5908afb33c8caa92ea428684d8e72d8915a81c7a65b53ee5e04fecf7d39f4ec6cd0954f7ba0389ee74aefa74c83ff7b1574e1704f259a9a9c7c99f81c5079f6333c28624918b3cd71739881e3c64c65e2c8444891164b783465df74064b76633c792c6f83b06d8796a1742ac18b0a783497135588ed129c230c942a794a960da8b8d38fd24ccd082a027e34797e3af50e9f10ff3f38780308e1270206398f270b699b3bff2776df648fd470bddad31e71d72060104d5c5779508b33a96795d98b2a32a9eaff341aa761ce49900e04d291e29a67be65fce5c742a8eee4bb272daf96ff785beac0d62048aa53f1674041531407d67913e2bff61315efd19ba836a7eb217501d5deee2e185e260e2ff0c734b72fc344319969ec7884061f59c3d8e74e558337073f1a095dcf47c1e8e29cded28c7e0ffd4c5fd73aa8649ecd7f62416586e8024b83634c0b993eabcbc9d6bf82cd5d160104b37696cbdc001033b4ba545dc3bef576da42af6f83d89a9595a88c939c80bb1c366726b2bdd6ae3acf29b04b1e75c4799961f61931a8c483926dcba0c5211aa4c30c3ae401af7bdcbc1271b61e6ee21349e502755d865f84b2117c4c3151ee15246c7718a873e6b4ba0589bdbc0c11ba4581c5eba1e34b314f6ed1f654fe5c37dd8b93c416229fb8cdbebb3412ddad17fe43a5df6c740c8f5109a6ec3f38d6dee8ced4aa2519040dc2b1d66894d088745f98dc8a88079b0c904781aebc1f103a233a767a01fa2a10a9476f5b88274d8268769a1e041872df0989eed9f77cb7563432cb288a1e9c149775aad7e5d501183d3cbfd2d3b256c6d36779b3c49e88b5f6a332ef7e868f33bf1c6b63a1616f41a6d6607c5dcb360e0f6dd81fbc2c8644f09eee133b69ed6f1cd8f34beaca228b085e5fa2cf5f7f692d7fb4c8956cb7fa80008ecda67c9cc818c309e5f1cc7acad5599ab1deb053df8f4e793de180b66eb1e370da7e1f5867f0d6462cdf2848b7bf3382e24a341992929c0159d7a5b037b3d755b7b342f9699d991d95437f96b697b46504a24295b0fabce63ba04c2c296d7c9cca3201c7a3fc6bbee3c1b96422f4a5a0fe2ec9020f15ed535e00374f2e4342f9785ab82b0a9c9e162a4c0fb9c7ee697b520dce87497b32ff9af2981ba9c9c3579bce1aef5ffdd5aa82868decd537e44b8abd067873b571851f5183c91e364f53c831e3de312530d6721d00ecc71bd63eb694106001c4c0cde9be15739cf64be9b7a1ff0691a1bc7752a147949f668a40229402811233bcd17af44befc07b5d5c678108e0c87a17620af36d4ec11270da42bf373f2ac17025b2b6aafc3983ee0bd1ef8ec3130dd3030c656fc7d53d22f1c1cd6a64f7124bd7d2423a8ef43241bed8e54590398c65a6fcfafd52ed8c801fed917507ad6dc3828cb6381ecf314dfa7cac064de6344ac32c69bb02623f23a0ff325aab022edf372dd102e2f808d94ebfde082355351093aa17018098448afe90244c2e43ef8558fccf359287ab571eb142ebdbd82a28cd168c0e0a7df4c0ece9593df0170fa92a5716be722363bcaf2869c99755853296877163cb98f6ba8b6bff971068fcde7eaee9dc229ef317cfe94885ac9b4cc03c4a1188c8c5383325fd30813682ff86b2b1028f905bf6972a529058f82a0f835b183b962518727a0d45007256465058db4f37e47c816dceed03391bd49bf4d645a1488ab2c20577ae765b8d03efbb23faf78b37d5af85f8826b77ab4626385be35eae0f3caa373cb3f35ace338f267ad9635aed45ef73f9d5424a1fa54d8f4763e2f4947a90b1acfd451f12fa99e10a66c7aa617be59365e6f5011bfaf34f8273bfcf3a82f18959dd29c0f5a6cae38d4d125569967ebf13af387038d47967778b194eb4aa849674fba703265c7f133948430563448d984df4ae31705147e8ef59deb7a9093ca419d0c906ebfa678b0d7cca5847c6ad3ecb25cfc9b7dffb11f4391b387915c9ada65dbe8a81327b03d54fea3ebc11350d85c3f0cac0fe3de5b2fae48d1b752d8c423c2f5655e6d26cc33e3ef14a79ba44f7a08acda5b952de2549795b0adfd4459df1ec300275a2211e57bf6b18f8691e8fe6788538e5695d24f0dcf132aeb5578936238f68b879dd9faa3092b07a72a4fd3010e54865980c6495a59347e104214569ddd4dea37daae1150bbb461893476f1ce07a532edd1925e9a1316120152d388ca883b4cff0ec4df2a1d7362fcf53de345f138951750ef9cb91124bc013bdef02d6cc7e3d1987cfe4b82b772207c51c3670d99b7f0f769f2a6a0d2a0ccc4a92bbe9b635b5372b4f65517a0a735df37c154802c9abebc452b189ee282b39b9f37229537939ab7611cdd864d8e9cac9ecfdb5b06c70ece40ffcb1a4ddcfcc6583746e7ac99c7305c5cd60aa03bd98eacf10ffad8e8446a3658c716d3618f25b55ec974f254c67ef40cede289b3eb1395b5e7381a0235dbe69a642a5a177d17a7f56d3963a4333479fbe5b7cc67f0765e7b9ef4ac446bb74914e6fd678ed862cf34e3933aead4ae622479f5d4d6a634b6b11013e7864ee285a2bf10278eaf9ef30f24065fd3a7a3856015f515b58e08930bcb4e32dea3406c1aea1bde63d0f3c992113244a1fea566ad3e7b5449f4acec864cb286015d8a1bd1211f18fa0b5711a0121f591328c98496da8e623d3d628472f1e9025c4e11f7e06829736d94c59e05af49ec6a45d48eab61b0b8e64cc184f2569ede0936316c1e8ecbae1695101c0de5bda82f70c3d5987ed32d1091e82f4f3b74037e065a373f7352b0134cf943c9cf9f09a626c62eceae568bca14b39a1d63f2c431545e719dd33d898b6b1370cb477681da203d46fe7a11d0fed8828461768c96f2b9c3f1e277767100a8618e2edee344c79502550d32e420a70651108be90914f3685a47ff8af64f5cf73f0edcf1ebba0a5e9c8e8a39d35b2ea45c9761c93f1b8daedcb96cfbe78cb51a1c20d783ba1c0728c7f21a71c525782a0834e38f9c2784bcad7ec52083f0654685c261da7c2063f9165665e7d0f0d8d0cf0109d5a1bc6054c460376d836feeea0153bd4761d161f8b65098dc03503a38a720b3aa5a80fff0251e24c6ac4da8294ac4a62a4ba4e6ed3a70eb02230ca4033f0d42cd1a0d5dba5e295d7bc5f76856e3d6f84ee35eb0624612d3933c67b25fa429fec01d9cd4e62b7c32d4c837e9df7cd91492c8c8a6e3ecb5e27e2bdc4d243cdffcce7a063e55c7fd702a8b45b121377ea8991fee89652de963bbe32ec5fda6d879803b0b716c6fbe842648907f7048fda73f17b3fa6ba2df0b765c784d6953a41f81787553f9cd3129d5f051b9ac2ce9d68b3b7496c1d26291ad848d69203daae123c6eb43cc7e938994d21070d45e9550bca780b464182938988646b1c90767500222c50d2f6b6b541e80475288a93bcc508909edff87121eb41062a3bd18855aa0fb394ca73af780784db818bcaf0daf0926b40affa1931f2e1119dfc98443d2d1e323a3de9a4a518fa947d4ce656053483813efbb7e743d2ce98dbea748829fc52ad726f5a488f4b3a70fb2a7350b12faa39ce570b4436477782077f68c8547f61910accb3e99830136d477067fdf93cf99f29985d7b9f4fd4823e0954460c4c198024d480d1e1182dd4192759d12a89282a9d3e51b6d4ee11ae9a9ebe0121f5cc623b32c5f985977cf74d5c7bfbad7e0e176d1e569845cd88012709216a3a22a6534fa4e90aba1c9a7ca15d88ec8ececfa68522f74f830f7698e103ac54ae1a2c719ad9c8ca003896dd676b22e8b03298f77f077cc3196c6750eb34d4b4fa100b812fc011301f154a0f546fe92dcde9743e69a4002c5536c71b040d41b78642899beed87a52adfe5bae0311a64816b15a34c1dc36d8dae5eacac25f51d14192608307aab04155e5149f54836bd53448209854ed5cacb416a5f7dea9ea9d56d5f920d6eb1bb73d8538a8ceb011edcda432eb8813133659216ff767dd75fa1ca60c489ee6c87135aa3f48f0d2dcb0b70000858b5bc941f9ac1b58c994a259eec4528d58fe96027aae207491aafdaeb3508f445d2618bad3ce79e39526fb095376c19b4296322d6fc90e567c0851342e1ada8a444c3fed85a58d8c399fab67a9cac9d64f8f27328c0471e01b92f9b8eac2f830ab833d26a6a2e33367db62b92f7b28003c0e6568bf07741ed15278e58a1ceabbab9bb9495e5e6820b6b69ecb56f74921acd8c6fbca11be1f0efabf500f67dd9e7fd995a22e5bc55db423211e813f075bb58312e6bba3ebe43c2b17aad652af3944e28c36b74c08349bd9e2455aa6f86249fa4b1b0b9e8aec6b8e0481dc18d9711399389cfea09677cea86cddaad3d7a40329e5a7d6a3e73ef7c2465d316c5345accf1cdaab799182a2f1af4f60e6a1d48e98060611f0dbf65d229a69d4477bc72cf27bc60a6a6ab4748ccc4c461c49e35165df951adf4643ce8a432a88287f556eca2903ed30bf3daf22496a8b20d55c9c565c04d65b4319a31d2fb1e372cb59a1a82f8c16cdd0fb120fb73ba7725c0773dab58767b23524a00e400519b35615330135ff7f7c0dcb3de6b0d7a726b169189b66890af23dbf7ca37be79597361d2f0ff42e0bff0c6b4635737529cab4975165649c45b7bfcf9168b839bcdedbbfa4ca3d3eab254949ed74645dc0af870a7dbd666641e9e9faaf9cc7e52bffe72888cad83526e9be0f28704d4e67f242b96b921f8981fffeb3c9fa256575cbd228f5125d2c6a18022011df325f6e50901beba08ab16cd006e32d770c5773f6d5088436301e9f7c66ad335c3d007265c22ec0b4dfb374dfc9cb9d30138c90da50f4193820e3c4044de29028da5fde59140c325ce78207432af7d1d07f16859ab27509d960b05272e2fe893e2eae54a6a7f3ea33590f7ef9cda98f155c664baa90df7d684feae4d53c35aa45a2a3313c08ba66f9830bd177615e67de41a51e7683374a0b8382526e85b78c6bb05e96448618f559cf13b1a9eb7b32a714f5507211eb05f62f92b1df2257ea16a84cc39f2ffe0cbab3b87806d0a7dc018d62c7870c94cdaea8107fb269d67b65a8dcb0d5392ce5754bf59aca17e61381a7b22cedb53f9908a25abb44d15e784557350890c32c721ed6b235ed004ec3327d6d9c34f47a19da3d697a8a92d45d5482a63f45139233710d87b7d725e444f703b9359d90078a44c897575eb8e53747fff80ff6782ed3c53a54b2493c456e79fb4ca47a0bf028930c179ef26b6926a6a95b576fe7fa8a7399822697e065c596cc01dcbb5f7329a18e993e3959f2e4fff8826fb704d7fe0ed2766231b07574d78e10e792ccaac6fafd56f864bb8a20d5d667ba5c2eaf5bdd609fce87663af3fdbf8daf9c3403572083c6cc9ecc274232172521629f91e725a25938f193b6912a604a2152c215180467c864293a8be410702e53a554ef91cb8098cf11a6abd9dddc86681a907d185ac5752601e3f9cba4d2d86051cfabdb1f9c9b1869087e19d35f6a356a5347f11751a4ede473af5f75962b6d3b895ec3d529ce33be26c6fa4aa71566e1b8b4a907538d0f242d4299806050369a38be198e48c511b33f21a40017287aa7b4c4d240b469df6a3f007fbb1b5f93e9c784560fad35913e2ad681aa6a1dd91fbff9b203074ccc77228bfea5584159f21142daf19ed72c881891f7061749478e0a184a2f1698caa72649c62da7b284b8149a02e771f6d14c2335808418b12aa350513af8a734765261d7d6cca09fe933b3b63b746d566c32be1de1ec1110ecfb8c2bb694eac526e96591d4f7195abc0e5aa08581142b993486590824648613f1423f1ddd42976df2132362947183152d1fc3001439b03b2ba87cc886f504f222922ee093cba9442c298c506c64d7701538500e4906956b736d957160e73bea51e0009fa738a34731992c7d92854b4ce39c556d9666e17aa884e4bfe435baf98865bd30ac5bb351bd59f1c53d630585cbae8885ed4790f7deb61bb59659af29da85e395a84ef6a4b3948a6123ab321e25e2e3483ac23660a0ba07e0de035ddf0e7f082f00cd7fbad53e347bc66b1c68fde5c2b4e4c6ae7a061e16a286b481101afb6283e10bc37b480cfdbf3fbcfa37e7bfebc150bb081b8f6311edd7f89481066966035d756aa649423b0b6f19de5085b2c00ba666fdaf3df8577508bea77de0d67857eefabbbcbd60509ac4eabbde184e263647b57fec17e1654f4c752baa7b71db43fc5b366badda5848e728c8b8062f2d6a6f5a6f186cd6b61fed1d0aad1f213689e92be4bbafcccecd6cc7e11d11ad4fdc0097ae8f5055bc2fb01bf6d5b91f231d66bbb46c2556a0f5ec7907cf75b21f4dd35701e7220e5fa94fa0187571b515cfd9e4e33d7332d255e33a24f9d1676b766815e9211a6d75eece491e760af10743175c75a3a5e93440b5d66bc24832ab02c73e85ebc3e7bd6b8ab3be614c75d70c99edc95606d8aac508ac4bc29650122b01c1b3f78ddf33d95c5cb1ec8d428c531ad2592380e8eb8dbaa8b05892842296be4c37e8afc035033f572c4cc9e18275377a1fe08d0700b9484790d8bbdb0d7bb6faad423c233cc3f7402aaf3eacb7b1fb6570087afcf3af7532653dcb2c834424d2052521ae6a238d72a0153d35a5da9adcbb39c43763c26604afe32628f45f2318e72c4129dd4bc2b4b6d2ac6cb14fa745822039d1b43c528a78cd6b0ce5f4ad8b75fed3b6583634f56999bc6774e0c864a76f48febb55a8ec9c84933500ec4ab6ef48002da0ca4c761beb4aa1112eb233fd6da315a068d3055f7d112b96e26141708c557c0098d8c8e6ce73f1c021ab13a33c89115e6ecc5179a169e3d854e577430a9cecaf8c546950ede3ada56c77cee973522a682bdda98f2196170811a4e15e2d5106b639aa333644f5067006e512a9a54d0d5263956cfee4164de93a67064ccb887b5978ee79fa5f5ddb89854b2511f239f18dccd7019f7a9b78af996e5b4012fd2254cbe4b0849bf36a75449fcd1a1889e8145b2e437fd3f4aba40d667492fcb153dfc4c990d2d1f1d40dcce527a6115a73e8d919b2c95008bd638b89cd6cff3bfed45c05033f32e372628274eadc9ef5bb9ef8d69523352b3d809da5236f7659c7791c5c3ddd776b8f7c448d25b02f5f96ca7f98ed1cd6e73559a3ca5b4584d5cea563c00d3a3b6a9093d350096ae0c0fbf882beff1d7563b2f0e5866ffd09d9753494e68c3bb524b66787a1cc5a92e90762928aa0e82adb7a21a82dc236561dfe0178e5872751edb687020fdfcce7d70571b981e3c2aa0133e594d02cd00d6056c7bcc3ed883b75e91b566940622014811943c799bd0a1b6aa9bd7fd9bdf63338a5a05e8d8d58b2b8a4ec8763a4454afda70679c6b8fbfd3a3b3a393d433b56850719457ac17d27b08d9aeb07f0aefb2b5d136019b080a28eb41e05449fd6adf4c854eaf4e5396df2bcd28f48f6734ef29794014cbe31ad0d3ed34f466e3941c0d3ff07dd88aa2e1fea7c9f24cfc562ff69cffd5c1d0652a2ea02438238fd5b35e4c683fb4c389cd81bedddde07d745c2cd5d6ff7a68afaa94cd7e36f24bef9e411cb4621bc2f5aac553a3ac5d3e68515bebd83ff8ea42a57f049599b4ea691d76e591ee8f264aa03a0e588c44efa7a1af798611babb201e0a439eac511d7194beeb9c89e585df64c79a14d91441928552bbc3b08651ac977d97391c198f85033fcf9f5d2d812ed0ece42779747b2f2d8d6c199e0391bf212c1f23f7535c9cf2e3068afd911fe97170cf131d70a1bdc40c7ef663992e75c019855a0219ff52d3b5c02720b27b19e42bf248268038909b4114c2d776c423f74e1bece9bd4e28062cd559dca19fcea9d94f386454a5367b43c12e7b4172c4bf9c97a03bfb587c017f5886a623e584e3eaf7f027f63b4d0c44f36737369ac93ca1bcb95a907da22e788cc56812357c0c5c92cff28873da971a9d1615a864960443925f58c9fece46169899c02a50d07bdf1b454035008bbf9115b4fda19b024e0593dafc33f983b4cac00337f0476a302a6f952c6b889aa9968e066d8f934457beea2f496993775e5973f7b9d9136d6e1e4edde3685a9a1903be58be0bcf7435df447665f6f7c5780d91e38842001275b92d344beeb184ec5babc506401480ab2a6448f6ed7eaebc374402eaa7ad536fb3d24b6149747c08d7f421227d5dcc54f26b6ad452d5e32849e9f2410e43479ee1307b9758981b7be8d64dfe3b9bc671a639f2a3466c12eb7ed79989d4ec4c4132127be5659182ed9bffb84228d35bbd350508339e9d1a8daa77cbd1ffb2920a521763ad31c521c4592bea49c142729ab29789dbcbdd4ffb9be764d2ecf62af1f1706921be1308f880c01413e65fc2d486ba65d1e171930e88412a4d13f1155a22b2958189b14c2e28cc03d76d2c6841ef2f0a9f6d189fcd2a8cc97cea6e84351a85887f77b53db97b7389fff25d9472887a0a92c2ff26822216a5ac068965c14508eb5fe48264178953ca2a2a04865c07ce5c800ba5569bcd5fff74043a83abf503dd44e4140a0f8fb67dd0052b350c9e33dc388a85ecbf763107932bbbbc97de26b2cb350337ac65b57f09ee76ca9d838e27dd7e23cc15ae010369047e14a4b397249d973935e39d83b5f8a1498a0976c5193d37423b946d96d7b782f9b563e31288d219d58afdc332eaf1f660175a8ea70695f81e5fecd261c346611027415a3b79dfa0c48a9afba3886063ec6c788c10a5e9127573c3cc39d34d45d017e898219bdc67b7984913ab45f50fd882d7a56cbec4cda94706ca38a56502f3e5c5a5e7db128136ffc3d0daa950474e5c828ef7cf5771bca11533f3d946e36d4dd35a5cf7ab01ebd97a4b416ec4971996a0905437c2c0ade316c327bf34b121d439b7364afe8790b63c433181f82a450d73db3c3fbda1e2ce38f438b883ed306fd60b83d4ebc1ea0955b84222d9ea3a8b7686283ea08269af839d28f8c6bd08c5aedf72afe14d978413b0e5134462bb509b1aafe1305f2f1f6ce73c5c831817a97c3ac6f0361b1e317b37b1f11de7dc0295f5538dfbe7a953938548f0b1be322912519fdbbb8a2d81fcaf5e59816620ca93ba1c26464e43286084308ec61d0a7d7c5dec5514be54bb5843b1e893c7a13adf571f61f00a5823c91e8e3bc4a615a5f3ebeadd37143b2d3a2c4da889196e0595bd3e5bb41838a173b8fb2556096bd1715b434dd3ada8114dc17c4e70378cddd48b72242665bc66820932d181f98cfeb75ae735b72b7797573a0e4b01794de17a36291f085fa087c8899a8430de6cd2dbe503b95e613dc7e1f9d51fb019e8ff15e15c7f77b8d407656072911b5a97a91e4a85c1ccf3a8b9f3b1863bba89fdcdf3e5f2666ad2f2ad8daa200d1703c2673d0070fbfe8f064a40ed1f2e072889f245c33406cecd9f3c593103a364f0e186c08852e6ce72d8275d14232b421f9150e92cf3e862b9fa078c366f905e393e2fc234d6a0152c6ad77fd5631974d5713344a22d4c6ec51779c564ad3a5bf575ee6a54c85833094baae29125adc9ca90920ee8136af5e57195dba7f4ab8645900eea3bc580b73ec5b9b3d3b88991057f41cc1e9b9de8cac94aa30e43dd8d39a69704a3e30e14c12f8a3d716f47d0593bb9ec6274865098fbd338415e3f9e89ff9f0a9c55d6440487c42c093316f755c743cd296be9ee51b73149fc4b6387231bde2be0d2b39abd91740c853428b4b7126677fd319becfe0a346812ff2137e9f3c6bd97aa7c869e32fc08f5c6978cd54efcb606f1757159e2d8c1f28a9156c06c6d2708b9d78b1dee4e9a171632bd588aa63980c65f7abf27a95edd0dd509a6536881f6a632752d4116e7c6b6f47cfc07af9bef71a0eb21941b25fb48be3c829fdc2d662bd0f6a0e8798f18bd7e6e6d4c258d4dba88e8683183342a36cd823b5aa848764542f4ace33a7d384318f5d983192c5f3cc81c45760a854589b16f7624ceb670615b4cbcd691cf89d4ca706b0b7ff0f8d05c50980abc80ba9829f8a16a762fa7334009bd47d993399a86ec417b5e42d87405ac6445665e2f03290ab59af0dd0cef9d7c42ca77b23ec6c841a9905c4eadbd0d74865eb62d4b604716345558683fe70abf3572e0063b25ab90f43f062995e3ce5c688cd44e897a8af0e1b068ba146511179790d17a33970bc9bbae3fc4a2050003afc0489e2b02ec735e2c50c08c72d96d31dfe661244788171f2e2ef3af7085bcc8698795094147bfd9f4ab8135d6cd4f3f6b69f86d27898a9c79c5196c73a7ccbca1ecabcba14c040d529e61c380c5491e84b070b1f5e5a9a1945c7c83d37a93401c83984198f6fab4ff196daf9b17072942b5d6ce03e1a56296dd80c99ed376988b43e0fd5730301965fea2c0872ccffb5197a4b6ceb0e57b306ac12202452479fc8b658d3983e4ea865514f20c4fa09731fc41a212d5c500e7ff6891cb984fbc6cf4a6509df9eb404b31651bc91961a9ab101044be4a2367ed212eee9278946c58119f54becddc1f2732f5367ae160fc7c3a24655d879c1935fac7a1758d33b1a099f22bd853b19ddcf4e84514face8c8e3fec885b81b896aa89089470821cb52269d45c0820e71338df0b48866b7513f63b9bf875754a7c7d56bf9049586d6d779d0ba5f0af60691236ac02b03c4b6a94225320b1eada345f7d1544cce3cf5b96340f585a81a770e10f6751ba1eeaaa4b5c5c21f5adcbc768776b820ce310ec630c282dd100192761da0a601e992a66f9311a05d6bc17f7618ebdad0bf86b47b4a56b05282abf535ce1ae026f3e73f81d1f592ff15e08ea92e366312bead151752b7ee06b34d84c041e96b096ad830b7f6c713ed70c78bb17d5e31ea6187adb139f020de4dfba2648ca8bdc84a7fc99efe456b2aa7a85c86442b8b2a2ed5936f79f75bff5f72780a9eb31f607c20b47a9d97ff8d4553befe10eb1986f0ca845275d640faaefebb409a2dbe48f15e9b96d0dcba646c7f335897d20938653a475cf265d1008c8c3c2871443261f9f5b3ba8c3bb668c879a3e8437e0c4c446f86466d1be79aae684d42cd293c64d9bdcc499cc0840e2cb2d50b3414fe95bad180bbdc6a3127ebe4ba06dec9f6f49e3866c31f15a94b7c8bd46eac56f2ab7c771efb6eacd00b6d829781bffc87f1474405a85965c9a5e3879fae4f1c2116565ac6c80568d7ea02ccb275ecc543c56743f34ddfc2f806935a938f5b8b1342f2d292152f54bdb23e60790d29ef6da79cbcddeaf1346b54ecea6060ebd040db95c133d3a036fd751d1182e31733ccbe08160bc63f46315f0641fb68f9533201bd0385f3a19bb0db494f9caee06b5fbb22c9516d4893be0eb669ac02af18f8b0b3c1b770de888f759cbb3177505cd652aa964bee7c3e7deee02fbc3cf8eb22a9ad0dffae2d022d6497016d2bbaca90f684e78d883997fa1a292aef80600c1b96a2cca69fa26a401b6df4142d25ced3a194782ff753eb72ab9f7f28e03d8bf14db33e01b20af5ec1670bf36745dd0addd47fbb0331cec41acb0794c0be0c1bf1edd6a5d92bad6da84bc38c0cfd54efbb755ace1cc84a1444f5c82c66928f656905ceff8fb76c1d6bd35ad7c0b54ebd3b5b43b17ebad6a2fbbb26b7213b761b45d1287e83880866a36e20f65844593753a4ae10a5f558c9638f7c55939898260111f6fddc7b4e836727f10a78b0ce4038e83b72f070789a84ab29d18e784ec6376a15667be1a5811097a40bb13ea68e6c11df512dd8e3ad512686cfc679b8ba59fc25f77800c705fd44b2cc68e5dd980f7731e8b79493ea20a10f11a130c90a912ccc5096daa4d6b6730060579be64b830c86907e16f5725e7799082fec6e4199bf4e4d003cdba607efd23d79893e88dde2f8ed87afa37658be7c5c9e4471d3a23323578490d3ca391881ec1cfaa19163f99aa1c5ec99f57155969060bf3fcb1e1622bd6ab4f5b52a69c71975e5771a4418a17f6f2577bd8c916c1be3008f5abc17a7b998c54341afa01717a7adb0fdbaa3dbb64703108e7f9e5177ca845e4ce49c3de0e741c884467504340667a83f3c24c7338eee27238a37d01e771151b978b1a440edbf3651f2c5151396979bcdabf89fc96aa221d0c0ff89de91d558c36c86b3c373e2a7697f43997c3d9e019e1a8d87fce0291ad30f71fc8be72f04226bbbb91337fc01684d3d0920d83bef2ee33313e2c63716e9e28bc1a8dcf83173efeb1933d9894753a35060b01b3d2ee19d2d6666c25812c0395132539031277119630b0461bd723583f5b1bf6aa462a3a1027d1bf3d1eae58bef06f6c56af4e9e303b15957f5d96ceefae5db0aa9a87e23f22c9bcecd560ca57bb46a416507d2eee80e1db565a10a46a9f0440024bcf2b24c26af86e171f2fdd22c758e059bc89da3390c47b00632fe7d56b3258031b910e0aa30b440623fee18d88c8e585edb64b1e57e5c041e10e726daa96062e60687f106cecb5b880274fe1d90c3521ed6aa646917a21aeddb3b1afe21cbcec60c611ba5a5ad9160f5fbd00f7106020ff36699577da6068deeb3e5e6e9144b464bcaab5b6bd955c67b2275b8ffde582d35212389745ec3e9de6fe0bc032a3b3762bc90cc02cacf1e8e920fc260b566760120a408a1a7001ee1acea0db88c806c717ae211a9f9ae07c32298c1c918e121d9f2e8183eb82905e6fd08db649c6343d8ff26fed7c3341055e17e4c97d7c6bdd40b76b5328002d21d86310f39118a4d8ad078e1da3bb8a9e0e7c738404f6624f9e88918d279e6a31486991b4cf253caa377ec9c2ec50b0c774a6c419cb575ff60a17258be2fbcb8ecde4425cf80d36f01f2184396f6892746d0614dced9bd99442991f21475f50fe554d8b3fcd60b54a55a9904f6e14f13cfa16ddf5c8ff98275cfba567e09e97b78ed4ce63ed8db7b9f912b889cedd5f6862e4c50220fa1fefcb64b35a5160ca747acbb86b09b3e8d4db31d738c2826d1c612f80dd5de40ec49d56a198be17b63b19b9a04ffd711471b5e4fd69c42dd56d7ac4914b7a25d07f359fb0dbd08059cd7089a99f4a5dfea0cc68ae1fe59044996faba09cd6cb165dcdfafc2a580aabb3fde2f95130599d9b1b71ded016cdd8a586e2325e48e79461892d75b1a515ce9e0171fb9cdaa6150c5c1b3b119e90e62550a4a4ac844e9ba3d824dd907abd1bb6a81d6a041736d0de501ec3ac156ed42cd464120b4cb8090ab822b8d952d42dd185d924766c403631b0f36f4ff194f65067ec94fce8e1807116c13dabe63384088c952089d73df220e4e91c120feb8308a386f11fcb56bbaf92dbacfb8222fce555a9e203d6337ecdd6a79de0d50e237240e971a7be9aa740b4ec16352e6fd92c9782456303895bd30eabad85d93a418ad1c457f55823824735b602c1550123fc91b387bdc337bc5f85a9ccb7e000129f3e85bc53cf1712657c1a774922e05df689f1809b8428dfc239c58bf14bd91c9a6dc89b4f460673487f69b05e9c444508300bde4d51a3b34fccab15b626f55b4d3bfbbe31d55168c407b6d959a7117fe1a4e34ec450ba920182230396b132de7677ee1c96edffc87c2bb665f3292876e4d57b5a3854e57058382f1991f7c6a04002409bca7e969e24951778ce014ff668062e861c4745af609590c45586b82dc302e233078c979836a4d304ce1d7dc1052195d68e46152732720bec08644f39d597167d769ec1914cf4816c844cec68bdfebacf08e81126675085b942aeb2c40ee46fdde009de2dba115bdb80932b108501ebe1d40e7af98c34a17b74892fcd02e6119065b5622654e8b9740d89c4584e99e68109817a97b7061c90a9fa862bb79b46d7058bc19260fd5f9a58aea4654e80c2741408f96e0f277d90e4bb90037dab92ab8db0fc9ae74fc0d4c5debdaf347990ed85520b4856097acb0e4b0ed5d7fb65842d5e81837fa5af84e75bb03116814fa0381f35b6b1f599d73171952240604d0aa32375fbf83d4e5ffb4cc353ba9f6b90387bca5b4e4ee67453ba90382f7472cdea7d8475e1bcd2d56643cb159baa22ee52f52a6957fece41c16157dfbe4892ff4761fa2d0ece36661208a59d42a85ee8c004fdbb9988728ef62e797a11f8a8016f400d87da00d11042ca04c074686586a8d9c14adc114134971d71d32800266e0a91d45cd6831c95370f76d5d677c143bb2ef33e10000bbcea4337642491fcb10b387cae2f971ff3ddcf14030458f9df542b513be4cdbdfc0e71dfddc3f4c136c66885ea0163f9988299189804e95eb41215aad8555c43e9999bb90633bacd5eab7036a1532acef5535ff6baab5569b3c90bd8e19dbf79d48ae369bb0bdf2272933dc9384133d610010377f8d5a1b49c5142a798ce031c43f1e1ad11d19fa8cb902426932e5aa66c3ea8ab31de0702121ad2f293852663a09fb9085dbc2756f759572f5514cabc1707883e6bde75ea2caae6e2973322b5139f8fa6c0c5fc95a5e7a5a5b46866aa7059f5573a3212a028f26793ee4055db0264915e3bb334af71aa2af3aceac4601fbc8bc5f0af49482a19e5e563e4a22d9a7f6c1f486fb6fee6eb69df03d75f3174e01aca36a80e6bd2d436c23e438b405aafeb83a0ff9ebee24cc47f8ca882e7f402a8f2b14b2d64f1433d353595e3a59fed15c56aed5628347a052f8d64c94b74bac1c0ebbad6b570ddd73cfc8e40fc0a077df77a3814f838616138f30030b21cbf304d48d7ff32f9eef3b06c34fc4fc88999039ea34d7a870998c04d235eeb2549b7f786210ebaecbd8a8f9a64addd88634744920954e7cf23d72279aa582ce527eee63bdcfb30c47eca5a599c210beefdfd9f5d341a785159b6bb3097cf1abb56b01977992ea9fa6f79af38b17d5769c8dad11c188f40aa2a7437a741b7059765abc45dacef7cca83efc48051bf988b605b3cb21793bf970574aa7b8e6cd755cf24a3484f048d16f5d80244d16d0194dc4cecde735caa0947021a594fc4a7317f59657063bdd7dbcf09d249c9db0d1def3e5c063afd81515808016ed79c9885899aec0017f1f09ca15328ed5dd355ec8df9495c099dbd89628029b2e9496a48d898684d9f4a918f41dffef0c771649cb61510585ca085f8d82be5bce3ebe1a1cf7a0ef5192b86a2303cfd9674aa8a364a69693eedcd1be73d3ff0e2434ea6268a965d774f559ac0ae26d8af8519d4025c8935e8fd71f806d62a2e119855f2373704a1e8a5b5f4adc7e9b5f7def7dcce8162bb589a0d2be6ac94a9a0daf2debba61e0898466bf406dbb35269707e88e3a9c659623b7b2478355291be361e2641a821b6dc2209d490ba8f62525c002d648378a6fdd9761b6bc0c2ba1626a987b3ec7d58c0ac350882f20acb6e4225e08377b052cdfa7151bd35aeee4fb2faa5926f32ea754ef971298141f246d6ba289856fa4c4bf5d5a05aea1d9067732ce605610d554079296be9ede8930bf011542bfe45ffe7b5570297feb53854d3336bf8d998ca66aaefbfe15ad98952bf1a0f3d49e1482b72f9f6495af6cbe040673bfa1021fa511aa6afb02525644de863d44c1778092656aa27a7eff0ebd18a1fd0aa0367fd49cbd001a79e8acea4698e73da17edbbe50d08234fbcf0592d3cb3df404d1fb4ad7985806e7f9575cb9816cf5e5071cc338254d04075dd0f0e4549b64351949293c277a9f8903182d74ec7e5336a642eaa675e1264517ff826a5f2142f340c8957445595c78aea345eea52c7e5f24dfc1abd99e7e5a09e505e3355d3c21ceeaff95ae5d3509f902f2fc725a6c698bb8061fd39b1155eb148af67ca8bebfcbb2c7f80b9b898ea27ce9d1f9f35893b19d3055e3748b4adad447240534df9bab6e7f164df1feee2b52452c2fe917332a1bf213bbb00aa859f03c1c248f320813ff8a4681f42dbdb79d2bec4eebc756bf07d2c3bb3bad7fde762e9a702c9373199af1bb5d75b46fc157d91e0bf2b49908bb988a7483dbb8222f3f4dafe473861b625431a77af19b193b4daa64a40922ab80c10a1b8738c3c6099adaef7a202b524124cf7bbf0870457aada521ceae3e1e01c62ee60e94c99f06df878a3d41c3385489a44c262ef0383ee98824bb237157625557377ce753d8419a27520ff761d00689124017027fd2d4405e1f6f1eec209f06e972bbbca928561c6e179ea5221a97eca4246fb36ed750295fa6c2336eadc4b0a79ccbfcb4813c51300245a46b0c88fdc70ab83e699ee39e4ae61d1dfc4e1ffc2022fc535d410354469db4c2527bf643086ed5abc516f237ea7712f92cf1ce3faed2e2cc386f2b8e07b56a2cff99fa8eb107de181011bbdcee8247d44fd82cdf11c013b24f3e1ad5af1949f755ec26cedcb7e3b2ce9df8fd745ff0660bedc209dfa235200990256c979fc4ce309cb0f8790a07ea78042d847de27b1737e12a2eac35806b8e9b122a914323d26bbbf39e18d6f25a5947d4607c2f88599f2ba542ad55963d75b668adab53c46bd344559818c1e8f5d5d6b9193f2a78835b25939d58bc31bf4a6e4e9f8984fba454583b868c58a188a37120193acf96a149d87643983399bd92b1baf3dc36bcee7090315406a2c70918f0724de09b512bf69cac7e4726d43887e5ef93868a2b75aeefefafcf2c0b80fe9c641365f6878d6256dc5feacd61bb8f05baf27d84c43f53fdf70d292d45310524fe78e5f43cac047423ce9e690182f81ca9b7bd1f107fdc5a14f9b91001f23c17dd4c81b090e02d7f5084963739052602ad5ecdaedec199421c065bc64b7016e6d971704e5844e7b2d3ded330e8cf1c2e68e07c3bb6a61b84782d1ce5a96ee649bfce649b943e2ce28b96607a8d417a8b1d3b3232428481836b5566ecf785922815a4231bce2f0da28bea295f11ef909a10b6b654723f5b6ab0f5ce5549007dc8fc957a882c5f813487ecfa9962356e4b37ed5a5f09ef04609b6f603b44f4ecaf2f14eb7590f4aebfab993be212f214f6e11dbbbbe67178756aade6b98679539146915d54558ed90d3c3ffaff9e816c3e20a678436f568483629592ed081178cbba4fae6a1207443dc63cd9dc21111fc52e35e60c3527989c8eb36c73a2f618ddf5c7f93978fdb7c3b1bf43a132a08dc040a8092064f75dc47c146df6f15a1fa67fa96353ffca13c327db13dcb5e7893258147729a8b429c01278ad8b7e25f6e70ccc508cfced511c100bf00e9ec5e5da960d72707b7fbf8bf7a5647b4ad1b5b249fbfd727001de51f0ef8bd7e4ad2d578b82984919878fd9e21b3e64e035bb41466f81d164f011da6e4dd017459a35aea5df77c451f44d715e752bf2415118757751f6164e567186fec4c5add2cf82f5fa36d174a93cf4d2bd226184bd77fddb097e0d4f87c0fc3f82b0e60da1ff85333f51967d2efa0ffddcc310e14549e1c542e2318cab51f363bb730ca012d59a0a2a01b13481eca961b2d98c5b9091ea017d34b07650ac0268f6a1121f1dc1faaa8644dbf4f143b52d8c56654781c2f8d8950c95f4d4bfc5421611af9c088172ad6bb40a62ed049fe8304a6caeb9f7ff21a5bb8e718f05645b18b1dbe93c60e56f1617b0b716ebc0913ca224759fd1520a79d201658f7491587623798753da50777d988dc655a74566bf9ad9c3c850494922c889253d1dfa9545023514dd49b9a02b881cb41aba4cf5f01b96ca8f2f8b101650ce9ee909a8608aa0a288c4a9073bfe37006fb9bb783843dd1912e003eab3477c770699561a54fb38998ad22cdfdc769fbc58b4b3cfbb57c9b352b61c667adc70642fdfa682c01ffe2f34ab0a4f7b24b3cb018861d5c5e183f2163a5e045d4d56b7a2b7abf4d899a7ef83dbc087a3d677bc0cf9b23def71459f7e18ec6d074e982663bd506ed8c59775a0aef95b0e3977d54d3b7351df9526ebb532c16996665f3833d5fef75768032f7df8812561f9a43c080e6e7fca79769f7f03a70f1d60aa9b84dc7e7e07c70cff14acf86e9dc07c6c37e382a94fffcf0179ab2e9f3bb91d282f5a9794062f6880d8af3a4cf310648b3ca53a167cbc78e9c0856bd1bc0d523d65759dfcc1de8f5f7389f5b67f2e79ccc397988a4d6d3a546c41b4efc2bab7a8cd508be0be8c6b7143084bb43387ed58106adf36ada3167cc515d9cf8ce44c77fc2086b39983a4efeb76843c812a3413c64f123056ae8359a09fa835503276ddba14d29435449dde280268b61c839b8cab149ef0e300bfedf07f8ee9f19d4a998a79bd8a2f651c30f49280118e2ba57f01667f6e56cac8b7a99b81addc31e840bb2b96fb40b97149454c7db52214bbeaf2475e9102f57f7e613ebc7d0425d1c100c77d70fb0a06cbbc0d73b21ed7b37ec34824e3a793f68d7803146fe7a38a72f632da1baefc41771d28693800e7ec41b9ba45e644ee4413312e9d69f29b1eea2634b40e6bc97893ae6eaa73ae0c93d27c53f09bd1fd945a26ffb6510adccb3b5933f0745ce4c740c0ea575c617be7b44a05da5ebeb561b890c9de90d5a3a14453c448b12332e708a3ac7d7363ba65c595ed90732b038629bf1c2a2c23d4fb7f13848bbd08d21d027ef583090762264a6fe5fd1083f579811aff4409125b624ebcf6655b51fb2025cb30f750152ee324363878806e8bd9b5343e71bd021c292687893b8526939e9ff34b7c3fd589b7059fd39cd22fbeec3c47b7759ad4db1752d01155f07c3b9058329d18543a74b150349cc51254503c1b57ed1d5d4292205090265948989d9392c931abb2762693ac558e68f8bad82caa1a337cae862d7eacc9df335759d0745f4b2273480d6ec8ccc021fd5e80921b8d96bce689c5f7e53c5842cf4604e48cfd15f79eaa8bcc71c713972aee9be413535385e071c08c70d37d3046f34f2278dacca4a4e006f193a56c1df1f0a3ba7ab8985bc90e08ba07ed999dad58149925237232b81303ea4dc64426851656b023850f5f97e9eba3bcc24141f7b3db28c55071bec2a41b92463ac29428d67d7b54b727553f056ed6f0ff6af32a796f6c8a40e77a2d5950cc0af8f27eee262631eebd951f71a6aa5ed2070c92fe9af738783fe68cc0f0fae5cf7bf8ca8b80007a628e1d73f72e84efc5df796e25eb550a27f9cc69bca5b3449fdd5f19f878dd0f589d9fb446eb60754f6b81a2effaf7c426f58654439caefd9e618049d26c4ae8f2ab4d5ae3caa9942c7e266e89efdc78b3d5942ed1c14ddbe4a3e074ab57f545f20d697879458f7594f19b4ad03a2cbd69fab5cfad6a7aa6babb9408eb3f3964450c5bfaa78b8087893008c0cad8cf48bf3c536af710857426a8fbc91c09cbcf21f0b1931474e6ba03c94e844cc17909aab4ff3471d3a013e810dceb0416bc5c1fbda238cd2af143b53ca3723bbbb628bbf042cda7bfd1ecb110ab2f5420eb26c0c36e8f55fe858865ca9fbd327ab2e1e6aec9034a4b8b4391c61745b912b20f87350fea73321fad305a29e1791a94f19bf1ff41b212cd37aa0a887b3302626b66a346c8e9fcc4c3fa910e179f0c62b9b83da13ca9f06cff14c686538985dce6d0e4c5c368c6d094d0a693a834398020258e938ea951f8145d8554f029a1a5db930d343d1f09c1aa5f908f0d123a868f77e043740dcb4dd6fc5215e8ff5e0e6f3c70071d1762060bea99bc552d5d8a3a738140e1a07d82a0af1e75fa5a08dc5066373303e66aaddb003b5061d4f1977815d0ef80a4e41a0bb778166b34d139f96167df9dc67b7eca9655235b920ec35418b9e527eb4af20f8e072510263193da47a56b771816654ad489fc659396e62b4653040f45726a274f76613ca275482b7b388464679af26db4928f4270511a0494da3b9da079db6f58367034776c8e5a634cb9813c479e65454b0126bd604611e15c284b13b9197b0f1c6d5851c170716625c808c4abfd2b5dc7e13a5e589d1a38cee33355b39ada8a3ac5797660294066ca5cf7715d33b580f42adb3915206a0a1e6fcb8fa6c359ecaba67e6bec7bd165d5b44536cc49ccdc9b52b1f0f24ef4c0c006401e8394289f946be172aaee7d94a45f7830175d6933d92b1207f4feae40edfbfa4eab8573103331336d44a1d6b24fe694c4869f1f809d10a4a8bafd7f39be2a5b8f064fb33adf7ddb26fbfaee8782c748b768582a01b7f774ce09ac6e8c293be60cac9a8a14cfe31e0572f74779d249d753c5ecaad795828fa48e7dfcefc3c42b6a05cece2217488cefb48550960c994d213da9d06fa957860a99be0a19aca510ad30c58e1587d1923199b1305b26478278b1044681cc4c0eb58bacd7d5d0eb7031c5b185275576c5252fe2bd4d2b7b5a139572a5f506309ade3f9e83775a3eb8288d4e0ea48f6ab87f24bd6ebe479e5fe2c57db4c515fc5aab2a37f0cfbf843a52f5eb9ccc37fa6faaa4171a1e50aa2a54e1b08ed29de7696af908a897fba746a8ddd4429e9b3237b70038c34cd183b9139968f29c59e3149a7a9c85ec1a14d71b6377652b5e97e30108d2191e6457ef7c591e633b4c0656b171ae3c7264096f32a2619f8983e539c13f94e7e23c70c01cc299d4d3df6a2f8538f9f670cc9ee256bb1d7edde782e0ad7273e1b9d07751d8b0db4a3c1c4b70f6a674a1edca877da93999f8c6ce4405f8f52ae5be840c2266c2e6247c6eb4ecfdbfb75780fc7317207880345db857f0b0231a1c2da3f6253c2f776b5584a9c76b787f3ab5c71eff1ea1b9afc15507cc8f77fe79b6ccf1851bbee26f1857d82dd2f7041506d0c5992df32e1ea99c4f9712471b5764a0e0ac2de24327600318267d58508fd3d9e585777da31928f3ef0a24a55392befd57e2ddd4b71afafcf964d69953c4c259235c441b4379b65de54db89b2ba338bbf5d59e74728dc4c144db26ed71544fc6683372788b244e73315c4f0a614f2f56422e59fa2516a5dd6abda4b69e1ca5dbb425526298b8d1a214f0e166c47d18b73cfbe0e8b14da6f82ee44ee3fc974d8428338a082800fe696f53a9a598cf3258e25b7fbfa107d5220c8cef9e165a0902fe070d313572fad52ab8c66b90245987d8f07d218032969f304ff609bd96b16072586f45b7eb048f5d53461ff04fcf1a0f4b7e37ea0e54c00776e26b65d60c182720a59363e17f008f4bc8bf7f3136d55761abb061ac81e4c38b7ac6a23fec13dfe88f74e63de3e7059a3bb4e15df781f0a168d468009be86b987b875ec3f10eaeccfd408c148b849001fbc821119a7d0dd638aa8503892a18cf4727f621ceaca1f100aa7609f00d98e6e8c129a9fb50544611e2bd3339245375226ba1311a0bed0a78eef1c076871f08b3a3e3c51d01482fd45f846adc1705a7b6e1e99405971378e49f49471f90ab942d9dd4fb32fa57b30fb4d0c74f26b19cc210b9015d2336f5d2a268ce10366068551b3490ebac8f6c06980a384566a6bb16ef721a05b80a080e67ae534d3376e950bdd2e1409a67abc19acd2a9507c86ef4ee80cc4ad6bc6dba703c67a0ec9294c046d19268cf151b1d3731cc4c287f155f4823b70af9385ca34e81d4c299b059cb6c7d60e9dcd5a0c13bb8e2c7c1b62a9eb500244515a644398b6f1f247a64446238fcd4c7387d571638acfc408548b4dd9707bdd9eeedd5cf20e6e4d53865b071e95b0f89cedd8e75fae4787e3d4a854801e9bde3e912dc6113bbccfa9f46aa92190418f7807fcaec16d80ccecdc2f4ed1b23a7f862217171472a48eb81afb26801adf7caab5bcbd7a82bf48a027456a09b50a79bb2a535d4dad92700f45943a922f5ae4187df3a97ed263abd7c8d2a4da737e0f078728b5c851b00ccc5f72890ba5fad192c6f2c01c4c5dea7234112d5ffb2285f0b968de9cd02c234405122473fd7a1beefc4904ec0ac32d8251e2ae1b2d60ac34a3cfa8a8d55e026b9c643eeca855d72858cae7287db2abbe9c483e0977982f6e6af53b867e45ad1926078b14e277754142e4415ea034f64de0a102e80957747b2151ab9386a357f39fabed25b43341c15e982943907c49c6a6dfca4e8e2e5023218f578255d66b37383c4f27ca53005a613bed85b408e3fd599d651a9f1491aaaa91496c5989ed851c0ddf4f02b691d6b653dd44c29df6d827a376ebfae65c74179054ad3fe9e1ae1261b2ae2d2e90529ee17b0aef1411dea89834bd893775e5cea03165e40e96cbb6943e0696071c371f9cb60e84845109e619f1075fa72c6f793ee80ab40c9f82c0968c5539c145e0dd8851f968bd6d3e5a051ef964c98ff30031326696b55f69fccdd1c8e116e7883f359a88db59e81481875cd5247e2e96728712f4b01ee4e0869b76cd467221376c01f7256de686acf27832d6f981a2d8497fde0361599cd4327c3f6c5c05f4e2a5e7da8041718ae91d300aeb5c42d8190c76d81dfa9397de583fabd047700b648b1441aae41170d73702ec27cce276e025fa6c9376913e884d6661ed845043ba0f84425f625303a48e5c9e1ca5db52c10ebb914572045416cebd0d0991781e77ba9b7333c90d86da7c210a29169e42b0768a3aa083c627ec93e5c0d587dd100e2421075684ef96854496e0951b77ce5bb042c53f5ed6d693f8aff27976644f46b518cd5f09888a5b3bc0cafb01980a9625db1e62f3e141d7ff7ec2fe2a68eae4d520128850c99d1191624ca20eaa415d862263a8cd9c8fb3684ad892518d27cd416d7b92d3c3303936bb31fc1bae6480fe2c8cc35cadc62ac88499eb33b83d8b5bdde5fdfb8f56a355e0b7c03fcf9f6e6129ae9196f604acf610ee2d21b8c42c566070e4cf6082511bcd089ed4f8786a32aa013031db2791e0446f688203045e9e146ff6f1a04b5e14eeb81a6c711ae61cc05012f47d7e92bc6d6db2fa32a772efd79a83c9b230b7b9b9249927d4ca8ce7efaddef4e0352c6fa1189881b9f3337aff5ef3eaa38ed66013cbe4b51b7ec3a00b627ce8135e3194aea9e8b952031785256f6e02ede97b35d5e2619b07396cbd133368ee8b9252a12728780b6500699ce0ab3a1d733b5565bc70dd474e32788fa429f441f090d0bfeaf8e488250ee49ed67eed605ba6d704ccae68cc81f9036aa03ba837001dc175e423207ccac8216d8334a69f730ec2d1aaea03db9d4854aa9874bc3739ccc0f227abc3e3b8ad64be5a1ed56c68fcc1738c10fd27c805a658d68867b54fca5aa10d1ede319f50babafeced1412641fe259c1dfe4ac48c096c48fdb00417b335910354579f7126202942b2e88e05f816078be2bcbdc6fca0132d43005e685ab38a9ae06c49d1163bfdac1c7ebeb15eacc25be1ff73dfb088e14a460f5bfe6483ee508be5d122f13d4883f625040a9e7c1c4b1e61640881f43d2dfff16b594dc9046a6f13ba687b7dd4584aa1475e5ae9a996928ba871f2809a11e442bd26a5a75c8e02f617c87ef825b85e1d7e3c0ce1b36d6a52308525e7e5a15070f7891e949ee9067422b5c7e7bc9c9a97be1efaace9e6ae92549689c1d4d7a1cfb68e9d97ae244ecbcd82e4ae07694c34af52252bd17e872d3d28da3af3beb397d2af8ee88ddaa3ec92cc84db27c8dbcda1b77a889737228b89eafe5d030f21c1ea767ee27697b9369b70b811b1ce71a62203175996369c264d58e39309bcea13f052c622dcb5489a544cdb174a4c2dcfb3666616505e62fd8799af29c79ba8b891835b142c54f3d741ef2a9eb76b5aa77360c07c16add7e9ed29a6a75be09841625a8e6842c5bcf1563a0d4ead79f3e0d19468db10df6d4547b1cff8597a4dbb352a592dd9f25d68eda801fbe19c91382b9d72dda3eb24aae763a4c501f3b59ef5e69670de4bc6c240a56fb6d50d64da5862e210e712f3320feadb85ad88cd2c4ec416bec8ab32e8176fc7dbc2ed97297f419ec4706f17f60eebd9db67ec201d95b675f4252f4b5915f581410316babbc57a09eecee93f326047224e6c9d5f83377a87b7cce604f7758ee2286dfe1fa3dc909871f4fb122e88e18ef936defabb1c59d51d4bfa54f01c4c5877ded4d18f1dcffc15e91ae8a10cc027fae2a283a0a660eba02b833559fc2040240bf01c49dbbf93acebeeeda02d600afeea5c16312ffda1a378e77ab3d19d343e0029b8c3bab5386068ec5e5d300b34b97614e7a9f68e185fad0206fe5fb7510b3c9f1157c9445d1fa5a069da8a7c4f463cf841d67543517dff37de5568aac6d1ce82c1d1e85dfa5bd611ba01d66b0d609fa52aece784ed399fe4c3ab70374b7a11b3f1ead95650c104da57e477b4a49223225310ace39aeb9415ff7983338d3e2ab8ea1a08c99cce2601e7e6db880326fd369b9416f315b91c98876dda6b271418f0e3bf43e3c86c012de472defd35ffedc27bb742361576351138928401540d94de1a6bd95e513c4aaa4bbb4a4d3b52316e7282fc8bb80c1d13b7709645f9f8575504fc7293d883bb32674d7d2c5f5ea041be62ccab27bbc5e36310baca14bc9d059886445e9e0fa170a33bf80585a444227a76e03f5ee5f91cb383803e76522ffb5b604cfe74549991cac5e9cb76cc2861bb33a536b48a5b9f81a4a51a29dc796ace6efa21be6be8aab787d0857e1d2743e38e5430f51e7fbc09637084ae2df4aa08963acf8a027d77c3211d4b71d0c26512d32d0d7f8c34e85ddc1bd9e8e3784c8f2b9fba7903d15a2114f40cefbfc1ab815e3bf9ec8ee5154940fdffbaf3ed511ebd61e61b6add1ea7f6861b9ace23b8e626a062e15d2036c941687ea89a7903588b92f238518802dd9a041a3de606d678856529b3a4954c559b830ca2ae185f1f44ed516090ef61d92a8733e5a93ce16fca554af07fb3f25bd105812e8ce0fd8057e9fdf5b210a89c79e266435fab40bd6b83d0c85e190182185c171e4d46be1168d09f519664109b181717bc7a1a6c1e713ebfb8cc22582da23db4a9c9cca59a516614ab475f9227d737131b82cba3b506851d17e8deeb42588486586eb1ba2dfc746dc3b13fc7952205966a26181d3e6b86e3f782e6b4f98a4899eb52522d91ca853f6ba82d7c516d6459b623940dc1d4974dfeb1cf11d6edff3ccf7bddd5935c3299e7ba3c4f307a934724aa6600d59540950e89cf677974eaf76f2bc55cd6dba708e0f7daf484b6bfd18ed20192cddd02955ad1e4a400e3339ad70b510f372a162f60654bd1eace0cc030c82599de80d4080b3493bc1c73f0d56fc048821e5799096067f33b505a51561cbab21513239a1bc2d17f8f4724ee16f7f388a3a0dacfc93471b72877ee855fec60b082f7b1cacae45b2d5c6841c62f09df53e70e697b2b822fe4116560cd29faeee06d7de9a5c5dee48c3ffda694fe2a6ca83f1fbf9607c1fc81803fe5fbfc62941b2076cea695a6652254250d3925855b01f5cee6b60d7f2c058d3f7584ca523758f7a19daa74caab84db84600f7f1f0ad7111d2926f812e05208c3cd0a31f78936360e39e9261f865901be03fefff2bb06b37cf9ff1dc3d3d791279c8afae4e228af617b089602a1155bb0120a851e97ec7aba642aca640bf022eb0d98f961051865f886151dfc1c3156d543350e51f61d01baa9fb1d681c7ccf4cb2fe5e461f8539573c5f29c50c1072ae209dd7adec09b98c1bb9727cd4f9ee8dee6f63433442faf9d986c6694438b644a192cfe6912be0bf0ae305e25fcee8df8b8ff34dae8f45b94c01b783fb381315b50c13cb137af13ae5208e352278e9e67907ecef13fc08f3e87d505cb0c48bca95399aa1d1a84353a99bd2d06577531a649efde0859bdb7887a8fdc48db2771d62a709add462b6724b05c4db7a7c9eb58ff7250b484f6dbe7d6aba777da3544c0a9158550197bb1dad78d5795924170d735fae9aa8aff5318f5d864fc01cedd05dc15bd0c0f21bd6913bdd73f7ec06b7fc65858fe4a22a1720ee54c0805fae477bb054891bd4dcd3e1d8dad2b2f5c628f0e06ef77b905410224b705f83a08c13fef17e3dcdce97d72039889463d0f4c3a5f0c5c37290c80bd5661c46ecde6149633b3ec89e72c174dc144743b1a93429eed03b1d9192d7c9591b609fcfbb2e7aa7f58899557a16fa01a0ae9f73d9d9554f82e94dbb3695bc49e4c3fe685bf71ca4af0f47b4e7cadd39789b903ec8fd3ae895d5a2e2ed7cd2399337e2953dbcb2415f9b3c17e752d5ecd30dbb6d7b9db2e0ae8f4eef660bd9c6e0f36eab069ec2a279051fdbc5361705e17b06b99a7cc38f845c6b0528e4546dbd813af9382fb08662d87b1507a95e078634b3acb17ad56c78be890bf5e4f1e02c8eb30ddb914fedf9d765b1d776176a7807b251137c7d5ea4d64dc156c39144e43804ea4805f1026693be74449e63f518c3816d02c29a7ffe3bdb1ebaeee86d692946813e1b5d9e1ab835688b6d2f8d95f0c09e2d7eeec741519a2f4b7d72c06e99533a92bc6b6b51fe0eef3b67956e88698d1ada5becd9757fc2983d08c1dc3945a7af1c9b226e99e3f578bb813dbc10eade99de214d2bea422a8f6be6e403ccb2bae2141b822733c7b99644c9c22ef90dddd09fad13bdaaa8fefd477e2070f28903b97d9cc8a859df8a802e017c5e39fa1fea7b066af4693e06d37f9b979e8ec403f9aaa9213a0a7db7dcb1fb239c1fa711d171f2addd94391b7324535f26195ecf2e8b2b66b5672687c80a93ad2231b1567127eee4eac02e1559c984e29e2a30fc37ff3b7b2984c7429e50a340e19c2af78da7ca7e879e3f3d9176e5e07eae8438dfedd770988c4a40151ef90736529aab4291a42c8248d4e0a076b789e97f3e1624bc2ea2048d28ca559519c19e4ea5f64a4b63aa786d2ed98cc6bebfbee89b24d7ca9705844ad510ec4d39ba9db5256e0fb72125742a271f7a07b8dcc6741c40498d54105a4385455cf39a689a672ee7051e672eeb5b06e0dd6b36714c3a1e9bb621f8410ce1ea88dafdef2818637ed7fc46aed6c648d2756f1a7d08e057aae89ad2ebc2fa79b1b9383bac976699991a5a5dd85d26c0a233f2f2793279dcf1baad7f40a0ab669cf883155cea1a72fa8eb78da6d6593fe815cfef2633270c3019b021e00df97a11f4deebc46d6caac2427d614a16084b418e61a0ea68da7ba71e0b9efdff2237187c9efc6dd65e119babde2aff663108e31fbdb0fd5c8ca08f517aff8e63b98ce2318f41b1042c1da4e8acb48f5842cc69292942d79d468c89b1a01f26d289994a6fa48836373e4cfe8e6bac4030e50f0fde5b617c9cec36553ba3fb2bde2472c5f7587b5983cc8f8dbbf48d4bcfd993b54c761c26e02b5747b623d5d9ff60995a49cd2f466808e66412b34000c9bb1a22f60e63436a72b9108c35286f96e89388847eb851f888bb4d8422fe7feb2504cd07797cd1bfcdc8d946d6fa86035674fdd1da8730f4b3379239f222df76198861a60066116e22e49cb005f1f91c9bb3ac5deeff929c55eb95ce5ef1fa15ad43877e9ffe1ab58b453d00bf2692c23445d809cd7a172190a6f96afab64fb9f7fe2c4b1dfb0981a2ce00c28aa417c8667d58c6a5b5bd7648b334bb8db3dc2281461105b338a5e179d1465b9b2f0cec270740f76a15dba38a76350320cfe61d8c6dcc7986e600c0c8e497aac0ad886259894acd30300359b53667c44e5cdb763d5432986838bde780dd60930248654144f0cc282f739e936f8f73914dbf24b5641fda74d956afb2fd2de6e582b76e7629e638e2f148c2e9576e3ee5c749b4f699d1433346a5793036a8afc691c9c478f57cf002dffe4c66d8c5e014a97452740055086168be5bfac8d14021e3141bc2fa33484b633b29c118630f67401700eacb039a454997960a6391cdec028278e412f025b22510662b5edef680b63ccd1a6af3e88ac0fc71640a7ece8901ce7b38017e596f0583e5557eb8e690c84095807575c11c7c6ee545a888256fe3ce3e94b7eadb8687c83b70f173426ae5b1b6c70f2b2e207ee537adf6769495c21d0fa01b7342402babdf35f39622a7a9dd76b049bbf9440c22b1f79d88f677b796b2de73329817c9496e261e0e807716510a9078309a2f4a1a2ccf2640f7d9cd0081b20020c6bca336b58d6ef48e4804d6af5dbcfaa7e6f3490995fa9873965f4383c31b06d4162d665a64c8a1c05f2cc8ca0c85460bb583197e95d174c7009521d88e6e03c4aee35a26955432195a3e402ff83e1c17ed57ef36fddabb7461407a333331c27a0a97afead50e6332aabcb5bc52eb47334b10b51a0c11e2c9b9de5736d4978ad35a818e19d82a35733d151fad57332c06b8791d709b35463c6ae4a3494ca535e38e2286bfaf906d070de1590eab094fb5460ed66a14cef2c98887389add4eab6dc785a4065ecf548fe1b4406997b36c27e71c6b0698a9a6050e7e5a7ed7d646c0ea76d3f1b2c423dfe51516c04b85c0ecb4fa05c7f684737cc84f9470c7c7ca158533bc93eff4afecce4ed07ca203dac03f3d11da8747649533ef0b03df4c7f9b8e5a8b3ea408190a33cc1a8bc14de659076d910368b05d87effc404d1ad0f0fc3c55247d1b23ea6ce2fd1b708d320da139940bbf5cf792caf503aec72ec4d7c52da149059aefbd05e942b96a7c12f255140497284fd268906d911a7427dda7c01238a6c158ea83659d86f34edfd8baa9d19c8888df520c8461557de65157aed9133d325629e248463ce3439932b89113c43f8a2d3dcef05cfeba4d6ac05c4f54359d14f2f15f4f72534b7f36dea98e175344979d534429c6314efbc60ec22c2a2b8f7abbd7f55fa9091a641e2a7a71a6e63fdde95f263fec6e2c954c5ffa4ffbc9d227c00028d5e4721950491ba679007c6866371d39b5c294493e5cb9c077df6e182986670479ac2636c5dca5237c4b7f4c70f33e62a102fefe8f97eb1de86049ec82ddff8d43db900f3b774b52568e49a141071a9e81ef4c678ba44360711ccb0844c9a2eb891b9a8ad815001902ad2a82509067ce1d1973a4fa7c937c289c94f5d82cd23d25d22911fc33188ac7e5a594697ce95adcc50aba978c12d7a65241753e986a609dc85d05a53b32beb95a56f682f9bd3b56a7abba0524a2480bb8428bb66cd3193295c6939334f9a85e64f31367a74f7e46fa0a8393b59051432562123eba5a3a875a03bf4396dc9de1f0f061e719f94d913321ad88a9c2f98791ddde7dd29b7c1d83aa2e1605b1dd6d97282f9f354e63fa1c65be24f0cce80876af5b89fc91781007f35e1d24cc94f70c587970acd2a688e238116d54faefb0840adb6e564ab32d5148c877f1796f33bd1ac725a817550902925e282dfd7294c08cc6b7b9e306833016aa9855c589b1bd1c851116354107fa34661d66b74ae876ff7c36902938674bea17039ec5bda4d79a791681ced674fb347fc5a21c8fb99a1ec98667fc172e5abfb9febb13dcf4d36f8146e07c1b78d91a7a944efca7fd79078758f1a2ec1f01dad4dac70d9f73c2d35060710f247c01e66e8a5c36190b77e843b2ab15e5c976da0bbfb9a518eed07ddd0c9e47f924ad175b3bdb8b9b73f8a6debdb510259e5fcc5dbf19750a43ef5abecc70356ad9b46ad45fb9818ea6b885b42fc9123d248b7c1d2d9929731fc6faa4a7e1b8822b551c8de84ed4fb0350fbe6501b3781f9b12d1009481a3985a9b4d88d865ce14617b7f9e8caa04837c8baa58927c1aa9888f7df8113478a25d5fdcdee0d05c16737c88ece719843c1398dbf62dda85a2ab07875ac6232d2a8f4bcd9e49d60793f4344e3f8271f72ee26861aeef3b5a15698c17f6057ecc9de84c57bf584160106341b1c81f9ee7e50367930c61c91f045d81fece11b27ea8029459988366c4d6966aaaf169c5229b6a55c15fe3d40676863ee83d1698260b6cd789501f6929ec1b077dffef15784d1caa5a9acc16d93b34ee9742f1453bbb097823bab650592c21edc3fb8751ab6b02f1c0a0ec1f675fd88791d3d7147281a29271b1f73a5900323655061a50ecd57066c1725c36227371cb8bd46d60df0e7a286a3b615b1b370dfd191986a9b027c0ae162565d6824b173f546d181e396a7a671846d49bf420236d5dae2ae397d8c90697cb4c2931b5c9a62bc27eb97e8ee8a9a856ec41a13618fed9a8176816c426e26a74471abedf71f9f49a6c3e78ed2bcddd6f15eafddbf006917c3ef35905d293e466ff9fa867b43a9d0c0a7c05c06ab9494c4fe4748813bd55ffce7cf22b1bf55190521e7e9e5044731f913eafb4b8b46c979c2c0395ded607dd3cf2f8b65936c9fa825ebcab5c34206c86eba8713a7f594f8a7fefc36bcdefeb4f0733e0e8542a7b5a7ff5e7ef61c411534f8a252dc931f57326ae75e9a6f868950386ed696bdadfcd37dfbb5f05cacc459c904fbd74911e828cc1b8292c09946105cb2f9f57108eee00f9a710a3de356b928c81121180f629f2d34632868d61da12117bfa294b987567790428b3bcfc31c497e02cecdfc935511e8a2d7bdbb48515ac6ee9528083dfc5f92241e33a84eb7b4192f96571d9c45d766f0ebd45d4d2ff7973f42a0dcb624490ef6eaadd7d1d70765cf368bc8756a6ff44d9b5576b59f4fffbd1ee076ed36ebaa6232d1a970eeb93ab19d7e874e82969120a952d1ebf56c27377771a90b3571ea1960b3a534652e3df40cc1d51c4b8cf56b3db379f73fe4f0716dae3e7f7ee15e14c728bae8fc6b7ed395e8ccaf0385af3ab6ce2ee2fdde7b03a7463071088c2df19d4fb767d95c85bb34600d3548dbd5a99dc3b200a6c5b2c9f8c8d74ea0958f402fec5dbc3d76b953e70feec734e39c42bc0c37684303b1de4d4c60c1d95b6d8a6c07a21c31c3f59fde8f07ecc48cb1c4b57f409d8e6e665603f3cc3e21d4ba280570f2328589d97f7bd70ae0f9daf2ee7e01715f48b359e3f76f4871735eeb4c27c571bf68237e39eedb1e7bc045a98f210a34c7539fb056164b6b0492290e28e57c505ab419c86ca7d456f8046ee2a64a037deaf1b67ffe1101fca836cf5aa0fcf9acb81ffcc8dfbf9fd70cbbf8f65c136aeafb688d1c3a442b1f3605c1029b396dc0a829e0be90c9a6c963227e6bdccd323983554e3a129965f72e14f9ff38c71a1fba284b791e45b382295f70144972a0ce2b5dd27c2a74e5f4b732ea8a2e20603618c2fe94ab63af7d23c60b8203eb72ab7a993487363bae0f0fd2356dfed44628233aed4ab9f5b6c902b77a0948629834ca4ff1b8166753d4e9032ecef49a6e53640bc2ec8a56c0273e202c2e708e6f7f29c694e6518900c9040e204a5d27e42081fbf22d91721fd669d6dda7b0c672c8bd0f49602bac1adff70d1d22b02356e94910b1db4ed8f0bdb4125c6aebcb4824f8126a2965ea7c818f52d837fb0a3ddcdd6b043a8bd4529e43fb1e2e5d77377a808d85583ddc144b7426f9abe39840a012e44b5d0a8a8bc9344a18905e7e0353b15f0da3dc485aeede80c4b027926da5bf4d86112cd8025020fc963803f9c78c17678ce23d7cac587a7b0684342b5ec49ef66d24b8151ddbac008b0557f6bcd5ae195bec947c20056e8a87ba1f7d5021193d886b70bc83ab3fd163726ddbbb802e5e2ea87362df56c55d6c0184c2a13a96dba79d013e327e13f616b077769bf5c0133520e36a635a0d4c450c359bd309eb66359277f61b02786dfc666588b4421c87166e488b67ded224ca9e984cf3bb70397d60b673df0b80767fc1fc26a2637950394887d6c0537fef34cb3da764e6766247e37f78c0a1de1d0ffaa0553fce070fe2705549e56686a544c4f1743ebe6069d3616bd1b4a0111da0bd63e71256a8d7a1146d25448d0b4b1da8fb71cc6262e407ded4d2211ca7484c458fa6815f21309ec35ff9be9654a4a8fc944845a30ac4abd02f094c95501e721d286e8dc4c2efb136c14a08d3e0df245a72d418e5bd923dd23896de6e27a7c71d4697a92382e4168730b7e6615bed3878209118a4dda191fed8f77748d6b8f17e316213fb8dd4706e9bad45b353f90b00b4438434ad5517d20ba6eaff128590250faa04e57ff3cbd3efb79ad027e8f90fd1f319eb680caa622907f10e87817e3240aa9ebc0c4c193d5d2fa3d2726679a22841ad3b3ffe390d08779695a899c5e498e8e545be95e2da02546366007c67bbe4b42de95774beb446d1236627b9389805ee16a47699b873e674661e648e1f8521c8269b616a48f86616784fbafb02240aecda0a903bf923d5029f7b61689ca076db134939bb3aa5d7628691a478e15874e80c2f7c48a0795951f3f7e6be270af2e1e3296340c41d7c89b0347210ffefa567cc6ba56f37a28591e513e77292e0b5128f33b02031b31a83b0120429e949a80ca18e10bfc6206f568c5df9e48d0b5c1107f664c9724eef40409fda9a4e9c71e3458a739c58460d788934e478788f5aa5580f68b479be61304ed43eca173d8aca57e90b4872fcb4605825a59d4c37f821eb7abcf75839084e08e1c4a83b3beacad64bfc0724eac58eb1c9a7217e6dcdfb3eabd079f5a94ad8e01c0d3c8f4031d13653036714c5142ea3b087914a33ac08795a27bcdf62d67b57a884a759ec0bbd2ebf16ffe8e5c2abc590a1b1a03775f19f9ec3a6b47afc4a50aaea60c3b897d21eb7160ca811e553c3c3b054c2490fc12e4c038811add94ce03b772f75d7b828fe68c7910c04d84573496105ad3f1ed4297e26b412a2746abce290dd52e39356bacb7ae9605c78822ba8cd2e54c89d6fecba648c226d22c221962412fbbc8fdabf64586918fa53312ac454f0db0272209dce3bd5f9141d554f859930d95ef9b2093737d67b3de1ec83059cc5d87cc8d9fb45a034ba2f2e4bd30caffed183e6df8a4cdd75ccf89c442069a10b04157d8dad269f7a4a8a9b26cb80da47a74c8d5e4a2b4f55000081be464c4e0d09ad3eedc221000516cbbb1b4b9b6bbce0552752d0851d7b7559c6b23fbbd923405a821c40c3903547adb81987e571a2ad190ef150e33d65f92e64abc28a9c34e1678417ea27e50f79675c704f1602b71882b91f56edbe7f516e3e12be41bfb3d4d0f19bfc3602b1515b34f87b713deec4b59a72821076ad06152567b434ff39dd483ca8dd5139fec3722c595bf07f035199e9962783e31f6e3c95116ce1f7deb2364c5bebfdb03454b5c2962fb96e3a0dbfac6b19c163b01fe8ea3ea1e07c10cd7eb0bddffc15c61c0e386c64518a42c368ba4a6436909d3b156b45af3d2f1f34db5aebf8233d335e2045c527b7c9afac2e3d82e6a054b5fcb693c1a07bffda55e5c5ccc2bb383f3bf0acf0ec16b25f0206aae5b84284531b3ff4378e33d8c8bade886daa7db50c76afd1ccae10ae091d52a4faaaa01b30dd2d8df3b194e198aae74cc49810c2cbd5865aada6e91dd9f3c2a612440a4da8d16821424aa4bf3c27c026ef757874cdc56285f83b64177ef9d47a64781f15a74fd2f6ab9e0b84736c931b59cb0eefb015025d69f634b4abd4462f2f9bac32cf3ebe67a4b776c2f91f1b546fc6102c6befb8000b9ea8ed56820e5f85ca096f03e7a6d71fcc30fe6b7b5af96e953e491eed372a28b12de9bd40ef698dd22066a9e1b29607075ceb1ad15a9d8835614bf0bbd76ba63f57a80195e2bd6bc7cd15c9d18b442a4ebc0c80c20187296d47041b22bc9230e221ed35b37443cd5f11bf6df44a160f98bdcadc06cb302fbbb435bed0a8a417f122e1bb25b2b0ba1f968894d3568866b6c9c9a653b24af56917e5c19cb81453d1769124cf0c9499286e7422860af54d985996788f5607fcba6345d14d252801d9d01ea20706558feda33831dbde6faa79f27f8b8a3d608814db018bc6ff22ad4ee3862c11fbf393e925bf080c43e7965e8af73ae33d5690ed18663c75fecc5bfead38026b54e78f3bdb083b2ce1e993d414cf5895f485690c2f05bbee9152394d16847d06b62a21fc648d11cdfa7178c2d0f59db3bd7046c85bee2107eeca7184bc02688fd0c631551358393237c0b180b09ea7a20f48db2d589b92252354afdaadf1fa8cf813000dab5fa080ad49b4a2052f247eff1b7457a6e1f3221f0606126db95f31068ed17d0c8aea65a927dc63f79da3a52af231ffe9d48de6f52185a1beb601d0a03fe1f43631694d62cb216aa02c861d7d46843ef51226bb5763cf03194d765bd23657a152bb360e1cc9cabc3780bcadb07196b747e10341034675f5bbda507dad32d34908690d85163689f285e50094cc8b3157d9e0bcb40a4bf4f54915b7a28c83d34919cbef35ad004e7143388cdc02086e07637c4e1a608e8945cf914f3266f591b377c9226f22ce5054e05fa67357cd264689a8fc8e4fe72d8726e3845cfb9ff9c2e03678ca75837e182bf729aba3eed4365b4f184a330ed342c7d4411b2c4131d355088ca1c08f6ae936e9c9f4cb00df02cdc6cfe05cdb8373c9d94932a2a990001231257e58808ffe2cf3699b2c704266a4decfa1102705f4cf3661365b21a5a26d8995900fea8130511b888fc43a552723e7aba7f9ac27065ea2b6ff029f599cd8ec2536cb071d9ba65c660e75df70e4cb5925809a497989a9569ed8389dea925142792324c00a277953722e0478594b1811c3dae9045317750509d23601f978d21643805e04d7aee58eb8680c3d51db9b25163c803fdea33c0492399a65ecdc5fd7524706fbee2cf5add07d5d62cbecdf25f7a69ae6f29b2034fa280d40337fe68fe2fa173805225d2a5fa8fd4d6836d8b0c572d3295bd6ca18d524931a24bdafe2f7c29063f5ee097bc5b00fa03f8fec8103c02291671767551d1f22a0e6a9facc70fac58b3d62987ff25b390454f72dc7b90a3b808efcc1ff65f320adcbb65defb5d3765a05588f298c8b547be8573218d62aa3f6795c51867bf63f0ef3a718bed3abf44605ce3ccf8095c7ecf3c29676bb4127bed037a8b7adf7df3a342f6072d74441f4daa191b39b5eebd03a59f3580fbff1d5aa96647abb61d6c0748b1d03a353e94dd737d4a224328bda8f345e8c67bcfb5155304abdb47ff075b293483988fd691a5e275d12819198f7971cb5633eb71184b9524b3b68fe4873ce915a5c24ef686b640b7e2ea09dc455ab0545045dcf56733eeb211b44837a61de256eb35422bb99add46d52e8379a8a37094c6394d74716a4f191e6eb777872377ead4fde2abac777b8c3fcddf0b7200336e68f96b722a11ac1815e8c0cb8c97d0e7995df7cbdb74f990458ba50a18695ab233104770fab24138b5db884a492962beafdef9cadfd2037b811323736781ffa4cd3664369b15ebd72945cd500ec56b9ccbdd2b068d97464aab4f5de138277e1ba347421434a69213f72adda67c0b2d7e58a51b14560b03d05d38316281c09d86db8d05de4d2183d2de1140a0fd8f7585068f97b90cb9384f772c0b07855ee0eff5eef51f37f729169c3e86f4acec101a620f40b1d8d6cdb58b5e8cef6ec03a4090769b6968eb587e2ee139d138e7d9484c6faaba0d8d9a38c8bef8618e28a62d94d4a426bfbb6d4107d56fae8bb906a59ca97e70b6af2e4524e4b5ba18e454407efeb54102188410b28144c96f0cb270a3d6d5ae2c5c2e0425e7dedafdbcdcfd03eaac591e292057ea45ecc99aaf09534680fb6e493321c7efb92808d5429121482cb3b82d42da56791a075a41de0ca73d3a9bdc54866df605859b20a0175611601fd5da0344eaf4c10c5494702565a412f86a5a059851678132b22659520dc82310f6db9faa43037dfdeb22d89f6602fbfb8a087bc2c24857054f447f16312ec90e4021b8157080a896e7d64d35d8a1cc9a46e38b4d34a48a66d8bbdcd906106c9f6312b449a7dffc35e64ab1ede9e7a2e44522e9fc54736dc6f9e9e5f41712973de88e12bf9f6b303f596723617f3531f47a59ef4bc752652ef77ca3558d731610126249707916966e30cb65ec63a4706271a213e228cb6f1e1e048cf92974c500b333794532cfce8e7e3d0f160798cc0c92e1bd6fabeb606cd8c44d7fe5c261489f449ed0f8587ba42cd254b6dd4be53551914a23148af4d43f5e7a6e68fe84c67231bfe43fb534f7f6de47bfe3048b02e605873ec08a18eaedbf611229dcd7a7616053c1891bbc0499f78515f4336a7b924bd2a161c7c3f31dd78afd8f9aef8ab9e0ceeaf2da5ad31cb06f02547bbccaa569a090e90c2cbf014c2c7211b664de5fa6bba35b8b5c055fa73208a3df8ba8007c694f3084ec9171c8e7be2a65df74abc004ec1750d74a7fa1f1ffc531c721a8f10061ea7a56d976ed928cfd17583f40ea4932d4f24854d8c5e2fcf2ae70ee8619ffc3ee23b36a6de26da26dabf375e9e0b36574b7e7058aef029e6f6503a702d273c6809175501ef2e595b05df9b071a092dcb81fb99c571fdcbbe015a95b9c1deaa45f69518e26c5958c83d5671e1059b72714d4fb36510ef721a32e9ca098a039e59452f1cacfc58bd8af5b250d4d92ecb1ec412ce3fb40212e06054ac75a7d410777e1974d75e0669fe48d690c9516b5832c52db1abed0d57f4afd9aa71b29020d944a6ed2b39d1dce6dd89c630506280752c041e1eda08b0672239e119a5264d74d03093cb469b76a91d73c1a516bb6782282597b154e91c0ae35f050010f104bf7c7777aa688a58056e61c67cf91cc1f78a78e95b669f688f168b2d38b12ee95574e60d2e8fdc01cd3442d0b6d71e60e38d231a555952a7baebaec962449cf3182204027b2def184cd08d3a5823c7dbf0754d98003c8b686c6ea9cf7d8ee94344b35f98be150635e2826bb8b516c198e3af1cd365eaa30234c7ee694f898a7fc42157fbe76d3ec818f21862aa26b779d4c187d2abba1a26ec09d9d3275078c2b82eda1a943ff57ee0f0a7e674cec0f75f3c048c5ac21d42f46d74f15554b985072d27c5e7798975a234db1e7153cb862c6f01bcd1d1b2aa706e5e379f92ae97f36dd0a4532df518c0acb63479e07e43fce108f1564a3bf354bf4b732c7234ac7dc8d8f55644bf31f9235d700ac43fb42993797a8698f22124bbdb1665f36707396b037ad0502bd029c4d3c393e3ed4b445cee1297fe8166d753182256ec45d029ae6f344715d35a815a5a0356b2ac832de1cace591caf5afc4aef876e382c4de9ac4f401dffc3112964c91bdbaf3785c91d33ac2d9f87f7a454b2724a0165da2da72f6cbb4be3678a28d1d0182d306bd83d39a6f4239b34aaece9223feb29af7e9601275026fa025c6a1d47895c67ba8d8ceda4c45594a52660a41dfe303de0f10ff70621cdcc809b64386296e5912aea514660050b43a7e731f338e15441ed3934fdc95eb25c54efc6d24b98f21f6b2fd1589852f47da1eb0bb1f4343e796109406990b6bf746cb5a663fac7f2cd43e6d3c2decbb3708bc5d5b4b7420b2ea9ca77815774beb8daf54ea9470ed6a88b13d9607cff4e8442a98f73a894bfb5705d6872d0985cb36abb49c427346f31c98ae7f3a0188f33147a5f1fb78ce75651fc9e6970be401dc9fc104abe5eb0360c792cb9b8f96396abb7f4bb828a433931644dabc869c446d8ea637fc87d6a020b55ab71b6e9f9126a9ef0f20341cdb1534e3f32a5ee92909f0d55d7cd0883c218e8bbc87d73099b3fb458fd4e25921925850090e530a77ad7072df7a0d5b8a0742e64445d22173197d5d9fe1b45a44aec593672791a41d36aa5aec0e83cddc99527e3c6f21dee1f48f520eefeb89fbf7b88ce8d56e70f09d40237a0250272b67bd80aa2bbafdb91423ed3b0081ff4c4270ef985201d083a9b9375f0832c83c17e179cabec015220b5b4141b2412ea41ab190038e0451e0335dc2714b46e4ca80e5f8ae3da652eb5fb9bfc2fa85e667cac3b0e89bc2d0375e8b030a3b5ee7bb2c69a9388c65248b8c37e20b5bdfbe653d1bfac86ca254c4cd16f97f110e2d66f9826e90ca33c95e964560f5fc9da439fb262010b0ac5c3226ada83ffefb2a1b3e8c77ecff160819284a1d682aa3cef30f60a1a36eca9eb4fe8fddf6e7db99f99f85886ed864fae2ba0bad7c9b2b7a71037ff1b6e892d57455e139298562aa0ae74da98960d92d8b25b8af5a4cab9c39e3ff89a90e5ce416acc22a1753e34fe683240e0df140de908c571b660063de50347c6aa56c434d8775cd7fde840dd503413ebfe3d8e1967c7a7d09ca07574df99f6c5f5b8b2dbc6f061e570ab2c55a159401e7bf00c1fd88935161b57f471b2b43d1a850d6a8cf5e973abdc7a01dedcba10165142dd2683e29f11ce1cc899b5a47375d707b6521d62c5dc455214d9bbcbbe46c81cb44fea616020b51fdd9bab4340df457a672c5276594a2e77b00d89fd71412fbe33693d7cf77485cfb9cffc1b09a396ac7b5d4f459bbacfb77cf02a8d47c6bdf7da5d9925c8da4286b754299bf20ca1cc599117874998d1c291cf402e8a8e54d422fa4f051015bbbbfc71b7e505c999b01754fdb457bc8b3ffc44be3f86c083520e4be904c72e969cd52095df837df60c6c10bf286e2b6fd44ff05672205fe0b8ec25ab7686538f7d7658e696d90bc69adb3d7e56a3c0ed78711e6da524f8f29b39c49bdf175c49e606fd7b3a2c9736fe0bb0ee3eaf1616e318e94c7ed00e483eedad2d70e3ba8b8c107ef2dadb3a7ef33c1eb947d84b611b097dfc11256d9ef8fedbc11911d5ea107438b9d94e13bb263c1b30a9c62786722014cd256c810bbde4e2c8d7bdd910909afbea1e69cdd2caa63f7224ebf7eac129762ee58bfc6f9ccb090ebc73b71f1e0ee2a973b94f7d28f3de6b402e8f721480e0fbb5c834eb4944c51ab31e78aa8f2e2e38c77e7176fe926ff884e5ff093e130ea51f19ee07b7af27981f57a32d46269b97d44e194d60d57378f1eba9f15f11805c5b659621a3379d9738957eb91a1bbf75187afc5f608b3b7c4533bb6040d84e61d1fcaa0a309b305db19eab57696e4a9554394bfa4143a38e6a587e41d05dcac89a7ba350192468af4ef52ae6b67d9c64cbd1721b0f723770a4d3332087a9be6c6b6ad421c03d9a499bcfdb2ad3dab3110246f1d827d4220d4c8a7b1fdea0aef2dbb477ac9964665bf71d4283aa623b628367ef6b6478a1a74b849c23326874593a7c8c91dec36a858125d40a2f1b337e8bc5553f555a0a1610b86ff1455c21b83dcf68c51383721799cf2e6d4eee1e2a554523f8b25cfb737fb42af4d4cb9971c7b6d7844a357f9d389ef12cc076597892e1886c0568262fb5c29e6274da3396cc6efce77158f7a71d7cc22876e2bc03282db6df27b4e27eeb2a9022ce9b7e0a3f21091183c448c336f98ab74ccd5d5378eac2b185a749b185fb1e777d1840e93321f3e89ff1cd192fdc52279ba2008099b0841b2e8262196a558c0ea3d156700b50700f6dcb42f5275b054c519815bb1aadb9901c12ab161d270f6c38d215d95531e17570633d0280f8d16efa0822f02aa13df537948c861d826187f554063f1af2f8f1d1053e0794c2bf7b40633f8c9bbbc9b685628af8738ec751a3505256b727c874d5a3613a709e5824ccdac5c645c1de74f0c2ca124274aaa7463c07dc497b9cc67c2c83f524667c8e54131391f71a9356ea1023278bb7a9757960c2214a253938b95b158a1c216d429d87b4323efa4e1cfcf69db532be222125b4c0548ab1c90acde76eceb91acef58b9ea6ec9bb1771d8d370d68dee6399815cc35db4560cffb5cf97517516b690913cbb62511499109e07be72b1049a8358e99b6a45fe5526c377c2e12271a8b0d326541eec7dd18b3d2301e863c74cc829d3ad6dac7ead45d30433d9b3ed9c36022751b65c1c7afc478a8c453e644a9e29521a3b608b072cb0c45a339a8694c145b6984c1df19ccd62a2b6271cbf65d1a03bfa2c2d5cb93e74b28ae30e46acd19379bfa09dc4ffd8075dfd00529c7da0e91012cc772945689e72238cc8df8254a2a824f1947187c9778024d8ce3552cde70fd08091f15d9437fc59a04039faef426e087cd2322d8868d189d276a09b320ff3dd74f7e7a7da9fb312a1ecb8ef793190e25a69e6a33c8afa86aa82ca091bcf853dcacd0f36aecf4c3e9af6e02545fdb2c70fb3618cc21c513dbc748cf4d08a9e085daa8e1a41accae1371a9f101643392d83a127193721e1603cfd3f974fe99ffadd1890cd4c3f220c4c53a8b1e2d7316ebf9363599ee6d5cf195219f980491fc8145c1eeb1e111475ceac6cb0aa7184c63255a03e8926d9c954935afa3c90742b5211f9fd7ce209e8a7961916116fa63db9c24ffe1ee0bc02c0533328797aa698a06d5eafe4849f3d96c35967fed34a8bbd7ac47748642e1e5b131bb7ca45ac9c368f8284f6bfdc3413a1c9b981ec6643d14faf56f03a881d22d5a1fe68222f60edf0a035b675cee257560703451aff7abb8c06710efde577dd4f28144262a14f875df768b39d3c4efab178b87e7c58224e23f2bd86419df4760d80fed8a498860584637b9306575bec6dae01fb071597c31212a5214dffb853a11bf2c048c4c32c1b036852ab392610dc2528933210a5df66c7cf05a3ce75fce05f71db14f658b13b9656c6b7656e07717eb6121c0ed2ffab613de494c444f64c460de314b80656db08adf98cfcf2d37b4656e4d1b6db4f146335f7d77358c6753eed67cb9115dc935a5710462b4a60d8fbd11f0648f3cd5f709f494e287bd61fa6d64c8e6ab10be90f923b23eb50fb0d13a355e4fb59972dec37616320406acc8f0ef1d2c4bd279c2f2eef76d853b5b0ca3af2b8e1f1de84ed35dd5078780ce4594c4e40e2d1b7c4025368eec7551e37a9cd04951c2bf7dd4d05ee5e54a12e48da2db0587f0d571029b672e3fb9a3fd21985630fda5c248110085029f9a306e913947baa83f141ae057467f8e56b77e11d1a8d358b1caa81a1da418b49fcfe240f0c84d41f303a69e79530a57b536c4fd80caf7778f1118d811b4be89be4a4e0634b27eea01a1581920b4a108007074a82501f3bc760536344600aacf385c4a0543df39e8254c3ed32bfbc1d2fa65a6357cfecfb3e2c6efdfa3eb3d3f3c200649addaf8924d5abbf403238a70b28534a697e56cefcbe53ab6bd4503b136df7d1a7cf6c7dbce2182fe391e4b9fe2daebdfd65dfe09355dadea4e0c7b01d2011bb07499ee94154c7e5b646786d2b360dbfb4c63dfc5628c89a478f7ed43159b25aa584b9de3065fd5b44e363521c7a5bd848ef1e9b3188c92e00f1937dd8343373a2127e0c0f126827dcf1f57897f4cb77b45bda0a18523efa6a5238c924a1a9bf35b64e0199a111b1621f27f549efdaf9f64aa7a3fe61a960ddff81fe885044ad38cbe09a7180bc1fa9f11de3e1c4dd3b1e97957feef204e119adba3fc7468a19b55e9f8936134d2bb23836667a210bb8d3513cf485b0c10503f3a27de4592418bbd181ea14880c8b0a7aeec2b1c3aa348e3e790902e2398ce74aa10990e12277464e55a9c4288a9114834eb679d838fd8cc6ef30e5ca690265c2c1d0238da449fb6159d7689fe70ff2576a74c578c1dc59cb05a8bf4ccadc8feec5c0c587c86baf44aed237455d800b0b1c65453f473c32fdef0b4fc3e2384e011e9281991d7734e4e3d45a9cf0ea2d848ca874fd5297fde450cddf699886b042dd8737e8692b265b07f91d760937ff0cb3a7fa2c11b7b1c2509cf7abed407a365cd45f1d8566ca248a60904ee3871a904a1d967be75e433dd0fde3478031a9b9285f80f254791984c68da98b014f72a4027c6ce99a8a0432171f2e0b23a4bf66c6c8c0660d29b18565601a64cf141e271946394610e7b0e2b212166727fcd48e540e15dd08664a5ebd8e5279f1679c71c638791c0544cbb27cc1480567a6d63359fbc0dcc3a8359a32afe13fabb40fde4671fe171cbc13a96c6475b2fec41c8758a0cd49441891fb01a02b77991aaa16385b5e85fee58aa225063fcebbbeaf56cc4c8a6e3d637e856802445528dccd24cae0532576279f733c515f8db2b74a83534bc09214c24085e88ecb4843837ba5e80dada0310590d76b90dd2dde5a9589f9d223803afe605fba11697d382e911c9788586476e1e491d1b0d5a0f39f7477cc31f401422ab4a6119ba541c00d43cf644cdf0798ac56a30b7c78134ce92eb10e3112543173407c5880e565f2f7715d5de34bc988b1c723f1cc8e87cbe0cac3c4e8ce384b9eba0190ca79236eda67eb99989fa7279cc86760a25b878aa4501cfd907ebe12292e89a76f7a83448e69c93eb84c3f8dcacec1e0c7b6cb442fddb71c7c7ae1c3c3d85df9fbb8646962032fcd923925402fe7db8b598eece045ff67f28256b60917e82a34195f90c509d0ec40a79ec7cdab286a7e8753b95964db53e1c2301f0bc3d7bbc6b054c0113d59b4e5ed815d4055e6c7a62e528a1f196466a457d366997eb8ecf8a1dd57cae8d5bef1762835a20fdb58bea6d624bb5caee621c9aec0ce818f9ba6c35cecc0669aa835f94932e8e67b46ee23171c1eebf0a422179e7f7de3741b70a2df742114461fe8c2c7be1642f28728db3279ef798f8a805122813038d0da09b95dca3a562d8b6568e9416ae634f90b867308d33c9fcbfb0bc911a32e51304364c305081734bbc9deeeb37ef4e6aded04b16681807f5493df660ccff772751eda56ae3c776ca8c40d3665c687e3050c548de455270a75919218bafe4c5b6c11c999f94dfda523b8a8213b425548cf73ac52562ae2ee4abd60ede607009117fb8290d0ff2a2b0d2da7b11f0a60130ec0f3190453efe0a2e0b52debc7b4fbfd236d000a5fe8e6e7f57f2872f35b0a111562891370618ce9d53ccfe4cddaf5e3d49f393547549ce288efe1d96e24a3ff88919f083dd2113645d96a3c76349c9baa711c64b7bd942f4b0fd588132b8f3843119394c71eed3a80e6ddc3104609224d5f12f81fe487b3111700b12be6bce870c949a501fdaee1d740ccdc2d7f8f17340d58f90e60923192b0913b61a31e180168b89df82bc03d76d4b2f7251eb99a79168cea27939c70b49665765452953f05b33383407e28426d63d35530a273feb878d79f80e1a024f838264bfb0b053216fa5638374402628d36f6d5523f2940b021678fb5daba11ba709e2b43bfef2c374c3fa2ef9fd39155de22030b1d7a42a1f5288fdf1d72a9b713c8c5fc5e264bebc38427cdefa38ac3cc91f5649f9cd47e92056c7190a346399c52c90d73a4726ea23369f6f76611b5f5ef7d6676cccce9f5fe209841616f6687a6d934c3a14b9736399afbe15829cb2dd066aa907acb9d3d7802b7a242036c090b3f8fe4ddee4950814e98d530facf601448d4d93003fa110731e58bcc770d2b488c17cb26566a88177f5e792e1d716542b70dd572529cb82a536140c727a035ceadf0704ddf7bc5919e9185f229cfbd242fe02c771be5e62ca185acb9dd2fdc35b55d65885a7c727d1c2018bcdd6e31a4596b948d2ffecd7eeed5801d7c1c837e0b39a4c3db93298d49db99f9cfd78e708c6122d5e36c89bd9c74c78fd3948309d084ae3f6f163e9612e4279d3dbe77adbb391479f2827578f6f935698f40d292dbf5aaf838e07c77c0646c2d6eaa35a744df15673c0424c08b0de0fc2896e934ce398d5032b9e48b9be3bbd0a17b1ea4f039ddee545aef10162492a328b3140cc9d435c6a58df48a57dc800ece93d14cb4982669b303721dca517cd552943175527e5e49a889d02e9ad43af1f22c43c23e26bf7abd397f925d670d578feb2db3d9ad6425abc99b94dea44001cc2e4af6a55016e3f87a7092b4ca394711d4d8f0d4e51b02b19a3ea9d91b3a85d139a2a7bfad1e6c473bef1442a7240b51822499d0e040bed29c9b792b68f173d1d5c4aa53c5b8ffc568c449e609bf6f011d21af63568b3a559b40a659b3d6573162b0a1d194c3e0baaf7bb20b62c0cbc7d45bb18866f0fd1a70e94bd7b02e9652ca912d93e3a53e9b46d6576afdf0f661846b26c8e4a607e0dc44b7fa50060a9160863910dbd0a26d7f7d7c7daf048c4b2eee96041812c3785ae6af01f64a5c735dad2aca4b934787b3ed2ffdb32d6858644d1c60aba40b52a3a68e66ff879851d7322d94e216d4bb8f0cd810fe7bcd0589d1257cf520c66fb2a17d9382f944f13bd59fa891ec02cfbf62224f1e10e7c5edb19af741f77638ec54619c40c491146eeae85b2bb2b4bcfc9175527dcdc7ed6287cd5c18ac5b021e2f236036a753b9c644131e18e0548f1246f969bdfed7d81c9e052d70b98beaf068b1c4bc1444c64cd96be811fb115fc3ee29e3f4c8453ba99a5f04808c510b9774091d7cf36b036c2d192aed3ccf134162e0891e72f3cbb8045e02d623a9bdfcda50eabf472bfa56b0efc7fba11c9d403f95f075217fd291b1ab00520affb0df3a0013ce89f9ff9a000ff5a12e627cb2cdb4e0e51111038c1870245da3afdeeab381295a1ed1b9f79889f61ffb2c7c401e8caa144fa9580f88fa5609c5107dd14bbe02ada9125d2ebbf97b30c932d3a2a07f8305ded52b5311e7dbacf96057986f0aa72413a7a19088831e8f14d3b577daa3bb4d2c4f5af09008d1ec5e7cac64c9a8904fc1ee1d16ae7df0e8243850f431747b2bf943287ec96bcb4129db699b2380ad479dcd6b3822453fe0ad1b6fe89f9f694792303c5c238181fe265db113a1ca14ac4b983726e24314dfa946a6f693d9be0c6a7e49e4a974ca36b85712773c7d56a8b3b174414b1f04a31a26d07a91e1b93e56d889252982847b545027d53b619ef246586f82a3818910e0b8e836b9ba90d6c936df8533b2e305d6cae5f921e7d6da1cdaf12244c2d9ab13dc4a90bd32134a8294259023b1b5263c197ba18208ec32c9f6395d18b09978ddcbfeb1c22aaa696bd97b68d78f65ce2388b03d2f230902e549af41c6baca242c0a7d1bd711fe03d9691f5f713480f9ceac953faa629bad16454e4604c4b3b7f41a10d7bc09d731db43a3e04a57f8e3fc1254b9ca96a3d7c1fbfc977394925827dffcedc1701ffe5bf469c60924ee00ec9edbdc0bebdc644a6d429c917327df2cb4a935b71fbf5bf1a05380e7ed3eae555da5cc936527c902db62851805aed7b7d7e70a5684d51f70bedf5e7adb95ad218bfbe7a10768a960fa27119dc28b5861a6355f7d2dabaa02efe66b77bc3bf6971ccb5353a42e9135e12f8939cd955b2cbfa6a72affb690b086989d2975db09fca474885fb537dd7a9c94d893d0a549c3893f0fa846cbd7063af81affde0c7c0ae87f5664d9758d2729b17f4385a091498cfc8e2604f4a991f431c94dd3871a2b8f8516ddcb206eacc3ff0279c4aa3d89c208cecb79455e01895509a50353c8aa9013a2e742f958cb5966ce25784cda744ad9fd40b7925f8c3a247d7be3a6bc90b8bd049c41d1e200cd72b7d4f3f43a3c3de26ceaad5412b64ea3d1d1e593fd10f822bca0dd5c248eaaf66bf9225fab52616368680099154ab060cc5ee9cc6ad3594cede565cf6d82b6a82e6dc4a793ac580282c0a8a450e8240f0b6c6a5798e79b999276baf19f81ce46f10a37049b5d5f18bd37f8a68852d12693dd679df14463ad9582061996773a45fdd1f5ce81044df8568a62ae645f152422a29a9f61107068c562b0957ee183dbbd8c66e69a4b4eebaebfa3a09a0a74671879b14526dde113964a17a2c46fd7f6e6f1dba6d44296ffda9fe5ebd37cf6432ebc7bad3e70b8e355fe0a5fadf99efeba64637ee617832f15097fa811debde9af7c1056f74f964785d3934368771a8a8a8a241166130737045aced7eead68cce32cd8576140065dd5a471f301b449e0b5ded6180d5644a374654edd6c7333781b3e7e49923b040f53a140f186dd2ad0726b58226d4bd7168e7846a58b5bde4009f0d70786cb48632ddeb69593b71f7846c964d00e5c1ed7ebe45c3f7fb2266c98723c6af796e7a341e4dd17ff92cf852f9472d1fd03713223adacc087792466d7f61e8bc16a08a880f99465270ec9ad3cf28fbdefaa69b0344f256c3acc436e5d8d6a1e3879e2582885e38d1b4ddf292d0df1d1abc6159a0339280aca45c0389f828e7826e61bd0d506e4c268bcbf7b259443d2c913e13e7c841773c305a7e02cea4a187b0b808c2a1fe48662fa3559aeb21c9b4e21b2ce41a845de21d47a92e8b0de7d50d5e769c3ed6e222a4a8462d21aef94b52d9834e9c43a462cd859bcfb92ab7f6f4b176a3499399095271329a1ef860292e3f62e06753a1c8c5e6a73e4e36352596950c09e9dd515e961db57e4c56d28f82b9de2064913a4d5cff2ca0efaa17e9a4a7045d0fa1751432cbfc771787e033112bfc3ccc4746f52cc647b9e579d21dfbe450a9b59fed89ee81f6f91f2bb45690fcf6a91623d7c28315a5906d7ef969a90be2626e7afc24977435836f555d92b78072059b946b7d5aeea234c74d0849cd5dc3ab74ff920faf7e2bb79cf53102cba76d4aea440012fb7ed2c23e131f9b87ed9a8cf32ba16856a19ffb0bc146581e89c4d2e1d3f74258a84eafc6ef86f17468c036c8728138abc33dfcdfd2ca1be83b0fdd3f7a959c68fe5e1c1360f53c53c881f45b9f140f29d2f179d30cd7eb47beab3ea202922cdb74797c342c5f91ba360c4f937d58cd14b2a19f2697e59ddda6283c7f60b48229382ecd1887959b3ed3b05dfd62f0f559198372f08bb1440e2a4313594449bc7aea0a1fe738993a131d2e13d3d2eec3c44b3255d6ac350b2343f17ff36d3cd6f00b1787eb4fd04478b4d6d1bb79a1e456eafa104282db26ce2935fecc76fe3ee85a4f5e8ef4c4d9572d23ac56344ec0cf6ea2e3a7c1e067a3b98b7cf815703b8ddd4a1e1a9cf410ddcde1a91de4a3338958ee676cfd32b937bc1445eaefe8119466eaf325bc70ca815e784b1a0ecb90da21fd0e018d0ff5fe61b9d1a1129fec18cff81fbf584bbda7062f680505cd1be7486628474c2d9616095be5447084b4c2954c03d17ad6b0886e7eecd8486e045a0b93c07048a1e2fe6eb0420f37b808a0349a636ae83d92f6e1e55a1e90fc6e5c007367299cbc942375405eb2c7cc5896abf6408a2a9f328a62c56918c92a52b1696dd76f1c55a257ad017ce49af11d50c4e7cd8a872626c9b3e5b4e75fcae695a2d84c9b3960ab952612cc47e5a92b413c50aa2d3d96464ced320fa9882f3666451c33bb99f4b295041c0ae37a4f783517666658d8ff7cbb8d149cd6dd51db5e1c4f4c34b74506bb55861437dccbc8ecf8c41997b8160a48a93d97ff5c86d8559cf91dbfa80dd3fe3bdf5102a53ec7fedab927fa9251df38f798d1be8d099c3cdc0602e073e18581108a34adb2c6f3d69ef667366d6b52da990f1c31db97302e5ac1c62d55b8b33b03466df8b610d9f47ea1cbb2baf4da18bc40c909494ab49022a5c0b3f945b75762e7b8ecefae5437365be1c88717d73ab9850ba18bb01d9a8374a60147a0f4541ea205a934159d320a0ba062f6004e9485bb3454da710d92a94bfe5f9cfc92da702fbbcb140bf56465754d5cf4a256641f6752138d095b06ba3fca8cdee32a478a53350f5bd0fa61a55f76a72da64775daf989cc00a25ae3f8895ae4c2e46765ce806c87b093de71d569a3d142f371eb372c30e46c46bc753fce688ee8a6088ae7d7112dd1bd38c73b70a954806ac60f81aba7083f87e3a39153f9d3d3a6eb2da4dd7476f64e305e8435259482772151fc20547ca22b71a7b564315811574222ede056998985f48c0a9a85be7e4233d6462cf8c7d630a0a6611202e6beb4d7518ea33eb74bc0a3e7a063b594bbae1ebcf785d4daa8ef4b5ab381290d75150a018c3c367e0033fa548f63b5e190903e1969011ef5c7f44b84e7d599179726a56ba5c29d2db6cf48a8b0b87c3350ef1fac7a98acbc28c3897be0076266c0e720bf7d2a80bd04ebc734dabbe5e361ab660928ba58e374f79e95935a972aec8cdc61a2a70e83e0a7f1610802d5406f092c74d2bfdd573e1d9cf026968c55da1a165f9de1885f206ef0e9f4e5dfd1e665d69ccdb2750ebc04ed5adc34438804d55fe4c7440f7691a3753959d73232a26f6fba5ac7e5f4b7b4611ae3b44878f81f2c09e29a7bea31131768194ee6e48cb7165d09f433bc5362a84157fd18d0e7a22c7ca82500c84bc710a4eba6e8e850d9115e0b1b1e7a5822ae6789cedf0b6c1192aea685bd7b735aa1a37b60e5d06d8fc9c19f7815920a5e2e370254f1cd772e39a75baff9300f240d24c611bb0ad69fbcef5fbdc557d9bac8b95b3756f4e15b6b4af9792dc3e44616358dc0226ebdebd7aa87030b6ae4ca70c02e71fb5946f2b7d697d663c18e738eee79faeadf9b4b0c2e0ef2522e1547bf0309bdebe1f9e98b48b744405c04989bb20d2429f85d8c6c0bd7d1f3ee68133524871f96ddbfc1901bc73a849b80f225c35f30b40a0db06cc4afe3f4624f8458313ef36a4bead9edf1d54f388195fb7e5af7bba44ef0f93808dfd85073bdedf108aab8bfa2e32cb77675779447ee30df64f5e8cb6dd7a7a8ab5805bcd5804aa7b4ba5e425771322c7fb027b6f86e89c34c7f769ec7fbd0e68e54d578d6885d05cb6e64cb52a71363842663db2b40dc15b46cf542ec90911be3c5b43fada5e5f06f7527ff5b3eaeee3d91a4bc9165a0ecfcd06523f3b1ae612f30f496572c87e105c53d95934819fa16cd2d7d5c2136b74f896025dc17bc7477aa6787a59b21360a62645589634bfa8772823a152500c909778432466af06663d370488bac6027d758751a7313d1c9e8394d8ff2009ec157bbf6a3246f553c5e1c9550cedc633f3c834421ca248dbc8df6c802810673bba83811a809b88538bcb5e609a6d3a7936c82f5f109395cbc2b310cf4d4bea2342fd25144c8f3de98e1ac9fa98921e8575d475097442bef24b6f5e34e0cc2e734f5dff56d6961a2004dc9468a8cff025c8856a0d0364abd835ea2f1f7dcf3a1a5f8e52b25e8b9b76b70102823d640dcb9f4655d6b842a77bf678df6c3e2a57f6a379fd029983fd079cfae682ccbedb0a5968417e412cab11618d09c411ba2fc6e518891d5ac2033c96d3e260e39b90473d91763208ab5b4f17fab9e7f05be967edfbc3f2984ec7626e5a57fd02f69fc231ff77596b04ad865afef3b57eff26eff28c8fcdfe57081eb8d37ffedec5c6678ac128f2a73058d344faebd7939f52add875e98f6035315e4e13494472e83c627168a8f9728518342dd7a7e7d0c198e72585f440f47318656e8caecf547a252a4557ad4c5001270ac1b962dcc4d6fb45bf8c6ae0b2ade79f22a4981fba3f8b2aa60233e3f4a8cd193b5d13201947b44de61ebf0a8b1dfb65382b9ea7d403c920cc2430f376ed844209154aafb1033d93a7f5896553bd54d6012bbb7ee7a2352727a1280980388f47732af165e0dcb7940655b0ed214b99574cfa86d2dcedfc9dc311e0d6705a40a4e4cb603c8ef0d65db2899fb682341f72537dae1213cfb00e0ce448f50ea11d2df6c9a68ca87358088b13034904e73f52431963f0c084107ba8fe337104df4d6bebfe6647dd8680d5dbf1641264788b586029fa4efa0ee4e3b1f803ced8e4872c427676c84303b6bcd1b14c7e4602df2bd36bf297bbf1968813af42b1eb2c913947a9e8695943762d2c826ef3858971ba4aaaafd4c994d649161419009b4bd15abf6ee5daac8f017407949f873d32c4d35422b057d55116a94485576c71ab28046ca3676e933c8db48ac1531d3d3ed0a9e6ad548c26fb7066c2bec78c6106356beb1611d23041f97028765e68846b72746798a5b31998613bd4d2efd5c3a802315f2e2fed7bdd11e9525de502034417c2a4cbc1b6c32caf49aafec8a79b0a093cdfd532d3d6b467736a4bd3c20fe8f493cf97782cab78240c7a099ec8ba59cb2b0f5ef845b5e56c151889a6bfae78a8d6861e7d34e8f84930234add133f7fd6b6279487c4972c9b835bc24f68363d2c8556fbf1080824e76ed36847215fe3ac070efdb0c151f8919abbd16a106eed923c43926f6aa0d271c0a280833e7f59ea068098e4621af03786927db9c60255d09d6b20aeb3f6cc1b20213b249f3a877db6173c1a3989b2d3fc8283400b59a4d6e14db2ae82b3b3f16ea1a97f7fb36d0d1712f071f77d5048fe89af916bbfdb223be3c48789277d9d147140ca35cb0a2b64399c70d7cc5d0bfd4d06be670c5687bdd49a0d190f052b03857d1a2cdea6cb73e21b3cadac27fabf132d6b12d41e81bf59e14a078213cde38a6cd288cee7063a25cbac7c650748a35b668abc2f2c755c6291d467d5632a4c1930d25eb26bdb561d67369c0194ba901be0063d57a024fd4cbf14171c64cf4b09152caf1e64d4c1030af33b95f7802add1c2aa4ff00e9b8e8516946e12b3e569f57a5b13fe45854976055b1feeead42475dac329b9ca7bc22010d71121b6431c9d9e9bd0644f0c8d8740912816e1be077a8930e8308f74e460da3dd13e816c0eeacf5689d0f5bd067a69b633490cdf11427a9d2a1ff71a38c562c3f742e43982069ddb8111a82f34b27026c877afea1d43a8c8f26245f18326aef2d416cc6fbf3e0674f638108ae0be7e8a7f9ad3414657650878adbf048a7ca48d1e4e4a3cbde9661c02023b531ef3e933d1e0969818d12409734d546e8bf38ad46f63f50dd7ef54e669438dd7889aa9e58710cda3a5b2ce362eef095b25855be00185fc4a0388d43e90ce8479a2896ae3527f17e8b9bfe5d1663136d36e38226453e9ce8ed2ea39ad67f72e8596bc84a3e010008a03d18f3703cbfc783baef51ca0ca10c3e78b001d511f66e6041b6317e6f4820c56754adb50341906f2c81036be7c95bf7485fd7d30c58fa0dd9fd0b8e88aa3de2feb55cd4cabd6e763105d65102532404bb60347a2eb4e565c857257d34a6975967867eb8a1244058c79757d10c86b335dc86dfecc2fee6b0290a79eebfe541537abae208145b61a4f2b699e9bc6aac590b7f2ef01d55242d271bdb14a4db6b1451a3080b7f1fec87cabcc1d4cdd72e18b00d71c8bdbfc09a55f243ebc186ee58771503c1f4e7242f64d626c3df09e93064f8979c028c24fa5d62e0956981141740baa8c2da0574dbd0908cc3bc4906956b96e08c8b8e20bcf73d6bbb56adc2555a952c9019bcde0e67cbadec214465a4583e05d2d3ffbca89adcd6c3af982983e3bcce9e74931af378f69d4e60337f0b70b22794e6510f2176ff89b17977c4f75babba0a87ef66853bf6c39bc3a3a8083faa70f712164ae92ee36b1244f9a12f215b005e597fd96346ebd7ac29cef794c230605a8078cbf6e46710880e19c5ec80eb95c6613bf1b9d3434ce9e47a1f26ccd35e005b44d9c4cb558456f83bbfc1b10237ed6bf2a0a3501a4363eb23f8250dc8294b841e47305b5e60a83f51b69bac6f9114046d666860c9d51f294bbf9e7b617de7b154096b84e108549aa476bcca7d5b2c90a790b2ab27f4c0e1bc6f2ba6bbb7f00c81a65e3f6d003446027a233177aea49da2e500d4f663d8a38f7f3e74cfc259a714b28e7622db92ff4661394fe31f54cbe4fcf5a465f1aae926ebbef842eeea353726de78d589f86c9088499c8771f84ec23b5ac5c9d079e96644ef1568c7aabaa0f55a13bd89aad84524c6a2a2b1d6c3c07f755e116f35162ff6bb9cdecdec61d2ba7f8364de4ddc913cad40c5be4015867a15e6d3caf151e3d3044ae689b9f34330634a941d0479d4465ff28a7ccc970304588d0f1563fe796420ade010962c825e2b941cff8c80e61efc62f877fb0deeecc1efd7884dfc132eaaba04628db45f4a5624f4fe512c706cccf23fc249a1ab6b8e53b8e5d8eab2a748309289ed9e11822f690699a707347aa1cc0c58b97bb91202c3ce4b734766f67c2d997becc8dc44009befda38d352e6673ea68879a76b4771f51f187d2e882d675ecb76a87c01e42d274a80559080163c180b13d92b7f30fc3a4fc06fea297c86b6a01a2dbbd4ec4190f9cf358621469966e7a101fc3a0c41d52a2d56485b40728e498397cfe6562e0819c6ad044b514529db1ecdfe750795eaa65cac1872a053f7022a33c256a49ab69ef4778da26f6fa43130e08180d512e69bbe1f48d8dbcb07fb38b19171aa45af7098a42eb9015d8a56bc32dbea297380c15c82a39221d098fb1f2dfdff2dc35bb98d9434e660df211296c71447131f5003219a0febf220a9ef04fa22ae3330d6dea1d0b87b3f87d6358beef5c5ca87dfa51964d0da10ce1905afbaf46e70acc658c8ccef57dfe3718fd64538bd5e27cafc1e4a4cd7ee4f8902dce8c4fe0f1c08471d39fb9cceeec7b229e7dbadadaa6ccd9bf5672259e22dd505a117caa8bd14ff04b374caba68f4c8c303ac6d935a705f2a9bf27dc1ae88f5b458bfe0871416b4f67fa9819ab1646124594c53e4c1d2f2092ad5ff231ab9f4a0b8bcefa1b2b4effae3eaa1e538600d07da033e773165319232d441ed9aa20225ce41e1f84745e250a2830f5623c0ffea491c5026c4bef4c2c1f3e2deafacdc8909e366bda88c1b642e158a03ea889706b724664a2315a362ae7b1dc02ca4a03f6e503fe2f9fe9e58af52c7d783e403c4df806e1621fe06285b0d818f6f7ff266a30020257e0ee27edb9f856e945be34f340d6e68c606c3b66728bd87c0e7f3db7e59ba93613b8191fe2fd1f543552f1c89b84206bc4f99e440a90777760a81a5c120f7cf0a781d996edb7d85a8f0662eb218f8890c21596a48e9a8fe5bb1a0d1a284aa544c1cf3747117da92b47a7be99729379e48dcd3bc9bcfc0497a61f0f230b929971b2b285fd15148ff153a041f14539eda6b866ccebb34c08bb4f8b0dbf81216c67f72f4ba03266e60d0035a9a2b34e1a44a30029189da1c6328841c93ccb89493959f38968a9d43f4209ea8c3efdbdadda8750194d82788af927d7217de56387c779f7f0e349a6e8269a93b52e014da454f7f334f840a4ad242435eeb1f155925ae8212f58b5733a7560aaf8d79e20a53229b924a84f6f3c3f65ddf9dbf8613fd9b4bd355fae9816638b5873a6781b0ee127f2c2f30f091bf2a1f8056f98db81d7660693ef927ac291ee8a095962b5c8b6eb129cff3a12480e92b5463967815ea65be039d928a8e13fdb30a67c38325cd5ba8a6654510bb67661a84c93eeed4083202d028c61772dfcd0e0c4de360cf91dc3008f36a9ede0ff8e26542673901dcfab21c10e8dc8bdd775d3976343775a96b071dd5effdc071dd2e82832f269987f2866f8094c5304e6a9d8da5c1a05c4f436cceda72d17f5ac886fc4126a5ff83adc364ca6225109cfc4ec2aac3f691a2b395899d2dd6b3170c55d8b7a7408ce963381f18b46d92f24b9e940d2647efeae85b6cf6f7f61c97f9a7b52fbc6c3a0cb52c28649bf12b5dfdc615a2c817c0bb65db6bfbb974573f5880abfc0b87a21ca1c609638f11197735671d71ee314971b286cb10ee6232ac12cf5ee9e59c705e13915c19638332bb48ea91d371f7e25e2e8dd481f41026aca2f5463dbb4f9855e4ad2f26d484a5460cdd95e81f628606a8cb0fe785da48bb35347fc5383fbc66ca0e5a975bc54857b1039cd6ad0975207de1fcd8db0515be9dec6c9e24c4fd526851236972ab2de51514c9412086af583f0e5d2806b6daedadd10a01a531b9a86825f3b8b89420dbfd4fd3070216b51f658ec336207f75eb76ba9e53e54b53ce7718808ad6c6445ddc6d982216495e7f0fa928e1ed9ca632b0317c3159a2ae297f92a57e2bb1445dff9b3de798d2afec2f8ab584030c6900dbcc3a9f7b9e5b3d981542cf4015f2877666ed8df1ae77eceba6130f5b247454eeefac753d42d2390e4fc0e0455088c5a5f18577cb76d86e62584e340aaebd704c7a1822d139f8fdab45d68097a8598bde94f05ea1349656a197fdb8e5493e10c46ef7b4147e9899f39ac474c366cb575497885fa229de92e7d99f5e88c6bfa2b0c5c9bda6c811625c66cba9904dc64ed3800d069ed31877fe15f672696b1b451914394b10570bc7adc387d6ed2251834b5a9fb5a55bcd6156680d369e9a86dccdb9babbfc01ebc2ef9d472b4412322f3a8406e68454e327504708723dd2be4b8f5cbd538a5aa10f421160ada77acd82b6edd1ffbcc67a739a5c169539cd3edbd12fbc28fadebc6f63e3896a0171d9985cd4235017ab46fe6c5ee8a6357ed652162b066687bbcc29d1076f38d0f27240eb3bb35fa6a48b99c4f2a1a77197dab0e0555f23c445ae6f068198438e4a35b45144d8c3ba382e1891d9f1bd0f3626f6dcd114eb3f319d621d4b9753e943aa524c7ad0f05b7ebf95529bad78212e2425edf11f3296dd85d3c223b019f64ce192e919226ac18b8554d9a2603f811689c12bca269cb793caa10423a163f044d4b2fa928c00b53c6382b7a5907dc244dbbbed47f5693cd092c04d11c03684b39b2183d6288149ccda75844c2e9edde0bda5f4c59485ebdedf6d9296fb88f01691641b6e61ceac8a7550437d59d47ed3a63a62a6be053297ce60ca12c1774afaf7748cedc4db0448a5f18c2a388a6a8786bf7b3b31de3a6bbaf96912928b9787ebac34e1532284896c74e445140a794b35b61652b300ad40caa9b9e9bff518f18394f649757b67fa4e523ac59e211da049cfe840e74226b422e26c31c8d6a3584fd1517ffa567c8e773a5a3739613d53af525cb0c3d725fdbeba005a78006048332980a7572a0d2b2faffdd3422695044b9912d3ea1f2667ff2ffef36af2e8083decfbb8c6d842bb3d37032539a79321b57d8c6a56a9edbfff91a29338ed8c0bfd4fb65e56dccabc6857b97696f5c6c09a18e060f23aa049d4cdb9dab103347fb2e58cf0a1f0b7d48ea7ad7d9d145c21c0f458d8ce787a5a138aa347e702963db44f6f49b4af56e5fa79a48a5a7be1937849132f01693056960b8b503eaf224ac6503652c120b7046db8d0ff9d0101fa4f6281c6f338df60725bc0c51c75e702d8dd71217373f62a8e545b66c38858f893e5faa1b9ebc8150ff4d02c4d1d8d27223778e77b17deb11ded0b3feedea1066c883e2a4b458275109e5520efe0a43190e23f3d22146e16485963c5a4446442bd02553fd8e01c4e966c6177678ef40cb9f06f2a1d3693152fcaac17e4dddedd66ed32f67a63f401c916f769b4240e76555c2c508c1b6940b1155a2a1ac6a93a316c7d5174c10da89647295855810288979ef1f611b497a5de96fd6d7426d330538cb57c1716df5396357b5b4ef946ab4ad8da8cb63f1642a1754330f801836478e2072e33d06a36695c4a9061dbc3f0796efe1aee4541b125425f8414e12b45217286829e462bddb5c073589851c2089cfd74b485d4cd30553437e4ab26fe7a8d0869f2117ec58616836491f28c2457da22e9d6d1456d257d746b8ecc1cf61d609454c968e92d87a9c00f07c75aa255a4a29a80ed94ba8d15608e3d777efa91628c9a85aa37acfee78a10040315bdd394862303b1cd8ba5dd89e24f8709d57bb588fae78c839914c1e8c958c604b06f6ee616f8f5dfff6571032a3aeb2dc1b91221e5bd859409af63d6f639662ac110b510b45a072b6e78110094eb8c4217063f472f13a330a0365da44ab79966ac4ec47370f5ebf28b516a7c4f0540d9d248e6fd5a91856a6d61fce40842d0ff03ee864735f3ec0060d62e18c299653f6b0ce97a1df4d182d5850f4445fc3df2e454fe09932119535d88f5fcef0abbd5f8a572201703ccdd91c3bcaaf80c9356d4aa6fec7f400532d5679345267c807aecc90cd9b34da77f1d4dcbfe1abeaadc459c22fdca941121642924fb74a469c8aabf2629a9c31a36610884313ea28a81178d01f64279e275c2d1f422e0d65916ca20122c6f9bb741061e078a80f32ce1df3d472c55a535bfd7bf9c2fe19775536f4b6696d3014f114ec337e1ba636c9550750fdc8430f1df7389d2237f263e9dfba2c54a57e57512af079195fa748e07730b0779348a3a693b0c4b99397f91d37810eaea9bf64b12ff602a80d8ad99f6603a41a84d5d01e8691dba8c51f966d1f51c09f1fe5be695b4136023c743cda9fd1a8f20c111b10438c75c169cad162331dc7cb4444519e73d1c4af5fa10aef63a94c19f09b3739bb3a1cfe097cfc4019dd0fcb819626f8eb6d7480de4a3d6dbb19093b6bde8261beb6ada84cc6da6b7dc0411a127f3e94a0bd09d38457964053566e9b278e4edd4d43e17fce582b0d0dcda1b9e704a568ec1fffe1ad4b379c789e62bf6ee0e5e5a4366e6c6c47e8cf67438d55ac6ddb7c1c9ddfa6a77fe0628cf8e92c750f185fc9e09e920448e54899bd0975a7d078dc322fadbcd012d69460698da2b1d31fd4d9f5418a41e472aed90fd8fe2ded2faf7b153f817803d99cf8a4374dcd55f1b140f2d66b246ec45d3ddea768d37d8618996c0ab6d7aa61d96e0e347ee4f20dfc1171ea9e8ef27857982fb18872f4fd14184aff0741178c23a98cff4b299a2c422c324e3aabc1f39656b20cd9dd4d9bdce69e9bfb868c11fd5b527ea148f1622d56d14447263faacbc9cc6294cf346ff7bc3aa51b20181076c8a3f049bf1792725cebde73d94f8462d08bb39745d977b62b9040f9cc82219a4485ad9633d1de005361a24c780e72f71e918bc0cf2c1d9461c8ccbddbd61ec1e58fe42b45b0376d507031402fec9d1d2d56874cdf7ec784cc55e2f91f789ab75b58780a27359ca1496db382bf778a866e434e41741c85be1a0ef3f5233ba756d7caef005cc7ca2f0fd48fec7ccc7f9145fb18dd01ac0a16743cffb9ab53ce9dfcc32435da816c0278757d5bbba706393a3663acd5abc999054640751bcd060095f65c8e5fe90ead7f08712db5eb58098eedf59d3d5913f2bb64d9564d47866b908c7c3c2663490e6b7cd814439776e4b721c1f4a7864bf5d00527159f8cc5e4751b44ab083462089770b32d0cb8dff426ee32927ad078e403fd410edf07c77a1e91ceca7d7d981add270148297f290b8c8dc49fb0efe4aabe9239e24d68832e6ca723bea7ad83a9645b0dc6df5a689080c4009170d51665cc80aee23e08391bbf3e8b9dc271f2d660b635349b3135980f869080174a020eea3daaca50f66fe2b30c1865faf3ffbb89395627c259c6731da4cd1d6cf8092e3aa9d523d429539ea3d9c999ac7bc921fe7cd61c99fd320201072a0a40c2a9ea11db02f4bc40555008014b9364870b27a52273f1461f1ccc2ba9a6b5ce287a27fcebab8c463edd53180b3cf0a696cea399b66eb75a4868a01eb7b49c95adfde6c2c3c3e868f0e277915b74de70337e28abc6de0b64fa691ace65a705a675d89af04ab4d119f8d35f867d7a61b69cc6d844d63cddf925e500762b5c5c80436766410cb789ec5f2f28c0f90ed36d4fb1b912eefd86c317e185194255a7734078c868d79ea8dfaae787df82d7c420823ae8c8a6b62a2a756842607a0627e22548def23de11ce56986b5df0f118b1b3f35d07a10a52b2634334a0803b2cfaae3bebb5b29672616fab0a1b5cfac188263984788e468e79a34f044f356f051295bf827086cb180062ec3db89972eaa0b7c980311d5372cac08df8f884bcac8ea892f5e1622d16facda2455fd11e6525ad5f092c640810cc94d38252ffdeacca5e29d3d92b1ea9895e4dacd20784498e9d5a553362acbfe6d72da25d1435eae3f0b7b85627c3c4a3d9ef4fa507859466d0ac4ab1e3e91f493fa93741a452c8e72a854481d2e2c406fc43a82ce08ef483f4caf3f0b312c88562b7189da53eeb257fe87fd8d3353b2b941f3dfc82e6311892981fcf196fe3deb4d0f071898d02f3425631b9e5771cb8b03c2117c93640fe8874d370bbd718b7eb5227f32efff9f9b37c1ac74f2969d1f06857b7d116e48fd98938678cdd852cc30818683c8a9077508558926df2609601281deb62d7f08be803f1cb237e97af380ba087d25002e5d4cd1e40ca8d2d7ac3ecd69f75235ae25aa00810ddab853c9007fb2ce134438187a52cb9d09977cc1171c34fa057dbb4d3292deebba4aef23cab0d531f6af4ad68325a804a4abf631e20f15ce3ce25db486a86da8197c8d43400346c0145e98c0b82e0025c1e3d87a4bd49d595a7c68d764bcc1ce8138fd63a882615982872b1d22067d1d85079c7872bcb3c0e358121c194412f13950074bd920801ef2d945641bb05d769ab0ca28230948a7b321433b3fbd29e1a4f9f3778741dac08a76ca7824d581a46ed581bc442af6779f4372f42cac737e663341b147391bf0507a272e3d2a15715695eb23cbd50cf9f643fa5f92322c7c105ce46a04981a6dea945221827c6d3e9fa1811698b02853090e061df15855b1f5687fad29d2be5d752b001baf424e64b54818f90dafe1630e4299f7515d76c64b8c1a9e7e16f457202c07d1f4e44176ee59b53216791f4a322589f849b4a5c2e30195d26098c20897796c6455e90911b1d91f8d27256815359018e89e6ac2ab5120beef713dbc17c246109e11d6b729ef43c4ee5732a2d3442cca2d339a33d821f2499e6e82f42f9384668b5c9771fbab9c8ea56c7cc0693fd38947919ed54eaf0400eba4e44fc595492b4580874a0788e2dbaa1999840b4e10242d48420fa05382dcb49c739597be68388aefaaad752afe4437dac93c77b4256b9df2a0871b9c9adcccdd4fdb0c5a32be3d261e9186f081f850bbf33260959f8e033ccaf6de3fe949aaeeaa11df6f573de8e4e3175a4d70fccae009d31d3e65ac159705f1fb2ba960f0e1effa5c4b00489453e8c57893c1f030c17f9a8fe99d1ddaba6307c622c9f84762e7d5ae5566a864a9027ea9265c27d7e4945b13469f1dad635c35e62073944251d145f1be17b395facbfe4d598e92ebabc223edf77572102733c46d9781547ca7c13a6e78de041c58674bbd089de6dbec0c0be4fbec6a3d849940f3e3b1e9c076ffea10f9174d8d7dc2b27e5a1d07fcbc157ffb7b77fc30a37505cd446ef586e745a7d20bf01bc53e6271b8de5be2422e475ba149644fcc62b218bc7906d04658b7fb47d850850a41e3821cadf90553717200c1bdbbac997bedcbe37f98385119d4e71911db603728c982c9cd88e90e775fd88ee8f212a98824068eea356b2479a40bcc898d6e998ec61dd8aea22c1b95886e719514cd366ab44ff1869b1caffaa896170daebf6c48d29f49989d1d728c466536f769a2a390bd2e4ee5588f2f7b22accd142ba9f34397c0804bedcf100da3f3645289dcf8f33def308c82a8f81afd4ae43ea0ac917ca081bdebf55adee926942fef73d5fdacd89869a07bde0f69d0e165aa480e4e69a1a95f14b0f949b1ae9dba574b1bc8786160e45951ac0ad1bdc0eb7bcc4f862ad6f88de1e34e504fc5bae7694f7cd86f05fceb28bb42b608074e1c49aa0fc73810b45edc604fe806d0e28e0a0fa264aa4356b7a5b8910394602472dd52a617d2584e0abfe8ec9facfb5cde5a9612b4e09ae426982a03e9153eb4276e4498b830dc4f44730b9629d36f991314ec04232799d91167945b8cc211e02ed75ecb1b21210607315880c6ea9f1252e08df532aac401de1ed62bbcbba262d68e14ce3f324b98ecd15c1144dcf7f868b886b99c542962d98f2b5888d08173f8617ad08bbb581f1466305d4c89a003232456fcd46ba7dad2f15a1bbdbd9392b0754c86d2de7dc62d8d2cda8d529f20040bab698dd2c6e88ddbce076d14dbd1cc642912159f024d8735e61442599c22b7125acde1bb8d27d914bc6159a89462cd4f6fdb0a3e02302a1d9f12d1c839e50af4f3a0444250db1f1dc1207adbe2a7c5ef6d38f3e319af5d68baaecda53e44cc52f5567619751ab71d450301d2422c55bf5c45f535b0dbc180adde941ea5fefd1a034f1be816aaaa2eb4640ffecfd7845ce388e7c0d028697b70e8c075db579fb3dfd36df4c1f0b7e59521d205e4e714ce9713241eee5b314171c15bd936dde7e506de7b3a4a7a66d4cced1ea88f541196c57442fc0e84d763b71f9ce5b4683a54094f5528124ae722e6b2d098452673aa49f6b8b86156a585a72e126f98e055bd37d85dbe81007c806d13887af77ef0632496d1c2dd99d2a6ff2cb1b9d55dfb5746ef483b3e67d97adaf9f02207655798a0ea163aace27329ebd24a0296bd49fa98d7f1d11f54c5fe941cf5dde5d922bc00ff8d678c0a525869230472e4a8f157a3e1ba3f9f9dbb35d3db7d1029686b30f1a61f7b78e8f54330bfbe4d9b87e2840ba032dcc5f9f6b493eacd50c74f7f3ff4ba162899f76db5cf7329331d8992aad1950da2f74679109a4d54262f8787a4a7231ba7a6c211e267e636b95bc71cf728facf857d2d5555c040c4521962780db1f6de6187e0aa43c11b55bfcf50736cb7925334899566b65adaeb54b6bf6814ca776cacd88e945559ab9ce2451b4e769f245e4d2ee7b0661adb5e6f9fcee5167e9275325af007ed194de1e2e8b3d137c1f872db3d479bfa4356ff0f6239c1a92dcfc46eada849b3922db75f1ac3fba7e180a658d3e8d0bc96bb589aeb85a5dd27018ccdfed9691fbb6c3480f3873d7d4ee480080ed2d116c48d955d74adca5fdcbda8d0b5fecc4920b2bb38cde7ede532eccce5061980af9aabc4e4a27c7ba420aed847c060b48831a2e2cba5660f3d14a31ea5f1fcbcda30c4744f791c3a4d097e849fdf94860544a9aca0a9f1d4c36a984bdc2f9a49eaef7663cfd05314ed0b00347f813f58edec35e3372797a052c1a9afb4515b960ca74b3eeae08e43036229db662259edacebc9333e620a35c7acdfe001ed9ea5d36f7f55a361345d8d54c0942afe140bd919703a3822ac307de02911b0b66db47ae984b0b6747f6c5dec17c20a37c66cda7aa96e4bf4fa2788fd65e9e87acb6e3f9f31fdb94f1b9d2a5f0e1022c9ce2073707ed65dae758874a21009e1d96889897941a12511730b448551ebb9bc5cdb2543a2927fe2c699b2568b42c39478701281f352e5fc069d8f93cb7b0f41e999841861e2308aa9416a88ed7beb1543bb7936bcdf63f3aaab67ee0b64340120ac6fa2c7af8102df768a8e6eb4d243b7a393ceb98e40c3bae84002bbe3cb452544702401a54b733e411a68c510925459c7a488db0d5a85c76f4ca1d6e09850ed98e52e2b9347710ebcaee163381ea99502b6c8d3a31cfd8537a2b742bb8b94705897da286280be61d59b2af3ec15d27c3f8f0c99ac11e825b4fd15e435139b87b81f8296392e70f099945b3bf36409f19a7c447ae60abf85eee975532f70175cc020f6af2d2f32ee2eb8a7d6fcdd2f19637104341f294fc92f1eb1053fb3d9cecee76d52ed43326294260d7ad4d0cb0cbbe4b56797481fd37c1d40b0fe66823d539d11b0a4ef5db546a9dff3096593db548b58382696bca8a757ab74ee1499333826a6a60a6fc63b5c81f571c2cdc3b93b12ea2ca763fe072ec33b29acb88473032f88cfac78a8778f81c370d2a0e4a3819f3975079659e5ae4dd5f5187df9c41d90d4c1812a9e8a866c07285a0124d14975f010cb18522a40927b37d8302fc76e1222b6799859d81d5f81cc2deba6eb6e8a5d49890ca47f328f7a7080f433c2d3c270f9e10e90c80787b6f6b753c5224a4faeac3aa0254196eaa9354144948e43036c43bd987c9028e5e1176c3a2c7b0c2522d42385af7ec1ad538c48917ccfe2ca2bd3eb10408bb7effe37bb1bed796cec7eeb36af216595d7217d5d0d40d88f5ad8759c7881e55c70d2357f26bf2abd29fa94c4d1b2da174e355f799ccc96621568ffbc8f6217fb8e47e4f3ec47b88353a978927e4ad153f03870ee428f169742dc6a7125c375ed474c576965e460f4858d9707fabd8d4864f511aeb0322219dd73e47bf2390ef387cf45071c27d2a956b2098225c7f2c650637bdb365e3a02bf29149bce106bd5465b5bec1d2efe21c240d4e724851cec949f19a479a6c635e281a10f08a5a4b374a81f7b379385a8cbcaebd665e3ecf852fddd30dcd1866ec3c649674decc036fabf993053452ea6d0c1cac467dda554bf862e276fd4139484bf0d54bcf0975f2f2e3cb7b852c23cccdce11a2afac16cb423f6d2eebd12c94230247e1f408f0e31462b10ee7c3db8ffe2ba9fe4fecbc1c4c0379db3452efc2222128dfbe92987db22380c736f6ede06f72e3552eca4952394c0a22a87aba6b97d5c21377748589bbc4f53b0144df6636f4ae2df0f50e6d7dab1ea2fda9eccf50a5a53bfd3b60687105bbdf88184b690c90048e7b90a8603da6374c5939c5923c7eabcb0aeac64685c69c8e2bff5e2726e8000fc8b8aafbed58f1ab4dd0ebe09ac2b83902ae0a6279cb7a669f7d814f7b5da54cc1509a209d950dd7c7ebf168719395aa25a78bbf5c45ca84a5a0ddcdb76c60400ea52a65537e5ada0458934008fbc3cedd86761e200ee16c1f3988566c99751dc1687fa851ab7776df3e41bf6ce58ab8880fcd2a990fb8dc8389b9b133ac0d2cd9d3d820f60c001ef6fa5a22df484b1b4ab03c0369b1c871c5d95ce4a15f9cda369521c7ad03fd6844d81caa290e2e9d1259060f0073e257f2658b19876d5b507723ff3a774b7993feb27230e651962970edb2ba2858352fb12a40f49857ca457f18dc63142f0b4cd1f027202e32595d6e71d472d18f890470fadf8e538ddacd308f38a6d0c5c3dcb0ced492e397494fd73dd32dd003a538bafdcbe0f1bec78593d3f0a57ac2f6b665b52d8562e6090fec588f99b910ad1b1f1faf5029209ecb7b3d4e8ac7259e141c84dc6136fe6cf8e64c98569a25d49c066497f1a5077837c4e8643860f01c09da9e320dca42c3dd9fb573ef43302f73455bc30133911c84129faa700972554b572aec3b712e87f3f962e44b750ee6affd706d2e6ca34bcd0396d013732e41bb184f98113b6c13e6598ffc31b818bec6f16afc60c91247930ecb16fdc51ed48ef90736d479318236b7bbb1f059b3c0efe973d4000c2daaa412d3e40ec13824bab9f5d1115795c408d726d2263ca3f77ee5ce9f2606e7e243fc257973edca57d11abb3782e283a68fff6d7dc56d62213b3d095557c6d12d975ac3c2146af4edb2067b45bbc1888cba8ed876f5ca4cb6529fa523abadda0139ec5da038c729cacdc39bae7b6d11d4bfc7da9f1806deadbd2ea76aaab2edb1c288d264e8752441ad76c5bf75860d5d0a34b663fa51e19c2dab3039969962033c4e00ba3a770f0f5e67d51719c20d15a173b1b790c7dd7f225fedfccda5ca02776c71fe8cd8cde3827f70d7db89b6771ce480f1f9dbadaffd416d71eba052a948eded0e28ac65edf558ab70c23775297a7ab4ce8b22ed9f8281c5a588057554dee04c96fca717493e190c77a79cb6bf8e4ed534ed6d050a67ffe232178bd05e8b534ed1df31997bae0b80008c4fcfba73f63fed2885c7923450802dac8a5fa0a350ce4278e8b45a5a4de412bf1b42dae302b7ac23d0229e841e8daf1e5d9117b8951aba0a39b3eab798df6ecc17e729a79efaa7bc3b320f713d10b2880da7ec41c359d191e54504702634d617580b75c629777c5272809032d1670dcfd9a6e910be406c0516be3aa3df3c1eb512944a711798b3c340a34caf165e4b8e73db1b8c4c40301569e15cd097241edc85064bdb9840a1ded65df60d954bf2b70c916ce8447a12b328f5c02cbca1b45bea334125817967203a589a0709797a9fea390f67b6b0290b904af4bc9510479ff9b30fce4c83bc2fa5e0b3f1896078dfb7227191245e24fc9eaab6461d09c1ae41b5c2f8d69c8afc2f8a69a739d0c09a2edd42f378de819f73d95a3e68f2f81e48780158f544311b636ac4aeba8c4fc29fd955c3d728d33a1a295fed8f7fc213702784d4b542f1ad0e16fec0025e4bc5fa38a72ecc525fda6ac6429902dbad8a2c550f247daa412cc03208ef49ef91be19e851ec9cf698ba7b6003fecf4c47673cdf838f2f5f4074709841bec54d0c970787444dd5e7b8417311db5909d06ce6b864fb6f1b805566d9e2ef935a42ff42a4496ce61d7a18a51d7ddcbd8775ef5b8c53168ada15db55b00fd1fa92714840b63a1431a7d780ba656b73587d32b8f9ec8f2693a2a75a0bfa6463f0daba4e3b20d573c8461b333e783f9087f9ee49510cca267ac000c5f8fc75cd078d24d4d09611fc2a8c48d95a4a4ff644628194fcbf38acf71616eb7dd23c7a252d4e457647f0aaadd982dc73f3905e6f6224acb21bafa6cd94ceed207a5b488664ca59ae1c4518f54109751b975f423f034d3324c474475e9d62998e9a5ba9519aacbe453b04ac1e285b6c266830d85e03212b37570abc21f7ae51e38cfe5a5ba95365b63aa1ef75296bb3aff3c1be6eebdd7f834e283fc53b0d04b7797c65e7d3df53a091bd2b6c92afb4902d4ac4e0ee0ba3e5f204da3d7ca255b3e88b99bf3d471efc92f94e74385115686af4c27917800a026560dd83f98f0aa7cd3f226c3b91d05eb3dc9f139363064e0033b34e8c2b9adf802d9b08b3cb989213375a20f1991dbf4384c260c03871b7325dbadfb14c79e1796ba6693621651d669b3f584e0bb88e9926b4a7bc341b507a9dd4289812ffa4accb768670bec42332fcd3e39304d86616080cf337002b31dacb91d0cd40777525548f72ad4ae9c45199c6ae80dd4d6ebd4a6351cc547fd809e6381aaac4793a049a22ff86ccb8485011a64ad8837a17bca0accfc6294dd6d337db61b974c9eab2e45c935b089658f7c72906658c22c041d3d72640c89f5b9adebac09fc3fae49a34aaee07b8bde992bc901ac7ed6bcc04cd8a84e56bf9ba27bfc91f8d776aed2b6e1f88cb64fc3a97adfc8b248244d519025fe662a9cb0cd98edddf847f13eeeba3420e123d1efa827b432c044cf72b51d6fd16ddd2b3582678364f99a99d135dd5286ac6c0e277175b3b8406b0ae3558e56584cec528407d1c59988eb66754a1d3d5fa806a7b6a865cf4aed4f05fbda696ff40512290f6c5ab4cfbf3b8f90b7d907f8b11a74988778854b966c75038464cfb04e4e9098d8db17b32c147a5f7ceab9b043e690231ef59f57263e4399bb9a93e007548dcb1e3a7096781762e674e1bc5aa2483ddbac97a68c70e5b67c0ef928363b23dab9f8a1d248e112ab72873d0ddc1090b98880a8c1b684b7791924515d2313350d455d9c14721142c23bbf8105960c98ccae671d139b18f6f7204bef9f9e677ce0be2fe36fd91d7d1c4b13454c2c27164debe685f0bcb7b484d7063842079bf4b2a5e289a34c6ef64474a53d0bc6887066859a5e140c77132b8e83c1b34c73132398e4ea13dc4471f8aba938871d0723435f96421e2b603b1ffe43c34665c67825ca19cdabfcfba2a196e148290c88ebe18762445d5161fa3055178c5e860299a9dfca55fdc9db1ff27eda2fb734900ef493e071f1aa0f8f378c0ac498da89c523b0704d82ff05ce8e4c5b320df417e36f0163345a1af9f56d3d0ca63e2f4154ab67db5a1ba0e7c7354e22c9cfd9a82a174947d92045f825f2e570079930a0fa667f7dab75c08648e55c2f0d0a044321e5eeff6897267806c6e54c32b30d7cfd6fc9be56e0152f2ec0830a91408989a4199db52ce0f730b2d2a4daf7127692ffa4a41e751c4057d1523b702137deb18916a2806b520355b247e26df7d98890c5d65819787eb032c4bda5f6d6bf8653d5ed73182dfc905e510c3b8cf22baea0957c5f3490deb0fc5e2df19607b92100aee40536955786b2d0e8cc54e217a130eebe47cd23b7d8e26e92d97f3374dc144107b6b3a78b5ede83c37731c2243cb3531cf61df66dda7512d0aae0f942aefd775c443cc36ef44ab8025142ec62e217032792fe3d2bf7564509f1f174efba6cea959dafcc060820684b1fcb055276f6225788b1cf4befbabde2c2cbe862f2026b4c51ad40a8ae0f89faaedbba78cc7a51a39c0803d2692e57d10fd49aeb41c8a84cc2107ad941e236310ff7eb9b1e39d8ddec6b27da340ed843196754b3fb22fb989fd0ad4f55bbb63f72212e9a5b437a496e9314be5fa038bbbbf0f9bcabff6e74f14aba3efa5bd6cac5ad95b1009d9177963e756ceea9d0c7dc082cb3a656bc15a2bcc7c7dd04a4ebad87a1383cc0b58328475a6e0ee02fce9913c89f6fd9b05d35358cd85c28da1c84a6f45ec23a1d009662f37351a5a9658f7a070f7e66c3720b80e16bcba4f4f65918db6cffe8ca8ee220cf0e2cb0cf14a5f8e97c4b9615b387c1c6e5fd0ad0752b0fb8bc229c69c7e3dd3e172fc3e85593596998c053ebbc0c7b29642027370e4cfd3b0c86057989ea2d90cc430a71ca9738bd160e9259dc39d4a89d4bf459b2dc839baa5098df135d2f6080bce20747bf6b2d7cfed2ec4584c227282a907022d337445feefd42ad9c716f7c13af40c6df1ba89536b6789ec29339600b71e9e139bb2a8376595b802c06fcda71a6fc5efab6b73e10f85f048c124cba8c4770ce06d678d66151391288a181455ce2288803e2d4e55f2325cf391fdb30be167aec5f24abde6000f1ddc1009399591e1866f881edc88860494f2dfe51bd6703caba856bb235632d4d8b6dd6a3efb9a382187b69a3d421c03b2579d889e54422eb83407e97dba6cd65a36c942cb977b3a720f46b005800c6fcbb34f75da9ef28f5cb7beaf2f87a0385a6b90411517673a86bfc34ec82cf1205cea8f802d7ec5af2f0d08855ef22b7fdf160d4b5f5cc1f657e78c4ebca9e050d9316c2f22f275ccb32bf5b0235a1e6b507ab884218f6a714250ba661a44e5083a22a3b557d1bdd9516cf666aac78ba12047c5b5cedf2622d8490c3f8f385a470742e9ad15fc4bb2dd54d97b2fa574ca9635c20b019e2cb422e182b613e66e12a3521b4552c7726adf0bf5b2fc76674cb36fb4cf213f5125ead295c247668b0809c90fa708e406ccc447adafd4d1ea8a4fee88167e7b7e0cf59b7018c2a5612c1789ad077ecb7deb5459b72b6605d5bf020a34fcd1ea983a1ba38bde12898c69b04b5499e5bfbdc7771d2ae9d891e81ff5af7ce4e6c245ac00e4123eb51b9607cffec1403fdb61270f6c923756a9aef2e0d9fd4d7558b4b3cbbc8f80b63b792f95bed7f0ff1ca4654f34157242069dbc6647f28258ebf10c8e123d66474b189ccdfd0284c42cdb29248841ad0ab5f959004577f15b147f0fdc231866529eca7d5607a104cd4bf6d9a8589dacfd10eea5e6673c729f6a8f9cb759401e7f92648d103e781e09d4045d16fb172addd8b9f2bd86d4c62adce327ac96ae01f5a337ece5d856123c15941437b483ff0c7749ba416ff0fd4c9f802526bc563b8f2334c36611f86377b9461dded8fac9deb6ec2ea082df0f8d8f23458c4832e21f5cbb28cb5d70d7a33b03adb0b03248864a2c02c7985625161bc5d32e98f5ffe91956162fe2eddd21ec46bd30c2eb6c45e9712c7e1d146d38ec15d572bd9249a71798946a21352fe1f8564f6f6076d60808c076c21542b1d71c326fc5fa6f8af0491e28155f5b01feea7933641d6812f68836301499669da300f7d6b5bbf0e0c7debca1e616b2621b61cda349f01c507764af7aea85540531ad8b3ccd51f0c1b8eeede1aa40158a0fb433469047ce6c0c6b64592fcfac60e14327250f366e667f82ca508a4fc22602cfb15f6d3697e25823cf9a5f7fd69fde927d16b0a2113d0cbca2bc655a1359d12665ea95e48ca7d916d3d378d0cb465d9cd7bfada24556fd2e9e4b1b80773ed69a89fc2d722d15ff673cb8f806d78bf67e25d7dfdf9038563f17af523e388cd3ea2cf12f21f442595ba5a5b398b4dc56852f685f2172fcc09165d5a85d3f09dca213aee32629309f7252c6d81fda0003a49011e08ddf926537eab17cfe43846f7bd469303931ba9067fb08ed17b334551e8a3158542ac23614332b6ade76eb457d68a3aaf80a59195a2d6e7982f95705da4009f048d897c8d7e23ca1f01f09ba08734b2eb588c94e18ccd2c371a3768eec511ac51341bafa8eece57b23f57be5366fcafe577088ff89691ea768d7f45e1ae627fa662de619a32713af6160ee530625b53f8967db93491bf7e7dc861595be68f95a7bf00e60e8ac86ff07b35c2a3afc0c4acb574244d8f4e660374d6514ba3bb61e51d634e3cddf2478cbfc31abb93aa26535d8d3323afe46ead78f182ad2a6408d295f95c4d91fec47c66d82a7255ca653e79e7e9ad84e5b98c1246f9ab9391f37b5bb3bc37dc0fcf6d754881449c45b39bc6a1417b934c7df858fb95ccf7b88f0d5e9792b66df39dd831cc7ab2f9ccd844852243874e64311a4fec81d5d2857ceaeec781b0dc80b322f4f8ec149b31aab352adb39cdd1cfb35fd1b248027ec7bb6d7b29cd83968ab7aef7621612b8750b5812d38eed5225b097fc02b420c3360dc51fa0f9239a6734c0f9455464116ceadf10f629d4cff4b44b7109258d05961c126c901a32a53328af9fabc3d0e55d72adb54b62c780d11db2b169265474ed699e722ed02e2bd6a9e867a4c9415650733fdec6f88d8285a0892e99ef2c32163e47251b3ec4a6690626cb489eebf4b73a07b562a636200d66bfd62d9e43cd32c32afa54f315c34a0bd17b1d120344691e88c80b058df54fecf163ff732465c0d1d32e012848b0b9c96f1fd86de7ca742be2efe362b494762b9178e190387fea0e91d7c0fcc3185f11c133e0901b7d58a04fd9abeb8ff9985a627d683eaf57956aebf2392e804dedd413c5f2df2e2a23dfdec47d9203ef9add3af82a6128f7b471c8bf1fcd8acfe55854393419488b6bbddef21f6a3d3f60e912b32fd356b74f1326356eddf4d424b892db55fc2454c11aaf72044dec1634dcb5050a95291e3e287c6aa6a9abd59c41724647c371e3191c77c5974759b65f727ee03079fe4a286deed4cc035e7691b9dce4bc0d3475eaa8f49567c375d48b96c0e8c8ab32cd21cfc0e7104b57c75622bed52ebc8ee56bce70ae37fc864d1882cc7b0db1f7967774ba76c0e6775fd6b4b324368070b00294ef29fdc093bdabf6e8b83283cd611beedb9d3344e8b38916f45460f7558da6575f43b50af919fc6c1a314b4d2a31040144a2c1e5c7c396623f77f0bc81bd811b01f08fbb0a38dadf30f31c199cb0dc399f2253c7549b9ec0863c308df39cccd6ec65211d1e0cac92a7b1a2d9b2d2f29953bf9b71e969013331492c681ed4825421d27719787c87536be90a4869fabe522cc527ad972b9e93115a5853e45a00837fdfb2e89f47caed0d7d9878823ca014e291cecb4402a00700829429989abe0e21cfbe11395ac5535192c6d0b7b87bc6aea222ab3a6b7b125373879a1fda33286a892a6a4d4cb5bc37020cdeca6ff7d395c6c0716ed3b462ff923a6ae7eb0fb02778fdab6224b127a619447bc268e4de03bfec29e0f4e13134656308462b53046223a5164b1d75ace768bca177dea8de0b762135c1a33dfd0f8e2450dd4a26da3c18b568d8bef27707fb2ab8ac36df31dff5ea037b007dff3d49c66e8c830e67f883b0096c661928a36d6b8c0501368a2f718e5d793020bc4204dd8578294326f744f045cc34ec819bec5d25cd45f17c3e4a37ae687c640e17a5dfb74a61e2730851c3b9ac42222746143cf715c8fdd761adbb64e93ecbed668b56f5fb709afa8b02e0deef3a6cdbb158d24c67469cc99a39e1d3e5232cae12856799b56fe2db83aabe5386a2e3c3016cac5f106db6c15e4587ca8db26e7dc30d7e138df819ac3d86981aba961b7c5c3f0553a841a3e17a6f6af0cd859fd76611dccc66644d1d98936532ba1a0cf30bedbcf24ccfb2075126825b370f36a6f9765592f619734e1db518f49f11093d0c1496fff618d2897a2c1ffd46dbf3856e0f9665ecf0bfce68b13756551cef8aeacc63e448b388e36acd834df01fcb6c654996608853300b6e92bfe60c547422dd69764715bc917c41cca0097c0791a768862e33daa8ad33e73ca91cb316948ff30eb649767e80ff8ec54fdd5543487a54bef1968bce15ef6ba300681e4bb2d3d4123f8ca68ae48585b40fb6704596b20a2cd6f6e539cf02000554ad57221a3374258d875ce8affa443fd5129bdf9712f54fe5dbb824513fcfa130b42189a7618b781d3853fe5dca30098397c95b8ed0aba4a706d6c42dae0c29d9da75e6f56f282f9dea69c48c6a0ff799a4620b6ba3a9d81e2cd43d187e9e77f9069b299274caabff161d537425fd2fb55d8036435bf8bbec0b181b207733f1a78eb25eda8c0f13c2f1ffbb4dd75d3b67461054999648dc7ac56f0267329bb04a26152788b800a594dd191d1bff3d705a6196a2e0d928c43a2c92b9ce32847e6fa96ea3e2d4c84196e394c34498b426a0b22ecc462dbf4caa5d0c7e7fdee00034d9c2e38b4fa561761bd6ca4e64736686d3d3711ed39bc0b617e2a66d23247f747713bd2ebf7a807b15e39ea73b2d37d18dffa3b12dd0fe1bae250ddbd54e26096cb0cd6549ca5544dcbfd91723a81965160f44a22db76168afa40f1a8eb6684bae284d15be205d9d0fb628e019098690c78c89c67913a994f63ad8f18db54d401633f96ccf92a9e8df068c331436a8fb86e195c556c32090f96d516df1498579bc828edc6db3461517d95508e5aba0530965cc6a857e86ec119a370d6d5d3ab8871fe41204200e36dce1f492ddd867949a5ec9ee243d303ab34e9c64f22137e7cac74ee8465456459455a084b9cc12eb7892c06e2df6ec547f48bdf1150c3afd1c5a36757d0ed4450c6cb6f5d1adda9c7d8f7e7fdfa339e1d644a578aa24c1481222d656c463d17cd245955de8229e96240d6bd00391117224e870d7f5cc91263d36820ec64c186baa296dfe31c74c7443293fb82ae5e29fbd5b8bdf5431f9ce535faa0df417434281aa8f9f398adef80ea66a618732022526004fd5d1dfd802818db47524c539e92271710c495c907102b108c920e19fc1c65a080af95c49c344bf2dc25405a7f02db57b9e8bef85c62f95bbc986c3b17f4f4fd8e8bae8c376f1956425c769a993848d413f406b5c22d431160918eb70e2b545a6b114b70ecbd2000a6e61772988d83797d8d7bc969083d02d940c70e139f925a757943b5a8bdcc42f38696e28a8a0e59036101f6a8bb8bbb5d92a5ecfedc103a07f4820410c7d388ecb00587c6af75b0e8634075165c121f016bc38e1ad110c692b58ce5f93b21b8b0bbf08835bbe8ffbe4928417a523160000361090faced686b5394b48eeafbcfc27bf8dfee0529b67a74bdadc78f5d08476dedd607ee34c94f93de839d2462b737f3889d6330f7aac1aa612b3fedc88c42edeb405463498f884d951d38d36f775d145511840309a845ab28b5e6462cae25e4206b638d9b4817153e313ffec0f314d39a3fbf1f5cb9f65befd5d564b3a6e254577891847193bdf6f455fb5b67e1e708be8f3221e77df0078132373b81ec17a6a8f5301049e7c829bd8936ed823b45b40712d0900c4f2231ba78eb256eaaf12bb6f31ae16b733dc4ace05a3953adfecae4e27bf6b26c95452547e3fd19bbb6c1d501f1212039575471eafbcc34d4d1f211a08114a24fbad722b68d80e7e37fe6449b0e02581dadc734374cf945dac281efb6c95265f590a86702bcc6560fead51eacbe4bb59466a646098380af5e78b6481a28aa86ee79324d5a62ba14e6c0a85bf11a7be1b5815cbd3f0bec6dda79905473a46aab1fedcde17918b90d2d5cc2852a3565d7e3dc0cc206f496c3a5bd01a3790b4241a3a063c54c294dc6f93d08cfd6adf95035a178239f81d895106b1eec7f019254db16a3535c01f7b19458c2c7ba266c0608bef74be73ebf5e76a58feac6d7e5902ddbb18f2193f554c4598db7996c5fc9722a3fbf8b753e4699b6325dbb0aec65d0a331111730ee7e5f3496e4548e4046fb77674805c801dd4eac440d832076de2d33c2489a148160b6a0cc16bc22e6dd6739851a9c69a2fb839d8238727f508fb041df2a3d79ad753748068ee25e9eb742de1f329ee71d2032b91fe1c17d64a28c748548b7b4957812c236db6459465676897f0483d62056a1112e4bf8bd6fba4ec9488472d758206f520c4ecf2375ff8d7c4cd2cfff49440d874f6618fc99c0158b35e900856d601640c3dd8cce27b68acb128196d7f10f102650bce844bd446f872d2ccec5a26003a9529e0d870da3fd0dba44eec6e65d87e62c496de7db78ffc1e1a987b02f8677215fc3bb8a59eed5486d0072e2b604bc0ff443ac2a11697e3a7a68975b7ef49a6de36d5d4007f93d71bb9ce49b00addc9bfdb0355e935a17be75992060e15547ec90a52a471c0995280abc4f84fcd9b5c5851c8add80771522a4f3a708e5425d6bf0cf63a9c82875b26cbad4b12c9b6703bf4f8d8d1e16b55e4f03d89016dbee995ce94bb54897e3457b4071ae96e55769e30cbe15e66734d98d610e227eee78d22fa95d8b1cfd8fb6283bca1768dfe8f2dbe751a8779896b1a9c948e09e711663424d2f2248b8813cb90b2e13eae9f5cc8c4773f070da65cedc3dc423fe03b2f4ab9b5c37c40d281182b3c32a212d1dbff2cd2402fbe7b609d1a3b8bcbce8610b5c01e42623660af47df5b7998e28d8f17da7a793b8af72f69132b7865c3baeec4a05d427e1bd9a2b732e1f04cd7df60c0fab7199fea6123e645e046e2009f944d8470a06d418dd2c8be6ee62ff62f9a1151f449d8b4c034e5ba3fcd4afd5b46002e9050235b3ccdbb539d04c8e04eb3278ba6f3cb04d7141260f31c9c9d5fe4535405bdb576bba6b2a6d9105538d6bd6c006b86d4dfd992b1659d04c0ea514b63b822e472d1fd0b62d5a54508676f516d7535c1d64e0e48432ad0fb313d788cfb10191c3ecc2b4c49df1f6ab50a5ad7e7ab3a7a7f39bc852cb229435acfc252adaad45c967a65d0047b80ae4f32d5e0906d49c2d29c78a3b7c3ed9fd795bc8e7d68af8a3fe98df642fb02a8a503b4a88eb4bd1ffd00391dadea803e700bff49aceb851a9cddb9e4d369daf81ece13729479a403cd3e325913ce0c29a42fb770ad6b6fde53066b9085e6b336a278a4301ca9784a03c5a93c94f9bcbfd4f39c41be763408908e02d55ebf8e2857c8ea3112cc76bfa50910f50ae9d7bc4d8ceb53d75abe987d07f20dd998029caf3c05d50c6529496ca862b0cf58ddb30f52df8a3a59a1177b1f4b3a6db04cfec32c6d732fa94e2c760263d2ee7de5b0831b86ed6cc4d1fbb0cad2c8a65e31044adbb03b85f7160d03f73d70b98e00424dd7bcba3a268a0e45b4c309ece8f2d064811188c9e3209a7e52d7ddac049e00277358353037a719206b96534b680f338f8baf0486ced6a76c4fe7a3f244e0944960b33e844125996933df98d49a382b8b861a5093310b3404ead7dfef3bdc1c4f8530296a0727af47880190ae34ccb2ca9fa387af6a261961d57b100bf036191e804f8e27dcc55276bfd9d410e85e78d897cf754a427981192ee5f92a6c48d8d89f2d23dc8d7c8a72d80eacf555ae06b419e897699eec75e51ebd455c15174f4d5f1519396bf096074f18281a81534381cbcf30d4408c287430830bcbf2fb41278bfc15abe835834c2185ba9422d29c2bc13d736d6a669348c18cc658db0d8f26be0aca5885388d49baea5fc4f84776046b978f59d7b49ddeec3f22fe425edd93614c7359a1755452fc341e5a416b814f264fff44ff061d11805a4734c818b80bc8f26bdda77ba641acfc2f3d33a74c5d017266142d896cfdf594157cf719e787ec11dce76ef5dd4cebb8e073247d67eff63f6b5196a057983f694be431a9d973072820d238525bc66c05ff01693a8e131fcaad41c3612d6b2d21e9e55abb28a26f007d9a225defb839c061e2a647add99ae2373db4f19c3968a1c18da3b25c8d9f3a73c922d87a118bdab40d27f3b0640923d4e4f14908e43f031230108a88a270a697d35569800e433465fd65b8d050863fbccad29567a3f0fba336e3c0f347721671df0a229ab72c593807fedae0c27e9a1e92649664a290c5a297d0912cab63f724c7d0b72db3da3f969344729c369482b1af007ead1bf9fce8c3a9f858d3d20bc3398fc5f83ae50c28e518e59576fee7f1cbbd7c3d48bc85a88af236769d4e3d604f1224904c2690494e13839a1afc8d298ebd28f60594d96cc35b4a8a0e441a605362984e9ea33bbc30ce722440797124c9ac7983a684a1151ba7975b5e5b82b90e86d2db2112f72962485f3280225a331e20f6be413f9b8d6ed17bf119bd918acc9bdc0102eb86554d41775afb230f7ad927a79ee71af3317e4a2597a85e92778ea57ea9335cc2b2b4e7fb90e4d44c03a43f702c704a5ab458c0134871050478a655c4e339318583b204130b07549f62e9ca61fe11ae4f9430d1716b520b92a796fcfd2c2fa83a25d33ef25aea1ac94c84afcdaaa17fb08f69e4a22402cc8b4a8e0792959343b4eb8493aa210646c48eee267672c3b6f69ce6b6810c3341fec630e84a8f3cd9a5573aba3d9ad29ba6adf9db6163dfe09ebf715e5bd16fc50b0f3b36ac6f8d4c1305949581ce72765b8fa9f46eab9755b98b8d5c4d842d1093d725a22a1656e39e3cf65767a80968aba1eb9238e8cad73d35845a4fb6c87c518e948c4d2ad6c04ba3a0eaabd9b62dc357292f3a74d5a24ea937c4461ccfeec3c6053ff873a87f8a446ef1e45d0af4af70152be2b574029fa3419359a260eb9d03ea5b06df6d20546c886be488cf14007a29af1c42af2e2782a252cae06ad9c441f2bf44c5bf078db4de37b3db375cde6dee989f0a78d94b0cc7e1a276836c872c689f98c14a026688473945728d6cfec264368f291391230c803ad8a80cae3e8e572b7c9248870f3bd9a60c72ee3b36f1566efcd28aacded1ea0755f8bb05b5118710381456fb15429fb863adfc0d5092353111c1724251eba53f407bd87a479fbce4657d220b5ce9c088b69898296fc2b84e9965676d7fed491adc14b669269cb260e79376ef84bc03e6654c48b9e6c7d205de292f821e6e55800c30426b07a77f520d9f5546eec72a1968483d57da6fb0d7ad620781dba62be51fb0536b9cdd6a62c0d22be0802c650033929e78998e071e0e8152794872f50df432c7e923d9d5db8a882234b08c6306a5cb389fa861766192c9280f0bfc2514b1cf875f5be8bf136e0e39ab0be01fd28f55050be3ab49ebe91b295a977182208bce60186741977d4cab8cd45bfa88c8b4e49a1be2fd93135b489aa0c8814b16baebeffbaa6ac6464139f8a9cbb2b0bcbc6e6faa60a3442ccf7c468c83639dd7d2fd5b93bc3fac32bd38fb573dfd92c3e072171e0caa1db677675216d6ee431acd7f3720d0006541f08c56a2f24cf718f84ed413b2ee9b70be231c6d6c9554a766bc2b5d750727c01f100f2ab36027cfa0f32b565220c83294eb57307915076f28de163013a5f5001a2bdc1b65b1ada8c1e4ac70c4e8f2686f5a328db855a1a5fe742b24a54bbf760eb93ce576adf9b074a02d4d7a2b44cac908122d33f2346b6c6e670c6cc7c3c0d23dd59aadda3ded060e4f2f917894441dff841818357e15f57a5aa2cdf8d2628ca43c6d30c1cadbec33dddfb24c380098295f7858a20b508319c4ac2568fb7023aafa8d0b5bb0f3c8686c092923b86f5ba8648aab750d521069949a4cea69759273284d84f8f79e6c228e2a8602dc121106da3e10a081761d7a7604593f6c04d45f0d086f0704574bfd9b4bec24046fc4beaf7e188a793698073c9483732f28ec99e8c42ddc9bc2213a852aa426bdb0a2540d2b9e83c41a7f36332d343a18e9df241a9349a3eda58d70aedda5aa8c9472fa91f3964c081aa48318a4712f7007472cf30ec2af5594376569f71fd23be286ff47a884d8501fc14f3d49d2a09847e3939b645ecd910d12464cdc93f92522b24dd2248e62b553c8217bc08ee18ee2b70e14484ef0f88b919179b35de5eedfe23b9817678f44f147025156a21c069b9659a832066b04611f3a053565c886aa7a8873d68c5d850cf6b714cd3bc28dee567d318217df81f0f4e3049be4255bf6c11e47877d7be40ba775f2ff902315142458add5ba233c8ca05960c13f0371afea5a76768e88f2e27e2b6bfd5ad30009f0f8f2433efb9156bfe00a75f1f72b4e74e4d7249a4c732b40a02a2d7d8df1a59bdca394b3e5bf2c9e8971eee5c6698143f96fa7a2aad32645e393f6a21054d056e1c8659d3fba86b65b29d119e0f98daf94318b2d82f31ba0c7b388cadb8978903f2bd6aa2ab5025ce960988822ee31dd3589ed4923f5a0cd47271ffd97bedcce1b42a8643746aa4b137cb329a93bdaf725f455ca889a0df07b82363aef6f3086e26736e44c94f0d8e7cc09c1ac2dfcd0f9f6d1fd22c0a089ec3f483a15471a7582ace147fb1db8decdf68336d485e512e67f71eecbf987a75203f25447829ff872e6b7a086aacc7bc2f67c2338c434b39e7c730bdfb55dd58778f8c5abada413f3ec618027df1431569b5636747b4f08b2e699ba558504604cfef70aa2d60148700f4048f24176fb19682fc55617710ad49e27482ff6cc13986f0f95850897ba35ac6fbcc88c2a9c218e037dd476157f3c4688e2ce23d4fd6254cc898f3db8089d65fdf0e0aea33ad031b4bfdded90c11ddbb33f662834c8cb891c37b147d2a33fc5db3e643485189c0e9256a1e82f5fde8d2f09612c941a6a252029aa8ed121635d8e8a18760bfa436dbc202b4b5fab99dd50b02b183b201af3dead592b3945ebd8a66b4776a7d420d6353f0944221dcfdc8419610df8509f8bd0ef4ce45454ec3cb802bea1b326b33f44e90716469a787b32384b6c314479b6c0c97aba2d4b950cd72bfbdd82225f703b2c5d1b4d99a4e611502bb42f79367c39592ffba6cea726963eda2444f0fefb6acbc2f8ea88a266b914ec60113ca29d2470c93d32aa216292698e7cb73e6743b39ad476c8e62d04d0f60fdf3e33b906a36c931a3f2d760caab90591ca253ebdc7e2b0dba70440da24ea68efe7d4bb5bd23175dc8630269ce397ab749fcd7e9607f00534b870e2fe50250c4c5d37d476637275d9b9af6921af18807c0ad48f2f02a0048d985eedf262910e8fe06a684d379555e6005dec94ff6cfcd469ed507b0bb40a5fd1780c38cca44790c59e55a535392c39207a1ff04957651e82fef8a3e77617cf42803e9ab9d6e48ce0547af834f3349d80e76245ff79ee26cf9d395d70e4dbcc2838afc6f84ca701e8c0344d6d24cd5c55ca76f30cd0b5c71d6e46be21faf2faf25cdcbc0616caa5e1ebb7c58986fe921a884b711f6c0b019649bc220be6186e83d004d8dd697278fe766d16ae15b9c4a24e56d8bc07217880fe7999e4be7a5ec8c2647e2a128748a2ce525901ecfc0df19db5c9ba0845f61f1d6badcb5eb29eb8e8ef6cbcb476504927342fa5caa541e7ff9c38d7019256f18f433356072135d677f5d195fbb229e642f843fa43779077d5cf773ed395f531fa8a09a611074d23b8c7e30d1e7771ea1db44b1320df0c00937425b661d9d9b1f7920efe7a76b6a10e05efc087307c50553e76534a6ef6edf5b7e5f94eb83cf250d719a49963fc66de5be85710b0cd020f0691f235f12b9d73a077217a702f6addf78b3947ee8242a7a4ac352506ccd5ba7f2ddf59c081ef7a08324c236f3d49dc00d75b6bdf90b043c6b9194b81579688ca952b65e550f4d28902fd7990f459c797c014d70ab69fb051b0530fcc5e97273575943cf80b72f55a1c9a4184360d8b536ea858ea7a79dfb66a3f150b1b70aeb9d19046aff1cf54afd16ae2a1e4177ed75178a05ba5a16cc0c16208f42718158aa26e88f814ec83c87a98d31a1e6fc907a585809391da36759007915460c859635264df18d8e9b6a80bf1ee2a02c61427e6fdaf5821802807ece580a86a8c0a5ff27420b83a06711eacbc51d7f270be897063447ad35bf4418884ceaa5960a2955447606e2fec35eae459af86bdbee4ff8fb4fee9f92a28c86a2299319b9cd5f5cd2d50310849fb47b5be9abd4963c29a051161f274518c3c15bf92eef78bc1e56e18b00f815e57274e29106e3e40fddb6cdb10d2bd854901fc9b4e82b4052701fae0cb791f6b367780330043dd4ec6aab57023bcad72d1fdb7204f1d5824272297c2ab5ce3a8fef9addcfc87343e6e44ebf6864c8df7761f1ff3cd7c3eea92ca92781fc10b4a543cdb5372820f6787374fed82ce20f91dca117568fde12ce02483f7494ff8e3f97a7d80e1f2f1601a5c4fd62192776e0a9962f4835fa0738fdae07a665436f133e7d69cd1ca7a1220ac2d66aea041d2495a34e5bd5b809ebe6a8f108ff6443b0d5793bc51eee73330e1a1658860a4ba922b3ff167da51b85b980804e573f05bd99291ec2cc91be4b009691e2fd4c9ecd4d5a337cbc32b863fcc031aeadbc11d15bb74e4fad923a1b9e2c016ad3a8da68b46c59b5a29b23ffe1c9eb85b168effc8e3844fdf0bfd3bc463081614f78b479ac74d8a064ff27a1b00b740528f2283e0b0f910e7b8de2998a75791c2386d337c07802114a57061f43e1f4be9d792276577ace3278a554d49b38ff995222d66fa60d5d243b1bc56df4e5837fff529fe741215aa930f8e439554064401ab897a3caa62686f1883cac85d8db154f8ae1aed30ce0c3067befc1b5b642d8d032eb763c27b75720512d281ec7c569128c22367867069534efe72462c28b9cd8c62c24ff8ee7e3b02856fa8e4596c7787694948cf6a43c2dcb63bf09e4d66e3de80479d44fd29bc2265d81173c66bd5c9fc710523c4ac3c086ca0c19948087a983d6f7c92d407860a0a5efd333d344993e6778ebd23001c32c69735d10058408515bebcc77f6aebfa1aaff9cb9c9fcfe1601bc44d30b8356265082bf09d868c9e911bad7415efff5bb963d9a6c89f1a3c4f55cf681ae77486d9cd1a00d153b93667bfac347668b500a639dac5eb08f7703ac63f3902c1ca3c2a05ec96e5ce283ecdd8da9b20fdd0ecf72905c0ba1bc6a26ae5f1d569af0e984b71bc104eec81c0fd6d8486f72060909743710861c6dfaa9daa2fe73438c398a0ce5bb130d8709da358015810560e0026f7fa82ae5ba7b03967522f25f8bcf3e0bf5e8b1b9062c9565bc51107f764c2fa832b774ca022c2ae6d3e8c164966552f2a599c3b5ad86ef7710babd286ea5a60823782302e2ecbe915923b7c31828bd527084e3bdfa4a4441fdb5769caed2caa57f3355b609e14da3694be447fc2bba8327d83cc1375fdc6377d7b0ae869237f7a3d6ef979e69d4196ed7560a875901b45417f19dbae4bc6d6d40afe2b583fff0dc82006405ce73afae84c10f247b988a17efe05ea6d05cea00dc479a8dab8cd4d225391285dbad3a4cbd0896bfa1eb7be8a1e1e3afb0a3a5e7865ad9d8d1928a64dbba6412e184cca17390e635c41ef060f578b27af853c73eddc2e535336fb5fde548eca113b071d96f0eca2fb79ceb4ad9b1da45b4c5a13b7013505f3aff15753b959f9f94df24b55ec9709c13c60cad3062f73cc21331fd58504512fa607fb1e431ea0cdac3a0437afba171bca74303633ccc5f0b70634cf43b91d48c0bcae2692093b1b3074fec8b5e3f7d8e9933218400518a6cbf1e39ed900c850cb831acfb4fef086d388bf22d00673460bb861278a9433ec8b03eff858d36aac707153fb3cbfd54351b2e6f3e01690d2dea8c8824d35607d443f3dcbc512d08109270f7469813b954c4952a097d1e6e84d4a21ecc7aa810bde053b4c19299851e70bedc3f414ec8192e26597a8c5cf8f7e337b7c344f208031c68bcae701882e444b62dabc0cfa0f487d40445618ffcc28202715d7015493baba053d5919bbb80d5daff9f2accbf5f3f5c80d3f2160ed883a89474bf3632cd364560ec68b09cd8f8c5fe4a55c0b027e7a36a416ef351940659eaf2f78d36e608ef0a601f6f00d2a146e2eef6598fde290861185f9a80208d6b8f383499cf1a29a4ef4dbc408ef33f24206f91950932a7a07648d592c9da48e209d6f58e59413706c45f67fda4614327390748c3fdc9cfd82cdfb10f9cf3eb127f047b2eef2b9d561ad1e14949e591b708e091f287378d85d1d079dce1dcd65c66bc7184894e8556fee42d37acde5297e696e10327867f8316b8f03e94e0a6d4ad4537fbc944c8f87b91b20e6bb961746305183447304982024d9ce9d5d49f672deff726927d04f8526601693b147ff093a0f968a5fe4cc392248808203f830ad26de83f75076f376b1fdf2925f134087bf650f34194f0404b5a279037c44f36d2610e7119d18c3ab3f79f3a51ec9117a23589240d38f4cd68e2e52b5871de5e29a0833bd5d25153b2ac3d9b073fe4f6dd8e184426a6dc96fbdba1027574107a754c2d8458962034ba654bb143237727014e1da9e24e123b4a097a9cf210565f0598efecaf7aa6d48c4978beafdda69925328339c751beb24ac780c1e75b65c33013856e3948dffbc529c321eb7815c3ebdc05999899c488d2ee8e2ddb8b79c24761fdf828c9e96f3ed6783a870a7a1d1945b2c6670d58b0296d836fa9a35474f75b0abfb86a79e07928b24488732d3ea8a880886197a269b28bb4ea35e1bb87e41949952825c9fa86dd6494ebbd6f7badf3d6955c4c209463bcc8878ba36143132c3d0ac39096576c02d855b4e438f7bf1d16633a3232b817e02e59b2b241a81f1f426147e2622a4a9edbba7d911b630b42983873743979a76cda60e6fec4779bcfa9fcfd366a2b768305f67cd1d1af043c232433b2676ffcccda1862ddce0f6b243e6d187d71a51d8133e520bff0945a2c2121697f1d1c1787a91e358f1f541345eeb35a0f4d754583d39203960d3fd802e2fa995684c261c482c261e94c7c1fa7002bad36ff6b09b0ebbdce11d1be3370d08a5b1fffdfda205175d16bb5bf0aad68b3a5664572e491e23bf8e6a60f8c3a13c257d1e1a00784845e82e435b9b1fa5f5c05797589faccf23cb28ab31f942c4c0ea188a6698688d68d9ca0cc340ca22e29a224755a1fc8b504a5ca9784c1ec19a2df61cbf688e29525f74d62e574a55d9f8211fc9c9ff9ec1daa844263f1b6f40c2ed430a76ebbb1bcf1ceab382476dd9d77f6f1a8ea414d8230a6cf5a81105e0a1b61f0630355b27aeb4e76253d1f0fadcebe020faa5d3d66e63881be50d9966d0d6c287f9c1c4087b0ac5f9775c7d85c8484972759030b894937d29c4a872233ef53b61bf507bd5937eaaf02224b37001c37a671ce018c212a2dc08bcb2b7118baa2469f832eab138c1824ea6ba0e917efa7b5e57de7c011c9cfd25bffa45917de5d2c7e92ee0453392e6960cb01e8e766c05ebd3923c4bce11bb64258833bbdaca01560914fdd04329023e80bfc4fcf391db16f04d8286a56a95e97784e3a5122cb0eb50ad70da02080bfe55e6d2b037c44d2a17dcab9a30d54aa5818f5a2f73ab2809fa28058a3035daf277ac9c669a25b5b6fae9d930f57419ecf330a746752eeebf23c9450198f1d750cbdaf83d03215fb67a3c2d0c8f1069a7a143949b33bcc7289e9370ce5297ee86baddab4a668367ab32542519a8a03308a80c104eb3b79193779e0b7b86cf0fefb4699c323eef82e0d43702d7cf673fe70ed2649f4554a04a1859550f8293df7797e39925190d4352b091b616759bdf0056d5a12de6eb2cfb75cca8ec8239c54e6a6e63ebaf324a753404a89be487e3b36f64b015d9628ffba80b83db46dd97f84c9280c8aedbf306e8319271f5fc7789c52f17fc426bb659832388ba6acdececb2bad4870ca7699184f84b331e3fea574f21ad23ddb8c362a07962b577c3ec010a40656fb1f02905bf559e5918da96ac747d47f9333f5b736c3a6b57fb2027e1bb69a745eadfaa46e3351f63fe033038f13ecae5627a7f20c61489a24d8e2dbd8db09047c335c522dc2a1d774448c99079dfc5fa39e3288450d0620108f1f7f7524581b79143940210fb8954cad30623e0b9465e1b52c94626a22a2903a2b419a36a3c0e11655abc729915a0e646a59d202468584b487adde844532252575999ec196133a0af54823637b211309284fd0ce7a7fa62b40735df4b661e4e434a45f6cecec2bdd6ab92921233028d15b637ba9a073de5eeb7cf1ac04145d4cd386f0010dda7af523922dea43493c13ddb3139db448646f44588e4dcd14894a9797515b5f8f43a65c8d9713790a2a819939a939306290dcbaa746d1a67eddb90092cc77f1f28aeccca27abe7d243e682df4893cd1b35e900cc80205f71f302fb6d22b649c7fa47b7ccf926ce47bc062ae8206705f32ab22a40f19b5350e862d78cd04157250f72e4219f55d3948e74f882b0a656a632f1f8e567533781eb397d8bac9aac2ee6b31a0a828dd18e43ad26b577012061f3d68ba03ec0956fb1c4762ebc5302557c8882f56693186049ccc500e5f20c5e5fdc50909cf40ee35bd8689b7d6b90c5d0a19220baad2f93de3be14fbda27d5475f14323f35c687344d001395fc4088b73f1567451859fbe991a15b65c0deb221654d60ef2b275be561f52b80a10b5f46b33b1b9e4f765229e69d1d1834db5f757078cf25a93aa053b171b27a7981359fbf3c98b60a679054c3a12589ffddbc3bf14eacd6b52202218b66e4e6ff41b155d43426e464bc0c2a2eb2b19f882f9f62db95c7218f36db04d8452668415ead919e743ed1ebbfcacf24d0c143b14fad952807aa2cd447da8997ec254480adfd157602d6c3a4e88f7d81447b0dda8b41a3837ce65d165e59cca39e1ba57751280727dcc53f8835d362f64021d674117107eca7464a5fba6c4e5d11349503720d8377863953d09d8827b8b1ffa99b13a0f96af8ef6361ae53657511310939c301bf1d74503e3f3cd433491e37b0221802d2065859ce9d1dd722d6711b2745be7ffebb71ffd8d1da503d76b92454f2e0f1a3ea90b3d08462ca8113711e84cce8e1ce22a52dfc934b587a340759611793240f3b6a5c3a323dd45d8d736b6979d16d62cc588c3e4d8a1b57df4e45130910d6f9076e66d92d0be530d64042702815f0fa40ecd9e0cf7138d3c62238f50c2a9d181688d92ac99def4bf1f20510e04f63df9c7572f93fb22bf11f6d49578c7fca6981522b90c1a59421273e0b96feea8c72866fd6f53e8850f224b5daa10e069920365fe13433650761238c0a74f0678c489436d9d9b695451b338e693eb5def82c7d7810e4dcd89343210391e2f6f1ccd81cbb22b380d7bf7b42391552a8011b8350ea3bd600416d583bc3ce43d72bfbab13c50962122aae2d83469235174a20604ca78e72e7df00e28c4b67c418a5dfe0874bec8cd89410e3b0d6ea25e84f6acc642b3b7505937af34f928072842773d744fadcf5065dec058580235a85f8bb1ab5c6245e85275d1ec6b6f11f27721508232af08682b4d5b683f1ee94a9445eeda67a8a9371df36a3f0807e1de618f826bd5e4b6b7f6ddc39abb5e6305363f42af88d8e6078e996f3c48a35d61a319780acbad5249b8a0d58a006eff7be31e9e179bce76b151583c38c50d1a0aac406337bc8c78d4005438a0b5ff5f70547ec5c18ab725416cfadd12368cd895a794f19f928d1e5c43da56f6f41065ec49f17001f8addd71a45fb7aac1982453f69fcecebaedfe766b95191f2a3bd30245b7d47f4241483cfc025376969d6c42f813d7200f735cf6bfac0035c9e447cbc3b6140093b57d6c4e7302d9f46e60d2dd237e532122966f76b35ac5e4e098cb85de2d3edf653dea737ce0ae4c22c7a4607edbc689efdc9131d1e39484a0a90f28aaced77918b255fb867c6ec71e8f311714055fb2cf5fe78ac8432c5f2457a145b3abe574359f200900c452d687083fb5aa7e1be3522e46741fc9667d39769b9703bac46816caec190d3dd5e355c37a53af33642f6c16cff1e9d226ffa083370214280c259e68d69f9cbda7b6b06fb80be7e28d2fdd3552aa280ab9d9b9080d66c361e8f5c3f63c5766ec2478f25a611c9c65fc5ef86f6c1a9629cbaaacb493438a341351f098560547657a0d0697cd6cf7e059cd7d2d6f07135e27b126f0f1b0140be14271c5af233f7f81982e619fef9b29dc7dce11de01159bab797dd6b6849b8e6bdc7b662d21985d106af795d91be81aee2c299d9b4775adb92554126c7c82c9763c4a686843deed5d410c5c39168b5cf8cd8591ecd29c01027473fee1ecc6c4fa31a8ca5b37a86bea4a7dc9f29b24f34f4f37f0901b7edeae089923874cb985fc2f151ba2cad10ffa4a8ab96ee9cfe9c3a0978176db4b7402a54838848be856b1e4102fa2d2c55fa843b3eaa90ee2cc32527ff89be7433ae7203bea57121c73fbdd761293db2cf523dd16627e9847e5bed51ba82f7eff74a92988917c5de05137f628f3c536ca35d05cb8b5edd8978ab4209ed5db37ff867ffc487e2073c2453bd445480f8558293b6a7864a6913b58eefed4cf89502486daa04cc1ead9c3716d0c639583bc119ac051099a304a3a49445513a72dbaac085c1fd20afc35726bc488b2a54aea87c5db2fed588fe609b1e71498b95e762c8248bfcda993369c906ddb6e38219e7ae8372a773632d095cb65f8ae7b940539e2bbb86b79f77987b5a2fce5e7ee5162d6d4eec175319346c5e6a855ca4ecdd5597e2882b668e2fbafdd0d08042800358e438a5f57b9ddbbde67c05f9c7881d917cce3aebe8bd2c0142b098d70f3c8685d01d096bd093bb67c695b1b134e57d283a8285c24a8596a17d39fc334aa1cd7182d60d5ef95249815a0d9621694586ca750143c2d9ea233430eaaa1133fab148b1cad347e46d8bf30b1688e0e958e008cdee4fe5c9fa55604c46e0d5bd797b86f9e8f72ba668d1f023d42bf9491f64e6f385d885055a4c33ac8872cc734a0139e0ba02ac1a05666948e1f01fb3b85408f78bb79262b8476dd4df590df0fe57be0f2c75334cb29ff047674d5436cae8e2653b7367edd4291fe944a683924a992006fe4a093bdfaa7b02ae3b73f4f101bc4eec2425ce0de4567a42c4fc44c382cef72b547187a6353124cbc9c08dfc26cd221fd3682dd9c11c51fe8b4a9f22320ae0fa6fd9c3cd725ca0c0fd25bba841ea654366d3d357c10c369e033c3f26d3b8b60baadb79828f18004f6b24f8e42d14cdbad60cd78104261f2f435165e7af53a2d0a37355537dc97fdd6fe64e273638437ff30ea0bb39cb594f9d38f833474ff0e3a8d51de14a02d36c016ee613e77dd64d592b5acc21ff8764c68ff406b21e2fb967bd70625904671d198718579550a90d83ec433fe5097191d1f95f50b423dda8b895ca1aca42e609427ab73ccf6b5fb8bf3f85fc184e6806976f55630c4f1616c26c60395e6357fd33e93e15298a01daa58340358524a386e2e406d564f03e7a101ad2ddfd853a881dcc4190276de4c4ba2eea751605aafe1b3c1ebe0672475751cd9ae75f1c8d3fd2e2cab6357588dc3a1d6bc06e306cae2275d728d10169ce5e5c553fa6f746fd02af10dd6c3aaa5f431c1d29830ae22bb9aadc9edc3826c5f514a853718a82ca3efbf48e1a43ce19c7bc2d50e4b1ac7f5cb11dbc228178fe69d8c3b1fcdb436ce7215bdb10fd6e6fa427ce20ff12cb363045a9b4586f8b0707de07ad0407cf0da1730708924818c37b070fa9590b89c8e0c5489b6ee5ce2b56fea9125bfdfab0ddcdd48c66d557dd613f1c9b4ccf4933c412b950a71f7bfe4e857bff0ace9cdb56fb692f7cd35433658e52856ceaeb6e0fccfde9292a85f0c80d33c57da9b79d523aa717f29781511145bade5a3ac84215e57ad603e07aeed6dff5bfe186b1e185a47818a3780e060a7cdb7dde56dbd0f881d7a2b5bfffce6e509da23b53ac638df4f8ff0bccf3390d30b48f81bd5fe0cdd969d9d392d3d9eb7194654533939cf2bac53102c169cbfbcce17be6c02bb2f8f3b2328b355da3578f298085315e800be0d5774fe6a33630458d5087c27f38ab448022ff2a9f724dfc3e2bb7945ed6b94fdfe9c5ff2b76dd84b9f5edfbe7c376dc9a0226ea66ffc4d09edaa1b42ec2c7c70b99e0122d5e44165cdf4a5f70666ab3ed536255f1bd4e88f5c171f392b4a2e8a8bb40f1e7df529670291db028a5a971b771fc7bd0d2979ae4d8649dc4a050e03d50c0c13e446834a87de2223eab7a4237dd2fe477763df7448023a4da8f2f35904f260aa860bdbef193e0a6db3e7de93b6e6675245a39aeefdaada706694625ec31fcf62ee9e74b88dabbb7cc51d2fbfd1b5c3459a8ffc1be61e9ae1dea30f19e109cee6ae65b15b5ab63bbbb2d7a5ba17af0cd9c6ce0339206478a7bfaae9781f7f3272b25d6b5ad5192a307402cbe5fdd574f304adba22e8d94b80d36ba769129cdbd2e958535ce347ae31c217b1dadb62a47acbbd1e978283cc2b6c21baa734fffafb4ff78fb72f9f2c4d3ee7b3114cbf644d1fe2e974a5a5a0a943a1a3ea3296aac1fea0c53041cc05f0fe4c8d7127ebcf78da95c619d6e97e1023a70fd952531fc99b57f4bd5f7af189f3621ce1b98a3e0bff20e496ea80084ce321d4fd95002682f101038a4947aa3ae0a6089131c6289f3933ae8d19189ec90b74c275b1cf3e5e381eee8474ddbabd9f7d12b6f98d1631ac9c611d0ccaf155f224b02656041a32a9685e9b3cf56d4aac0559c524a6263db8f76169468904c289d4de507769a190a9c22b391521682aecf615dafdd4c4ca44ce239b3a36dd6c750ac85c028d06ba6864aa51eb47a866f83abcf12de49044d4d29703cf157599fd58d436667a2843ba79f07d1fccc27a1609d16bb7a264b4584511288f7dd4812bcfeefeb8d6a3c30e2375af9d043ac4a5ea9705299bb24e1cf8097b96df33351a6a11890cd3191319c2918fe02349ac7dc77a8552a18f2f5a188b51a14489d9b50894769110ea9401af810dd0ba97a1657f940ff59aa35d1e1878d481c5f60b759bb496e9bc49998e299a6f8d0b6f118b05f8261b4a25a1d8617a69c6d723e5940880ed1d78efd47072ad69e0c4bf5e474013372d32070a1ab3f8c1785ad075b6ae849fd2f6e0a4f92c6a2262c5039be27bd59a18150bba3bb23350e30d86ce3632e3a2744d770bd50cd6c1cf3048003473e0e8d18b8d4a0dbb46dda1654d487f1055d3e72bdad8ce02a091cc6487fd7fc79cb9c8535295e80e36d5ac36acb8788da125b3c091d9dee7350ecd4fb974b0ac75d79df8032a4cc500a94810ec58dc92329b61d569b8900d6c9b75f9b7c2b91de25c0e9f0d6d5534cc1eee7543dfa95a78c7638831ea49905515e478150407309b2be82bd31fecaaa8defac6616b74c6c3751850b8cd4b16a8e1e8d0adaca3c63e0d5028fe72f57c1ac37e3db57c66adcb55868ad941d9f1151b28d3b61f90d1178ae1ce01752480ef1eb0c169aafee5a4e1d9b187f5e0baf9ffd745bffad1c99b1affa45bc998606d084bbd1fc7243f4e37c210cbbec55d0131ee65028d148c3b70b05d53440464263efd95b0075835b26a0d6bb1846c77f7b13542952c152dc542f5503974e0dc7081523153f8aa583ea9500551da827759bcd156510e6bc14c263eb80bf7508eb2871acb452ae8e4bdcd8f5f77b2689983b15ffbf9a6af0f0157c0d0c9496a8eb5f714146d0ac663948c08d9589698c5c08802c2cba72f7e225dfde00127f83484ba620663b913614f6e6e013b308a1b847e1fecce199d0d51ebeb45bd23bc4179bc0de0bfc27f52e4d9a920c48b4794dc965a17040328bceea6b332b3403fb1431cb2114af14fdac5204294e9cf415d982a02d016207419447779c0969428cc13e70d70227c1b04000f6a502eacedb78bcc9ee01251632280066eaf6ae52b0b67aaa4a625aa996c6929bb469fa2235e9f90bde6f3e9f9486dcb6a6322ae5227336a2c793f25a6693ef3a12b9d0d63d37757ae1a67e9b85314b70484aa97d0252586d4a15e129bb9d069c691da6ccc36bddac1eb75ef560f859e9f72be161c1c6f7b47f56a04c12f32931e197e36a6e1192ba6a3badc92a68fb2c9888347f7962577282d842a4173e32d0fb887168bd3819e516aa07de6f3d45021937873d5c96f7f20b6911354cbd21d0e444a7629be0b9987d126b719fe62e8a57ddcf5b8ee0492402c6ae831b4b946f047d5355fa0b92fbc88496e4802717f26d80137af0dee04aab69f9931fa079b6d837e465381b0bf9ccc45d5cbe2ad1263cfc1928d8dd8e37630ffe9fd9ed4a98e3552df1b73d8b1cd7c41f8934893d40768e74df5595779332ff4483ffa0fcb7e4dc13f7bf79212f8127b0f19ebd8d6bf9b97ab232c561f4702ad581cc4249a3bd79b488eb0a3c395fae194cab13eac5e5d56e2d4ef92fd0bf4b71d86679611cf46dd340a555f74e0790c01914e6e21d12216f7259603a3f146c9446f36f16696fd9ad086a36d41a77d34cab04df77cc5ffc61f19a3a66e354b840cc6774ab3261aa3bdca27052885e798108f12b9a65ee34ad6ccd89eef367f0f5858be6323098b30c49e034ae9c13d47f56948d48da1f99d87936813705d216fa5c89315af99611c2c0ad012983cb763c9d207a0431b2eef68b68da1092dc16347d92a3703c63e0eaff0d741d80c5e61485fbef93216b26242a77aa19ae9cd88d167a0a7358eded5dc000ab0490626df04a9b6982f934228f92db532493911eb8eab2fff64c3c8604afa4321bfb5ae65b99aa92156b08383afaddc897408f8ec504b3a6b9c980b4bc9456cf0e14151a857942e624e72105b2e6f1487208b93aee049c8b0e72595fa2e42d037ac485dbb7e8a598f1f08c7859f02cb29128c7b97c17f14c61ae5f528cd55dbaf232ca1a97817798e7208194b862da9200e50612490c4ddb4e9b2dc902990f669f4aa6d3018aba8ddf5b6683a38ac9e38e9c878e7831cc3df204db4a25f0a68361b3a161afe3552fce6a84e31c48447977352235a06b4a5361de4460e96908fefb056e90f7857e87054d6937ce9b62dc5234a3a35d9fdd4f7bf6d5636d8fecde9c1ccc41ed1dca988a5b9fe9d42dc458adcf05167dde0a9f87e5fc79cae31bc678f65711518414670d15993390c7e9593bd0df2857f00df6e1eb1f0c3232e78ac4343eef3a55acaf18b5d068c2cdccff69388d846918482d9b48633c7fa996c2de65a4d9a451e79799584ba4364ae8115d50fff757edc09f7cce16b616439d76f31c805ab04a4a3891d10922dbd997a064a9a9f62ebb424ec04aaf949d71abaab6aaa1be4026a2c919b78df749c7554d9fe81225435a5879c5c783834117ee067cafc8b830446a117617f8aa1f84ffed1da7be2aba527a2f86c0bc861db06fdf581ad9dfedb07681528e022ad16d1187a3dd01a4576b882d08b943167cb86be1af95161fe30d59d82629cd7495a0a658cb39d9ef5da526d25b8a3555221e85e84f0e5a20efc355ddf355b3d818aa9a77d71196a622d7b9d1878f3e75c26d192d23f1bffe4cdab993e64b36aaef1b8c389409601d1b81e5e115be7898be19e6df822feeab792229053865fb7b65dc0f46ea54fe30a2f2ee1dca74b700de093c30e12c7731612d599b138ea70abda6df96583d894239d4bae666583080c06e98a6511273ef66969360670213ddb0f21dd43b3857c2d1f78404050726a207eaa245f1a1bad5031d5b0e6fdf60bf12da226adb3128b671053f3d5761987454f5898f9143b9f226d3895fc06355b81354d5ff8c54981adec96898b1da2e7038da9418324aed312550cc7f410c140aa6438e5560ead08dcdb59a7a46d51fb899efb8bb77e685f09b6f77b44b613bffa0f106c30cd6fab543c7ef90b62fc74cae1db6d4236153d2f7ccff11ac74eb52a7b1bdca34cf76aca7128bd68f019514cad6ff5ef70ebbd95f95b4c99f441707a177e7e8af8e6f1e3c73c1859a9ed2360e38f636c26c23dd764f06a7f5b6eafbbe65aa156bcdfd86a95635a7ec75db98237d83bf2ee49f54d9424f131d22658fe17edde17bf7045a5965358bdeab146f2a08518140a3548c766e605eae7721002799e6b1f86b2cf3da5380dcac6c1401a0907711b593d501ea791bab228c5a0126de81adf58c43ac55e772e6c4e344871b2143d463d3509875b7aed063201e93b25203daa5f0e04cfb4874f83c33b1439fb2e18ab5946645837ab0ac60f7efee55682fd7dfb78744b2e5f0eead679f6f70a2a9a790b3d4376e053cd3b5c96d894597dd23ea41765a63fe1d9f7212b7091f1e0ea054eec46fad09a45465eabbc9ad7754d74af0e5a3cdffe3c43d7d9ee8f28d50b67d3fac4c8b86a87aeaf58ce2d00fe2f26481263dd187bdde31544939c2732df4900d64c8edd88d7fa173a2d6164f4000be51a8c81dd46d38c2f55b506ec89a6f50529f9e00162173b76a54e7cd60ba35a3940dc75318af4ab10a14bfbb753be614611ef3fe86e63dae2c0f1c912eba9c4b87f0d8ca74da4cd954edfa188b772dfa50ce65552fcf7c25907d29437c781f4f245623b68af14f7215c4ded12c730dcd53db88125486c25eda9ab3d86d27b02a8274cb8cf035000d7bc439c84158a96c56e18001b992aa841a24a20246aeb57689de8c6acfb47495d17ce23b60859200b89b2a71b77d8e29e351dd2e206e58be794e0b2c6e7d1777296593fba976345511629a7598c8b706e5dc5f005f6f2c7844f70d9a17a7c25017cd281f362dd51ee2f508c8467333f5a9aafd085f6f65991c619ab3584804aa8524711db48bec2ef252d60fa11537bf7770824c71f38ff2879249fef721887c1eb40ddc121b906da62f3c9e35f64e7b04f943b1da92feb1d92d7c176daaeb8fd296604d5eaba04864cfb04c6b036d2f8320976f18dbc52c9426582d32a9cf0d813c381fde55142c179513f39542590bfd51010468ec0179089206b30545c6b1ab5c13f77e24ea77e3835d4ad74a0abdf069ba0903047b59e99dd5418bcb61e074f4021086969b401659438111b19fdb6a409f9a4e501cad72ebae1169cc8ed37ded1ca2c1e830043b434e0a4a6a5bb36bacd0ec464739e79cf031dec96ed8b6b96a4c9e2e1ed92d0e138517befcced50291a163883b7b5cd5bd4130427ff141c471d70806588c2c4feac626c7e514327b8a06a693ac47b5081476fe575e4178ed7e64c2c6271f489c3a719b7f959a1a5f29bcaf17cec5ece14f4d739ea5a9a699bc9357763a84819db8e86452c2dc7e041c24f3235369660a008fc5443cc9fdfaadb2e99bb56771a812935028de8d2d0272c408f8e0ffb73237b950b16b152b2db88c76f9029e2c501c048c066b47bca1a6648be1f2e51bd03d0335f02b2b3029b1bd41e93bb9026256399ef4ed10cab6a4762acacb1f98ce76e5e399c4cf06118f63d82d744ca1d7e4c2e9bf8205c7904b2eb36d33c847b229c1a6a9dfaf8bd8e7789148a08782e4d8a86dc7325bd6e0c228982b733d2cb7566f44ac422289e7cda13fcd75cc7747d689e99ff97be167cb95255d5ac1efa3014e25c959630636551a414320d8d64949596b470c80d18ae483bd100021d53d8a4c8858982477d4ab69d12da8e1f83a466eedea3ccaf26e28feaa0d974a5249b3442dd778bd281c03f5897c7aa61026cf887ed05806f5d9d5d2ee11000a5020682a3f37ea6f6ea39b42d7d11347ab821f5e505e7786f5471ba109a9c018958807da3ba98cdb486c89edc709b2794f9b42a5ddd29cfd5fd165a13eea76dcfc8bd67b8ac9fdf3d42d5767bcd6c42742480969477aa840bf3bbfbbed33a5f2611605e420247eb331cd7559d2d57d3d051cf6a9d7ff9352d57f0c6bb6bc1c6c74b25c295554754c3400f69e747042fc223478ec9ee83689f242f2f25fa56ea41f604ae9832031cf48cf1416fe410bdebfbb4b3a0472661fcd960994413dca89e7c9410e37a9e4e9c13f3c6a5ff4d537c2a949296dac996dc743b92405db5012946106e286d59f8ca2078c14c93ac87db6a821d80510006f726875551eb50c37833b5bd83fe0ad4783b79949afa2307361e9daae2fa7753de08c4fabc8b2bf61a0c358d0ca243111b7cfcd2dfb7ab0b42058e39c5d3a5c94e20c13ad4f427d96f7b4d5dc21e44abd294cc7d80c75b21dd1cd4651bc17d116dacf1e374aeaead0e3ee160006de49864c595dc44dcb9a2acbe5066b7e02050aa7d74c61557aa24c660c0b19517f33305689f77c9abe446292cef4be98ec62a13008df4b5bfae03eece2bbf4eecdf54a54ee72460c23283f4e0bb57a9cd15aaa84b199dbfb0b0d5acb9cc83f7495e17638b2f15e67d174eaa607ba2e9830ae722f5041a8bcb3a33333dbb5107ed92c0deda14b6d55c53d2bbf4b248c1da85fffa7ee5da2ec60941aee91d96677fa99b7beae97e3f1eec2f803df3b822f553f4972aa9fd590e9e16dac9de1e3d3e8cd3506dc73cdfa824fdb110861ac1520470c3daf83f05f4a66f98c5f745ff7e7faa0b8038e2ea0c6d4b9b5a555ef562840c745a2cdf212f62bbc44b3a3070f9ee694a522b2af067c0e0f403fa6555e468acbd6688c79b92c1512d74dad5f1cc532a1eeeff2222842e98b17b380680f0c5f4d6f55e9a0ed22f9b4f7a0a4b8d022012775c8fbd776e42217f67be43ea6b97592a7a380c5c277f20453e8eef4fcbe8e2500273b0c44c7dce4f29ace28ce6fa463b840165816ce53d5e185a5a7e4b872be61058ca2d14cea40635d854690b2d3aeadcdcb0871ab187652138847c6e947071f8255e00a7baca75ea1acc5749458652b82ac4de6e4cdf18b9ca14e2e23a59d9b2ae7fe63bdb9c8c7918a021165612b2282d9572fb80003e224044db5285b8d8e10ec255f57602e76d21dcea2356a0f365c19eb8d0bb16b5a3e08197b40c16dfbed6a387a2a2ce055c5c59b69188dfb13e596e47ea783d5b79fb092ad57fbd4bb18f3e5dcf056bfaf0248d126efbffc3b94b044994a7348633fa1862db5cc450794047ed0048f1cb136c97a1605220dcf21d017ece2331464a1a1b543a3dc123e6ac5e3fb55ac08682dce4a726304d8151d4d50fb11becc29374bf6e02e959e9ffd3a2c9a95fea4e6517b53ab922fe657b41bde169326a643be0a298712ac627f0cbc1155a7e0b91de287da0107f14a0885020b441c81832bc6d2015fbf33fc811de9422d8907624597a8c6cf606efb95a6956dc735b274101a07a64cbf38d440479f745ac8309b0d6a8ba6301107bdc6927d93ad647a472a660f11f85e0d1013dd5354abb6bc442a78acbb860f0ab52a1f619ea3c4ee187b63e9816f50a1e73ef7abfc7d539891bf1d54806df347dfb6ded4f7cf69cd6e53a3567495762ce20f354900930488374514bbbc8414059ad54a1e1be6db1572212660bacc8c4830e8eb64b3b19768cf1cdc73445d3e6e0f3f304e16c840f30ee45a36fb8b33674268c7fcb5a706deb320f7495a646b82316d6dddb50f888696bb2b02ce1ffcc1d9045703fd75fafe52b568095c8ce5b78b1d7cf156a09a9c3709af3f416250d0551845a3a9a2927fe5ceb0b4e3d7f96cbb6b78c23af1f37346fee57eb4bcea4b1b390ded539790c310c3fa2fe4eb67df603718e8bd56b0b6876eb3c841838a5b456ed5c27a2c0079745c23fb28f92a8c917a752a86acb86f8820a75337ccdb8bbdab8eb0084f10e5bf5ced9c0c72ed86bcb932c23ddc459a9b181eb0869f1612f833d9eaeca2300d3e19d891cf06ae4a40ab6baf48fba13cd369e9f73bd08b85891d843fbece74ffc5437e1f78c5789b2ab28bb29da4957227229f53fbf53cba327baf0ce8dfa1dbba83adc4fc084cd99c475a3c7d06efdd448bd6f5b05ad2bcd7f1d706e22da5d665f4714691abdb9934f66b1117f3783ba174c7f3b991c52c3be0330f456ce668187bd581047b599f676185fe95a047249c34e85a43c3794f21cc71ae4122096209106c9b75827a7524f69925912d65e2d2317d781c1c7a5e7cc9be5d53dd599f14005a9c529f7b67f4518eb5300532f3459322edb156a2b96771b7b0a2fde06945d0ad1ae0805272f01af2242a67c18ea1407aa05ebe25b5276b16fd1197a98ea3a6371a4bb5b52d4296f37753a13034025de720fbd79d5a2ccbfa43a53b8013c79f25a737b2edfd87e1dd2aa49fdaed2239bd8f9edc44a11686abc9cb8c321308fbd88c2c88358c708f57b097055eb4d98d500a6ac57aa96b562a7a30883fe0f3ae09efdeff793c4c932c50ed4f39d698659dbfd8d7da3a4ae397df332df653af158a27e812d8915a1cc46d5f0fd9ebcb7a9dc1cfa47f3a18a15f2b869794052c59366242aa6abc9c7f71b2c9659703bf188a0331fb1bf296fd0ec585874eb6b40dffd4cf4d2903c8ba56851cf4e4da91329be73bb28584ec003a82495ddf22c26729bbf70f6e68ff14571e432e1fd42fb335d8f945f00316ebd9f9099bbbe6d307fe6f14d124067dc5977e7fcc11a97bc0fb36b83553a413bc9b220325125e06515f76c44e24f5fe0a4e12d64f22013ae4b9c0807b5c8763873f21d4651117dc234f9b86423fd89d78eea17d445ca02e2c42cfda8e0727c51721cdc25b7d9badff0e22dcce18649e19c808b4371007fda3c3d639cd20393e632405ed2f3f26e927b4295fd41fe22d72ebebc9d1782138b850cb4fad6d0c7ad8ba8eb88f968489d64d01f57476891d40f1bee49376987408145b4be12fe06ee1c6e68d2ecc8699647879b275cd41c1790619eed038288e46775357905f7c31a3b2fd86f10db1dc56e84a6ddb02c5edbd861a4929b91324f257d3efb78a8353e9f14e0b4314635b8478a221226352986660f6ba34c11d10b16a4c08539ec3ee7f0b7edd97feaa49d6f7c115b9b89b23a38daa5046fff8ae5f3c1bfad97a9524e51000ce65bb198fd61b1187ef4ce4e4e532c6bb5b11c35bd04927ef6af84927c20d462878658bbc79e4098014ad442655281b257597fa74b588d7027a2b1984ade8c0341f956115fc601b6dde913dd7a94d2394a7ef4fae10c421cdb1e649bebd26e73b3ce0b482349b0c486829d19a19b161720071671fd665f7059890da532dda43069babcaaf52292701e29c4b207f38aafdf6a5b22c7afd9f9c73fcf6b52489d604d0ff6a374f79bfcbcf5192e4a98e9c3b0793f9eb543dc766a0efbb6fc47db6177daf76b56658be9907cb35d72bda4d95727156a3fd927fcec81425467b3de92998fb7f91db25872463d710d88c6b41b2d303bf1790254650a6349a73e2dcd02fb7419ae5defb0a760f9021caca14ddabe3416238ad0118814081daccbd8301ab1b51f73dcf33e809727ce38ec89c8230ad1ebdd9eaa969e1e351fcb3d4626255a5376ffe2050fea93555d772b36e4ee49ee12f5372a38fa042b51558b14c3a626956fe9a6b1d01bd95d1714145f257f257957d077aee5daa5c5c75e28068acb07aaa56b850e0274f9e46dfb755c658f2de475bf29a857c09049ede6a9e7f5b17b202db3736b9985be6c116bd18e06cff8efff30cfc3e894b38dd3a59bf513c02bdda3f7f8e2b8b876c583837fa93e95e0b34ec66b5397cf2ab9c9eeb0b786139d264384d6e0110621334280e19446245846a1f5a4a479e165918b8babda2375975ebb6c0ec52b39600795347491e142e63798883b9247c7e5b7e5e3da2c370649c20b70fd8adf294d86c92f2a6457b51c495f4ff050cfa25ed1900221238fd12c508fa8c878c9c54e76f959e3b48678172cec8f504a8d21943e9c4ad7191b154523bde2f045a87728cf15dc9b85fcaac3efb1063346eef48deba45e5e322b7e155fd3c932cca4578829edc18f35a703217f65e2597d780bb6b699ca317d46653f513685bff71ad74fd3c765550d3e31200362190408c87d6d37d6091ad68b2460cdf38715ce96768c5a32b5ce727f44014bde7c39e9ab1af4ceca17718e7411ca8c04d5511f30e32d038e867f4a10e09e70a46ad878f07ee9d6dd8324820a85f477ab5e3d0e6e286016079da371ace7875093a01457cb314e3bd47f9d688f21e6a23679c410404c1318e4e43a817a8be15f9dcc4feafa05abba10322cc534c033a021215dcb97f6fdbeea04f3b0cd9f6c18136a06cd03b8610d33e09c39521e0c8161402c2a87addedadae64adb701ffa560a8547ee307a1fcba5f8500bb8b364ec1ae3b7053183f57a0581d678369156aafb71b41f999ffeb8fd7204a94985e717b4ef8648d19d0d7802b39eaec98c2c9c7e37365f1d2e312b5b3ed7d9465809250a2fa87e00785d4fac3e3ab05302b6ba13cf293afd9c3d53294f046ce95f90db63f5e5e9a641ce549f75721ca67de69379d7990aedea366a2bc533ef3547072591eb4a0fa43d8595b8689a761a5864986d9cf67a5b6a7694660777acae84381d4acad834b1661c074f7bc9d87d9d6c90e98cc8868aecfeeed6dc5d0f5c93ea4feb76e35000533e40897bddfc7aeedf6270f011e85cf6a8cd39683261d78610db5660c2901ab36c22fb3f1f7c36fdaf8d5e8cfe5794b1521925f1f7939a23d02aaa3790ff0dff2b9f1256278b86d07e4717553a42aba5a1f5f5d4c7903ca006306a7961e77f37ccccda5986f0aff9e4e57bf2d43f568bfe8199b31e43927500969418b5a9ba3c9b83d8f4c1f6039aeaea7d5f0a85ddc4608cb527e7498c93a3b6c6430801f5f26ee8ac567ff8ce7e7c4f128664d58cf46f694de4f4ece4dd3309cba7b733a0f4fea89d65e7fdcd0b446562d26b96a7f291df7c4833bd558f5fc996434640b84c53c431e8186e2b33cc33892f709b9b314fcdcb0a5aabe55fd06046319ea726b56eead034030fca261fe1cb4f7506ac424b8dfe4ff12a08aa68245f9a1c471606f22f3cecc3ca455cb6a723937a0f470e752eebb105cfb711246a55272f2cf2547a41435fad1f69642f65bf26e726ac9e138ff0517fd2437b679f892a988fc75e2bf73b222fb358aa6c3ab35a7c7391ca134a3ef711eb85b9d6566a348d01d09d47523e62ff8107d5dbae9cad4ae43a41818ab7231558c468927b7e7156222e90eb393e6f4a25377c0a2b0e351413781ce0de0e5ebfd9071b3a763ec1251825cf6cb1807366e5aea2fdd6c4f422c39098b8f5ae5488b450ddc5252b786102995da603c8bb01912098bd8f2377de34ef1db2a41dfb650a838e7ed9998d3c9929f07bf6ca8218b107ece08d9a402799cf8c351900904cb797d377d05bf379a6270f001ee1c2d5ac5b28e5d0e161d7787d567e67b9731f7c57fc36f3a1a685eab8a0887eaf1ce6701ddedeab58d7420df9520fc195a630d0606d47a32d55ed7c197a2a96cce52b1bd09580688fcf9c50dda9dba656a25635d7fec5214620138baea5fbd3105690f1ce2facfa0a4b8de78b6697a834d43908f095895e32bca4a9909fae01b573ed1571cbf2a4c7e7a403b8c777a8977e97bd4c9db02ee065e5a019c2ddb2f92e7f6838e5295615022513080b601ac84b37ef4163b7d96336ffdacf52cbeee6b1d387c8d3d6ee05dde9398416f1cf51c5976334c887bafef32a871528792ab266790792be6f5c8a9370030e224fab5ed4e0b0abafaab7c9bd2886b5f28f7fe86b902441ff1cc7f72cfbaae619d09c458c9abaab80c81b5ed636fca0d5ef1105cc0215fe80a0d5364d4cf4437c60e49896d06d403fc49985c34731eefba65b95bff76cf6e91121cb3771d47b511f7b890b18e56bb6516d7a2e4346f1be841cf32fa4d1023e325acafa3ecb1f4be3d7ae5820b2697c91b7173e786a4db7773f359dd97660e18cd3f98202d4f3bc9db9d494aa0497a89ea063b058e887c7d0b860bff220c054d87abce22e6ca4064a1b51d27099ead09b688ec4de23524eb24bd0d14561f5322131c1fb5f981d74ecfa002f5a5a3afe09e5626ecc74aaee5f934a074f0409554084e8a926fe0aa139876c990e8f5e7fb68f8a5cc521f186ccf650302700a88ddc1ceead7a4b5737706918c3124a27222aa668887f102b0436a99e9fdf40f58d6bfaf8cbf243332be5b1364061c646389c3a5d3439c7e1a803d9787b10a64c36f3fe450e3c7b1f386d33eca88550d27430b3a2891d0d5be8ce3a53629c6633244c1e33756f7fa32400ffa814fd98c7df6a03ebcc2a2ed9bd361e6c85a4a2e792827c0bb96a36e225ba627b6f405dea5664844fd34f96914e66d3baa985d8be12010cd69ff0492f7bede7cdae8888aa6b05a94d9bd4dafd07d99b910f1f5b82d6b04ae66a21813db3154ce8d788cd5efe0454e1da8de87983dfc977426de237565b55a0b0a750d1c3ecd53da34c79afd3faf59760d7f3acbde5a014e1db1ba2c4d96d42ab0563fc21ddf3af89d3c05653dffefe85c674ebf6b1e8468a6db42c82c687f99bc579186920016ed7ff3ed8b523260d1b7ac30c60ee94e91ad9e7de8018ffeced6e5c478ce8a7f490b7d5a65495466685d47364e8ca8e2bbe90372d01077e65d0d1fd10c8a3449be2eb5df86d1c849a445a53c55f1b39b4167e77b07819c4b7e716c8c756a2c7456f83ef903e1c7de262ab23a3d44c58c9374ab871d5dc86fa68ae3a9c1fd95495bafbb46c37a1d2f4be4e0377716460744b0df08342ad5a6203cc5a47f932a135b5590eea16bf11d85ae76594916d1ef5a077030e67964a58a7b0b80756fd0cb4317433d6a09a38d456f1d63785faa6e8a515a19c4290202d06b29825cb73794d18ffbc7c4f44fbe4753d7044e78ccacc89968f3d60e1f01b95a7a46668fc762ece7e1ecf9ba81fb9ea31e024b5993523c53e658f4d52f8aa71b77ab364b39dcd0c3a7438bac4c4febf6bbc2fbb4d999fbc66969fda7f6e0c30831e22ffb976c509b35c8d4e0c31e1c64ea6db53bf7dce8d13bd522a0cb919608e19af18453386de1c72a7ec8f4b2a3617d9510ecbdb1ded8b9bfda928155fd7bededcb15eee5462b641b0b017112937c5a29d81b22c3f61a9c7c7add9744a55dc4c71285096a3a0fc6ac3de27b1f00613c7ac41ed06a20e0140a1ec4ca4ace3368bd1dd215103be06f84eb40b430e715d6b6646bafa8d6830c5ff9a22a7875c3672a7b51385ff24c91213e46ed5e3e942d14a67f816a00c0a60980b6007c7de9a493998e7b596ac5d20e5e9141653155530f7727ac166dd9dd3e30b14972de3ee4a3b60ac3dfe29d6e24cb80a5aa7bc93348be4defe51d105539fc0071abfd1706fc332a33204f9ddfcd0bdcd6088c36245454bff8229b4bcce07684fdb16b71259f22e6704b579874256565e6107123e4ded0d843475dbfaf335c3ec106779464c1edadbb68c905a701c80ae0b0af36a9e6c099b9bcb735ffd5ac17cccc39ec516ad048247b81b971b40f6f2ba0d3655ebd3fb2de7ea648ce2d600ae1eb732fb3b62481a3cab963f6dae29cb149f434eef6d7a68b58318e4a2d007045c40596096cf316882f3cafa8bf691023c753eee0b97ac09dca0de125a88574480d6ef12f67a1af14a96bb22b0c19c322ff1c5be24240fe995a5db5d0cb2a3b99818ea40dd7badcb86c40e94f5c2e2a3db2276c76ac559cf1f876da934f73e6a4234dbf126eb0d9d976e92715f5c85a758b9082acf1ab04f46394ed801d8e8b952b32a36a4c7eb98bb7b6f86d8ac2fcab6cfcf06f01755f3fab5bcee898f97b917215ad87b74f61d277cbfd0028dfe912944fbd7a3acd9fe42cac2a500250867544188d05efd79f3274615e727461f062a56dbd106f7526cfddec76dc0ed956f57ada8c5cdedff52ec992d2ca5825df43c1eafb502d3b65491ee00a275c8be8d00391562ab3e682a86437916817a73534609e8386ec29af6f6b8839775f0551f361a86f6b499979c710698dede3084e9db85d05395e75a093d61541a9b8323fb238c7d97837f2284aa45f43ec2f1c512ca5542d2ae47679b5532dac8476d4b0786c4d8b6469ba010faab5fc5920dcecc9f55ce3149bf71ad8e33a92e3b7e17ed3669fd9862596335e4982bf31e6fff23ea1337e524e2f7ae0be7ebf826560d6e40be7dc11a7f2509204ca38dd4fd218fdaa6ddc045285839a95dc70a5b1719cfef5e0b46da0eec71690c506390956c4d611fbd74d1c5fe9cdb0df063b498cf7f8ea774f700138b3ae3043f06503f015dd342ce2d0b38e8c439495393e8c95c6c0357d3c6fe8f7c2c57d3f569998c46e1fe28d5517685ba848d8c4095996eb1e2106cdddb1c885bdbe1e591a1a58dfbf32e9220ac892a3efbd85ac44acae66b615ec4e17d6bedaed613f0f82b2f1899061747c91c96ecc5dcb17b3c49b9a49c1ed8aba307a8df6893e7e20dd798928e5f6d8fa5878a6b0edfa8da02f33062cfef49f651dd530246370e71bcb486d814d4f51ce2d8029c50bbbb43692d8fa2538ec9ab021fb071804c9b889a1d5b56f18d1f96ef14495eef6421899349b2089f3dcef2fc92859d5f122944031849f6dce2ff0c475e7b519f6528cb7cdc92892adcf4739cb7855db4b18c4d5fb3584df2ca2308678215b3d593f9b9692083902157043f9b4aa8450246f93a845fc2c2de182770f2817cfa011c368642ad2d1d2f5ed7ef75fd2d9cd4aaa440851e5d81d60e157e9c032596d85da3bc1777b8dec1502093e8f1972d50030220114fec4c9d214ec274f372f0d7fd6c06aa1ecf872d26a0cbdc396084cc13e1c1f1282e1f7b2aa937e030a1865cd6a62af5823df1bb37db7e5ee054eac53af61caa1ee38a28bb9c23e33ca379d026042a0fe3f6116fc2b84e029ce67023ea174a5173fe6eae302d86472bb2f1d5ddbb35ab62dd573c9af056bb5c46f9cc397eaf23b6c8980cbb9c3bc5aa4820b967ca694cbec1b139b4af84c9cf784c42554beb025d9839f2c9a4409f21835df5cd649fa972883a9c01ebbea81b436df283e69fa79b222d0ca38797a0fd43bac4b2b769663e978c07d75310bdd33ca0f5b6458ac29bc4c56cb273393304a14b8c9b423491c61e8bcbfeaa5c8db00e043003a508617a425951d1e44a4f318ae4d27881f8dd20280f866746e91488246575e752716b0c1468e965ac0206fd288333247913f28cb1fcdb4d958bbdd7796ea70fb68436b367ee8897d57954cbf8bb40bbb8fea65ae7de729fa23b6607d8f4b26e300197d97603df741b1deae95af52f3077dd18bc5d0ac7f5515d435303b3b6e62577f49f16e152303187150d02109de7aec7ddcad456b9a5f15b6eab21309b44a9c51ce9f4aea7f9f0de4f94ecd435cdb6849f6ed0791b713c20a81c4786701c8e80cc454e26049826f95d77969707efeb4b532a44937895d0d7395bd6452adce5a462f4d4d9f5382c5ae09bec41bfd16ca6e1e4bbea726f435791c756cc22c9e89a51349780fc1fd16a1334216ad35b2d7c4dec9e3a5638cd0fa748d33a863d70bb07789db21373b9da056b9b50a158aa5cf930aa6c0e3a597ae9c0f9c7c3f54e01bfa727d127c2890c42bbda71a056bf75b4a587bfe5289f47f175022704f638d634ee31ebea6bf8584b9eec26fb8d1b99d82fc1ac39c60b370c17464532033ab14bf74ba26bbc559bdc04ed58c3bca97fc4b45d06eb3d95a64370a2afba048f8331285d27a3776327cb37d305747a1226439895e2649f0f7b4c07dc394c09c3d3d4378faf15f8b3306e1a86b2b06868aba137a5f6c1a78e2c7228fc9806611dfae4a35009d625236298e66933be762f9d6b08e6a1818e005d3b5663a2e02b6f7d3a0c2b11ce9ccf9df98af0bec043a32f5264f7f702f2a231ceab3a03db035ca773dbce0fb6b5a999d658203428e11ef3f025801e1069e2488195ab0a076da6bbafc74854fc664c697e3f0082f7779e1979991e0cea9b22d4a7b79d349163f4c1c0c4ecd8474bec34bbb1c188676ba4286a74e93192b608cebd6e844a1fcd53c6c0975040ea3e3c9429899235587a41f1da20b2b0d7afd19a6dd6abad371f75697d880208b9ba37986d692a1369f3adf0ba9d1a2d49027170bde6c97d80560074ec306e31d759f7b5e400c89fce873c0ee08f351252c66726460d5178e67b88327d4ae7d4b625fd2b3b45a60eabf8e0744d9ff44f42993533d336f8bf08746147e4f643bdc933ca8700bbf62006d3b6044fd0cc56e09a1a0666097180cfc9080bc26f6b9ddc23b90a58c688ac578a7e4c27309cc40c0a46c544eda7e2aa342da0f10effd49fe34fec6e9a1cb9a89b6850f9f866eec4891d86cf68bf2fc33a9ef281540b931e90aad1884d396707d801bbb9d6733141b5ef33b83f8329e59acfaab2d8d96fed64529679dac7d450ecc62986439fb8857672363b64640ef0a17c237fcd9e8c20b0221ca7970754db9b94abeabf1c7f9fb94906b009e4498f08a34373b4cdedd8fafadd8a585f776e4b48de073411cdf3b41e55638e50277ca645b8b6bf3153d0d34a352efacc37a27e8820685e6780ffb30585bf0aaaa402fe5727747a926dac8be7b215610bf9747288bdee1674a50068ec9e43cc5c31780121c12e3bcfc4c41637505eff65420d61f16533d6ae0cae95e3db7bdc337865ad9bdd95c2cb02956497bb8f969d870c86bdb1bda0185d0b9e9d95fd762f386b504859d8c15074cfb1e1038460124bd180d0f6a8fb48e3e945b5a4858443abec80150ea7fd5cfa41b9e02b99da9d936d39afb26b46ebb52a4c6798e89406a820e5b56d505b4a115c3d80751051c2bf9d8800b4e26be0ebdaefe667e7d3aeea21a762e77b8f9c20a980a2614338029356106b194469479dacb52d6e5d80f4e3c9c5c48cc5504d9833a93345c1a6942c489c00e3f981ca49ff661f7fb705ad197a713337adbca600ddb8ed861cb08f50ce6ba8eed4ff12036c21140de1feb9f58534425f0627dbd0a8f8706086f83e32c2d8cc070b76d547e835298906c97446d48d6d55711c3c13cf9ce228a3c7ca685aebea5bc93ea10dd6f0a6b6e28ef13d59fa7a09c99a18878d3c06a19726d969ed9ff1cba6d5e3b5c56f68065a70cc36e7a00ef67005f3a10a50eabdc95f042d21bb7314b40013271e7cc6ed448fcbcb45a801c34e72b604f4bfa9da7e808555839fb7d941cb66826d5c75954b4b8eb32f4ffb7530fd7fbd11c1f6c896ba5472b94a623766e9ee4c353426d9660cec39e74776d48dcaadab9962233a12e69a0d2c3c1df0eec80bb5f3d0ef87d1faa3d9c9db333799a36fadd298630bb41ff8c462c995ad5ff83d46ed1057a7f107eaf567a81caac6cca5252eb63cec83b96afac8bec70a0bff2dcacd74b21e08eb00efaac5ab4bab4a499c3c6ee22dc63d22528b5e5418e576c43dc4b1de351be9d29113fec59ff9cebca911b641fde67e0ab2fd60b5dfa74beb4d82123422a8068e80bc6835da47300218b1b566f60e58a2c62ba04bdcbc9dfdb9ac36b967ccd8b1a7e94725fe927e1bffdfadfab80c719b9eb8e99bb51ff3438622bc34c6b26a8b5085b0b579f9d16aa703874c977555da565199af1cbe6b92f26718596dc2c24432a82175753bfcddd35ad06cd8578e6f07e148c59f959502a3ab9eb0ac8c3bd599a185f6ea338e8a59c8bf712a98a4ed2a168bb88a636f67cb5e8480ba62c0e7b46e333254acef9cce32cbcb7b403069e181ee2b2397f779ad005deeb4061a6f504bf5ef7174f8bf2ade615329a465ffc126b9a879c2d122838bbf9f39b45f4041d36f726c1eb0274d2e704118034278da27eb0947d0ec4663fd4cacd0d20a71bbfdb0a4815dae3377f96e52f76793720c57b533be5ada714c784fb1c46218dbdb5c916393d7b422aa597c2f311a6035dbfc313aed5bb5524b2c74327a745424507a1c79b673366a5e662da4531d5c11c0e4804af395e3af1ef1d2ad2c1dea3048952fcff3d7b61cbc848302675d1dadb0d2e207e0ac4b338752fde78cfe04de75ac0787051ef27105ed011cd19d19ffc9ea77ccba91e40fdd52a8651da27856549ddfb4b8cd236c59e49dd8afcfeef7da71a8430012a2127c051009dbf1f737a7a2203cd87bcc07fd2789364e04e01362857400cefc55c6e24d4828404e60fe0c23d53bce957c607d6c78a5c8b5a3447a70abae7f6ee6a15ed6763da56dff427280fbb0b7c41aa555602105d9faa394f8daa6fcdcaa5f9e3d32d420be192e42678b275568e1b951c1472116b313755221dcfad0057e5b1324bede28d62f5f8502efff9f50270967a43137edab2899712ae5994c0e0083c62c20a337b137fd1275d22062068c83fc939c17be7e7f396caff5cece11f83aaddbc978fa839bf0b3a5efac2e613793fb8bbf1252fed33fa6c4109818bbf2744608b31ccce7a7402e233024bd92f863100bed309911f54d73b87cd8c7b7a450c36e4d1f7d26caded64a8078c364a4f68bbcb634b6d601187a127a94c57e6be91b35adfd7b7307b32b3e76ffac68519ea70a445604be085e59659845205f07429635ab6c5cb3cf4a1a38c612d75d995017bcb873121becb8bd5487b2d657c16b8b1315530e6d60a9dab387cb7e8ca768b9b719c8ae673412c28f1446f7b709ccbacfcb1bcee5257405b5fd3856b7e8936686daf9b8a067918d1a43e860f2b4498287e1ad004fff455cd0439719dc5ad8beba59815da8b898e7335995145e7ba437a9f6d2d65e472aff75d4db56b428d4422a483e5a5c825c548e4ac15137710d09dd748df03d60f234679381fc7535d7cf4550f2e52b1faab2fbd684bcc08ea57b4865a2a57177fd35ee67f76b7f45b11a00cd78ec35d1a10b605bcdd643c00303c0e1518136585eeabab3040e2e2ff991f600066093a5da2f5538668338a711250a93fee6f5a362760b087fcc7e6038f2e53bed104cf7bf8ec6fbfc625f941bbe6ff3ca02846c5d49c1714838b954a2928dbce16b6028367f091ea0fbc7fa3956ebc3b2673f09fd44d62386cfabe8febaea3c52c43b09a3bc55c5909bea6b703f9bdfa913076e87d987750e3734bdc15ee9931df4fe9c8bf51709fb22e6f16e0483f364a61e74e39bf522da6f5cd411d87a604b84115b0a556cfeba5e0403deffe9c0b26d506665553511211f79981d7b60961c30e7e4331e283029a93b1ab6aabc3adde8af085ee9ce099e19f7578acb4000d76dfda1bcf5faf8322d88eb62e80aa6304be8e41d80e6bb7fc9af3008c928881bedf4b06a462ae79675ac3a10b26de300ce1dd557c9f2d00d29a3bb6da11235e970712a08361b3a70dc435dcafe67e5c34629d72ac7fdfe53aaf3e4d103e82e49dd21f4c76ff8b227a50c5edbcecdab0fe919341ed8fd7f605ebc6fac38d2518d7a21302df06898ab40c31729126d4c1797e96b08ecf06432736f4211f791c19c881d1b3429d9eb89b6f4a7b4ca003049f75cde634283f0fbf36a84b063978a84968205d91e13248413b36992b2839a6340f21b0c77615ff02f19122c22db202750f4411214805fd8397ccc43a301da7241e11fd697b7c74943cb0e332db8e91c0edc4824de9f456223f4c2547fb5ac9f5af8ee356422bca7d642514a924e368f25d5d8b8cea8649ecf559eb86495946d83b4a5dfc4a858d475cf849515f810aaf24475554e2b2fd193a58b7ebc76bdb2dbddfd9780a506ca67faf212ba0c19a45d3522738b8e92c13822d0395475ca3bbdf3832d5e2f9545c22da7b2ae51e3b290ac932b1df8ca24412db7f95e38e0dbae0d509dec20f7efe1997cee97d3c985f980f056877f6f92517636bcaa6db1fb626076074f966bf485a718b5114a5b6e2ee6417ac157404a5e1a407b6bbcd125b86128a5b2dfce0f8077e44d71dbbbf8c9d9b89e389b70ad81d20f68666509b02826e10b66a8d90472434ff6061049ba81ebd202f81485343f801f9bd20d15e92df15715f8d52707b4406386cd97a071fba6fd871aebefcb7dbd971058ea53557f637083a6e1365fec4826597ab61f57535c4a0d5c2340d130ac325d5a7a2a441bfaa814e49f13e273e15d2f51800ed7690ee97a5e45ffff50a7afc451e6e9fcda8a8e0fc22de33124f715ad62aa7e1e7c928a1bad48ad704bd6fae81e3354c2a575cbde7885d096bb4e3c12c146c59bd05a8ae40af7b119172bdaf595921e1076e4a55b8d3304fb872d168be88983e7401cfe2f371915b5742881ff9a37d7f2352e2e15424b8622bd8507a69150d2e634a78cbdc51ef1621047ffe574ebf7721f7d90b88c11fa5971147804bc6f14fbf28bc3a84c2af50507234123a586cb0cb84dea69ce64c0ff13fefc517213f2b5f21991d5498ead5fdf6cad0ecf910609d83ed6cc943b9ee0a17f1f418977803701bad213bc66bc0b7b64c1f6037dfddbe2932db31edc41c631ec2ac640ad9b31193756f325c0bd123a2cc856e88d251b4e80afcaf6ecbce99d68b248afe339ea40904bf1085cd7d022c2b23c0c6f5a25be60205f50f231464dac808c23793c55749372d1eddad40966c6fccaf813b1df637117cb46d369c3a073f4e2c306cfa74a5f128d408efca18398c23462b40f3c63b12362f582bfc7a9117571580faa4dbe0b6072f7df4a99d8fb06168c22c5ed5159938b1bead128df517e1fa66c175a5536e044318b77df5f1c9a8845785b13e46e34698478cd729339af7e9109e8a723444e9f6f78ad26931a0c672e6b8c7b8d0bef77c43ebab3427384731fb14edd19ecad06e60a1531b75e5af0624a8d8804d539759de023c230e2447411e46437fbb30fbddb6f9ed5a1f98a9079f5279d7698807d0960334e997206385b0e52114b20a45d234df8a38ac6cb6ff813b6a61f862396790472b3466f1daee7deae0323b3ade4228eb69914c6daa935d533cb9b9c17794dfb41513a83af1175a866ae7a9027591c3737b5430c4bde0de30af1076124c6c45fde0d4028e72067744546ba75c3a5c66a08f5f2736b11673ff73f2f0bcab9c6b6155bcd72cc746c42e63ba8540e9756197d94a8c499e18a7f554723a33aad136aa5f0ef60850f721b5b157a358eb3213671e69b8e1ad2f194e691fbdd47b0ecf616e6d90631876bfd46dfe9b20e5b812361360b62d39531126de2ac1449203692051afab1b65e4dafa49f19864bdc3121ca274ab52b07bd88f35526f2169839b97e8244bf7c8d0d83faa0cfdfbd5eaf11a670200512cbaf66444a13105209feca7d732f76609a36735c7f96417047e41f191f6ca5bfb6f6e01f2b2a11c1cf01c8c20242308f1353765fffdb1e10745e8fbb4ee99629f47dd04eda377372de190e4d1511adfef1fa84c0c13033e071e8fb00a801ea00fbd147473edf53212766591d0811f511be89325449091ef455099de5236d11987a9b696a5b8b50c7f75429d21396db21bcd2411a0c16f10bd685643d7d5c19a76cfb993128e6419f2dcc2c7cf9b4b7b87e353ae5eafb6541acb6c0dac23d6f2b23adb88030bbf6a5542dfd85fde08266389cbf58b5d556f7c4c38d7d784e7a8b307884096e2c8a88b1fdc0a90c3b9e182fbcbac76c12ba1c538e428389af1212a2a06e27b098a68a2fb62d8a2ec35818b9136a44c571b6d99202679bf6b8e37865a0eaaf77b10a2b2cfc08d609e9a6b4e233d9375d123ffae5f18232807b4c618bd61962314d5f57f164989744dbab31a5b008c6a749787f3886533977bfa59fac5a61ae80d3a7a56b32867f1eae9513fa1641146ab83a7d57183ae38741c51ce6c1f7dd1c6e459d597cf1ad51f4b6e793a4209cf926c7a4a936f1afe7198ddad74ab40dfcaa364855f6152086de379f06eb3bc5a87c038a5a0175fd2a74537cdda4942ce20cbf79fd320af3433beec5003661e04175b3c662ecdd29b75a61beb143796fbcf6cced7ea2f01f57b35017fe1aeff53ecb381f2c92f7e79d7dd5d46506406d0144abe3700006cd18f8bffb1cfc27b4858a59297ae64709ee06beb8e2d3e50180b5739654d946a6fb8cd672e3b35ac7f7ee32d50ffc542691bb37352ddea77c0d9c3a38431fa98d240198cf4ccad51443b75dcadbf010aa728a2ecdc16cfed6564934e86d7bccd5ba66bd6c90aedeae99c1c1edbb2a228bb88b2ad577e8991de5284dc5974817410ab8d49cfedef0e1d1ffffc912cbd5287ad0b849a5f1ed9c41acfdfcae52e47f5bdb31672ab2bb05dcb19a219475d22d2c3200beb2fb0770e0ba3eaf10d183cd7db997504db408f9c6e82f4ab62e5abd039d2a72c58968ac7d3963b278b2de229d5d77461a5085e711cc42a12943439d5ec0e585a671f838e4282f0e91aad898645a3326716dfc935ff1a03f066cc46e68b7051924864459a6974cf3dd6452c095342c34b6eb9e484bae9cdecd43e4a844be91124f99993cf6db9a4593be26a0a700e67b4d21591b4fb87364b37210b133fc5bdc49e47de72e1548cc15605cef33dc0e4f92ef57c7733d55de219e2267b629120d74f7b6e2e56c19012e0d38bec1121e3b627f9c27133ba8f532c2010171372831ce1edcdfa23c61e6d0277e0c678124e3b8d7a9a46f43c5a46021ec334f7840c878eaa42fdefc7dde3fca49c289cab1b10ec3929216e0faa0f3bacfcd518b33f71fa98c9a1015469ab7d30b91047e7cbac4e44c514e4b2e86ab0742cc5486188bd667bc31fbc721dc4d3f4486d2d27dca56e5743e384f298562d247569a015e77c3766c257f6d08f24b7f3995422b0a6d30c40bb2b40f1749b7356a465a6a11fc21abf49631ca6974f667b458bd1f53b02b95a3c0a0091e1a5c27656272b7d3aff514f22df2cf9cb093b3861f7faccc88581e75b4a5629bd23e7e52f464ab8c0d2f3eb17612c67f37ed36daa2e02e6bf397e56aaf4076e13f278f8a925002c2baaac4c447fcebc91ad97b4b2e0c4e010ac030fca75668acc39b3f975cd2607e95296739f0e8423f0aa4c1c4affef547dbe8ce69dbce4da022cfe55a55c3572a000ed872e1f501e3b78f275fecef81ffab7ec331b6b38a9134aaeb44c1cd0971a83c64c5b5f3039c82d0f8245cb2838fefa7c45b918b46be6b54690598446aef76f0b1f5a096b133bcf1b624fe512c4ae21b98a67f2f193773b3d08818598f6820f18802a5816b9343639d9b5931c6baa88c96f65dcb012069d524110b345cff962133cca44867ca77ed1a7189de47e5db2c2a9e0d310d6d8cc7530c0e0c7dad2da2a52b383801bc12092e96421b4c63964c96b55c74bc818cd17869348b204dfc8fb12c0722a05dd50a76bd13e5e46f9dcd28d3f19f60cdec218a1cd8aec9c8de4b377004989c5aad9c7eef9bc34cdd20125c2d83ae7e7e212f2bfcf59347cefa2dded98c8eb25cc3fd1769756aa2a679410aec6eb5e08ed7b868849b62d9a9bfe987b130b6c34856cb190a2e2361d8ab36010775d55401e24ca46cc499d7f42d1f080c930baf0715d8d8e6f19c9bf8df59d4c33443995e5c51e37552b47133621e8bd8f81007d03606861144d930031bf6d425c9eb6e88f59f5d860f077137b0c3488595c1a9755835e51932058c1d2ea0402503dba854d9efe16819d23527f67298809da400bae284eedc428bafe0e313bd1256ad2d31e1ca2e831f848804941b53da004434de67c955bf63e34ec76f9644f8a36716cabd7b17f5f244c03de0093d85894bd36cc0673cef495b437b6d2c90537bef37bdf38517c597883d82ecde1ac75bff6213e8693de32986205d6dc44c03a805174bcc2efb0d1318e7d495a75bde5a384c38536565e5fbebbe2b524fe483745d43cf0b40c3a585fecec33665c116c4ac9eb99c47c57c7fd76f31387fd6e938a08f51ef20feeec3ec2d58e3f7715697650e5a1cf1a87a3f62492204f9dd431f6e96d34939fe4352fcdd5af43864ae036e172a06036419c70cb8f715742cb197875b605b1e7efc4d2aefec9f547c4809975541be3f23eb0eb655922603e245ec85527c34cdf6640e5445ebc8e3c56968d5ba13260062eb576d7aa9ddfcae3327829b531971027db467fb4a55dd4f45ca58f04b39192de7897b0474a281eca688d3d0597b3e7636f2675d8acaacb1a63b8dc265fd0410b3098c9e3f3045d769053729482e73e20c97107b5bd9de48a20f067e5e0b58a9e33b0467281f620a242b2ec7b54490f4a60ec73fbe5b72ac88d162ce14ba86c3f236f0ce2b35f15d77c357594487237773587912475b122e08ab1dfee2edaf0d4de23737890f6537413a2069f3015974efc99baf61c5aa15fcdf9f8e6bc6ffc660ce9ce64857f29b92d00b7fc3a94081c91abb7ec2a5e3a2854c0238045a319b11ff4fa0f0e2c875864109555190da00b139630005f33d8fd025d06357f3b330ed46559e555170357561c0c39d94b9158dbebcfb693f77ad697806e09c9d37793e4363dac2ea0a69a2ae24a68a29490ad8b06fae752b36e13b264fa3830f3c125bf1ac9205c74698c68d29a5b94e83867777b2da8af4d226003a5a9bbb71510cd9548a577fee7df2b34c06d185f6fda7faccbdf1b023e669d972b166c2f7b9142b084e7d85ce6b8ac7d4688ca203fd935cfe23d93b11e06235a8f0c47226a48fbbfd516fd0bb65f9bd0b0bc2d7dab8fc137e0e66514c049f3c2f9c938a91c14c9aa061e4020173f393411c7dece7688eb43344c25ee29b44459e67afdf60fb3efb409bb6cdaafb276e6bb7714f5e31a0000658a0d77063e4ddb2d8f4c9440b64fda2efc5966413ea6f7afa84d8721340e409888b59c4536e44b6e1a52777265d1c704fb224d17f33d81f391f3a93f8c9d8fd955de665fad778e8b6211884c035e4e459bbff2b4fe505fa6b08ed11709410166d0a0238c1ecfaf4e20c97fb276b9fd1cc4078bceed336f6edce03a59d20868f403ffebef71e35ab874ce74fda31be4a4339f42954523f4f00ba0fbcf26ca65eb4661b65ca56520351774386bc90187f2608d3702a9ccebd9a58ddea7ddfeb57f809567795f52127e69d03b3a7f41fb385475794f0fad43a74bb9e41f40df37e318b08fce1b493b428644105f263c1100a3cacc6c3c0f27acd20884057f9d65de26dc948ad0507180f80572368306be5d9de4765c1951393bc6ee32427e7997ecb545087bc564431197f60ed0825b7515344b68aa4619f419723e4dec4cdfb8499e8d617c4423a6ab25530d728093469d245e55b820ce92c1d9e5eadc232bfa46642d6bce8d6c5a0880f0313bb5481e7adf44fa598ea11791f9ee67346c01a8ea283c675885c97a63cffdaa0ef8a8a47def460b81d0dace4fdada861a40b727dbeba4a6f75113b2514815ea97157ebeb88ebbea98ab17d12f64cc0ad331246b0c7b048a3a022a99616fd225de85065d79257f547e92a97bfc31c9d7fbded8a1808237967dfce4eeb3c9a9d45aa25f3e33316bc91cca5a01ad34ffbf919ecabd062078867cf91a087fca27fe779df5334198bbdb406151d95346cad9ca57e2e314f770ecf5960c6674dbd49e5bba18796948bf84b0362cb737ba5629c4fd93d4874934f9d20f46fdcafed567d45babcc5cccdb44c8cd7559bc32313a17ad91136188effbe6530a340bab6273e4b18494c971c96079886e713d0879ff003f43dda86357d5df09323db5317de4344b94b015fa3cf7449cdabaa3cdd54ba04a3ca74921a6a53ae0a709880b2b0db92434734d71d8fc368f3ecf75d331c2093779137759060c22fe63cfe4d7043efada2f7364a901a4b9f5d044cf7aceccf5a78d424db0f9add585060988b26a7d8bdb2e714fab37221bd64d24ebfdc65433cc3420f3314e714bc97c7b454fce53b5786020bd99b2a1858a5c370fdcb938ad6e10dc6691ea0364c43697b0339a839bbef445c35949325bc25365a2e17031275dfbc1c8d0c6b05bd04ab648712bf2bfe346503b8e0045856020aedae13114ef13e4bcd35df75de216a4628ba8c4c32361ce8f246906e77b25ca7b7cff9954359b177e69afc08fc08d144bb65d9b52004cb7cae77cea3638657638d344d85972dcdcc41400de730dba1c7295d98e07cfbe89afc2cba77673560570a5ecbf1e5f64d57f00781e54b013c119ce6fe5079e2fe356dafc711e96696ec8351346142248c1aaac5781e6d4088b6e3efdfafc77329723391c6b42bf1720014f46d60b9bcf17f7fa5b158544fb68ef17f9ae14b221fb00a7f23a4600c6de60afdfc0a2ad6fb65c87bf1e42719c0009499b6bcf89e065983f565af532a9066d99a659975c0493a60cb448063eb0d2d25af30faa209dcac97a59e6463a79a8295be9c1911ead774d4b32ed6f56a61ed14d2d9cc134265d92f49a0507af1a671b92cd10e7c689ae80487f3e87637ac8b7e6104835f9e9279e0f2c2335f8ea6d39fde655baf8e2b8d4e86b74b6ef45e78cf4be151e8f23b269e5554b9931dfa4a2dca5e438cd9c50f2edf0489b8f5b7b9e5780428c245449927652e2995541a2c026554d07785f0fe8aacedaf179a6fbf3fcf70fddfdaf2c285bfcb0a031b4d0591ff4511a46b1e0584e1b5f639218eac9927a1b89d2d3a9204317a3f597f6a007074c1f6f81e82a7f80cd9e3e365a45fc8af604b1af4ccc0f93a6f0e126495a6bb6bf00efcbe16ccc34e67d0b567cd1eed76ffc7d93a915551151b12c53cd74183bb6566874722936f71c891177c29d0f78a1cc17dd356313dde973ded2389035681fcbc265af05c65e4e3c59b2ed2e8595f5f0b5ffe1bbab2e68c0752eca830141f43c886b84b58f0f2b656dec24a93c3d0ac9617adbe0987237887b409fa4da0776f5bb4964264cfe6989c4c2d4d9155bd1684815fd6ad65e3d537b0ea09245c0caeba68be8a6b6bdf4dc5e03f4fa91f07bdb21dd90d6b0edbfd55e34df59ebc0434d638a71531590710b830b89db2b5dd23782bd04da89c715664254f28dd931e542f596df327a869ace2d47f06bd09292ca276f2b4e847752465164825d5d45a68161054dc61a8a14e620521bf0071be9af5a5fa3ce3ab1229b79a5a77c559b37b5aa90631a0949e256b9fd59b991b8806ae50b38e3b0e4f3d908a349f509d769acc758d5648dc3a551785aa9ab0ece3573d6495a36088e29f04aaf9f4ac47385d437623f8eae360d5ae1647ac7c8fb1e0c0d0296dd4bc60e36baf9eae723d3f52452fe3a8edf0f194cfa9c74a6b4da54494520aacef9a9297a33028a4cb29cdc93cef318234d71fe68d1e00c8c8654c8f584b613fd106913bb712c451af64e87bbf1572c8297d4b5bd9d0ca90368c14dbdbcfe05147e4c495d1324790d545db21ecd97660180a9dcc3c9c0ea86553e602f5912c5307083d99ab0c6cd2549eb6d97c8a2ddd17d232de6b721cc60d135661f4e59d62c9ee738ace01835c75162cc18dee8d6c7b79f341ff9f1b20252470fc8bc2a0ecdd5e5875021eb0eac814435eff0273dff8cc69a62c186d32c876299662bc6d58d4c33e1cbda1bb311858563ebde75990f268e529df3480b525acbff5c7d1d34037a1b304f043bb8e21fe9bc2f3153bec20e21fde4e024ad618942d2284afc87da4d2b70e30e46d41af5a692a75b2368ad38cbdeb08126f57e6a94232cb55aa9d4b8cdae5d914d4a0e3a81fc8d3231ad2410cdb4a54fd0c69a4ae52c21e778e20a30a98e32f0163acef2f42f61e35ccfca4ab24a004b63fa40dfd6fe575f35648d0cda34bce3ece9ea56148fa49e777a2b8b828add55bf84846f9f9d4a8b02dac3bf0c71e33a4a554001e3926592b0f996cb6906924d857a7203a84bf43e7186ed7e7457027190153ff93a424d353941e21c6004065244307526a80a77f2523e22cb9d08da0e3894c83edacb1c041cdb6426c4d5974ee1d3a0178f6095ff353e239115873d597b0ab8db4c47a1174f5bc30c21be7d174a0e030c3ab2a5caa26188a880c21aa8a697eb3b7cdc8cf0042a9ba160902a0f7af13156b4c59c77763bd8e71f407e5822ddf6c20301bfaa94fedd34a723cb0e7685565b2cecc13a81c4f2d5d8e7fac74c31dc9cf77fdb72bd27878f991210f8120160971205f3f31d2511d959a5b0b0b535d49a703070753bca496dffb1d193a571098af48aeb4ecaa8e374d59acd4e1df80973f80dfe6750e022e44e40094a9df4ba201c2a2e853ea61f518ec04d4efffdc810bc87610df3c559ac2141a284f9dec7a11ed5bb05568ecc2fdcff16710b8d057fd682827d1cddc3a266558e8c9f5473e46ef15c0068d244b1044a211d09c4b82ca577259697078caa4091a4a5ec9051b6115c6679117a26db290b429174eff797c8adcd41d90fb47fc6723f2fbfe55ba26242535fefb97ad5121046e2986bd6387ee8f068cd302ad52d6639ac54515ff54c5db762cd453539b2a0b7ed11754e6c1b6052c753d99a8aef6689ec5097c0fded9ad8cf9ec1fd7d7868d6ea3a577dafbec4fb13678e3485a4a38da298f7af01de05df011b82c36080be65f7bc1028e0b7b05c956cdf73c4276845d2cdc5f929700628a14401e100f9723547da03dd3c9cacadbb9cdd3f70a6d97bfd61434214507a6b8ee77291be2d819c21800e0793899ba220ffb8642ded9ffe8c49cb975ca54e12ac5bf4b89d4069d938983f3b2000a6633fe011926a83286ef53a016fa6d9cd6505dd884656b686b48eb04a0647dd86cf00e98fb04746b20815a48af4fc52814219eebd3a4117398c408c2893887b58e6ad7b294b5ed41e568073599a15c5a1105f9c994b5492e9fb673b9e7b81b7de919ce975f7dac8d1a0d42d583211b4848162218c517d107c2b65a4e958203c72d9f90d64decb0ad043f9b578f953639d8c9ed51e2c6a4ba84df0fd028c10bc485ed81e26f2bcf46ed87158f0a00604cb1afb5cbee28f259c9be70f932ab79b94e8f54b379df4f6fd2d97455355f8d98a2456f63ee7abad2233ef00a0fa085d087c46ebf8fe84411611ae33a46cacdff0659618046bbc77ccf132272d36495d6118131337d85cf19a063d1cf72a6c5a0d34e3e9f85c857b18357638cccf91e5590bba5be02145375b3d52abfe3e0ce645b53efa0dde40d775a6aab30deb2b7ee580b68e734ee306546f11e416a9d125c02d01828ca04356517729adcbe37712b124007f4caeb0d42b4e0b4fa758d9ed423188db914a4ee6ba5966719c3d7a42d09dce44f3b4824fbdb1d6be1cb015654540698433d12230980ec3c5dec4a33f3f38ff1d12801763e70774de2d0778e3f6b79ff5442dde069d9746170dba2276313824bb9fc2d46a9eab30fd6860e51a1903f440525138c5b154012af74aebfbfdb75aa8b2237c8b4d1a4921e34999265166484265930dbe5c8f85826bf2a039e8abc0b7092d306a08261e7f4d05895bdf05e1422411bfa229aa776c82110c5a45bed547227b8c40ab89bfff36a5d0ec89ec31653a70442f3ab99f35594abdf56b7d8f5f2af71acbb5e5bb1ba62326577b5e00e2ea27868362d2c3df08476fe0c2e1d78c85da4386bf9982cdc36c8687407d468cdc69865b41af4a87fcdd32908bf3fcc7b837d87582a04fa87702a01e6f36b5d5016806018912b656cb7df555a2b5711505253bc329ee14b4d659404f1ad74da8a400ff31f99b3efa0e4ab5a0b9c3531c0fa0151457b14c772a0bffcf91fe752401f666614f77ea2ce9d93c207b32a25084e30beb411fe3f10dc7f44d98185ae3f18fb15f062079342d321ec202efecc2cfb142fe57b4bc2f9a7c62e70ba7e6bd8b8effcdf16d7c37eee7796cf71e2c3a0b564ee57d2888a1d055c2a487095e540e1ea88573d91eb9511df54d0807b76b7eddd9f8eef00c80f6bc98c11a56b62a8f343c5f8599268c18558dcf631687dfe7677beaa7815cfa2c5c38c786a933a3928785b7e0a1718c2e00bf61ac6fb6887cab8854dca10736e20577ecfcc0665ae1acd57a41888542f904a3fc44935e82b5d37a3c384f329067cb8e2860d1f0f7f611e9fb13fad91fc2ff186a67e360da28f8b9e12d579749f62f2504ddfcd5df4f458156c19305d9f75675e27969c08b4063b56166ca1e3963f630d8cd48777bec0421ea19b7df7c820331a0a2e7d1ed5ca508f7960be84522719b9685ab967929a262cbb5f6fd143b73de15b785f938ed9a17d8a5513892cc57bcfefe198e108eb94a812eec4a0b9ea8409eedd4920a2a2eb5c922141713f857b376cd45160570c109bd629aba6a18ca9104c861578b63169566e886a50c089aad59a005f80f0f10e1497efe59df7b03d2a616eeb22ea0c2b96e60f455a5e6a0783b3aed7635f5abfcebfa39a3c41c8114e15d698cb06cd0994701991e7ae92c7df4e45c3de15954d1df6cf121f0f5c09607d6903672c75fd03d42b139c12c9e8aa312227e3406615c8f5ec31f0a00768b17803a5a5f92c9241afd150ed6f25f8019b0748162feafe21857637e241009ce59ff229809c29ad92e40de8afcc021183e13353e2e6b5a889c21cdf2243138d90695908b44e06ffe101121a3aa1751bdbe602b2c5798089882388b9256adf47d7404ba9055b5632ec02edef8ed5b305f166e47f9ab73e4766dec0ef450241fdd30891600bd83870f171e1301cf7d02de0fe2d6344c4a13c961a21c262653272feb293296be4f0bed7747f9e09833bc6177d2e3d008340525d26dba93d17f96fd07b5f191a2f5a25beba9ba8345e07ce28035c5fa23687bb517a8462fc28bfa7934dc2240f5665eef5a4ffd2ab0d5fb9b15994794ffc3872367c9f343847b1640c3b671fe80d45667b4e56c9d08b2b804b306ddf9720f18b0ed528d1430119af1fbf8795f51cff46b70c738ff6dfb20583fa5cb93ddff57e1f4e3d134c45bd0be9556f2de23ae36ac29a8351bc2ba2ed163fcdbcac78cb3e7e80bfb5e330ad6ebfe03ccacc426cac071f153109a026ae015e0feec8b3be7c9d61b858725aac4911030759f0f7320c7ac5e2aa4c80d1719b546c83af9e1dc0236da82ec1893651c495ec4227f75a2009dd4671e2c7758c692c233903f245770ce7e750aa6c4712e2801d9e277c7f82c36135cb1c8198f90654d6456a1667804e2c87e5fece8afaa31f706cc884577bf58a1ce58a14c14ed7dcf5ab1f56520d0ff4cb84941f048f4876070361d818f2044358d1b8b16668d4dc63632cea3466830521dfb8ef451f0bd253e7dbe2a0b418edd4e9292f9422a976dcd61ccf1a330f743477652629f1f6d3f8c1c94faae4f2a9af8164b0bda7bf0b88e48c04a8d44cbf0beb1ee25704ce47a9b5d81fd760a4929ba953024cf1aa98fdb196e5530ac7c78d847182d6eb49114987a461322d414f550b1afcb5a3bcb6a0fc1a160bc9f7f7a2d2db48dc30f6e1d7e121f2bd5a84dc47c15a2c6968731f9ef0c5fe93bf300eb2d876571c8a615557cc1a75fc251991258f225b1fa7078c81225f7ebdbf73240f4e5a8906fe0b227122febebecadca296dbd58ca250d86e54e95134e5e33be3a08759482aa825141029d3c073377b79efa546f4a484baef8cf74b79d2ed6b2b27d804b603beefe5bfa085bf3cb3058207e8b4debe4fefdabe808be5574e1226c3a7f4f7218cbecc2c19e90775b3fc18f75923c2ad8492532a9ecdaa96f3b6cb461db7dac6f9da86f09a2df09e8648c4222ab02e668ac28663c62c9b75dbca31f3f7f550c79f75a96e677d21cc0d117e799fbea3c17833ab2ccf525296338eb049479acdc0ceddd6a111c731e0375d1a410c26137f8d571a1e3675fa03aff7d96389174aeee41e8186898e0163810327f048ae6bec2e194bfeeb263cb7974d6e21444bb199e7e2d1fe608bcd86c9ac5fcf2583aaf3114a69cb57395332ba402aefbb093f9e09e3e506cd0bfd142da787664ca50bb6a42dd6b620b14bb3440538765dcaa80723c7ffff6ec2a13da234ade7b6c215de65300f49ffe6826c83aa287972fe5bbe051b8eb226ce6fce95a004f828efe4747a35745f724ac96c17b74a6e2fb167191f4dd175a335c565b6cb580dabdf08e51071591230c8d94fed0d96e2fd20b0ac711458d2ffc76561af0ed69bf31db1c9e83b78b9c3b59dd87863e789da7677458a80cb113b7607829c533b1fb6634b20f7b59f491e55e3ac7d2c159804c8f3d4e76aa095d8402e7ac84543ff17786e431360ae1edd7bd2986731ee4e5c217fffb19a70904e6587b536ee916965ddb36dd3b6fe2338ff97d636fcaf5830c084fb14a6467db68107936b5f5f3afad04187901a7f2ea6597ff7d308d7c97dde456ad64247c5d77e4a47fd6cc00a646c80fd797a8d57a0eb23ed765f6b7aacf8a2c9c9b10312c91e8701004bf97a516f2ff2071bfd895aa93ea8ffb9840a884afeabc8772a85470d3e09e6305d4a9db305ad6f7ee5dfe45cf34a90ddad94d5a4e4440bbfdda2b79a4f87cad985bf37050f13ee3aba0e0e2b321fca73a52c12c62d23378c0f4f46e4009b54be36c73e35082ba6b3cf6a4206d85a44d89a1aba3884d76aabf8890f781d6016637409294a4c3c3abb66feb37db1d676fcb8969f09c38dbbbfe27b3d5d87ada0738501f6705e9a693492aa7759dd746fd504d26022606b30889640611cdd12c99353f0e17f4d6f453b137b00faa435434c461fe31a95e8871e3bdc9dfd9bc7ec1c43405fbfc2e88a5a8a88ac3b232f536771737971a6b1ef38bc502dfe4e45ecc31ceacf7453c9f6a66e14c58377fd97c3e51363f3709ab1784982ab41e78533806206418c9741ff43ace51f8f18fa39ce80ac0c0f9e29d892d4ac4d1c88a1e5478743e37e76523d4f425a55a8484d07cbc276fb93b9205197736a3d4eefbeffc528a42c48cfc172eaa17df56be647beb9375751db80bc2b377f6fb12dbd16ebb4b88317d7ad9cc13c1cac1b9de2dd3610443541eb91d0c75d1358d2e35b4b464f550e2a02661ebce5c9b3f6270fb559c9db51287689e94c1a32c946df45edb320aaf0f7a0a52c39bfe0b67480e48b25a50195828f34389fd63ec1d61b9e5d1e01dd56c68ed8bee7d09ab51cbf76bbdfb5cbfdb381f0e8cbf923126fd91d0046808ef34a128e59f16ad3cc0879c78037d74735ba206fa52e99809d42a722d738a8b13b1886419f6057ee9ea2a368b773c291a203fff0f41491bc2ac24bbf62dc521e3f6b9223f29da5b6ce6814aaddd0e1beaac85c04a44027127e6d121336319a701d2dcf8b07b6836531fe779d592617ae337d59a9bcc55a3509134885e703ed93c786ac21ba3a975acf2fae580b0e0fbccbaffb30f6357aabde1d2c830a8f7e66882f5b75a4f416dbd7d4db69dd9cb893b79ff2b1e621c65fa374f7b02131a994970267c40377a82413b36535c31f2dbf20dcdcda0c6e2cc04f5eb6d7b1d03cb52f37469e6a1777214358ba87cf1e4fa2ae3ce09edba209800cc5afa9fecd26bab8295a084d49fc703d6269f327a90a4c9addac9f7da3a6d69a1278bbce875d1ffc89b2a9dd411531dbd84a914a275d9bc49b82738e24675ebe36bd11f9545203818d8737556d2ded855c3e96ffe0ebcac487857463afa1e1bd5f698eb3b1966619a99b9c8568992f9db6b988bc02dd7bca85fbb015dc0097c3211483b16dcd0de850461163c694666ab18a5ef21361aa3ed32db1b6b99eee85bca7788cece3aa5d21154c46f4adb56366a479f3d2910d22f288f9e7527c14377d3fb8e4d8e0bbfe9296cf666457ef34c8e48ef6d15433303c50213e4c23e8299fed12561a07d63bf7c02f0e599410f27f9de181259a429666e16f9d360b212956155b8af593f46d31bd6a9fdef648de7ac563fc24d5d43162f7036fd8728263d5b158a3108fe2de1ace226cf8009b34600d31395a086dd20a38fc3e1e0df41de43fb4bc1839ad9989ecee1f9bcc9c0c0f8d3c7fbd85b3f59d8876034c23fd470fd902ec695b58c053876ea8da60c1c74720ed8cb7eb58d27f52f2f8b5e36c744016fb6ea03fa82ede3a8d413174676672ea7b1d5261f2b78e46261893c377145ec96deaea4cd01b24109dec6c6a0cbe097762ee604babb02a3a1c8fbeb69c105553304e8a8f25ccedbba790f972f151fcccf94c216746cd213bf66b11d00fd0e33306b5838d124b1fff8aa4e2b80c360a7444e14e90a6a363d1b0aea507b24f717e22b601f1d62d9f780a0575c5cd9e2cc663eb0c4469ffda46eb3493599f3b84030a79bb9b0643a14a9a33e2ff05880ea1f5be338f843a274a00430bcbc2866c69d75579ccb1f6f7b557926bb0f932c9bab8352be5e0af531c5c6f37ad8e033f455fb16a8fd3718f45e5eeac0572bd47951deb9b4cf7b91ccab32b2e3d81c4ebb603c3d751669b21fb9f58056e05e864bcdc4a6457ec9e7912da98db42917a84d170ad903373ca1d00fa3c27bbaf3edb8eae8f610353c2b12781ab75c22b088c7fba399f4f586c9821ae4ee52f0e6fb6d9e4a0fb852d2a8cf702b34cd8197607e1c17d60274a74b70018ea6449de833ba4cf21d6585cfc9a86a43c23b68c77966434ab07fd2e8ac196f6c17e2ee764360d5f50695305ae4cf04e1a59ad1ddb48890f5f5d4b1ec126e4cc4eddde500eb0f663f033c6ca25f6d978a6a83a35ab7eaca0c23df10cc985a05e582b985f0ca09f2cd14da8834a15f543469b59add2b9af95ff933cfecddbe1b7cbc4ff5beec4bf86b34464f18df38653833254bb37a513342399f2aa954e2222de794e5d5cae63b726aa8be4d6f959452131ebcba47d6da2730a2348d0401c811f13a980311b7a7ef19ccfee9d50f9f3243aa86590065712e50159f395593f927d38e81a1df0cb00252dcc81f3abc55b8d673907abc2dd9d4773043cf7de4da7be9faf514a44c739f83a7a47746d104103da8e91911f7d181e909ef37c60a5ba43c71ab872e6d13b3aaeeaebbbbcefed648d9542dfc8b9d495950924fdc133bb122bae6b68e7a769fbf32fa25ee9c729e1a04000b23be5d26acefc4e0616340b561105696f54b448abf620ada8ad5de78824ab832fedfcea85491946f7821e309bc970a2e9493ec50d41d37fcd87998cfd3fff5a60e2a114fdde562ece1e9928a0ffd4d9f1ea5e389bc56bf7c6b3c7d2a23039ee5a230ef2d0d461e439e3da2faf7a050952eade5148a58b52acc79b405fbc6befbc7b7e9d501eed1aca2c6456f708df6416f14ae5eb8f61992b9aa28c58fd8853cc4e48cef071f85aca5f7df064fbfdf1f0b763ef0777fdff768c3305f1de260ce3c65f7025e0f6f94bf4589521c9eafa44860792819a7336f5da161278135708cc25326122b34511982a49a5a00ee2c6d04f80a4709698aa62ccfef26f0cedfd1c0664d14a5b11f1158f189cb3bf85606712ba944a0e2ee24f2fc6e5ec8d05645deb6e3a6f0b92d11e69925cce3b0a48ccc6a9cfc0f4a814cdd28f62ad348c143a382220f2c4d883fc6aa268f6386d7b0ce29d38547f78dc65b70c6fd7422ba071fb0f83431579f1c902539cf09ea9970ddde156f8a961d909bc12036ccd1e0bbd56ac9a524471d0ec37a52e0c6f0389e1a2b8698cb64a2d2237349d39d34340a10f153c01e332a78ad363ba30d4cb4692f72dfe209a8e3dd985711818e724846d3a3ad6830e79fd596b100e9eb2efc83922fd02889284417d3b2008fdd6829423f3292d95f3e1712631bf70e5fe3ecb9a554f77dcf8fad317307d9a27109b1b032467d51a1a87c10723e2bc371e5ccac02223fe6a07e2c65129a0467c990bd6440e5a0fd420ca25e5cc5258e3bf0768bb31e35948bbba78cc56a2ac5b2d63277577521a2550d1137bc6283116b1007ea7dd3ddd08d2b3879f5d404ae808b8951e58ac4ec91ecaa6dfb6f7fcf55105b7c9fbde89b90e97482a83b1f2534d81b9180d6a4805d1c0adacbb7530048397512687961627a5ab6b845c3ea04c8588b78b738450b8374067806189c000922bd7af0cd01fa006d8bf47f56e2f263ced6f2c4803aae5bbd0b387c91c4a2c81f59a966a8c1facb489079384ba3289a24ec103cd908ce9c5c49bd1797285bf99e5367c219e677591c0e4bfecedf42a0fc3c0416222b434efe3065a32e4e32641dd7fd09bd4c605482ff90f8748906e375ef48b19deba6032c70a0f1e6c33d2993d15cc43e3f1311a4c05474cf64a32b083f2b230368250775079fff48e3c290e24b182fb86806c15d9a62533232b2cd75616214b6b094c8a85c54b7ac05b78b7d5f0d3e032c80ae8168c4c0100c8dd75f346ba43bafa9f1886a0e44313787f50371c090f4b747698c111217a0a4230ad6b7ce7dbe4bc3c38cde06a2e27059ad68e4cf15dc1b77c76bfd85bf7f2703e24ade0f2d3214b53e8c915e9ad0feebf5704cb33fe5321e9f0ac49c3b58e0c66be918afc0dd89fe9c47cebeb5121e84e33093f30ac293c80f87cbec73c833df6df4bb81e451fdc95ce240560120a037740ff143877d0e12db26a5b6bb9a32158d888f131752f2396a468e0d1e38223e680809df96c3fc8101a4e8c35107548e6af40af6e6567b3e7d920cbe5ee145175ad97fa54ad9db75f96c9a898a7b77bdf9408eb7cafe974603b5cfa0cdeccb81fab1c743cfd7d30aeca36c67f62815c4238493c311eb32ce4ed221dfae83d5b6386867503031fbb18c748ed9fc12bdc88f8671c0cb23695b2a30a1818daf8cbccdd402525e800ab6d98265c5396204ef38a976a847f98f3699219e6cd2d355114f833a7ac5ecffe6bffaec3684fcd36760bb1901e6c80bb0577e229815302c4587fbb5015a65d97e3b5808cc9c0bf948f31f1a67fbf5159a6583d13f2dee4bab18b9bc280dc9d962002f0eca28893b6f5c8ccec0a3aec5bf1c6f6829ac3afabe2703711846d3578442171d37545023f43ed4d0e31a32ab093553dd254ca0589b2acd8d0f6b594ee21fda5e364c04eafcc6b76e2cebfbad8fb2b89bfbd1882ad38149994d64a3ae117db8fd6e291bb4c7e2339ef0bc39d6240ae2db0ece5815ae2aa15589e2b34cb847204935d2d110345488a74ad3286880d7d67c5b382dcd09b2d3ae3ff959473c4a65d72f5160853f72f6b4aa67dc28108fee354bc036a40b15908d81526c8d855c39fda0261f3d155087be4544e54f728d78cb935f031e58c862f73d7e1138f7bd2a9f81096ff4d90ddd6759498f5ae3d8c2bbaf7c29cf1cd8895b5525d7b8e4e5687221cb97742cdbf36ac1996051ec0f4be5fac9945722b32bcf658af7818035b486bb08294b6a68698efdfaaf8581f59c15ef95aec57d3f32a934bcd5d8809ad4eb8a6283b5943a11948a0107bd80396ca28be801abdd2d818e4d80eff1d39366e0edd4e5c97f5300057ca20efedc265d547144211988c6e0d07cc5b26c65830172e868d214d7f97b1e1c6ae2b054e731617f51d73e74c61b985654c926fe96bdd3472fc36887ef328f07bc06bbba102736b937243e861fd18e010cc1d8b21890d74359cd6625ec5910e9b3ac0995cd92949e9b9e1605f0c565cbefe57817ca37e5741add1ec6bbe834ea3be03475638a9d941171aeccb33662ffabfd5130d3e5c9cc3451d497d75ed0b7092a1630b1160235f731cfa3fd68a53636956c60fd2bb77e39ebc9a4e37fd1143bcb89074b188f2e058180e5d3c285d81bfee3d1d96837b6ce5a3e46f4be1410d7f785df1834cbab3a264cbda7b1c3b21f048dd9301337a688a25510707212710e2a87c809b97084bc87c69c804cb3150eca081e73043b4aa7c4e159bc613722aaff48183f1eabe0c827e9c6b0e33105d9f05625a877274d9aa6fb67881e8b00d60e80c3fb54ba302c03b340f4c1a07ad661c85de8d9fac76e4fd63705eb123de36ddf6c3a1c965c1e08dda801a45b7d436008d7f47985c984897aa9661551c41148c5898d0f4e304a5f5124f82fa7565d5911e0ed7a5fd08844495caf692773e66a672b48aa62b5aa6790a474b5e884ecdc6b58616d3963a4d344dee648102f602479d77f3c801966e0a48925d55ee51e9f9024b1e57afbdc0191660bc06d38009a4103cf2f035bd10e7d5a2e5a32e0903a78b24bb2f23c6f58b682fda864737aba725aadefee9298e0687bcb9fea093056fede8135e4f0410f49cf0969c7787ee7b129f5ffb9d33547bdcf66d2ca08ceaa2c8e295a6277054f8895106cfe935c605c3752297391d182526c230884fa0e2ae024f84015452eeb09e44930078c1bedff16d13794b2f2493cf325a24529f0a481fa853065922911ac503cc04b1ae555d8277bf3f90364ad16024241ec0739cd0781572268d77d3ba8a30f4f9bf090dd8ab1afb265979c58480aec5e0fff9d40637ef9f7357bf865017423ac60c222cebe983d44439f91fb116e070922644a17b45811a6bc9029eef1f66e831b7998ed054dcc2951703e4e694af85e5a14e3fa209b6536b64e6a773231e44b8e506333e57285fb50938145dfca2b2803d0a78562e5610dbb7fd596f508108b847d0ee22481bf760ac3a0410ccb881809f221398ccdca588fb98fe07b609dcbc4b79126fdfde950f77761c8b3cfada7666eb6deb85508f757375742c564dd36681d526eaf8877ab232dc5c44bf58c49cce677c60e869a81f4f7d1b4ca4fc41c8d494121250bc13c3d75fcdc9713fd325184832fe98a4462b9ef9d7ff2e5d922c157a00246439e058c2d57963af24a4eeac9c3a220a67188b78a6d26016788b128befb993c7409bae38dff370423e219a46585e866b6765696afa356009fb1a113e23af1b16307b7dd5fc5774aa9d30817c75d1b99321da3bc2bf7e40d9ed1c04eaf2c788392cdedc45ece49dbc973c4334ee8b22b21af06652c9e4d061daf5dfbbe0bd751dd3d56709200b03c104fe527cfdbc30c2afd0ad1275fa14248dfb61aaf27f16d3a295405fea031704e1da601e7965a383a1092db580bfed7a98f7bc73b90a72ca7af58e87696390d47cb767827681f2703da9f34ff9a9124cd39cab625e0b812e9b8624c1b684543639027c923d297c5ec760dad025e4c2669c687f29fe21b3eca25446dfec4633ef077e4d3cd76ebef3a4a3d9dabeaa15aa358ef8b2ce830608dc829dd6d135bd9a7ac1988328331096b494624c76a3cf9acb92918d80449518761d6bb69b77f3d362393a09b6685a79cfd3727111d67855449e26ad9b3b6de090130f82c20fd154c53e6d6eb0635ebcdf2f4901e13b78f2f36c90353195abb0243a6d6d2ed83e4ee0311386a3bcf0743ac5c7b1810df10cda4b8fae3eee15718d9e6470512c6f831df1eeb05980204af8c0b8de37491a1bef2f73f4cb84885657b1f9d30523b2524039504482d96c201a22737b9227a5462a6c8208b4a3796f68e334b3e4c434c5945d4b884f91a8400db39e19d7f6012d60a13088260619b1d836fd70be05c75b5532257b9696e6b647b6681780c4ddd2a63c47f2afc9ca531e2f7a69a35f3982d989bcf1b57fd4648689d09a196d0a87c1aa89b46bbc91f25c8b8da8a464d17b9a44481bc7382880fe663bd8c15dda4c937a6d7854eab0910e57784c0489b51a18f10941af47cc26251a305cdb7a94ee80e7ce7fe81f53c069e6b08b249986379d9541acab0bb53b152a52c43ab30d4ca0807beef693e5799f77e9ba4e9175d381cae07db416766278a449cd6961f637064807e3875911ff7d0a48f4e8dd6720a9e9c6cab42978f3378b7005a5ab30a7109b4aae05ab78c5a6738924fb1ead4d89eb129a87196e983d1248e8d17223520f089f54b2c513e19b06f871645df2b21e287c7c3a13d80d5adfecdc2b29d85ef49dae03c714ccef0eb58e8a63b637203443f59934cdb0453ad478545a799d5a90d72ed866a0d7ec15027b6b2a1aa9e968d711f11534d58938b4f7eb204cee9442ab0a7a0d77f3d78567ca85c886cb9a0da92678f61b2633ce6712ed6bfc8df3fdc7f54e5c7d8a403470566f0d878347117854b6ca7eb23f0e230c64bcb759e8581ed27a4672b8914ec0e32e562dcfe555b0816d8c9c78f9e13bcd3edbd79df378032e97dfc8c2e84a2da8ed264ceb6d48afd503d355018ed05d048ed24df9e69da9879fa73642831327e87c3852b045e5bfc9cb9872d096f888c0755e791fc16b89c06bbb997188acc9d1b57c5314ecbfcdd8549e10e79bb81ec3beee6ea9d161a7ae72b03a0f84ea9f966d20e03cc5f75c3db9a89234902cdeb59db7aa7991164a07ca312250e07ac32ee6700ed77b396e4b924f9a6a4e24f5b8cf50768d8f0e165daa444b802db6b0d74ef809b8c25b1b568f5c28b8be60938a7bc3b65c76523e82fab2fc48e541997e143771baecf19318aa9c0e63a90616401bfa68989f8fc513138a67ce1f586696cbd5fe9e8f0635b12dc34f3df5efac1d062dd9dbcfb6534af9315a49c7de4f3a095bdf2efd0807a8788fd5fd65357f4a59ee2e75b2538cf7093c2bfd1cea418274c4333316d82a06173dac23f63cbdba86c2c55ac00c9e2ba382ecc30600a73b92e18520f43f13a2347ff91b8fac647ba0b403a141f1a48e75a72b1fcf254375bc3b9cdabd95188dd6fee64b1d611833fd88c37cf04eaf40a9e72ab23c91e8352de904ca1b9e191330978904925a7aa4ea0a1eed02735e920a267d7a8df3da3a6cc3dcc0aabf69866f9393162cd060977faaabc71f178389dd8b32309c57efabd576203d7bee457d7b3812b1603428d35445ff625757cdd867c858691d6241c26a7b078fdf75b5671f515e275b81635b277daa571b55aaf203cd65308eee8611ed13ea80e95e837b2281453267f627dfc7570d666a756801998c4472ab6f597568c41fe3f3e62850171bbe56748053622a04a7c5c60ae968aa9f515ea2106885f3040859ff83f004905790d6b415aa7247f0b76e876d3b4f5ca432d51ce92452c38255f814384237789e0b573341145eff676e1e37ab886fb0f42f7748239828ab724dfebf860783eeb224fddc035f07ef7f8f132d9403520cc2553e8d1cd1994bd48baf46cea54780a18b582840550f327efd06018894955051aa0d72240ec0eb9947ba1ff1680eb11e3cfe1ba14b0e9d3013c056caefca9749a28b8780c935a84f0e42c33bc9a8f8cc2c38eebce68093e24e6356c8395811a330be41211a764e2347b55eb4042d44f8844079cfb9949658ae987efef3cf2b224c336f74dabe9559948b1f06d234b2b80657e977eaf58157bb161bd8abb2e664f74a4ad498d8ce9047e55d8ded2bc4bfc367d999c3fc6a7975c19bbd7f8235471f32ddf52f3b536af333a4ff6509968f3979001e2eef52abed7b33bff9cba1b9877586b658185dc4ffd5d654cb9122c6fb7ce6a30c9df90a0227d80cc15c8540d09f15a02ba40ac8b25a04a52ee00c372cb0cd1212b4c625746b2f416261dce1b8fa1599c090896e2628cce69c0b8ddedd1d56ed32240474d5dec7ff7931342b531e593a24b09eb8e36306637757f36002a11f9c6ef351627beb66396aa6fb63b6eac68c575359ae8b786d2a4368692573638ce867df31af48e8b0690818059c6371c270d60625631a09c3bd00bd1c61a1bf9f880bae5106eab3dd048658771eea1c2b46bf07f87aa87a2d6acf2cc85bb73b83ac287aed3887af1fdf5f0ff46dd288d4eefb5a93663bee194ce196b3c6167c90d2630302d749339af5345b69575610e41cc4ff98b5daa0680a907326e9a4d5235846d9de0ae561c23238a431ee4fc6c975f7d2e5a03259a2a5ce912fe112dc0d4fb035d8f4dbd42d61a92e986f18f2df0918a9417a14868b56abe378128390908d1338c5f4f2f0e2ffffe705eb7541539d6c446fd962ab478553765bf81946e359402111f60a2decb970fea214f3a067be5eb8abb3c33ebaa407eba835651cb90842b6bfd1021a96f7a47bea97335971d493e2f88a46b18243b43c9504e7fe3a6fc12ec18f54fccf622c334b49cd168b0d809641957768f7cdf286c55527ecf3bba153f15b7fd349ef568e0b05c378de9d6b5ff98125dbf26fba6197c87aa1b3b167b9a582c88834d5505771b4d110b0ca3e68b57b1309ab73591c156fcccdca0eef5dccbd6b236b3443ce9a7189bf9524b9b1a6e06719b03ebf641f6f029d4f033f4c57c7914e17fe013957d6a045df890938131a35eebc3e32599c7ea339aa42cf3c24bd94f1fa514df286293c753169f9e43b2699456941fe6df106595d8579f6fc26912a6527f2137e30fbf1e5e11e8d33858cbf88d40920fe98c1353665ae15def46bf711f843bd194a86429ca353cf49f3a1ae66c0e34fcc81d18ba1ce3ba913f05b400a8e67ed37cbce15d847dd4d3374fb23f882f9cf8ba52b3aeb335df9634dcc6cf445778ac520b0a7281db600537f4549759426c090c14e03251a42ffb2fa3c5027bd621711f70c7d2030c75e5ebb6a9980221cbb719c4ad4eff4233138e25de831fe37c96675c9632cc6e85ff4aaa816794dea9fb9915616f1fff94699b1b8e2e97bd51847b53bb9ecc97e0a696853880650dfebd397986aca0b4e7c2e9a5852ef4a55161e06e415f186e23d41d5732f2dc909e945ee5971b6f52f63b4db27d2964b5b83997960c3a64ea67493a8e2f17d5f1248da7073b94148de06f81b46995c3b948c985434d304314f39898752026b710c90c2347fd70392ddf17228d76c5c5fb5d948bcd4a3fcd907d6e2d4684cfc5b2e19be5231d240134c82bf2444b39eaa104f516895e6f7042ea9a1296867300737e2f755bfcdf5b9d9c89d493a1c596183141c6cf1c40a2904cf2f9fcbce5dc3d44fc9d3e395bc552b931bdcababe8f78aef74ae8db41bfbcf5bd4406722b27a647270ead340372891f86574a54b39d0562e5fd81b58d66e1967efa495b0ac5638da50554e9f7e2314c93721476cf6a6a41bbc4d88eb8307b60c8b14791ae21debbfab07c0eefe461020dd53f4edab30526720fae0fbbf1c052afbfe740b6472b409cba88ff386cc6e779f1f49fc14ebd4e5990c71950c4e77857088657d94cd53b8a862c8d8efc4b5f09f657d857bdab2c5492ddf36f51d4c7d431b945efe08919a709a1ecc7964ac085839efd8aad50cfd7e2984c83d582c0b80e877db45822a22285e618cb2ff67a894607546ff08a3dde45fb93966a44bcd303382ae41487266da36674f70109821133d0d2f6b947810c00755d75015622e5aed25b52cf904663239b7bb872cc3820163574f3c543fae8a503ca91b398c3f668cfb6ab63476e34414f412237609c4da9d0f2ee4c7bfd687f33b135865e786a01b5038a1749235d54750e783b39df9f647b760f86790eca8ed8676876be2184a3006b66c128c0a7dae82fe21f1ea171ba3bcc151ff27ca0ce07a7032f2054b189e324317657d186ecf269e4638903165da58564b0769102025d6e804aae7567aa45eb3d6a1f71fe1dd257390fc99b6341b45f33dbf7e21cebda458f05a7971525bc06c2b7c65a65618b1d294a11a3b03ef433af61789406e3bb87024cd6f28de4e5a7e3da73b03a106053e5cd380ac37954d686f1c01dd5f06f0f966ab93dfd3775a233d744a7575f71b943af947cf4fb95c2f91cda11786f782fabe75fe784a51e64d0427159281a49144b238450841df2f5765dba24fe68ef2f676e1b398e3abe510b4d98f452ff5aeeeb8efa361370d7ec72299452c953e42dbcbbdf67b31cb52095dde0b76cdf703bdbdbe2274f0581fc1d27b900079fc098f3424ec23869cdbeb610f0ca5298cbae2e745cb31a71367154e7d51b1a70531c8583c6d4dd44c516f8369214972a3599150aee2159aa99ddedaea209f7c22140050d29fc88824f1d3af5ea0a0230289f05948b8506979851dcba63821585f18023925c1ac72bb8218ada63412497013a20e6942fc19942d30408242160e1ea3a4b69ceb20e6dd488393510efc3edfcac74bcce2d65fce66764732f1d240ec970fd05ea17c66f0eca624921b8343a4064323954fef4e6c78b51c08a2e91d6f60cf2299911ae1901d2d33ade39dc2a0f4acfe65f287a9e5060354965ca44da39a70dd1c8efec29f18c70b14b1495e2bf4501f82373c131853312ecfcc63657bdd4f229fb0fcd6cfbd8b342876556fdd8f6ea5ee4ca9910ad2781660422896786ea4ecb56704257bf452e44b2fb69fbe8837cebb2ff483d6336ded41e41e8de788b34fb66299cfe37c224729149b803900c9133a3b2c6529782f597847ff2dc4cb3dbf6a5450b4b4458ce8c4c13244947a0558d465795ffd73c6c0831aac2cefde20d7af90a8932cba7ec57c5989b003d956675a497b8e275ec22545c59e7c4c56dc3471fcd693b7a7de51a23bd2d4a1b883c3c753eb8af7d439642669431ff8341b2ac632d43a79d578f7dbe99a10dd5c17a04e4b80278cce8ddbf9bf41df43f1793d194dc70694f38c180a32e778029349c07c21383cba2205f2658eb0a5ab59b5c60953843128031493e3da1442d8d9173a7346d4d1327ef8af9f65ef942fc66fd902a0e7178a385334ede4bdfd6d23b6bc240b65bfe3a215b70b7117f34759d4b98da36b9be0346aa6417a12ef8d459b7a3c62238fdbf7e79d00f3844622768898f6842ea93482984e5ccdde57a2b41de9e5968cfbfc85ade505acda27830f03360a7c0c3821414cc12da00ae2b2abc4fcd62368dd7fac79e61214c3896eea315732586cbe12b9c1b6e68b1f8c7c8604b262b17056a22846291250ab801259915ff53270984e6f13e943649fcd3923b02d96f0b70d1c9a0cc7feb0f9bbe470e91bd52cee68897bb3f9bae41fe1f934c7424d9dc0c81ec405d2e145ebfef4e95b05d6919b38acadeea113d5562a70f4d57d2da29c6c489f2539ae426c27596a6538c74eeb46b4913200921632635095e0c02e0dbc7c40c921c7ddc2ca8a7b62313585c124f71ae8f9bc5402dfafc09c5408035db81bbc89a20edcecd6a291b48aa6bde4ddda03c013e4232fe0c76bf845109693cc4c45ed1fc4cac4a7b2e1921e0a60d3320b563fc37ad6288449ddac00bf2347c7d3f2628fd6e12289d6e30f48c062afc42ce94ee8a19d0dfd25365df174ce3375b4340a4b4098873550ffd64750178b48902cff5f23b19f318b894c0bcdff6671f8ee78c6cc8bb96a9b503bfec02aaf14e7a0827ef445391a5ecc0ec225387a5ea5ebbb00953b130ba9659e19f018f9dd93a3f45f6fcfb2896213f9f7e86c5ccb2cfdf613fd7276d3fed3a1fbda4cb2f915cbc4fbc5e9533bf2147208bd1440a596753c8f29d481520a2f99fd87c062d790c9aff7e3f7b7749e21039dc7a26ef8d90dc6b55b3373f0b3de958f8dcf8d380d41c108b58a267c60e0902ab4154d67198fc2cc5a651edc0763924939e5d4583180d2710a0cfc2cac0cc29cc11e6de60dedb2ff367943ddf7caf6f50825c3cca0101e15b927ad371edfa087071dd0ef2ade37362bfcf3ee9078b2019a86e340ad0f140fa25a7b2187c72a284bbf61ae6b7470fa43e4925c8558bd35d9c1bc3946feadb0c90bd95ef81a387fd4e07bf866e5e7ea7a4fbb4edaf79fddea2d43b083d8779bc706b1aa02704b3fd870a542b05a5ec2d972a271ecfc8da522dec8bf24beeedbcfce256ec56a162aa343033f69d3f4f072015999daa47bac8496ceffc26a9008e8b49c7e87fb97091d77c6bc56e76732031c08bb378d68859439142c4915b0e9adc37e8ad2f4b7682932624bee5f8dae5216d52011d1dcd497534f91b67dcd779331bcaaa561e2b8e94752fb5a7e78cedaeeaeb1b777d59a7de522f0e909ed4fda09b4b7ed717c5b44ac05b4a9f9552679d75c733f1f82d136ae993060750f25e4921b9358214f70da93fa087eea1aadd64d7eb44ad09d73cff5d3107b9b062bfec60cf3f1111b048909928a136206da80bb54a998ee6609335699ad5538ea5e297f76ce1452af4d75ce284e5c94626926c40979f7a205188cdb36aacacfc2b9246d43c5b413dc789214b89f21967ee29e08b98a4d4241d8ceaa03ef628c97b975c8dbba36204db8d07e364571d14f331aba078876b9d46250beef271e7aa693bfd2fb3a87bff2e522a5d326f8fb56143bc3f8356a9ae74479e3f91eeec9e78636d43698433cb2d25c8bbd1f5930a3fc9553a3b0d0f8f03cfe4778c180c1f8b5f7eff4931c5170105b31642197a28fc64a8a9041e695b9b0630c0840669cc7092c7f9e764350b6e80b98fefeb3db67dc3838e95afba2b283452c64c5f7d8afc1ee629d2b619c0f11bbb8ccbc003defa8ffa5d542d97ff3c100de454fdc65460600ff3bfcacb5da23b5ee53cb382e38a03d764b39dcc118f4a4eca529243031e8f7a37de9688b6895fdfae03fdcf847f34dbece608cca30605c6773c49fcaaca2f01d27e708afa574dcbcae10db9d4b59e03c697d20578c5842202e7abf927d8d4eed38e3688f1584d64506f461eb3deb49f07e39132d514b61dd60661d0090fbaaf9aaab39e9636d219150a5c510cc82484609952fcf1afcaf14de8eda0b496cf50092c9e0db2a31586d5553919ea05753271c0cf8b486db7a7e72f44ae1e44e82387daea5281fb72c61f8b7c6390e783ea3a8f5f83f97d2a4236afe896f0a0776ec1643cbe3bea3ba490c3894369d5b6832e683aec6df4a17f11cf41d5431ea6933a582af4371702c65d5d32aaf87f77bde58487162f8a0645a503a9dc1b3d1cbbd5631fdba384f3701456e24e5b39710eb497fe0c81f0ddee787379ba7dfb1bf24d04b242a010a9b6cad99883d4915b79e3cec0bcc7cc952a3b70114471322b2d10d143737eb65379f40a1ed4e96fc3070f1dddd94f8831114355b3ca35b1874986577b0196093b9d408f3f5962bace08881db72f3abb6432584c4a3a44d42783a9711d1ae39036676cba0b81c8d62af3d4af7d6c94ee86061ef635cd4f017ba2d0e2bbc3a70f186c9e99ee180e06f467bfc57b6bab753e619174e500b419a012b7acfc0fe6bca2cec8ca43c0bb74a4d31a0273a73cb9e020ac862a0cc79921df650ba1ebbb1f86e80d3c2a2a47e9a49e62873872d31306328791d1923e76cfffe537e2410969fd0ed8e603ef129dbd56cad37ab04906b0825ceb1d027c157aa043146d6f76580a40a314b6fe9d857d073b4216e2dd7da04827bf69fec3b366117c50a6dd0fefa84291a5e03eca12ffccd05262fbd2964f5e6f7d75d7d4201682f574136e46c3ac35691ba48ab48bef688e62bf4d7b01306785762a0b82a44d95e152f596b03ff9ac072ad2114ce20aaef76b8b76332423f13342938a3be2086397c6dd820642283524864727975682a97e568d6e5112d2781ba3edf4d47618c59ec8230791a5f8a3f2df4cb87d6f3aa1c15599473960d708c56a2eb0092459445eec823049295f833f053515d3c3e80e1222950e40d4d245c13f90f13434f35a7ea332c6b3455b6fa19b495f6461767924fb8b86cd689a83df35d5c31ea45e32d660bd3d719ca53c1cb33a66119bb9b64d26095a9a7efdd6abc7db84d71dde00f43645d27bbd4eaff0396141673e1e257f2c022b0f58c62b7938a375e65e8fb9ef72c21da46b16f05bf6a54b0628c969428906ebfd227650df42a5eaf24164944c2dcf366ccb907d823076b5cfe70b4fd034e35b73c92ca927db12343a2c6bcc771732c440fa133c706be0257204ed36ed07066d4d7fb20bb90f6a4e239a061ed5fa2c0196bbc15beb396aa54f78073a7178a91718d28c4d91af1eff1e9f62c881c31a818535ababbddb5cf0c4304dfd125204d21109c4573dd7582b67f2102bb1e51cfa3dac0f1432ec20a918b7d55d5abfd06a088d96c36c7c94732616d882cc7ddedb9142d74edf85646669377f987e3c99e9348a1888a2cd47cee0e432d6f9b0f73cd65207cbe687857418a7435c14ee8e031bdaf3a64f9252553ec623b9a22d097ce4163e57330f2cb9df6ef21f273a50296adac0e223d8d7115b6f849e244fc073272e89f05243a7668742d7798a2de22d3c2ecdd5f41c62e043af7d380f5f0a2dab2d674091616e96a45c3e2e8a5884a4805eb4c7a52821ac63b4e5427ad7031e0c2cf2bb27e9aa1499aaad649ec13cbc4093ea2692c3b0b21a5c255c71dd965c27b334815aab9ff22c95a98725bdb8787a7432a41fd1e1aec58950c389aa98e422856f3ba1a71f1464b2e609273c4c65a72ef7d550c0de665206573f383cd506157c957c2a96f4389fc24b9954b339f49f02d96e83a67b17e8395d786379352698ffc9771a01aab1a9754a02038cf2b9e9c8cf09088cec961f39361a78cb981fd0cb85f8a32209226fab20a60643a2419eb8e0328f5bbe04b774b8404206c34bc6c404a27d57ae62e7a0d8fe4cb0a50d036e0343f8598e9572e6dd699cb977f5b8f59ffd510789e0385990450b1780fb0ed12fb95f86c9b4a9d0d0b3564c76dc2448f623a2698ea6d18f6d7c35d19b192beb25c69130884be8762f91719b45641258603e331b95a7c25e59308f376d72ea1e04982798b7d0990eddaa602bcf9acae0683aed3188bac1d331753f41427029e8c6ce9708f540255e8a58aa2648abe3887db1786cdff7597ba5e4bd078a49d88e91c63add1e0d937d6c313395b0d5d341cfe3e377ae2ce9001eb493cee89efa91dfeedd73220cc9e28126bb14c617607661e68af8007c6fe82ca7b7fb167cebaa970fd1a7123654dc2d25d4a58a4f160bb45de6dc7b349abe1c40663f537a04be7b8a50b95d4405aa64bc4364cfc16c32ef3a95a50756faaa270176840e15d1e960313788d966386bf5459c60d61e95741d94bd97ce170e97d156eb69a0b6e3aa1247145292fed522fecdb90e6cac27eda4f0d5d641249a8d027bed8421050736e58bcdf24925928a40de0e6b06deca13f46084d1d214a6659623eca2bc75c4f18ad2c82dc1644b5bb6fe5ce2114f091ad90cbc737be1c6a0860d2c566b40616127b2f921cd5340e605145ef2562665497ea33e0a6438f8898e97cb3aabf8292fec753067e257eca0629d53d67243762fbc351aa6fe2a023a8bde20801d0a08c33e7a072f73dc343f905ed8d750559dd6c127245bf197619e03ff8b60df95d63c6911c9294deeb19c3a0cefcef54b1bde4945052114899f1a2f0931e2b03ea6f7f45e7c44531f75b36d5db056678eda2548780ff8fe96fd978e8a92982ca001394b55fdeb46f196527cbf97086999602148bc5c83b70630daf3b533a3e0e208cba957735a49f733934c708446a7503eeb0f0bd370d0da7bda6d2ff3c2fa006c8aa2c853011465ff3b0c1745660039ea11a6ea5b027eab5314416f7bf740b11234face9ab57d725e709af71b567cc953fcbce1b055bf766fd4c716a8104b8c7354d61ecd4ff7b73437e63b3d1f2d956e2933c66636e8b0f1c1a1b9b7a198992905af7b7633eb01cc3d6b1aaef4fe30bae77a6f0e435f2ecc31fecbfed0d4fa89a46b16a9c339032dcb13bdf7b34db3cab16978c9a2c56182b397136d59d8858829b8fee4186acc89211f08f3e56a92a295bb46e79ccbbb8bf41182714928009b6144cd96e3d32e56ea57bd50cb5896e71229d2d45bdb68503407f73b509794002ad57a2f32cc95b5472d96ff5652deced948fc7d3f63a13291d98885f5e4e27076e589ee0318634611f5926f38871a6d83655bbd040f7fcc65a5d5fa443256ada40f3f169b424a385e3b0179ff8806f76226297bb485dad9e39dfe73c9a48ec4d30dc7749ca23b902cff4ecfddb6a5371efa22ecf173c527615de6a5424c622f0a96fde717faa728643a7239fd8ad15db5e5dee557c18b1a85b8833e82759fdee8aad7c6347436a79085ced220f3e3f37085b80e58c7bb5bfccc9a12d7d5c94d0be90802bb00878df3ce1e843c8f643c5811d2bc59faa781e25b8d44e7446cedb229f4d22c2c246f829fc8600f62616d73db7a39dac747c41eb7ebd0393c15abe4817e4225b4f662f4696cc2c3300d9715c464b9b6bcccb3222617d393f3bda9a5ff706cd15b3701ed46d8894e817e7ddd2866e42d055e7c46a4d86bf3427fca24296a37a7ef3a29c901abd5e4138a1f47e242e909c39eabf622ba634015b3a6443e09bfde09db3277f17be83c557c4385e8ac8616824fc1455e18ab2abe8d58934a946d06b37c38c40d443650cc74f4d15b274d8dc750ebf7b8a2c73b59631f37a008ff64635160152e460491befc36e4f2e9030420a8a91b0d986b97b7afcecc9bc73ebaae29ac769199c522bb9bb38ac7ac3100aff1b980f3bdaf6d481cd27cc18568b1f1ac72f8032c0e8b81c2041bcf934506fa17173aca4b00de163dd50555bc9b78eaddae3b10d039f04bf06d28bf0b6da4e1f3f7e778bf0d05b75ed7762847adaa2263c2ca18bfa535bd6a6bdf97f24d8e70ebb46cb20ab16cbfe1aee61287f04724ec3c806b60819ece714d2fd3315e1b651c439f10f2d22c106bdbcc638d4261f300d4d375f49ef9d019157ca75335d5b37bda31d794ac81c997a4e4cd63db91dbe03a68d0d7628de16cf0f4020685b1d922d6c20341754c0261eccd012a8586aa765b75edf305d0dd3604628776c49c87f00ad0aeb57d8b17409020a0c9fe605d5f5cebe6826be8053be86fd7169d8791f6bc89a3fa2b90775c8886385a98889c46e193e8dc12dd1cbb11384d781103aefe7183ef972fc227cebdd74985013f8d48857b62c7dd126e3804d868c3fafd2cc9d9fc56ab8b983bceb43b9d0c039aaba3f1fdd164ba820a284fef3ba705f3d19d813cd4d89f13fa1fe1d5391f129f5a7036ffb875894e73bdc214b432052551409c354fa744a628b35e3d9f2bf1c75fb4a49c565db58d129bbb6e1d7b82fbf92b4d3c55642bf291d018a11e41faa1a6717760f0ed421bd479ed1d19f66c98e6504cd02d16ea26be78211590c7278a7e035d0309c8110d5d9ac8d4b05d3df610728b8f8aa7402f35158990cc5ff15b1803d80dd319a158b9178d48ab7ef757bf2c1d991bfefcb99bcdc338aff2c9cfba4dc271188209bba5afd952c3f3148a6ed1fed1dd90ecf5b1c13ccb8c1e4979f01caecda8ef5a0d8e94055c9e465746ede9841bedc14931f8b3d28bd57dfd6cb1f79a1e33073327c9fb8dee4264d3442a6007a5b7888a71897acf41a899d901e9070f898a41d61205aec8445f0198f455bf8e2d9362494ca1061ae09a5a185c6797c4e0497d595f98457d2df56d6ad11c8214fb2f911c0d1c395d995b29f62e24334926bc3bdb0342a86645b57096f0e3b95d273b9098c823759949da9aecd38e114a084e06d116797addf6f198fbea0754b0c80b63ea0c548cca62e47ee3249579d28acd92db2e5dfdf548ae846e00d411e83426c2517320fd7e6e3333a9e064ca9d8a6fc5628912ef8b38c1c09495140b5bed702f93f491e306b4a62b2ab10c2ae967c1323018effcc26418db2286f8d7462ebdd5dee54d227d1dfee2c6a99f8cd481ac4c4b0d0908fd9008888759c32a0deb1c68d4b39e98e9bccf0da4df4db7b1fa4b62e41a62173fba66f87530e36d5f54938a26327d4d703a058273ba2beec819296fb4ddc14ea8daf8f8a81e89b8e18a9f8bce108602fa92baa248c6e94638dfe7c8fb25dbe97f06c48973edc23e37031edf644ee8b688219fb175e010f135d2381711a88bbfe0909ca5f182e29a06c9a3756779dfe84c7e660d3ad7f0ca05a9f85c25bc530d1ba0345e655dd21cca0cca7d3f9a75a7f6e7b675a3ef6e6aaad2bb146ff0fc1de7b8094c9578cd8b7a2585c989f953546a914c7af38029cca04efb4a1ed1b05f0e921c54270d213387ad397fa6112b3ed76c2662c74299ba83ab251886efe572350d52a721b43036e2a26cbdce01ee2877a53dbd6458727a97af801900d249cd934df33d855288196fd7c373857b26a1a29c2e7d713cb2cb0e3ca1c4b8bcbe4eb60c3517f7dcb2642ae8584c0d50e217cfccd20a9cda370197ba54a99164cfd6a1818d3efdffd77b63e9013afb54fdf2edc46b63d4be4e5b49f260496c66f632109f7a4a30ffab0ee1c4f5e77779da31000f335a8c869d3f1ad589121153fa385616e9d3675b4546d3986a2be33796089b078a5c0d8c384e1569e465855d9b0d8b4fd600fc9ea54662ba85f4b9750dcda7d91e52841ea5ddfb5a1d9fa1ad418482d63d696e106ffd2050a7e4ab86f53b0bd48c6a11b21b2c9c8f8e565c9353549c798cd06db0838e96fd0c2aeb197006738d46ebd5f36701127b5ca178b9536710f5aab79c6aad6e3ea511a8cc2c4741eb682dfaa59461176e39da3a0b13ec789366e74bc939b25ca078236fe6dc65b41b6c44f007b52e39e79aa5493c28433ab46b08e5a7932ef1a5b62e7fe3d01658fdddfe69383177efb868c489d0d8c9e70e8946277393ea88af0f814197aec56b01d47b4011052a96fdbd8804556116ce06863f87f25bcfdd2e977fddb98da0176791b249adc8965d6488e6a773ab6f49bcfd21ad5c6b93e6a1e20427231865b0cccc4208f1c5529f05ae86bbb42c8c428d5f527cffe5fd9b9b3f238d8711255f3bcc32ff5d851dc8bd62b064c3902b1de0933b4334ab627fe5a3e0dbf727fffcf7a8bc520adac6cc5c186a5b06f5430ad712a6b684fdefd1f2f6cfe364a5e678d1c7e0c76b0e93b03606b67a839075c9422300522bbaa1f4ce795500079e59f09af7b424bd6616bc9b42beb26fb3034bf92f66db060797d8216d22722f4dcac8c1c4e47384f54fd9feb36b875bafabb6adb45b6c41da55df5fdc634fbdc681badb2389045ca68760f5e0fcb3eb4dfbc829dd2bc8cff9c26d901f8bf6b0668fdba397365dc839908abea79b780bbef808c39afbfbd00d6ca53d86b59c1a9b2a1082b2c9211b6c859ede422c760f39f016b8d229f58213f436df669300ce790ec69b03ede65810fec9c865eeac5fad4150044c7363b058e1162abc0854afe45e7255e710d8d1ff6e5ca0f2c73d19731f83bf472fc5e3957ce8810d673d2a8c0f5976228872d2e4869b7c337b3ee7b2cae6c91b1fe007449aaa08a3f2eeb56a14ab638514ae4168a753b23a5a2cf1a725e20a891db0cdebd1802681657bee36cf68696fe31d5963d5c04225b6033c54a703aa7dcef376b99298b2daf0d5f08cac8575e41a90647d830e5ec261bf55e3d29eea625bc1ffa9d71a2caa6922657c44d41bab9a4793f3f75b3d6428b871c6ce5c7f69f4bb9a0a84c910f37b6dda0123ba21103fea463b02f8cee017508817faa9799258245c66003e31f2508f8fc794b411ef771fa3d0a58763a60b6abaa78e31b4f554af1501cd592235ae163ea4b42128b0429b1b186c899f13062def6da3c915b5ed478ae162c1d834350c7f4f248d15dcd0ebf29b9014b1cee167adc9aa9320b0696a1169fd29f0cbfaed004197a01eab125b3e0238f2f47d6acebe7f0a687244766dd3b65e587a423b0c8878b886d2a6b58f38e3bfb5c96b1a49fa71462488acafb203484c80ae7d2c288bbd4f0b9a6dcba57045c70ed2826141f7d1f233b0ba57352c25c5564940a4c2ab7124aa88a2767c0ed24109e6d1a6aa8b82b01590db312b31d1b6e30d3ba38bf7f993bfd47247d5087337c96ea8f66c478d842d39d070a89dc0533f4738068d7749550410e62fe826021047307c64897dd6dd524166acaab936941d636db05ef56466f61b0768599fbf0d9420bf8d81bd1e8133b0da8ed10619342a51ab330a05f6d10d49ffeaa3cc15a9fa47ef18ceedc76a97bbd74d52ce8f30b71d81a1abda9c696f697f8abf449b262ea7278468ea588020aa6f51f5852959f91ca9462813b222818913df9e74f6c05798858b23f1c5db52f635b529ad09df204247bc90a741e47a275557947cef6113fa73f71d2c2e11c856d85ce08357c4b7df8d6e29090be76bf5d010c49b9ca0c9fea4dadd1b31872cda731c7f7618170c3d49b86d86f60bc5c1b36bb51f7d6b5851a3d86359607f1834ef2a28edc6cc6a90abb9c5d4a3386827ec44a048ffec86b5faaaf83725b1b28d8f23fd1ac4d66c7f898f659e152c36a9fd99e30a66942df1ff8cfab17a3413ce14e694156fcbe5b05c064d750c1436d0c83a4398e0c73af8ca95182bc4b3d5b6c63476dcf959d4700b5fd9d708215488aad41eb8286e07e9ad4099d2c6683a28cfdc66d6529b282b2e16f412dce1be0af71a90c77afca431b173d86b8a350907ed63fc8415eb900bda192809d1cb20c921501bbdcf22e1fe6b1d642a13ef5e23cb2467de36062d5faea077b9da396174d1c124c0df9d10ca76544b2ef9479abf65e8ac20ce6059df5fb6214940fb68aad0a9490c4f1ddc6906629a33dee26393ab749f3bcfcf81c686a90f007a2ab2d952aeb0a52fd8cea0de60eeccf817cf6ffa3f5006e8e7d725894b6e0e92545f60ba80fe63a044af66d3206a7cb09cb73a187f2ed231686b203ff3212e6ab7d1e828768b57ffc5e93d279cfffe501daae00948269d988bc16fe0d60f4d835b7f8903d91586de71ca1730665db57dcc2e1c6ee60f3ded3fcdafc15bceecac9e52bc2f7f07adf6ce315b77a23abedd0d690cc6043a8eeffc523aaf20d8807babe7bcc9e72aa2d34f66fc2f6e16cf68de1600a5a5793d979603640257bd428b3d78bded58e429de16512e440a8438c7c635b812a77a2f3e65944a9977fd8516b3871b1cdfe19bc5482552f66049ab156885231600f478836259cc8ad9c69389814e06773df8d97027a9f76020bc2a2366fa478b2f21f730ddb77db4e2edee89eb59b9b38ef58d80ab8d7740b1e03d7ae545e96c67409b386f63f1211665288543256c30b4f4a18e625d2ea2f857aa1845a7618d2d7870406e7f066ca34596dde1696ed6a72c250b89be714cf9d6ab7a5b97555102040da585b406b7a5134abbe57d27e6479414583b96b5b4854d63e3233e1a9daa2b16ec061bdaeb9042088e6fb8a6cca562202acd8f238a4e7513fa2c948b8516e9e006d173d1c6bc31e699eb00f3aa26a42d874f97830de45794570bdb9ac66bf15bc25edb7028c4108b835ba3b9049087524e4dfeb89e633e477012b68b0b1e47fd143bb551a5cfe3bfb5f5d3d0187876ce42a60bb102f9a48286a1892979df92d5988e944d72ac875dcd166e1294440fa19fd5912a9f93443d46ba2c41131f3a808f9295df04acd467cda14ddbc99bc2c0ff19a78a2fe4120ae593a1a08cf493159bed027f64d489d21df56cb80d11030f5e99f6ebe7f78bd2b467ec176ef2ee7e798d4e8fd38032d5b19a73251836e1eba15b9b57b25609402bf43305c31739726985da57c5c1155c4c523876c4c97c9b7ccdd35ae570509df3e68fe40e1b62d4c37f277b0178f9fb4e08fbd8b335c5730994fef25d2cb1b9c067af9ecb1f0173abf34444bbc2d863306ad60775815688fa34d3d101149e110ac6ab323e42c0848377509d2a7c7d1ec312fa3b922501c4bde751eb8716a07192812fb02a232bd53be94e8c73dd31305703a931f3d32c06e5d02786a98110e7c74ad48870eabd4bab1c5418f30b9e336484034f4049f7e4724fe735c811e7a77d2c370e92934a6e014ac0a99fd5dbcadf67e2c570bd6c78736501e66f7a0bb1a17a6c676652c2b23f7ac49f2864be7cdc47bd7321f5f1d115ba01ba52b864d9090db19aa007f9de1c04cb1d371e0f297b59e565599f386746335c737a07efd5d6353bebb62316cf2a062438cb123eb152fe2710b2877a915a41545060610211e90bfdedbfa19a82e9cc7f8930cf5bd2be4b986d49abb16fd956f043b6cc3e06402bbe37ebc9797046aedd2f507fe6b02c55bcc1aefcdec1096a0138bc0ed3a0c40abaf3165f754dbf8706fc5a682273d81391e2d021881c192357f538ee397f2ba53dc06d460c73b511d35f7344af58455a6fdbe0a678d3504dbbb8808485045fe6decefce3c9ac517f9660e05e6fcf363b74891d1c222184f891f832b36b337fae7a44464bf2ba0c59f21767c0f085c6ac07cd03d079aeb8ce234538c1c7bd60b8751fb146c3e862dd8d7a3c19a6d9d919efc16e91c3fa215b891a418c25ebc2439cf477826dcd564b38d3aad68da0ecb6330a1f437ce5ac85ef59b881baf86e67a0db8a177c5c3c75c511db44fd0abd413a685b4d67261830a6e3461e975d13dd847a9971c53d23680201edf2851af862054dbb16194380f71a2030634ecb1f1f0b7d69615c7eca7e6413e3ed41ef01edb9c71ca68f944489625041caa43db97ace362e36c3c6453f63c91bd3737cd0de37c2a5916fef383ff0dbd8b6341b1b4931f6f21838e80f0d67f19f6009cb90375b8ecc0fd5a03cd573cf122df8050a8f6ff75fe43340edce708995a7456e67a5af3887b9dc961554c5fb0a5a6e527c2f9836764d8fcb3c6e1119d491afbbf02699722444aec29fd9eca6d6bcd7735c570f6e1e956f1603d312985ae8f1674c2d5a495f6acd3c2d58bee4fc1f62e55c50745fc6c360565edd8711c881bf60a28132858af45f28e80177f319418c1d1f9307dc0b244ee64f6447b65b57374d9eafc14c2597363089e6b01822dcadfc89701f4fb848a600c8538b915cdb934d1b7fb5180cb1a650aafdc5221ec269ca9001e16102cc82e6eeab1bf827c81a3d61fcc74b6c470a88216ad2619af6f286644766d255e9d6af45fe3fe003dcfc60f9a31fe052e5dad5adcce7a6c0912c6755a82560431735df7d38ffae16cf992e6ce6f735b2cdc5b7a935413fd856dc6bcb393d111878ed832e6fd95563807be1f1a02aa1ed0c59789a9aabeed5a6d957301e94b00ddd1c9faad36cadc15553330faa1afc958dda9a939ce443301886c530ae5f9edd181c0e504f94d8afe2e2fdf5754341ef1c593620e50ec1dcd695468733e421983303794377c3e93af29a0968499af38d5ba365518bb6ee97003c0f0ab00256230d2a7806fd6ecbbfc060064b92b0f4de748d73de8afa66dad7f3c93682ba1ddb2f1c2a3da993e9d829c037b296c010d88f23ca00d6da9acd8d7e345e5ddb7c53a2e92f6e926b91989d1e4e231ce2145f9a19909811489f6e85ae1b37500aa73d88bf08001f4a913668ea8bc583cd6bcb1422601d2c182b13beca27b8ad13b9741d9afaf86ee5673145a81cc10b774c9a1c8615b74d1786495303ec7219c6d3bb43cc2a63855f5ebffef3d8161f225875e3f7d4d62c791a93b916b0a321d46a5756a3cf990ea821201269c6bbedee7d117593e9db8cbf338dd05489d847f5bd103ea2a6a12a054de5aed49de6dcd2b52e85e10f9e7b74137a95eacc2e2886f7a77e75388caa084d64a564eea4c4e7803efce2c7a42f75d18e7ed619028b25b15b618d2bbd0636f6dffbcbcf14d7b2d1e2208ba598fd649680c8799a5647182c899491ab35d32f3a0d1360c0f4db573221e12ed098c658b892944c2193dc84dd511dd1a75d984c4a781386980aef17646dfc6722453ddc5bd3b8ddb4862b1cbf5c21475f86853e9967319855e08efb7885837f3c444797ff498137db93452af38d1d472bbb7981d7ddc7927a38a349d2bd4039dc508b75bf306222c27f10a1b842286e0d411e77f58539bd4afe0aaefd22e220ae7c519a90446665fc5988155e5d0346b4d929680c4eaf4dc3fefadd101679d4b385dac789d158780c7dcddd7218abf29cffda8b69e6c644e96df7dde52dda07a6a5a826988c94f2b772b63667bdb6ce2bb4721e23c50282f0c3046a43b654ec74bdcc1d497d069155f11706525853bd16f165bc12967ecb8537d746358605104a89ae5c4f25b1fd81eb391d661c4a4c1490802637e6e93c99a549f1ba0ee9dc2217e637189fdd9671def48ced050119c54cbbfa89c828203d5d29d84b44d8a20cfa48727672568f64e1613f6ae0fe6200a666faf462a69095dda36e0063e633830d4256c52c466576a423503cec247cc923b9b42dfbdc1ea75fee678ce450f4a387449a936e0b13a3ef00b37f0c6511561c5f94e8df1e15a64c757517028279ac9286dc2fa72ef89259fef60445a809675922810da598012d7f14c2f48713e4d8112b6e4119c9c707116d274562b798473470aa30d21dc15d2227ddf85354e552b8fde2f47e1f9a178f29ecd8a213f633feab22cb0e0384951d98960a53913952e2283da9085ad592afe84fd245e9dd4b95cc4a64d0b835dcecf960bd3a0ce7865d896488f2caa333b0a28dc2abdbcdde65804723d116ec63303e70251a95a3fec83512d29b155388f17a7b20c2aaaf8c01da5425f47d25eb675ad9fe52db3476c178219f45fb507efc0528656fb8996bd3095bccb0b8c79ce69e8428eb9a3e6e17b005d29b5f9578c3c4945ae9361ea33586a26dbc32b2fa253badff9111ffba2a4bfda159338c275303349859ddd7e9e7734292cc796155b0af58f6e7e4023700d0c57db5e563be3607c7f2257dc4a8d72489049ef09030aece48fe0bca62065a879e413c1191937130a169aed18fec8f63ee36c31eaf6b7bcca525f3477197f87cab54bc2e2b2c86441f9583d61b9b5c41cdeb86cba9bff04458f648251cb2c2881f1e94fcf87130045ce2b088e4b576ef02ed29b8fc3d278d3ebdced9a4944354910a7751402e80dde6e2325ea830c00dfc6e5301a93b5b98bbfe3b94c0d902fb24fde0ad50e7d428fd8440a55a82935b598271e6839361b0ed34089f7eeb27fabc2ec9fa319da9902a2beb9e89b0eb5f4471240fb51ec15f95853caa3d18ecd71ce55ca131f9c1d320052a35be54afffbf7ad149dfda1cf3f5217399ece14b3a55b536bcf7bf991f5dcbb9e32053e6a90dec72c5162f1bc9c672ec1c90089bac05020a92cc0bc79801142e094b45a14800d3ac6aac6534309356efe0f921cb26e9e1855a4dc476f4a89372dffabd4d3bc55dab452e828e90ab02206a1e8bfbd4f11a0a22b0062d4122a3307b5d499d2a267d0bf0d61912de931ba2b27fd71b505b0fe6779be84bcd6424d4da21797a73aadfabe96ba10834d22fe2a3f545395146359738b3a107daa288d62170559f7b3ea323e92af610044e1390f7fcd933ce094da70f5871eaa51f6881963b447974900bc1a28516595f3430945b97d27f4028c8a8385a4edad1eb7407763621446f69be27ec931fd3ed6411f3a9536399f1bdff8576c5e3566f0d8219cc087aa34dda1a1298ec2d118e05e58ef368a2d99f71e1f6f0859d970a95215b4b08e9f64185de62a160c7504905710ae5eb1f5a8b2381f4dd286d80a4339ef2f255eab94dbad7f15343119b8af332b91ec1d1161688b412cd145c57e09d25a4453c46a19df7d5c1b8af6f2978e2023130a445a01775ad291b54d411ef579a542670c4b38ed32e4ec22b28b4a9a216bcd3d00310bda557401f5f2177bc131b06bd710835fdda405a8e094fdccf23ce2db2ddb89efb960ce55f354feeed997c90a3a43aa7817cfb925a0368e196ea002e6d832790af38a4ff8dea5d8c390693c4509a0717714fcdb81c44c3b098f7705d915706d17cafd38e6a135f3ad6d24aa8324dd5d42262090d3b94625bac0091304bd7bb0a455c71534f55b7a2a21e59b4ca76a0e9aad147b5908d2af25f54676168cea427923734c2c5e1f4457f5090e204fb6110b2c3872f852eaa3b4c4d84b592c7b7783fa8698f191deb7315b07c8a0ad7e42b664c67239b124258198a913a6caa7ed7e3b4419fa9934d613c60025af16206841500a2a00bd421a57f947050cfa01c92d29c79980a0b1147653a3de538f0e97bfc8d70038db3eec716576bc786f108246733555990e9ccd0fc156d4c73b752ca876255845adaae537d46aad513637452ac48a35ad01968eeb72fce4f70c094afc23457d3763a24adb4738806e767d87879e71c459e85f586f83d36a3757c1d84de8210da31582d885c735b95d25ad847fabf75d4d5a8e04febc6a0d370d00e64839a4f974e3e1a53f5e4b04cd0ca4b4ce963e76b23d54d942c69ae46030ebfbca086c8d7ec7293f7f6b92e8c1121fa00b7f7c95971b2acb825ed63c6fe86312ba7fbf92f7c4a5c58e2e58874d657b37992a2da6920597c9ef65472625ed80ee6f2f02095d3e13de45bc601579619ff5ee9c66e25e719f11cff196dd89c6bf2fbc27a701860b6f72763be7c9c861360b11801bf5b34c3d4b1afdcb3a117f752a346e033cefcad1dda2e845941707c01c077d0be3c5e7276e5cc9919a6fb2df0e2851e50ce3a7baf40cece1b425929612481c1ac571c4f5214ede12295eba2fa2f7bb2897507f5b5b8a04c02d47bb1132afb2dd805623e4ea516854778e60d21e6f9c7c29a76cdedaeb3f949a851701e02e57f95900d71b2d2b31f38991215604451ccf41869f6f9454efe86204cfb2934c69b112a77dd29c0da924cc15a315ee380746c2084b5b1d18828f706f36b42f9291191c54aca588d1f7c36581ff83025661fbd61207f7ffde5aeb8583e180640086ed99322e6c7dafe26d2874aee941cdbb2e3af6efc4c7d388a4a0579c04090ba433d347341b4c3bab1e8858294aaf2e1cf750d62696419b512da65424d9dfa57805c43ae9fef5e04ecf0060ffaf66f68603876ab0b1ace1ed4e34473ec69f8ef57b6ce7b82751c85eb398effb58c36bbd8b062ae691d364956823a642e86874da4f4f005d53c194776a7d0cfa4decf224b106dc5e7f6fbdc9bc3740290362a7593484ee54bfdabeaf7445a7041de20d1b5baca428db5df7c990bad7df20d59876761e61e6b105ec3d1d442fa88ba60bdcfcfa6d3492935cfc24ca3383d891e4efca11744a4620af760aa98cde79337379d5673689667417dd7f95f5c96e6559b1614f5544cdb9e8d4b3e9bf0de194573f9c87f55c48f1eabc4411a9e29f793e63b5e5682dcd958a0bfc3b892c4dd0814795fef27ad836820a82472e6a7af2c21ccecfbc81542371fa87c62fcdd581fa3b28dcb2d789a707a8313a3224f0540680620cf55b9a584a3a7b9b496e224c0a55b3b54377d670515f2e2311d50c8a996f43604d905145cd1720e044bb26753574b16624ea0a68f22e8c73121063796c889899bbffe881e64039fcaa97ed6ebecf0660c9a5b4583ff7cfbdc3ef04829e0ce72ec3a3d0979caf6bdc5d47662cbeee6016d38749efd6e60cceaeee25d5ecae1608eb589ab643e2d3726140a17b093cd3197c30034f3d54d179fcd9a4c7b4214c277bc0da80b2e764f67d6a670b8f31120fab78372cfcdadfbb436dc55c97ec1a71c16154230182f5ef936cbeb62570501a190aaed5dc5815934c2f6ccf4d57721fc2b860a0c8c7b93415c32e4b18083caae44e061588ed814999c6016a53a55b742b211af227c463f2fc1d8e7906c6cc7cfb72171f9fd7c94a5d953d119a1dbb3af0256050d39122ab096128984a04e72de42f832a6e18b918b4094bed0e0ab50cf3a9c0e51bfe9b4e3feb6561c2a1d835d7398b31865c0de53bb97393b6da1ec17759cf57749e1cadbfc5d18b9665dfe37513cbad14f6c080815091beb05688d8bf0643bbb04046935f7f1d18a94b07f2ef8dca8120dd74cc242c34e8095aab18b3dd93da4b79ec120bb72f4717877cf8bd50c5ffc8fd29b59a5f7d829626b7c3b02151c09c61dcc19851fd8951fd087f41fcb56e8a4f297558dcaa14a8f47124b6d84e94fdc6bb13e1ffd2dc2bd5a1b63c406d538dc1069c37abf23ed4f4836539368b632210b53908aafe62a333698645b98caa9b1cb5fa9d849ae0dddfeb52f572ae1b5caf3e74799fc7be21f40fe1512f05f169143cb725354486602319f5b7044a1b5e580fb8be1adadc1e09fc3a7e8d0219ea2b409195d9fda2cda51edc34cf10240ebc51d5c4f989e0806b6b4378b4c6ad8cbe2584a3a0d39d102e68e4bd37c42e249a10ffeb5cc39970fc955cbf955c5d632638a68936d12e450cd1dd54f962156e555ca0ffd7c4b6c409f6ec1392cb2c87085e315e8ac704c22113b17e2d2ff268ea35977d0f2f53339e36612e638ffcc9c6b3c01ce73c54850ed3f6465b3a8dba659785347eb2ccaafbe1cc53e05c05cdbfd6bf5c7a3d7f2ceb95f0436a72b78228db0aee2df10bc7e8e1b3baff7458299fbe5b3e76275e79cf852d611109fcbd0932172eebd37d5eb85123ef838eb6178f6a75885cf4464e6c2b607a42fd0d1084326a2370b566036a6fbb7e9d870c6475419c66da7d46c18b0af0b6de77abd17298c1d33735012fb4cf6fe647aaea32e9fab3bd9171e8a6d8ff781f724c9689124cc77d150979a64f9a86deeec551000923758ff3da5725b9e4ca6ee65212efd3369fec3ebc25f9bff046b6b305e0c81dd4430db9135028c37c8584d4a2114f3cceac8aa20e00d2d7bab11ab4a4a6813858449c843a20b09087ed5389139e7c7e242275f359a1e52f121daadd267b9516f691bc646a634f2d631d256c5e83c59648a01062ee52e60ddf749729e66df52e8cc2cb866a4f9cb4ed4c62d9a3c50fabae4bcf27bedb41d771e66757190ae8cd8d631efae683bec7af535a8e68cfb7a661e27b8b1a333f7a79fcf895cca9846d6adaf406b78925d2385338140b1a84d47564f85c10deb5c4d38e0222938f849e1a66680b4c73ccea1d55af00bc29c05fd4f52e9368b7a6db3d2d72e3895fce7be53910353f94acb1a4708ee57809e885c31267c472485bb080f5f7eb2baf250f73cc69a8e41dbc82f9ac38fac0e4c618e6d860a8424dda2d9be0c66982499e78cba0ecdf12fbdaa1c140819bad8dd700aaa2158547311649b5e54cd2c176a8d7650ced5f368446e7c85a1997eac9e9adb0b28858dda519e71c8c8357f0143d72116b28b644b9fc181fa7d5032554e81e579837c3ea9c15a1033532e956ea2c869107b226e5fb9ddca153faebefc33bf928251b7ad1201c524290cb65bf1bfe0e7c3d456f95039511b0e7c0bf3024bb5ab73e338ffe3ed31f70710a80cb2cc16d877d4e2d160b1db7135ebc34744cca8033756ebc38e46b25391607cd7996b160cddda8e5c0e3b2978ee42449f3a2d88c71284cd0e8a518d89cdaf23a381d4e6cf4715ce9cdf7f12292037fa94a95e5cfa996c17a4ec0e09e9e62e9d52327cddf6e57695c0e158bd92a3319a9682ad5ae5cf1ede564ff9cdb0b2a0f0d86037a7ae8f194bc095588596a1146af169ced3e2b940917fe1559350067122fb2cb2d5102b8755d0c6d079237a0bbcc2e7aacd709004ac92984643b624ba6903b7b1caf3deb9f918dd1630a280fc95687cd619cbcccd44b7b5bf6b55c73dc58cd4deb94fcb5db2f227e212777b12129fc1f85deffeaaa049a0e280243bf23db4369b5c87aa0c5749bc66fb7995d71f2fbc5938449f0155166efb84bf3d2807efa122747f10b166a13ea74b27e1175263c44518dc857476871489baa2c6c7c894a96c4ceee2f3cf61ea667e6b0242a6f3e80284753b8bc5205fc4129d1adc8a2ffed1eec7efe3f937a6ff6bff3b42aba3b177270c35c17f1dfee0899aa1fe23bab12bbb3777c8f7363bff31d57d06f6bf118bbc742e725f6865a62a53f0dd7935ac6302049e6499157414433d188bb5ab80bca23ed1a446a28b8342fdaa097845c1617c13d5a56c0ba0d4e2072e62bfd525b5bb9583f8f410f0906ada119023d9faea0fefbdb930ae0cce90b2cb6a619cf99943736e32029f28e7319bb6731e965965089d3ec58dca1f1cfd5e95d6cd13e4e0d0f22639659525970038a1c9f6f75a80692e90a488c05333f8868d17a6af72d74e077787427ae540de185f42fe544b3185ca18b53f978af1fcee1e8d525f84fb3866b13a90de3e16b48abc52e5397810f6e0156069e09286b3886648abe632f4eddf949402673a8082ce8cd511be7560099a2a9e679361d2c0d1039901655b5610302b5cd768dbf4519f78b735524a625a967ce8ba2a78d02b58053edde735fac10ff5be14484661191d1c9cb53087c3bfbb7e360197fbac6e5919138284b0997561cba8498cbe426423f0923ef75fe3d4bb3dfa5f3e33606e082c36dfe8e2d6365ecdaddec41dd8a98913027e7837e8974293a3f4dbd673070543c32e583856bd756b88c0efc2e56c2463a494b213c5d2cd525dc6a5f9f9cfe1a02b3fdb3d92f4c07de6c66851687a2679c7e76b7011067e716e1c849f4e1073f3ab819c82f6cc81fbe4a434231a758d65c3a9cf0a06d4cd48f6bac648f367b49c5b5047b14bfef05e1be7169598e909504113f9b6b7387a9864087b010c5f0cca1950296110ba471c253d9daeda61638a0873e60b85e7f8765383c5212dbb3097b9c90c264542f4d03ff91d68693733894a7c4bfcbc9084139b38323877bb4d2db1b8448b60d258b5d6e7779235440a8d56270e54f86cedecf75dd6c1a37df25e92e8323684f1be555904b76b34a389ab2df7f15ba1a5ce88ff1fbb376b288feb1a9d3b32c72bb89eb6e166e3bbfe82958b9b8c80a9e7639c29a219332e417dce5151fcf1eea0d776db533260cc13556a85f52db1323c09562146473579ac1ad76694f634b3e58fd3b54f1e7ca53b55753f34d55fbed70854c90faa274f1b59e7f1a418a6e8ee7d2781abeefb44fef16bc84d1ac47a3e29dd8fa41ad7fbf5c7577b6076714677e6c8488e811f868877c5f56479ab80faa6846101b101545436b68d321c7fe50442f61465bc96f260a795f31776653da37aad92f31b76762593a161d67c6ad78ad58e7d095e4e479c4a4aef22ef24b3ee16cccc0e715496e90c696a1d3e5da73144dbc30376d976922679154f7489b070cac7e68307c0530709bcc41e2785c416c34a417bf7321efeaf2d4b885e2b196c97b787dabe284f31681f53b25bcd4b62051fc3e8d8ac31d05c988989509c93cd1f8d9b36a77195424bb08036ca20c4f0ea2b156e559655249478bd4444bef7d172798c0311e0c91ac208ceb429e8ad4c9170e67dc462dd89e75d565824dec762552e8cc340841c9007702063e3e1edaef265c9730aeb147b7ac549069ce7b85a0cca329de50cc54ad9f34c97ec6c76ec31e359bb56bc56f4ce4dcb84ac410aa5fb53297c8c12961d94272357a6756d02623d16a8706177403f747153ea589954139ef7159697f9f14d1461b2eca994b741acf202ac3cee18baaecf8a84bd0658c6ec0aeeac2155b248db07bfb74c32cc97f864b29adb82c8b73d38e8a163fe59cbcec2c6363d3cf4364121e3f7f1b0f7062f6d23a84a4fac46c9d0c225f13f7b258ed305b3527787cb4b0ffb86ade4b362402f3af8a1886aadb1f504126375c430e82dfe397c96a578100b7c055c7cd9840182a05f13ac7b45cfb66bcbfe3d0e2f68c8fb0983ec5a8b1398635cc06dc31597e4d0861669bcaed1eac3b465353e5bc904497e78dd1c1142644e34a5f6a877d438d79b8c3ba73c59a39bea82e963336e885ca703fbc6a475d6e30b0d91d4fcc86c5808120e72159832c1e5305868be0cd1f31c7be97249af0abee6a725c0076899eb0a9b04e83b5c23714d467903a88cc74944e36e55da16a58f836c1a5e52705d01e9898e9fdf0994d598542011a4d6c1fee2b40a54d65ba9a6154fbdf7391cc1b232afe77a7903bf1f9d623981d266ce3582d49b2da78c97619d763344ec9ba6f7c08a24beaf234a94c16598c1ee4e9ec16da97b54fe311bd28c3ddf87ef8051b047336824ef0fbf0c01b130b32886281055bd060f4a7f175fc3467bcaa982b74303f65f5b60454d6ece98f1cba5919d92c1e4b00eb6b9ff97b449f7b90e4dd5aac88308073bdad5db6ace6b406a0ccb5142f0da4f597761259c9eaa85005919820e93753a989de1ce929e3e2b53fdeee612aab8cc832477887a0633991a921f710faa8bea96ea0a465a8b8574f1a782bfd0b5c16b6d8df28c25840193015612fbfd014f988198627be5c059037d9725d49f5f0751fe43b5982ab689f11917483d345785843983a7b25d9def9c2f5541204dbe8dbd2732700a08ebb8ac685fa0b3b286b4abd99f7ad76eadb00a8d4751cce3e846bc1f2a4efefea5f939095688722082a8db7df91daffb7304c5b4a01ded33784f178ca736a14d644c27470471e2f53eddae62f894248dffbb682c95ec2f5d61b3e8225e673bace4264aafe89d03be7dea935338151190b9d3e846c41941294b9dc500aaa441c96b710e8927c43f0782129abee6ef92caa4ede87b5bf5e82982123031d19e22f02fe635efe9ec95fb202ac7b343d49f10ed40e2bece46c48e6a8905fbff213a80305d639ff0b2274383620b546ade8d4594ab6b8e11bd614154441006c2f5d6c79cef023aab6f23febb33008e7404feea43e487432251eae3ec8c7ad04d8aad4ef025bab873600053cbf9a4bc665ccb18051c4cbe388d12bac6cea698866d5bfd158e4c79d082bf78f3ed2891598f69f92bd13fadd15d618b9ab519ce39ccdb8fe7046dd41b105874b7a88676edd94bd3caf7c187f799a930519634e387635e6e73bd96a050128d6b624653d333d14b212e0819fc27dcaa77e0ee138ee941926bd47ebd2dbc52ed3df418b42aaf2c6717285a2398cbe9ad0bea71bbfb1501fbad2d7eb19a60340a4df729c8bc952ebf647c8dd7b8971a45b9831ad5fbd23ae3bc07c5775de445560d123b93c331fa9efb33984e911a2e809fa801814e30a6fc26e2103c5e2cc54de23f6396fb06b5929b347be21f5300a40c787a73378b8028c96aa5d4a0cc30d886732b87225e5b08ebb2dc10ad5c665aa4c9d6fe46419a39bd33d846f11340462fedc10d87e850c0851a35817185051a127b008740e4b42659bbbd1f3ea35b4436bf13dc7a9d30fd927dd480fc928dd264bc246d8a1df02f9828c5c0e2d679b8e628934527042ab2d40d416fca7f24335aedc44297d0183d6aba5e8a1cd04d944845f672f2e1d8a07414be552d1a5ddc61140033ac1b09d721e80418ab898b4f051b42fb8afa4690885a5154318bbdc1bbe5de3b3261577af09a1267c56b8738a3de0c9055561e17003c3dc007944fd171bbf5cdb37435ce6be1331dde327b2b3462ed1e5a2640f1e10deb4b4b7f2e04a28c77ac86c46b63c8414b8ae842cc52b7b55306cd11fcc723401c7bb4f40d435b778b013dad01b1e60a4c9ba59a9c66e37c8bc6c2011b8f41681176b35519278e51f93c0813d4900d808c36af41bc68da05f76000a406102f61f1395f99e079781e60ea55e811449bcd7a26a14b197bcd9076bc14b0147a9692e15fe6d2c2a17a265f58790ea391c33e1c80ecdce6a41abb0c031f17af29e07212a60d36f3effede675bdb8783883a6ecfe16c6f0e9d9b016a06e89fb738fa89049f765ec72e65a8d18ebf83ab918848a36d87fc6080f6f5fddb04f4b77d9e210636703d98146e6c33ce303e44b98d540dace0bde60c4dcc935eef45737558aff349a76b253ee34a9e43e3411f41f9fa8f8692158b4e012533eab4c400ddaea3212004fc4f9fa372b8705d487e3fde064dc562f1121af0532f84d7849da1b392d8991d63239437974e21e85ef93ffd69a49ee71f8238804e6922b2f593eaf5b216c28778225e9861c5b56447be75a744ed52931f933ca6412b9eac4f1aabfee40271fd52f23a137310f0b3fefd4ac4b2d347d01a76e490e0041999736bbe4a586fe8f09347634a4bd888b43a7767f202c85f814b49b2b47d8606c3f9d5f1e681da1ae39683c93e100386d38e5ff6f885e01cc459b11366056f92ff1ad5993060ebabcc801b024b1d68b9bdc340bc8e071851e5a76eb511d6aa9e3b0e9ce8a9d5e8a1766627242bdb5ce755efbbd67b4fb2f9741b1b395a4d1e2d71ecabc1f9ebb505094ca2f6b26c6c19e66ebb3425ddeb8f299dcb6284f3f55d7f52913a0b39cfdae59cf519f88a70f261e9c30664e9ade8a80cd11a46aa31acff8dec5a316779e01c8fa514625fb7457f6adbb807ae9f62991d9f120addef61f4773b84f39d8b6718deefe9baac52e1387176b5b30b31f959dd09181d0fbd023267d49d6b6ee5450c5fedcb3b6cc350c596f1a611979d31d6b376be9dd666170b696027d2a60d2b0c9db1a7da7076054069ead8cc4adca7f83421d166d031e9bcb611a7928b5bdc55903bd0e826538fdcc2890ce9b32313344e84ff06fe62a35ff4b04a807b707b6f9a4dcb202b157ff3c3e07f0e30612020990940ec49e6f950eb4e91f850059441bf6c5dc850a18786b65433080fb4f99a457a3eb6e80d68ec0ba0d57565d5c70fffe2ddc3bc9ce40f1638611c418d18348fb7cc466f7c33c4b0fd755587597ad49a7d8530693516031b102d346f0d54fb0a6324a4f558748a48ed39d534a62bc4a82fd7289999f4f8db114c5c4e09b259c322dcd45760b070f834d81b00c0458f80e2341a360568b60870dcc1864ed881fd850f785c7d9ffae5496cdb9964672c84af5a15f49c3f77ea8ba4997ce26e098f34cdf67477c855f664ced37c8f339a580ae7587cdbc52dc16ef0619a233ba213894fa31620db80c7f6808096e70c0ae049835d0c41a852a01f1228747cc1975fa153c1846f20155833be385cc049801ccd69b2124e7690fa69f72649e391a2b0f87053a8c15d93f64958575095cd423ea6d30c98f30f3a31d5344a5dc32389777559401bab5fdabb1cd4d382398a4a94c8392a55392765ec4a8ad281ca7ed98457e11e98b079c81f037c7c012a606055792f0c2ed5f69d60a05c5dae02f4ae374df22adfe0a8d408425992e3d5ffa7468aa3620908c9d8ed19475f791b314b4c6322ade59c71b08f3bf20e691c86ac8ed17c66bc2431e3f25664c73ff79c9a9bf362f2b74e523cfc035de4f00663927d371046a8adfb012f52bdddb127132e0174456edfcd6c0afe745958519eafd52f7eca90b2b4eb84af185e9c649af47b078143c5c91314a3553aeffdff3d7abde5688e61335d78c6b83d6970dafaef2cdac06dc1b528ae38170000499871051d54df4817761fab206795dfd06828a145421e0bf5c3d77a43ca69baa39208c0afaef7ceb2187bda939a6822df80f133babec438a8ce822366bc130afeb69928127ab4184eb44ac3dbfa82166f57db3e32b7b8bb95c8eccede2b5aa794b7ff916ffd95f909fde8d1cf707d0a69b46a719dc965c2341d067a59b3f37651fa7b280b6e590cd58a04d5f8410629dea5889f3e485b56025208823cd7cd2ea03f4271566b41ae98537c5190620a8257d1e5a868b0198535405210d29d2001d863e290ea8240ddf5969e0655a72875b7de0acc8f550193cc976ffaf91083c48ca32ec701c77012ebaf79d46b5510755bd8cf96eca4e790ffbfe5807a99ec4098ae9df710ee7a35dd85bec18acc167d893f428990aa80a9228f6b49082cf313c338442bff893f0da1bab6826cb60206c68d8fd98f000a818c3ab133829fed6d17f722043350311472c84c225775918be342935abe49b93de61fc02bb14c248b926033ae30bc0ec7e095643406d8a3b93147401c320c230bb041d11c993403fc732dc62842ae801e31b4092495453164df7fa773476fcf16a88385360d4a0f19592031c3788c1d9f7dbc92589fc37cb251ada25c5a17c83ee479075ccc353b8bbbf3115ed39cbb0bd4bc64df6061f11ef1062f7317d5d29673625ead58cad60ae02905b3b77cdcf794b9d202c37d6bc0b08312aa737cd6b9f7f7a7b2db1d8e2a6088659ba4f7cb4be5a60040540af81992ca63ae31f59bf424a0a4640e917261658ea4e19802c0c5461d0705b4b5ebf843bad6f4391eedf0db09ae789e84988f874db5ce4093217bbd5248887dcc286ad148ec1cd6cddf0207263b2f0be8def70845a657819657a1eb8999ca0089a2c927c5268dde53a79e129ed78e7ed104499e2b7b6f74c6e5426847c4050b2692f5270350acb2f6dc735d5afe4b00094d9c9400891867479c9f2e44926a6399d38bca9fbfbefb0253034d9c31c0476980f65524dc861f79e164a88d34987a6e7cc68778bb9bb574a9974c70d2ac3725e0582145b209662a35e792ddb095dcaef4c3a9c18dbf1495ff0464b25ad59867d1324d060efc6d3f9655248a5bc11e877d442ce68c1612352c99936bc56bf43281254b81ff194758bac31e1b31c4c77e409830e990d30c68a92c4e013e9e4adcd71656d8121968f6b128252656c2964adf71a914f4063142af7d49af5af29fa9c96ebb7763a21ec1d71700467c2d3a564410643fa66c6fe013fa0348b34b776f6b50d1146207712a37d1c5ac7d259b25570f3002b1aa0f62a17e1218c2f368c08dc9b14c33f106fe39983f645d6eeae8506c085267435eeb7b81583449dec1aaa3e56c6f415c9ccb632bd1d7d45f7c688edf74d8ca16e0753c80a8a53fd0f5b1c993ba1646025e4e305c2774002d946c34cdcb020354d33141fe6c1a8ad053d9659fe49aab013dbbea1eb58f11bbc43d743afe16057759823ebab050fea1a62f1c803a3ad8e7196270aac0851d265f479eb4a5444112504a0f4869480b44f75356545e483dd96b62196b2a75474e655f3e228057532af59242046339ae9fb6714e212470f29afc7e1c36abc93d0083aedf29aa6d3b8b7f62f46a61359c578a660cca202ee31966928b545447fb38637433d1fbf0393160de5ad22648d3a498cc372f9ce3832c147da3dbffafae1912d2f5ec9b4c7a3bad3df344128d5f8ee4109df81ea774eb9d9ad316653637419069b9249875cedc18315b1b273f292acc37aeceea8eccce7078e38d58d38aeb56bc33398b2e70f403f48fd5f9daa4852e59ebc92de5e52bae0064ed9f62d58baed2bc125ef8552e168ee91d4093e0763ce99f2812c2adce07364c154529a4b9cd2d612693b32e0489cee4287e63274a24b3b86563e1878cf85b554256b4c2e04b32bb23e543b088d61f759a1f38d6a48f8bd94fac6547237108f805cd02ea1e8efd80aafce087e5735a26e8c076852fdbdf2fdfe55c4144ec21f73c5ba99e279ef616bb619ee174e097200737c12daf290f2a833e7ea5bed5808941d3f9df1382121df70989c7d0261fdf6c1be71fb12b473c64f802419ffc853d648b9cb0caff30863c5355b7e7f4bb99545f081481b1451a9ba8eb183ebcbcf302187784b9190cf1ad65546bd8b9720ff62c07e5f7185582a583d6f66eb94c80123c7a1af31c8426df908db9fdac1e5be7fbec050757c8e44a67ce4a44d3452ff27c7eb6c8c7f12f8b1fdda0bd38edb4682135364cc00427ce2079a87168ffdf79ba92299f94ea082ddcdfbee5ed2b9b09cf28c7939ce35c4fc8bce3d6a0916553215562e00c4bd342f139554efa89551a0e67e4912bbab58f030d28ef42a91afa4641305b3609786d701ad079690635f4e423b13759a913c12eeb2ea8101fe7f53daf605eeb2258fc9f8e12031f50d7a8925fda9c23017b84235f3ed62aa44a86bb8f1b0256c4d5613e374fcd35b19ed2f0c7de8d3d83ce11cc01af5ff0d6281f81aaf1a1880ef380e10243cbcc3bdb733670507bd2e372a0f7a578c8a4afa4deb660469d6fca721802d7c36fe2fc6618dede89317b5f9ae9a11da99b16674cf57ec38e273bb80441ec2a2d9d290542b91f353954ba63c1e51c4111415a7984c891a6e87e5da21255f2fd8b5fa8954a30ecec25043b4865f1687a006507427a8f877ba6c7e44d3c234761d0d1d55e4a7b46ec9842649362a56e0a8e2667026f2736e38118e092f3956df85eaf14d39bc5a0d907421ef6ae1e45a6e68889cbe36ca42540b31591dca7da2e181bdcc8e89513382113155c55e0067c080cdc9395df67c2e4921643b346596b5da9970decafa4ee8a930f66a7380ec3f43dd35c0859bc991cbf1a4b5d69cf0afc8d2e1e16ff88e9b18e2ce41f1123bb2c7da4b202c4a064263195fde44ddb0fdf813349ba52d3d11d2be89eeea43e2960a5fa2375880b13914b4208bea2c1ab724a5f952f409b0eebfcd4ef18a5a2fbcea99b172409f3deb2987b42c56e0372e4d58d4fac29392ef3a9c900b131c5aa73d73ad09fc56dddce0e3bb3dc648ed1fc0975b8f3152d3fc9eb7a3715bfff095708cadfb423e39e3de6bde10895b6e9875ee3396ca6aced476d41881d88e28c9fd5977f72a44dcc2a82beaa295eba9d6fa579cb83092132dfd196d0942f48d3a129f8f104e87dcf90f1902d8fab1f23b14833a9bea73094d76d4a6210511b2c78d997dce510db0a83339b276bc90583a32ef82f5d590218ef2c9cabeaf44080a05c41c80041fb328a06e3a59e5318a999abcace5519b63fa1df25b43b8bcbc4a5c64a9e5108c22804ba37c3ea6ebb351a58b53fca229a35525d48f60bc8d854a5f20717a4b014c3c65bf35de28772da06912f7e35dc054efe4e42ee75b81ae586e65287bf4631ebff365ac9103c636d4149364ba94db0ff217ad7fdbd156f60775020532cc96515777b6bbdfe7234211d05f46f087e748aedf3b436132b415e6eef9f826d24b8da154df81d1f3d68bddb44af93a13016b902b1fda0f1bb874a1ae67f02cc797b4fb1e60c36360fa1a702438e1ea4e04f74940c1e97dc9d125f56df90ac5217485cbd2818411ca077953c96d1ad5435e1999471140cfde90a13a67ebb57b6a1cb033a4e78184f8ff2f821454bc1828c5a10d81340816d59aae117fc4677255dcccc22a17220b6eef4e7298833e4d5ea736e6a7100cb8c5c198054e9c8aada8977655b542a142073fd1ea0ec8a111e06166d58f0b75b2c071c3292b2e0f3ab1856b1c63381f3d3428e2b0362eb8277573001520edce4f1f973d81fff28f562d16dfd4a01a172674556fcf3d6fbc45b21b3b78760851a17d17582a4239ba26b686f69ce60639946a38c3235b46df75c9cb880a56cc95e28dddbde3af67ea54b993054d9b4fa7807de9b76aad6a260bfeba975559d6bfce26a543dbec382ff9c4b77bc61b7b13653bf1d37884d23b37a767df36c3a1b2b41e83bbb47c72a4bb0dbaed675145da7a49df1d93a26b22cddbade492b20aeaca7c2415107e51872760f44058426e5e30dc331a30b6db5204f5377215c8e0ddbebf54e4580f872e14caf6ff0e13233b82cf9356f2d5e3358bbed358cf3dec2026e1a230d74be0789f2abbcc8c121ab70b76607cb7052c71f24d6a67575d9a5c1ee8b8bb80c3313adc4a8436f712d7cb6120ff4c8194215b6867df4d2c1d6e7e2ab1f7a0d9c07d4525a2f62c599475eecf08715a2f58a2b1b8e503370394a411400786da729c2b68df3b2815087703d01d4df6d529e811ce34b88fe59424c7d6ea9f0374f63df9c0abe29e541c65787503a0945c214ea4b0ddec4f54b18334fed65167a14f1c737c39e5d95a3b1915cc2f3e307e20014624a01ce107fd461167eb94dc947ef2591bf672491bcfd49104bfa13d820b646aeb9cd6e841054123edbad276b98920e01e92c968de7305bfcc89ce6cee133306294e091e68f13763f53f47bb803b6be1fcf0eb82918adae5d9c5890e809acedf9ef2c4186696d08831c50fdfdd26a62f7afce62ea098a24c00713c0b7b078511f4920b11c1e80b1489921d7371ff5798e26fbf18a828fd87ec066baf01c0b9e3fd77b7b0a6d4ce0b82ad6e020d25c5809dc580271a7dbcf143ff77a309610d464aefacb74ceffcd064fe571881401c9b2fa6fa38bb7a3341b1f616a75627edfd493c7df2098c02dc07b53998d6e1c3436998db02cc115e55eaa74f2747232db482246f37550308138fe60067f5904dc8437e5dfd891e1920285ffcdc057bc6157fc608b8d10822b53f254669222a2ba18a2ca66a971b5b0ec6cfd954d78d48b74cae3070c7dc0ea3f5abce5ac3cd8a77a2d13309c7150deab71ce0a2201f3fa7ca637a6a90540df9f1c8d32de6da7ccc168735170e07f2a0738252f94164420192a19ca3daf9aba82bcad4a59226593aba5997237cbf066b8f08933529fba9d9dcfea3f5dcd6f394db4c54efaab1c2fee975c9080dbd2e4ce7513a5007e7939f9d945156d03d00a8926c00511a2f9516389dd83a7601692d9f31216191af5f558f1b01e39ed76bb99ad581b5754f3dcfa73eb2444750bacdb657ea24e0fb1b61229b6c54b1f4695ce61cf6cf62648f6b90b79a3bf53dca28b93731967c644427d8b4fb0711ac9f6318c49ed2dd622220587c5933618f8fa77e5232f14a3e8ab1a08c563af11599f50f2ed5997353d4280e014031ca71fff7fc81230bd6dedd5e327e9e8ea29374e5ccc8957ed91bae122a47e4267081b32a3b292c6a96b0bb2533d4b9a921f663b40c6f4630bacf6cf9dd5ea978ef2afb9fcfcab234140fead9c050ab76d5254337142db3a91c07a14a15cc034befd142b92f1174963111a754eb6d01816592fc892993a3e91788a7e9d6b651326d4e7f2163410a281d9f4d2b874c3e48a704708e9d7b0ecfec37a361a2d6675966acab167e6f2ddf6bf7ee3687f787f2ecbdf224c496f2fdf78496a7248649c9a2e8e727a20264d1b642e9ad0f41999ed0d01a42775f2ff91aa8c4d05e9dd679c92a5189e7da9d31a3cf7641d4e1c58ea8d1ca0b1a933dd27ba03d34297d19250607591ce9d0167984a6f27458ecb5d318fff70f2e598b955d9fe5ed5af9c9a7f412da3da98ad4834155ce1cdfd7332605de6b37f92f3c294e75980a77f6af90cc6bc2eed267af650fb4b9e8a1ff6160ca6f8d3021e16a69068c65c6ff33c56da7d44aac06c0882987aa3f22a3233eb12257d4e5d9ad056b83fe89366922fecc9537f879ac3e46e2ce317d191fd36b314588a5879ffc3bd136b7415bd406a732c779ce6bc5c0e806e1f08d3912e46cf81c88cc4cd4e346728cbee6f251c85d76869a4eb6ecdf5d89b318a2c90cc41f92426cb7933e441ddf6d934cd6c5838ed184974bc0f9d497d26866e7a21281ab48aa67d5ed4bd242ace8cc772a34bfc216678ccd7dba7d3c353eff1101bea255191b6d0f193f9c86a0b74b50b50ebfb2caac16ca105265e3f6fb7f152160573f86bd9fae1979bd1290ca32d3bd9ac1ba2c293effb9e7aa583f2156311cf24acb794d5ce3d3820ebda210efce2a32f53526074c9b77c67af57d79f2d3226fde6ac6c9b752be4db839cf202c0727cf37d1bb99e2720ffee1250ddc3c28bb8b4b83aacd4e6af74712e4d73544ebab546dae7628dd45995b271734f24510daa677e924a189ea0876ac7a84362cbfc40aa1f872d85d9f976b5443f213d3fee423324fa25798f819bb242d41f895515fb9e6864c4b973648b0c5c7a18addc405eb4b77e941397d30e4a6d86623e50a7433b23c49bb607303efd2f33d9ae9ee1375db7e651881488319040feedbd0fab7627ec4e742604e8a4cfa01acffcccb49c6851d8e134253e937df32e405159dd24778d87d8270cd6de602acd5c42577a127d43a71af1f33f0b372440873317a1740d58c16a483227aad3c6bc0fe282815946bfe8e53371b65f1823f3d4821859a53880850b80c2228a3c7f66cff1212831ff9f1f045931b44716691ab2621c37f3075350e77d7687bbf43c7ca2122646891d59864088e56a56af472780104400b03ca2011b68df4d875da1696aa8e70a75f668a8f4236002ffe050c269aea0a521a5fa032613a50634bdce18e5f30f3110ec292205c6166ade1630730f9a992014bdf1d7a741c2c6f3f99be95ecb9988e955220b56a3a3477ac239d0ff698936ae89bb735914c8ef1c6321d7c9ef6287ea12ab5ecc40fdede8ceac0c6ae4a242cf1a7ba693b8a1b2070017f774cf47f80c224116eadc2f89afb97fad8531c0013a5dd0357dd9d566f8d1710a03f9b8a77ed00d1dfe0019a96f6415909b026c83ffe5d847ce00b147813fd7b303a297c4d7d30ee5c82d3154523360adba51186304130fd687444e3716bc7164afd115d19b3685a6679beabab397a4a05a46aee654c89d2c1e3ebf76f0ac010c7ece5a1dd245d2d1d22eba196d5a044023db200fa15ff232c7804386902a6839236d64079c7359e556f34af355fcd0fcb63ea964509756b0c11eaa2c261fdaaf209a81570ebf6f7e4701d79dfb6ce8710f4cfb8e9a510933a1bddb4444cbae22dae24b3fe1dbcff75f3cc811f87d3b2a9c3d65fcb610618dd7033bf2595df21e6dfafc00977b1182c4debc4a9ec95ffed183513c8dee9d040aeb70c1b292163a1fe9301848ab61eb4f6ca511703ee912f82360267d55cdc0fabb1ecd7e79d71e8301f3fa5308a605d21cac11731439a94a221d9c08a016fe70899e6dd29fdb0845e94b40d6ddad6c703399e81ee8e4a50bb2d13c0df3965ae4d5004570abb674f0ba196a3666aaa90c2abf680772e0243cf5c154442c3cd2303ed00ccec6d286ccfb8c64593aa6eb6c28e0ce1880ddb986f36bedf04d46af86153d251a8594f594bbe86377dafdcff17f3d6637211fef0267335167cc2c9650e416c19473e8af32b6bc9ba51a6ff3f1900c7da86f9ad37848a912aa6f6ef34428a1a470bc5dec8f35f75dfc3cdf75591b987723173aa29c79ff96e6feae6dd79fb3ed5e5bc2b97972736f36cfafe2010e875dba8aef890099867826c63f796631a2b54b1339a0ae091f12b87beac748b9dbb3342e75b3ba1ef372b86975eb90dbf25290f1b67819d49fc83a074c8c378ff275c74b6bc8a87eab2f77cac2e1b382f7cb4096ee37275b08282a050232ff22d0977199db8457b128cf491c72279a603f6ce38f40b0b18c0ff5eb673fc50e7e9eef85869fcb294788e6285d07220f82013a631dbbec18069abd5b83b65398cdc83849f8c7ef34ad432ee7826ca2ba0a96675ac84e2240f02b26803a5fa9b7ffb97176516a339b794c0acf095608073fd5dde9ab19720c07c16b1464ed84a4c67a3b8b2fc983a1deb125755403e90c976c20c71bd5276574e057c435811d5ebd9c31678c39950d4445d3a7e0aa7478efddd8c95467a16da7c3b6c2b9a536c8f17c2b4312ff64c8111640b2acf6d9958d4119413dcf17b4c3fce4f40a80ae83f9d93ec36a55c799ed35d38088e8187ac2ec695e4feacd4752d32518e4d4a472f2739030ce4e36daba92c055a5b04d3584e78ac3c2a60883fa7f8b1e3845f2a87623b33ac4b7bc6d26833c3e0c533927f02a0e59ac3d663063ba9a8f1673132f8256efa4427000a13820d336cce1471ff540edb3e613c762caa4af7a20d9bff95292904c1fe50c90f6eb79da1b5658429b2c6ec4721522f213c2ff0669446a66f4435d2cb170601405a9aa44fdd089f2263e8bc2382427f19010f62d292680fbab2bf555d3239ba826aa4383540bf53ec0d85d8d4504a6cd910e5a1db84a612ed7612f1686026cf8e122220fa855cb778466e4aa42a1918b6869b9190d243be64672da4844198ecbdfde0c833c009cb8a8c4d82154031e6fe0a8a8a1565c2232b830b223d6241eebe4d0d1ef1462baaf6e7aac04e6eba5a76995560be6147eed408bc7cdcbf0d14463d19b639c2252ebe4b21e9e1a35bd979cc9d1adef4104157b922c33a4c3b4e836b6acfd85f669eba48aaf6c56d3c58505c93c1c7a796ea5664b5eaad358e0c25fd8d0af89bee2b5611111bf6875aaf74834b45402b16f049dd999790395d4e3f68332322dc131fe04b3f36e2e0819f304e339b758ed8997ec95d7d27348a6532417fa40d7ac6d25c79b74ef55e4aa88c5fefd6547b77788618370bcd80a64bbb3ec178124235e3a89b5f1658ba0f9de6d5d034598047aa7d1d9faa1bf678866c1598769a96f140368160f37c1372e49891f1fff4507e1ba2b141ebc407ea52dc33f1e2d2d4a6074a753895f02f31979ade91db1a314e889d90f8eba4d7ce48a713076812969ae7170fa8172ca3315ed7cbbe8d04267162b6f49852c725a533d1e13bf6c7812e32cff6eb03bd08770c36f4ce22e6054df7c44a431f43f6bfbd6ca50474f4cd0558dec1c440491600187db2ef6e089eeec067f8a223730c69181b4208c08bc933a8dd01b7e16b40137c748c4889f1ffec5ff4b4c881a2e7568f81996f36a0abb420906340cd6d2e981812aa883de2623d0bc52b07a6276a029b0083d77c66210189f884d2712d1ebcc7e9a6753feabcb6c7d5bd328ec6eafd3ecc37fed4676470c75359c5eb772b71815e409a639a47f50b815273ca87111929ca67672e9ce46ea6e22dc2fb95d1c1fd48516962cb13ad40e636dd60d14dd91f97a23e18910615c381820d1e21d490f78e8e48b3be37e2c9549e644a018b2a5b1cfecf7dc42f0f227440ab2b328ebe52e1b2406c75c308d4a9c44fe9de5b6748734e22f990d180b11dfb50ca7774b305f7cc483474e1ed6aa5bb649bb28e3aa22f441068bbb2294b4597927ab53a96ec42e65f88bc3abe23de06da14b35e7a27b4ce2b0eaf1bc3f0048c2ea26b9ca7cd907e1b09ffda3a32000352ee6dcb9a5c0d2ab32b791a20f2bb5eb521802da5a1de6621e25e53871831748aa392ac1622aa92c5899e2e7b675a80425359d71a3cb533251c16f0f8ea720ee648b8d8437fa28db1d1fe31c0b2cc525c2cc524baaeda5dc2a866463e672a9c3782d8d685ea8b556d8dfa3dea08b044c619e58000cba3df76eeb17c33169ccd5c0452ada26390ba3ee8261e1002c1851261dbde9026341d18a9a1428213fd949c9e28dd0c6cdeeecfe5e31dc423e63a22456b06c9e19b0740d355e72ccd2f9e4744e20fc298c72cd274cd71bce55cb303896165053a0d5677663327297002d8a7ca7e46c3e07580087aaf34f6308b2dfd5e9cbc841a1695a67861eda0d894d93456623f12c8bc4ea2d1e7c6753137fb7131163b4beadc2b799c4da89be8de1ca67063c78fb1749de1390737c8e54d64879ec1c57da7030a27a2a01889bca4ff9fcbc80831e37897268377dd33af388cce24f7838c805faeed7a324ec884aa8e1897d45a06762a7dbf15d4625723d303b3cd08b212e12911342ca43f7fc5b6fdeecb13905b2d01828300e1b69ab34a3f8627df0f9bc89a5a3cb8b721d4221c3863c27427b31814be8f0a880b7556f7ad096716a49b4af4b3f5e044153218322c4bf1609e78c3178c47890fae0f516c7c48d2f44cc104039bf32f95e98226b93feee8d52ddae4e604bb2786d4cc457a51abd85c3f75a703071751b32c6f580bf8745af6f2bf36b31f0196dd1a6d6aef9cb223e1ca25d220b207bf0d14afe3ec1df918ae7d51f6ac585b1e68992a79746acde32fd9634ece11320f155fb97c85390388bab80c052bb745b008c6a2fd007e12e069ff0737e3488b02ed8ba8aef1405b645c0c77147aeb9ecb3c7b77bf4a50b71aa60c7818f30005a03cdc6accd54fed3efdc0919aa7f3b84c08cb8dcc4db0359b948b0ff02b493cefc6d5abd40edfed04511381a83d60c0843a237b657dc44a47d86bbc0a55b5e13c966ef7db5523c52f5fa43a76aba85f59dd1500d0791f6f0d72ecfab6509b6bff713fdcef1d678dfd0bf17adc7ea2c46cb654ccac154a9f55f4f1be9fb6a870b7c074adcb36ca48d61e994704876337593e66e0416259eccddb7c96fc9a39871346cf121856451be0604e93f9205ad4da18cbfbb95058e8c421d1b0b37de860bea7d1ec1d7d3c6c73f2004e8df3286252e61f2455e566b7dab40691ae3fe0e8283fe436e24af60a5912b07410fcbf65cf0ed5648f4ee7a2d0b1c3c68a0810e869d22d4814206670f44918635006cb0017d80321979d8848aaf96d9233c7abd4f21f60be4ca2742e0869a3af6fea4866126149eb8eff6f9d0706b042b64005299d9f81ee90e134b440e1ea8c2c546183d04b4becd23b10226d39dadd12f66df2bf82ef3b1f4b1d6667a51f29c8464e08db12f06de4bc9b422689edddfc23c6c6858a331b54014be0f92bbe40fce8b5acd12de6738c56f05762592ac4a34d4c80e061ed1925610002135206df80d6eadb1436b0bdd054a48b68fe16e4b0f15edc4187c7fb4dd0c5ad8e1df2ea4d01cc807118bd3d280a7a4ee2dcac19d3103499ec37ca38d45fda1c894f2433a468a91cc9f684ba61582b0099100f9326c193286cedda0c39dbd1c4ac8ffb78b7ca32bca11a0070a7332e712bdbe916e8bfb88a382d44d1466c1e238c773df0c80ca1d61a8410e6561f7d855df548669f1fc04a477be6502cb9426f96044290f187b7d737170cc86a8107d13cfbfd46d22aa80c24d734ff9c034ba2e2d6f82584533d5290ee4cdd45918dee967da1c89ff6efee61589342aba078c82e1c99f72fdb4128e38debdb98f659e4e7707f47e40fe5be35ae30ee1d4b5d9ba1f871314b63175900cf3908cccaee3d45548b10f4414f5885b2afa579a6af87b75f64cd8fe2657227adc51297fd89af2d55dec13917e495af7371f167c87cfa8ab64d9a5e8ee01028085583ee3e2866054dd1102d526383947c91c7abca36fb9f96ad9576d0515624a123f3a866c8d860e67baa9e72dddc669ad98a8e6037bddbe11c060bf2846aa7212bf28cbe86f23b09194c8170c747f5dd4de95c6e26e39670fca037a5c3832580c097b8be67374a9d590b47103858711531fec86345dc8665b6d94329acfba30ccd298f2e17abdac2c9b81bb3646a8a6d082d340561a705b19cfd9c476f7cb6f0b47f3450197dc7a53d269c2850d5582e5bc893829753a0e47e68535268cb3d90f4d9368696d4797c12f875f0a5b0172b09c2b68966ba209eec8c9c97b60f03496127be3be3ee4a5c557bd58cc5f1cd7ddcadc0b541cd81a95b0c419a458c9be710b94c89de1eaa3e95fb2ca087ebf9357ec2e090261d6003d1bfa2991605945f3631d0c5abf28879493ee7c30b6f30caaf535f9a2bfbd0dbd281ac62ea5e89fd1349f1bf88d4724280ac3a6828386179a6cd842777a97ecff1ed85dea5d42e11dd5774a6e9f624959c76aed79d05b87ae2e85a35b704b2a724b521a5d7823ec9498c42dee4fb465e2c3105e7602f2118d9df21d5a1b9fa6c3a4ebd4e0c49e6bd6bb6d14993008e304d0ab8041768d31f6414f797f78f4008cf646c5c1dfd453d7a8dd5f78485ca9407350eec89e4ed9780f7dedcfd0ea2d5eeeb1f401cbdee513ecc0b1d94d9196de2dd8d2f2a688d9df830fde58a2d1d6d4bee3c6c1312894ce184b9ae938b523a32ccc43b0d47a62825dacb1b9e2602d89d5e7b3a4c9dbcee1d7f1ce26647a08bbda6d7d72f67839f7ebc354c114d52c51e482fb052319658ae9fcfd4d2e5f0385a39e7eb6474382bb4214afdec851bdc1ab7972542896d717a1d9a824e2a3a43392f9ef4cfd0773b245d5fb98880632bd7a67577bd4628a39d035dbe4388c707a7fe3bff0165a4f9ddf75a2a53024626a6f2bb85da0c5b2739a2763768a023ae113b312c33e9050bdf8b56a675c13ca002d799b25f9c62d4f04d16197df1d88821c77d3c276728dec7cd826471da7098df8a7abf9ce41663844254c58870c024343313ffb139c74f7618f6a4488115090e83486a7a48d3af298a9c1855354417ae38e480810e225f7665a2d521e986f862111fd64e047fae4aa008ffd01b04b1af9660fe629067a563d699f11b0ac631956dff5ec179cef9222eb57935a9e48dfd59c950e9453387e093ec65691170a12347f3bd2ef72180148dbd1b7b2350dd7e80d16474a900cd1cc10bffde17fba5157c179f4a461aef8eadda1d7ae521f4820a9c5ce7549377ab671f44c1c44e05b790e4ae9ee18a433599923920d1977b7ec4c28930a192b344d1e63a924bcedbdb622cd8aa17be3d0db3ca985edb7508c3e96a16c14dfd53a6b8888764a1b59b7d8e48797c82435aa572680bcf01cedd6026dd04f15092f2cf721a883398dedf64af0b5146a064c94c98050e60861efb270ef7f3ccc674e1ca65d6ecbc4a22bb83482bce50392394a8436aa41b6266bc435c41324a992042b5075a77743eaed8433d51f13609b2dd760108f7404eb22533ea71ab82fb7d8670b365cb20b0e2b1d196326234f2139e59b41ef12b363caad24be72157805136e4a566cf4d1bdd8d7bebf08700f2d5f98eb93279d58b03d5bd3ccee0ca4085c960d643d69ff3b96464f2976819534319a3ce1f9543e0fc9f879296bbf3fae6a5c78a1f9bb0e030d67a43763b81d7a97bf4114a5ab662686bf2a14d74d4ffb1d0f3fa19f5faa7d6a7e248d6ee39242d9e053887fcf3fab27acdcda27cedfd3546538b81fc3fcf641cb5775673ae1e59e044bc635ab77d8f84636fad85e209589d0e94675ff6ec50eca5bb228f922ad27a7ac97424ad21fea3be016d33ee1dd8db9f5968717eaa9012f113c3bd7ee2b34dd9190b90fb0a68b966df12219a66cf89a1107271215cedb30e1b9dc658cebcdf475509cd0dd81e20078178f6664ee0d5c21f4045dd3b26a8079616f7f613cebee58f3e2dbf7013e0b18b79fed99f9c541e9d56d8ab2b079a49e5572bef54d91d8ba75efbc4342b1c3e41963290d2ecb6b6d2ccaf9627131311888db5e10ddb59833fd4e60a970121ff563bc33fd6b9a919b4747008531965995ae033df836525ed0e2f01cef5bd9b819c81dac8eac8276a0c0d3955fa4417f394a8d4b4ffce88daec512ef6580b1103074871df0714689c0a35e0949419917e82e6c70c16e2ec567a4a7d6da4e2315f308efd59af2625ac84fadb6bad5d87f4a689c5289421c064d9ab53ca8d876bdf9d48d853719ca4170d05cea654735f51b7c46f00b0f3a63d3a79ab7e4873e4b92533c8615e275dc4d7eb6beb9619a99add6aa24b0d596abbc35037bd8bde4e1f598e3a93d97ad1c9369fee4bd5a3fba6041f17d859fc22d1095ad982f3e46e0539a7226666612bedf6ad1eb8b62deb3232d8b3b41e9ac4f5a04691e1ad294aa99b2cd223f8ad2de9e8a2ffbc99778c8635d3f1e88bb6085583eb5cc45ee0a503712f921d0fa6b86f56314c3e34c7ccef33cdd42d7fee162d09f548b7516872a96ebd8594b88e7db5c6c1f7a8a52393a3b34ed634859c2ba1dca91ae4770a963fb0931fd24ef77397e784c9fe4b3a0141f120e6116d1c0e704ca54bf6579e5a4ae2b615079432dbe1ed3b71e551b7ae00e575644aad5de00cbe31081ebd551cbb116d44d57c69f9bfc179f455ec3b2c7a848990d3bed0cabf948d7e000a25f055a6a531b12f0417300c160a04dca1fd8d17b0548d70dd79969bed7fc32b1f433fbfca7edb1749f1d2538e2a098a6d21c4fd6c37708da2c47f9c9c930dce62ed9570210fd0d36494a97d8f819c4b3efedf3c3a77e3f63d2074b1dec849421be5895314339c5298d138fdc08f8baa880f3dd7e9970c08e827865c953e8eb08ce82e5b766d2a8fc3fdffc7fff026119442dd69c6df21b3838ae00bc63697d7090d4d8b23fb3446faf8d1cbfdeecf2b0a6d1726b44eb15ce867743229aed22de516d5f1dbcc5199d37317a2226ef615ccd639610c487db3e00a374df0bd2f91c360278f0b8d1e062565551889f8e278649342d92af85b13d2db042b9264d90ea5497c180b5ca21f908a141a5f6065c98ac61174d65d417ba03c17c98c81380ade4c654fdef27e439877ceb88b8c0a203f1d16be2695307defa998f1af3962783136f1b724d01342995712cf67af351f852ecff4aa8043d60fa47e26e0a88277e7e583634d63734991270d9d470ecbef6be95cfe7fee113b89acb232bbc1c03f6d630d169c59ec2800cd9e66013b8d38e3ad670649f80f4753ca71e18900cd8a10b4dc9681c4d8ad2572b5e21c6c106a31debcc5a73679e2e2ba84ebef3d23d917783f2c6b28a24aeac30edf14cb834c6dcb3a84bab330a204e53713de7116778400ab4a6c69cddd434d02eaf0a7495e06050efe9d605c3dd107f89a90a8f7d8936a14a89062b90d8b33073aa9934758aa49f4753ae1bb3a0ea03d7597bfcb37f50a4bfaaa0bc0b6aedec06c511c36d9c37b14299fd26923f575374c5ee216686bd7d0267272ecc8e6625d8f79a16d2ab02a1647e67c643522360b4d271b3de41ad0ffd2b09cd811da436480b969aacdef1dafcd7037f38df3020439c1be591adf74f03de3e534f335a1c3d400f29649cc2dffa054f7faf1f1fb5e8c843dec0ec2536f8e8a66e82a0473fd5adf1c9d4aa33218ca4a7cb8df158c78875c2fcc6f0c93fe09b11658754621dbc39a31a56d51aab6d090593692c7f6e52c0dc1cf847140bdf59c71a7401900dd38f0b4422835bf9178237a7cde98a3fbfda545ae4669a4a3b49bc1f98fa8610b2203604ad9a046fd3c8bc1e7bd74a8d31aca725a1fbd1d20c70ac31693530628770d0492d5fef5fda065a180fa9d39d96114dae6e220abbc11c3510f7344b003c7ecb6b45909cc126e13b22095d522bf834e9f165dd5ba2b54040ff2080ab2f5944f3a4d847480e97f3487f3fad177c98335cc1f2a94b5a1709412c63371905f6593703f360596d1e8850718783d6c1474b8286b6549ca2bbaafd1522c16d04763941b569732384e18a4e60af684043bdccb618141a26cd578fbe82ea7b82792cb66e89d0bcf8039c3fa1a418580218ea28efc6b6a04834e8350dbc8fb497254d771a0adfc2e8e215383ae7518a92daa4b53549d5271ab8aa555ab3a20e1110aa56caaf3750617fc0d9e686d22e3a5cca48087c95f847c2be387c2c9ffec169ec0e0dcc3140c1d8245b496a7c594608326bb2661afbe29cd95cbc05398f6ac3c2934245403051916db4ee084be115671beff720feb67f8b3a2f2ee84f1c30541977003cf0560e864f324e65d776efb5f8171855cf21396811481c934bec626f8c048c876b8ebfb84d414e5a7e2d0aa06a97046c30b6292633b0cdc3547e533a6ddc74d4eb0c1e657ab273ee65d1842a1ff5f729e225430459775d2007ec7b350780a2caa396d3a40f842ed74fc98ddfb81d58d8cf8279be14edc2f9ad65edbe586b3aa8044ecc7fc9809ba38fb52b9f580b194e7994beab6b482b5c77353d2a39802faa78c4411f13821fa7b5e617c8ea3c44820c111cb50da356533295cff9e2288ac5c7f337006994b62d219518d90f66be70c1f7c7753b28f48dad92ac7c8b1483370e400e24c6cc5f0f9679a7b26cd8fb2eeb94371f7694f1d0ea277c06ac85ffd8bfdb61548092ebe6215b1c84260ad36ec2e5be54434bb505ef23ca37e82ec81f03fcc593043de66cf3ca70689e1b6585c229e3091c00dc21aaf481a017ccc19d3cc59e93ea23f2e7c09777a55404284f9120b4772738bcfdc71cf369fb6d00277db3bba9698f86796c9a6e386756849754d467cfc94f4d329a564f52ae68aee921bb6ad902d73de1a98d9e2564a7b49a5cce623f095dbea0d82603d124ced80d2fc9f01a9b26bb1da7683ed2f2d928c90a3a0604d146ef3aed35aa94beef71f8816e1eb89b7d959a2acc2f4447fe8faeb46248e534be38a65947c1a219e597513acb29a310fc4133fcdef82ba9d593931e184c0e0c28b9dd7ec858ac61376e8120bc3954070e8c04b2f38addeda3eaa1898d47c3c4773bfe6f19692b778e53248e18a99e2a1bb089fde03948cb5d2701a4b047cff272a4988a79996cb5094d5bb09aecec9eb68e9169ec3f9a9b4be03e5fb3d8e1a61a67d0f616cb1fdc19f1fa5fb474b6f9ea7c833be2963402112c4daaf504058ac9bb129c8045374c2154f8bb6b433fff0af0ce3ef5f7360bc38cc8f895deaf0d6a3337cb47e18c2cf25ae98093d598022f32d4bc995511d4b17ddf3dbc7c6b24d7ae5c8ea77e4d7bd2d0cb4a14d7a8175ae18088a6f5412c5ba51f79690d3e783ef91218db4a9147c1a6bab441dba36458d49dc0a724eb554eb424d48b6f6c85259928c1c7fbc453761391e1e36627a3af4947f67de3f080ae512708e75282548e1fcb517f2ce097e8e3b97fbbadd3029f1130de6355f003fafa36385252f88d4f48a2b9e9cedbd7d13c6a42ec835a4784eadc57c10cd5af97d8d499223ba0eaa0f6dc0bce20318aa0e2935460494af8312cb1f5937a7c6392f69d676cb245c6cb64a86e8d36b1cc775d6352ec7e4428d220fe0a61c7e5eab566b51901707d161df37e78c9c3cfebe6c5eaf62abb9f74e5bcb445049b67f6049fcd0e14728a37e3e64e85e07cc405c4f7887a2610341d94cc7241bb6c53376c231458b44631401324f95761cf4d570f34b84b8deeeda14b6b93625253e7c8f7c1042e25b03db9f4f9fe838cb0a899204abab95aa2459bd72e3da3a3f27a129f70f86c78c3a08accb8e68c6ab6679f860eff4f0e0cf34399793e8edac8f02cfacb7b4f04cfce85643bc9b7ef5581f78110191997aee6fc3f67c6c6cc93f44276e0b0654142eec8eb683652bd3958cfe6a1e092102b54d6d94d19cb14f838b4618a26887f848b49535e09db87b3e3903c5f06429c0d1a79dc312b11dde553f9ea8b95cad1ac57fe1ca26d57f88285227d6d8d2999b81de597a416866b1ece30bcacddd8a328dee9ead384758cbb1bd59243100ac2cebefe5142226cf88cf76c83530970022ab4d7001c8e140bf4b3f8fbe075bcf86fafab0eb7778faad00d1b83757261a0d1d280fa41aeda94e9f6a21845edb8981331b78fe43f01065f166f1efdde067638a2f968bf590ff4db0bf8c02cf6b928c29020516b9bac582418a36a83a713d61c385169e6465517f620ec810a9a75c497c26cc039d0e08b1cd71b0a0e5b05414a2ffc2cff6ddf3ab6412625b6b720cdea85bf06606ac31d641889c8787d25852f589373a532c165185c432ce09bdae34429faa21434d64261ee33e0bc63661f6014f9b2315e0b8285db286881726388153f92b66df7a37fbaca1861752157f8dc2c4c0eec0c6b3588159f57c40c62295a8553f5cb3e638814184f71f2c93d145f1600e31519e5df5fbca2a682b44fa0e6c66bc0a3d55847a95b4f972baed6f274507e438423cb3004fdc94591df24ff3b64f2259e111f394ec5c83773a5c0c08a72539d8c55bf953baec879f5d1505ba38210a6ab7691a221d9600210525fcde7fe1762547b538f07f82696a2b29fb44e567f13ee0315913069cd553aaa00cc8033e0474b964ec4c5d4a09f42ad242c6d3efd29aa1892afefa5cebc4c34905b83c6f49b150bff8686e85073466310fb077bcf3df87dcbde890aa9fe4e7195bcb47d98283ccb5d21bec2486ccda737686fbb82e4711eb83357876f00bf305208d1bd738fbfc5ecb69d2bc24cf3ae63d3289cf9148da4b35173001133eb3abd09c4723da92d7d56a69da74e28d2d730f43e4127ca8cfede6ff5bccf2da4c7d7e7027993ef306dcad0254bbbb1ed1ddcb7070ea76cad1617e9bf8ca60f2d36f0278ef70a139136027f193c6915eba676d2a4d2eb645fc3698dcc5aef9848490bcb2005fbdf1f20a136aa7f8e9d66fe726e30fa859d64e1ac1bf17ca7bfec304a08c73ce9979818f3a05a03c5ee5ccd2d3510f07dbf03869ccbf7a66b582810ff62de2e995726d0b1ecf34868af9987c0f74ee20da8ff7eca2e09b78347292c6938c85afabc0ecb0adebaf4e312f97dd0d32c9776de748028bd59f1d64c3e1d41da8e963a80500e4c8f815cccb42f48f16959d3e9496ee1a62152c8fc9ddf6287880f763074e9d31a0a1944d3ca8eff7dc7bd0290f63ed1ec67199c8985e674e9be914ee6f74e81a7c8aaad1db26bce1a2a5ebf654c05342d746260cba5115eb75e178c9233e08c65d509c4bfd8aefc9846419557cb72b371eb6d951ca4b713f4fae7dcdc93610d0eb7784090bb5e728cbcc06f69f1c4c15b08ac46d9a42493b58e8395eb5a4f20fb7f697cbe692aa2c2ece8f7d9ff825ab621d7366599de34faed51afc70ed2b41cab87304ee5e1713c083f09866a927af0d1e5e46aba5a2494786fb21c4e51de8d9b6fab7f7d42bc80b0afc563fffb6af93c43b18286b6901d79f27842621e49664fff1c2cc0389d8427bfc4ad9b4a436dc1a9a6b98cb3aea9f6cfeb3ed7db721e35d865db974a7375eb516f5e95efee097e406920abfe065485c1332d09d4674cc4abbdb5dfd0a0ee875ced0cd385818bc29ce7e402f1286f4aec9e9028b3ec7da2ff2806e237582deac0ef9069c21a47bc2e75b2d9ce83dc61fb14104af0b3b20ea203592c98b7708c4da35ce9f2f64d80c841fc50d59509b0fecf507bb693dffefdb60515e905a0fa9441b6539352355a2f8a069c05ce7aa79ee776ad643f3009faa37cb81f7ecd8c88680e644f079a9607b1de5b8f8b0ee4373b723a354a81fb21d744de1bb47a79feed16d4a46ef7cef174726870ab31ce42f4d1f8f397dde7c1d18b53b3d152b72bdb67c2bb87648a535c4a01822d54002903e97908528ee5f55fffa077d482dbe1e5ee8328174dc6ad3775e34c0d63c597d6876710064d6caa358a16b996fa8cfd1524c55d4a0b23933289527554e13a146bcfbbfd5c998af9a1b03fa608ccf4384f49a77d7cf033a15ee64d9af06df6f079db4c498f194b7e1f3177596fd9c93f3c041a5879e7fc9410e321dee3b44ba4f617d17083f7532d3510b5bc2a38f1e14c4cad00da4d06c57c3676ca063cebc7f7982dacfe6ebfda90c4fa5e923c7ff8b6c66f9b8e17b1d041eb0ce6f08b5d7c32d21549d23f0e948e02bcb63b3cc365887dc22c9bf81dc9a9286a7a4e37d1e292c7d9646f7f6bb012941485c869710f3d802c76421f20aadf59f2fbc3ccf3bdc1188ee9f47a909eabfe54d9e3619336c4b1d5e0fe6b32babc5093aceb8de90742a874c9d25c6081756ce80ca90973de6172419fe8c970f24baf6ed393ddfeed37357869b23ba9bb84c7fb9989a75c4adc40b48f04c68664a3b14fed8aed5a6a70cd98f8cc545fab6a2ec008368201617d8829adaa51a5b97c101a86ddbae476d41cfa2d1b66195af512cc52814fcf89e93c91b6c86ed25d2037be5a3a5a0eee926625a9038f900c88c6188b5cc3ad27d8e249af2014363b579adb6636b8f8ddd0a39419c3c2d077d3cf18d0d1da452bff13c5bffc63e0306351d8d293452df970a218a7cbcd51aac0ef920f0aeb88a304ed8ca4e75cdabb978d4e796368fdab037402c1d0ff01bc567564e4461eb69d40563b0b7951ca4a91e9b5ebfe93255288ceb18c96229ffa66e8cd7eca2778951d5aa4bd55a751fc77cae2ce1dfa8cf00f913969fb518b2dca8aaad4ca4559c781c9def44bca05a9bef06aaac8cd6f16058fe8a11dd728847b1e49ecd107910b709b66c14b541be76379d65293b7398153012602e2cf1dcbc2e8efbb5ffe0b56cbeea2770c382714c1af65ef388ab207ecbc12c9352e0fa8a69ae8c2eeef360c6a01da64634bd705a0fafceafe11ea1a3f9065be26831954cfa3541fb8b487623f19e21847dcc1c910a68551e0f7454f9d6009cbb577760e4c66f8998e2fdf67963080e3430b6dd7373492b2c0be62b1e30b7532ed9d8d690269b3fb00d3f64203806ab681b3e89ec4a3b0a348a78624dc5ed647d2d98c020ecc549b77efb9df3cfaea8cc049d2a4ed8f991af25df47a650dd2ec8ac961461a3e2eb6d2808e1d93b3751ac5e24f56f41aab55bd4e99588bcd359d538090f68858f4990759c6783667719124f5756c5f65fc59179768eb9a7f8e223940f149bd1348ea384d141a1ea73eb6c07d373b89d53a577ce066be436d2a7a9bcd7ce997b3659b3636549cc4b494c162d95e13b290fa54e35ba899e4483b42a0706487e9781d132a99f33352a7b712b904148ce35ca31460f93dcd40216d06b32a0e6931ecd24e9aa0e01bcb5a1c69a078687e51f909c5021950d1949fa79d5753c497f9798e72f2c83c5ae84b6b50267bf5c7246f94875d778c5eac23a28bd776b4ad4717f16c82c6412fc9635f5474931fea37e2334cf2d1dc2e5d88a9412a009782f906dada84eb85f0325c760b03858f40295e45d3416ddbd49d8d031c48a79d0a4a7cc0c0ea2cfae15726f46fc0e37a6a1a2fee1956e5b82d3102de3caaa20074f837003d028179f5f31536c87c83d5525225ccea11709437ad532e9ad9b71deab5c741b12fe485a22eedadfa2b6d5b8dd65a23800d58d2aa03dee3e307e9a42e8e9c2c8b09ce7662cf248f67b4a9670fc360d35867cddfd4b8f5d917da6559d3023e5a7ff4fe08bd2e36a89443563f81241256cf1eebd2e12024e93110a27cb04f0481f4fd0614a040fbce70ebceb17500dca6ff6e924f1ebf8b032c192f075065b7d6c85c2f889de2ea4ae8ee12b271c6e51a5d6f3de04621c960a1a21871915623710af3e29a648d1a811e0b160bac4e28a94541909b6d4f8270b40508cb90ed149e226be8645f4d371f5d97177f51f54bcba54f281548425273b4641f78fb2b9fa0b288fd2ba1f719b20f324e11460de5b64cdd00a52698d3d178c733cd633aeb28d331a4b8b08ae7ba1e3f914f8aef6053e0c876d7791e5013f3e219f90f927f51b1c49cbe0dda0600f752df54020b9895f49276755b492ecde68e6f5e21b66a12ee7a62a18ecbc072eda479624edbc5e54e1c804f79fabbe6cfafba7d1db0f7f195561f2b309eeedabcf7346d3f3d8dd261e406828b562fb136f59dd465b60c6ab27a5bb44cd26bf3ceb3dd716820b75a1d399ab1fef699228929950460ae8d7bbd6939b5430c6dd7817e518095018d28e6c41df0bb8239124ba30375ee40624f62e26ff92de570ff8b648d77b40f9a968470021d26567a0be373401f4476aaf8113ec7770c6a1faddb4befdac21998ae893a4f9f9cf35af453c11d9831662169b87564149282d876c088be4c5ffe6c6d1615229455d0c7b90be70b52b3b905d370a71dac74f3fb3d8cb2d2089bcb4a96c14e702579f710b7df4a688ed43312d23cfd6e75ff9ebb759db4b2f5694e0f020b8ce0015d95c692c95626728b193db44cbf229a009348c56d45a25fcbafc772368b6093fccab2e81d36a2b70f5383eb8d38a2c107ec0cd716ad9ac0a2f1d512c4a63c7a8a0ca4c42d6d99185b529459cb811a40a09ab75c317e15a287bf39565ab91b1d4528b707ea1f4671ed2e22f8c5b0cfe9b891caa19206209f7fd21d5eff320fbee26d48c289bdf8189f504c67aa881c7ce2060922eb5aaee31bdf68560cc4e0698491b07fd103eda705fc45eb54b67a1d6c6fdc69fb92fdd453ca51f00a1bb99eb4b8c1c5520359d744b25f6a1db452014b7fbaa99800db1d604141adbb8c1624e1e0e8652136f1c436918a89e8b4d190f5d4f34301031fc639dceab95ad06e831e29b8c970d0bed0b7b681c3e66fd53eeaec8790345afca6cf7c9f8631d58f24472790b96d46ca4aa5360f11a1971148cc2ba8c6de710b89ffa3cfdb14ee05679a638d8c1a0242b9317c044f8039f5703991afe626d4602fa05bacf48eba2723ac0021db269c411295b646b14c30eedd3e9885a0a4ee5f7a73369da56b50753a1807f3edd6299c26cd59175a03bb927ada988bdd262c701d9478c2e9b51a3c5280ab07d3127f593fb744faccc6d7903ba83792e8aa843ce56dd5138124a0135315840f07e313291e04f4ad8e7be20becf94b826bc4fa6a60b1ad729cdd4a6cd138a92f9db10e1725c0c473b446868e16f505558976c8772cb348f199877267907a1421d30337c08806b6968d0e31c012a88fac27042b6371efbf321eab73b6bc0591f85f56b746c40fc88c757fd8910d9957d75b308f0410312bb4ae9bbb86be5f0b7e3f671efd177716993cbd84f62fa3757be34aee6351935c73071a034f274c9b65ea03f7534db6e80da4172cce31f723ed09ff1afa7db86df4904e4472e71ba0953679d7dbde8076df20261aaea323d77482f95cf4594b3654870eb365e2b630fda5ab94439334903973e2056a71848086d60d5f8fd51314e7efcfcb0f437b4f83c8210095b4a4bcf5660cde613ba8299cf61a37a124504b1ea93aa0bbdcdf065132048dca2f97fee104c6eb55e48f811a9670a929223a86e5485a78097d0f005fab1696f9bb8025b1c99acb0afd325ee1cdb2cba43af9e13dca9f9523e41ce2956d5b0a1dbc0fcc3f392e52f2e168968d1d48c0e2327eed5e79f4000c52e0c152a8d9c3cc528c985e1cf05ad64ca9b6617e7f1cc0e41547d002f6278c277757eb8377499c74795c7443ed3bdbec9d21176c9313c8cfc379a192d107faead6cd9892d52f634665ba042755a6afd463b9a787d8011c3f8f7d9763d50dce19cf2a14c2bb4df7befd9f62cb3632b67b45926a20a00c703cc15db0a89994cdd100ff2dbf24bfa926c446eb5f108c70622b2c9bdb793197eb260c0c42a4aaca2e566e2dc22dbc58c93e7e735fb7077f083340ff7a005eaf4bd12eba55f469ca05010ceb5ea4f8ebcee6ddc9706bf817c2ad69ef07acc4701a5a33fb8d5e1098bd9f19b5a9bde4139481c0793ea52e3ec9c80cd707d1f30f95f126fc750a703621d95b4c9ddb38a9b849a0617af612de128be0da0d03e8270f4c873cb3b812dcaa37aa9c55286f7e88a0879658ebe1e146f710e53946a13db554943fe87b5b9cef1bd2375f88bd8ea13f5e5c4a7deb17ad394d0dde2253c29314f7afe605a1784d6e823c3b54113bb232df083cced00e6248628fb02a44cdd8481fbc81e6f35f61dea83c700c3ed44c1907766bc7da69a733676ea3daa865e117abfd3d0bde1860956a91234308a3ec07fc57277c4dc9ee1ca6f7d145e01253b900cbffb58e44f6f4d849b34bd7f26d992e7f4d54200a1ac00d146b8d88958f5be3ef04830ba1039feb494b776c683c94b8e941cd7380b48a0ca578fecd78c2ec03d9bd936273940c0cffd1cc1eb4110d0498be2ce7636316e823f9e82e1cdc85dde869f5dae5afc1650d007e25f0c7ace0ecf4eda320907a281ce99cd1410d9036ffbda4912fb4c1953f3d7b95863730e7b95becd7695cc690d69f81c3173d68fa2a9661d2a53450a1301292cb87ec8771149df184c2d1281e8237953f3779c76b6530f23e2e96b238d1609bdbca0ce6b8804e05c6b77d007fa04cf822330a29bd18b216bc25572f0873f68103e1edcfee78c386b87623fcbd3059ed27cb0a6f508e55dd34aa2342c0168459d2970b56794d60bb59e8c0c52a5fb0fdba2aef525a33bcd83123cae3115227114e5aa17c850c76896e3f2cc9aea58add955d5eb66e4243d928967a0d7d9049bb3bbc454c530d6208bd78a59ab2cd321c0869a1f83336247e71d50e4c10a141dbb4345fc356a4aaa30568596ceb1f74a74406994a18b34ba3149358198efef57930f46c131702262bb952e01235452a01a0ab1f9616e309b68e4e13c54fd5a130d857ca5d9b9b9f85a07d7610e4b5c583616f773c12c8a45362032d502e941f22366283593345e60c984aa327c30aba14868c2d59d5be6dd216463e4eaf6fc3b98b1ad44c4a5461df1fa16287834f971b070d2ec83cb4b2dd3289db5cd574acf6f7f92b67221943488f3d5d3a0b58c620feec86320f9b1f68413ca2abd10cc3d7e3787c616fe6291ceaf3742c1da788e744245ec8c081be6cfa3f823acd3d79d82aad3d2a242839bebe4c3e3ddbbdb8335c3abf0e9793dbfeaf901c1cb76a955582669d9ebf8595dd57a0e450e94a993ca5eaa38a697081818f37c65d189477cb035c938869d9643663d1d1857c9147ef691431e4830d81911408bdafb11733ae609e19e36602077a48d4352906c3c42bd6eac32cbb9e007a365d677c2d0df75e9a7d20229c96ff58e5b1dd381c12e96fac11f73102aa7d34600c64283f637a2a058d41fc8a5728d79742aadba7d7ddd3a1203bc2c647ec66a4502ac19cc8b8b2d8f45fd445d2e96c9901252e9b3bcc140eb1c82663e5175b12581dc6ea0a07ddf8418f699010c56b08148a99412b742a6b3c7f00c61f6f82979ef22af187e6b7dbec4014449ebc5fa7085b9dc50d2f799c6a31772b265dbb201dfd4ce2d13b730fdfd54ef620607fc912b00292703c0e245e0c0bc4567721111a5e3af25e8d8052437bd17898a94042a01f5a2f26fc2b5b9cea740a1924b381848fa23a1dcb98b9d7008320c56d4fc24038c0470398639ce696f67e44d7cbaf5688b29f3009ee053b824cf5ba73f8471a11b5e4ce79ec5a33904faf440439f53837bf795c45266e0306696a8b7be2392424d88a590794d8502ce1b8fcd58b1236ec17f647d8248eb0184bb5701bb0d7858183cfced94aff7fe1f0a31d06542aad685009db668eaf284db969e7f36be0f16478099b096a566fe3202703c3523634b626b85417f713b9c4ccbe9e0e9fb145ea0b9d475935b1ae83f59f42507d6bd3c1244d1d6e1f607f13a5a1039d29449a8d2c4ab9702afa0c8479f3010c0a4dde1a1411d9d548f007d35e8941ce2561292c3067646761bc80330c7ba1cab0856deebb299ef29b23e9ac9a1ab369a3219b52f7f88b4bc59f1de35dc1e7b83cea3c6df044966a9ec793bf7805c8d1e751f4615e78eb2cd3176e00fb1fe6a7e42f64af33caae4303420a3d98849eaa198845b0499b750e20d2e5268d34d9d61f3135b0e729be68f6e2af27fe86a8d2f619e94f768f8ea9eff12d64d7cfdbf29e2b8ece7be072f30fa907e854d3ae592faf3fa198101dfae76e0ef5837715f9d1d23d99c3e0594bfdf4d95196d1cae5ee0cc92d75e85691860797f0e2a7b5fa4ea80a6ea5a28e4d774478f9cce0c810e7dd1d5bb95e460d502beef5db81e698ce0430632b549531b1e1d1b199ceb1328be9add25207f80a558e1cc506c7f3ec97f7b04390723218e212f671124938a535eaeb6fc476822f2ce8dd6cda931003c0f7c20747c5f7a1466ea48b4c0ebd3bbdd008917128aa43edc5e0f7e2e72eae0427ece78124a2a32dd2243872a6a41c47c8c69c8be26716f1467c124295f0b05c70bbf36e242e2a0ab6bbd14110feb717b5e33124f92c036ea8637e450ce295008044d015a2175246e2541d1a383ab069b0c4fbe5933bd612fa231342231c6c9c297afb1a2b40691b1f157d12f96166954d862430d05be93b97947684d083f0cd820aadb2ed1dafde63e963b34d2a7bf30d05532cd28c07094db9b035c9b1df901a9823261db26d75e6db798d26a8891cd4d3a8fd62a3123a988d95552bd29f06ed4055204e2631be8150a4fbb752adc12b662d9504fcca40c282d45f1d49de98e921ca26acc755dade5038d777bd8d3cec2fe963221c07b554c745638c2b25ae33ac642afe25e7b30e4618645b8872a968a4b90ec9a1a90a39c4853f066484fb9a1421adb994155c376e7e734ddc970c8e8755df2b3b7ecad56f3cf038f6d674041888bc8fdc3eb35ce46baed966ee4b7de4462cc64fb7726fe00a96d68af9df26f5d8ce376e25e65e246fbcec4c39bb5703c6f6bbd05814d15461b98c8b26f46e357a2a569b4f258f8608d2f3cccb43ab412bea7ea37dfdc89a29ff0fff0646f5039d829c1f19e38393e564838038116f75a90371f4de187cdd465b4c359326d2647e16c1bd09e0fec0d8c8b270595e175f78610438eb3539d2cd25e4879ee21ee278764c103169dab0536f5f49a459d1274d91b74d4278850101e2f7bf92eec4fdb103759ff7398e5f021af93f7e0b58a2418e6dc5d31283d11d4cacbe8172313657ddead44e4b06b5c04d58cac301031bef62281f06f361ab93c3537db4f13059cfff9b27cbc75b1d73a5b0830634340cf075bdfbb9e7103fbfdf1a5d371e86dfc59062a2fc5a281a4a327f486dcbeabd3da3e1d03d772a52ff46dc8cbdbc6865eef3dbec3c336fdf31a5735da6d04e55598beb5e22bc1c8168ab16b6310746dc67fbf8a1aaafdb9119c05e308f08db22bde7882cf039620f44d84fb9bfecc2c9f3cb1f4004d518839d22c7310931e60793e1e298e50568ebf27a648a116c9afc296bd36006142064ffcdbfcd1652eac8eb8e374fafdb7ff736ec232a303e75d80c785f3daefb13c58c67d8c3774a94c63aa8f6410b2070a5575de7ae9e1cd2c3e6c6669599d72caa5516c81d543bf1ef0ef2f4bcb54987d1d4e42638608fdce5d926670ea817d02bf0406a339de5e8d662d40aa60f64a695e7d0e188b6cfaaa54e021bd9971b00ae7b57a586f3e187dbdcd1942d7b851b654891418029f6e537c14f6dc26d3c8dfc57128ca11e6705c17a8b65523bbd6af25ce7d419aa81937d59edec91c68398d7e1dc04bbf8857a3f22fbed934d85ef8096385ce92c4e6174547943a305bbafeced79b1ef878772f53ac28bd143be32729423a649d7bb8875c58d512f3e78cc100babd3df77c0718406d50abefd824f2a60120ec4168d10e72a7396e01f224f9ac4e9a59ebb9b0ea9bd138eb560f5c4e10da3c37e095d0505d4f3209665e2c2c6a1562315beb19e07679fe00fcd9d12c75126182af2cfaee618b08ce8034f3e455b073d7ffa6c2407cad1540946139556135225456a5f767b0de56cfae5a5e43f0bf0782b1264642632b6807c02d2dbcce01ef722a787abbbb550b8b2e70fe5cc051164d3ec8fbeaf461085b3b3753032856d56e2315bc66f79291a71ce9f99d574550d3d0efa209d89146d01322ff343d01433a493990f6c6670fbb9477e832c04aaed38257d787de951835c7fc0a622034197735ae00d112b35ad76b599f12d63153b1a3ed0c23dde9da53c8f977a185b7c7b089f5447244733738b4405bd0de059a8f0e14b03bd80bc656c7a005d377ceb4f83d48e310f017e412493d3b357f6466f90ab6382368df63f965258e61ed22926435d237bee4a4d5abf53af06f755fd993e9face9a313d1ad01956b669387bed06d158f9725e71ab8073b64274aed1a8882e49d1dc3f5232dabe6cbad2a84aaf6bc1084d60143a25a1211eec02d4789425e481b5fa61ab381dc908af6083b6241e52251e94bce95c7b1ba6bd9154d4a5f8e98dd7677f5464dfd4d9e06c25a25c04afe622f6260df8ea9d9a416663fbc906de3dd87d9a491cbbdfeb524e749a66ffad98833bc2ff5dffb4612931cce0f66bcee1313cd9f66bed1f346d76713cb235a8acc78c39bf50638bad33ffdf8b863f645c22706a0fb52bb4c83184ec2b4f7d09269f22387391f731920a1488e07b485d5224fc4b33951d9e2cf6edeea2688e233696a13b25f1dfdde09797157aaf29b595905af0ceaf9057f17941df06831036de1b453567d3f1e5649268489993113ea7550933ab610daf4aeb1a021b81e40e97f6c2b2793d6c4a221acb73bbe8329f13f35cceaef514b64d0121de4d4cc59328b72c0f795c362c2437f892bca179dbd0878022fb55381e641794879fc0d330d37b78b7610e3e67bf2cdf964899991ceb7498ff71c8ae32ddda344dbe294392a6c7d5e24a62198de95517df9a3b34f78b022d1ae0a141e87780af73fe1594e952150dacbb61b70e80f98b4eb9901a2d925b4d56ff25c506c8363f37b47c04c67631b84b6f464c67724099302fc2c95908e4c35610a42ed0b4440d46a8e275ad2a331d8561301162d15ddfec516b89366b2fbb4afd85c52c6cf68f8994980afe0675792becb2871a58648c92bc7fc0799665fe829184a80130a8be5b99a0db4d717a1a3005b9771ca6137cd6adf553422018efe93fbb224aa136b506246383d518bedcfe58ceb4e522a639cab2a6b31d4fc2cf6b4f70f778b8c4d8384ca9c8f7ad85e62ee04c1981c11d8786f7bcd9f1eb444f21aba8b17cfa2139d60d5056f311920bd6059244660d347ca88fc640cd7dc999447a0d82bc1a40f9fc7eadd31e4791837708aed8f3ffbbb49959308e0007c2e1534bbeafa9380ddd0b6355cb13b0957e517ff96c73538b5aec64ecb5a4b00dc073d522bebd64e5f80ac0fe817de350e5458ba5afa7c77157403bbd264609c441e468e7dc891d52045080b3a01952dcec954c41d99845ab3e663e2a7bea05e7353e46cf2ca033593eeb6c92ceba05a7a79328c8352e30193e4569671489dd297cf30424615cea2ae56f695a5ecf0292ecf4c19fdc84ee6f7f9f94bd68476b340a49e25c62b63fd0557651c8c0ade999b0d74989b845a87f29587c6daa1c2b1b7326bbe6d38ebf5e148f6c6cc8b4b10e6d5a875e86ba65682a22918cd9d573339b2444731e3f2f4236c4842d8ad6c03090452aba8cb952ac8a5f53a6c52dee74b2b30370c6bd18f9894dcca91a32238d68799f51caa05291fffb0080d48c5caaf954de6bfc724a50bcb7370a2959c8d9507629cbf5ccf86649fd68404953c4b471ac765f2bd1cddba8bc46a405a0bdb12044faf54435c0360c109628fdc29cb77db55b27ddcdb0011067048c33d2b895a700eb8f28b9228d6374d4566782f032326c508515e10518b990d0b99c5eda76630008950137c8abe8b50aaa79597d61b4cc4903053c053c4128f616e6ea32a33001ce2a313c30b66e42f74e2c8eb9dcead21ade45bc57c1e73a82f2047e90a50dfea63e39d3dc3a0261ae7df424d13cd0bfd9e00f5c5bca091a1c8ef29b953b2c2b69bae04fc9805c30afd2ba8afe094237a2911e4e1d1a50f3f752b7b237c98b5b3ad5bdf7b8bef201f298a5f2c14a8b95041c9c9b56a58422ea127179a60e7f2b07764d6840358c79feecd713615801d1818b04f658eaa34538c87ff6ed9ee71a74b505f32756b30d3511a5ebebe69e6665eeb992e6caa3688d5ee74edc1fc22b823fa8036fe7c2ff442b32e1707c7a5f2d34940e5c437044122e7b2feb19514afba4259aeb4beb20c83a8663eb8cb0e0f783a6e933a8c7feb724ab8aeabe28fcd41fb5eeaba7e3606947ce4dfef858c46f95fbfcd872ed05793afd0297167fd9f3e43266fdcf2dca3145b2931d2a9c4d131ddc7a2fbe3a50eee21c9363beb800e4bdf8d1f8fa0d6964242b00b462d1689232e4412eb4b5b9077f9befb775b4aed752f844b374911557281d9b387542efd6a3c4c2f707f9b779f98fc9aafe371306d3dcfe992a1bc57482c3434080ec6711a043802b12e48e497fdc4f2a3b53b726d9725911b848771613b2a2dfda8b0a2cb0dc5241923aee2e8a72c4345b78bfbec44591b727c27065becf733764d46b4ffb94bd5ef782e2d02a34a98f485aec4452cd13781e711be5b7c4090e3cd3820cc8b2a132cf58a3d66ac420b8f35154704f508c18e324c32b48250f4364ecb56e60b281f3a681cbcf5db401c402b67e045d8690ffc626dc4d73202bcc020c9f5e31f5a1caeadba4de51850af27f8e946353fcbb935a845a7ea69dd27108a07eff1d710764fea0a99deeab27ff8361e502f4f6252e1e173527610250140465b35c4d17bf6b8359e828b19c507346d36fa72aecdd73e013951658d9bef88f3a622890bfc49f11eaf12a328c994c2e7e1dac95769cef2755bd182381ba9683e590bed2ca2267ce76a4052140fa9b80a8b2c54c0cd1fa256c66a770f18f6ad531f007ac2ea3f11363e74651fbf308dcb4de2e41a185a45f7a43fb0d765eec3bc6605468d17d579875a8c891e82ca3a34a0308e0c9224142470d7a02a5944e54401e2c4fb795f870688ead22c706ff5237288c657a3c6b7fa9cfdebc192fcaffd0c184b051c367b373c8a93869ffc4d30eb161799830bd44cccc99cfb6e95fe05253bf55c03fbaf4a56a0eee0d4fed1b1086e43528077cd443df064ae0cea4e2d6ea85cbdfcdff8e20e017ef7d53f454eef8b9cf0a2be32e074af34d4352344667be0a63faac59bd60c99e643a94e91d7c2e128999c2ce5bddb0291fe94b38468ba26ae707c2e6cdca28e6d681265dfb11b13bd29c4628b590084d12c3f8554530244018b15d76b3af759f8d461e978ff8b6217ae5b4aee6f95e429d61f8c33a1bb409eaba329ce4502f9701fa3232a065cd536f66267dfa9ffb3658c7d36df31d131131f0a54c7b6ca13170df9a08c6acc160ab7d7c13b553ce4e0824174c976149b722dfc92323eae478c186aa0b19f3ed50dc29821c682ec5bde50e966a78ba58e940cf2bc042f2124f0fb9b903958928a2ecf66ccf306292b6766a38cfbfd155a6e56eaab07dcbf6cbbf81a4ba9689bbf4f81f16258b3bda9facb5a931e07977a124e7d88b7cb2a6923fea5773d89aab46da3f7e7302c3612f674fcbf56a24e0fdc06c31dea18b203783cb46335f946c708037bbd321df65d570e1d02f92a1279438fc6cf9b1de6df17fb6919b11fadf25751c7cd0af4c0339496eb09f01e59673d6d1cda97876469cf0d6282d40cc39ddcc43559e5cdbea60183db42cbb507521095b58c88b14da7357e6de75cfc011f1ac5a76cc4577f8a50d978c47d54776c0af8772b4a975fd8fe566cef4affb8cb1420e5fddcda240df6b37d519d6a0383d4e4f83345fd2edb80670ba5f7994bb58cac915caf81cb8a68fcb4ccb6f37dc83f7f146c29fc1dd9949abf3184bd4191621ccfa271ae582fdb25c243bb37c0113f0a9e96755aa8f5c3958499bd365fe2fc44b89f01be350caeec5ba9d519dab360bdf90621a8704824fbe99e18149f873bb45b66ee2ea7aac9c3ead9832740fb3a7556251458fcac7408fc2c91e3b998e497dd6bab9260283ea8c20a95df32d0706c43d432ee824086636f677e0a53041f1d9f7eb9d2a3732247efe19c73eb384578513e69d01a792172ad11634d6c25804802e5581ff78bcd6168eadb3db35d91b3e3d68cffed22a3b8c3dbe35a8594ee44fbd82f2bc65d0a43ef41de2d55f3b5c6465b9e987c2d25c2b93788e7a8975e668e40118d445329f062da2f7f40ecb02bd4fb30be88a7ba25f725d7ceb713b59465ca4f1bc3ab02e6b8eafd4775173a54f49cbdc7f8e5c6b661e8d89e3a3a8532e8ac89a1ac0329d38087b1f241fdc34e1b1c03ee859b8bb52a8321c4f88ad21d0c30978360aee80566bedb35f9269cbb3242abd510cbc103bb4e2ae702586ff0d95ca3c8f1ec4cb060f091d6d3db544a07ed4e9cb8e89c21f538f11029493467edca1daf296bb7ae370eb1500fc838843de6e7d4ba7d7bfe41b1968adf367258e8676dc9c7c9dd0f8196004b39862fe03f8ae010e1460dda3c27d369c141372f54ecb69c2a834fa372291c18b17650ddc9701eaede54fe57ddef56215732c74ec685d05222b121723e0672227624a137f0fa882ae327109159e01ff0026ff884d84ede798f1bd9cc507fb9572a0cf6582341898a1473aa6f6c885ab31e967b8a2b3b2d000dd8f8313638a3b2a22bf0da23b9260603b77b5ea71b227408795eeea4240a79cdb7e81161f16807cce262702f882ff4af923e8e91515e0f4fe012858df5dbd362edb5d845f04dce90702a5b064cd4d72f03c72697e435e4351e61e832a7c01c31220d7b0c3f5bafaa3e9e16902a319c9eb8fdc9dab3fe02b04b5132be68bfbd4aba08d449f074c5ebdbd4f111b93fecb7322f76a00dd2cde93d131c6e6c902cc7a81b2804c034b4ab47c1b6d917725701d0a8266bbad334b5bfec3e17a98394c95da2d6225127ab6a2a5f0d4313af4f49c6899f12c2cd06706b5f27f3aeeceaf2d83be12672f9ef452d97149574334cf25a655bce9bc20dfbbfcafbac19124c6820a0988b0978bb13b560bb7eb2debaed73fe67a64cf3f8add0ee1860287acd22a9053380f1a27e98ed3f15906aa86e995b3b7b77e0ec20b2cfe37d4ae495702578c16c2eca773e6ea37d696d982ba954e7715c94148b4c756835ad37f977a5a4e0ff7f91c479c16ec5b3ddd13049daf22d822f40ccaefff85c59b94897a4c9d49036bdd8c47745f5b9ff6c1818d499239f2b666d6c0f08c1b871a37a9d4dc05ddb5c02c9b7d74979aec5d30b33f673853cb0421c455769dd1708b8c113dd8e2a9241f438c13843ff88e32bedb443c542697c8e501a07e6f53d54c1e532a6624a47a349f1560ae0ab5a84f56b2b59f60a4a757c84dbc944dcb8238c566a777fc7a1cf975292be71bbbfffbdea59f2d7d44bcd0359f4eb707bb36672dfe13db28ecedba138f9f5f1f2a916facf988c8cdecba6ae6e71bc3056229e0eab6a22935c33cab2f2e555186c77589c6d0ff0d370447b897ba3514e2e1a6de73257107db3560ccb5d764d85c62299f633c187181ac7a560376929e406b3670ecf23bc027aa19d9ae649d4802ec2345ce19ec805fb694e81af7a28a08731883f6cbe58cd1c8ebe1eab50713172ea16e5f358e7e566780cd1f21ee72767c97145cda76dc144de7e7a97aa148719176a8befb7382093ea706b3de3c0d3f8f0a259f58454380b69594af61c80f1d7efaf9c303e76407a45fddb5a4a4fd10bf0d734f5f2f7ed27515ac58bcb25d8e43e80abaf2a6dc6e6748d1a2001680f140b4cbc5202c94f6ded8b063b2ae8cc08def9e50873c1ca5faa03a525a7e26b739382a09275afe90e51469b2c83565aaacc3e6afcea18a2bcf8cb09aa788ef16ed8316421342212c8a8ff9c0a6ccf48186a99c4054b7dbe62c3993ae672e17e165826327167a70de61b7cb3830da2247a5869e7924548fa9043d78d0a29ab073b7107d6e726b319ca8130f85a3ed7374d06070f1a11d303ae5ac40172022917cd01cd332b5b369d0b0b816bf7b25d6aaec7e2dc7fc2fefa9bf6d7668b3638c905c30f1fa6123f085c1aca9a120585210d5115c337c01ebd9d5a304ad1277b8e22582ac39ed1a0a33de374c8d50221b7b00e3813d0766c24dc579088c2a26b356909f9526f402838d58ec3c1a8c1afda3e32feab3126a3b15f49ff6b2bdc8d9090cec87fb03d027baeb0bd10e9db4f09c010b15a4bcd86e416873358b1a02e089094bfec5fe43c12b85249cae04d5a119891bbfe828ee0897a01721bddf6179ba3f785dd4cba68673560f2438a1405398eed8faddae3a9e0891cfd24fd7c9c8e103c215ef640df50281520a84bcb7101e47dc9c77cd76fc39f3a8fc0dc1131e280d2bd941679f1861fb4d488a40b240b5c565ff4b5a562cb694d81dd5852f43b84c698cf8d505a99a4d9fedf570f4f9f313ca3a9018657a99354b04b9863d9d450f913ea47074d776747f018e91616dbd4371d357f41deb78d61858848cbeabe90d9525531a72c3a0fd2bb5eda44196c71328b7b0e1ba3a09ab1dc45f877c21b52741c246818330c21ec0c4d854a94de70b26bbb030febd82165679770c4dc84a51dcba1971b26076c77e166f29cffe49718474a59dbd3223550ba21bc058b9396f1b43c4b5e8a7e66e8630d90cb4e15b1e4ebbeb7b4920e428c489b52e974a400470d57ac127d96ffe6ced05cd9afacf25d8f5b5ae8ec7a86af610e13d870bde6ce04b498818c6367220c224f26f7c89c19d4a3542ba6ebe16d1704a78d54a3f94fe8d5fd7d6ee3bf0277de2fa881202971f7ebc983e042165093c13b33fc177ff1f2e342beed865d3fb45213afe6e512b0f6a00fa63b4d30da8114edd35fa3afc5ee6f57d0ceee061b7b84f3bf309f929905f77357034fa5a485e922d82b3a41fb07e8768d3fb5456080e71a789f92c3e5d09ecad5ac100e45a00d50b34e95099e0d645ba6d4c3d7105274d76bd93e2e53554c6dbc315b3128fb6d5509610a16332845d4693fcca0b4e3c4162fa54a0ea75dffac6a6fbdf88f9f511e9db8ef76c45bff99fdba918b78ff4f883ddbfa7d6af4998a58bdcf2011e64906cef276bbf47087f81ee8f7245b61a529920c6cfa9102030791df5b834fd6d967445c6240410584fe4b8529829922bcfa1e3794482db3ea9f1124a126de48fc2b5bf0eca9f2bb4f2be2f620ae897933c506d499541248e680a35a2be749274b6e61c22881adc3bb065769842bbb3f8c3bfcff701018b9321e9ccd2043407fae5d6e8e767773c039fb6edf09cf325b9781d6651f4646d75c4d8c1f08863780cc83d4e8dbd8649b88b30b1180e24f56360958ee441805e1727094da27840eb3554d9a2de9b126e038bbd8a29de0cff4d9ae8e3a320a35c6985a5d860941fccec1f12ed22e388b9ee722b88cfba3ba7ba5e9cc8910d989336c267aaaa1e410f097cba54d82a1605bc9a75ebb7a1407717857c00047987af1e88a2d790a25e9c247c34dbc5dee1a0110ea43951ab6cb6e16de596271f7b4789bef0a287512ed49af35c8735e6250e5676392df32bc888c8ff0f2df1c251597819773e0538dd3186b795a241948b545131cb2da966237409a6641feebb40cddf09ac86b58194475c71c1867c5a1bc037c8d46fe6037b4bb371cf81c4b3e46d9e50a116e827ae31fb7039814f2fb5f4fac15569c54cb2d085da65a93c71b1bd0185ecfa98d9f8df7296ce5096e7637b0d75a2f8b2690791d497d4d143d54d7b8daed079b6f6fe31dded77ce17222fc2dec3aa19764945d4ab04b42aae9817042eee4e9a8f44d352ab18d78f35b689c6985970de522730bd7d8ebd69ccaf917e72a42574a98fab265b94619e7d4528bef6dea629f0280ea7069fefe97807fb553062055022e63c980b924fa0765310dcac11c9a82fb09aac968e0887ba084ae5d4e44ec4227720baff3e145f4ffb4c743c41cb10cd686d34e31e5d8542148ba5b5432c734788ab9e817ce05dbaaeb235286951e0052b5907ba2f69b51aca28ec78196572b5ca04e6322b9afe103b88d94eaf2d29f9f85e7d1ae47a88898239d46786882a98a72371f3b116281d33bc93d64b27fcd7c91214718ea0b9aabebbedb551a220fadee79f9ad028495fc865ce1f7139a3a98c4531616c427a2586d573535192d111a7a3e5d076185218fda12fbe415894119678f84a35847d54fdae288456a7f5dab2736380c61c71d773177018d43a56db500c45a5dea7cf848c1552fedc3c33dd2d97d91a1afa0cf047fe763c500dba022238be46525f277c1d05257b0148c5399d6bea9d980d8c9bd0c258161228d9434dec54e0aaaaa7a66ba9ab70efd4187df769079858f793f34695bcfc681124a53f2bda9c0d4276a1ee6a247c18002f4a012fe9bd295fbc3df3936824975063c162ca0de0915bd84dbe94a6555f161f3ddbc11cf403f14ec4ba43034b9053faaf8d7776da143ea9aff88c5d09c109dae81ee15187c5a9e51d20479652b1d153403e60931c7e2e8b6e10685117817332f24979f207f4250da25af41b00796212988972671ef3b96193311870eb15f5ffbbca91e30c000304db7e16b05061c55cae8425a06add5443055a777a849954e779f55a383f7700fac240d58c76848a67f39b94d0211c5942ed3b58397d3e5fc59f9941828445f9f1ba58bc91ba2ddf7139beff53bdd44471e3aaa7db1afb58b5dcc02ad1cb3fda0cdf2d6a24c674f71ef344126d40037155b9486e110f97f88ab70cde4f8de76db5cffaf16b15c0cb3eac53a62414b309301217648c1b4db8140d898c0002eeae6f48a8888f84572fbb228772ac949a578065681dbfd9ea1fe9076cf4162fd57b092f9c8e8a6ad6bb925beb373c829c160f22bd680949d12a15537782f172e744f1ffe00bb075cdc1fc9af021ccd3d357d440792faf0fc026a789ed444c22ae15fb749142e36acf1af418b6ac85a7886ec5726d0704799b0b8a0fe2a5dfa1be335ca7bf242a136103a5e7e2253b5229e7a9b83d314df014f1020a50e8f25e5fb545eb38b33033c39ed7507cb816ecb6201f91f0de25e4df000c9bae7dfb71f41127915abb938500d913cfafa4a217f2c268291300982ba0ab6297a232a91a0620da5d09151f3b7f83644f40015312b1828b84fafb8bb3af7f44da86c5ed87de4686993eb7c78e19366011a14789fc378d99385eba0e1bd896ac99856ec3e0d43dc2f49f8b7bc1b2c70c2571c6679abe0cc74ad65917f9d624bb376fc7222c33d945b92de109c5eeb3df162f9d51a97be38b93fa81a3ba7fdff439e5fa43a62bea69116854076a0b696c5dfc07d9024e07e93f3ccdce51beaa91df5d1a56649dab18d26d233e797cf3850da2a727fbdf1600796e91911555644ac4e4f23daa07f4e3f587a3461dbcc53e0121a3892a39f82949f1182036c7d5140efeb78eddb218673e4f0967c137ad94237909dde1d6c6f79e46e3327fe996f35c4310d7d55d1005f1c1e1f50e85f7ad2dc3f2230a7a702435443e009a318e24f646ab65038fa8632ec15a4f40a1080e49de3389a6665d0d1a67538fe5e625449595d30c7176800febb226742cedc4dba6dc62d11d491d5d7f70d3f12bdfcc3726e4fafe66c7287629a072e47900eb0804be44ebb43e913e31de9ace2cedb1eab3ee21a3d4c7d38a83c83caa1625f2a591960361862d6d120ac35d16c5e25e52d53cf4eaa4068312993e657e0b02d221b4082fc64afb1886d5ba8ffc4a5422544a8bd9cd75fa984cb0c60bfe60ec402ae0cd033c627c7dc4c6f10e5f81cd2be96db8b5e271fc46b937b1a710441ac3ba4b639dc4358811b4173f22b662b9fd6b7a46dc432edb2af988b86b3e4f1b5c3109bd5823d9e437645f0c5c54578e821d400f6ef8c14e7f3069e5849d4b8c2a3cc30f546f66c95f80975d56dfbc78e3e35945af6c436575d7559533bd6f04b26fde8ea98f0550286c3cc088018439c04d814aa01d86f051dd338eee710952b1d510fc61a709f0f1c6bda2c6bb776cc12b9a00c0256cbde2da8a14f4bd7dfe997129298ead80619c7533387752bcbd40fa0ff695e66afb6746e088e76d97b7f55459e325c8b777e0a59b93306f626a0d33bc3ca9a4dd146d5b100b0fb10e6867da8e87a0c0d0919c056b631f7c682261643037ac3ec0055d9417ce79728d069ad36e7d2c0ce919e9317a2f6919ac6d3488afaa5b68e98566b9d0f5bb9fd5171ddad59565cdaf49d16855a46e9ff2fad7bfc1f3fcd0f145304467b62bddf0376270b88375843d314932ed61fda19aca6f484361d978188519dfdaa91b4cef5e1c106fe63c553de7a4f445520ff7a7c00597e225b3793003d61cd056f5026cf8604b025fa6d6201573b8687a7cd6c830e0fc2cf2b4c02621f97a417ad836eb0a57742634723d4df2df28c948c308696db06e23061db2c560415802805953d4831aafb355756685acb6222fb547080aa2a119e8d0873bf093a913f6cb60d95303b845447de097fd020385559fa513040c9a631373628f500fba09b089396b6de2dfcc112224bdff275b06db7b48becf1636511c2f2b927c24ba035da7410e338a84a666ef6572efd29d52a5c80a514c2dc366f42e640cacfb73aac5ab294dd32dc31248fabd3742b90fc032118dca51d36e842c4e1995065d9dff1bf46483910280d343cdcfb785f9e1603b5be89e81230d40b6a344107d5e57f437540ba198f92f6dd4ddde59474ffca748aa84e64b1f417c9036035a974a27a9fe77fa70decfd3bb119727d85e34dd40aa94b89d7d3074eed16e850ff5626b6c2fb943669c9110ff7d27e47a8fe5ab75e0abf77f702f8e663771d47ab924c0310a76c22fcf5ba1b3b78e3d74614f8afa599320531a663be48b5ec355a441d94b6d241e890d0a0506e29e1069826bbe1d2cb0d66cb110125f6d7d3d7df5b54851c22223be76cba35967a74a727a04b476885c0966f549c0e4196b0c9d8cdf99d60f7660636fbb9448279bcaedb857f9cad78c0fa6784a2d514a77d16a2d6feb8821aa9b3d958ce7c3f388010b89100c4e09cab2e3b98f3ccefab5f3b931ca813c82982effa9a206a9eaeb24d36bc1d338c3f8ef058d33de2ba26e889e6b00060bd0f1e12c50e6405728f090538a770c7756cae82ea3767bbe265b4f1f4ddbdea0ab42bb8d0e0d1a5356762afcd52e0b91f2a77d195b9932e196f2484a7ccee9dd2a4aba9fa93e2faae00791e7dcb3e28172fd445faac0e3f28e78dc7a2035cf39d163046db8d0da859738900a89ce3cecd9d09ad5cb9a702d671525306471489670195bff3675d1943f22b090875484bc01c7b97d5902124b210c621d7eca00a217cf99087834cc3d14c124eef6eb0a37d4f4c1c0a449edf91a9cc0005667f6cd6552ae0271ec5a85c07bde310ad0530aa92cfdb8a96c30d6bf0f321474ed19afaf32982599b2cb05ebb81aa7ed4d69b2fbd3a71f6a45b1731fc1621991ffd5dc94626874d8d6b9617cb25ea920fa7d65e349a229309a2b5518efa82b3972c57f06abd84dd49ec3aea0d4fe4bf916648e98fe08f1d9fd54c028129a495f18340b10abf71cbf196dd67fb4e5935838f2f3cba49136820d89a14f5af43c4347290a19fccb412eff788d7fa9899e7e12bca21b0fb37e872163570c9fcdd2f4a62f4a4c7ee95b517f61cd1a2065970cb2d44bd352b5cd45227e1e92ebc4d8db6879d675bfb92dc20128995028eee84c246da7e80b811ea37714fca744aa12d80c843ab09f87b9777ecbfa5de8183699c4d5f3651908c0b26e77f5e85ca3fe55c34b73891bf84f3cb4c7eae51e66d188f839e266c12d1198982f47f7191cbc72f4e6aa1044c1babb64f50cb105de2c118ba023f7f39a6cba00caea26821db623d66eb83c267e6b1f12cce548a65bed3ff4c9559d0ba78b899e7b031521567751cdbeb33954923c68faf3333ce1f4c300a7f65ceb2b71c9bb54e7620f575fa74146d6e24f445f3d00a5ad646add2b8a912ea4d758d962529f333b5010c3505146877a9118f3bd1e10216a2f0b02c63fc52681581e40674ea26d2fa90daac86b9089fbd52924db898fb1722d5c1efd8230c88af2ad1d008f05cb6f6609016d44b08e4fd221ad645094bb9568f882cd086b2ebdcfa41e2a18c1af2dfef05d92b2f577f85fcebe86bcb4d3d45f345bc14e4f03ceeae779e63aa19f079544cc618e162e84e881f8e5ea25ed8a95c1e7aa89f12790872ffc536bc74a1504e0e17f0daead8a2a9518274bec1d5d159d53eb7502e40a231f472d5b3333c1dc75c01f95f2e7c15f2af593a964a5ae8b69bb7b8b113847c10f4ccee48aefaac153e5326b54ceed5fa90fb3cb107d6612a3ce399b8b74217f22196b1a98f6b71df32ed7eb962258067cb3ece52b777909cf8e03fb3c828eaa67d3696c6b12352bb0251311b8ac89be388b404087a175326fea83bc03e4e5b5058bd869112ae19008ad5458608521fbbe4d1387cedb8fb788d3835f69af81c477c3d2b8539ab6769a7f4abb885632a0243c537abea1823f79cf49d123a817c4b797ac752f9df1433ccd3da6a569da1e30d3fddc405bb26373108aa03836b5dc994dc2930a853457fa94eafdcceb1210e1208a8bb6e61000ecf76dd5ec164743a372c49eb4d882d951199c257b1e85e5b8880aeb1fe2dcf85a68c501acdf108a17509f03eaca3fde310137c3fc6278210671835b125cf9d651b672665b9ddbd0fbd72cb92543d6f120ce65508382ba789972150dcea90bcfad905dc7c231b2cb40c8ae27706475eb14e963285709556d93874759b67bc99b969136a793d341edaa6d2f179cb2a1d753d008278997b781c9ccf0670f59dd7eb2d52e06a3b4d18b6593f6e3179a2aec2c3d53872c42fd0ff2fcaa9c7e1b010395b77e2efaa07adf89cbe418d649de7124b57ff92a24881b5fe6d1a1249a23458225428cfcaa95fbc9eb679ddf854edda141f39b1eeab8afaf8c462bbb44abb9f3ffa61335618d71e6508781e809a28243dc3c59ddbd2229e8c07b1cb40e80de52a28bcbcf283f0cc967bc6ba9cd04ecc337d2ec65d258f1c44b3d1ce99453eff71c9ed037594e0dada1e39c0a7e9706601813cbb1f5d877966e116d4f364be41d61d02d0e3975a7ad2bf037e1fcb38744940cbf8f8d134106d47e35de75b1616800e0ac74dde05a7364984d7ff50ec5b1c56fb9fd16bee70aab4a530ed2830f761c2e499498a684806a5d1c6698a04b11e7ca1d343e2bc7e27842dd70816ba1e10ced1d412e26ec8faa61415f93d3ca6fd9b0e99127b0a9917cd3d1fcd5a496507c963f7753e2a5579ae9cfe1237b0487068da23c78d4166acda1919bcb3414046cbd2d852c956f24a1de8ae74468531d400f8322bd6f9e7b2726b13d82ee308742fdd1a75aad270a24d629fe8c69b5a1c23e38e4f05e26538ac798f457195a7e07f94f9d9906d1b2e3551471ab9a76431951bf293591c8da679e42c04266f8735e1da5752bd31a9319b43407dbdc68f5302657996a9783a6a69d53f26884d74e156a8346b9140e2d87323ca63d689a67f6fe7aa52c19614da4a6eac5dbcecaca17b02e675300547a667a66a2483a305bd49b029ee7ced59d3e41910220d7dcc4c24007922d18fc4d94d9612981a14bac987d926f0cbdfcea8c16adc83ddca1435fb7b933a28e9ec946acbbacf0e2229d419d3a1d9ee3ac84433e33fa17f964766aaeb420d1d1b809f8cb77fa092fdbc15a1aa26506212c9a6161fd5b73e9a25c15b47bda944548084e02668f77d3d60995397a3678badfed2ba0eed5c3b371ec0b75210d3513e4b3a5838f075596744d1982ca7c9573f2432d7168b42c621130762f0d6f3ac1be7760ee498bce4068d10849b57f652ac9ec36f4820a6285c287c846080cd9189791cef81c01ea548bd0f9db1e2f129dbd9ba9b21e679f55a368c434cdd9c95219d7a484d23e7e81f860afc8120d6bd73957d8ce8d1525fabe53950d15e95cae52231251eab547661ec18a04785b8efb15ed7e3bfd6ea8b99dd048908057122df86821ef5fc5c81631e5a06fed85f1515a023fbd1bc50e89dbb461540457874c5cecaa0b948fae9d7e639de1835dd698a780f58a00a17d1e84c51eacf67e515830695ce249d0f583117abe6436aea9e9ca033da3c259ad8cec6ca1be8f4db8e55c65907a975725db17b315a467c221712493e583ca082fe25b22041311197deee9c0b5c903af5cec009030efc13c7b54f02f3df1deee11ac3cfa4d7d5591da98f71296b3ccec9d78b67f2929eb0c996e2aae16d6d38b70f054e1d38e4b109051b92a289c41596cb8af502b06accd3a638ea0d270601ef919e918e3d976ba6511e6f0a1e1196bf8871f1b0979f2b0f6d805b8b73b93664085916b7d30378e0bd46f165329cceb0c5c1cc7acc1ee0c010650ad0a0e980995cf26709271f3a60c820f4711801ff704c874652e5ffbc5a826f7ee415ca87ceb852ad5914edfe2b97983c173c0c786757df7de3b82bbae05d172bfda9f53ca92bb9aefaddc1a437dbf4b556f38634313a0768618fd647385055a9f51f45b9a79d9ec579d7b51ef99e4de836041ca05ed320f45881d5bfd7df09ff17110305396b28e68965edfa6d2ace141adec13fce3af2ee0143620b3c7ebf2dab49f14fa5cb329478b5d875f66500e00d766b106c7efe8dbc674717f43c0253edb42b3d8be3d276e1207a58ff78c44e2423abc5c15dda001cfb4970a9ad50d57475baf00cf17bfeae3565ccc2ebeefa358f6f1e8062a0ed9d8b8cef087c1b01e02280828e0d7b9b580eb9e1de32ddbba223c7a36177be229121881d85b40bfb6009329b65da94887a88415571b70ceb2bbefc07389f2dafa45900cb3bb90ee1eff1b665ca67706dc74a71610d7e69f0c8d26b01ecbdfee220b5f7229cd0ab5f18fd009ca529898d1df02c86e24a4b78293e5d16481063769556f250c23db0591904300fa42cf6bf111548d45ed8470e571c2fddd551fcd3478b28b01e5256863d9f90b150624f0ee5ea632cc968bdee9a702c124c157fbed265bf2ea9465facef5907fcd3a443419b920582f5b31e1afeca1a984cbb17c2e32e5d72e6bf71c91c6b9c9108ab33426f8df81b372ac01f3f1143574afe07341e2678a339ebd3239faaa487841d44045a844378b84a5b88e06adb944dfa4c1060f38b8ac83a53a89cefea0588aae1983ba6a85d6739d72b08680eabda0cce81308146303c0ffae5bd9bb9ce6f07c62e03424684e4dc0bd239d2bc2ffa51f38991082ab81aa59c0f2532de1259db6bb98c8483c6b0e5a18df9cd0cc8fb623e71c22a24de03ea4c4c9d07743b18bb95cbf0c9526432112d5a2ac512b34a130fdffc29f4e4b8776ce174613cf021a4c6d4380c53adb6b6c2e4543a7c1ec868ac294b74eec9af1c0bace7e0af57c78f7d262e12b62fac884e4d0663749d523164b5bb595d0be69b05064a8e9f985a32499b729ed870d00447390450cbfa0ea885d8ae4f022391663ca97d32d8278639d5992fbc84945fc364f24edc5b5df77154fca8f06d5053acbc42ad7410a73cac7e81331a4d0520cbd41e0a76415e5eeb7f701fd7789332b4019850e9e01ac824163881cd8d3cf4f02822a3cdfca4de63c4593ebe475464acf8a140dfd5d7b727308b6e0277b1d18ba9eecf2fb15d0b59f5b26447e941378fa98066c8ef79253196fefcf54568487335b98b9c261c7a0772606346d430fbca1ceeef9e15012884b063c18a5b4a57534e1d8ecacb84acd585393c8f5a02971f3929342d61690ec7ed5d518396b4874074cf287f354428443386f2c279df7dc3472e9e6175a461e56cb0995bbef0ca87d960176de0b3901dc010c86847a8079540ecb98b73b3ef8ead73955a0e9c51cbbe725522a2b0010dc80ab9f650068d42200753261f5b2bfc1914428d73830603566601ea07144e7742f3c1347b0a39c95fadb18b4a3b8ac7b61cd27de8552d8b4b8cf039260384fe07eac1e144c7520f1d5ee664e1cedbf390b3eebef8a5593f3f6eb8d2922b620af5a45c0c5d7255d95ccbd0225d9c6e68769e21d705ce695b2c9609eccd747b83154526e594a675daeb5166408859278df20fffb9967f1048fe6fcff388bb31b8561b355feca0cacd292d96a4e52f206a5ba0ceeb986fedc755f77f6a1e1150cff50c497a2e66353b7b5c6ed8f1ed18d31ad5390b3813d32804d611f6fde1d00f08b7d2567dbc0f48fb81521a4f30cf8fa68d826636cf885dc014a1f28da01dfb1f4cdf38ecde290ff401ef1ada12635434d8c606fcc68eff4505496aa707e2947ec6f44fca919262255994988ff6b7785d912f3aa0ceea198c16145486a1137a29a71e615c1a6e96b2343ec1e89d5c9b99ccf8fdadcfd1119c5ee41cb13f2ec0d8cf5041ede4eb39b51743cae0743f70777d99531db7c9715d61def157b3ddf77d5bd6a732ef1720a4548164d72d1ede9eeb06bd19900e501c0205b1bb59902896fc1b27e892fc18c2dd7513ce6402989314f84f04d02d8dc49c8a11743e717201d7727ac94690422328043be4233eb24677f03e87d8d310fc7ed1b5643e01b48b2ab29eea10e0a77897fef97949e05c6c23e82ed5c124a52df444ab913c97d69991d0414c6d28f3656530a20f5b5d8f9fec33e8bf5536d76220e9c39f680bcfcac8635341fa2d173cbe064bf2ed01bfc3959938404f41ebcfd69e8eb2ffd423572e16303a1808a188256bd2b3513e860ef82db468885003a2a4384304b56c33ca389e4a3b6d4ba598e3377752922b14a21d8efc8a986b9e3f1e27554cce6a92fa7f260b49ff150b02b8a2a298a7190ae385d375ecbb06bd8e10e7da7d759e8af9a33ef3d13aab50c782b93e651348e447899b0e0f47703b726968b5bf04305def24905000c5bcfe7bc1be3c523d3dba5fad01958cdcc98aa2f3eb3cdb43e2f1e7c9a70b4db434e4c6e605eaf0b704b369a393008949bcbfc4fb435201ee78b344703babd1f6cf5188baaaafa7fe962b56903a1d249475fe0c49a30cab33110cd4da5c8e1ca1bd8b14b686ac81893a3ae6e4a43d1c6e7082daa716f7cc14485c4b4fde9d7d5eb9913f5a434c67212b4027629c0492db2f9cd3950bbb9b941bbd7ecfcb25e608115773315f0cf7bf2cc501ee64163ae8d8d2321d146c6403f078143f431a49956ef8de1ada4a97661f1dad89dbeb78b2da9b8a8193f65237669a36610e946d5774ed1e90c94101fe95edde9aa5916e52a494c71eb3257ae427c76d8acd51fe33d409ec2e60a3b7f5ac94a5729c0da797a3fec6e4ef126aea442c4610b919bd74de9130147df6500c91a09ae453e6c45b4f9518b2120ddb4d3cc6d5150d160191c33e79efa8aee91658fb9f62e43f74193d42d2ee3f8899ac9d1ec1001f1b05720f4b45792594ecf7de64285b1e9a18d841e9999e32c1734c3425ed132b63ff55b5ff748e582d738079319ecbd46db5aa621d2e5997f08ef54f88754d8b4823a2d0ee3462511718da06d6bb954ef0e2a73e5cb8566d80a20e4c8028934805ac6b48cb2173a627eb4ed424917d084a4153668586eb8c5f8dd26e22cbe15604f1a6850fc6142a283206e30c8c1e861cd22d686e4cd2865375fafd8bb2485b5b9381275fc52bdf4cc9c1e8dbcbbf3d0daabbdb20b0030d75ac875ee98543ea369832cb1c7ba4594dae69fc85b4fb71bbc58b0757bba799a0dcbf04486d00d55a34a3ea44d3a6fef7644970cb479f2f3de5737a90f2adc604fd41abac4e006d13643cbc10ed2ece660819f3e0baf6d188f4e64c5daa5f956fbc3880b00a555b0ef19a760e892154d83182f074455e54b1b173e998dd814524444c93ddcc836244aeee0261c84b5d11ac585c758ba8cf53e9b563b06f0052bb92b275bf820c671e7ebfcfa48f082825a5ea400d9143ad4240f874d187c48db7c22ec5b53a1f29f4fcede1940a3a47e914e79c4724aaa4c331d27d4b03ae06cdcb56292db5b4b6a9fbdf1d26064e8cb0fd3e026e4461df8c9e255c9c0769141c1f8311bc8a7fd0c9ce97505059930ad6452942c7b904f68595b6e0adfc34e5353fb55c3cb5e6cdda8684b365dd32ae0aa9b889e15e04741996020d04bde948c42fb586ed8f209be137b9d74a6df6dd8f9afd892f5e070064e81e25789e8082839bc6b35d00317c1806066a46f338d8f199cbfbe7051c5ea648f75867e77d4a429e2251d9903600b0c27bcc56fd0bbd2b383d792107c87381d1b04ac78eb9794c30f1364e6e73c6707c8521d0ed8767f1849b83f3ea0f0e71ecc019d249b2128690884925a5da659454d1a252e829ab45444a9c0dfce12c8b3675296dd644db3ee84b28883fd7748ca6ffe76b3425bcc272560525f18e1620bef5f9f523c1330be84afe8b9d2d86da440e4b437355490cf9b89364a50e6f5a55a70fcc3fd568ba310521e0ae3e7d36380703aa4c307fd9c389e7dda56690798fedc4cbd46ccdc598ca5ff63e01cfd1acd025dca1ffc5d50733197c80a80029e030faf93e261c4ccd2e55ad6240906269d9100a3a2aeaedc692ad5f85c02eec4506c7f1212ef9ab64481a747e3e62d1075805897a6c093a2bc63e9f69b7b717ef8d7849651ded46956005aa0a5f84b7c863c84bced5427554f14a0c3d17eb6037e00da2c2f1dd42217f637d0919bc48c6a39a79851971ede1475b84f16654bf006e6b42121334514859ee6d506af9a9959f7aeca1817ba0dc9afcf81a59a8a7af0c29e9f5aa67895ed2e0db90cfc15e34fefc948471fd95bb24b117397aaa20bf3e561f778ba2aef1aafb133fc354efcb635bbc4702db672a0b714f69c72450cea94a8e0ed7fbeb060fd79bcb9fbe024a234f03c1d5ed5b24e5a517d757c147b6e2e2dd04fe5a289101ad1a32b61225af9408e6996c01254d932ed54f0a899cfa488a84766e2805750a9ebdce91569f7dbce7169e629f8c22d4986cbcfad0877c52559b5a3a5ceeaeea016b45b4db5227e576f21577787e72ea527a875e96bdf587597ca65f8d9fa0ed95d70827857a4b57f8ec26e127559f517ee846f0f0148501c2cb49f97c5b833fd8f66a646a8c16c2c66dd20fcb93d95d79942cbc9ce31eb71369dcdc295da6b16cec15a7164c8193346113bac8471f7cf02298dc8376bac6de531a4f7e01c0600853932929123270c1fbb7a1a307a57e070dac8c7b94163383a520ce6a5da72421a00deefc065cf2b6b78d9eea1c959eb154f4b22a013e791b6dc17153de46cd013be77f4a71ba1521cb544d3d8f5d76d2a8a782c032f812e448cb1ae253a1d9b94cc3a8315291964f6ef3aa88007e9a70b403b26111db420d8f399759f772795639c94e16edf6f0f9b26a3d8ca0056f817ae0ae08e2cdb196a429d531c385148c598d6aa59d87674fe0543eb0d0447ce11182aa85f661aabbe3a9ca85cf8678b5725b44a8737a10dac49d26a9d1878fecb2a0dc47884e1106698357684ebc4eb257d9edbb3e89a095a18dc9256d83a1aa0f055b216c979b3d4226c39c7b3e7ccb59a05f888ea5de607f5cd0f7b409ce1b9d0189345d435d974c4ca47ffc7734cd2f44f0caa147fa30b2cca9ab57779eaef5c522233b48663a6b788acdf6769f2125872c4c16c5d55e7f91355429edf79891baec9563a25ce8abc02e62c7827bd2f7215a72e27a5abad1cdb74515147492555836fc8912b0ec2466c4d3b54644f35f48dcf06b4ba7d2ab3437196edcce476ae5df76b3889791ba61bc594839d739470183f9c0365faf6d715abda520737c8f1f3ec9472449ddca888205b00e5221918068004634b2367f0800d0d407e25ae52f050a90f3a9499b2f9af26a9f665081ff9a2e9b408660691dcdc775e9f0d78fe58ded50c0d40d7ac6dd668320c1a8cf5a15f446f11b9ce661bdbc2a51795867ad3b1adf8166605ed7241d05d314739bcdd1437ce0368e1d215ca30890cc1c9edb9aac050bec180cbcf45fba8c222af45b79ce17b29fb894b87ba1d6e06d910ccef727b8f26c1d60f93f75f0081b569e7956d7b5d73490a29356aebece0bcafd31e2ad25ee1f1cb92b412880c09790b166cd48d095371b3da935498c4b250e4472aacb5cf1779bdf3ad3f9c5e5e5217cb30b0105c48720d982ce8724f3d12df6bfba881a18862d9ebde04276fd6f005b7b2ae466cce1ae3101ddf9f6dcbd971b38c575f6cf43567486db25a8a345bce17fad66b6006363e2b0d80b5392f0aad314bab81aacdde336eb1245fe1ec4b59203c08d73751e2cc9cdf7396f0393d19d8d15a4364dbebcf3daeb8a7d70d4d7b56e9bc75ac848cdbf7a954fb4c57ec57f343f5fa2fb44652733a4917ffb56f3feebe6e300493e190bc7ef44ec812744539655f656a82f5b3b514719b1df15325e7c80b5266615a6040239a6443cb943f337f212553787b40d8e8caefa2d1f29d59227a301524baa2f5e24f48c322c6e091b99638e330de1a3353304bdb5cfd61d94f9b42e7df46e6ff580b8e865cda34ef266e70a5e95bc731a4b08a2402ac7f612d35c2faa6c7c3ebbf82c627aa010b11b916bd879d4abb131719cfff1cdd36c3e7b756df003a92a33831547fc238931975a132cd519c8353aba6afb74a7622f83bd8476187d38a617a34e9eba86558a96dda05cebc948e6d9b5cc34f9cdce2520aa9ccf4ec92bddfe6179ac5327002700658f49caaf11ffded8aac629b4f6c44188d73fd2e0e8185f0b2c9a1633a759cc059e2b64f2cce7a3aea426f2dcb231be0f38705bee2e53a1b3deb76adb01cd3a0d322dc462acc868e21c2cef9640c528c0bb26abd48f1c18c37e032fde773fc87ecb9525b125900608f7e3d8944ddcdfdee0f2336cd97ad68c7883aba493516c14f0e9cafb66554986efb9384b62fbd394d738e32d5cd62269df990824c48d53662d10a0103c3ab4e3f75c6352691f844b881226dfb55df87a112f247d23134ca3b156efbeee1a75ad562dde5f490e3452855d11ea10a5cc86ce1e2ed39688f9de4c38b0e0b34755fb2f8baf83a52a27c34abc9242414b02c588c57e484630b7a65167496da49a0a7fc8c063fcabcc7a830076a35c9ac6ba59459bb78c5b72ab84251ee2be9bd000fe666ebde36ad778fc3e2d7a0eec2846a26b61c4e347a95f316905b01a4a9435722bb380fe980d91d054b72f902a4099537501bfb0c3651b42207936cc2186c1122f1b16d5b11d4a9b99870a7aae92809bcc73b388c8c59fe1c9009ac49bd7326ffb466e261cf9776b357b45eb70783b388c990dfdcae15a97ab78febc5584d3bc856c3d6faabe58772e4a810255be0ef793925a6ff9f5cb85ed766574e8af7537d57931504a4c34a6dd0b39625eecc5d673195ae7ec970a89123df275a88ddc851837fd354808bee2cf7a46c927e57ccc12305375a2859fbd3092911d32049f2a6595fa3a1af3da89c0b0992370a36c2874094954b62ce0b8b37e2aef3a7b8177c6677e6540f1c4d1bc8cbf36f413253fed933e84f644b70d8dfcd57742b21745ff17e72a55834bb6f9cbf4d3a3a72cb75ac09b511285798b4dd15b374b333269beab0fe0c9411ea61d826d8ea93f4d01eee85164a9001c932054d221d0889eb6441d059b22bdf2ae5895a4e675d7681f9c6308a870ca7fc18afff150037d273c7a8f4a5dd3acfe48a8bc0be3fce31aeafb297b1a20ddfa1a62e22a174a95763c2dcf8b7e31c22922114dd0d5351ac398cb02c3e499d98a29483d8425420ac6054ce725feb85ca7a079003c5638b7d9fba17cfef449a8321f4dd9859d1635b98001e14869cc2c4691e84e8e4d445622c13a714d260e34fc152af3db0aa8c03b6418060885cd7f90ca0cb7b09e19d01c81005e335dc7d57eaee65bf478611c40c462f3404f8e69be6981ea1f25996d30e8b0072e9fe126f8e9580076dabc9bb432b4bea5e7dba91b5b72f3003b32a3eb45f3a56da9f5db7ee10bef7cdfa66163dfd93e6b91e9c03748e93a4a8c0cd7387665286647b4f45edf1ac7b7c8d1572cc6c0c52dabcd0717dfa9e22fbc9bed11a0bd61e3ff6adce5cc4118bc2b3edf79f287deed6891f9226845f8951dfb097c90ff7a65e9f9f1dc06dd356c99cd1902ca86df7c1fa9c2882d24b8592092ae97b1278aeeb4d4a76f01b78bba9891d8cf86ecd05ab74e2f565260ebf4830b885bd3e5ced3f053b160e4c8ae3e57cdba7e880a3d7fed2ebba04ccd76aa594a4713072754f08c22ff00ac6f4b3fb990fa27a6a8c6e8053b4fb03ede69e1ff95599e518e15338a1181e1ff9345c46997f64a874f90e617dfe4678c46b1cd5796a806837b04213068ae7e26fd152b1428a6165f49d3031feb9f3bf1c9f6764234256eee02edc111067478567184919b2caeb5a621af244423c3f20f8c5b8203a743dc90a4ae4561c2b94011aead96f88eab279df4e80f757c6f2d6962f9ccd5efe2f19627651a6c96470151f70e4f0b75ad52baa6be19470dc22a0221670a27cc34e4b29c7e68db5e2394bdf1f39f047af0f593a4b55f5de6488b5afcd42ffded8df2f4b5496216ac63ec64519ad36f02272c26c1d31b699ca22543aa686c8319af113240e1f3412002c64128658bf81b891e6eccc47ba4f10c25865c086a11e919866a28329d4382ec9e30877dd7f3bc30c6f402d90d482c5742c579e210e6a6678caddf0bf0fc131492a3c094593fba16b29d0b9c35ba4cac29315c624ef5e78634dba376c5f480de2b3bc901f046820b4d652504d03bea9b53141d7cf0f2ef52570ef92fa435c778e2fcc359eea1ab177c1fef25850a7e8bddd52b92f697b52dea4893f7caab60d8f12c7035a763cdcc434bf758c03e3610fb80c86bcb3d651c47fe30026d2cfe50b681553695d8951c4bff74614dc2ed6d031078018d369f5fb11349b4da641b2abf5cded90241ecbd431fae2ff657b37233fe611796d95d73f5be46245507524f839f23c0a852f9acf26e0d8fbbb55f89806848815462020731b286be7c3bf959a59b4421a46f08216f0b15391686461da5c7335868860cfdfbeb388de2f6e8ad17cd645dd043d659979b2ff429f7764a934754d54014716ff45e4d76c9fa108bac25bc40d1d5a7ac713d2c2d645003be16a87fe1fcaa98d8267047900fe320c116221c4bc5a1e9c6391e3c7d5a908604e1e932132a592e224acf057889403d0428346e0429e6aef9a16a6a8cf54b8edb4ac7915a3aecfbca4cbee0831befa62d1c83574891ed5ff25e3219912f4d444e509dd630500d0160a330353893d8fc70b4cb9280aa39115e30b8663ff636fcf8b53799f397dc78689af92b010bcc22307a2acfc73235b0978959193ff8e55a1f9aa6654374946ff6b37eabfccbd30d3cf228cf5bb5ef01c51da30e1f6317677ff4e2e3eb89f1c544e89d9b39f1c0227084d66d78519d109508beab2419f8351b19f3f9a694376d925133094581fa304b03f9fd51b842e0e387d625a5c1c7ff154be6ed09fb54f1066196feae52034f79ee464f2e37f971dd74e8019be2b3f8a9c4006c3b5655e9a39e83229b216421aa1fa0e3bd1c6da13a39979416d6d284432d7fa77ee7ac25a5641b92f8adf40a961f5923625191f1036209fe0e4483a869ed259e9bc45694abb55ac11d001648356adfe2939f129c9e3c1ad319eb9960eaa909148b84ceb5f15e9c72ee2b597eb1f41502ca418fedc1f6b12af291f14929ec399f15bd6fa76a4bcd502dad29b6cde36402ec80ac5f4f7bdbd9eed9d09c795d19cba8605518acdbff199bad1748265ad4b585771cdb3e567375e161839879f068115ce98855b72767dedc3163d02c629fb92f0aeebdaed69d9e9f1f5aae49fea9150366ec22556657ff7d12e36addfd69cfb1c12e9e2a2892abe75cf0bb0555857528ffe5f83ee0a00c0abde39c5520af99f8cce49adc55a7c56abf6f61aef2caf14b0ce6b3e17bf7ffe4bf4b8eb7c540c4a539924858d7c2dfd05b4ef25edbf0037c5b74a50bce4e88f664338a2297af4f9ab2cdf58b233d7b1733a3f5cee45e10d0b3c5a493fb91ddc26c6ba8bddfb718e86b56b6fa15b2fdc7f68bbaee49a3c739bfdd28a3eb467f28dd926bb842668327d5713da994b23737675013c2957d82bfa6eb6f1ccfd4f332d1c42c5f3dfae2ff85a2035d4e331f2143ca2cb7de4969133de0a96e236a4e1a862231fcee3212c4f131f30571e1ba0d44d2d2b17c14ff72cfae21d93c660f2d9ad65213ca7f2e9fca273abcc7daae6384b02a6deb15253317218653b920dfa0c1e919ddd320ec3c761a1b24fdc36fc04851d887b76aa59c6bb555eabf700dc21068236514ab90fa80f50295932d94d9aa84af4ea0c1e27feaf2f86b1148d3484cf25e81ae23f86589f64de5e1b246dd58449d3dee161bb14b0d9ff0fe953a5e25275387bb2c9b14472d1252f1ff6e3b6ea2d389ee206deaa60343df12679053190277324e799b78861ff7ca332471285e4e558b9c8fffac367b14bfb15e57f57b898f8773b583bdddddb215b3562f51f9c7416f0cada0f98c206387d7a1be32cc21087e96f0756efbe422b7e78ac866a30e290b498d22c1fe394589c783528c336ad163d6fa198f2398790634510f71d36bf0d272500f1c032837da4556a21ed6354979d94ad0bde277b45d46e90a881d0a7faed2ac7819fa89a4b025426ae4c8f070dc71ebcab4998138cb769205d5ba23aa68cd179b77027c9bc2d573cb721a58669fe392b84e78ff468b336647e5f3b7f1ac1bf3fa97312358b4799a168260697b7751d492013e0dddd7c6ca750abf3b6daa48c823aca353c0b127140f1fc80a71bcebe906064a91987f1af805329ed53c6fd6b6a3cb3aafc6412b64f0615d70eaa27031124f8e65fbf90781c85cc91e890e049f0b18a867eb67738e1fcd953c622779eb7015af2c3c13cc78ace3c5137c2ffc92ed644cf367a8ae2ddd035479841173ecf13c41176fc7dc2e1a473ae4a888db17902223ddd92607f448b7378eed39a4b229d68d9eb7f03360fd1819f944dd9dd632c65df07acf16c9650dffb206c406191f9a2e5217491563bbbaf54c2fad60107eaa448ee5fc83b005d3d3fd529cc60084bb55119b33c1f3fd4aca86551ffbe4d57cdd5c3107d720890049a7fe2b26ea971bf4f35469ce8914c77ab1cfa2bc675a0498e7df7bdbc951adf418c4eb09161469e7455a3d8403e222fb9d3371abc47bb394fe7bcc30573b6abd04cf6a3236d8a0560010b177a8e5924c04167351aecfbdbaa5d683eb6a74384a3e844410af852e5a950168684ac0840966b8bb86f2765978d181dd5d53fa26474e4e3758277dfd4498c3d75ddf841441e84b69cf1bddd990221000c618426d6f504d1a9d37704b449ceb8c55361d580efc4b9558cde91610a52388e8df42e1997facb01b7dbb377555860a3f1f4cc0458961ad6cc9a408d1022058bdf672a07b8ea527aafc426002f221b9e910cefc02fe9143f8347515c3b304670efa1d94add94165f330c706f4c4cf990550817345a7efcd4f71fbed9e949f0c332768c0ab78aff8d85bb614a2bd6b6141f4c4c78783cdb97fca5e0b4399065020d088dd0f7abbcac5aeed82a82f0cb04e8f08f4ecd579519753433f9c486b5b08ec659b51aaba1d98995a177c604fcec387da1e6cf3ea945541b676e68041bd44d942e6f7ac1aff243885bd761a329edf47e8f50d3ee6548218fecfbf896f6a281b1d01782423ef21a6d285952d9cc5d82bfccec306bcd557707ff3c357cfc5a129d37ae9f8a5dd82a3e485545bf7e3a30c177e3d8d1e190fcc57892a5af88602e7a3ddaefb1c00713807e7f261cbdf1cacf8e7277a908558b4e16b3d07addb4a0bc2f612e96be645137c4a666d73565aec62515724f7e38bb0b93502b69eb9c33f35c05cb133ad46aadb9e266113d556e7481e409803a16843e8b850c4bd21d3cf7b902f4f9ccc62d862cdb620aecb84a9bd78483392af8f773df35efcf0ba990307b2f1931fb9fa72a7f307445bdb0a295e7650981a6bf911c0188b9597b832f309bb7816ed6377eeb54794d79d612deb1159b27403012de2b7901321ddcc107e28cf2a252a3c0e2955efc20fb2782728ba71b9102fd615897b91560b0ca556d147e13d3d74bf957c161f37e72330b8c1ae8b7708366424a17e94044b71c4b70bcd750ed957407e88d41787d6322f59519e5be3f26159e616d7ffec11474b7b0976f22279cf4fb97bdbf222e9e77cfcb422e224c0aaf2837231bc9ed7c2e0ee18894dbec91c772e4c98159c75c028d742c5417ccb0e85340cf420dcdafc95a17a4cf307a23c4f31d2c397d33ec007e08744bb118adaaf4939b60023d78904500ca8f6dc18657d95e8d0a1a9a2544e735292f3a93cdaab0c69c3ad85db129fdbff8aa179ebe73b94c8ea700a1e36b230dca6a7c37129cd3f5e9416bff9271f3ef1f24f3f5e463cc5c3ac124689347590a7f5b31b1b49df31680a9e6dab722c3e99a907d358984873adfc6b42e852309c2cb5aa9a97d017627bac2b1dd21fb40b6b7b3bac799f7bf29bc374b424d2b601dda72d1ef0c823794ccc07c126d04bfaadb0cbed60212174a8c87629c9e5df25b5a485d4a5ccacc8f48be002c7b6d796720c8ca6923cecf7df86aa5213a03352f965021da65b3422a21e0e076142d0b95f894b54471f75caa28eb360c32724eddff25af5e3d008a5ff9fc4d2cb0a0c10eaa3e80c8ac4263f55eaa7951912fa328383d63a419d8649477c523606025340cdc1eb2ae11aab4f37412b6da81c0e31ab617b74277679c558a642e7fe234378a5e46b76df2a6050ebe43b3a13514b725ce6d4eaf3299bd9bf72bcbccf95be52e323ed224ac2bed6e77cceada3d3eecfd99301c8c0dc634c6db1b1faaba376449fe95df8a02ccc98ffb982f6da1f8bb5c87915ab9155696fcaac088cd0105f01d2269d001fa49abbffc4c62056e0aa6e06c08a242f542822564130f5164f685368fd1541540cf3fb4b71a8cdbffdec85188f579aaa38d851cdc3206d8f8f7ab2a7ef58a1e0c5c1eeb5780221abab44d3043221960abf445474bcf4f0566391b68b24a6fe9207f748fc33d641801776b50ae68b2bc511a1e134e8f8fd4a832955d71a15bece297b9e0892efe790108bf3f9bfb4a86fe92b427929a42b5f2af3a4c01bfcc5a6c3ca1e36d606dbc2f61c2913eb829a80898406b1726671e41df7b6d425ffe13b8cdaed17584baee052e5c70f7945388c8b47c66546b3b8b861ed7fce50f5e35b90e16fe0651617cca54cd361d6b3f0bb99c5f1293a562967a8b52a8a1ddd57f805ae062a3b5d12404231689fe9f74cf10abeb2d51d9aa6a894526d626dce2520f02ab5a36ed341bf341faef4683d8f3e508dc75db0679585f1cea7819304d2c90e25fbb6c8389cc8e5eb241b1f53e749aa32acbf8e70f481aeee843626b4c8b26cef725de72756f8d5620692c7655087b64fe3a2baa4441355ee1e09f19a5fa7346520972b99f1fda7377aadc2bf6d476bfbf5958debc431bf367e0fd392b9c843ea993141b4115ef336a6e5fbefec8350b1c6f36358b4bd9ff97020030e29e1f84b0dcc2d30acd2e6c51df81d8d88d423e8f35142860252ce5640e87b9e60e28d4421252d16fd4c86fdaee1c75c141e411894507aa997680b248d1cdb8a5782ae6de271f3e30ef60d5b377d5975ea3903a875e37a15a7b0df56f5f0e4f3a8649574ada2cf6bbe36cbf9d908fdb59bc2b9a6cc6aaac7c3f49dfe2bc464e5a68d6e7c690c32e8c328f4355f16f4e068d79f1dc529ba5f20501a98923ca88f90a8251f1a4f311ef732dd52da82ecc69826960dbe236ccbc186e925b51d1e28f004de67a2fa33a93314e1c6b63f655013f9c38c1970319a01a8fa7a17a886ecbb2ba9e5ecad6ced4bb888ca0da2ccc1c1fc41b95bd4a853d99e217a64effeef531670fa589fc91636075d194a243f21501c8d62e1d4e339c6bfdc75cdf5dc7c5dbd4d788bcdfd09396bb4fca059cfbc7b7380d263ff54f28fda17a7a5eb4c2a386f04b6a4c4b61f10ee294e5b077c89bba075615ba460f3be39ad70e757bf979525dc782e95c13f906aa9cc37fb8a76598a9b3f69b3ae4f90378b75b07149d74a3ccc56334454ee736d5ccd9600a6456520548079adc4871f19d43e3fb76eaf36a5aa0fd1aaeae7add92b6e0a56f169e31e5ae1f5d07e3da0a6c35da2d80d79b9df3e15a496113eff47d23f40ab3eb7dd1e962876ec4c1a12ebf251559459aaabde027c2ffca6be9a4b149477dba08e2499f49962accb3ed9f0ee1c0a932ee3d070af20551a1cb2b13da0aef89988b2026d1a915d33280bda34de8eefea4a28b9f456775811588f29cb3803388c63701f247f864aaea2f16d7062b0d3ec06ca1224226006f7f94573194ce72948c1b54c678381c7bad66f1e7a5a4a3b026a90d1799d32d5d88fa3305102e84648924a58dbb22a9d859c60c976d7bbfb4dbe8699c9efee6019450f1f7b42fb7151ae57b87ae587b75237c7a9f398eef904f4bd09261a0de2baee3e3de584abe96ebfead99fb33890527405c926ba6ecc86ddf0686765d8dafe131623d07bc74a374172f88853b843779d12b5cdab8a483ceea39fb91308a0928a8ba0ae9013e8687d3b21c3294d4b162146308162ef59e0aeaec9751c1c6011f9d59b319f27f1467020c106f5291673019bc55a5f127d760b997ba65a99f7ebf35d262c1c06c39fdaec601c0b93897105d97332c2a679441e17fb470e8653b6bb478fad626cdf188a3c5f94f1078da114dbc461595a2ee232a6da8049ae2fab31b21d20870addbf11a476f3ce74a4d77e83ebedf576a67d132f940c179fc50741f700069794cb888b9077f66ad6642d25b16141d51f36d6448a1696ed638eb581306c28be5ef2a95836bc47014d36b1d6052735ebeba94b7ffd2e70691d7ab573b21223386b008da6aa23c5a093bf59b4dc415fe2048b03e264cdab8dbc67526bbc66ed57f37f6bca9b47636328982609fd89c522d00bbfef774cd52fa621806f7e94d2b00a1fb3824980f3f699dabbdbb6132db14a2fea6276976825101a8ddb67aa8c3620c020b350b79b1915006c11544ca1c13e9d55ac71718557fa13e18a50b5f62f5577677f2a82ec0adaae70a1d1e8b1bf823ccb5ac2b3b1b18f075570b61200eaaa7e4cb8ee68d45625e9b24cd1e98fe68b4e52df1b3e25e68b1bf284301b6f220747af449c471fea286d3bc2fdefc09eb4f53c565744f19d61eda4f277ff630b1b29cec5fc9821cbd3ee1e52d7326e73d14fb3fcc56941cff214f066988352808c3f012a5eb8ef6423e0018c0254ad0c0eea2db4c166eaedb152592da86acb5e0f584142bd4913cd70c7420bbc12ce3fd44a0f785816790a2e71804c1a5ebf6e0b13bf53cdf9cf5c2ea049a85a534cb01e5dce6d29953e81fe873702b6d64d3c482d3f35f5c9efb3267897b242f4d9016968dc5000be025eb5b3ec84d39b5ab2fa5d3687426c9d5447a351498576cf627b8f1c91026543ba714918a9b673f37d144a6823d9fcd1fbca929097a0fe51eb085bad24fd7619bbf16704bb826700be165d53d0fdd2553b750c638d1ba23ab442e968d6f1327275c06a1c061f91dae58f679f9e07bbbcf8757d16bd0e9e807f340bfefb2eb2bfabacac088a013a3ee6ed57cbaa6b01aa0f7c7ea3b42e590a4bce4702be67e63ef199a5fdcb9b95f70f09282d8f64da7fa393f062fa001e71eade30b64c32c2a21d8409460bb400b909ca76f9f70ceb7c12ceaec78c25f1e266c09d00ca05c6d8e714af930412ad07dba975ef2b04e7566cf83331b30143edd48b0a0d40579920c47944dd0c275f29f24616e1752af399dbcd2cbdd9b2ed0fbc7627755be91dfedf7bbdddd1f3fee4a8f9f745d182f9c730218a1ba4d8e5facbff5e6fc41d4352a791459b5aadfb93b32c5176be5de95defee4364e3729bd2e8439f89f1e2fccdb41f31c62b36010d51361e68cef8c45454c84d57c65a62c85e205bff1cf7fe26a5b8dad7aa9cf624fa362d17b22a611b57d543c7c42dcd606c19f5d9c7b653de11e007b758ef4bf8fdf17246a664274102937a31384354cbc8557a8f3143d00ca83c6049ee9ec511398fc09eb3021e906b346141f0e2176de7246320f2db9fca91f3eb30fae41a3b939c7f7746fd711d1fd48ed5db339ebea4c20cb8afbc9b2c5b510212391638cf2f096d849bd17277d61664126fc53a48ede8441c2fd3cbd514115a4b49d7250ff4d10fc9fb434e07ce575c7681605e7538c6d1e7bae85bf2b7a1b84345e9d94e10c98607506f7ebda6d5dd5ee42723e57740ea9fbd28420802620399a29ec64d21a717183a79a2f5a132bf6e29042704954773b3de9bae8ecf8ce21539f807ee8a4299c49d37083827598adceaffa7f5721f8c42a9cce819aef211c466b1283d62d73e545a2f8aa8b08602a77a9888f74400e4b34f349616cce5b07971bb21f15bc08ba6b6b6bd7ae298fa13f44d288d1bfd3b667634ca5b8cdc95918fc405031b8db7df2e524acd670731b111092fe53be1b16bb76aa067c7cfdf57315b87c9a8f2f7f56413784fa508a48f823c69ec6080e39657310029cb244d4824313ecd5b284588a64779207f909114bf205cadd68b4d870100151c4ac795cc24de8cf331f553fda970c9ddf02272765538d48f917b7852fc23567fb36997b4ff848144bf32a764ce0ace4d6f88055727846412ee4953339aad9a4a172a4a525d3cf0697690c6fc771ac0526ae049e88322979ddaa73c8c1ea9d94947aca0f1fc4428fb4d0c8df497e13e9022d6335087fc18f23c4f2d273e7db633f791f273292a58e7bf07d48f09e2fb5a986aa00e44c6208553763e349092820d83c356b20e9afc66a00076b1f6c2aae5b695076f8c38524fd822fd1d77c5046a013065b85ade0bb642767609fcff334ee556bfd6efe107f2be7493e7462db18bef0900eebb88f827c6ae22fb56fec4d7de3301e9c825adbfdda11b6f2b2b56cf8b26efb2be81dab70507e2b6a59b41692e9165aa98f8d59ce5d50d172a953bdf0be9e8c20ba3f04e3dce3a07b17fcd9d8f5842a4d6301df93b2a56cf20dc49c7864e997a427e18b13d943f994b040f484d09adac7879d0056c1800513d483c83d110d75f1e9b282f1c40ad487d8da8c4403735d7a0782821b7c298bf1f24b9f3afc930442066fbf76a92ba774934ce6777fb637ec41063afb6142a82782393709e3bae02598dd542e8656663896b977634a7bcf874153da5ca2c8eb485dbebd2ed978389b924cb75f407d73e3da9534c80f8eefee97966b452c772ab6abf4806838314a120941292db604db1fe15ae5fe92d96713b7b218c2cbc12341417acf6171784afa6d75aa9bdce6bf9ad56ec36b7081f7d0738a3be1d922481d1068a867a6c1666e40ef7685677dc39a5f8f906f09b55f4c93d2cba8790a8903b6f08cca1a8b36ff95af3a23a720a51cb74817b5d12722316717e33d82b81999f3b9e97780f0aeb0588904d165f0497d68867bfbf45e9658bd52ec070bdf227ff590f82e86b42e984f00f18590da8abb89bca4bf10221c7211d1395b0ae73f95fc85b1d7108210079994bf3083ee1f04a7b95eed4d2785791fd41061d3ce9df2e3c3028514925c20bd683c2536e81bda238fe09362d35863346a60545ea1371c98448d129d1529800dbcb36724cc21623eb1e866cc05c0ceedaaebbefa671f1a8c19e978fe2d110ef63b57668a781db4b43289835dc72606c110f5db9808a6a411b07e2a673747d38a8522345ab6daffc4815e782f96d1478ac3d1830c0f51abb94beeb26c5e0d7db83512c5cb0da3af4b5b49b9fb7c79cf054b348e28c8d20fbbbeda78714ee64d18ed88606eed219a2a78ed1cce9bfe3cd31a0353f06cec5d89dd07931c3ca7f1bce85f3f7dfc69dcc7b120255bf1fc8035e243866623faaabbf9b812f49418b2186ff2d093d3ca779ce750a95938117b40c74061c6abe04d4eecb3fd87b091aaf2c86239db87d75aea6b468fe5c84502921dd96d8a94b8e28ce7eeb98260e8be50b5d3273992bd25e4364e911038b887f6aa083cfcef07fbce0b546b117e752ce4742d9218bda97fbb39a3fbce0777961ad4b860ce3e9d43f956534883540b63659e743b738307f39ba14c2fe71817dd91879761b838f3da0ebb0d83b04e5488eb602d18f9a6df24bd4c3b7ba02049a3c4f935238ecda04d517577ad850530ab30ff6c2d838605661c89aed16d8cc933199034560601141b7c397277009684a501dec6f3d6b123547db72c61e17ac998f06a24508efa3c3f631cf652946dc02ad7aa6e12483690158648b9b8c18d02b9caa53c269d86fb7f0865cc6dc2ce41c88bd252024fa8f4a34bffdfb204f100730bad1b0bb43429a218366c935bf9ed6fd85175def1b155717def9449c32e5530f20dbcd38fbb71c2ec2849d5a9359c64b7233b025a2ee4fddcce67a4baa1a9383dce9f59181fe8de0a88e5f8c32698da1a220ea20880d66ff8a3a3d1f09fb9c785f0df98f7013a77d5f7055006fa4b4c7f1f0b2b0a42824ed678f659abe66d149031a980ba0f2814dd96472738754b889e70a17f2730dcd4ed86d7663e954ba2ceae743122065ceaa19e2055df8069fe3032ac69d15037ff9281cd2f4c782c58b5897ad1f50b812e087a36b0872905996af2d06b588b1f72c025dbf4d06161381c65882794bd25afba5085023b3a0d8c8fb1d7d9f333ea83e021aadc5d4aaffcbcaeb344b0e94f777396f5ad5d4a27902b0bf2bbb266e58e46438e9c462705f5ab9f120c4b5816deeac7c0c92e12ae6724faf1615de37659e84e2fd2e4dc9305e554e58a48bc7e1c277ccfdd722036ca0b57714cc9f417f9d53da408c1e764272f5339054461c499c5ee526d7edcb43c450c8b0ecefb211258e2bb357fece98912e5d02b58f126f445bf899c5dd6ee5e515529258a8b76549ca777cbc071a732ecd25c0d8e5d67a12580d0f9bebc9b0ebda5b367b309934d68293d6e15bb8438be5241bd74f8197e654a6c92796c7c2284faed3ed2335471562f9b665cc690a035a25ce42d4854f015a28595dd020a974f13fe9684497ba0107b62b7d6baa4ea33a4cd5d1a6c25ebd13659ddabfa6dee110f8c8d3066ab93785e6c0870651b42af8c993dbdd515a0ba8341f2496fddd1530b784cd101fd45ed098a3eb2cf39d97fba879b65139f6f389cec61dbb60e29ca5c1eb8427307540e549c61f77da101fa9b4922a75bf14011a4ebc4148175146c86cf6a138e5c2b272bfdc6001ffe8e147f03b5b59c8f884cc27c9de1ca6b28dec277c865e1b1bbd4cacc0ead787669a5821103e47c2a26430675294d4cd2a92981ffd86601ef92a6bc61f2f81e1893f08cdb7fa880e8d313d737d44fa1b4667980c7140226d5d0844609074006bd1065c8fe7b809beea754eb2984aa17178a324d4c1ed6d565ff1afe3f2d2b9811ab3371d063a42d3efb648f0061d1e9400721e9bc95b6383058673a7183121bde4580dfefd171139bda4b802a435f92231017b9a9beaa81a4f5004c2357e6a044cf46ecbae403303793c36ff6754b11ead0fa0a4b1f9eaeace11bc138a375aa24b088b55d404e4988136455af59b597cf38d008d0921bd675e87a3ded22563e187621a71234a8ce11828401f969a82ca08fd121d4e4947b234a2076a06220a4a65bd93406637605d98d181cb615e6d7f660aca65239e2e7e0e209760581ca7700c5af1a8b728fef41a700882c1e6ee7dd60db2c4124f9363ceb956ab348e6be9b0350b3407ec25d4fa6fa54d6003923296391e4cde42f5de21beeececae5edf4d58aae0dd0889ecb81bbd6f999aef2a02711e0b8c8d9f28f2a050696fddf05dab75b2b9dd1f301afa12c0e36816f0f002c6df06f7241f7eefb5d4aeb8bf85b1a53107101161dff166e7bfc42fdf71f8f6a6dfb0a75f9058f28242aecbade10f0243991ba714f01cd872f5daa6e9b704d443fe5a691788a95a882958b8c7ca625547bf978d3cca6ecbd91893207ded8dd73db0747407930e683e996e5c7680c07ae6b3609380c3f73a1e9abe53362124f0ab558afab5bee37e351fd52ba71b1d0126cb21b5e9d852ad8350523d4889a6b0d665f6642e4c12e85783078045b55ae2e21dd6e20d0ad6d5cd750916714e9781e66dcecdd5cefb2c2ccf5615a649115cb749f0e251aeb5f7f6f6bb042b5676f13af4642b666ae5ab7088ed0bd2f8849c972a95740dcf6728e08d8c93945478376438941f74d73b9ac48773ea6f307820a87d296dd53f5b9cce83dbd3814d33ca419b6916d4c8bd9062c1c79863ba9274ad3b7ba95dc1444c9452053da6863a0739cbd778529b5ec314080754a2434c6a6a9fcd1f47f0f65ed8013d7497d434d026e2d2b612c0279a6c3c19f2c1d44f40146fa2a10759595c5c53e32083b4ca94bc1e2ca2c430650851e00a6c385b6023819681fe85a3a5b03d3dcccf479b97649a4fc6a4b73ffd61272a1240ee90c5aecc9b5feee047810b118b7fbfd363dee83d62801402c8b0879634b4bcace3bcc6b92458b60e58d57efe4d29b1a199641946ac82de7098684dcc18f9e1120418268e8dd04071c99acd23bd0b7772c4bbb19afb7c55a61eb7c4730d63833f75e73be8cad1ea22f519804b4671966ef3bebb760896fde5c655a5143c13ada4eb5f63a0ada04c5c8d3f7e5919a877072658d6163dcae2368e10096da81b3f0765add24666f368f0a7ae4618c4df6bb4f338bfacba75cd44594ac50df894ccfb37f36c1920c66ec5be27661b28eb59ea82de8e4fd798c122f106b6f2c25db025872f0e41f2edc5c304daa05814d34b8106bb75b65d92b81fd80b9ecc49a1b9bd9d7b9b10ac2513917be01f27969f702b6c7a395b47872b86aa6f809afa70915c406e30cc22c52885f3afd1c5735c50ccf8c026c55140d30cfe5ed678c8eff0f30e2aa17a9a0e727789b434ee3c558e43c31b6d68d2f5cbbe0942c955ae04c2c1e8bd27d45a7180785696af5b710e21221db4910c86a084be40a53f5758b31eb370adb12ffd76e6defb61b26ceceff8186d211e7178d867388ea256d5d9c627d329fadb7fc0be44439e43e54d9ec8073bc1fcd180efb66588a161ef7ac424fbd2a43fbc2c3c1606a6ec6b39922c8672ec075ab0212cb612b8718ee04efdcb19352cacb94a747155de497a7eb5bc932266d8e4443c2a568fcde2e9a4effddacefbd163b047466486aa2662758fb9e1c8a0283a6d4c0364b40d928139277e7072fffb998e2d8d1a0a5cfdc22ad2c0825872e9c0f3da4298c0f4621f26207984ceeeeb6266d34abad19a3b79118b7f75af77a1bd8883bd6eba8e1b6468e4f8aeb2108723773910b3730ef0b31cfc29daa6c91a3a987ac895d00cbb78ae3b125b81f74e3c7dd5460e2821d1b3bc169644dd3bdd6ab4150422d2e13ede07191b3470b173c16e1c1ee34f96963456183ed2f0f5c9627f5e4a1733b36f80ef1cf3f6790adef0da19aca3f70012273f89c683c5e759cf8ed3981b08011252fab15e4061d3c27f467824a1d5e18cbe92308cc50c352642f3791a2c9c2c54b5eddc55e9d28c7cfcaf625065895b6fadc42a4e73fe88dae23a535d9114865d568d8eae2d0cab94b9fc2f8c1987dfc839d849c406856c48e59764df7490882aec8e54d4162df42de8c4365e17a3271f6a6aae254f43cc90c7cfbade2ee438611e1cc41a1c441943410cd2a7aca60acf03aa8ea73d4123202e5dd3c01f34c433f6e6c04ebb3917613792f8d12a4f5a83520e1a9bfe0b00f08e39762179056acfae98940e59011ca3b1c5cd96df736585b9c128fcced0efeed0b9721007a6cc72988ee3c279b1c9371e9880c0b25ad833e6da5f38e6f9c74903fd5d52d477540a52d2e621a63f61a3ed93fa6ed88d5b3fc69e7789b7d1d98b0ed9a35888b2a52c7ee0e0ab90c126197605973066475c69ca97df376d9d437a32561a1df014c71f073a709ff3cb9f159512fd0a90491b8299593fa755b9b900ca59d52808f0b4976f3a1826e92326809dc04aee7b203e3bc3cba8db517c357cb4cf61f240f07b8d9927be568ed8401096035e05714e6d5e6aa8f5d724b4cc593dba9cfc80b29f72dcb4b6616691a00d458efb686f1f027784eff321b3bfff366cee3f15f33f6fb47966f3e2881c0250cf1b061442b17e9bf8e682a93063dbe3ef635b14562ecfd384d9576659d1d7b4c4eaf698866139cd1ee768dcab78052e1249e662757389aa7333f2389e62cd732fe835bd4b952eb9e02e14435057cbc79be3ee87174d0abb8a2f4c843abbe766d3df7cff04c8d3c00cd1de2db7d2f2fecb055e591ccb416d50984cc43ee70188cfada7c8e128c8d443086c3d454ba5f5189b9b90711ac84230a373bf61cd3992abd3a0a1280901dbe8a1760ab97a5f94f444910ea04fc8745d9eba85ec6450832f2105516308ec9fb45c796da26ddbad4b14fa2e796b53a2c52460095a5cb328d9275059a7b0a8fff4be015fa47e11b96342287c56525ec7037aa8db4227aca8caafc7c214e272a5706df2c1723e6abc0a254eb87279fc61ce833ffb64824ef3486840b2b7be204b7587f3a373827341498c5d8e02e12caffc56401813a708be1b5fc9d878349b53a930039a4de63774e4de466af6459ac93a710f1bcd5ba671af4570066b1ea5ebd3098308551444031e2ea48d248a27083582ee9eb7be05cc7b735c33a70a65177d1d8c0bea67bbbb54bcd195d786d080a2ce003d905cfaf9eb0601df19668dd55d76e0e418fa82cfbc5369ed898856f09285b0ed35b79ea8428a9af29f5337b605cf019d7618bdaa2ba096ba35f7ea0eb1da434064541821e25d1d20a083ec7ad15541b01fa3a3ec2f766d8a59f0bfed7ae21437d3cfdf8bd240cac18982631ca8fa8aea140b7aa62a380bbf71e775b5d943891c282ca13db2029e1356c4bcf5dc24bbc0442620e25b810db022a7ddfae7bd60eedd968d76b21056db861e0da80a95fe6e927798cd612b71becfcae0d06b5a322dcd365ddc7a9ef6979ffc46c5a0947224fa9a0611763acf1cab9cd28b1affa36492fa433e8f79683456db6e81f1d037580522a5af04441a9bb41d4983adff432d68dbbd7b860e1e6271b6b6abfb02f6595a73a81199723f8d9b402d74a9980f4955fc80939a472c81c04dc20733e30292c796030059e210d50ec61d88ba6a34686065eafa158e356f2922decd1a0224cf6e6dad3622aa04e1fe2933fe5914ce150d9e899d8eb6aa6182fe362d5c5c6318020ba4a8015484438efec3671d5f24f367855dfd331ff68d5430247360091b77be3279051d7d4b5a656062d781556e8b7f11ce2ee4d2ff5d1411d0603ef5487fc21b6b5adc04f54facb6647bf5ff021e2b38f4b39e17191fd14a8de14cb55244a10540ffc1ca6d12983368dedab9abd249a2acc2670f54492b73944a11c21685178409572da835d7742879a4188f36a2ebc0e47c05db41f35eabf222fae58fc259abb14cc86edb91d6a467964758e73d770f217f0f4946d61bbb413eeb844bbded451a0bc3b6b728ac85778975851838e68c5b0147aaeb13e61ba6e5c996dc68d20103725e20f3dbdf6f75c80ce6c13accc6032905412d35acfe0ad557d5b7b7c2930c617529c51962a699df62cb9726ec446206248a51cce18e89f3a33d7ccf5b136c493543cb4f3ad265d5a1394906202cdf9602233e36140faa2bc1dc4bd34a1134c3fea5eee20b90e24b1f7383bcf52cdddf71c940e23de539125a138afb47d6a13637a2b216a3b22cbadb4ce01ead17edcb21f6f17cd0619446eb80ecb0d75d16ed94cc7adb27a911a5a259ecedf6eac730fa44e8226f4117869b8913e016de07bb7327a5b23a61165ef81c2c06a6dd2a84fddd8f3e171091786955ad3da18b0c0f5151aea99160bde2eb28656ff47a533d55127db30c504ab48cbb85984403a144d2c4f6ab813c434e120509e7b285408de93f31a290e905346c6dcc3ccf677f94e04253931ab892f3d5edce410bd865112656db6ea329c31b5a237df16a3bebe7239b80fab06dd0d662ec8d49d775a1908ac139d6176f603e5552ab0c5797966f98f890284283d421b60b2693f5d639e7450eb858682c3e84d0d2fee1402cda27729dd16ddaa6a8913c04239bd547d8bf014603b045d06a79da0fdc2811f1f194cae6d4e59fe2cd4fd6c1091bc753a96fea6705cca30bbea67d7de16ad8c9e469ffe5da4e56d46cc232e3b95d1c7a8431630dc1620c55f8e5f925777ef224bae80db6a38b5fb66ae0b86854e79e0dcf3a5c6b6df5f85c4c605bf36ae529a857028965cd7857ad7158cb1acc56c87a14db9dadb3c5e37579ffc59ce1e463b9cd7f39b88af750e28926e582e40d1969f91107e4f0e8699a807b9cd9c3ada221e4acfed40422e9c79fda7acfb5dcc3f2834f081b02b7a4433a72c1f1c70cbb694d23b154337d33fe4cd46b62a517ae7afd0b2694192431f550f709deff859bb7c874b87efae23304db58c32d9bd89ca9e1b6886e3b534a3811cc5d4ab46f5e8ca75f505db484e683f420a99281d48b246d36605e13e0605ec72274a39fbb42e796a0412544f96c8ad741dd5a98480239a5abeae0e062f6dfbf56e08686bb99bfb9374ceed6c27c0a02c537bb3fcf99b648a35b489890c9703cc2bef945ba73162b085f5dd19e14791c079470422fe20866514f5fb372446fd1f8e7bd02e4f2fe728c2d117315fa38547db82d92f6cda4fa0b7f9d010531fe6df2046b1f4454c7bf6ee92b8c9faf45fed076f9972b254447896c591826cc0c92cc9c5ae231b1a7e37a533bd510794e8986f5ece3ed102a83fce91895eee34a3ecd96b916dab62aee4945af5d6faaee044c996436e6268acd9f780b4c1c48483a3fe274c203a78c45bc4557849617919f2546d976814a436808fa0b2f232cafb5f543f7ed7cf0989d15b64de6dfba625075fec58c80fb7f69b25e4233c22ae06ac9059fd1d413de1bce2c8c054a2274d29b3aa108af40cbc4b14510c95dc34b4e3d34bbcf18f4e5096d9764758216731d6ba87c5ec132a9cf67ca8b11b8c52d728a0f1eaeae5d6292c1742c28b32bb49e63587b94dbc78cf8a71ad314a54ed46cb29633a9c7da2035f14f7f716402daab42f5397ab0c1d96f22e2b247e946e2a74ad52779624b5fb439e957a1020ab2fe9e1fda884e6713a2750c57addd311af779fb59136c318c53ed51b1b267755fe17eba357030ce74fb4f9b25df86985a7d273120fcdf497a6a81dc12e12b3491eebb41d74dca28c54b15b912a2ce1182c992bc8cf822163255ce9abd97ca52d6d467db65d8ba8eab3c0850d7708ef67f0596485c00bdfe83862fbb1e700a42b99a73614d6b6621bd89ded2998cafda5c4019cba17dd07d2d2af41a9727c473bdd6f8f420e55a13df6407a63730410e700262345cb279bd1c6bc0a680e8aa30c1fe2311e207d4caa0a9ce4038bccac3bd8d667ec878b1f74a031ecaf6a42e32095de9b1e2334fd23d55bff4afdc84f2489762e1c0d32fd429ad63878a82bf0d3cfb482a343bf0a894b7d5e4bbc2e0808640f491e535188a8dba65037e90b8cf4c3835331818079f975c73ba7bf709b78add358c769932a8dae0202d96321277f2c6fb6946afbda1968a85cf4a4f8793810c2de19b1f5ea92dd12b75dd091f4dd96caacd5372207b8198ba92867c0b28259fcc86cabdec46cb8237873350039b5a91c48027641d5ee05612474e94d9f4b34e97eaed82fcbad9507c3cfb50d9ca61e5c836906c57f49fa5b69f03ca42a95d9bc94d6ff3c6fbf4a0de12017206b0cb3370f503c34c7edd3ef6a5863b5206778ca4f9c58f70a1689bf423540aed57f878d690620fa6f8274dc5bbdf2f394e1ac506f02f9f6bcec01b81ec032cc80b5e6cb248b417a0fffe4a59427a3a1fc0d485b7b3534f1f97c99222c1ea5c74a54ff738594610fda3bee72f00bb397f5f3ae58dd881d96375f0a584669f74612674707de6ad90f71a34f5e0a4f1c021573975388bd4a963002d7114f62f7b5a14b33706e900cd71ca906c43ceba8857a2e611a63c9025a1904ccb874d692c1c1247f1aeea7282a73446d1419f83404e644d551bcb6e1b885ee680c02a6f438c640d8f2adc786a85e30dc9ea2c200bb5c6d9732f206856c9fc89b208fe193351bd22c62d5a856346480fc750e3434367835d7bea556d3d50add926f0f7905e1cd7e27a48b0f83b09db2fb3b235a297c37aa034de37500e028e5f7bea82e79f9f8ed104ebcce1556c1cb9a9c0af7bd61508d1a9432f815510910ca4a3d4f25a3e15338cc939e8870dca028c40e1ba4ec37be8c727ea17bf29dc0c7fb75b0bf4cbb23f8782c027c4d152815e91f751a2313dcd6bea9fc8d79bbcab85975a17bffa6d78e0079308903e5851774fc0c6f204e3549bf419b6427ba6987716d3ddc03ede62806710ab99ddf432ebb3822082019c3dfa9199f1c455263a1c5c013e2529d5b63970ddae2351563698c241a64ca1c18185d2065d3181da84ed52ea11912073ac300ba0a377a4a0117c188d3d48381d1bc758d7575921acedc8a65a2f2e8db7f0295a25fa1a51a9ce942ac976d62f472a37f745709f32b641a10836a9169ab43d0b05483966775c646f99714c6087b3c7b2acd99dc5de86f0462ea0fc8e12b4c8e5379a2e0372b4d7b9bf7d812700081293fb9fdfe50a3f49e5a9f2f6792f3ce9fdd459823e2e3dc55caac80eb8ce4f1e227429387f707a0d68310bc1a1024cc6b963bbb52feb10e8a14b097474872120444602c3052ecb1be2de3e780bc1aecbd7e3c92ac84baa6b7dac5d9c95e581c0088a56e687e32eef3feccecf4c675b783e05e68a31736f4b0d7aa45125f0cac051fa093ff86879c1b2f8b5534e3bb4c630072300c619abcc6b02afced33999dfb6c843da1e54027442c3cdc125b42159f297d568825aec4c0562f27818fa5e231958032d5f00b07c1881aae2b3439e8e6d1d28d9c18dc1aa62a43604163f23c23dd85131f571cf1104da872003b370812c4ba20f8ecad935c5a07fa1918834def06a94210dff3d83e1f7782cfd9494c31b05bd0038dfe3a5afa10152e123ef492d15f7f59adf08e60ffa396b2463cda7e88a60664bcb238984cf21ecedc8332bfcb6277927f743ff48b8ff947751e39c4cd5fd94794e78d1226f0411609b61aeef33e37e52a4e5b645eeacfb1e528d29a950124f9e050a9b5e63498548f9672527e26da397e85cdda8feb185e853fe991608f65aa0fe2d82d57d51d8ecf50f49d6d85032acdda21f0624b284197209dd3684364019e0ed3462365ef3cce05d547dc046639517f7dbed8e15c603909578cb2c6ad21c6e1d1569e178a27228c8034a880a961d855d82719933151531c309698aca6acef0ae3fc490ce11d1a0f40d6151a0c4019238e72c1e41cc93901f91b862c2926d1f6044a64afbebd53b02c42a73b6b5a953b419ccc8daa00b5d78bd653cdf046675ea91ccda3ccefc6ed39c7d41a0b1b3d01b731733c08b321da8783a0bab86fe2078a482bdf164f7de7957bd419607d9e162c00d6470ec24918664c927e5c1ae7a4676bc5898c8b5046ec894d4d5d7c56995ed58772adb432f5cdd49b21a05389d521c8597a60dc1f346c8e836e7fd859a7319016db3c256dd67706275379184613e5c51304559cf4eeea96e658a42fe19c0141a6e3d5109871e9db63cd535c6fbbca62afc9dce9541a819cf88e8dd5e2945b90a7dfa9e60f6f187af29282512b9d61f1ec894d010755d708d05a751cbb2dd8fc3fa021e868db874fd7150747e0fabdaff5e0816c0ebbca7597a5fe7eca31dff02c5da0e456870d9e8a731409786936557d3feeb15990381004dfbe4fc3672742fae2ac9b63d1917ce697968aa0ebbbda00084eb14464887b290f8348bed46b66d01d2c66ca4579fbc295d447031882cc34663d8212df330da80a4ada009ac63d77c0f0e949d867529ba311233799f222778cc0160bcd4f39300ef020933f960e9ea61e6410f8845bdfbdd3d38d9a46385684af27405457c6558dbc5e9d88f07d8efdf803568be609e95fb4ebef0088aa2e1aa188d7bd98bea59193dc573c1c33295b56ca12eb7cc983a7ab5ec827b7c407f2931c68614fdf294285dd66adaee94c687bd54061c6e4e0d1fb54f5acb01b4441d5ebdd10fbf1d83f98967fabc3a2e5268c41c73bc57659957a4448cb4765d1a031a7a8974797277061c2a7bf3a19fa58a762bca85cca3e74bbaf5e887d966944ed71a84b8933509d757c0974a9dbbb3b8405f5ae96898dee6ffb5fa05d4d3de6477a407bdda7a4f00b101ae7da1d0d559a0e343d97d5efd7088e0a58d3b425ffe654b6bd191ec34717e6803def98f4e78d3280a1cc53baadb63be340d488f229849da62abf844aa185650c6d7459f2d357e4c3bf64b2dba75dce19d700d3c675bb170dc480eb0ff8a75f0b82a3fe772d772492ae008d9fb3821a862e5c4905382e3149815df35710048b2341bad68edc10cf26151bf1b3b0b077f281431ee73881a095f54fe1d084d3c4aeebf0039f66ad2a6ec191cd1978b36c18ecb59c2ebfd5e743c457fa310fc619534fccd12548552d58a0721aee95c565f1a7b057091c7eac6ea82cfaac92416e81b4a0f2ffbe7afb1736a79c91f5258dbce9cc9c8a1b24ad000468fbe26a33a93de1a608765036d879e6097c2ae19ff4080e31bc974821a3fbde614b1c1804138104972dd90242b5e02dd560c49929ef189af36b986b4a4e4833dbe577ae47472f2a30e477130be545ffe9bb302372bb415de2e4f4487a5d350a1b5f337b38ebc0e764a65af4d3790cf1369cf7a378076f9b12c1b1ea4def52e10d24e65e145a73378592b6cb6418282f64df10711dca0f0be957391d547e6054b67e2d94b9808827d13d6f2bdb8711e36cd7f7e0126920ba3f16a57cf5b8f848a900f4ce4fcc746cb16934d729d72d44ce3b82d19062ef860e60ed2db53c28444603e5ceab86ab5c4d36ca028b2737e2ab1416622a89bde62b369570c495d3a008d861c794841abf1040db45b8a44e7dd7b1f91efcde6d7b51fc12c9a30bc33ec1ca8c82369320c56d6ee4c586c313f83650dbe77be3a828502d9195d4cb8d9c31cc49a07ec04addfc5af7666bbcdb67041553ddce5490122a78a9554d1d4bc43c902ab5bb39f1deeefc245529d6b494dbfbeb2a056f56ef057a41b687a7d1edc4dc0794fd47f5f1e128bb3538eb0336b4ae10acfef5d91565110daa7b88ebf23f53bf95eecda04036aa9edfdbc5871be7141365198f9f8b27033a504911c27ee56e600a99f2469f83d828e08885c3b594ea52e6b5a7dc003efa4680e05507cb96a36e94cceea527408db04fe111dbc9e5b59453ba15fad663bf025d402f6dfba1f2f59591490b9aec30f225dd6241895b8744b14053a281e6c0ee242569cbf5f94b7938b28a673ffb2eb6519da1663d7947cebd37783d9d3e43a2917e394a8af4d3786955cca6f6ecbea420c31bfd3799ba8fbe4906ef17b97715b58cc999b3bbda5fc3e4e26d23e8163ac74e077d93ef9feb500646d2c002f944dbca8affb92702ee8c53e80c99e340f0ef2b594d362a77cb0c69b48fa1affa5aa64aa8836849e4d93241948325cffd56f210bcf83e7ff7785c920a33ef25f89d9d6e7168534f9a956a477f3ba47953d44f0cb53a522f4833e3c0fd9149d5e1f47f607b5e874a64998a99b73b66b76347d20f6865c068d7ea04cea71b9531b99317884388ca25e6ebd57c8571aec08699b73d055ad5aaba6b80ada5c0971add41da6f40f96870a4e3bd3c73bbd1d90022bbe0c9d9fd36f298b3f0bd389c36d51317433a6064f39edd5e7d55b17e118d763dfcd517e4bc6307aecdc0626b617c5b590bdec529959b869f381369ad9c97674799543c518a0c5989db08951e083265e03a1da91b66e887f0debe6aa4019e1f913802939276c4f110c74662e00ec17c22a7739edf85e8866e663b92f436457e091d2d26534df1ac997885a0b5ce7655e843cbfceff60dacaaa74365638a56a6f88d430c1712c884c3be41e4bd666db0e73c0c5bd064f54062646a13c102b3bf9a6453687c89293078ea6f9af6504a25e33984eee729e6ef89f8e731be88a77ffb710381e1e55670079b04e63661bf759408ab0a0f0261a5fdcc76634022662d29f187f7aa9b4775368cc82472fabccde2429fb42a7e6697aaf690dfd0af220250e932498c92419d94d2496fd3fb6573f3781b955c03f58165181b71e3131fd5eee8a6d722b5d3765200cf23e8669ce5a779f7697010644b2a50f0cc6496c26f60bd43c9793ced9f7cc6392eaf889ab994acc0d3fe9ba6dce1157ff97064836985633194d0e71ae89817e100ec89a39076609b64e590e243768905aa06b19689e53d14936f25753cc1679828629a4e49c542fb1a8c164d19f6d2ac0d2ee0e6122f60c7a6d43af063e9dc77053a76dc389ab61272793a9ec2e6216222eab17185fa80de6005dff1d57b1d6c4b98d5828e7d7817245db0181869b34e71cb0a5344830e80f491bbd3f2ae6c5a1f81aaad9288f7f2c005af9e1071b36d6f3e6f87058a7674283b9cdca16c6c926f6fb6c80832a1f879be597270c4b3951edf9d42db9dd79879d19e65715da5d816288cbdc4bae865e283c8a6d609bcf37060cbdde8935280c99b9811b43ca7b2402d600274e7fed80d055ef823fa3b1e94cae41d4dddb2be1a1ab4ec6af168ae2aae336191ed88d599f7f08de86364c55a4ee7e49e781c0a192a1bf982dfe5cf44f0ae217b4c749081cd7b030b2800517124ad788a6caa4f7dcf4544322cc3395a90854db2087de86364faa9daa3b9bdc6139e7218032fb139feb2806501fba26a47fb16fec3cef335ecaaa6ff9e556f6dcba69672f2bf27ef31c9b107d404f0f04ee40cfcf991f22222ef82b3cad23efb44f69d08054364c0a7fe79278bccf000caf6a644ed6c93e28e1c2080634c27f2aedb082ccfb2aa08d64f05ac3720cd1d84e35e0724d9418843f724086de50e353b659b4cab27aab80d52c1fadde6104a0e3f1a8fd8e4633e4ba7b0efeeedb5e53a9a3dce604ea6f978a750384996ea1999acd7e59748a10997b40a1c472d83271953e9350e2f39224de5ed718097e90304b33fe62b7a696d47812b4162f8ddeaab4218dc3c4ce4f4297c50ed1f09ea5d8aaad6e388faa5a673d17be7f3211b682c69d309c8c57a277c540998862fac418ed6d875cf636b236b2d3121dbb6c4e6b9c4f125f50a60a670e066dbc60edaff08b2ae15cb6970480b4bb506b073070979b4a96dd648cfa54316d4ae812fad1c9a45a1e3297e608f6fdd3008fbfd583c0a06a815dfc4d038c0f70f6a928e5b644011a1737426c40f54e6b1261592d90ccace37ac136a0345d6e71a9e2a1aa16c7a75393fe1fd23bb99eac1b8d49e0ff25a2adf42c733db38fd80a196b62b1b845b9c4ff36efa9cea48e60afe17698245b55134cf8e12fba9c9daf8a67939a3da41d15ee8472101a504c7d7ed6d3fe28312a23057a501dd911e17424e618cab0d16c68cf8dd6ab3e0a3806303bb2fd479782227516d358d19f2ea567d21aa1baa25c41024e46c6bf83fe4660b04955e9e2f3c30942bd1f79df62b3953d3bba513cb81234aa4f93c9516bf30d87394aa102831bce53f74d3dc2f36dbdcd74d640d83a46bcd87599ad2927cad515964ebd27fcb13b93e9a652096165c851a5fe9eb2fe91279b9252e3a685677115bf5c01787148618f09e1c6dcf76ee4453a781445ebb8fc22f2128cf545022664747c4be9a1399d9903caadfc333b6cb6b57032d8270f0ab246be261023e20e9e5f56162ab2ea478cd2d239d981612e400f099399c1ad3cbc5e7eada387a01b14fa19b612e1d5b4d0121c54bbb232934d86f8fd3e426ed74ba082c9990e45d80c858bf4d9ffed94b4cceb197d5a8ef1558778223e7ac01c28f11b300fa3ed84bf3f8b4e306618e213812c19021f5a30be2c5f25c9b309a351db5a32cef1d26d8cf2a4acbb87ba396b7b2273ada8be5b37588162f72ec61b76b6de9c27cb0cd27164100e7a8d345a9dfc30b5b9abf02c246be54106e91bb0c68c98b0a486a1153b15cb9819ea199ff46e75e0bdeab0b4cb6ffc6340cb15aacc4b1dfab1491a44a4e4cb5f4e2f8c10f01692c1ab5170e8280a90f380ac117f3055889adf48552a3d7d1464a4c21313f9585d88b437a25bc7aac5b0cb0f13119cd7f55a7942e327dcd729d5b578575d25cb27dd372fa232a8d44db1aa0472bfc1a0f53ee02d9ca80e611fa7ccfa51c433bda9577a027d617b644f327ceb31f96f8671cb13e13da190b40decc28f07b1b96612fd00ee2755003288a2db4302af18ac2bee5addf111f1018e77f2c0e9aec5a3b0158cf57337ff48f7129115f631aa5ce0ff78779faaa24eec9b9854c2370ae0025b6ad05b7d1da1a761a09b210ab297b018212b140187be667f5beca8bb03370cfcddff058e44503b77b322dccf01604dc799f9124df87a9d274eb9d1b85b5284cfd487bafeee3e0f34e922ce66895b0adba07af8c4c6f93480e183c1fe2004907f7884bb5d26686d65fb84d0a674b59ca0167f708d0b03a72b5af1fdc99d4a24352a33016b3d3201380d752201768aba3a10e8d834583fc1445835c59dd1e544df5d66f162df7499102b25f9fd7aa199b7adac48bf8f98e9cce9a1ebf16e37d69d8bb67adee4e64e994ae081996b0ec8d2dc9c9153608ab0327c1c7e2d1280dcbe31f3f56ce944a0789360f1b4131e7d85502bac44e2ef0393bc3157b67c66d83f6ded08fab9177bb00f3168517c702fa93492362a0ecb2c9e4fd6ffe19a7bd6dc1ab2ada7041b8cd06e27368f0cd2d03178a0091a3c57bda519fb52db6c7bb093943219d38e3de225e60827391dbe0fec0ffda0549fc2409d75c2cb9598c7693702791fa4db2a60f650c91171e256fabb12becb3e5bd7dcb1ad41e1e24f5bdb2aa7d0c6fcdd8513372bd2e25ee35c2a9e8cdc21f5a8032cb2db3090f77731ea9f5ca5a1fcb1fe5e4bb9ca4746a30405595ec224dc98e39236576555527dbe9b7f9d73a67405b048cf1647d0ec8696f3dbfce53081c0c42c4498a66cbb71075692852c435ad80b0385412ff10de4ee5f0c11fdf4aaf46d632e300c3f365df07a71c1959ccb02d7e7ad9da9463b872dd629fb0e7b6f1191f5d341974a13c6e5979d4edfa46021fa7796ce8ca1d34169141bdde58a07df23bd5806f698f8aadd579aed096cd651776c2055bf44d855e9492620d1e17aba9df6ecc4118991ce6f18b1394b213ec9c634f06fc9af865b0582a6574c1b50dd9afb6dc81c57e514479f18b6328fc05aafc43ff755d6de514f060cf7fe925de319eb99fb6ae05b75fbb1bcee774fea448349601807e9fa71e2994ac5f560c5803a119ef3acba58698abaac436b48960f3adbeddb41664d0763da76550c10bc63fc081de08cfce6786aab55367158908978d8a145c4e3e0d109d69a4f7ceeccbeb10296bf5b799010a1b2ad65f7afcc21197bd6a7aa267b3285720f094c26beb0ea6ef1b2bf834ff3749ed383ea6a54363b411e4829864a5eeee2d5d2100b83c8409cc00739cdd7933b167bb77bb500b3e9798a8cd73670885b157f82a5ebce245b23ddc064de99257df3eb407fda38638ef2f95739ececa1ec47e248f31f49e6fbf9fca56606751b0ab0a72d7f2b05f047d5eb9a011f08fbf62231f1cc286502ba38ce76b6a2e5d9ddd424bdf8aee8b7ddbe036faaeb607cef88af3953fd7301079051517a1606c802f5e561c740df578f93881c3837fac54c1c6525da5a6d6a5ce7cc368a3eb48911b18a0c8a47574ce9b4c66c8f178a8b8978f11769aa12487d3bfe2189bf8facac90193a9e9dbb8363bbb6097827aac80de4586b3cba48c013c1c7a389a584d5cf456eda3fb050617e38242c423e65985cf5c6379296374f230702b5b48d109ac6e97d0b9609f898fe629ba24aff7dc28cc926be71cbda6deca1c20a9e69a532f826f4a8fe1613fbf034b14aecb3de8e94366358792f8bc19c8c36051823c4398fbb16097d370aae6161a69ed757302d984535460f2a3971e356a1eabb074fbb341b15173ec42961f37d0da7c8ace29c3ebf6f7b081e93b48c032691b65efadabae7c9d5c3629f48ecaf44a8d3ff55e0a0ab838ad3e9626c713694552ba897e75d4dfb209b483871e0796569bb6e53e3d25cae2867970ab8d311aa6376d8d0b056aada49d269c77e707e686990770d59ae922231f4bbed2101c75ce630fa015c80b93c7dac227932336ccebf002f7b2e80df8f153dff81a7b091ad14a373ab744ccda425c4c0d474e16cc34e223e1d547dd310806b8babcde403afd29f6aa96eb0e6fbfccf9923936100ffbc494eeef8db3f85d4a819b2b4f744007ec487838d829ae36e6d8cda6f3d4320c6dd28357831be72dd41bbed87b73661509d3b71816bf1f84ae3dfc68076778e1ba36db9b5cf92a0828f4b755f71b57b920cadd227eaf16f423f7869f4561fb9f657390042922dd316cd6c308f73432c32d52f5ca6dbf19c00d0b9cd11ead9922f770aed319f365b873a0df2ec969aa3ec80a95c50fd8edf937defe1e67a5d52bfa94418388ab3f7df60b70d8e86a158facde2452996bc427cdf426120ba2ebe2e272df82b47f39857d522344a1aeb004c83b258211e03b314fde408ee6680e66cc686a2fd86099e3f478f16347ec7a5c48cb1d8c7c954e99af3c9fa4bb980455dc7c20c046d4c3fbcca91148e467b9454500c019f3c01c26e82e86e7297f7998c20a84ff7908fc3745f8fa9a36233531031d1ad96fd5bab07a3d721228cabd6c3cfdbbacb68b2352ff783298458b5bcdaa0b9ee3a992aa403564da8aaf8dcb05174f2a546c6482546591dcb57b12f08b72c3c45f70f915164a99543980339958ca6902ddfd17aad6bc498dd8e5ed203ec16c5922b40de69b36f69695171a3cf29d517799042d830b8ecf79c1277d6b70ffa40c94671ac8d27f61072009783c373e37bba7dfc2381e93ee594c1ca1985d55c4319faca8b794afa194f62a5aa3851fbaffb6fd94c41496f03cc80e98d9dd28bf8136d3d14f859dcc58a138c081119677946fc42bdd2edfb53201a034278a15fdfd40decc64066d5e4bc5411b183432e6944dc25595ee171d22ceb3dd71d8d05882cbf7aa0c7b4b0f523df3bcc178a4db739dcb41978973ab6a450e007f0661c54626ea225e42fc615cd517e74257fa5aee96dd073141e1c8b14d290eae8fa452467ea9a1bf4834038b4de1c2fdc7922b28673c484f85099f866277bc1ba39500dbeb417c68bbe67fc42f3e492a503b39a639f938854c01891213bcb719c2e79a2b5f5df5f0f368b757b005b9b63acf85963f8dd425d11fee2da015670155a59cf9642b71abea8cdfb7510900d9792b6bc3f8018644691e564905700e71e0072e87fce2741119c95909255d25b3a8248076e683ce36346c266210c39eea28c66e9591955c741d998e6838d08bf51c994204b18716647101b8a255db36a58453875f5957ca5d084f7ca0faa3319c622e26feb1ab2a12ef60bed2f1a7d75eeb5040aad96f1f84b9d6a67b2110d54a2a880bf0b36aa45e5829db31bd03eb760155a4a5a6d0cb4ed20c9b0e7508d8070d91e9f9fc90ee3ab3fb6281854a50478f72ecc4633f6919bc1a90b172e683cbf56ce5d74806f5ec9faa6af2f801e4e494ebb0340085a1a0814bd79a941ac0ccf7e4a1ce8f79e9037b0db3bcac503f33e57e3748b2bf0c80a2541e7d56ff9476921ada7b6bab707a5657a2fc98a58483e119eb670f5471e513ba863b233a121ab5c502de7fcda0785c878ed6bd6c640210b38ae53c4cfd3704c728f464cfbb1c2ef7e385b7b86e348a10ed8482df6d42a6762cb643260addeb32fc6d1697d84e145d8534ad4914c59952ffd82e8ff4d026d8f0403c45459cf033167018e35f0faaa11d4f2f5ffb17bf4ccf87a05d1c8de1db2372dfaefedcae42c0d30fb0e3e210a34e5cf058ce9edcb8280f288ce449537af7a44dd3fa05fab712ed1ad915b111a3335940a9fc106f530898ba2a1f7ee3afef8b0b8b94f16021c937194ae34aef4a1498ebc58d038b0775a7d54962da4e5ce4e7045f7c8d7d9c5668f3312adb3fbfb6c1ac17ceb3c31cc34aeb5739d4630e3b1fa4e68d797ed3fd9dda2e2cfe89a9f7c2f197bada1c3b74a71a5b5cada3d114322f819310915a9446621848d8105ab4776d255b2575f306d6913bfe54cb3e1e962a300b18c5d0884c619067d085f1c91550f9fda9ddd1ea4f06811b909f769136cb68c72c6de3a339d628c18a5b17af9473f2d8cd24171c1e756911611214f3ba29448b70024b04408661b1016f10ccaf5f2dac1460667af428c44d3e4f2b7c21f7ac53a5e601ca9db809a90ccfc50abd612a25e308ef8d4599bb2041bc270fa7055e7b0ec8ccb57f211e250f862b918078f8708cd020ef289d641626f40117adaaec28a8abfdacd074572e1938ed72b45e402973c68e55ec0dec745bea647540a3a86c34c06285c9fb004c07e2daddecf227dd21fbc4ff5c9073f0dc0da71faab857386807f517c5b8afadff2f25216044fb67a0094e23431c9658e63a86896539cf4ed7c1520e8868a0ec99b5c6bc5df869e04f7902d757ebd6e3596aa23675ee14b86938b8420f468adc98b3ca05a0f5204a640086ce6e62636fd9fcbdd24be5bedae17fa9f7cddeb27da3494b90b45f64e2e0a043b91df713545c35c4287b0face9fb1af01154cc576a9a5e67921d9b0afa225983ebbd0ad934f21bff333d8253f976cee605d9e0c7b9d358098e75b312c03593f4d99d0f8e01a1cdb59d22cec21dc9c7e404a7599cfd7c451aac2eba1655c6ed895bbeba018e5928d1054a74484519207b5d6825b52b0622030c0dab7618a3209557af016e46442a1860110b4b6d4a7f30a3ecfa147c7e6cf4081ca87b077daa31f640da831678bf25c865c01c716818a78acbd17ef1d2d6da7257840124f62301d4c31ae487ecf27424f5ef49c02b0ba3f103bddf7fc130a0d7fd73eebe8ef39a46d8f26a9d5ff21f4dd6329e0c4cbbeb2822eaa52026f560ff87c68e75a00083e238201f7f6c895c59965d3dda93ac7ddf612f8eb68d54aeda3e4361a67919f89e50e1eeee1839f93b1187b243439bb6309254c3074a22ae8fe62a108d290b303d85f4497046ec67447c42615d705c9143524a83e590e81bc0c5c906b67dff361088224388a92f210e927bf83e9c3fdb30c4c18dc5cff3cd3c15e20f4c5d712a58d359f3a0d3a9da0994fd4a8e8c98feecb266856e14254a197e1ba09da4e3162485f2c39286706c2312ba859cce2565c28bd851f6a8718cd68a1bce529d0c5108f68f8e257f22284c49fcec625cc60f6b8f6871c2658fbfde929b5d1bf31913395e9bcb336c9934dffc507e8d6c1ceab11bed3d61d630ea850fcdd2d6488e4ba73574532567fb279a347004d7a1a0e25c9093989e266091cc5e23f9440b5a95951e0938d1827dac4571d30c67652ec296c2991dcb14cf8966ff603bcd39927fd38b42e53f3e207fb65de5ae86d75eac10e57df3677cb6db2460441d65d3b9114bceeb2ce4c742539c751b448a57b7cfa7a69c15f68702557f6f7b5f3dd481b9e2874e665010c8b49550f8e34e0615a8fce9e61b37bcba021904ee1c305df1deaaeccd3ade492a2c45332b1a4bec4966475dce54bea9cc4ea2335897f5186fcb62076b800338bb11080b0bec7311aeaf31ed5b48652303e01e81b3a32681682ae514c2012463de08d33fe0be493da847e6e5a704828e7887be1658ed0fb5de4ebcc3478918abdd1dad810e835606d8bed3adbb456b7dce94f90900c8b57049fd77991d0cce5e0c28b35a576af408df104c0957172bd6d6cfff6ae4ae280fcf686c9b27538c3602c3589f77e51eae33140deff62ea1760c1a956f4b40795573f9c7faf28222e35f451446315858f56fc6e80cbedb89f9f6fd57dc13c4b65cca79a3ee96b95a5ad5de7ecf9dff9feb440dcbc5cd5489ef162e17b60d4382538ef488a75ecb1b517eb1a71e70fc7f112f3cb2811bbd456085e1aaa6177d217cf1df63da40ed0dc80fcc827c543feb7d58243f6f85cfec8110847fd4fbd9c585514fc71ec9d7105680c5b39b1e6e05547205822e0d81cf54bc2c1ac0a98ab083679edf01b4943290a163e6c2c7e881cabd502282b46edbe138e715c9e1ef10917f473af9b77408d8b39fbefb2baf905db64be883a996fd3a482574d3a5f95022554485241ae71bd2a19d6235ed542127eba134055c6ff3816114ff7927cf6d901c67ac6a2482753348af1d63ab19196b93fd91f704a5cca5ae1b6cb1fd71a201140a65ce456ec4166034d1034e7491eb957db91208c41acd78a21f6b54f413af9b5b84bd2df8d9c75294778149436cbeba29ed0cba8b836126c14e6d70f145ab49068cd0ebabcc7d6fb3f6fc8942cb23241a92ed380a949d7cc3174a4743a06be2972033eda143cc935e06352eaffeaf359cac189754097a27cd24c99ebb76eb44820bd21cfd059285b250a8a9d522f0f8e1314c8d10302d5d87d6ee2e2e4d9d3935abdae926fb55d040bac20a945112363321d1e431abd9d321ded3993d6380d96b788c5501df023fb4dc9ca15a9072445679ac457f1d79e37a78c46551a5705e1449ce71a15cca542af90e0ecacebf47495a53e1c0050cfeae02670c6a46191c0fbedff6b0622953f68c0ad9fec86ab27aebd3850d9b66d9cbd5f57b0c25933e8746eafaf9d6b70f24a11c5f16929e3958cebee3c35c7a66a0565df8db5057e808f31a35fa9623a4191c2dea712595215f8bf0d6b79b02d85526cabcec5a38fdc1aef4e30cb3a44e717cb9f0c0d900f7e8dc804498c99b4778b1a2c48f37327e74ef0cf9e4c3cf9f365ec5070e5689bccb2d1c26c7cecd0d9b0f34f75adf65917c1641725ef55b7fe951c883bc2d2552c84dbbf4ddd8a1bfb5e8f74fed5e4d7ee4c34ab938c52e1519914d91d87b1b7fedcfdd6a43181e7b920d3d621f8607a5d4122778edb93efc930e23c87066e4b9fb4ca89159cbf72f386832ea17c0af0c594e6a40f145aef44d1a9f3d0c9103bc7438bb92374ce6b11915db16aca0978b6bb093e0a829134c2eb46b79a2bc87c5704ebc39a160655b43a320ddad234be0109ed1c8e35808cd95f8804b557da2def0a2c7497a38972320fafde409cfed1b12c4a999a179713a1006d10ebe46c078fc39107e3db699584ab7b2b2cc24fc6f111c9fab28234887cb66c911053dbafab5b0ed3548a676ae20fae0986223ea29a16737d6b870bed4fccf484ca77ee254dc959e7f16e321d216fc2e3239adf04366bcc4fa1ec06a5d5fe42ddc1f83c750c336686234fbb4007eb36cfcdd9778973122b85734efefff875df716f22e00f25f4404068b45392fd34f63baeda6725d3ba483a0d7f5bed8381880bbcb20bf74a1056f1afe70e9b115d1b6e4b222b3b59eabf78f94853a34a9691d713e2a6422afb61fc7cc1716b3ec13414cea596bed1aee631f0054ddd6d94c644fcd9f40cb43f654681c6e63f2cfc5ce9d642ace454db12d4f3fd0e4abaa4250a01ccda8f158f7d1e885821ac946f10705e0f61e5afd2f4db5ae61fd2aeddbf856c90aaa258db70fc9bc8d20e8e0a259902b6655e8feface0290e29f1b49d9149c0813bd43f66aab8d8a1036ec78f9dbbaddf0038b6075053bc173d67afd1d3ccb607e354f7e30053e216bf54a94a921c67c24580d422bd15af3b27f40ccf01c0ee0ecaf80896cc0e6cdb0b26f55fdbdbcb5acda78b29f364e48cbbd45325b324450749148a37813391dcc0cdc84e26f094d5b1994ddd03d2dd45f88b9540af1f761dafe265079717d05d09e27577a4eaef499254a6711b6c693872b71464d11700db43513dba3733def219edebed34f9211f8d9d83c7ac0fe19f94533eb50f1104aaad8680b7fb39a87ed91f669f0f268638ced6c2f0da38b5be4cc8646005ab06a750672752a3f961b02338265e83ae7d9b191ba02912e24e6f738f87828225e1e09f0d1b30439d0808dff8bdda7128d693e8fe0dedd7d0426eb5d80935458a5c0cd61c59cd15d0cb58129bedb7566028c0b67cde92cf1712ea6ec334407d70300218733fb5a54eae43fd9854b6cfb833b98c5c302003c0fcbf5de9b108ed4029f445b1ca33a7d8f4db922c9eb7db067f179b42cb3a8a8361fc2507aecae693b48243bb9100743811a30113803c89430b6369f36ba683b4dc69d37dc5f216c2c46e1d3e7533d12dd02b72a798aa14a6f878cca46073288c52ba931a5528dde062fbd7b484cb777f091e6b16d06fa8bf054ab928c65032973d9a95e6832e8a5678a9d92e57327a3ebcd0243e7e0b35046627ccd7fb0b3f96599cc99c7bc4408ad7a4d3d3dd6b934045816db58778d911975751742729e92de9646f3d5f6cef139bd2344602a174c36f8e408054f246e5718d245268f29dc525689a54dcc55655f79c870982cc44293456fdf9ff763316f6c2b7de49e14c063f92d0cab45f5ff3a04496d173dc720cf1a2552b3fbb85228ed2e96f6ae22dcd662d7dc8a06feadacb4ed62bbe57762686addf55ea60285aa604bc548a1567545c2adf3828496d71e55d2487ae2f20295cb8e29696c9d78c6f3d2b29ff6b2ca19617c52cf0203c5b554f2fe16d7ed243fdf189bb17801301e74ecf69eeade03707303831f5da53537360b3bb6fd3851226542c652b1404e2e08710c3728f8925c8f7f1bf1e363071c5d76eaf19d76b69c4de7b46e590607c351c0f5febdbb523b38fe5dd32ae20a9d04637cc5ffa7fbbc291592ad0bfb62a96edd6fc3dafac3e1805daa8e650df9a3fb12dbc502fb26b3344e42b9b4de4126913844244e141b4bcf021bad39ca2117788d66f1d4062e9a35b2f9b819184de8834b5b9a73d1f5d607f1a0e0bb7aca172b94a52e920a37aa75da11c18c09ccb39136b7622c48b3c831dcb745ec9c0d16568faaa67b9627deb8c1d8bcc3b63c88727fdb469998136ba412927f2f464888a0ccba5b006b31ce71f946bfa7399b18e8e49490244409c6b723725ba8a40722bfe468bd47841d38fce6e7cfc3d05884c01d64185fffefb0c167b79309f83d9390503e5cbba4e9ae8b950700d38a8bb2b64c02901eb25af26723d0d7a84d52b13ae6ef047d594ac1678caaaaa5206e671cfe3aedab5fb71fd64d1502628975e91d38a7e5077a6b5548a21f523e9f3964180882c4d7669d66508f5c276127b50bf0beebc89592e9d0998ee7bbe7a6674ec511f7dcf631db67bf5cea496640abe4ee227b672290e53f41821989203bce325760274f27d3223bd82734ed7f26d56dcef9ca5f10169e3432fad597ca357ae6163ee25919b66d0ef7db9a74d656d4b7d898849b719eda00cccc4891b5ffb5ef35c9d9c90dac1ea433e155420513e786f2e28df0d08a854c02a994f0b1588ae2e12eece579d96d1724439a222b0d452cbebade6e7687a5e7d268ec9b93c70900d2ba4e46402c556c4dc46a8218667b9561cc0be22de60466f508c2d83f93a242d859867cc6ee3d3eb6fa9427ff581f5259539cdd6a8aea38766c130fb147625cf4d5c8ad8beeb5c8a3891f7e0aec7954bda8ae09ec8d9e4f6b5c735ef8478f4d4bbc6242be2f26cd4532e4dbc1ff3fb9a0ac6aabadff123586fab811793e830e4e7dd47b7e58a63b04b8f26e2b36d661a1ccfc0a014814048054c8d8f17a6c6521bda422cde1fd5bf2b9a54d3d4b6961db9441f9ac83e5dff4e09fc54eb704a9d2689101da486e5828bb73ba5df2919ddd0e7548e307bfc46c17bb75604ddba175643a2dabf504a9e834dc34bb995060f66b5fee06c1ba2fb241be7701f2068c3d230f2e263f70b195f1ef63af55300461a0d34be100249902f73cdde47bd178150a068b841334d3d9f93e9f1fa36929d1c4ad41523f3e50146686d1cfc33dfb5628898d927a92b688ade4f0b63e84864d4c0c1f32a1c93ad949608c3aec4a2e6ce1b7c8aa902fc43eb08afaa3886a3c0c594a5c1b003b31e0e179b2b7006a075d9e5133c248303ece5c2dd6feb8d271c34a14aed50c409729780aa57aa00a0804c39bcdf40c3a9a6b54f6dbe10f3b396f6b5a9dab5e6b304bba6cc38c433603dc81c205a5de29e0d076bb30b5c75727f115635a16d3565018fe9db2c6af6c6c398fee60d23a9393d7240a25b45586767edadeeecf86503ff7214b6ecb1f724f9221ecdd9829b799dbf7544e8adf8c05c29a23730c20fce0b0052259d6cfc3e9bb8a43a55a7965010a44625e9a579f948fc50a51b8393ded38f293f24afef72fa0e7041112edc382cf003df322a7c7232214d2bdf30ef40f098073f445b5b7b083538eebc6a7aeaa533aea9b8e4f1ea1e6c06a8b9c476f00ff5310abd831f684fdc318b363352a632517eae676747421c0389106d83777d34c602030741a812d1528e6202e21182a23a5a87389b44118f862b5698d37efd200143c36ec7c63816c84267ad61b0d7e45a3ba4ec9d5bef12642f26d98bd8d7c9f67508b489e9006cdafc0c36ab3fa14484f16e076f8179faf487d5abc865df88430096d44dba42008775ce556a618a8c0bbc53056102936af667b8f0e1fcb43bb7c578b11ec53a8c879d2f018842886fb7fb1d0d179217b325d06dbd37c52f611f5696a070ca99607130a78213031b3b3fb96a2059668b3d43a25a9ef45cdf5354d3d62f71fbbb6035b70020f060ec263497fc3b27515fb444e3651350193c14f12f1479e42d21a694b89a58b1a84b3e48499086d3c1087da5eaca1f43ebdd738ddf205a788d8509cd4d313327bd0c5ecaebbdc0453f691e83c9449ebe0e8ce68c4af941ffd485f59966a5e0d77e820369f2957d447da350039d0ac5b939a21a5fc6251f282eb310c392c77f013786243bb3969a87e3000ce0eb02ea0ca3040b86250bf45ea833b41202e62851aeeaa996ab1d58c7fcbfff39ba15edc28890d0724559161f63824f5403b282f4f8e80fb71f2ab06245a670aa856638afbfda7b7d365c68236ca7462e06f8bdb71b9a86e9fb9bec6c12790f3bb1acf5aa0b3f88a9a36d0724a26fd52e302a3fcfebd35da86da67abfc8cad68367e16c0495db191acf974f742240069ec95d00fadba05bef626759ebdf7bbc1899ba338aac8a71512c63db1fcbb530669ab9198c90f5076a64c4c772e69574cabc44db857565eec98366489e94177f043f7bac1e3d28e538b0fd56083699e2204c8f4931574027601c25301b35aede08b93d89976796427dfec8ce2179b3968d884043b839c2f2a75ce2018cbdcc513c0a83eff4a7dd97335175b52ef1098abd1744f7f0654376d108082d08ff3e4a64e75040f050aa1ab3ad1e8d91c24d5bc484d5d5c670df7036f8c21084a47d67ae15717f92b31ecc75b34eeb3281d9869936dd1fa952072344d03bd769b0dcae9f9e0db66123ab1962aa196deacf7e5ed786dc3ccb2873106127721f2834828a64b31b9328ee7b6b4adb6a63147dd7fc4076a6dd5f24d9724bb0964fbb1f270532da87dad2f4e013fbeb2c9dd021d4ec525bb548df94b3d63562a4bbd909de8585e50bdde7b4edcbe1911721b620ef904fda3e164f57317a525e2ff67fe8a702a37dc23b00582bbdc8d1c2283d1c2c76cdb10e567a00d24e493bde9b463abd15667c9803638d8808f608b8b9329313003efa0192a8ff61dc82a7133ad9aaca8a4a080ce5f8ad9d97306383faa82a654c8f95f13ccf28dc51718ad5410b498bf4c58f62b13a2f2681a3a1723d9e9b2c38190806df58fbc63f7f96716da9c4102325bf19717656bd558129cd6a9fbff53f3317a541da46d81139879aab9f0f198db502d1c443b7bcabc8c366f994fad5c84f52186c2d1c94e9d2d7cce0aad4ab4d6bf16e037f6dd6d6ab0b18519fb3c36f11cafcdf2e4d163cd499e49d9ab33bd2b18cc66c5fd03208f59d62bd0ad538cb5553a2ff853fc053b120a6872aceaf25b697aa2fdd4767ecee38fd779a129b27a2cd171a721b9063b6b347bc61471bb3586d67cda1ea179a224b1f0b5fab6cc60b2900c8898760f23926951b5438b3b8caf5b7ee8725034b723735a3a5fed69a817968ce0dda0b35ff54d7ff11073f9cbfeb4aa02c02a23d38bfaed760a9ec20da15af28ebe8762b8838609ec024c22b1997bccad153318b466432130191dd86dabd98dfc6978b46e354933abeaec43664100906c4649752bc5f960161b13d7e03e9f89aeaa8ae186a4c017022893f59e3665b08cd9befb062e91daef1eaa9d776ac2af9bf95d567c3e69a6d330d7f8d9bf7cc40fe30148ab554c7a5c978d19de873b7f856f5b0ec6bc40c1e1e87e65bb4c428a2e3a5d65d1d1ecfc485bcd3e89fc6bb71ec1fd78f18b7a897ba2b430d3f5278d075cef83ec014e32a27394a62bdcf640eae6e07dfdc8abe32fe7bbf4e3b27a50b67c2449acaf3422d7c925de2cae6cb1af4f58df81b4efaa97fc539818f14f81ef89cddba36711994938cd38c856c4b9287024e8a1279b968dd852dc06ca995d09fb34da6ec981691fcd85335007ecd6874308e560710b323a12b93dff14d8fcf9845fd4cb93a604640b1dc8a184af25560509b956e489f95f4eafe51d626c36c81076c0540d5c1214d5f970962b32efedffbd5cd2ecbd156be779d5972acc56f04f2dc41fdcef4b5dcb9842707106af297018672d051afc92c8ba7a1f7e8bbb987bfcc2d2eacc05f30cf46036120d5f1dc9d4bf9f09664e9b969de93aaaa96690e5f967880aa9ceb4db4a76b5ecde833241251a47f62d343c96a8fcbc5aa6a80015989b617bbc6f16bcdd6c1acf87a0c0d6b7a778cc057ba08dd6b2c4a9036da936a267575a19f566bc8f0a98a99f3f314113570aa9852a3136c0ae7c1a680761ee13cf8c88ff0eff9cb3b6b7e0aff9869a36c184468cf59afee85dd3d66e0c3b48e95525e35e08a0f7555999dae4963102be308a02f356bd9dfe713841f98e8f3d5ca6e0f7781697cb40baf25704da055d63c708dba0c7c087892c3f938f3bb85bfe03bc7d5a694e4b1f3a31b73e393dea26fef5040d14e2de2a26eea02231647ae83913d955ca7f3c98eb060c027fc5515bcd545b3683f81638c7bf5424ede7dfbbe3fb3b80bfaac9a91ce2300183c66ca736106edc53a854369fe783103c1fe4a3689769007e43e5ff30723e4c2d8c6d8e5c3dba8f9b0df706daccc8663e64619ee0b8ca1ad8e2e7790ba6793ef0b50aab119bc4bf855e9926e2ca912580ff5a37d70f11b260c9deb296a1b03f83dddbef0d83f96b10eadeb826b62e48ef9f7059baed773c54ba14ad5f5bce1de414cc58a23bc72af74fd325bc40b70e60cc314e94f903d8f6bd2eb7cb734e8f46efcafa38f9b4cb3c932a4e1074e1a9bed55b9b9bc1cca8b8fd2784cc935e55ef422ac06b2e508aa752476ac1804eac3cdffe1885c068147182225a1a7a83f1485d12fbf622891f5d6c5f28b762c6790b9d47cfe74e40ef05fcae2de7dd0cd8d875498122a16fa5fa3f35b0c10df34e6013bb51722ac4cebe8b60bc3067067a3780fe9707c72600e1f697a4116e8a7e1f48e5737d6a442c184ee23bf05721c66ce378b77b0088d0aa74c18fbccf53bf94b0090a6fef06781d30694be98030bab4088ef4ffc3bec42afdc447234375e9f5b7978f2cf6b4c770ac0bea44ae0255b2e6fc5d0fcede7ece2fbef4ec97c3d92e3a7d6971307757102aef20538f56c198e6c1be2e3b75fb5580a573d0979b4b715ce6ffcddded22dca27c558adbf99f2a1d74e4a144231f6107397fc400a8387a9fd3b05f420b85c3831a4585a348681cb156f51e13f3c611166a0f094696ed5855379d16a9d1552d78769373bcc0ecfefbfbc4e7cd88d6a982bfe80f3391445dea0248999a3db2a2584bd36dff1fb4c7823cfd5d3ad9d89071e590cd3d7e107331fe9c68440bf6a734b5b0bf3e822adb7f755a1194a1ebf1e5ef4044be55f89202436995715b0aae97cf530209713a72029ebd37cb9e183708d9a3e81276f59a31e882af983c94be0ecfabb4bb112fdf664e1b17599f39c7a08c8f4015d04c14ea27f0af1ecb1b0a7cba0685fa77b5187e6f39649280cb9a83ad5e2eb8ca10128eaa5e12f9260a28434d6b4a606c92f638113f3ebbd0982ef30f69f532b629e410e5ec3533f671acb2337b9cd2805bcf175763d3b46b024fbb6bb77afb852154ac382e854f663e64ca2da459b29a3cdf79e49fa723c57167ae2131355327b9584afe3f123cff187baa38b0fd08626bdef7f294be3304c4d00fad875b301a6d50138a482ae563fd727e36f24ea008395df30e818462cdf0d1c6d29e448089077e85df6db2745f7d927b68cb55ed81c3b3cbcb9b7c26e861a5892dd43326690ecbbb125e564e19cb6c21d0fcac02929c2ada34fbe9bda1d74a388b0a7bdf38d54e1169d1753bcda80aa6ba676bb7f4ae0ccf3fadcb2fb8a6ee420959d25af5bdf8f58e002a0ea37511afa512bc7a6568606cf5e49d39225796e5e22a9489694fcd09af51c34894e35bdc1e157834692a80f45c233848b0f7556c9cb2d7a7da9778c8563e8254a96591615a58a6dcf2bab82b61fe5816abe8d6f173e624d222b7c5fae1bbe76d710ce719f31d252e13bec4ff8f511380e7e3c7b389f2a3dc36dbdda1309598e290b70a12acaea586dcbd0407c2cb8fb3349dc7c2d126ce1a798c7312ad1b1673cdba9f187a25d12e8dd2ccac0c9b065d3f5d4ff95372a8ff32ea8e95d5d144244ae8bf163a4eb7df30257e90f55c0c73a9a2093498a91d9d57624b64f871d5a43555002010f1320d5a01c8857430ee25ef0a43d602d27f42c4ca43ef4be1752a397d1472f544aba712961b48ca5b482d83451963214af7d27b318b5fe894cdf54a7b007d9bf3c53b175e461608982f6c2bb2c95149cd6683fdc6cf2036274a21a2b66d5e73b11f9f3b3a4736fa60556c3322612bbf539df439b542b93a62909f34924b0d0d15178d6811cfe1dfd32fde50a0efc2669d904e6d4e226a7862dafc67527b00f1c33f4a0623348770bee61c87a8391a0694f4e6016d6f20ca2fa80fdcc9d1a093c4974ca525f69c53d669856802a5da3d337cfc5dad6b4d5ac0f58f8bc9263b62386e9210417fc013d061c98544f8b4550d5af4b41b0533524717b650d445beb516167cd64a6a23175305f96b1b3bf286ab30d53397d5ae9aafc7128fe441dd7d230f0860d508aca93910d37c3348b0f397d4f635e4b365e28d4e8335840e36e14d5e4060e1a3b6ce672ff386674765f5f8a5ebde343d183c408913ae0b70f8544611f7cfbe09aeebf08d9be8c824dbd83b9eab6ceb144764a752a1dc50d030fa4ab310c700db43db07bab36a65a18355f2bc4b0e0f4480b0776bf29f4592178e4ee7fe9c84747d2e742c6b3acec8b8f86624ca3f035dc6af7115a5312aec4265b3b20e6af93e9ee73a6ee99d834034c6ebfbc01ae99cd77b32246a55092e95557084d449d138528bd336458c34e7d95104adcfc34a16a2a84c6800668ec9b14cbb58445429d74dc4ae247f84d1cef0e88ef67b5165b0d7ae01dd040ce73e6286b478b11e3d89f76b6104db541636abbb63a4c32923d2dfcaaf6a3fb00c19392b08556812bc05ff5981102c1976e27207f2089fd42eeef832c4391ebc31b47e727d90b33986571afaaaca0d2069445e19f79ae785e996694f4c3feba8d7b36436fba64cfdf30055e439eaa2923216633d289e4f235182cbf1fbd6fd20288323be1ce1a75f20e17314b049529b0543099a01f668c66e60f7267d3f40fead0c16a432acbfdf5ef454599a1af307cd4931e53bf68f4226c997f84c0049af08c0da4f0adfeaebba6a58ba19e7a9262b29f1694881dfa2587aaa70906b024ab65a1c8773713b4e3cef33338af2857fa2fd64337d937fa6c7e0c789f69d5ecd42cefc07cfcf98622ddd7788d51f9b7e464a33a158a2e28724e9c72cedea9cf0ebbe884f129663242c09b0108272bdba282593de0b7e17dd20406ce74fb543da68e8516711d8f08b03d77407a1ad8ea696f3c5a6f05ee7fd47f02e073b33ee750fe5b70e38c68e2ed3186ca74671b20ddc3e6335cd5098fdd35ee2867cd25906e1808aa76c86998ff0ec8a4e2d7adb05603e00ac3531b42b4235f7e50bf5eaffcd20ee96c2e489ebe82bf544a0623ece70bf57d73bf90096540d369cb48bd041fcf8f6d5d96ff887e6d71e8a466f7563cf801f640bfc53a6e773b01f855e51c06d958d5e33b3904efa2f42248e2c453478fb12cf82959b1debf1d0c52ef1b2fe1853c1823e09aef08076fcef0b0a49dec781d8996f325de122b11b1c849f91c158c54265645c5528a0602e109090703496281f5364b391d1ff34a7bd65bbfe124467022a35371df76fad9591f5afcea376abafe595193524a8d3b90eb38f8721cf854c3d5e2c2ab410df02765fd3b2c343444ec3ec194e551adfe4897b80054a71f28c151f0242a194309bdc272b3f930dea8d12536e0e575e7bfeea96a58e0f1dc5c05cd73925e4e56c04c85629d063ee4fb3846876830fb9f94b92caaedc3da1a78ea3c4bf99cffe7fb3959716e19728840c75f61bb5adc9b076a39bca297df92deb8128abddc40c4c5d9bf057b5d109498a23f8e06a98728011edc1f811375e8786be65c5d20606e52bfcfec73fb9cbeac91373f6e804a14a78c435a8b381cf28d2deb3c0a54ec637c703dc44cf90f68e886b52f2db14e329d695ef8b0260e872aa4958afa09c92728abf334875fef9bf0b2c3eef3ec66a91bd597f878407db1ce8a94eeedc2de309799bde7ae8f9c187b62e91f8ce0fece55b8fbb1023cc270f8d4d7bc131d61a7871932f0e132f9e1f56338824ebb3a396afa0fe9d396f3e08e4e18e91319b81f3f2cd5ea95eb78421314543152a3f37052a43d682d63c98debdbf39aad759d91b181653a18c702f3eb99434aecc878e9bd739fa9fabfb79e5c2dbc552904654b53b859d834408aaff0490d22a6e4482d64089c1a1375a70e35a3ddc90db20562399fd024b66382d1c7728aebcc40dc0c73484ba4332e413df4613ba0e1932b24c02a7c26a7e7f7f7f2aaccbd13de7071dd88d890bcd5ff4521e8e0d346ab79ffddeaac02d62819cc90b35f33bb40a85ec88a2c7412ecf5d7f1be28e0533d5bea96aa85e4e958861fa4b7945a8846e00b2db41b353a1dd2b4ec2cf4a0c17bde6c65c7f1a5fc5803efdc5dbfd7cddf271a1d0324b395e305b79e2591c75ee41b34d8f683f41087e3352891c2c595a787e1712a4df982e014567355b8bf7e2776b7c47b4eeb6ea1daf253d198719ebc54bd8cd22e7b4bd904038fbc049a2752de7e80716429b04c6754e469d2ee496f025d21c418f40d936abfc8355d8fd6bb8df97db3d7c831d97ac224ec8ff6381a85b73ee4ba39ce4232ecb58db97b18cf9721cc661687db11e9d181a2f264a4e01b8b927656e05ad99c69a99d335d8c310d6eb85a7810cb7768223d3146c3088db8ba021fa188344cc8f707eb67ae133d2719d3d3dfda41ed502180dfcf312e26c806228be28dfcaba46b2d50a3c1d99685e78615d53b2fc26a3d923bc712f07233d2023ba50fdebb5084fb64ac0067b64494de9fb4ede8825968074eb3ee6ce3a83953031385aadf4da7e972671cadb07d22c2dd2a9a8026d4ae3934dcc6f00bf1defb9c23556ee56b436f1934ec30923e67e0ed02080d80ea3c256a9040bcc10fec6e2d9bad4487fc283fc6afb21dbfd2609b0a08f85fd4400243f361685da51bd05d8ebb87f8c93537a86a66586c63807277eda8f04fbe4025b746de77f64c8651ccaf57184ab85bf713a651707852cb550eec07c4fcc3904b9d882755707876c03ca946fd60425cc699081733808e5420202ae7f19747d5cd74c1c4078e0fe8722b7ee63ed5348ef559fff635e389ce23975236194a980802aad7f3045e5443683051b9bfdb019904e4b8cd8b25e14fb5a802dd9cb3dec4056b8095a74cc497474b3dd2f6d0cdae7c9580728b035819d862af69059b4d17f94d12268411b0d1b1088bf0cd6270a385e889a9853ce8a35e24361de5ef4439bb932fc198e3e46e163289c2240f422749a5d20319a12a16b49d853c6ed7fed3e2e7bb2490cb65ff5e757de5ec6ea1b3f613c285899b149259ddf932cda17415fc604150ae52e5ae486a444d739f6849510a578f7c5fd7b1fc188f7d60c013bba626cb67033d2f7c4ebfc2b6eda9cee6856f9e0b9f1a1a112c5f2c4d55d5a8565f973082379c22382b13e2fb080cda3fedc99c9dd26ae71d96b8a6ba3ef941e6e03024aa916547fc76188506390bb5b58e6ae7b6924a8a791f283fda50c5a7e7f1943d089dde3646e7e8fe50f627cc80ccf876b6db469387062a8142f19f39bec1af29e428c8a7809aaf586830f48a85e5ce4fa5bb87ec451d5c061f1a3efb92a52e1412e90ffb96238d65806fec76c7d502dcaed142eae96829b0080251020b0f5ba0c132a22ee7e39ee44fad68b9eac228526b0e2f03c13f6e36c72a8c5cd3691e73bbd555dbb7d640919f4a4a7c7e3a1e8754a5d72c5b8f3aeb5ba86ae547e8a412cda51fd1431803e9e5737ba9c42c9354282d0c64f414311ac7dd3049978f1cdaf2310de53e4f417c7344e26cb2e272f13aecaee8b2e3505ae75c8ce6818a78489e777768cf3307c04c1743527782e61f12eb89abee4e1d60ce83351dd3633253a745e00c72129ea5e65cfdde2b4b94aa6da955c353fa4d15b4ef555d64b1d3d726aec6a846d9800eddabbbd40276917b91d7a73173145a51fb2400763ef2082f016e9755f74c53d662d8215d51af296cab9c09546b77109c1c60ebfb467ec3059123ff364c3448fc5664525cadb884fc990e38a59badee4fc8f0792cb429c9df7b9bb247288371a7d901cf1420c53c182b3ede5847a595323d96aa6484e7b42c5d5fab97595024a53f7c411217abf0a75ac1ba36735d7c996aa27bc0d83145cfd0a52df735f229f3845662315f3a9811b8dc8644fff5e751056841eaf09803564afdf7bfa9aded0030c9520ce460e5346f031f331da10cea0d8d83e279933364568922be114b4a39e38af5329c1d2b47be9c7778b082abb378a82fc12601117b38e8c87343033881ae60f419760f62aa21926759082c7fd18a7a5d4398c364754e2aa9abd631fb8497f39c177c297fc7bc6291bbc1774de98fe0de4437ebf44364db208bbd2a07a641829b04ed4014b3e5069c0320a537e1e6cfcfdadce8796c03307f2aa67819e881d1ee62bd51a006aa039a91d89d3633540463016f6462ade2c6ddc651009425b967dee34990cdd085a2ea53374cf965d3fc6c8408036a9eff38c02705360506378100262bc7b87fdecc80f2e6211643784a3d9bf24a3e68f6b3ec239617b7096a645260f1a30afa521ad8b40e93c2a600118ef69735a14706d99d0559900a998c93b4f6fa86ee9a72cc814c31431a5420e02c7c33cd2d2e3b7487e537970d13d3936ceab7193ff96faed292afe774069a8ae5652e85b98ac505f234916b45d10d21a73a1034e0d142fbdec1004fb529f6d8412f48d0c62ae3dd2750c0bb3889b1a5bf85d307ada92c090031ee6f7a078bf759afbb7e65dc91cbd1484c13c9d57a2c67f43013803b342969b3638f0fed3eb6078015bbcc599676149c21e8f6a5fbc633d547e3676b826b9a8eaeffe4dbfd54ed6b95547b9e88b128fc00f9518d2538022416c2234dd7a44c0f4aee89a499cf60273faedbd68780eeb7d2960bf40356c142713b3bcb83134166baea3ba7871823c4159d39cbbaa43efd955861fb28069bde2cb040382126ed9398027a0a9c1aa97f43beaa00b53704cc821b728552b644ff64da5e2af7fd6ea7355e2c9eb876af19c0a13ca7df6e0f62d1474a17bba2462eb386716c14154c0b18451879a8058c2192fb4c32661be346f8aaf597e60948ff8218bfdc331dbb6871d95e51c4f1ee4e5c4143361197359ace35552040c533690f0c70e85a7019edd8b584c31c6a71600f05b6dd29d5111c11a8b91d515cc4e65dda978095b76a5bf5b3b5858daa06560fde455f2924cbc77ebc84cc26ad6bb33bd1374677fb1ac1d5a65a81eb90e2eb838ce7ae74c212b72e961bd92dc33f512e07795a52b6cfe29ada63bffb73fd2442895e0c987c45afab554116f618f78f652fbc57a88d709f33a072b7f3b1ff773e5777762b35679acdc5d0ef2fe27a2fefc58861317193c6104b556bea94ee357747d6db10e57c66c2b7de10af72444276c0ab42e1e628c4f128030649ee9cd017a14557a483e3dd7a7f2500b2d8cfe5c747c1b10252b581ff0e8702227ba454ed3e9553546a6f72fe2274f3344323afdcedf58d7d1a064993a95b416489cfe280aebe9dd435f784e99c9e5103a92604c446e19a67cb3ed032ebcf129e61ce980e5a6dbd560baefb48576a74c73a86daf13fba9308b88d06cd2198b744cdaa606bb0da55ccc67dd4adaf766ab421b1d5b51b408e47c643ac66208130f2d5f0654cd5ae9e03e505706a88dbadc46801aba19624ebbdbd951795eed868e4cdbb6a8822f688ec45efe24f099c3c7af5ac2e017f44ea4d00bd21becd66909ca55c249485d6450f44de322cce30d17b6cf24a2c27fddaa8702c1593d9a0d6095c9e8cb9fadae6b4c8dbd7d0ed22cf703909de1f3fd0cfd3880c0e4f896d9162e6d13116fdab1b757445d5e2d823c057ecbb0842ca872a0ebb1d17fbb4732189473dc6683343633a4d1924ac1ee52ac079129335f75f5ee9cf9722471d1117532629efe83dc875cc0e9df19516d68eb080a3720a56fef512d6d319bcb058ecb29f1fa9b09f0d4465e50ae53e0846f9af7e0cb77de534437b8063aa09dfbea5c3fc9718461c11537bdbaacf7a783ea3a5c187a8fd41ac99670b729ab4861a2574aace4e9cd0233fadf59a634b75e15bd0c767690db5e6b5e0e20d356222f1731eeaf2b060363dfd50909b45a3e209c24da27a70b3ce3710ca7f4e1e74eced7d3ff605f742f5511d9e18ab6de31218f36d6d7eb761cea73bcaa96a7bca6b75ed09d4b3c450306c220d6708700adf92ad48d615d9ae5da1bf47277693f01d2b27039fad376aa5bc73d4962cdec9c08347daac6efc719cfbbc9d816b7a2d9cfba8c3be67afc67d50a13692345f330c9832a29bc5b6a80513b063642a5ea2eae1b85e79c22df586bd6f7c8b8391e22aca23e41620492a854ef304930f154520323280641559dae759fd9ba382651ce2944a68d9ed66572cd2128cecce5195c44d72cb99ccc00479bd8e15a0bdb140cc7f8277f0f2f84951be8f724608992a1b8cae1822c96419a4f6d282f35e7951ca677003518bf0b8cbb18fbd5a09c8b9c7bbe224a16040b5aa74bed1a304701775487c10980f571e0948fbaddb89b4e29309870f3ed452d108986c548c926f2be3544b2abfeed486a3446dc3ee4c58ed0c4f9a9efc054c6b0747f2b86ae75358043a43d8a44743f981d88956e1edc2311bec44057e87fe4ac772e700167c4afe335b063b04de4c865ffcf60a1c6abf754d8cf820b58f8ffad89d291e50cad832125238b34df5b6f261d7769ed97ebc9b6683c7e7cad1c8865df70f12034c613024295f0ce3613fd79722751b25a99ab08ab944d4565dc21f864dfd473b6f0578c0bd1128db05efa7d6fd18c15597329b8ebdb9cddfeec34ec9e0158aa96c26cd58f5b41711aa7356104032925ccd0e17c820c35a236938e6174931f09c38973b93c6af2c58025f621b888020c337f37e642c8156d8e46fad153bb9c74e251cc511d145f57414eaba14201bc75b33a7b3d970d0ef4ab8e089f54516963b124b74a787980310ee6a4f908a32dc50f420b22c45096913f4fd9ae6d6d7de5dc1b5a807ef61dda9338641e912f9ec28387deadab5d5131635d0ca28954a3fdd8b6797d740f78871b46eb242c9ce7944b5e6b06afb9df6981beae2218d96692508eb56a12997eeae92ee1c9fd65618caba7b4b84e490f722a1605db3ed2caf469246c14598a7a15593006bd21e540bf96333a98ac69c3e62119acc4a87b5cafca9e5fb52526351e7651986ef8c9c4d9d3f15edac1ac7e73a420f83b599dbe31ecbbdeb8e2947f8aa3471edc1593abe100cc462e16a5692da005c8c227cff4693e65311196d86f96493148a03ac31349da98d39a7eb8051991531080bc2c94051da46d444f27932f1feaa7813f447b113aec6969168df1e31309b6265d51e5a2d4be677c968f42094032e811ba8183f5ffa9d72bebf90843f0f0932d54dd2a455857d124c81124d8a485433abb1f15a91123e4054d4edf7347cec65ed7cbbe252a81a5d414b0d83aec166b179909baaf96688fab5cbe2a08c92e3c85f13405b3968085a3430bfe43316978699a22d1c600e2565227851e9e1e73569e4f3d8ed71a86f5b8e6d9af58d9e3f7528ba75937d87367e5df0a3f7232ea7117a40aa0f25d0651918f81b77344000330db74f37f7818aadfe90e232e86adb6fad8ffac99fa6c7087772527dbcc58da0384276808f7654726c99fa337b8c282e0716288d3740acb84c21077ef3ea88dba69f87cc7eb6b52d5f26d68b15184416824f4195dd22b845f0d589ce0c26820f2b4087f22477f491d1d7588c01b500b365a41cc9207399dd285059e399313989c63d2156be6e97d664d9dbc11c650c59246ae346278279f7e99e3c896086205d3ca9c739fe6b9a399e8e888fcdb171de8283690bfe85fe0552e7860328cb059cf35b2a7a8a723b6a4cf7621780356af03bd726653068a52ae52a28deb9813fe1f9b0e9aab06a643e1131519c16f928d94ff021446d31598be9bcedd429df4efb9473b2faf73ab4a5afdeb6f7e22afaa65625e380da89accd272740ca67960cd02c72c82cdca4a57d890bc6dc5fcb8889cea3cba692b5f11fd24cef37b69ae1b3965f15e744442079dced6873c39b93200a71954bd68f5457040cd55e6fed87d75b67aadba156dff088423d0609f3000179fba4d7b2372bf3ca2147ac06881ec3cc841d096403ce1f3c52a9f027cf5069cdd54819ed96cfadcee8fae7ecd0e0847782579c3f287133a570b81e0ff2fd185d88d2ca41a9c41fb1bc5c4a294d07197fcec8e3aeddb32ccd5ed4c7f7d48d1c5228404d50b4a9972531fdb9b235692c2a5069a180d37752fcceb96d96369d6959e58a66a711a18e8b1fe667172bf26d7e0e7e272dbc221d07ed970e4e9e7e0d54e07688575a4212720e0374ef71d68df435d30e6eb7a1e12f9f2726a6d6999c9ae9697917d605c4334753ed9b2dbd3d852830dd6dee940e17146028949e02f789688ffbf5b42813d68c1a58332286904336649f8cdd2a4a99139de4bdb13c28d727f009e4bb22f18096593b3591575dc9949a254b883c2938c81a985874d1c3fd8469f29c831d7921548a4b92476d8868a6f0b49fc188f06f383d5afb48e2f790b34fd935b7bd9580d4a81d06996470bbe0873e8c3287ae2daa9012ae638a7ad5aa12104ae9071e0a2c79bd15600320bb50e5aae885c30db57fe5990ce800ee0cc085bc1ea585a863eabcd596ceb860a155de643d1e5a32fcda2a02849afb235c3ee50897375be992d19980af12575292c8982992e73f55ee63012219b008d67b20112fbf5d26be1f726f1b1d5e290ebbbeafe0ba8c6ca8f1c79bdf1cc5234d993638c5bb4a79d89bb43462249a9472bc2fb714c9c0b2e50f1bf64ce75a1830808cae7d1787168b7f43299fb1fdcc1ebdaf20946a74b5e1c7955de65ceb045a5dc6d3a59410cec25a22cec5227766df4e7e7cb9614708caa3108d9533695e06c05b910808fb03019464ab7579ba4bd98193a7ff1352860f12bc6824f23a30ceadcc6bbd3ee6bc5772d7489ed655efbc92446f26e8f355ab3e7ecd92155523cf26a98f029f02c422f0750a3a7b4d4ffe33c3c64a532bdd5b62faa5cf8c5eb9387cb23647740d77aadeddf20d0d094247fcaa7f8a23e42a83e7abc397f00b772e9ed6acbfc3551ce749b4c5f953920dc2af48d53834f68752189207d2a741cc716d80eed111767749fd511e773dcfa7321bebdf389ca5164e0150ebf40cb263ab24f386f932accf8f882acda27319cb478954ab32b83ba31cff07883a0d2a35448627c293811055033ddf5dfc315fc59aab6510fd4e8afc3cb077d6f0b562b52b7d75d7f6cac60407c2a2ec87dc9a95be6ae48224162696e70ee47f88c88dd2eba7bd2c7aed5db426bd67019e56d75491a8e029b06f694568909aeb528240016ad6741e1118277714c3fb01a41335dc00d2b4a38c5082da5f89da2e0c4aceafc74d1128c7fe5c640bbdd688d9b7846f76293bdf48fea7f595c6df189c84fe9c9b7fa15deba4ed97d4158ded028aae6299b4cface4745ed05c3ec27f888dc3e836165606877ca5b78817ac1c530618b011f89a0e39e7a2c665e1166d76e16a5ea2129f9c5ff3f80768e9bc71f17747e3cde0255fe0bed6787c4bd06ba62e35e6e701d9032fca3e2801f274200ecc6dbc2ba2f2fc724f4afd5e5488c61584efcda6a43cb927582ab706b880c7e70e55003cb3ec8692618a57310e955ce0dde20137e257c68e34b9356ceb09d4b8ae3534e906bdd2c1a525ef8588f941648aed9fde084315a9e18b2d1be3547684b75ff443a4a5764fba5e0d61c72fb846d62987a635cf7e0256e5345927c6205ad712dea02c5d75d3540bfe8a1890fdfa58629535aa1f0e61098bca06c87cea3aa42c8e23eb8c2e224f231f947b5c5b3346143c892bb741df4b03c0761472a765b588fb305d4c14a39f41c1a20c8f51d5569a5ef5a333ab16fbb36c356845f6b7dffe4dcc3af80ada78e589a9142a05420b06e83300dfe9a01aad413a9707889e34f6e0e1a596bf2f9799cc1e703a61dc3a90477d10bdb87882e5e7962dc011a911fca204853e1daeff4bef785af1c4cc93ec7b2592eddc80ac128efdb104bcedc0ce879d146cc8102929871b5141fda47c3176b808046f2c95921ea22d59a2045b02d147a13fecc74492380808ad4b7505b6caf77825019b2a356b6dc9ac558ec405f0726dbe0b596604457553a9b33db1ee8baa4e89a3da9c62ca0c7d78bae70145f7d58078ce454da600b5dff32872a1cf817aa504417a92327b0362ddfd5b3bc03365078c3e581e80fa2d61a69a61a3150440c535bafc43f1e889f53b52fa169448652bb00e01325d24afce052e5f8ffbf5ec4b6ce88fda74dad15ae371c5d01a28a536c034c451b8366716205619415d78db6847d83a68c1b444590b09c1c6551b8ea0b606cff277d28a6073259f09adaae649d7aefa6b7b9b4f328fcf1aca69a5d7a55542d67e805c75b3743ce73cfbb33e24cc5872af42ae8a34747b17a7a18b0d18f9ed1cb7747bb81d0e1c8d023e8113ec8f5c2a4472171cdf151511ad13aa9b9f5bc07b7aeabf2ba4b8f3efab32e760b84abd3bb451742f3effc1339e594762d2caa0366c7e52dee1d5a1e9675c773736f9924820500643f69f0496e2c27600a20b067a6d2b5c54718392f7f955b9bfb34a116674c0f096eae53245f9fa30bbf1c31a5ca4ca00f489544a92a50f1d5b4c7dfb80b64be9c51321a8656be5c6b08a16dc5b089f5312a604092743df104fe3548f11b0b9199b8a93c627dd8a67193275a7dd62c165b095fb4623bf56451ac5bb166eb65d98572b5d6842563bef9d922f18fee5e3dc70d59ce4866c3334266ad08d61425665f9217fa2b4aed9e33e40d088ce95030c833b115ea4ee949891b8165b4b2532eb3522926266a60e41fcf5972f0258677476284cc9d8f4aa2032c3274c22aa478e05b78ee4e5aa854e130a47a6b27135350f884b7ec42e7cca5aaf89cac49d7cf02af7285b5bdd5124f64bf798804212e4a135776f0ea33cf213043609057838e7c2f928d864df17616c9f60a7e5ce2af5b4e422f0fd953be58ddc354b6b856419054f4fd604ed317b5d1e0014cdb407f5d572e2c910374d7103ffda899464495bd01e087ed0125873de89c81109ef1b87183b85464e069a093927a8029b60392550ae95dca0f9be2b572222237afc539746958308c6d1ab1b7bcc5d4d71a44f42d6967a2cd9ea2d4a293a8339a78355cccf70bc0cf80b6148fbf6962e6323eb2eb34c10eaf9ff1b449c9a4ee9c904dcdc148bcd151d5737dcea8f5e9812b6373c024fadc27d94418a8766b1f58268ec84b95cb1d19410b4f0054a84dfa7f323ab792317ae21bf98339825e7b4b57a83de6d336d9890e76e52d0e871a7ca730bf2cb464800aa3e04a666d96ccf777e443b60f720e639dedc43a026f336d0470b8669150beb4667faff6d74a4b3e1a380cc635538e4fb0fd5c1fce67bc416feb0881ae60e0fcb3de365ad2771f41cf102e4746b89eebe9d1a0c915d1657d40f3ff1785d25eae83703ab380fdc63c65d7a560b7aed611db7960765b4fa6f50218ca09c135dba7b6efebde49c803e56c46ac0ad14d5ae08d00e0cc3c98253a2bf64cbb71fcaf42f5abfb9a131e2f27fe6ba625ed5c5855abcae56b6ca1e003dad80fc9dc5dfc189965eec163bafc5edc927eea943e5e3c9e88b099bcefd34faa9b7cd1229053e82f83693a72ab5402159610029d40ef253015fd7eb355f31b66d8da4526f0f128804e2b40ce17c6181b1b0b41a2005250b1c47ef5eef3dd4829e91fac8e337d5e3e78bbb5a9d42c8dbf73732756ef0dd88e20ac73f528a70655058c6ae5207e3edd63eab9f8bed43aea5f6e2a100bbcc8ff20c121d335fcd0eccefc6dc478f65cf901ad1169964756845ffaa169951119e3c35b06c4769bc98f47f5e8f5c8d72655e9b0f259f99e8c6ef0d537fd4f3c4046c901535605e5eea32cb4b0a1ce338dcffd4d832a40ba0acfde2cca254ab0f974cf7e28b1156af2680a31ddd01fc83fcc053b8230ac5406a6737685ac7d4974e73ec78dcadf9d501bed2b4d2c1bb78bc9c0a896fc379b8b44b7f93697d864db9b82f7cf8c8c0b1d81038854858f069399c050b1f871791e78a9f45667ef1b7a8362a4ea5ecfdd203218feec3e56c5a7711f39f327b0475d20ca54ab924f3f91d6b0d20e5972edcb5d01903be9839dceb98e384cb59ba7c416f7ce724daa2489354f7db82f180998df7bf6ff43a95e4091d81eec91e8d341049f5a877ed724bfede29edd22ebfd0a374a854612b3e64e5a7134a47ea9d3f7e1d51b97125c1e334419777066489110fd4a71533614a9e05e8ce94c20d26083b7f1bb4e024acc719d55d49c82fcce77fed5f5d83a4f1030c6f7d359120af07f2ab81eb6cb88f1770655b765f3805dc0ea760eb273caaae292d4f48a63983af39726023f9fd52bb2870b4cddc09db97a0183bf0a6765db67379f615b088a72e9ee84b6909dddf0ab82553b959be95db36642dbcfaa403b725a96231420e595dc9f70c5d8d5f466d51d1aa9ad701f9060a99c19f9b4db07be65615feb0a58440ba1ab4a9abc77d4893913192537171871c1651153c620ab8f9db9c95bb74536f5f0ae8db3147f197911785aeeb33a92f69413bf60f97c1b81cbc71cacace9c158c864c6610bc9d66e1149c432d2c7e5187faa95b20e3666acfbc37df854f0faed933d38a85662cee7d59f32618c59f2263c46533f0199b067d1c44d6fac2fa978b7008cdb53de9743575b337d18612454be71b7c9c6c4cc51ac00562c7313e9a8d8e3654eb314b3ae797228acd32dfe35515390f5074cbad1dc3996408608c3de48a82365a3978bfd045a290b7405a3eae0a7b234e8b8bd42adad57cd0fad1b25be65f8b9eb112410cc32310e079422500f7dfadc4126938c8181ff9d59995770cba4fbe9bbb1941f4c82e12b745a109b662b5868a4beeb6ebfec87c4853b4f0511e12f3fe0ecad11f5e8c63a30b61a547941100be529a0a3d301d58b7fb72802b9bbdb17ce1d41f67a3b11c92829dc24badb3004fcf7aaf3bd48f1d4486790c97b60040a0f982462a18ca1f1e7df9fb69754b428341de6a6ac447145101d6d021b8cadcab6789f46a6463a2469e64bfd6ca0f3e5f50693cd616d5b43f3c6e11fa79026c2b0a693d9c00bc0f84378e9adb70af9ea00d8e6607cd542e9594adf98442cdfc23a92e5633e2d024472a8d9ecfde870f92d468d321f53c445cb26b37eab22fbd0d99b93263012a66216346b0460bf5cb984faca9a5fc4f87474cbfc047eb8eab512d3ec9bacc15fed9fe8d7b4f2081703b12bbbe3d473408d2705c0d2212e2f40bb1a0f9d1d1769312eee6d8ca59ca725411e023485229b25d9af0a602f41dfbe888f9858c05c7860abb07ccbf11545712c680c62b3de5282aced2d06287b556f26333bb2bc289913c7846a60a7b92b300fb7da8037fc635758728df13f93064cdeb786446578255f8024e9b5a7cff4c8b31cfc9c097aacb00dbbd27d686c9c7e006303a15e35910eb77c3554ab6bfe2583f8d5b7d0cc6bdeb202cca3eb96ea5b99a4f51eb05b1b42f25d06c320f7bd721a087518b200162b0e7fcfb2a14935ecd4ce17ea6694915bc6c1061433c600c00641a551913443ee4f719d4fc689fb70f41a56e29c383d507086ea3ca35e3f4cf509171c0222eabae358e9ea1086cebe7999f487d7e8c0ec7e48127913b4cc48a07a4b1e802e8bee266461b8d0c9003b3e72d93750895cf18bad85d8f2171ec5107f0f122fee47d9f9be9175f802d10e208160b6e06fb4949a358d76f797ed13fb9237db68b870d1c5e69f23af54f591d52a43b781af12c3a635e75830e004cb6f86178a967f296bcf4b8d72ec43edb2dbf475f09281c0bab8f62bf8e9abbc450ff820a7e4e173c31514a76383b225e4d768954a08bd3698a3b2c51a95df4addb1aacfa525004511b7ab9d9e5b0a7b214b3e04614ac0b94a124128d421af541ffb3328b3028cecd22fa7c9702407b04a0063144dadd6fc3cda1688eda004eb2cc536a14dabbb50c18bb453a1d0360fdc2d6bef2650267983e33a0b04aa1b4619869149009c993d9c52906bd6975a3a8e200cd6b128b514ab8eec1db9989b6c2fab9e937416fdd16452af70be97f4dda4f7bee79aaccaa06696efe401334af986c2985630109536ea0e205645e3cc069ee09ea98c203c89dc85fe698d3b15e4bd6e3804c1a5cb52b97a766daa3242edebe20f30585668e175126236bc051d079ee368da600b2000c1f0ba8a3b4e0161dee60810e845cd335457b94a56e47947ad5c89a8cc64d8c59b1a1e05dd2ca6d89b49de923d7632aad7b6e56c1a866d6088ad90a25ab55f9189b23b72ca6494ad1b4b1c51fb76c444cd66e4cbfdf9fc5916914c6add8f68e2cf755e1a59f42ca31efab8efc550e1c2b86f9a21e3ef1ceed952cf2b4d46821276ecc4adc138d6ae17f70fac04ad3e950cc063733535f23dafa56fc906e07452ab0d6525e551be0871c70c146575ff8c538dd3a9448f0fe7621dc1e4dc8b1d025b62a2aaa599e49f72b981b0fa9818c922d95e32d77091c6467b843ccf572ff07134881c117684770d2bc0ae5dbaca65bb6129915ea0a05feb24b5b137515a50ebd58cb832c38e2fb2021571984bd2e489f2f85653bcf06c0ae4abd03e455a2089467bf7b578ed6dac52bcda71f3474b31575c6eef2567ed8926412f38a35568c300e1053c56bd2dee6bfc633abd4bea6d36fcc4067bf500adb0c27328c242dc18b1ccd0cfe224deeb7f3142b815d88d771af67b55366b29e4626a0d1823e5c17442260162b96f3694cad4e1da154dca99252d6f80c98a4e0d9b3b9639f28be357c894a5110fb8a6f0721a8ac14e935382dfe45300d147741d44b22fb31e85ad24fc17ce9e1ac7d05e2f7e2e87ae25ac862b1c9a20239a299a151de4c0e2319f7dd671b39e90a0113ad46bb387ddc1d73dfc9b04b750cafffe00ec6572178774435fbed7f80d25a6e4fe864561902bbcbaef7e0e883735b8daa2a4fc0c5b435961ba59e401af38d962325486016fdf56edcb32fd3ea08317b99a6f5f41410aa472fe32042b7f693573880dc2e288255aee3895315b27f369416656dc8a743f9e78547760f75ad29893d62909bdd155208a75e764e0ec20e37a5affd972875dd33933205a22eb74fa85f6c5545c2a576f8082ba78ff9c49176a0146539d69728749fc5aa4dde82c419963cb37e9557c42d067d30540b154230070dab54f2cd4d81cbb36fe9094997c2c32ac5fc703f371b3191d374b9847b431f63aa611980fed625def4fab172bd613e3567caacd3f1eb63e6a2c2277ea13c4ef369f32fd5fb0c5700e02979fd37f58f4d64184931ed0d3e7e6c78c8f034f7131a68a16126c9d51f5c09df4b4749f050f9a078f9f53e7f59a80dbb63293e60820ec7822da3d72d03d4edefe64b17b80b4f5fb0e4928328dd886932556e469746e04750c5802dc1ff75e79d767a2c79fa873e7e94f81e83b703b4ec51ece495672fa64fb42f9b0a3b3a57a680ecd53338ec60d663de1dde144dfa316555b9c4c957b0cb02ce053d3df5b8e589af530c90f1ae360ef904af9b629aab9cd027a0650c8f8b7703b095a5e2d6e62eb5b99610b84c80f3eea4bc8fbf5be8e8b0001c666ed3844d6e3adf741f257af9730dd931a04300f16434790a766e70f0f722f87c71e4bbc000ad809ea76416ecd3b23b0e3abf7a4482db6dee59046f62cd2c30f0cfd7711d27657aef6d78288bae207b29d1475604ae11efee8ca7a463b6a15b0d91bf45338b7ed80c79e60b2fd6d39e7c9b81a14b72919a5aa1bffb974a088f82875556d6de1dafcc2a936a2ec7dce8b5d068e3d95dfae6caa7f9c557e4be69ce843ba96c6b0b1cadc4fec712e92836fcf500eb82645d4ed35ff5dd79c24fe5c0ef3e5d6a889d71627fb1c926e6d4c67d280c94b9a4adc7731a8039307486bf0fdb106d71ce46b38697255d2a970f320b407718a5c6429ab4c1ac790aa15cf974a49ce5fbff836a58d855be40ed8ff46e9727b8f655d47b0779c0f62dc3fc8eba69bf5dbf9fbcdbca89368f1bc9d8e2287df102d2aac2e834b64c3f19b5b05e2fd42579efe3bf9523b1b6b089414b47f9822e8be3be9d0eb5f77f5a048e496f8290887df546c1febb65bc49c00aa6d2b4a3a33d46cf3194925d3695e485a6b62d3a728515d949ab91494b4a8e42749df8508233e687cc02995226bafc737b2e3985160354bd9b841c924d22a9baaabecfded58cf87e8feb5ebfae844f82cbdae76737cf4fe211302bfea6f8971ab4d73aaa8ba96e4c2cae0c7bdbf5fff6db890d7577d226003afb72303bd0116e8e08ce82a7caaeee127c1367b2ed43543a9818fa3b218379dbd5ee74e740bc99abe20a53880d3ce81e2d3f7e90ce466812533dcb4252a43f60f159c5f67c3e8145f9426ed2549e492dc2b22221b21162ca116ff4a47464c2710ebf861c8a3095471201c24a6d04d0de68f631dab7b122bbb017fe3d5b21d4ce2284e9bfd25f474794f732edc6a5bf671c5b0247538cd5d062fb25819081f4d742f2e6ac9dfb978a77cef82065c00bcfaa84a932a33cc0453355f2dac9f0340c368be5c2fa457562cb57d9ac4623465a2451179785e116a2425066fa86fdef7189ee8b30f3953bdf6a68b28d3b98764eda98d414bfc6dc3a26506fbbcbbd9c8d1d06df30840650ce316f093e148f16229d023595c87deb5456970d856ded78fec7db46fe7d2d9ed0335dee38258a1e297e69ac41ffcf8048daaf482952117f8270da629ffd6c494f1ec615a04746b1935fceb06419a3d5d1308a4fc8df6cd5b89e4533d22a9c2a0806a013df0ca8f116c0f539692c87656693848f4d2b47c664f1245521061be417d74b060609df43a5a4264e1f380fe3e01b452253046562a5780d4033b24639242b41d9f60d27a3ad9e501a85bf82bb4d8c37a3e2ee9ad31f8b7f9e6aed2955abbc0729882a2a6f8ee115a386511ccf0f78a3ebc5cab75b00dd3121dc69d32a5e47f0f08dd13af6e6dae98c4fd98e638e79ab91cdc9e634af9e9fc35acfe75c3b59800140182020a22be3eb81903eda913323c161b021313638f72a208ead3d8c82ed08c1e2af83fbf4524c28f63c1c8f134f17efd75d397b12b2ea7ed472ef948cd73581a4266a19f3b05c721d39aa2799557f057b5d070e408b6463df814a76ded590062ce03fb689b2f57e2551f45be4b554545b58b7b6f28d55a6cd533fd16cea046e67ae329648d3f7e238113c6e8c0cb5ce1ffa6173c72bbdc82aa2407ff9cf8b9e1a61259740cb5507d1ca62f82014621452bd8fc8dc6608fed2096fa1eced8a9c40027f22f4fc0016b95e0291f9d506b8138abeb690ba19d17e911261d06d58c09176a9fa044f204d41cf78e8d6aac355771c3048d02d4aad52540c2a45e8261ae105f20a4a90ceaa9bafa8bc46cdccff0ecfc29bd5a859c521838f15aaa85bd7e41c684d24c0f16886096daf88d5f50d7fa91bc1d77be376618aea1c741c059c697ac416d207e4dfaea42609de9e046a073168483b59e4149da9682b80dccc4a0acd7bf6bae2aa8aea58f3a8e2b643ea0b09d964831f6375c469cf6adace5f558456579e7e13d2873d5d9eef9462da4368c926c7dc4f75d1ea3b0546ad90614757263c7f9f1cf99f2764ba31c01a7dc50591b827899bc6462ee189af225d24cf212e050bf0116a75f8f78807fd7b04e899eb12b80c949e1f697e359add3cb4ecb81797402b5d83f583f811f12e0ad362ce647aee58e1bb6248153def8e6febe967da709ebca3d3d6e35b697b9f68b33e5263b5b5e997fe7831db045232b4a382a34eb860b03a76805b9784c68f4c24231e5dc5720877d8253881c545d8ed53ed9bfe6a1fc0909434be2f8e070dec8e02c86b428c28cbfb89ed1c2fdbff260a81f0608f513e1373ea1d396fb3aed67b7c33a386e4bfaa31387dd554c174b0b9ea38583349757a7e4d3b03e6afe17ed1fd94ed8740e33f0823d5d758f3f19fcfabf42da6e37898df15c53434826ebe144805ee936fa9d8c0f554c888477df49e288a50cada98bb10d623feba6765fba36289df999b1e135d63af693a1a4e47adff7cf3d32fe2280e92ffd39c1c405a835b9d944ff13af52fd1a940e57b7846716689fa4a0ce25694b1314dacd489009fcddd7ba3dfaecb8659b46fe404118bfc04259810ca7d1325d6d281c568fe4a4df8450d74d0a8c45657a1f180f8cbbca2de32c44d2d23b486764c39f79a30a16cd82982e659483306867b78152658560b2a2a652bce0986d7edc28571cdd4bd3450a27ae1a926b11468dcf0adca7e5fccc22c4e5e18bdc422995b1826111d456f99b09b022f6147a14ac69bf13b4d0130ca9381af2f50a6faac8651c0bd4e366f6124eb9ff38445035986765452cf3c662880cae132c63ae39c69076dcc02091c315934b2d2fca56aeb92c3d35ff209d5719bb240c8c17fc2a68d809b38e37a9fc42a971f2f68ccf339e6a8ba97e224f514599f70c80d86231efad7014eca93da1fc8de8974c49076f0c98ea65052c32b14e5644bf1d5962c7e3980b56d5d01b46a13358bbb75745a41fad38c0a015319c3b23b9e8a28bdd05034c0a5b0020c93f00bc0bfc9619842ca9d7029deeb4de95855b625ce43d7a2fc183bd2b29f608fa53cba9132994cd1788f0493666e445a7f82c565d4055755c8bef0606e97761b9d3d63171dd168c6ea7b1294aeb9a7503638f3a636f5e0e34cd9fa0e899bd3d714808a433f2caea4128f6c58911595fa0a73a18edb318a98e40be2c7c9455d1197cc5e4dc54daaab19d9cdb466d2ab541406c23e5b581934066f2d1c58786be14a5e01f4f7c91a4fe5f11fdd963ea90a9a94e2fd17ed8cb13190e70622d0454b253a311b57f41f3a058b377191605a78afaefb489b0d353b1b35a3c1f572427b42efe1cdb67ca51fa13d885dfe96fb5fc9747e944a7554778da51c114af283961d2cea9c57655400281a94c18089ee4269f17ef748c5f884c1692e28f0d087da42ce0ff0ab10f9f6528f58cf9c9eade886119a2fddd1d79d1e599cd86575ec941348a9f2f380ca2138a6901b6815a0e1ba51798e934c4825c695d0bcec0f57349dd8c082f31a312a8fa22f11f058768150fa961abb8aa3a6e8588e39e66c13ae1cc84a6a9a04633ecbcca33dcbbffda2d416dc2461c20c7f2adece9d0d9221bb755b0a6eb083bc27a763fcca41e8fa2f9a28468b229929f9af3ee650f300bd9d25d448b9fd28a01cdc461e3e001a6622dbf196d932c23792340c631f051a524c6d4948ce24c9cdfb30a177a203b0501d5c09162f72bf100ffabcd18da2ff2a9a8e601579531cd042eb0c29d0725099255f4eb388a12a61c830b8d1137531bd60a6a4cffc198dc625abab1dc9739bb9960b7135828155ec1dfcaf6e3cbd33b0ba79775ae212556b300b7410cab997d6e076a1ae725bf5e5f4f7258d6f01e8bd5552f59aa7ca1614adbece19efdf18a414934013674430ed3c3131a13be34d45551b9f82f7a1366d18c09bf9720dcc253c74810b9fdb3bcba6a8fd7dd5be7ab42a1e83baba4a00fc80aa996f4128ae4fbc25df60eaf0c29d466abece76aeedd3c59237b326d3668e7bd7c44b48249e3bd1da21e76a9a860608a490fc0eda1c46db08a4fa09584f062e13c6bf5cbde84b691b8b61fc00279dc2758a02f5e4b9b98d8083d973bd1d575ea0aaa7eef7737ab1a85c66d0fbf6d60a02a6808a8c74058d3af0ded32d1d699be2860f24cf0cf5028e2520ee40ff75ec2f3fe4ff1d1a22c59849d73819288b0b25c09e45e5949deb210838047ec9e74269c89fa4a1a5fee669a0374a64a89615c1c4a7469d3c617cedcf5ff5f7f63dc79a6b1c26897128e11ed9493d7e4c173eb2ea2f281158ac6905e922a3ef460eba6714de1b19305d85e010c0e568e8a748c7033740dba1628450e42dc4a7ff85d9c39fa25d904b804314c800019e1c4d3b1d3fb7fa33fa546b99b5de9311a10c64c43a39358e2ff1c47d41e2bb0dc963361c3d2112888c7101986ccefbbd324b7907fb33378a971f2be02c9f778d6048cf7af6b4703b13e3c530646da4ab918dbf8b3993e3997597fdad7b502618b67758840e3277f977007930b813ebf4ceb752622c857014702f3d17c79efb1fc3a6673dbb0ccf77c8c0ecab1b9051883c62c96270c80c7e14e6a8b5e4f34d3e4b78d752ac2490838c01e71dc69e6a1480c7671e6ebeb5c19542b2bb779b988dc2f7a94e2e521ba3ee3040b0ba89228ae339d6545b3e32296f76df4236424de2f93a671b5cba9006c90c7d43dfd60f9cc056d95bb6c49900947caf332ceef0c57332980323211cb338fe450fa2c78d3330bf50c374d19e4dc099bc50f790f3264ac5e212798aafc63bee0817246ba1137bce8c9c6884adb201414f231b1512f79afa915125cee67838b02974ddf1f41ffd1eff1f38448c256ba8224328c1c8cab866c2decabde6e510ce29f56a41d634f5a79b02f67febf15075d1658d95b95fda02d535746af8e041d9906cf077c68f322cd1b70d3c9225c15ddcb956b844a5d88efb9d2d95fd3cd498d16479d917b01b5f08bda4e299827d00eabb9778dcb5d1806f932f9c3e0bc37d62e46c961d2dd0bab638ad4dc1d03aaa776e32b491f4a1824177d0eecc887acf34bde7bdf41387a7ae9e26f7ca031ca021e8b7c0b02cae590ba8fde92deb68609e866ad5171793f253a43dae0ef24f304174718089a4aeeb52a0101270fd1f97e359b09983094d72f3c4e20416bd3e1203d8da52aa92e51e81deb8b4fe49ebb8032585d24f7fc57625c812eb793ddf1bdd2b0f85658b599eafd4cdb4bf7187af9d26b363a608bf8b3009034fd77ae4e2a61392a6677dc3a0a656729a72bfe0f73d2012cd7008c880960ea5091b0c858bdaa5fc8451d72eaa4e965d9c4050b43900ce03dce672d6a3736057e68e1628d0c02dfb58a50d972074619170c206884f9994afeec742d66ad480f5467e79792bc0479adce715a5bde66178c6ebbe3e26fa9b2f663aa0f525e01f6ce72456f1236e351da46c921ff47fb9acea7b9d7df66303c4beefeff88ac81b3409c02be2f611e27fb80b334320f21a6235d33a00b6cc14985ce32cf92845c25058aa43216c56bf0391dba0d08822e6b373e994ef44269507558792d9630a4eead14205a38ddfd362bdfaea968f78ad6e921d1c981002c1e05f6e55555d0f2f6be9e9370b08b2851ec9c0b6bbaf796fbcc38e1f79ccd6db7f446861a70edf8f92c31f2a300b407024614605e149d31f03123160b518ad2c2c1bf8ce818b6b4537810c819cd87d6ba0c985d6fd826dd2b4294f708a94038e7570f8ab29957ad9e33e4f72a40649b80197687e8f6e4027c70cc54612ff3ff9da4b89797f85b7f21658dd7dc95a1633dcfdbdb273c879ea461fc287aa55f883fa265c59a045377bfa75cb875fa46d85dfcd68374c317291d0abf9ef9a65e25b61cc8d03960cfd1cc1868f079957cb2df72f63803b43b93bd7b0040a61dfcc05836cc365ddb411c5ea604a658c5121171fc89a2af6ebe97dc170423399506bc11916ac0cf27b83cf0b434b7412e17cc5e9b19f6850cf0ff1f77ea0b408a413b31e562a573922a01b30250f736381a17153180167bdd9c9c91b3314d9c7f7707a0d4bf6d55cba340f20a5403dd590bb0e0eb8083b7f48c2ef3b89a28b7c2eb495f57f854753d676e26847330c448d2e99e53388706dcb4d4453ac3826c751f856167e60acb0926b72820a2cd21055f077ab619f4fd59048016555e0011bc8c0454d91bfa003b0c67b0c83052a74fc03e7c6b08483c84572fb01c09e2fe87f4467ed0d68f5413ceee2357c8bd5efff92c6d168f540f5f29001d6e9505ea424be90214d2dfd201686107875ca891ddbb9e77828c3e5ab61a3a18472500c1a86b01f0eb10f414d5611e132bb9886025d3c862a84300a413297f969a5af2a3cffb1743bba81ad3c08ac465dd97b471afb43747657a5b66f1369f2819aa38a8a8282d84cef66e51a4be58d7a0969c57a6268343f46ea83a1bf2c919797724fd384335904b7401e54fd0cf3bc4feb33ca30e2484646c40c14a69a536330486550aa9967eadeb1ddd8b45a67814b8e4c47087768413fef6635c47e190730917c6d3690071c26e5adeecfa44c31f7b95233c4279983f6b8d185f175f02875369d986ac7223712c1ecfdd9330731d7309700b3cfe9b834ec295a62c98b594e273c3b094cffbc2d4060a06369cbde04f7c069ecccd3626419c4474cd1379b50e04b3c8e80c581f31c2e5e6a22ce66c660d30016e0ebe8483179a8ca705285f9df3843a5b1f28bca897a3ceefd6fb7ea1de0506f502fc7e6132b4467bb1a5e5298e2b41bb7f62fd6ecc720da6c9a39148d5e1389fdc291254bb90cdcfe14a781746a397c02803e5221321bd0e84e02950a12d2f8e29cd5ce02d87af2eebbcc9a0a030ac8c65d54347416c6700212666e83500688fb63218dd62126eb5c17f0682f1848c424b6fb2f4354432afd2b68aca44454a002ee7cd428deef76b11f0718221636a939d619b1a8c6146e45e7b859ab87e18432ddc161a85b63025ae33426127355972f12d4371853772c7c291cc8357ae474a6416634aecef78026e521fca3f535df1d6c7b2dab1a0defca562c8ff3deca53786e3513baf4125ac8af63bcc6f93258b310976e7575481b3a16c6679dd392620d16aaa0f39e5e64efa15af41e0d3cfff159f86429eaafe48bb38076e13c861534597698a731f9d6ef97a2906c8904c411b66f2a9009320f547be4d7a3fde6dec3ed2f5ccc4c3a4e2d39dcd1e3422f5a8c22d1edd502ca834b1ef2f662b380af07db572f3b77f70bc64e7d28d969987fae08b59cc98375eeae549416835660851127c008c5082bad335c76b03ed46d78896faf46818cb26df061092bb7ccba873cecdb6b350b14af2da14cd24d703fa156b3e0ef83a02037fc53a9a660f566e9ce596e923b79e7a567287e49eee5754da4904dd7f6bcf19cc24bb7935e5476f36f245586186fd78f023050dd83efb7be1d6ce9ed1df2cc712444c8f2bc06cb7b00edc6059e5f06bcea1f0720bb79b56ecb6d6bdd0b8259655a87ce3a09e39be580f84f99b369f0d450aa08d7b977ed64638923fb1bd578786849be1406692257031893334f3888130ecd482d22fe9b029a0e1093fa87d6fea790682830bc8b596ccd7165176a04b46ac9fcf6c0cac44d8b7928954e199a1f2b5e6402fc284e784d216fc4a48f90bdbc0635ac3b97c35aa10fe521722ea9d90b0099bb944f37fddd687c89af18c3e3c8ab031272dd4cd3df5b603e3d28a4870af3743f642a98b7f20089df55f3a1119f4db93d301594a5c482f8e6ed3609c55b4be7bc9b010fda0a25804e2d0cdd8137c339713a1b21c38539bbbbbc86452faeeebf3dcc86fbc7e3111413417c6bc495ebec2101537c9ffb489534dee1af6b42b18d55f3916ec05d2bdec265e768025a9a59ed470518f14d6f37cce8a0d10687b75ebe0b5cd48a88e8d68944c9ce15df1d1689806e6c070aa8b26f294e158411cbc99178d5a9217f920099d563f33125915d719cfd4a1cdce167eb9ac2cc35146bc17f1cebe37dc4d156503080ad53251a19c7429bcdb3b237a1c7c91ba62a0661be64dea649051c8a20a3dceb7bc115b17c2a218c66ed12449ad657c6af2a31869f6eac0045cff8633805443c1d6c1caed76bd1461dc10e2c827f331cba7b582bfcc76ee2720882dac655d5eb5f5e3a53e7c52dc8074abf505661f8db6c65d0abcfe70f3ab8523550ba3e697fed7dbac410b78bc0f0ebb253dae4ccb88078ac85feb0102671e1609a134227795a97c7c5ce6fc90aa82bc1bc2e0c5fe833137f37ea4fe404f6b4179d85a0330967fe8b827cc139d6aeac9ec7758bc7048021043acd72d6893ca0979c4600e94b8dff72a4461dc8e8ee3032539c0827bef3c93d45c6351433cb77a50bec3dbeb477d9d5f03ecc86bd38a158f9c272e6a495682601dc8db19bbea00bb62bf5bdda4ae1c0977f5d1730bbbfb05fbaa6520ddb6c58a05267eb0196f7c8d6f9b63c0a5f8674a7ec94ae197060801fc6c778e9b833e1d1161410fc6066180a482d505f789368558a041a87ca21539d30c168ba76030be88df14759b3490663e175249c8c35c3a1f8f507d9976e2e2545c850e99b5cb0ced87ada9821aec7a4a3039890195e11e9b9479f15cdc912b8636643650809454c1284f2b04b67384675362823c0541b72e3eb693cf96805c061f970e433d0599242aeb264f19e9739ae5dfe0b3f4906c38f6b67555c4f3641113d80e1ae20d7e82412a9bf42b0d40bd3ccb83f0dc44821130f81ab4e04a76c0635a094ad6e6a45c2a7473dc2302a6b8c0591979de2240ed56ccabffcb869c01f708f972f851aba68d6b121d6e1aef45eaa7702334a2b05ed17ab84b8c1a30d3b2951e73b1905fcb63532c603e0476fc166addeb80154f152f7f88aedbff12a8861329887af9917758ddac71dce4b9085866494ea956de500c8e73e7e853e9803fcd6c63f40af16bd778bf0ca19fcd00a81932676d2d38da9a6f0302b48eb2ad7b38e058aae8214077da182b45758a516819848a969375823a52b93fd9b8d561dcabdadbea796bdd677df41b99a3b03f8f871f52534466408e2fa9cab4964b55f732ecb013a4152cd6223cbcffcf115cae677a2b87035cddae1156f88dbe9a9d0a8a8cb6dd7985e757c223e0600f7110365c9923b798e79e2e21c3eec169b000877c51a40f7301e1a2059854bbf65d11ac34aa75a40e910dd476a3b3fdcb331c03026211a8eded0ac1c7486ff6999b40cf217e6529d8804f9242ce22075710984adfed3c7727bc0adce71d0ae94b75e862dbf5df05d9f573da191ff9e5d68188c856d1b540cc56aa2eea4ce7515375e83d3387821ef05f473d12ccb6f3226887eb8f3282f1d738c23bc251e7fec3b9262d84e39eba295e739d2705f0ac75003522585189d1f8310992e202a47b091c764000d0a17bcb846143f0f49f4e42cbeb343a001559824ec4b0848fb249fc64ec9ae164b364181d7d1fe58c0a986cf4588071342bea550d54d38fabcc5c7058335b7dec649cb3cb961c2e808889dcc02d17c48e28ef79ca929343b8574b9339ab3313276f10091623ffba11f5d2a66dbc1e082dfca3a2b6cb9f7b574eea5671f5a7fc6e5d191ab188ecf37ae1208c31816a917e79af9ad8d797b616706076dc16fabb0369690dee4953444d250767452cf46aaddf63036029ce656a1a4e0391556fd5b8fde943ac92d12cd363eb6b56d1df31c0c9858a8fae10ea3b0d433077fd729c376f271ec9a94e9756ed7eca60e731ab6a43d1bcdbc80e51007eb776301589e9b2af6eadd6995fc9db3f947127d196bc5dd9192f3547b992cbc0d337675d1826948104aa416403f640214160a197ce7db18749620eb6345bdef1cb0fdac290eb91ae557e5cb54c7db9a8119229c54de5dd1393a3da01a1377090178419ddbf5cc29b95b0540f093387996458ec6184ab07bbed44368ce86ab164e0cb288be3f95dcb0c90bf45f86400ff3da0d9d8fdf7f0c550dbdb56c8c6d4e158fa647dcd41fc9d4970c300ed3b84d306d45b2ecd70f6c25e26cd5198dd4747872c88d0800372e902dc5a1be5c57b60a0375721a83c7546530880867f13e432c43564707a8fe5f6d5e7e2bd57a075667d1a97e52792913a548e8965a25c9ab2e01e4e4bce4de63eaf2984aba067b2c30304e64c2a50f3dcbae556c9e2808bd45d1acab640aea10985dde93e7195b152d4f15bb60be0e575ebcc79af0ec0857cc17cfaf11f5f2ba9e4174fbbaecf3e008ed3bd1165c3131389a689b86b12dc32cb8e97d411266c88541291e5f6a92ba0e891483644895edd5b40a428a87ced71697b97d26b4b78a964945c6c999f0daf203ba38e6048f47d8c56e4d26d215c59bc969f886d8054723d30aea63c5dddddad1633ad19c0fad6a3a38638c770b13542e616219a9f003d4bb2d14eb9e3e26a08d17a2b72ed5d9700e3720ab106ce8bee611a1612af3e07be0965abd8babcf863f24ee7102c27c839fcdf93146dcb66308c325e3debe9fe7a3cb3a13aa2a8f16c1af9efcc1c93f8800bd77aaf9a8587d51b76dc6248c878c7e572989bc1bba0c3e6c373d3065cdb72135f75c747ba1c0b412a51eb2beaeabf192f080bc9999e2901527345492ddc42cae5ba2d798065335b9e39d12d7301877e0391695fe4a3c8edbeb6f5d0cfb636acc8989d070a80575627792538f4c6c52f533b767d37e8cc223df0f370f69a052980c751dd553df26b17533ea765dc60bf444dca6a6d5af218a0a208ac4c45eb45feba8fc96aaa82eb9606f61d9dbc22228c79118305dab6c74aa22cd2f6522260b99a7e59c55c6d1a9e68e036eca60371018ef8a73bc368fd024f36c1dded347597a836c635c89944adf30884e3940bd994fbbf767d5f05cab9695d362459a487ab3ad339bed8751baf64d0750d8174efb3ef643e18279867ec529fa30517dc30da7de42d69fa329d4b65de30bd1dab6c441e5c95986e476b115211b7f6f70c8aa4ba2d3a4b29320ea0396ab79789297bfdacecd27145b89cf028b49b73839c9c1deb314d0563dead0c6d2d644aa757fe21587aa4c7bf72cc44634ccb64eaa8b18d3a0aee0c18bb459f2dc9196a97bc3649bc96129971c1dca5f5173661f22644750ef73042537e99639c85b7ce79c544abd9217a897d7e5cccf4a8f82a41592cf861b5c341e4167ea2dcca30ce33e1f78a94a79202f8e558851fd58be8e9421fa11391658d0731c231054ba4d62231ce1dd4efa3f703c8db7c6afc5964d94f436763262e1524c272500bc316dbdaf83e30c6ae35ca38075cdc4f7aa19a6fef5bd2990d8a71933d2e135565515042901db24e81a1583226e15aa8b88e006ff7f26bed26a6b8ba835537df2890d3b10d7cd0cf8eee8f1a605df9360b9ef48a84593d3717387dc9c2ac1467c65b32bc96854532a67767e265983a9c624e246b8957b26758688b30fd853ab273b73f27657ce0bfcf4ca234a7b6bdbc43c3a084fdeacf61b6a6b12998060090209b7e2a0e877fc3a95456b51a80b3c2aaa198dc5a1549e241dde897c2a74987e5b221564a9d0677a6c67aad96b565bf99e785a948973e8fb940d9412a5196cc471ab50c83e4eb6d7da2e7c29040ed50d80176ff7e0aac65f6c3469f223ec177a86b10ad486073c752a6d6cb8bcbf9b4e2b4e83bcbed112ffe5fe460b3e3a7ecc28cbe7f5af1e35718d9fc4c13ca2da155aab29289adb6b88f6fd4b4bdfb5d1e372ab97524e070a1aba8c916b2b59db307ac8fbdc8a55a911d592b0e2dc2ace8f94901d9df100f12846d2fb94531ab85db919b2cd1fdf85c5d64a8b03fe1044d3e253c90e0e6629512f3a0d5bb8717af521f0225bfc997508ec4ce26610dd04e18bb06b9562d0f9c9646ec3d1216bd0c77f8a8bc47e49b5a1651b08c5929d2562ebc57ce6f70acf0414f58de20ae4088ef2b96b52ee3aadd32a3c904e0668a626fd9be4de8d934b643d2b7ed80ed92bc3d856be68a532e4b62c60905370d438f0459ce916064f0f46c9d40e33859724aa543a842ed39da03140b26437634146be96fd2262824b394296ee86871b93b86f1155b78117f933583811e0d6c2672f1801419d618a96aa164df7047fc76ad315d6896b50e881e0ba63337986211f81db9785f528faba4d6298fb7ca1b5e61c93ecaaedb6eebadc57b20191a38a80ce76b57a4c52c8b08580c2b8c27e2c85e5b482aa36e59f5fcb9d3fa292cfaba7c12d105a2743f4cec884e882d806da7c8cbd1aa42212fdafb4ef04d220c7efbf7896facf6d003a71954d7a75e6603bea8d0eb1f9dc948801db5ca7a1d429485dec9630c30a7847af35183decd0c2ca5f774c8824b7265b830e7fe9c75315063a7715a3a2690014f3e72d2e355f31db6aa9bde3a00aa7542ad2b6e7eb5d2e36ae21dc4933110f67865d0f7eaf32c3d441d44fa4739d1afd22136fdc29643901265bd1d65d21f48229391a07a0fd48f5df98dbb125c4f6155e870eba1c075a48f031e10d56bc77ca3fe8c3d2036aee09cdfe3ce572fbda3fa8c41d10163bfe39edecc9fb2c2d2fe39446b7c4f4b47bd05c57c493c05632027cb0ab2da12b859f5b81810147c80934e251d1aaf35e9abb425fd5c09e61623c021423de8d836e488ef97f55d046c20b5bec787745ef13bfeddd390324717eaa1e4cc701aa982e42bafca1ca6b7ca34756ffbd8bc32607eb1a67465c552d80bb8a9a8af402af4bda83a6e8459e50963578525981c6dfee686404549a594f4c48619716b98f067c96947046f499a58b2c2c0595fc7ec3a3ef1694e7973efcc3fa244cb37804c7d55845f031e862f6ae3752e87ad4bf2d55cef37694557c98e1cb391f8e313e4c8a00c36f778389c072608c34881bfbc72dc9439c8441a5db7a7ea012c1c309e6143d108bc16ffc20480f4f4607c43099aee4a468e472ea10d1f7ff1198019eacc1f5ede9391210b72ee4ed5211bee17b27e3ef5e94cfe018c34794b465ef00fe4bbc9ecccd60f390b281826e6a64017b846844e9518a33aab9aa6fd8b3d3f4622504bafbb046b20196fa8283175f6c87815d54a0a8d10a7839ae3ac6a0a228d5095e585f1c4edea150d386e7ecba47770497a1dfe7d1daaaadd15545bb716e24c316fd3a6e75a0be348ae40e8ebe3af1089e8e1fb27370511062befd6edad7a95bf925abedc08fbd17ae6a7c1f32b6924efbb32c9039fbb35716eeb2eb6a0757debabac59337c6bc0b2432f71a8d60f40ffa7577e09f4522fca084288336e1500ce4406c215f886693e306823aa42c609ce510ac1997e5ca218192ff682ee9ab8632a55f88c00d6a2c79406c0bb82d950c361c431d9f929166fb90f539c0b650c2fe057ff8a342508372ff58ac678c45b11f8682447c145fdd9b559fad21285c9a32fe703aa318d8fa73a8e0dc094f7ede73fa75137d0e9a0b012d7f9b5434f426826762f7424ab8606f256f2c19e4f5f169fa8a68530f157d73e81215a81c16528a4d528992307e07aeca5ab53d5e19eb947556721aac3f996ef0ed16ebcf0bcfae2208baf778719fb068b7f244131ed89ad725d4671ab92a52604570205f8d5a644bd9ce86713d179312b9014ee4ed4504b13b395a828b4cc730633c0480fbcd3e67db04baaa1c79022fdd9243ebb111af226aabb4edd973fdfb0db28daa7cab2247bc55c92f329f7ae8d52315c164be363a24b09e6c02b6922f24a016579dd24c023cdc90015ce5240d981afef000d8226672c0dd5172866be7265adfdc5ec59a539105874ca1877afc566cac3121e3cbd90dd5b7ba287fd12c93d0b6f40307a2e81f6aee730341c6f3d4044d64ab134c4e51602b438c737a6e532be716314f77a0d0363b3a55cb803fe64093e1e58ed7c814c0e8a74e1154a8447e960bdfaa3bcce7952b5b0e19dd868e9bc4dd262b2276c7012a87fec26a69a970f6f2a0bce953be85e1a8449acf4e2e95423596064dbedc6fd8e16779ae1295b4be237f87ed5854e46a9d16a2ed7bcc84ae6c674d639d8f1f57723db1bdc1c6e794f5082256837139331bd6e0aade815cec63de84072b2aa076fff7bff68fa3845a5c0ba1b4b73cfee5b9878078fd58d1de77bde0eccb955d8d3a7ca5ca806adc89caf9e322a9ed385f93a19e4d193a97ed35390a3686964dad80e5c5257a59be674bd0f1e289c5af774e327e2fdb9f5be113d2a6cb02783c43c5831d118fa572f5a825442416f7fbb45e0ad7f3f1458555d7e57d802c226a536d55faf10f90b668df6b934b1a5909fe9bfa524ca4f4d0074ad726b83a6be2f152486ac87dcfa2e0542d189dd5da44e2322c88a8e218d245f73203b8089c402e8d517494db303398c634e95631e19b52bbe9026054f8c91223695f3f61ccad2559b27382295b3cc6062a2466159e6db6dc6e3a5416490f7d3b0c175e20711ac408381327a794383999ce786669456fdd850d7b75622906278712b8bbadd2e7a7f194ff5944506b1e97d8d27486ce75404c63d9601c749a111762a5e05352dd7bee15c5e248552f0f43977c29445b8175191f7ed1a54769ff045d54757ee067517c3c926284ce3b2fb095e5d2bfd59ca0b5094baa25663d7750a951a6c91e6894f9b47da2bb2207572a4ee5a65d2e1f98a4bc4eaa1417cc3c01c3da516415a93a17f99cbdbe142ea58877bb9275e293610278173f3c3ffadade369f340d995e798e1c71d8464fa14ea8e2330758ff467c73214fc36419388fd6744be0220e55f42005295ecd2dabc45b979e9ca4d4291ec9bd6e46790a2fe46dae574adddb2a0faceaefc54a44a884f020844e5cd09b42a2c947e6513016b0a9f636f40f1a5719f66ccd17b54e787488266c1be6dce0f4a783677d6ce4ce03d08d101387c4358f1e33249ac3a225c9fc3033522f2f55e585916e86c68b833ff704cce457e2fc35badd8880dfe98a8de4710f71cdfcde861a151b3133d9a8bd7b69c8ca0953ce4129a06db4a246edbf460dba825111e37f0f277448d65f5c7a324731b40ebfe0880dfe1a45f74f4e74c51ce4e3abbe21c7fbadd93d7b09d56d630cfe65021005ae77164621a9a25da3fbd52ee5275dc9b3643921ec034bcb60ae9bbe2e3e3419af479fdabe01f4aa42dccc1dd35f8db7c5f3f2951c30becf943d8a4d0c917acf0fd141a040bafc99103725a0787cb8184964a286e2fcc2be2b3b6b31b4ebe537997e3a71a9b5d508164a7d31933ceef07bae2bfdac907c13ce1963032dce568a5dea7657673c20cfba2d6f20a34eee7215f27cf79b4f2223221f11045ea8625114f586799ee23eadad09689cb27db56e95f6fed572e4ca433682c3bb0f1b3f15794313c0791848bdd7245f5e983aaf4073d34d38412349783e4cf3ce5fed7d412844d5f2bb3a26e41e38061aa28d6e1348f134bca52bcd7f9753d29325604e7b5110b943bb46579bbb6af21fd588abc02d08bb9d4437d9cdf98be4f9604f0487c9236eb2d50c561c9f2bde9d956f7867a63f8d07cf4dd1a59d718985c3f1b13a1bc2e3ae7c51a04d0880aa1012598d0274090b73298f0bc8a322ff988c78f56c898f33555b58bf56c9f647ec3fa213bc79d3a9ce137a85487ae680e5303b8ee9c27bff2001df7e92afb02979ded57c2e8f6d869e72be461f97a63f2c364d07f293116285f27220ea417dc0f810cde885f5a20a0b6097eb0ae867fd777d5b4e3647bd04027a3b75a7bf24a078f083099aa766847864dce105ff5a970d8e5590ebaa590bc70a1b16037baa63ac4763e56ff1e56c9b214884abc2b6d22004482d522eb5623339de955197dbbf5ebf5731fa1c8d9909bcbf34f1b0333dd16e6e643fa7965bd6c0a36b5f9bc7284613d848babdbb38401568eb0c62f9e753dbc5f94466ae4da0b7abdb44a05d3e3932377619a6ad2af3c6021df2d53be52b912b00fb3488c65a14abc197be6b518ac5dfe640b85fde06645b6bc36ba00c0ede9b18bbed5f6dd0b34c57fb50549af035c318fa83617d7ea1268a0f0cac5b33175f87fa010bbf983ef37c1caf36a12a0331e4c37c76ee247f274d941a860a54cb99b9355f89ee11263bbdb8f76c2e8f6fec361e1c58fdb3716a2cda0f14bf8c1c2e9ae67cd6f482a8cfb4d0248c13cb7c9681c9962c1b3de574319f55f5ac1a01415c14a213d04730792e7e13fade24c0e808b488606bbc9c50106caa1bc58dabfcd2de12c0f509e368db1c6687b113da2f1cad001c53add0356b5fb3b028b1a4d9dcb9ba4c0615e20be51289c041c796d849f8482414951128275315f01560d9d34d690cf6ed23a1f5ea009517373457c44af5e3dbe49ca81d8c3b23a51c9ea523a5c2946880163de5ba059c584eb22833671c6528b86028095a94dec6c5e5800596d7ae4b5b011f83edbda16f1f6e88f8e4c7371e68ba0a218f99a4b81e9e812bc3c7d89bd492e8a6a18f0d55f1be29d477f0b09062259751df8a39e865cfa4d687a690631de32de8924338998ed3116e0b62283b25a26a49dbb9dba211950f3f503d13d61496cefc212dd6c9bedeff7b66d97b271469a13855b114069ad5db502ab90914828d3b06c98fc5697da6e00e93c1c4a9cda52d2e75c6f91ff19ba9973c6222d3c09526180a401ccb4cd275b3831bd79539dc76378b17d630d38816012d25253a4ea393c606894c34ff9fbf6a93dc94510403e12e0c9b8369cc4950182d22550c2ddb894548f1ac3812675fd07872e42b0a2dd3ff42ec298e48dfe995757b900713acbd4f2060fd92e9de169f10171d283a0441e392a3f40445c68f478c28b76c3795b8593341373c0ef9a8e3042b3a15f59ba83eab38d8eb2084704a24fae437dc9b7880cb017fd2f159bc4b73407f1516754c018be8e9959914c66ba694483c1eb3f2f017a2b252d79518ec24ed80670dcc6ab41f1bf133f64cb85ced8bf129f02ee93fcd214296b26395d4f778b9aba86e8741495eab10c49b4e914aa0151b30b63486e6ff283068c60bc990fa9d217ab581c9a59bcfbeef7dff5afcde55b27417d5fcd38d48117ee04b58a81f7fd6a98071c90cffb89349b8f82434b6998dfc1894a28131c5711067da603b3645e63799ce5fd4c62e304883911653a61dc8ac22eebe51a546327f627bde37a4bae4bbce46b123d6050ee6f03bea4d3544e3ef918126946643eef88888f6ca902174685f34f6a9b467119747e08b6c869f828bae743f3b4b7cf59a0b3325044d867248213fd2afd61976126e15263c1d24a28668fc83a5062a5f97b00823988af02785bc1ae1431384a9e907d961d363033deb1e48324b2749e927d41652eaa070c6f4f31da256c9efd8c4dd7bdcf5d11e83b278510543712ac1469db44750c717ee0705cfc757998aadeb14d95ea35836734fe2b34c813cfc5c633fe3d78861cb0543425a782f08dd7974680cdef87b5c7c6c45adcf2f3b98551a67fd9f8ddfc27fcd77273c71d3eb6de25423dbcbbca7374daff62fe33204d41ed732dca2ab53cec56fdf21f0e265d69e77a842a836272c653113baec5af81783e5ef10addafe35335f2088b09ababbdf20e2c0b9b0b7ef08e12d905ba364ecaae1f56a24413fcd67f3e8ea3870064b576e6b773d95e04fe885900ecc500298c5534b1ff66ee112d26b98accc4d74a8f4dd3390d28e845d58411d89493efe2f7e2c0c90b06ee344437d10087fbf5705b995899fb76f3186947d96258ac87165553d7ff955834f9431158210ab5ef34a9cde5338e0427f7ed5a9d081d8f06f0d131f9882dac8b967b2f2e94cc1ef3a5ec903f4e9fe7faa0cb5fa2d0ceaf63a50e4e4f1d64705fa60213831753565f0e9de7c25241ddb076498b682f46f3cc7bc165838b9555cf8d429163023a1f4df16e7fbe50101104e32d454b42e2219e019e3b6ef5afca6b751183a21db664291b6ba8734fefa9ccff0b18207b26b7ebecde33b1a8f0765454102671ae9b9e88f10db8f1c261bad3fad7cb6378da3816e92d654c057d2044af27363bd44adfe11d6fe522eb4888496e2586efa13a7f0a66425b645ee593bd1faffcce670e11b515478ea5aecd8c735ea0aaae3b185a1322e339212df4d16cea5fa2045d87dbbd001cb921e6f71a029b20f4d91cc5ff3a99a29ea8bb308fd8f6b5fcb5d7ae67e85110285a543f1bf674538f04929276cd6d0735ff695485f26e143c47d7b25c88e2570ee5804d3e06dd1d1481dad9f9b1de148d05b2ed53f9ca1330bb2a7443c046764055c9a3ff5f9b9c4d0c9a8c4b6ed18ae18a53cb1dfa031d56f812e6ef194c18b43eb01d327b1db64a89cb55611640b709f403c38c5835b0edb0c484ad21cba0be71e5d9f58ca40ca28617fbfa0aa7d011b2d89437e407f6a5e33737a487829bc0f9e71ba2c9f3f46c37fd9d718e3dfe1ca6911f174bca2175b52c0328377e602c682d0fea863a567e7de8abd61f9101100bcfb4fe5ed08d943b304f275268027a0ae4ec0f702abfabfc67960c9cdfbbe64298022fe860b03a47cd5c3cd8221308c2da8cdc9d12704e4228ea49603703491ac694a4860c42e9325b32bf9c824fce35cb9580fdedba0cdde92705ce060364ee3d33119b0d71b6b6799c46f3c3c86512e82b51ff69704e046d8a150209cc34eacaeda92a412b6bc74c5ffad7b50c24825d2a09d8332ddab7fea81554c5a1a46098bc368cc2461eb5854f281b62a0dc9f4db8ec5effc67f7fa5ac5350e59dc55f5b942db3136d531ccd2b2c64023df9eb5e384cc2d13712609234bf6bb40df4342c7348d3c97b346354adb02b2accd1eed51b3db8c72c521a709e0f44a2cd07fb4236712a845abfe3949be140eccf5630927966e1639ba169cb0f83eb38bd2dbd6e32aa1a9e8e85b61bf2daf1c579a55a0df07e80ede6102d17acb39e97772d1d21796797e6243d39536505422b04f3dc7b685407dafd8769d63abc674d9f7d8221632da116aa28750baea22f31c921629e4c3479b21efed9994b0cbb57a8198a290acb8a788dddafb043cf8ceb46defdf805704f8c134e8f9c6630247490f1aede0ba91823097cd5bdb4f280d727c493e8580f1c815eb52911a1cc4bc7ede85dbab4e61b16db90d74c9bf076c21c11323911298f59f75b714e166540c4d81af696d8b34d75448b22ea7197066a0758b0b3b537dcef5a9baccf3520555893810df14ae9f067c20d9621de950d1caf1027fc67a87a2effa5c985caf0df7619f44d808bf0cf44a0d67e2ce640e7072316ae6fa7d865c34482481911c138cab8e8ed3076f390b5dee907343f5ef0715de9773673816dbae75f0bf7bfbac9b6b14159077e1f5be6e1edbf671b5c05cc0433d8603c3295e8adda8295bc186f192a854c779753354ba705c234a0a97ffa8379197645e9468cbb28a0849092e91710f8d23583d69b0fb07e9b104d4d3998bbf36de04621510072634a0a61cdabb4b78dc913be0df18d6ddd4eb83e4728a60314796d6e668fe5a89300b6963e8e266766a231a1f7e183008a19bdfa6369463059d07f17b773c49704ad27e7056ff8385a56e26d4e038290bbf24232975a14791bb3cc292ce2c4a470b496db619de73a16eb3ccc560f989fa11f1445dc9142ce610a10d03fada63668058b91ae5d7d735e18cc2244ced20bdba8cf72782439c139ed3940f946041d59b150df2b7aad335f2567ca27ca0b23c4ebebefd362052f92b601aa7db06e7ff0925cad0fd7d4fbf05fbde4efd665deef6b1bf5edb2c2fc443b90b60bada51c8b57c9ef4dde72de3b967dbdf29f9abe7b8df6dc4a71c98c9ce111117517b31dbb1b84316212c1ec0a32637ffa930099fb97e6b6c00a4f64d02720cccd0e7e2fd727b82dbd59a1a2a31ca6e2981fac0cdadbd01e0884745e05ed5007e9542dcafb31c9c553ec5c3751f9754d22169ac41ed2175339209226db51be2fc55a129bab0ac0942b930590afbc1cfcab0ba562b682d2b0c91d1f9e6c5cd52aeda7236230d36f0c5504e9ddd4acb55cecc30140a0938d8210eedb08214ffe766818716011c3c508a86e01d8690f7d839147710cd8de4ea5be3b53336e54aeed207d70490c753d5ce94eb8bb15207bfb4d43babd7a6847c261eb547123ad8b1c5a0957c41dfcd01180bc18ff62721bfecd23013953707c5c899623a87526e36a61979ae7719de3b2e63a5ad9ba21df298e4755c3701ccbb7daaac97b62a8d97f976c5f6da953b58a69790a67e20209fefd00079e8bbccc3ef7365f07d25f53e7f8013ace0205da0b879f2fc21931344aa29d819acba4537c7433353f1b1a8a69d2bcf06bca4c31fd14540a4532040bc5b7a40b2a92d183abdf473d895d6223453432feb2831d835dd0976043af83c52b2fd9e90360baccdc649736a1ac86334463a94f5b751708c4910f4a19a2adfa8a358e70707c40b741f5f6a2be84a72691cc4a56f78d3f5fd102cf87da03d3049f886c61dd2ad26a71c67729323f78425820990669f12602cc082466d425cdf97e37b9720f98684686532a7333866134bfd6486fed9717a12aa497e09e7044f6ae4927992c9f22af05cb3774cf7a76bfcd7353a457c0e811553e832fb27aa7e421fbb9913996fc4dc47e6659a0c5f84f0c1333b00e0b7dc63a0edaf735b65985041041492b01705e551a014d904a1d1fcf2cdfc93d7549ee7200f53ba7bb00b269c62c86f461927300fb24c4185f4974739a7a2c2b07f6fcbd5f5fcd228b22962b3c13609e9e75730dd8e0d8a648f97fbeca852e609465b1565aac795e497a5ff4adff0702483641750cd9a1f471161e7d75e7da8f5fe453219ac652875e830af73836ddea5bb3ced1bb0416fbda11637fb2237476a9ef8f7d88722c62d487f150c723ae0e579d18a388cc19117e30373af03a69451d613f1dc7c8a6e6992f9c761942159dcb6e5dd70f208e3f90181f890c386b032db80ec4a5187e5a40935c94dc5446c50b24c74c3cef864382fd2edf59d2895c92d2d3d3176e7c86301ee8a558594b120648c8116e51dc8a00e4747e1f858e5bfc9d9e79161844fe55295617dc764f7a2f0cdf94cdd931b65339a4ed6fea7eb5b6ee893314c8a5a4752d2c17a6dd6a41d1cd1e3cd6c96aeff92024af9b1654dcebb18a79b94daade0067ef95768102683be341286ca0d4e5cf4e6e9c6011f9c07e538dea1db6c05dd8dc820c7a5f1ce4533e18fff99936c88d4458e725d7eaba71784a455451b36ac402cabd5dbe6b012c1e7476f184881c92a8e14f5785d5b20e56896eb7e56ecc34952362efbfdbc043a5e28bd3a97b83f8016babc91f0dc187308d6dd13c0d69bf61b697efce421ce9b77eb5e0f5a7a7248956d1cfd8725f6a129e9d07e401b9dddc99f25a1edc431f91e145287e0bf27cd70371f167a14fddd17068102d50da1536af12d9fc12c0480c33dd5febe76cae0e0437ac534e6870a0b8e2d21c5a3ff5f90717bc999db2ddf5f998ef763f2748dc1d1725768d772d460d81217f1a83a1cbc3b4257d2f884f31828f18b5ddf0063edda1658a6302fc45dc138563152389bbbb7982796f4d6b38467b275dcbedfa9c02b3ee4ff0dc1b3717e93db3450c3000ecbe3f36aa52e3e582189588f96642d0674e355ce693cd0122009c9ae0dee7a87781778b974094da1fa502fd7d7fd66ef9afff8ede9a0672ff99504e2d587deb996afc6fee1ae13b082f5eb72a6ef2b7671fe72845e457f24ae9cfc3bffb3ca5e0d31055407ff68246fe8054c74bce68b1da56cfb22a9b3d5f9dbeaa0220c087b1693145cc40ac525771e381c67b24e92844359178665e86b5c8ca2148f20144a3f9e8cc53142d14a4cf04d5be5bddf75ff68a2907217f2a09ebd2e43b9515304d5928b657a6b7c467fd43241ea8b5e10a8e8d359a04821d8dbddb8638e1645fc3c4b7a8d9ffa0c03942a60b8dfaa97fa0f40bd0d35433e57250e44d71585147739bc72dfabab17ecdb080849a9174e5adc421ca308e1de327307bc5c5a09c1afed7e4c4e852c7aab79497e1a308105f9bc1a7fb53661f09ffe857ed7840290bdd8a610edc709d83fbdadfc14ed6999d5247bd4b65b5334187b2f074dd5f701209c8957ce8b592a160bcb61d63a7d28f9dbc1cdbdd417535ee37195cc9f9c4162234889f5906a757787efb5c38411b2928dc7c3acffcb38aa5a1a28945aac7efa6c10fbcecf8035ee9dc27a3cafdc7f76f2b3960661705072afb92fa13090c2384e09807493728e3336aa841382b1d286e7f1140529dd2a4316d0484af5d6467285a34ab591c4fff59bff1c13d9cd9de5c1fe0a278ec4edc595b59e1cf2868adef81b42a8e93d7897872fe9d1b4df58d818537d7bdd2ac749fe02c869403bca72730851e36bb92e99c018f9bb82794cbb21bed43958d420fc1fca2587d3999068c4c26aae2573d2dfddd6e37fa5aa9a409d860ddd80fc22d9ac41d5daec3cb73e25223af2fbcf9c74ac321f1cf3405c13bd9e12d78cd3a3c87bc39af517b3b846ceba44129ca68b3999d0e5df1389f4d3cb86a461ec7229f9e68d1d07c28c2af8964eecbd5bce4b4451d977364b16ca364342f94b251dfcd405490c685b656fb2c9e7fca569610c98849b79572a145e797d0b6161619f53bda5c25b5e380f3c0c5aa77149474b8f1c82599eade856617998129fc521eaa613b06b09c2a7ed6e7c5a113cf535882842d5660da51a2064299f757bec3f24442cd5a960abd10b5fd037ed9dc62beb39f047af57b76760fd8c5767899a8dd2e1f5417693bb9fa66c10696e7c8e4bacb03c8fd0b417bc9a3a86569c989428cca2796aecc24252b5771023f4736912025b112d73d20c2f11960e68adf152569e723909a07f86372e0bfa8c23a1ce9e3c309171012c1c7997aa2b1c7ef343d0021bfa95e6e45bfaa8bdc18f1382c5f75380375e459f6261051bf4b546a881dcae3e9f796ca649eee31971b068bf3e1b57410b2474dfca6e0de3ce666a891a4c7edad0079f33e840276a4b57f55e2aa1e28250f04b8929ddc1d454c03ff5d0c3110774dd68448ec39a12f4a04fb5950d68cdd586471a37f6aa54a1d1ae1253738341115a8828950aa23934ded8c4bb804ddd9fd331114595dc657e9b4030f5c0c03912472e8afc51fb2962a2dda0e13eb3a6dcaff90027e70d4b985176cd776bcd356305281c5e9468bc48294a68988a387b00002b6207686267729e96d1fdaf5a26249fa503eb7da96ec59050a17b051b2e05aa1501bd79261ef7ca898befb4a40c5eb15d311d61207e5f74601917bb9810687e8349580e772d64c27be33132c6376fcbe17a75ebc896288536f2b0cbfe88c9f42163a7b57865ea870f29b1a6fef39786ec6642a2259e956cfee062323d0161034aba9fc37efb0bc4981fc159e187eac96754ab757bf361a0fec2de456bc61af5fa44e4b919ba46e9d2a8160e64a75f05d4f11b65ee5c9cde80e474a14476198e277eb8a08a2c18c200d108335dfdafa468cc6f07289c10dcf0294cb5243a1a12ca5872f7da39096d9d6ce86b11cddc6b3fa05bfdbde3023ba52f270250133369e4ece9584e1811c842eb840c3e03ee06f83c6ed915c89a1fb0403f4f78ce6ea498bdaa55b59bd2307cdc1d1682e61af268de2c8c3c4da7a56af2cb945ca8da7af34fe6e082b1804a18f34d9dcd843afeaf322e8eca7b0fa67980260b6fa69d0da75bb23919ae180dd576554af4f9598e668bbe55846729cadf32ecc55deeccfaa7f2fb489ea87fecb14b5bdcadadf7e4811ed36a91bce4cc75a3e9337e64887e927cfdfe0f17626d65ac26ecbb6ce2e55663837f373023f4bb6be8a6220c1911cd2c6581793f7117d20f18c4a18327a90992439ef353bf5cf9c9d690b6886080b550ef90c5332e764af7fc40c5cf6fe3117dde0b6f1034394394a3f0e50e8c5efbd242d1fa229aae2c53248a108c3b8a4786ae72b9092b01fcecb375ff95a31203483316a764860ca70fe50c225d9b5ff3e10831c145f6aa925ff5e1d6d95a8407ec1c99591e5de084f20f69a722a47d0c50843587824abc4e5b7db7b951198c400744744ef843feeec79064acd6a00848074198ce70c4242a88488464965e9b307c74e0a89f32e43f708b667cf2579e6fb1ec1f700c2faf75355fd8d8d295243a085a896238064168c39d615836486d5a866215897f56c25e2a15e9c409702a20f92d0b4b83a1c594921094a6fb186a9c238af9c684f3db0f6f68f2e20f72b717ee0aa4df065033a7ad80724237431b96d8d6c70fc635bdcd99f0710fd30884d2b3427274f0fcd7627cb99ffcc9178a982618ce05f0cba0c280342ce949aea95f8b0757ffe6061bb9dccaf18d65fe9c2b52d83f436a821e1a809b037a930044587db9c141eb35277ffd16bc0eafce2a2a7d3ae0ab8ad629ae2b047db5abc8283b4562d90d5526d6a6c5793c24196ec872c183282780af27a48d614208a9ad33e6e4a4191fefe40805a6ca9693fcd76ed9af15287137988d71fde618d6850213000c2f56373d5047a3999cbace91784f74786cbee583bca8c58112dab6acd06fbe377ca5ab14445dd0bb09bba0b80378acfceedfeaa0a06793f10b34b29535c73981f52c220800f1f75af2be669600be1e89e93e89cf0a55e0ae1b762e8217cc2cace0ae4bf851cc441dd19294d683e1820458f6ab5ed30f4f198aa9b3de74e9782ffe6274d23dc457b964f5a8a9d3914cbc3829171e288733225989b1d7242f774acf56377de3c97a3783fc9b96ab47a185871ef5882170b2e19c60722b9f4af996878b65988c3cf91e7a7e969adc18b1b56c4316fa153fe009320a858ec902ebbd05402d6668a9b137bcf03549fc57656f530d5b10b2121ccedbdac0a12130d7a1c3a046d535b9cbeeb1ab401305184ef58bfcfc67901b1458f23992132a9a29368d7ebddc6f18d1409f6644392db61fa21af7527bb0bf29d0e9d9cc4b97b42c43651bf7b05662e065ae927c19327bfb8455360ce569f95ecac7ddd85eca394b8187d01c9d85e121d97193b675783c0e6b958fade89f41fb4dcdb47bc712a63d3c9e2d33b618489f916cfbd5ab5871201674420f8d1d0cc294975f212f66977a26664dd9c50bf774a051c5e6f93f4313e1a5c0943b610c572e19780ad13e158143c3df4be720bf09091606451cb560074cd3337af58c9d3afeaf0fcb0e1b8094e29fc1546e21f1a3506a17c2184f8f253e73b7b1f035cb8535eec9b8115833e152a8dc495b896c57582dd921cd550e574fd6f00dd01a266d193f06194f3d14ab08ddbaffb231c9ec74f1c45925df1bf173ca0df54032cc28fdc293bf0d0c51685df61569ddb48720a1186c2b38d8afd71b1f7b3a83130fdb6dd3286118da640184d04c525bbfed991ea43736deca9e153eab5eaa5ce2b938436eb48e7a2dea08703cfa24f8fc43510a935231c5adc997c97ec148bdaa3315480b30ac0de59a64a480f10376913745b7fd409b3ecaabc0dafc6b1a2fd4b9a6f8fdc58841fc19966e71d4f90ece9ff3cbd2919d33a8a27fc620c6c025a3dc2682e39fb967b6bb3134654775b47ab4e78d759b65e770c0bdacfc0df9a9f7d25e1d8e648b823869b7070a66bc5b2030059627c9c36d4b69ed8be42cb68a30ee08fb2c195e608af66f81cf8f8ac56a10575f0f0623eee4f099ed42eeb92e766b138786dcebb5f61b485a6f0dea14dee08b324193dd006c4a1b7f23c2d38d031712674430d0c47d457dbeb2c6c015472cf953d6c365a86cfd9928ee27a1043e0e25a7f59d95d560077d14702a8ce1ceb7ad4344175bb9968c36daa9b84a482235d94132fed7726aaf1635d4a4f629eda6429fdd2b1e81569a3add970e2265504eeb72a0b4b63259bce67349c7692acb35a08bba2d8f774032e807c85f9d450287e7ed59ba7c1f32fd161899edd811b2ce9282476bd4f6a4d423b5ec570202b13193fcd1092201d9749f11c2fb22e60c86cda443c8a7ced06b7b1f6f94447e3b5d94928408858a8a28c547b2ffd87376ff62cab0dfec39a91c6993d37de87baa0ab4992aa12c0e4287cb2f703add3ef23add0507c2208387fee63a054f4d5db9bf82ed0f2c900243412fd2fd27d079e00b8fe394090a8064804493f9e737da0b695f99909a386c72e9dd857e2dded033d44f56f91ce0f7fd169a10daa1a40cceb3ce4ee3a7193b8ae4a3d694e9901072e9381631fee079f5a12b89607e273a6c498cf1358dde7c11d7d91e6a1f8018bc2fa9a7ab7170d593210eb601ec8a746f9291b6f638b40211454b93145b2e5155d5446221e2b18abb53fd67e038cc3c1acf291474a40a877f71afee29454f3884432a73e8b4263210fca7ef84265eb60429ed9fa5c93c6af8ab1dbb6ce5198a067ddd1680941eeadafa5e43ea9cc7ec16b6baa5517d78eb50e62f924c5f890d65c740e8925a9ef93d86ea7d641a4e3415ab66bcf15ec17722e1c5f2a99d78eb9fd0e370bcdb55ec4c007cc0e301c7e6c2263ea8e1aa4a552d0dac54d08fe188b7b1d581645dd240c9ceb7cadbc6536c55fe93183327765f5daaf44749995a9b80ac350a9c55e73e6e2ab80c1b0b5703d7e511f6070e2e609a06fc0e8295119fe67b8002c29e3b72ae617ba60714c27e5724cffca617b820c1b2f0e081cb4527655882074404c5bcca058ccc878c7dd12233e41647ced4558b1a3ded9836d864f632f9f083d4d81e709e2c2e6941b429167588e730c3a331a9290def9a91e3eb9e6d48f4696026e56e66541b7a1b577a5478bbd812eba40724596c2da88ea02a0ea128d7e351a9ea4191fc75eecd1ac0e9dc9e8bd8ba70a4e4824d694e3e10db5369bc87972c736bbd6bf79943280b788cc90bcb700fb920f94ec55bb4e1a2fc35f6d2bf63b4793e3ee3bd1ec24203bc6ff0da1b2752a7b771675ab4345c1db3c42c130fca4107792b4056f7c9b1c68a4640f50aad285727425e745d74752fdce3fe8116ce03676a0a27b6702de93e2673ce2c3818dd8dd5d7e80ebcd3aa969728aa603bb4a7327a86f52065e39b52b31c7f180d8c18cd79480d8fec22ab6b375b433edcc6fa55a68002b5ed88a24c61c6d988297c23fe02e401535d2b56b5f82b2b1d120680901992ea39405626b9cab735b7c0d7683054a9af811035d674dbcc162f8f0dbefba7113662b303f7ed1e826ccdf54547f9f29205a17debf541390388065900e775096fe65ccd103c02a1ba252a853a45d879c8535b81c8317249c12079dcd2a01f7c64e9ad0f3dedb0d224fb5b6ce8cbcdff14a2a2c463eaf3f38a4448cf45c9faa9c3ad0e935486697b97fa22a6e75a17766a2dc1245a08d78c5730287c78ee9cb4e4071228f3703316eb915c509bd91f1d3bfdce48f9d3bbf4420118daf4894874ca8772bd7cffc0b4941e36c2d33a6ad118c2d6b1b2c2bcd926de2c2e311b603567a42b6f6eb71b2b27bb293f4db16a10a6f08ed6507f9810348c692ef62600840a0b3e7d7fc9c6aca0f610d96176a879a84b1b4d5da5271f28206e1faab24d9075adb816a8e86ec750aacdf14ee90e78660b355a2ea77645ee14c66e4a100c2daef5bd24cf23acc3edd1de35baac9bbefd78088e5d013cf452596c7f152d53331bb4c06da7392c7f656783e1a23019db603d1a26d87bd6283b3343a67fa95a7ce9cb048429ad143659489ede758abd2d4337ecb9a0e773b4be3c51bfad498662d21b65d604d098d5cf0b280db3d2f489ada8a184718a57afb3f406c5aa50ab89f8a76dd971513db44b52887f21ae44bc45eda573f5553158399e8a93412ebfefb333b2b52221de540ae417077afab0c639148287c8f7cc9341cd859135163b59b446c32415d6e7cbb1a2f77704cfba9ad5885481b7d18fb0f885ff7fdf7a2d3dd8afa023281b4840100af5f99aa66433b7645afcc39b61f61a79ec59c5ca208385741cf435e80e7072e193fd97b44d9ee52091bfdd6457cfc6fd9d392fa93294e1f3c268dc6a803c4a4cbde8efa3cb8ec2ff962c421f3745ec2ed21eefb87781c2ad4f65b61e408a8ede4a9f20b772ebbf69bf8a08b9f31bdabce24c68367de088715e9359c795a575891cc758ef6afcbc1e3f9930ed10ecdad6b28df7ea25748d635b4edfef3306ee4481d262304660221adfd5cbd697f91353b99c96fd276eac02cdbfa8108f7181361e61588a89e7c8a1e5a5a8e4b1ddb0d123032705241e76623de9470cec03c96b07d449d120b5ebe92e8d969da7d3f50340c8f5ff198100f7a1a025e6b63c3c3c7e2be4a4a64c84a5ce3989f9a279a3cb8e84de92f606cef3980307d560b5e44c8d3864487683f8bfef02f5b95471662b51bc1b2de81683999773a0dacb557a83497aed8d822c12435e6d3e30d9ed07005921df1e5ca1bbe6ef94364ca91742d756d64b931c46c79d300919c7e2b7b1ba5956323676c474726370bb520df100c3f35fad6228ec9efd0d63529401e67a64e6c73d5aaee0317752470450b3951d01f511ff20f499458e67789944b0db8f4dff09823649fbef7c2bd6e0541303c31365b07a03e8beb64cb4a8833ecb2b6935961ea8c78df78290aed983a85bd99ee934b0095780851192d76a820788e71917506f1447af87223bc1512c4619c6490f7174318587c91472f3976fcc5c47527a334268d635b7824380cb6f7d85e75769ec4e7786e7ec7ec42d0cd554d435f0592229dbd8b4e0ad6249aa1b1c2934239f0d8c7a1d760f590e0a2c689e824bb217b2052ad3e1dba18666ded55d4e1b639b1ec32c5943dc40804f430338382a50c7243ce3d637d0d3c6b5063b1a81493792e99a9eb91e0a706b1ba305634f6e2cacc3a0c8575c583736b25e5509dd146239853eeda1354b3a1413537b7ceb7cea2d38259e2b5a9b27650289fb2016b4220e9728bdf9ce4a845481271f9a221116113d84d2f567e2ea2d10d3747bd1f1cbc45bfaa522ae6ee857445ac4cb8172f469643d0117580fae1625c3fc04e7c1453eaaee20c228c7b96468ffc2a43c38d44cc1fcc532c66b1296c43a5ae95475937bdfe3067aa47aa594f770df9a8d8585fad604a76b60985eedc6d900efbb6a8fedfca1338ee59884c7f4510a2810494d5250e620b834c1b74d1f586e4122dcbec64154a968d96a6c6248a1e3acef7fa9c32907cd32f20e832874565f20dbde380d3aa39c4baa0025a391ec861bd41c6aae1d5d0aa1476b9c4b6772db21a4a857237e30f497dd18af6766187ea32f8c8150fe1d881297e56a8ee2936277ac0fa1fd8481ddfc78aa983bfd372a734a82d71511723868d4046c3ddcc5b86c955c88bcc2b2363dc98cfe3414305506b632b3b4a40ca4712879dcfee6700cf1a1f9d93e2c2888ce4438a16a0ac07365c208040a50fc1fb0dcdb0fe5db0a3aca7ece6ebc2158f498806f6886cc7fa8bf1038c670fc366ef3ee133cad4e7de21011da5099d1d9b2691f3441d0a1baff850a525d94a92438802ee39a216030e6a72a6f1b47b17d2071fc9b179759488b7759b6e29fb573a971d00c311f00b2d61b3b883cdc454b667f35b9c7a82c4474d63c297fdeaf16437b1dad656af6a59496083a99cf1404a2d59f00c19418d8eb1e6c159e35c52c11fccbab7b1149e92968df935c44a3cec50e56ff8603fb2fb77b7acdc446e91c57cb4b08ac4a4679a6a0f5f5336442bc0e453096143d007d15b6314307d410cc4e2b94b36881b4513dda14a6acfb980ea426c7c97dc146fefb93549117a4ffa3383f7e227ce662978ffb97a599d8256dcfe2210f4143f4e3b5435eae5a070b46eb0d7aca453b65fec30efc01c6d298c63bf4d3a6e316f344613514573dcd8aacf123f27078fe524dc700edc24e894b44a6b7eed719dbbb85f8a50d3d8312d94f8f1257da963bc60f6301ca012d678d43fc0e5eee31a3658f33d0a37ac53f906597ab8d1afa2b107bd99dcfaa0bf2f102b77b0aaa2e663245c117f8a4038fe2f7e9d6f95a5b2fb10a3e0e71e1da369f2b318b8fcf803ff1c5addf367a751a42469dbaf7279fa738a92843b9de56909e4f6a1893cdfb0c55b1cac7ba977383e7bdbba3716ba01cf2320b7a340c98b47792da1a6928d0ec5f43f476229b37caf12b0ecd68cf28cb92755307065305f8e47caf849ac6e6354300d07d99e8a9da46e1292a639082108bcc3b491246fc606776cbd1eb75c552e3ed4c86a38787b904c9367d2c7202cdece2c84da05b42dd75d20b9219b7416592269b435994584e3037c0b22a7e17efd99f020ff3e19d22f012b982765f6fb98667caa7196122d829e5d9eccb7b7ba30858206df7f4fbaa59d7f701fb786fc02640b532bcd6e78a1867cb22f9870811c76ecbf01a062b22999dfbf7cd38f2bb5cd82a09cef43e58453a97d35b01e9a38f1ff719682484648521ee20da1b44e14c27438bc6917068cc0917bd09e7209a1f5b8ed5db8cc454cc7621d8fe71ad40180b8fc0093ca4e176ef33e75cf632abe86356dd3a5957c415b819e51c0381bdaebe753f23318665c2dae8ce48d723a57b02a115948805cb02a22424720c8759e7aed884e6a25326659cab377115eabf810780f70c5f10d8343456b27072259cce865e7b9b3061fc78a953a5ae2ba6e7b5d5a3be430c68aa5e73d48523dd9d392ad14dd5108c4c9b8478cf0a2894fe623661c1733d16b0824e035cd87e1f493c70fadf16d415c514f64482f4ebb6e394e7011d1e3e79f9ea44cd856d4ab923875155113b447a8ba8b1c2aca03326ac98f0a87e1f6ec2c97125994b1c59837a736989843c6b47ace3c12bea25beb727284778dd47ae6b48d340e2b220bc5b2ce091c7cfb54da23b67d078a9db407298fa4cc1c905cb56e9953b164bcfb881220e637b31252297e7edb655be96d098bad16a88bfe1ec038437aa5f9aa2d31759eeecd1cce8d6969a2ff301a140b3622c724155d759a46dd90d5b77e5e1190607897ee2b2314029f9294466c0b7e6668814600695f6400256293751dabf6d5b11cb591ccf6c6ef80e288896ed3187b0fbb6f020b5739cc6c619b555c56ea771346c641a9f7a44cbcbb9a67ece13dffe8f66a00a62888ade43d56c3f366c4bbe739da5aacf2850fd0990586b5072a84208dd0e7c6ed02c8ed8fb758a108b8f09854506acf9e26b24ae5e59d757d7f42fb592f1755c384b92d3267805baa4bb0c2ed9fa841dbd95e6dfbbe09c13994df40d65fa9883fff996eff020023a292e1dddf482aea41ba2eba794abe136bc9e79bc52ffbbf736ca813b488245e0e08c5408b919121f17c4bea8d314cddfc4dab2697685379cb4b256ad8aab0d82a972a93bb554ec29a8acb2dd20b112b77b4920378dfeab2b14fc08694e1ca53c81312f2449fc65ae82bf5f6181e107238fa82d52529be7f9ec1fa63464bdfc41e74074423adbe38a239f95d23661ecaf87bfe860b9660fd0e4375d6c0c93d69eb9c62262ea294dcef4a0ad8833da6e213560877f6300f83100514cd59245b63d452a71d8f529c182230b5a5681f62ebe628f76d39fb7347fcc5496896690d5112b12e6070945227034750ae6ae29862a23e166ad9e0fb61c36c76b4b1cf9bea79eb094cafc011d29296ac3ddf0ad13eef1027a0f09b74970aee2e7422f4f6990dfc6dd9ba44d7db14bf80e6126b12b93184f9d85a07fa1338b72a6c692f3c06c688749341025158bbce601208a90c9a39485ce0aa55effef29cad960b36b5277b871ff5108b0be6057fafdfee4e9f3adfda911b6a924b606bf58dcbc1d58b4a2d821498f1ca037451200d5130d93d0e1521e9b8341bbfc33de06e1f564c8a9558436a75b9bc59df93efd6949024f1a97060f5231984dfd2230f86d5b45dee30c78f4ddfea2a3ffa44281c0a88446c0f95258ddee25ba3fe5c5ce0931a007b539875e44b09fd82195f00212018902d1e5ef804caa43fb93569df154c0595213c950705aba805245c835cddfc0d7e931b118a9ce43b57d7374b2a3ba17c67393e7356c1d8d4df75a96b7174e1797c0095d80459711fd40f1bc992740b3be1c1ef8c2b8efa0b7a0a3aa2f4fdfa2b7c02088bf013110f62bb24561aa85f26ba541f116f006de4b403099431f43fe665b07e9d8cc8ac576b20f429cfba8a424fc7ac0936bb0da834ed70e6de2addcf1d600fb66657ccc2de9bc4b79b84b8acd161c6b959a13fbd86f220f947e7aef5f02555c94d953e3f08b33f13da62519c76228a05716530b710a45df91bb8f508cb50bf6a4cbf3663ba93b5bd59d0adede7ad3401946b70382f25a73d1f80274a85a8f8213bd9e143ff8f062d0f449f4cd38525f12cf2cc53c749563d1f24802ec24aab848d99c5a1260af4cbf13dc6981de3a0dac93f4505dba528257be29d108c491bd886b3b151a3912345d396d358f49cc0998075a7722c3b3d5e18f925e065adac844bc4863d73668aed9fcb31943b9f457980df784a85672d68791024659680da25ee5c929712a2b6e1584bf3ff1d3f463f8e0b06c66090e0a864d4b939758370100a4a5225179d355193b1f09edd464e4e00069c44753bd2d8468359de44b55ea65d933e9506319d86f6d169bdbdec1b07be22a5a5f7510b715fc1a8150e21ef5a71605394b0e163efc3b47c88eb87de83694f876007a1d4066b7d7a15ac63b606d85e9aec9195dece3e60eec8a348cc41cd419f3279baea3271ef5c7e62156b8742899cb2263528a4e4b90be6944e3a57f192b8e0e08af3549d0aaa9002dfabf33c1da6b1fe70fe75012ed21755a55dda76efe3408e7f1e4b53503dd1c6053b9b87103a9b8059964c8462e4ccf2eb3e02e651ae26fa840372181b69544087e6804971e10f6d737a83621b8641784f95994384bf1a7be8008874b52a7e0a6a8b820475163f23aa0cf9c209a13ad7d46ed6b96af95e0bd88cfa88637c0b1650a9f457f075fdda8f4cb9b9723b9c90e7fdd5930578b82ea9efd4cc1b6b48477caa961cca3b4a4a35cecc9b150caf5848802250c4546148a25a185fd747389ec12eb182748990a585e8b67896ebdf8d0ae99a02fe31f5c7657500098095f23ca4fd91259749fcaf202ebb0af49b9b160654f2e0c3c0eac427c2b572f776ddcbf58f96ef5aa631e2ac09cc27f732115aa911b25e8db49998000a130bcac24efa56123c84896bc3f148fecd24fe2db177931ebd475167e65d5a692eef2effe17981507eb3433a7e40fabe7eb88261e3963ff8675299e6a43777a3f491c71aeff4b0a4546aaaa7eaa030f9ace040da34293c3c17ab8d3357876dca2777d6017e75348207a3ada60a69fc83a20bbec80ef7af328d981ae68bf1865d35c30da2bf66ebc5746768976c13a1cb61137332f4b6a51ec915d0bd23cb3f6a32d5a1f025328d34f18e4f917673eca74a7ba20e62bf21cbbf4ce9561f037249767842d2d832982d965702955977777fd9962e54f2d4e86c59cf4d168f748551959405fe38ac772bc13717b79829b79d5269a53ad14f1ff10fae4d4957106f2c183f5e3d19def53141aa915f9f070a3c5bfe82c60cb91759e83116dcd2a8cff1992addb89b8a7648e9ee83b0b80e010010380f4baced43f9128005fd9bcde7ffdf37c4e484985abbc645c23d7d74f8421a0db0c644a8026322e496de1c5f77beb1eefe7df2b60118f5af57431cddb5d5d54d48888f66933d4f82f9e43b3fc9fa173a7b1adb537773b112e83931d5d7a721fe017c22044c54417b6bccfd67c1759981aea197b1db238e9f70f5e733aa6a080f2440b9a75293e984c7cb7ce87b0563e1e7fbcee9c2bfcdea14808a7e35715d9b41af7412424e4e9a1916bca178dc407e5bd368accf1675f56f6086875dabb36fdc0bc34bfa063125598bc83b0e600c1a35b81e39caa009a2013d7bd68fe57804612ab238c065fe4af2eed7d3c408358693d6cefde5259fa7479976624bc6167b06881dd4e118cf94b07a3d7bd969ec0fd103ce99cdb870f29bdf40b31c802a914fa974536c77df7cad156b830fbd66a50ed10b3c32b642d9967811d145172821d81e59f21546be8771e883ce77865d346e5b67044639b7ee37cea71ca691658114835264392926fe43cfe567a54d3700c449d12f36b4c7b22f24bc68e922c8580d7f4bba6ef4d31c954d218b33410c0143d121bb5ac05509ce14090b50faa8019095de6bea9b400be26f8b87d5a131078cb5b88bf64be18583fdf060b7157ce70330d07454423e660931cf2c086c41247ef0f00be7e0187c3fce3bc67db220aa6ad0c2346fe152b7fe67eb34ab61882820de65d5d18d97931d06a40f2cd07e9f95d51b6a1efea9baf273b1522f996995ade2c65cebaa86f54b1392c94e71d8540abe1f67d9259ffa4c97e86084f1854600e1a21465a2bfc8fc052fad5f82f355877b70b4db461b5050f59ca9e047357ae4593dc6f08655597dd250201933976cafc48106fe56f0b68333df6cf3c7a1ef6d9ef5d6fa2e70d28e0d5e1abca9e2e90fb89a05f840d0209b9164df4290a875305b217c8b229dbba597d9fb6ecfe860c66da9c9db60f4273b03310351249acac70fc2468b4f68b76383e1a1759f060a8a7e7d041559edd083194e750ee478df903716747503e0858238f83339b1f580c5de97611459c6dd7c5508fcc9c155b6e3a2ee984814257008dc5d73e334b74d45971f1588f910c3faabcf09f979ce5d22e787affee109863bc616ee190d580f4785bd4a4202b0e2a5e9d0cc1772426645144b96ded53f7b7aa8e8b141dd3ed7e003e3fc0e47070c24a745d8c18e22b23b69597801f0ad35d1574764a358b7a5bdf8769ea932dd6fc80e38d5e1ab46b9ffa43d669626b4bf0153895eefc15425eb57726309c483de244e2c15af158a73125b2e47a73ffead4093985722dc1b87ace9b1e92c172f7a50a7e1cd5eca39987941dce2fde0fabcd7f9ec1f55c9ddecd807291bb598f51e835771700d211cc370d026ca23825a930807886bb19b605059db30e122aedbd994c7aa38d32c0bf4fe6953daaccb5fffd5e012f4b6feb0f92d61d058c8ed4143d0b7027e7b6f7225714dd9ff1d5e37049fd15fa742ccb7ba7a38a22f87827b6a563c1380fb1d89d37237c82b3a6292cbc354457f50d66f944d53889697302202195a1320d01e64b083a1515ec3fbf0be8a47ca6e1604b551a3be4ff9664dd173114e89b86e90655a913a26057f1a0d397f0d182c862916d0e89a6da67d1f0e68fb165756046b6970c96c9933fab46d5bc59fe1b657ce8361f2a9b75b4cabb804c7d5709d1905f48165699a3c37c00fcf070e825816358c8551d0c442f9a029771f571cddc3f71e9ec7b67602d87c7f213ce263a902c0d80743df51ee2a76be6ebd8d2686c2bda8bc2b3be2069f5f230b31b06d5161b64d67489b19a892fa603f77a6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="笔记" scheme="http://wolf-ll.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://wolf-ll.github.io/tags/Java/"/>
    
    <category term="项目" scheme="http://wolf-ll.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>MLLM Papers Review</title>
    <link href="http://wolf-ll.github.io/2025/01/08/mllm-papers-review/"/>
    <id>http://wolf-ll.github.io/2025/01/08/mllm-papers-review/</id>
    <published>2025-01-08T07:16:44.000Z</published>
    <updated>2025-04-19T14:55:05.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MLLM-Papers-Review"><a href="#MLLM-Papers-Review" class="headerlink" title="MLLM Papers Review"></a>MLLM Papers Review</h1><h2 id="视频理解"><a href="#视频理解" class="headerlink" title="视频理解"></a>视频理解</h2><h3 id="MVBench"><a href="#MVBench" class="headerlink" title="MVBench"></a>MVBench</h3><p><strong>[CVPR2024 Highlight] MVBench: A Comprehensive Multi-modal Video Understanding Benchmark</strong></p><ul><li>提出了<strong>MVBench</strong>，一个全新的多模态视频理解基准测试，由20项单帧无法有效解决的视频任务组成，用于全面评测现有多模态模型的视频理解能力。<ul><li>在时间任务定义的指导下，为每个任务收集和标注视频。</li><li>选择11个高质量视频annotation数据集，根据任务定义的约束，让GPT为视频<strong>自动生成3-5个问题</strong>并选择其一，答案设计策略分为（1）<strong>模板定义</strong>（如移动方向相关，只限制在前后左右等）；（2）让GPT自己根据任务+annotation<strong>生成</strong>答案。</li><li>GPT问答的生成设计了system prompt和answer prompt。</li></ul></li><li>提出了更强大的基线模型<strong>VideoChat2</strong>，其不仅在MVBench上取得<strong>15个</strong>任务的领先，更在流行的<strong>视频问答、对话、推理</strong>数据集上取得有竞争力的性能。</li></ul><img src="/2025/01/08/mllm-papers-review/image-20250108154042622.png" alt="image-20250108154042622" style="zoom: 67%;"><p><strong>VideoChat2渐进式跨模态训练范式</strong></p><p><strong>阶段1：视觉-语言对齐</strong></p><ul><li>视觉编码器：UMT-L，与BLIP2对比具有更强大的<strong>时空表示学习</strong>能力。</li><li>QFormer：BLIP2训练的三种损失函数：视觉文本对比学习（VTC）、视觉文本匹配（VTM）和基于视觉的文本生成（VTG）</li><li>数据集：CC3M和CC12M的15M图像字幕，WebVid-10M的10M视频字幕。</li><li>目的：对齐UMT-L和QFormer，对齐图像和对应caption，压缩视觉输入。</li></ul><p><strong>阶段2：视觉-语言连接</strong></p><ul><li>LLM：mistral/vicuna/phi</li><li>数据集：除了阶段1以外，进一步引入了2M图像caption（COCO、Visual Genome和SBU）和10M视频caption（InternVid）</li><li>目的：对齐UMT-L、QFormer和LLM，将投影的视觉标记与文本caption对齐。</li></ul><p><strong>阶段3：指令微调</strong></p><p>使用本文生成的指令微调数据进行微调。在冻结的LLM上进行lora低轶微调，通过VTG损失与视觉编码器和QFormer一起调整。此外，借鉴InstructBLIP，<strong>作者在QFormer中也插入了instruction</strong>，用于提取与指令相关的视觉token作为LLM的输入。</p><h3 id="TimeChat"><a href="#TimeChat" class="headerlink" title="TimeChat"></a>TimeChat</h3><p><strong>[CVPR2024] TimeChat: A Time-sensitive Multimodal Large Language Model for Long Video Understanding</strong></p><ul><li><p>一种时间敏感的MLLM，用于长视频理解和准确的<strong>时间定位</strong>。</p><ul><li>两个关键架构：（1）<strong>时间戳感知帧编码器</strong>，可以将视觉内容与每个帧的时间戳绑定；（2）<strong>滑动视频 Q-Former</strong>，生成不同长度的视频token序列，以适应不同时长的视频。</li></ul></li><li><p>指令微调数据集，涉及不同的<strong>时间戳相关的用户指令</strong>，包含 6 个任务和总共 125K 个实例。</p></li></ul><img src="/2025/01/08/mllm-papers-review/image-20250108165902854.png" alt="image-20250108165902854" style="zoom: 50%;"><p><strong>时间戳感知帧编码器</strong></p><ul><li>视觉编码器：ViT-G/14 from EVA-CLIP。</li><li>QFormer：对齐图像和文本标记。通过输入文本“This frame is sampled at 2s.”，把时间戳信息混合进去。压缩图像帧token。</li></ul><p><strong>滑动视频 Q-Former</strong></p><ul><li><p>帧编码器提取帧特征，各帧独立编码，没有建模<strong>帧间时间信息</strong>。–&gt;引入Q-Former滑窗，在<strong>时间维度上增强特征融合</strong>。</p></li><li><p>设计了一个长度为Lw的滑动窗口，并在每个窗口内<strong>利用视频Q-Former从Lw帧中提取Nv长度的视频token</strong>。（<strong>滑窗Lw，步长S，Q-former查询向量数Nv</strong>）最终可以将输入的视频表示为（T /S）×Nv的视频token。</p><ul><li>通俗来说，就是对所有独立的帧token，成组构成patch，然后对token组再做一次自注意力，把帧patch压缩到单一查询向量Nv。</li></ul></li><li><p>然后做线性映射使tokens的特征维度符合LLM的输入特征维度需求。</p></li></ul><p><strong>指令微调</strong></p><ul><li>TimeIT包含了6个与时间戳相关的视频任务，即：(1) 视频说明字幕生成，(2) 视频时间定位，(3) 步骤定位和文字生成，(4) 视频摘要，(5) 视频亮点检测，以及 (6) 转录语音生成。</li></ul><h3 id="ShareGPT4Video"><a href="#ShareGPT4Video" class="headerlink" title="ShareGPT4Video"></a>ShareGPT4Video</h3><p><strong>[NeurIPS 2024] ShareGPT4Video: Improving Video Understanding and Generation with Better Captions</strong></p><ul><li><p><strong>ShareGPT4Video</strong>，包含4万个GPT4V标注的密集视频字幕</p><ul><li>数据过滤：将两分钟内的视频作为候选。使用Panda学生模型生成单句caption，bert编码计算相似度，选择有差异的加入候选集。</li><li>关键帧抽取：clip抽取帧特征，计算相似度，差异大的加入候选集。</li><li>字幕生成：差分滑动窗口pipeline。每次输入到图像多模态模型的内容包括当前关键帧，前一关键帧及其差分字幕。</li></ul></li><li><p><strong>ShareCaptioner-Video</strong>，使用收集的视频字幕数据对<strong>IXC2-4KHD</strong> 进行微调得到的<strong>任意视频标注模型</strong>，由其标注了480万个高质量美学视频。</p></li><li><p><strong>ShareGPT4Video-8B</strong>，一个简单却卓越的LVLM，在三个前沿视频基准测试中达到了最先进（SOTA）性能。</p></li></ul><img src="/2025/01/08/mllm-papers-review/image-20250109151719552.png" alt="image-20250109151719552" style="zoom:67%;"><h3 id="MovieChat"><a href="#MovieChat" class="headerlink" title="MovieChat"></a>MovieChat</h3><p><strong>[CVPR2024] MovieChat: From Dense Token to Sparse Memory for Long Video Understanding</strong></p><ul><li><p>提出了一种有效的内存管理机制，以降低计算复杂度和内存成本，同时增强长期记忆。</p></li><li><p>发布了第一个带有手动注释的长视频理解基准MovieChat-1K。</p></li></ul><img src="/2025/01/08/mllm-papers-review/image-20250109152914961.png" alt="image-20250109152914961" style="zoom:67%;"><ul><li><p>视觉特征提取：EVA-CLIP + QFormer</p></li><li><p>滑动窗口将视频分割成多个片段，每个片段包含 C 帧</p></li><li><p><strong>短期记忆：</strong>将帧token组成的片段存储在临时固定长度缓冲区中。当固定长度的短期记忆达到其预设限制时，所有token将被弹出并合并到长期记忆中。清空并重新初始化短期存储池。（短期记忆窗口长度16）</p></li><li><p><strong>长期记忆：</strong>对弹出的短期帧两两比较相似度，找到整个S中相似度最大的两帧，加权平均合并，不断循环直到整个短期窗口压缩到仅剩2帧。添加到长期记忆池。</p></li><li><p>由于长期记忆中存储的 token 数量可能超过预训练模型的最大长度位置编码，因此需要对位置编码进行扩展。在 MovieChat 中，采用了 BERT 的扩展位置编码方法，使得位置编码能够适应更长的长期记忆。</p></li></ul><p>推理：全局模式（仅使用长期记忆），断点模式（使用长期记忆+指定的查询时间位置为止的短期记忆+指定位置帧Xi的聚合）</p><h2 id="通用多模态"><a href="#通用多模态" class="headerlink" title="通用多模态"></a>通用多模态</h2><h3 id="InternVL"><a href="#InternVL" class="headerlink" title="InternVL"></a>InternVL</h3><p><a href="https://blog.csdn.net/qq_35812205/article/details/140248836">【LLM多模态】InternVL模型架构和训练过程-CSDN博客</a></p><img src="https://i-blog.csdnimg.cn/direct/f26947095f194047af07572ed4afa657.png" alt="img" style="zoom:67%;"><h2 id="视频时间定位"><a href="#视频时间定位" class="headerlink" title="视频时间定位"></a>视频时间定位</h2><h3 id="VTimeLLM"><a href="#VTimeLLM" class="headerlink" title="VTimeLLM"></a>VTimeLLM</h3><p><strong>[CVPR] VTimeLLM: Empower LLM to Grasp Video Moments</strong></p><p>挑战：1. 缺少一个<strong>有精确时间范围标注</strong>的大规模的视频数据集；2. 需要设计有效的<strong>时序相关的视频任务</strong>帮助LLM理解多个时刻的内容。</p><p>方案：1：一个视觉编码器和一个视觉适配器来处理输入视频；2. 一个特制的LLM通过三阶段训练策略来同时理解文本和视频内容。</p><img src="/2025/01/08/mllm-papers-review/image-20250109215253199.png" alt="image-20250109215253199" style="zoom:67%;"><ul><li><strong>阶段一：</strong>视觉特征通过图片-文本对训练与LLM在语义空间对齐。<ul><li>视觉编码器：CLIP ViT-L/14。每一帧有cls token的feature和每个patch的feature，直接采用cls token的作为图片特征。</li><li>视觉适配器：一个线性层，对每一帧的v_cls做变换，映射到LLM空间，最后视频由N*d的特征<strong>Z</strong>代表（N为帧数，d为LLM的隐层维度），这里均匀采样100帧。</li></ul></li><li><strong>阶段二：</strong>设计了单论（single-turn）和多轮（multi-turn）的QA任务来使得模型能够感知到时间边界并理解时间边界内事件内容。<ul><li>数据：InternVid-10M-FLT数据集，自动化对视频进行分割和标注。每个视频都包含多个事件及其粗略的时间注释和描述。</li><li>单轮QA（20%）是密集Video Caption，多轮QA（80%）包括片段描述&amp;时序grounding任务。</li><li>作用：让模型具有时序感知的能力，可以定位视频的segmentation。</li><li>训练：只训练LLM的LoRA，别的组件冻住，Prompt里告诉LLM有一百帧。</li></ul></li><li><strong>阶段三：</strong>创造了一个高质量的对话数据集来指令微调。</li></ul><h3 id="UniVTG"><a href="#UniVTG" class="headerlink" title="UniVTG"></a>UniVTG</h3><p>Video Temporal Grounding（VTG）任务目标是根据文本输入（query），在视频中检索一个或多个与文本相对应的片段。根据检索得到的片段长度及标签粒度不同，过往的VTG任务可以分为Moment Retrieval、Highlight Detection和Video Summarization三类。</p><ol><li>MR旨在通过文本查询定位视频中符合的片段；</li><li>HD旨在给视频各部分打分，越符合视频主题的分数越高；</li><li>VS旨在根据或者不根据文本，来得到视频中多个时间点，这些时间点的片段组合在一起能够较好总结视频内容。</li></ol><p>本文实现首个预训练VTG模型UniVTG，<strong>将不同层次的VTG任务标注及模型结构相统一，</strong>以增强模型在不同粒度的VTG任务上的泛化能力。</p><img src="/2025/01/08/mllm-papers-review/image-20250110171959943.png" alt="image-20250110171959943" style="zoom:67%;"><ul><li>从任务和标签的角度，定义了一种统一的范式。将视频分解为多个等长clips序列，每个clip分配3种基础的标签。从而能够进行统一的预训练。<ul><li>foreground indicator（Point-Level）：0/1二值标签，假如是前景则为1，反之为0。</li><li>boundary offsets（Interval-Level）：二维向量，将特定帧clip的时间戳转换到时间边界。**[a,b]对应当前点距离时间段边界的距离。a为距离起始点的距离，b为距离终止点的距离。**</li><li>saliency score（Curve-Level）：是一个[0,1]的连续值，表示当前clip与查询Q的相关性。</li></ul></li><li>数据收集方面，将帧视为视频的原子组成，VTG任务收集目标clip集合。<ul><li>使用CLIP构建具备Curve-Level标注能力的CLIP Teacher。CLIP Teacher标注根据以下步骤构造：（1）利用CLIP编码帧特征，计算预设语料库concept池文本特征与视频间相似度；（2）选取top-5 concept作为query，对应相似度曲线作为saliency score；（3）将相似度以0.05的间隔进行离散化，并取最大值作为interval。有了interval就能相应生成point。</li></ul></li><li>从模型的角度，提出了一个统一的框架。<ul><li>Cross-modal alignment路径用于输出saliency score，由于saliency代表query和视频之间的相关程度，模型在对query进行注意力池化得到句特征后，直接计算句-视频特征间相似度作为saliency score。该路径采用对比学习损失优化编码过程：同视频内，负样例为相对于正样例clip具有更低saliency的clip；不同视频，负样例为其他视频的query。</li><li>Cross-modal interaction路径用于输出foreground indicator和boundary offsets，其利用注意力建模连接后的query-视频特征，输入卷积层进行预测，损失为分类（indicator）及重叠区间（offsets）损失。</li></ul></li><li>从预训练的角度，利用统一任务和统一框架，进行了大规模的预训练。</li></ul><img src="/2025/01/08/mllm-papers-review/image-20250110180441782.png" alt="image-20250110180441782" style="zoom:67%;"><h3 id="TFVTG"><a href="#TFVTG" class="headerlink" title="TFVTG"></a>TFVTG</h3><p><strong>（ECCV2024）Training-free Video Temporal Grounding using Large-scale Pre-trained Models</strong></p><p>大多数现有的vlm都是通过图像-文本对或视频剪辑-文本对进行训练的，在这种训练范式中，模型的主要目标是将最具区别性的视觉线索与其相应的文本描述联系起来。这使得它很难做到：</p><ul><li>理解同一视频中多个事件的关系，区分<strong>时间界限</strong>；</li><li>对视频中<strong>事件的变换</strong>敏感（从一个事件到另一个事件的动态转变）。</li></ul><p>本文方案：</p><ul><li>基于prompt让LLM将原始查询分成若干子事件，并分析这些事件之间的时间顺序和关系。<ul><li>推理子事件，确定顺序及关系，为事件提供描述。</li></ul></li><li>将一个子事件分为动态过渡和静态状态部分，并提出了使用VLM的动态和静态评分函数，以更好地评估事件和描述之间的相关性。<ul><li>对于动态部分，测量相似度变化率；对于静态部分，测量内部和外部的比较相似度。</li></ul></li><li>对于LLM提供的子事件描述，利用VLM定位最相关的k个proposal。若子事件同时发生，取定位结果交集；若顺序发生，则取并集，得到最终预测。</li></ul><img src="/2025/01/08/mllm-papers-review/image-20250111212738890.png" alt="image-20250111212738890" style="zoom:67%;"><p>选用 BLIP - 2 Q - Former 作为 VLM 定位器。计算文本与视觉特征的余弦相似度来衡量子事件描述与视频帧的相关性</p><ul><li><strong>动态评分</strong>：考虑到视频的连续性，在目标片段的动态部分，视频内容从一个事件过渡到查询所描述的目标事件，<strong>视频帧与查询的相关性应快速提升。</strong>其特征是在静态段内具有较高的平均视频文本相似性，同时在其之外保持较低的平均相似性。</li><li>为消除视频抖动影响，先<strong>对相似度S应用高斯滤波</strong>$\S: \hat S = G(S)$ 再计算相似度差值。$\hat S: D_i = \hat S_i − \hat S_{i-1}$<br>  对于从第i帧开始到第k帧结束的proposal，<strong>当其中所有的差值超过特定阈值时，将该proposal内的差值求和得到动态分数</strong>。<ul><li>也就是先高斯滤波平滑一下余弦相似度，再找相似度变化陡峭的位置判定其可能是事件转换的开端。（可靠性存疑</li></ul></li></ul><img src="/2025/01/08/mllm-papers-review/image-20250111223418627.png" alt="image-20250111223418627" style="zoom:67%;"><ul><li><strong>静态评分</strong>：受 SPL 启发，在静态部分，要求给定查询的最相关事件需满足<strong>事件内视频与查询相关性高，事件外相关性低。</strong>对于从第k帧开始到第j帧结束的proposal，通过计算<strong>proposal内平均相似度与proposal外平均相似度的差值作为静态分数</strong>。</li></ul><img src="/2025/01/08/mllm-papers-review/image-20250111223733515.png" alt="image-20250111223733515" style="zoom:67%;"><ul><li><strong>定位结果选取</strong>：对于每个proposal (i, j)，考虑到不同事件过渡段长度不一，<strong>枚举所有可能的过渡结束时间戳k</strong>，将proposal划分为动态部分(i, k)和静态部分(k, j)，计算动态分数与静态分数之和，并选取最大值作为该proposal的分数。最终，选取分数最高的top-k个proposal作为 VLM 定位器的定位结果。</li></ul><p>预测过滤与整合：</p><ul><li><strong>枚举预测组合</strong>：VLM 定位器针对每个子事件描述返回前 k 个预测结果。假设有 m 个子事件，通过枚举每个子事件的一个预测结果，总共会产生$k^m$种组合。</li><li><strong>顺序约束过滤</strong>：依据 LLM 分析得到的子事件发生顺序，对上述组合进行过滤。若 LLM 判断子事件Pi应在Pj之前发生，但在某组合中Pi的开始时间晚于Pj的结束时间，则该组合不符合顺序逻辑，将被舍弃。</li><li><strong>分数计算与结果整合</strong>：过滤后，计算每个组合的总分，该分数为 VLM 定位器为该组合中各子事件预测返回的最终分数之和。然后，选取总分最高的组合。对于子事件关系，若 LLM 判定子事件同时发生，将该组合中各子事件的预测取交集作为最终预测；若子事件顺序发生，则取并集作为最终预测。</li></ul><h2 id="视频异常检测"><a href="#视频异常检测" class="headerlink" title="视频异常检测"></a>视频异常检测</h2><h3 id="Holmes-VAD"><a href="#Holmes-VAD" class="headerlink" title="Holmes-VAD"></a>Holmes-VAD</h3><h3 id="LAVAD"><a href="#LAVAD" class="headerlink" title="LAVAD"></a>LAVAD</h3><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h3 id="Surveillance-DB"><a href="#Surveillance-DB" class="headerlink" title="Surveillance DB"></a>Surveillance DB</h3><p><strong>Towards Surveillance Video-and-Language Understanding: New Dataset, Baselines, and Challenges</strong></p><p>监控视频对公共安全至关重要，但<strong>现有监控视频任务局限于预定义异常事件的检测与分类，缺乏语义理解能力</strong>。多模态视频数据集虽有发展，但面向监控视频的多模态学习研究不足，原因在于现有监控数据集缺少句子级语言注释，且监控视频特性增加学习难度。为此，文章提出拓展现有监控视频数据集至多模态场景，构建了 UCA 数据集。</p><img src="/2025/01/08/mllm-papers-review/fig-visual.jpg" alt="Abstract Image" style="zoom: 50%;"><ul><li><p>提出了监控视频与语言理解（VALU）这一新的研究方向，并构建了首个多模态监控视频数据集。</p><ul><li>新标注的数据集UCA（UCF-Crime注释）包含23,542个句子，平均长度为20个单词，标注的视频长达110.7小时。</li><li>包含细粒度的注释和事件描述；包含事件的时间戳和活动的描述。</li><li>UCA可以支持多种多模态理解任务，如时间定位(TSGV)，视频字幕(VC)，密集视频字幕生成(DVC)，多模态异常检测(MAD)。</li></ul></li><li><p>在数据集上对四个多模态任务的前沿模型进行了基准测试，这些结果为监控 VALU 提供了新的基线。</p></li><li><p>在MAD实验中提供基本的监控视频字幕模型作为即插即用模块。结果表明，多模态监控学习可以提高异常检测的性能。</p></li></ul><p><strong>数据集构造：</strong>从 UCF - Crime 中过滤低质量视频，得到 1854 个视频组成 UCA。<strong>标注时详细描述事件并记录起止时间，标注间隔 0.1 秒。</strong>完成 23542 条句子级标注。UCA 按视频长度和原始类别分为训练、验证和测试集，涵盖 13 种异常。标注视频总时长 110.7 小时，事件时长多在 5 - 10 秒，平均视频时长 236.8 秒，平均事件标注时长 16.9 秒。平均注释词数约 20 个，名词、动词、形容词比例约为 2:2:1。</p><h2 id="视频监控相关"><a href="#视频监控相关" class="headerlink" title="视频监控相关"></a>视频监控相关</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_63950428/article/details/144700425">【CVPR论文复现】VTimeLLM: Empower LLM to Grasp Video Moments-CSDN博客</a></p><p><a href="https://blog.kamino.link/2024/04/13/UniVTG/">论文笔记 UniVTG：Towards Unified Video-Language Temporal Grounding - Kamino’s Blog</a></p><p><a href="https://blog.csdn.net/wjjc1017/article/details/137606677">大语言模型在视频理解中的应用综述 Video Understanding with Large Language Models: A Survey_videoagent: long-form video understanding with lar-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MLLM-Papers-Review&quot;&gt;&lt;a href=&quot;#MLLM-Papers-Review&quot; class=&quot;headerlink&quot; title=&quot;MLLM Papers Review&quot;&gt;&lt;/a&gt;MLLM Papers Review&lt;/h1&gt;&lt;h2 id=&quot;视</summary>
      
    
    
    
    <category term="笔记" scheme="http://wolf-ll.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MLLM" scheme="http://wolf-ll.github.io/tags/MLLM/"/>
    
    <category term="论文" scheme="http://wolf-ll.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>MLLM Dataset&amp;Code</title>
    <link href="http://wolf-ll.github.io/2024/12/10/mllm-code/"/>
    <id>http://wolf-ll.github.io/2024/12/10/mllm-code/</id>
    <published>2024-12-10T06:31:13.000Z</published>
    <updated>2025-01-08T07:15:48.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MLLM-Dataset-Code"><a href="#MLLM-Dataset-Code" class="headerlink" title="MLLM Dataset&amp;Code"></a>MLLM Dataset&amp;Code</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h3 id="CC3M"><a href="#CC3M" class="headerlink" title="CC3M"></a>CC3M</h3><p>图像caption数据集（共 3318333 张图像），每张图配一个单句字幕。</p><p>huggingface<strong>已处理的版本</strong>（<a href="https://huggingface.co/datasets/pixparse/cc3m-wds/tree/main">pixparse/cc3m-wds at main</a>），使用：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> datasets <span class="token keyword">import</span> load_datasetds <span class="token operator">=</span> load_dataset<span class="token punctuation">(</span><span class="token string">"pixparse/cc3m-wds"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>自行处理的版本</strong>（原始tsv文件：<a href="https://ai.google.com/research/ConceptualCaptions/download">Conceptual Captions</a>）</p><p>先为tsv添加列名<code>sed -i '1s/^/caption\turl\n/' cc3m.tsv</code></p><p>然后解析，脚本（<a href="https://github.com/rom1504/img2dataset/blob/main/dataset_examples/cc3m.md">img2dataset/dataset_examples/cc3m.md at main · rom1504/img2dataset</a>）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">img2dataset <span class="token parameter variable">--url_list</span> cc3m.tsv <span class="token parameter variable">--input_format</span> <span class="token string">"tsv"</span><span class="token punctuation">\</span>         <span class="token parameter variable">--url_col</span> <span class="token string">"url"</span> <span class="token parameter variable">--caption_col</span> <span class="token string">"caption"</span> <span class="token parameter variable">--output_format</span> webdataset<span class="token punctuation">\</span>           <span class="token parameter variable">--output_folder</span> cc3m <span class="token parameter variable">--processes_count</span> <span class="token number">16</span> <span class="token parameter variable">--thread_count</span> <span class="token number">64</span> <span class="token parameter variable">--image_size</span> <span class="token number">256</span><span class="token punctuation">\</span>             <span class="token parameter variable">--enable_wandb</span> True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>caption格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"hard rock artist of hard rock artist performs"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://media.gettyimages.com/photos/lead-singer-steve-perry-of-rock-band-journey-performs-at-the-rosemont-picture-id832243484?s=612x612"</span><span class="token punctuation">,</span>    <span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"000000001"</span><span class="token punctuation">,</span>    <span class="token property">"status"</span><span class="token operator">:</span> <span class="token string">"success"</span><span class="token punctuation">,</span>    <span class="token property">"error_message"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>    <span class="token property">"width"</span><span class="token operator">:</span> <span class="token number">415</span><span class="token punctuation">,</span>    <span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">612</span><span class="token punctuation">,</span>    <span class="token property">"exif"</span><span class="token operator">:</span> <span class="token string">"{\"Image ImageDescription\": \"Lead singer Steve Perry of rock band Journey performs at the Rosemont Horizon in Rosemont, Illinois, June 10, 1983. (Photo by Paul Natkin/Getty Images)\", \"Image Copyright\": \"2017 Paul Natkin\"}"</span><span class="token punctuation">,</span>    <span class="token property">"original_width"</span><span class="token operator">:</span> <span class="token number">415</span><span class="token punctuation">,</span>    <span class="token property">"original_height"</span><span class="token operator">:</span> <span class="token number">612</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据集目前放在<code>Ask-Anything/video_chat2/annotation/videos_images/cc3m</code>路径下。</p><h3 id="WebVid-10M"><a href="#WebVid-10M" class="headerlink" title="WebVid-10M"></a>WebVid-10M</h3><p>视频caption，缺点是<strong>有水印</strong>。论文使用基本都会做预处理。</p><p>CSV文件：</p><ul><li>huggingface：<a href="https://huggingface.co/datasets/TempoFunk/webvid-10M">TempoFunk/webvid-10M · Datasets at Hugging Face</a></li><li>HyperAI：<a href="https://hyper.ai/cn/datasets/17289">WebVid 大型短视频数据集 / 数据集 / HyperAI超神经 | HyperAI超神经</a></li></ul><p>视频数据下载（很多因为网络问题下不下来）：<a href="https://github.com/iejMac/video2dataset/blob/main/dataset_examples/WebVid.md">video2dataset/dataset_examples/WebVid.md at main · iejMac/video2dataset</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">wget</span> <span class="token parameter variable">-nc</span> http://www.robots.ox.ac.uk/~maxbain/webvid/results_10M_train.csvvideo2dataset <span class="token parameter variable">--url_list</span><span class="token operator">=</span><span class="token string">"results_10M_train.csv"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">--input_format</span><span class="token operator">=</span><span class="token string">"csv"</span> <span class="token punctuation">\</span>        --output-format<span class="token operator">=</span><span class="token string">"webdataset"</span> <span class="token punctuation">\</span><span class="token parameter variable">--output_folder</span><span class="token operator">=</span><span class="token string">"dataset"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">--url_col</span><span class="token operator">=</span><span class="token string">"contentUrl"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">--caption_col</span><span class="token operator">=</span><span class="token string">"name"</span> <span class="token punctuation">\</span>        <span class="token parameter variable">--save_additional_columns</span><span class="token operator">=</span><span class="token string">'[videoid,page_idx,page_dir,duration]'</span> <span class="token punctuation">\</span>        <span class="token parameter variable">--enable_wandb</span><span class="token operator">=</span>True <span class="token punctuation">\</span><span class="token parameter variable">--config</span><span class="token operator">=</span><span class="token string">"path/to/config.yaml"</span> <span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>caption格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"videoid"</span><span class="token operator">:</span> <span class="token number">1051729318</span><span class="token punctuation">,</span>    <span class="token property">"page_dir"</span><span class="token operator">:</span> <span class="token string">"095551_095600"</span><span class="token punctuation">,</span>    <span class="token property">"duration"</span><span class="token operator">:</span> <span class="token string">"PT00H00M09S"</span><span class="token punctuation">,</span>    <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"Mount saint helens, washington - the stunning scenery of a rocky mountains during golden hours - wide shot"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://ak.picdn.net/shutterstock/videos/1051729318/preview/stock-footage-mount-saint-helens-washington-the-stunning-scenery-of-a-rocky-mountains-during-golden-hours.mp4"</span><span class="token punctuation">,</span>    <span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"00000034"</span><span class="token punctuation">,</span>    <span class="token property">"status"</span><span class="token operator">:</span> <span class="token string">"success"</span><span class="token punctuation">,</span>    <span class="token property">"error_message"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>    <span class="token property">"yt_meta_dict"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MSR-VTT"><a href="#MSR-VTT" class="headerlink" title="MSR-VTT"></a>MSR-VTT</h3><p>MSR-VTT是一个通用的视频字幕数据集，包括10000个视频片段，每个视频剪辑持续约15秒。标准情况下通常使用6153个片段进行训练，497个片段用于验证，2090个片段用于测试。（压缩包6g）</p><p>数据集：<a href="https://github.com/yangbang18/CARE/blob/master/README_DATA.md">CARE/README_DATA.md at master · yangbang18/CARE</a></p><p>下载： <a href="https://github.com/jpthu17/EMCL?tab=readme-ov-file">NeurIPS 2022 Spotlight] Expectation-Maximization Contrastive Learning for Compact Video-and-Language Representations</a>（这个版本提供了csv，但标注json是category不是caption，服务器的caption忘了从哪下载的了）</p><p>caption格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"video9770.mp4"</span><span class="token punctuation">,</span> <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"a person is connecting something to system"</span><span class="token punctuation">,</span> <span class="token property">"duration"</span><span class="token operator">:</span> <span class="token number">10.8</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"video9771.mp4"</span><span class="token punctuation">,</span> <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"a little girl does gymnastics"</span><span class="token punctuation">,</span> <span class="token property">"duration"</span><span class="token operator">:</span> <span class="token number">13.78</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="COCO"><a href="#COCO" class="headerlink" title="COCO"></a>COCO</h3><ul><li>COCO数据集包含20万个图像；</li><li>80个类别中有超过50万个目标标注,它是最广泛公开的目标检测数据库；</li></ul><p>下载：<a href="https://blog.csdn.net/qq_41847324/article/details/86224628">COCO数据集的下载、介绍及如何使用（数据载入及数据增广，含代码）_coco数据集下载-CSDN博客</a></p><p>数据路径：D:\东南\智慧城市\数据集</p><p>标注数据格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"info"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"COCO 2017 Dataset"</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://cocodataset.org"</span><span class="token punctuation">,</span><span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0"</span><span class="token punctuation">,</span><span class="token property">"year"</span><span class="token operator">:</span> <span class="token number">2017</span><span class="token punctuation">,</span><span class="token property">"contributor"</span><span class="token operator">:</span> <span class="token string">"COCO Consortium"</span><span class="token punctuation">,</span><span class="token property">"date_created"</span><span class="token operator">:</span> <span class="token string">"2017/09/01"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token property">"licenses"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://creativecommons.org/licenses/by-nc-sa/2.0/"</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Attribution-NonCommercial-ShareAlike License"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://creativecommons.org/licenses/by-nc/2.0/"</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Attribution-NonCommercial License"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>…………<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"images"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"license"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token property">"file_name"</span><span class="token operator">:</span> <span class="token string">"000000391895.jpg"</span><span class="token punctuation">,</span><span class="token property">"coco_url"</span><span class="token operator">:</span> <span class="token string">"http://images.cocodataset.org/train2017/000000391895.jpg"</span><span class="token punctuation">,</span><span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">360</span><span class="token punctuation">,</span><span class="token property">"width"</span><span class="token operator">:</span> <span class="token number">640</span><span class="token punctuation">,</span><span class="token property">"date_captured"</span><span class="token operator">:</span> <span class="token string">"2013-11-14 11:18:45"</span><span class="token punctuation">,</span><span class="token property">"flickr_url"</span><span class="token operator">:</span> <span class="token string">"http://farm9.staticflickr.com/8186/8119368305_4e622c8349_z.jpg"</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">391895</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token property">"license"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token property">"file_name"</span><span class="token operator">:</span> <span class="token string">"000000522418.jpg"</span><span class="token punctuation">,</span><span class="token property">"coco_url"</span><span class="token operator">:</span> <span class="token string">"http://images.cocodataset.org/train2017/000000522418.jpg"</span><span class="token punctuation">,</span><span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">480</span><span class="token punctuation">,</span><span class="token property">"width"</span><span class="token operator">:</span> <span class="token number">640</span><span class="token punctuation">,</span><span class="token property">"date_captured"</span><span class="token operator">:</span> <span class="token string">"2013-11-14 11:38:44"</span><span class="token punctuation">,</span><span class="token property">"flickr_url"</span><span class="token operator">:</span> <span class="token string">"http://farm1.staticflickr.com/1/127244861_ab0c0381e7_z.jpg"</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">522418</span><span class="token punctuation">}</span><span class="token punctuation">,</span>…………<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"annotations"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token number">203564</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">37</span><span class="token punctuation">,</span><span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"A bicycle replica with a clock as the front wheel."</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token number">322141</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">49</span><span class="token punctuation">,</span><span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"A room with blue walls and a white sink and door."</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token number">16977</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">89</span><span class="token punctuation">,</span><span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"A car that seems to be parked illegally behind a legally parked car"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>…………<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="InternVID"><a href="#InternVID" class="headerlink" title="InternVID"></a>InternVID</h3><p>github：<a href="https://github.com/OpenGVLab/InternVideo/blob/main/Data/InternVid/README_CN.md">InternVideo/Data/InternVid/README_CN.md at main · OpenGVLab/InternVideo</a></p><p>数据路径：<a href="https://opendatalab.com/shepshep/InternVid">数据集-OpenDataLab</a></p><p>InternVid是一个大规模的以视频为中心的多模态数据集，可用于学习强大且可迁移的视频-文本表示，用于多模态理解和生成。InternVid数据集包含超过700万个视频，总时长近76万小时，共有2.34亿个视频片段，伴随着总计41亿个单词的详细描述。</p><p>作为本次发布的一部分，我们提供了数据集的一个子集InternVid-10M-FLT，包含<a href="https://opendatalab.com/datasets/#">1000万个视频片段</a>。相关视频对应的Youtube ID和对应的文本描述详见caption.jsonl,对应的处理后的视频片段下载详见<a href="https://opendatalab.com/datasets/#">链接</a>,另外还包括了使用<a href="https://opendatalab.com/datasets/#">UMT</a>计算对应视频片段和文本的相关度UMT-SIM（已归一化*）和美学评分Aesthetic_Score（使用LAION<a href="https://opendatalab.com/datasets/#">美学评估模型</a>），其对应的示例如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"YoutubeID"</span><span class="token operator">:</span> <span class="token string">"HdYoyzCSWyw"</span><span class="token punctuation">,</span> <span class="token property">"Start_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:03:10.567"</span><span class="token punctuation">,</span> <span class="token property">"End_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:03:11.200"</span><span class="token punctuation">,</span> <span class="token property">"Caption"</span><span class="token operator">:</span> <span class="token string">"woman using a computer mouse and keyboard"</span><span class="token punctuation">,</span> <span class="token property">"Aesthetic_Score"</span><span class="token operator">:</span> <span class="token number">4.58984375</span><span class="token punctuation">,</span> <span class="token property">"UMT_Score"</span><span class="token operator">:</span> <span class="token number">0.39794921875</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"YoutubeID"</span><span class="token operator">:</span> <span class="token string">"qJrOyggIB-w"</span><span class="token punctuation">,</span> <span class="token property">"Start_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:07:33.689"</span><span class="token punctuation">,</span> <span class="token property">"End_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:07:51.085"</span><span class="token punctuation">,</span> <span class="token property">"Caption"</span><span class="token operator">:</span> <span class="token string">"a screen shot of heroes of the storm with people in action"</span><span class="token punctuation">,</span> <span class="token property">"Aesthetic_Score"</span><span class="token operator">:</span> <span class="token number">4.29296875</span><span class="token punctuation">,</span> <span class="token property">"UMT_Score"</span><span class="token operator">:</span> <span class="token number">0.4501953125</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"YoutubeID"</span><span class="token operator">:</span> <span class="token string">"pDq9UzfCtGw"</span><span class="token punctuation">,</span> <span class="token property">"Start_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:08:14.520"</span><span class="token punctuation">,</span> <span class="token property">"End_timestamp"</span><span class="token operator">:</span> <span class="token string">"00:08:37.120"</span><span class="token punctuation">,</span> <span class="token property">"Caption"</span><span class="token operator">:</span> <span class="token string">"in october, 2019, in lviv, there was a conference about the legal information technology"</span><span class="token punctuation">,</span> <span class="token property">"Aesthetic_Score"</span><span class="token operator">:</span> <span class="token number">4.28515625</span><span class="token punctuation">,</span> <span class="token property">"UMT_Score"</span><span class="token operator">:</span> <span class="token number">0.375732421875</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：之前发布的UMT-SIM实际由OpenAI的CLIP-L计算得到。</p><p>pytube数据集下载：<a href="https://blog.csdn.net/qq_43854103/article/details/134884707">InternVid数据集的下载指南-CSDN博客</a></p><p>403 forbidden：<a href="https://github.com/pytube/pytube/issues/1570">it showing streaming data error · Issue #1570 · pytube/pytube</a></p><img src="/2024/12/10/mllm-code/image-20250107151235469.png" alt="image-20250107151235469" style="zoom:67%;"><p>400 bad request：<a href="https://stackoverflow.com/questions/78160027/how-to-solve-http-error-400-bad-request-in-pytube">python - How to solve HTTP Error 400: Bad Request in PyTube? - Stack Overflow</a></p><img src="/2024/12/10/mllm-code/image-20250107151321921.png" alt="image-20250107151321921" style="zoom:67%;"><h2 id="InternLM-XComposer2-4KHD"><a href="#InternLM-XComposer2-4KHD" class="headerlink" title="InternLM-XComposer2-4KHD"></a>InternLM-XComposer2-4KHD</h2><p>IXC2-4KHD结构</p><ul><li>视觉编码器：OpenAI CLIP ViT-L-14-336，添加动态分辨率方案</li><li>projector 层：MLP</li><li>LLM ：为最新的 InternLM2</li><li>预训练：训练Vit，MLP投影和LLM；</li><li>微调：Partial LoRA (P-LoRA)</li></ul><img src="/2024/12/10/mllm-code/image-20241211142115207.png" alt="image-20241211142115207" style="zoom: 67%;"><p>和 llava next 一样，模型输入包括两个视图，具体做法为：</p><ul><li>对于给定的任意一张图片，训练时候需要指定这张图片希望切分为最多为多少个 patch，例如论文说的 HD-9，HD-25 和 HD-55，HD-9 也就是说经过处理后这张图片，这种图片最多(<strong>可以少</strong>)可以切分为 9 个 patch，假设正好可以切分为 9 个 patch，那么可能输出分辨率为 1008×1008, 672×1344, 336×3024，至于到底选择的是那个分辨率则是依据图片宽高比来确定的，算法的目标是<strong>在接近 9 个 patch 情况下，图片后续 padding 的像素最少即可</strong></li><li>假设算出来是 672×1344，那么图片会在先进行保持宽高比情况下 resize，然后 padding 为 672×1344（下面函数到这里为止）</li><li>上述就得到高分辨率图了，将这个 672×1344 图片直接强制 resize 为 336x336 就得到了<strong>全局视图</strong></li><li>为了让模型更容易理解 patch，如上所示，作者在每一行后面加一个可学习的 \n 特殊 token，并且也加了一个可学习的 sp 特殊 token</li><li>由于在 HD 输入下，token 非常多，直接训练肯定会炸了，例如 HD-55，此时的 patch 一共 55+1=56 个，每个 patch 输出 576 个 token，那么就有 32256 个 image token，这就有点夸张了。所以作者简单的进行 token merge了，就是相邻的 4 个 token 合并，将信息转换到通道维度了，<strong>此时最多的 Image token 是 8064 了，虽然也很多，但是至少看起来还行。</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">HD_transform</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> hd_num<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># hd_num 期望切分的最大patch数</span>    width<span class="token punctuation">,</span> height <span class="token operator">=</span> img<span class="token punctuation">.</span>size    <span class="token keyword">if</span> width <span class="token operator">&lt;</span> height<span class="token punctuation">:</span>        width<span class="token punctuation">,</span> height <span class="token operator">=</span> img<span class="token punctuation">.</span>size    ratio <span class="token operator">=</span> <span class="token punctuation">(</span>width <span class="token operator">/</span> height<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ratio<span class="token punctuation">)</span>    <span class="token comment"># 假设某条边扩展为 n 个 patch，此时可以得到在宽高比不变情况下另一条边最多可以扩展为 n/ratio 个 patch</span>    <span class="token comment"># 如果总的 patch 数 (scale*np.ceil(scale/ratio) )接近 hd_num 但是不超过 hd_num，那么就选择这个</span>    scale <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># scale计算某条边扩展到多少patch数</span>    <span class="token keyword">while</span> scale<span class="token operator">*</span>np<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>scale<span class="token operator">/</span>ratio<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> hd_num<span class="token punctuation">:</span>        scale <span class="token operator">+=</span> <span class="token number">1</span>    scale <span class="token operator">-=</span> <span class="token number">1</span>        new_w <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>scale <span class="token operator">*</span> <span class="token number">336</span><span class="token punctuation">)</span><span class="token comment"># 每个patch 336*336</span>    new_h <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>new_w <span class="token operator">/</span> ratio<span class="token punctuation">)</span>    img <span class="token operator">=</span> transforms<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token punctuation">[</span>new_h<span class="token punctuation">,</span> new_w<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span>    <span class="token comment"># 确保能够被 336 整除，周围padding填充</span>    img <span class="token operator">=</span> padding_336<span class="token punctuation">(</span>img<span class="token punctuation">)</span>    <span class="token keyword">return</span> img<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="VideoChat2"><a href="#VideoChat2" class="headerlink" title="VideoChat2"></a>VideoChat2</h2><h2 id="配置记录"><a href="#配置记录" class="headerlink" title="配置记录"></a>配置记录</h2><h3 id="pycharm映射"><a href="#pycharm映射" class="headerlink" title="pycharm映射"></a>pycharm映射</h3><p><img src="/2024/12/10/mllm-code/image-20250103155952566.png" alt="image-20250103155952566" style="zoom: 50%;"><img src="/2024/12/10/mllm-code/image-20250103160038049.png" alt="image-20250103160038049" style="zoom: 67%;"></p><h3 id="依赖版本"><a href="#依赖版本" class="headerlink" title="依赖版本"></a>依赖版本</h3><p>cuda-runtime              12.1.0                        0    nvidia<br>cuda-version              12.4                 hbda6634_3    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>ffmpeg                    6.1.1                h4c62175_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>ffmpeg-python             0.2.0                    pypi_0    pypi<br>fontconfig                2.14.1               h4c34cd2_2    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>freetype                  2.12.1               h4a9f257_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>numpy                     1.23.5           py39hf6e8229_1    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>numpy-base                1.23.5           py39h060ed82_1    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>pandas                    2.0.3            py39h1128e8f_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>peft                      0.4.0                    pypi_0    pypi<br>pillow                    10.0.0                   pypi_0    pypi<br>pip                       24.2             py39h06a4308_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>python                    3.9.20               he870216_1    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>pytorch-cuda              12.1                 ha16c6d3_6    pytorch<br>scipy                     1.13.0                   pypi_0    pypi<br>sentencepiece             0.1.99                   pypi_0    pypi<br>tokenizers                0.15.2                   pypi_0    pypi<br>torch                     1.13.1+cu117             pypi_0    pypi<br>torchaudio                0.13.1+cu117             pypi_0    pypi<br>torchvision               0.14.1+cu117             pypi_0    pypi<br>tqdm                      4.66.1             pyhd8ed1ab_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a><br>transformers              4.37.1                   pypi_0    pypi<br>urllib3                   2.2.3            py39h06a4308_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>wandb                     0.16.6             pyhd8ed1ab_1    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a><br>wheel                     0.44.0           py39h06a4308_0    <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>CC3M数据集：<a href="https://huggingface.co/datasets/pixparse/cc3m-wds/tree/main">pixparse/cc3m-wds at main</a></p><p>WebVid数据集：<a href="https://huggingface.co/datasets/TempoFunk/webvid-10M">TempoFunk/webvid-10M · Datasets at Hugging Face</a></p><p>MSR-VTT数据集：<a href="https://mmaction2.readthedocs.io/zh-cn/dev-1.x/dataset_zoo/msrvtt.html">准备 MSR-VTT 检索/视频问答数据集 — MMAction2 1.2.0 文档</a></p><ul><li><p>下载：<a href="https://github.com/jpthu17/EMCL?tab=readme-ov-file">NeurIPS 2022 Spotlight] Expectation-Maximization Contrastive Learning for Compact Video-and-Language Representations</a></p></li><li><p>对应google云：<a href="https://drive.google.com/drive/folders/1LYVUCPRxpKMRjCSfB_Gz-ugQa88FqDu_">MSRVTT - Google Drive</a></p></li><li><p>这个版本不是服务器用的版本，标注json只有category没有caption</p></li></ul><p>COCO数据集：<a href="https://blog.csdn.net/qq_41185868/article/details/82939959">Dataset之COCO数据集：COCO数据集的简介、下载、使用方法之详细攻略-CSDN博客</a></p><p>InternVID数据集：<a href="https://opendatalab.com/shepshep/InternVid">数据集-OpenDataLab</a></p><p>Video-LLaVA训练：<a href="https://github.com/PKU-YuanGroup/Video-LLaVA/blob/main/TRAIN_AND_VALIDATE.md">Video-LLaVA/TRAIN_AND_VALIDATE.md at main · PKU-YuanGroup/Video-LLaVA</a></p><p>IXC2-4KHD：<a href="https://zhuanlan.zhihu.com/p/692049805">MLLM-算法推荐-2024.4.12] InternLM-XComposer2-4KHD 处理高分辨率有一手 - 知乎</a></p><p>pycharm连接服务器（核心是deployment ssh配置+mapping填对）：<a href="https://blog.csdn.net/qq_42730750/article/details/119249193">Pycharm远程连接服务器进行代码的运行与调试_remote sdk is saved in idesetting-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MLLM-Dataset-Code&quot;&gt;&lt;a href=&quot;#MLLM-Dataset-Code&quot; class=&quot;headerlink&quot; title=&quot;MLLM Dataset&amp;amp;Code&quot;&gt;&lt;/a&gt;MLLM Dataset&amp;amp;Code&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="笔记" scheme="http://wolf-ll.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MLLM" scheme="http://wolf-ll.github.io/tags/MLLM/"/>
    
    <category term="代码" scheme="http://wolf-ll.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ShareGPT4Video</title>
    <link href="http://wolf-ll.github.io/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/"/>
    <id>http://wolf-ll.github.io/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/</id>
    <published>2024-12-03T07:53:21.000Z</published>
    <updated>2024-12-16T07:25:07.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ShareGPT4Video"><a href="#ShareGPT4Video" class="headerlink" title="ShareGPT4Video"></a>ShareGPT4Video</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>论文推出了ShareGPT4Video系列，旨在通过<strong>密集且精确的标注</strong>促进大型视频语言模型（large video-language models, LVLMs）的<strong>视频理解</strong>和文本到视频模型（text-to-video models, T2VMs）的<strong>视频生成</strong>。该系列包括：</p><p>1）<strong>ShareGPT4Video</strong>，包含4万个GPT4V标注的密集视频字幕，这些视频具有不同长度和来源，通过精心设计的数据过滤和标注策略开发。</p><p>2）<strong>ShareCaptioner-Video</strong>，一个高效且能力强大的<strong>任意视频标注模型</strong>，由其标注了480万个高质量美学视频。</p><p>3）<strong>ShareGPT4Video-8B</strong>，一个简单却卓越的LVLM，在三个前沿视频基准测试中达到了最先进（SOTA）性能。</p><p>为了达成上述目标，不考虑不可扩展且成本高昂的人工标注，作者发现使用GPT4V对视频进行标注，采用简单的多帧或帧连接输入策略，会导致<strong>细节不足，生成的字幕不够详细且会出现时间混淆</strong>的结果。针对这一问题，作者认为设计高质量视频标注策略的挑战在于三个方面：<strong>1) 帧间精确的时间变化识别。2) 帧内详细内容描述。3) 任意长度视频的帧数可扩展性。</strong></p><p>为此，论文精心设计了一种<strong>差分视频标注策略</strong>，该策略稳定、可扩展且高效，适用于生成<strong>任意分辨率、宽高比和长度的视频标注</strong>。基于此，论文构建了ShareGPT4Video，包含4万个高质量视频，涵盖广泛类别，其标注涵盖丰富的<strong>世界知识、物体属性、摄像机运动</strong>，以及关键的、详细且精确的<strong>事件时间描述</strong>。基于ShareGPT4Video，论文进一步开发了ShareCaptioner-Video，一个<strong>能够高效生成任意视频高质量标注的优秀标注器。</strong>本文通过它标注了480万个具有美学吸引力的视频，并在<strong>10秒文本到视频生成任务</strong>中验证了其有效性。对于视频理解，论文验证了ShareGPT4Video在几种当前LVLM架构上的有效性，并展示了论文卓越的新大型视频语言模型 ShareGPT4Video-8B。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241203171739454.png" alt="image-20241203171739454" style="zoom:67%;"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>LLM的驱动下，多模态学习中<strong>图文对话</strong>（image-text dialogue）和<strong>文生图</strong>任务（text-to-image generation tasks）已经取得了最新进展。这也激发了向<strong>视频理解</strong>和<strong>生成任务</strong>的转变，允许用户跨视频和语言模式的交互。因此，详细和高保真的视频字幕，连接上述模态，有助于推动该领域的进展。</p><p>尽管视频内容具有丰富的语义和时间信息，但现有数据中视频通常<strong>只配有简短的描述</strong>。这些简短的描述<strong>限制了对视频的深入理解以及视频生成的可控性</strong>。虽然图像-文本对话和文本到图像生成任务中已认识到详细描述的重要性，但在视频理解和生成方面类似的努力仍然不足。</p><p>然而，创建大规模、高质量的视频描述是一项挑战性任务。即使是人类，为长视频生成详细的描述也是<strong>复杂且耗时</strong>的，这阻碍了大规模的标注工作。<strong>当前的开源大规模视觉语言模型（LVLMs）缺乏这种能力，而闭源API尚不支持视频输入。</strong></p><p>另一方面，如果将视频输入<strong>简化为多个帧</strong>，即使是GPT4V也难以提供满意质量的描述。例如，一个直观的想法是向GPT4V提供带有时间戳的多帧视频，并生成描述，但论文发现GPT4V在描述时表现不稳定，有时会<strong>误解帧之间的时间关系</strong>，且<strong>随着视频帧数的增加，其性能进一步下降</strong>。其他解决方案，如将所有帧拼接成一张大图，<strong>对于解决时间问题并无帮助</strong>，且随着帧数的增加，描述的细节会丢失。论文在图11-12中展示了这些问题。</p><p>论文认为，制定有效的视频描述策略的挑战源于三个基本方面：1) <strong>帧间精确的时间变化理解</strong>：时间维度将视频与图像区分开来。不精确的时间描述会显著降低视频描述的质量，并在训练模型时引起混淆。2) <strong>帧内详细内容的描述</strong>：详细描述对于图像与文本模态之间的对齐至关重要，对于视频-文本对齐也同样重要。3) <strong>任意长度视频的帧数可扩展性</strong>：在实际应用中，视频的长度差异很大。理想的描述策略应能适应这种变化，并为任何长度的视频生成适当的描述。</p><p>为此，论文提出了<strong>差分滑动窗口</strong>标注策略 <strong>Differential Sliding-Window Captioning strategy</strong> (DiffSW)，该策略稳定、可扩展且高效，适用于为任意视频生成描述。DiffSW的核心理念是<strong>将  所有帧到描述（all-frames-to-caption）  的任务转化为差分描述任务</strong>。具体而言，本文<strong>为第一帧生成详细字幕</strong>，然后按时间顺序对后续帧应用长度为二的滑动窗口。GPT4V负责基于三个输入（前一帧、其差分字幕和当前帧）识别帧间变化。这包括了照相机运动、对象运动、角色动作和场景转换。获取所有差分字幕后，这些字幕将输入到GPT4生成<strong>整个视频的综合描述</strong>。差分概念使DiffSW能够<strong>集中于帧间的变化</strong>，即<strong>时序变化</strong>。滑动设计确保<strong>了时间顺序的正确性和帧数的不变性</strong>，保证GPT4V不遗漏细节并高效利用API，从而实现稳定、可扩展和高效的字幕质量。此外，差分设计允许通过重用其差分字幕来重新标注带字幕视频的任何子剪辑。</p><p>基于DiffSW，本文构建了<strong>ShareGPT4Video</strong>，包含4万组高质量的视频-字幕对，涵盖广泛类别，由此产生的字幕包含了丰富的世界知识、对象属性、相机运动，以及对事件的详细和精确的时间描述。ShareGPT4Video的视频来自不同来源，采用<strong>基于语义的数据过滤</strong>策略来减轻这些视频之间的内容同质性。然后对视频采用<strong>语义感知的关键帧提取</strong>策略，以减少时间冗余。将DiffSW应用于关键帧，生成高质量的字幕，并通过<strong>层次提示设计</strong>进一步提高了其稳定性和质量。采用<strong>人工质量检查</strong>，以确保视频字幕的质量。</p><p>基于ShareGPT4Video，本文提供了<strong>ShareCaptionor-Video</strong>,，一种特殊的<strong>视频标注器</strong>，能够有效地为广泛的<strong>分辨率、纵横比和持续时间</strong>的视频<strong>生成高质量的字幕</strong>。它能够以较低的成本和令人满意的质量，进一步<strong>扩展高质量的视频字幕数据</strong>，本文作者为480万个视频（总计约3000小时）生成高质量的字幕。</p><p>作者<strong>在视频理解和生成任务中进行了广泛的实验</strong>，以证明高质量的视频字幕数据集和优越的视频标注器的价值。在视频生成方面，在4.8M视频-字幕对上训练的基于DiT的文本到视频模型在生成10秒高分辨率视频-字幕对内容生成的细粒度控制方面表现良好。为了理解视频，ShareGPT4Video通过替换一小部分训练数据，在多个基准测试上为多个当前lvlm带来了一致的性能提高。本文进一步提出了ShareGPT4Video-8B，一个简单而出色的LVLM，在三个先进而全面的视频基准上达到了SOTA的性能。</p><h2 id="ShareGPT4Video数据集"><a href="#ShareGPT4Video数据集" class="headerlink" title="ShareGPT4Video数据集"></a>ShareGPT4Video数据集</h2><p>图2展示了ShareGPT4Video数据集构建的完整pipeline。首先要基于<strong>感官质量与内容复杂性</strong>选择多种不同的视频数据源。随后，使用<strong>基于语义的数据过滤</strong>来防止内容的同质化。然后，应用<strong>语义感知的关键帧提取</strong>来进行<strong>稀疏采样</strong>，以保持显著的语义变化。最后，实现了一个<strong>差分滑动窗口标注策略</strong>，利用GPT-4V来生成<strong>详细</strong>的和<strong>时间上丰富</strong>的描述。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241203225514426.png" alt="image-20241203225514426" style="zoom: 67%;"><h3 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h3><p><strong>数据源选择</strong>：为了服务于视频理解和视频生成任务，论文在收集过程中考虑视频的美学质量和内容复杂性：</p><ul><li>论文首先考虑<strong>Panda-70M</strong>，这是一个从YouTube获取的<strong>高分辨率视频数据集</strong>，包含时长约<strong>一分钟</strong>的片段。这个开放领域来源覆盖了<strong>野生动物、烹饪、体育、新闻与电视节目、游戏与3D渲染</strong>等多样领域。它通常包含<strong>复杂的内容和过渡</strong>，为理解各种现实世界场景提供了坚实基础。</li><li>然而，这些内容和过渡的复杂性<strong>对视频生成领域提出了重大挑战</strong>。为了解决这一问题，论文还从一些用户上传视频网站获取了大量美学上吸引人的视频。这些视频主要由<strong>风景和美学上令人愉悦的人类活动</strong>组成，涉及<strong>较少的过渡和更简单的事件</strong>。</li><li>最后，论文通过选择来自<strong>Ego4D 和BDD100K</strong> 的视频来补充数据集，填补自我中心人类活动和自动驾驶场景中的空白，确保论文的视频来源尽可能多地涵盖现实世界场景。</li></ul><p><strong>基于语义的数据过滤</strong>。尽管论文的字幕生成方法能够支持较长时间的视频，但由于<strong>视频时长与数量之间的权衡</strong>，数据采集主要集中在<strong>短于两分钟</strong>的视频上。</p><ul><li>论文首先从选定的数据源中<strong>过滤掉超过两分钟的视频</strong>，将两分钟内的视频作为候选。随后，论文引入了一种<strong>基于语义的数据过滤</strong>策略，以减少这些候选视频之间的内容同质性，并保持最终视频数据集的多样性。该方法旨在<strong>从候选视频池中选择具有显著主题差异的视频</strong>，以构成论文的最终视频集合。</li><li>具体而言，论文首先使用<strong>Panda-Student</strong> 模型为每个候选视频<strong>生成一个简短的单句字幕</strong>，然后维护一个最终的视频候选池。每当处理一个新的视频V时，使用<strong>Bert-Base-Uncased</strong>语言模型对其相应的<strong>短字幕S进行编码</strong>，以获得CLS标记Pn+1∈R^1×D，它<strong>捕获高级语义表达</strong>。然后我们计算这个CLS标记P^n+1和候选池中的视频CLS标记{P1，P2，…Pn}的<strong>相似度</strong>。只有当一个新视频的<strong>最大相似度低于预定义的阈值时</strong>，该新视频才会被添加到池中。</li><li>论文提供了伪代码，如图14所示。</li></ul><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204115240634.png" alt="image-20241204115240634" style="zoom: 50%;"><h3 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h3><p>视频在时间维度上通常是冗余的，而<strong>关键帧采样</strong>是<strong>紧凑地表示视频</strong>的一般思想。然而，传统的<strong>关键帧提取方法（key-frame extraction methods）</strong>通常难以<strong>确保语义的连贯性</strong>，导致缺少<strong>覆盖关键变化和过渡</strong>的关键帧。因此，本文开发了一种语义感知的关键帧提取方法，它可以在减少时间冗余和保持语义连贯性之间取得平衡。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204151350827.png" alt="image-20241204151350827" style="zoom:67%;"><h4 id="语义感知的关键帧提取"><a href="#语义感知的关键帧提取" class="headerlink" title="语义感知的关键帧提取"></a>语义感知的关键帧提取</h4><p>将V表示为从固定2秒间隔的视频中采样的T帧集，计算关键帧集合V’，<strong>该集合足够稀疏但能全面覆盖视频内事件的演变</strong>。论文将CLIP-Large图像编码器的输出CLS token视为<strong>每个帧的全局语义</strong>，并<strong>移除具有高语义相似性的相邻帧</strong>。在实践中，论文<strong>初始化</strong>关键帧集合V’为<strong>V的第一帧</strong>。对于V中的每个帧，论文<strong>计算其与V’中最新关键帧的语义相似度d</strong> 。如果d低于预定义的阈值，论文将该帧视为关键帧并将其添加到V’中。如果不是，则该帧被作为冗余帧跳过。为了完整性，<strong>V的最后一帧总是被添加到V’中</strong>。论文提供了伪代码，如图15所示。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204152438461.png" alt="image-20241204152438461" style="zoom: 50%;"><h3 id="字幕生成pipeline"><a href="#字幕生成pipeline" class="headerlink" title="字幕生成pipeline"></a>字幕生成pipeline</h3><p>正如第一节引言中提到的，本文发现如果直接将所有帧输入GPT4V，GPT4V难以稳定生成具有正确时序关系的字幕，并且随着帧数的增加，其性能进一步恶化。另一方面，如果论文将所有帧合并成一张大图，随着帧数的增加，GPT4V会丢失更多细节，如图11-12所示。</p><p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204153952314.png" alt="image-20241204153952314" style="zoom:50%;"><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204154030747.png" alt="image-20241204154030747" style="zoom:50%;"></p><h4 id="差分滑动窗口字幕生成"><a href="#差分滑动窗口字幕生成" class="headerlink" title="差分滑动窗口字幕生成"></a>差分滑动窗口字幕生成</h4><p>为此，论文开发了一种差分滑动窗口字幕生成pipeline，用于为各种视频生成高质量的字幕，<strong>并附带详细的时序描述</strong>。</p><p>具体而言，每次输入到图像多模态模型的内容包括<strong>当前关键帧，前一关键帧及其差分字幕</strong>。接着，论文引入了差分prompt，引导GPT4V<strong>关注当前帧与前一帧之间的变化</strong>，如<strong>姿态、位置、摄像机角度</strong>等。此外，将前一帧的差分字幕作为<strong>补充上下文</strong>融入，提高了响应质量并减少了幻觉现象。这是因为<strong>图像嵌入和文本字幕分别提供了图像的显式和隐式表示</strong>。差分字幕不仅增加了额外的上下文，还<strong>整合了来自两帧之前的时序信息</strong>，进一步增强了模型的<strong>时序理解</strong>能力。需要注意的是，对于第一帧，它的差分字幕直接由标准字幕替换。</p><p>最后，论文将所有差分字幕及其相应的时间戳输入到GPT4中。设计了一个特定的<strong>总结prompt</strong>，指导大型语言模型生成具有<strong>精确时序动态和详细空间信息</strong>的高质量视频字幕。在实践中，论文使用<strong>GPT-4-Turbo-04-09</strong>进行所有标注。</p><p>在提示的设计中，作者发现<strong>显式的层次提示设计</strong>有助于GPT4V理解其角色、预期格式和操作边界。这种方法有助于稳定输出的格式，并提高结果的整体质量。</p><h4 id="分层提示设计"><a href="#分层提示设计" class="headerlink" title="分层提示设计"></a>分层提示设计</h4><p>分层提示设计（Hierarchical Prompt Design）帮助多模态模型和语言模型在captioning过程中有效地执行它们的角色。</p><p>图7和图8分别阐述了<strong>差分字幕提示（differential-caption prompt）</strong>和<strong>摘要（总结）提示（summary prompt）</strong>。</p><p>层次化prompt主要由四个组件组成。<strong>角色</strong>（character）部分为模型提供了对它所扮演的角色和它所面临的工作环境的整体感知。<strong>技能</strong>（skills）部分指定了模型需要拥有的技能，确保精确地符合多个要求，而不存在遗漏或混淆。<strong>约束</strong>（constraints）部分澄清了用户<strong>不希望执行的行为，以及在构建输出时要遵循的规则</strong>。<strong>结构化输入</strong>（Structured Input）部分要求用户<strong>根据他们的特定场景进行设置</strong>。</p><p>例如，当指导模型生成差分字幕时，角色部分通知模型它是分析视频帧的专家。技能部分要求模型来描述帧间的目标动作和行为、环境和背景的变化、目标外观属性的变化，以及反映时间变化的摄像机运动。约束部分要求精确的描述，而不是逐项列出它们。在“结构化输入”部分中，输入由帧索引、时间戳、前一帧和它的差分字幕组成。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204170526404.png" alt="image-20241204170526404" style="zoom: 50%;"><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204170617540.png" alt="image-20241204170617540" style="zoom:50%;"><h2 id="ShareCaptioner-Video"><a href="#ShareCaptioner-Video" class="headerlink" title="ShareCaptioner-Video"></a>ShareCaptioner-Video</h2><h3 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h3><p>论文使用收集的视频字幕数据对<strong>IXC2-4KHD</strong> 进行微调，从而得到论文的ShareCaptioner-Video。为了灵活使用，论文对数据进行了重新组织，以支持以下功能：</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204172727478.png" alt="image-20241204172727478" style="zoom:67%;"><ol><li><strong>快速字幕生成</strong>：该模型采用图像网格格式（image-grid format）进行直接字幕生成（direct video captioning），提供了<strong>适用于短视频的快速生成速度</strong>。在实践中，论文<strong>将视频的所有关键帧连接成一个垂直拉长的图像</strong>，并在字幕任务上对模型进行训练。</li><li><strong>滑动字幕生成</strong>：该模型支持以差分滑动窗口格式（differential sliding-window format）进行流式字幕生成，生成<strong>适用于长视频</strong>的高质量字幕。与第2.3节中使用的字幕流程类似，将两个相邻关键帧及前面的字幕作为输入，并训练模型描述它们之间发生的事件。</li><li><strong>片段摘要</strong>：该模型可以快速总结来自ShareGPT4Video或经历了差分滑动窗口字幕生成过程的视频的任何片段，无需重新处理帧。论文将所有差分描述作为输入，输出为视频字幕。</li><li><strong>prompt重述</strong>：模型可以根据用户输入的特定视频生成领域的提示进行重述，确保基于高质量视频字幕数据训练的T2VM<strong>在推理过程中与其训练中保持格式对齐</strong>。在实践中，论文使用GPT-4生成Sora风格的提示，用于论文的密集字幕，并以相反的方式训练re-captioning任务，即  使用生成的prompt作为输入，密集字幕作为训练目标。（这个没懂</li></ol><p>在实践中，作者在一个epoch内对模型进行端到端微调。遵循默认的高分辨率策略，使用“HD-55”用于快速字幕任务，其他的则使用“HD-25”。所有模型组件的学习速率都是一致的，并在前1%的step内从0升温到2.5×10−5。批处理大小设置为1024，且对数据进行统一采样。</p><h3 id="规模化caption"><a href="#规模化caption" class="headerlink" title="规模化caption"></a>规模化caption</h3><p>为了验证论文的ShareCaptioner-Video在视频字幕生成任务中的有效性，并进一步支持视频生成领域的发展，论文利用它对大量审美吸引人的视频进行了注释。具体来说，论文从三个来源精心收集和处理了480万个视频剪辑，总计约3000个小时，分别是： MixKit，Pexels 和Pixabay。随后，采用ShareCaptioner-Video的滑动字幕生成模式，为这些视频生成高质量的字幕。整个字幕生成过程需要大约4000个H100 GPU小时。图8中提供了一些关于生成的字幕的统计信息。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204212139827.png" alt="image-20241204212139827" style="zoom: 50%;"><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="视频理解"><a href="#视频理解" class="headerlink" title="视频理解"></a>视频理解</h3><h4 id="数据集和基准"><a href="#数据集和基准" class="headerlink" title="数据集和基准"></a>数据集和基准</h4><p>为了全面探索高质量视频字幕数据给LVLMs带来的益处，论文在三个多模态视频基准上对模型进行了全面评估。VideoBench从13个现有数据源（如MSVD-QA，MSRVTT-QA，Activitynet-QA等）中策划了约<strong>15,000个跨10个评估维度的QA对。</strong>MVBench 旨在挑战LVLMs处理视频任务，这些任务不能通过单帧依赖有效解决，其包含了<strong>从11个公共视频测试中派生出的4,000个QA对基准</strong>。TempCompass 特别评估了LVLMs在各种时间方面的微妙性能，如速度、方向和属性变化。它包含<strong>410个视频和7,540个精心收集的指令</strong>，强调时间理解和交互。</p><h4 id="ShareGPT4Video-1"><a href="#ShareGPT4Video-1" class="headerlink" title="ShareGPT4Video"></a>ShareGPT4Video</h4><p><strong>通过ShareGPT4Video提升当前LVLM的性能</strong>。论文验证了ShareGPT4Video收集的高质量视频字幕数据对于提升当前LVLM性能的有效性。为了公平和简化，论文将ShareGPT4Video中与复杂场景相关的28K高质量视频字幕数据（包括Panda-70M 、Ego4D和BDD100K ）整合，<strong>以同等数量替换VideoChatGPT-100K 对话数据中的字幕数据</strong>。然后，论文使用默认的训练设置和超参数训练VideoLLaVA 和LLaMA-VID。如<strong>表1</strong>所示，ShareGPT4Video在不同的LVLM架构和规模上<strong>持续提高了视频与语言模态之间的对齐</strong>。具体而言，集成高质量字幕后，VideoLLaVA-7B在三个全面的多模态视频基准测试上<strong>平均性能提升了1.1</strong>，而LLaMA-VID-7B和LLaMA-VID-13B分别实现了平均2.0和2.3的提升。论文证明高质量的视频字幕数据特别<strong>有助于LVLM在需要复杂时间理解的基准测试上实现显著的性能提升</strong>，例如TempCompass 。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204215938456.png" alt="image-20241204215938456" style="zoom:67%;"><h4 id="ShareGPT4Video-8B"><a href="#ShareGPT4Video-8B" class="headerlink" title="ShareGPT4Video-8B"></a>ShareGPT4Video-8B</h4><p>为了获得最终的ShareGPT4Video-8B模型，论文从LLaVA-Next-8B图像多模态模型开始。与之前的LVLM方法一致，论文遵循lG-VLM策略，<strong>从每个视频中均匀采样16帧，并将这些帧排列成4x4的图像网格，以形成训练和推理的输入</strong>。对于训练数据，论文首先从各种<strong>视频到文本数据集</strong>中收集153K的VQA数据来构建论文的基准。这一收集包括来自VideoChatGPT的13K对话数据和140K问答对，其中45K数据点来自CLEVRER ，8K来自EGO-QA ，34K来自NextQA ，53K来自TGIF-Transition 。然后，这些VQA数据与28K视频字幕数据结合，形成一个包含181K样本的综合训练数据集。</p><blockquote><p>在训练期间，本文使用了128的批处理大小和AdamW优化器。本文选择对整个模型进行微调，将视觉编码器的学习速率设置为2e-6，将MLP投影层的学习率设置为2e-5，对于使用LoRA的LLM，将学习速率设置为2e-4。这样的训练策略使作者能够在大约5小时8A100gpu内获得一个特殊的LVLM，ShareGPT4Video-8B。</p></blockquote><p>表3、4、5展示了ShareGPT4Video-8B模型（由论文的ShareGPT4Video数据集增强）与现有最先进的LVLMs之间的定量比较。值得注意的是，与之前的LVLMs相比，论文的ShareGPT4Video-8B在所有三个综合基准测试中均取得了最优性能。具体而言，得益于ShareGPT4Video提供的<strong>丰富时间信息</strong>，本文模型在TempCompass基准上实现了平均准确率61.59%。这比之前表现最佳的LVLM，VideoLLaVA-7B提高了11.6%。此外，尽管VideoBench和MVBench基准从各种现有视频数据集中收集了多样化的QA数据，论文在这两个基准上均取得了稳健的性能，平均准确率分别超过之前的最先进水平2.7%和8.2%。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204215525840.png" alt="image-20241204215525840" style="zoom: 50%;"><h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p><strong>关于字幕质量和ViT的消融研究</strong>。基于ShareGPT4Video-8B，论文研究了字幕质量和可学习的视觉编码器如何影响模态对齐。如表2所示，在VQA数据之上<strong>引入简短的字幕可能不会带来显著的性能提升</strong>。由于模态对齐不佳，<strong>它甚至可能在某些基准上降低性能</strong>。比较表2中的第一、第二和第四行，得益于论文高质量字幕数据，理解时间序列的性能提升是显而易见的。此外，在训练时<strong>使用详细字幕解锁视觉编码器有助于更好地实现LVLMs的模态对齐。</strong></p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204220004727.png" alt="image-20241204220004727" style="zoom:67%;"><h3 id="视频字幕生成"><a href="#视频字幕生成" class="headerlink" title="视频字幕生成"></a>视频字幕生成</h3><p>为了验证ShareCapitoner-Video的能力，论文通过人类偏好投票定量比较了ShareCapitoner-Video与GPT4V之间的视频字幕质量。如表7显示，其性能与GPT4V相当。打分标准：邀请10名志愿者从三个方面对字幕进行评估。这些方面包括：(1)<strong>遗漏和虚构</strong> - 检查字幕中有没有缺少的关键元素，或识别到视频中不存在的图像元素；(2)<strong>失真</strong> - 评估元素属性，如颜色和大小的准确性；(3)<strong>时间不匹配</strong> - 评估描述是否准确地反映了视频中时间事件的演变。每对最多可以获得3分，每个标准1分。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204220203143.png" alt="image-20241204220203143" style="zoom:67%;"><p>表6比较了ShareCapitoner-Video与GPT4V生成的字幕的词汇成分，结果表明二者有相当的信息级别。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204221121407.png" alt="image-20241204221121407" style="zoom: 67%;"><p>图9给出了不同来源的视频字幕质量的定性比较。</p><ul><li><strong>Panda-Student</strong>：为视频生成一句话的描述。虽然这种方法最大限度地减少了错误，但它没有为信息密集的视频提供足够的文本信息，阻碍了视频和语言模式的对齐。</li><li><strong>Video ChatCaptioner</strong>：使用ChatGPT构建问题，使用BLIP2做VQA，然后再次使用ChatGPT基于QA总结一个完整的字幕。虽然这种方法产生的字幕比Panda-Student更长，但ChatGPT的广泛参与往往会导致<strong>过度想象和幻觉</strong>，对视频和语言模式之间的一致性产生负面影响。</li><li><strong>GPT-4V</strong>：展现了杰出的字幕生成能力。</li><li><strong>ShareCapitoner-Video</strong>：在ShareGPT4Video数据集上进行微调后，同样展现了优秀的字幕生成能力。</li></ul><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204220319092.png" alt="image-20241204220319092" style="zoom: 50%;"><h3 id="视频生成"><a href="#视频生成" class="headerlink" title="视频生成"></a>视频生成</h3><h4 id="模型设置"><a href="#模型设置" class="headerlink" title="模型设置"></a>模型设置</h4><p>为了验证高质量字幕在T2VMs领域的有效性，论文使用ShareCaptioner-Video和Panda-Student 分别为450万个65帧视频和30万个221帧视频生成高质量且简短的视频字幕。遵循Open-Sora-Plan中概述的流程，论文对预训练的T2VM进行了微调，以生成高保真度10秒视频。作为比较，论文对具有相同数量视频-简短字幕对的基线模型进行了微调。</p><p>实现细节：利用Latte-XL模型和一个来自T5-XXL的文本编码器。第一阶段，在较少的帧数上进行预训练，并实现联合图像-视频训练，图像批处理大小是视频的4倍。这个阶段包括5万训练steps。在第二阶段，视频和图像的批量大小都减少到2。对于所有的训练阶段，使用了固定的学习速率为2e-5的AdamW优化器，图像和视频的分辨率均设置为512×512。为了训练精度，使用Bf16，因为fp16导致损失成为NaN。第一阶段需要大约6K H100 GPU小时，而第二阶段需要大约36K Ascend GPU小时。</p><h4 id="定性分析"><a href="#定性分析" class="headerlink" title="定性分析"></a>定性分析</h4><p>如图5所示，T2VM在ShareCaptioner-Video生成的高质量详细字幕辅助下，<strong>能够准确遵循详细prompt，并在语义内容和相机运动控制方面表现出卓越的控制能力。</strong>生成的视频展示了复杂而生动的画面。相比之下，当提供简短字幕时，T2VM难以遵循复杂的生成prompt，导致结果不佳。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204225717589.png" alt="image-20241204225717589" style="zoom:67%;"><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241204225840397.png" alt="image-20241204225840397" style="zoom:67%;"><h2 id="局限和影响"><a href="#局限和影响" class="headerlink" title="局限和影响"></a>局限和影响</h2><p>局限：虽然本文目前生成高质量视频字幕的pipeline充分利用了视觉和文本信息，但由于GPT4V无法同时合并音频信息，它受到了限制。音频信息在涉及日常人类活动的对话场景中是有益的，一旦GPT4o支持音频输入，作者计划在未来的工作中引入音频信息，以进一步提高字幕的质量。</p><p>社会影响：1)由于大型语言模型涉及到大规模字幕的生成过程，作者没有手动验证每个字幕的社会偏见内容；2)虽然作者利用了来自现有公共数据集的视频数据，但作者不能确保所选的视频不包含人脸。因此，虽然对本文生成的字幕的使用没有限制，但用户在使用视频时必须遵守原始视频源的许可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本研究中，作者的目的是解决大型视频语言模型（LVLMs）和文本到视频模型（T2VMs）<strong>缺乏高质量的视频字幕数据</strong>的挑战。作者开发了ShareGPT4Video，一个高质量的<strong>视频字幕数据集</strong>，和ShareCaptioner-Video，一个在<strong>视频语言多模态</strong>领域的先进和多功能的<strong>模型</strong>。通过采用一系列的策略和设计，本文从高级的图像多模态模型、GPT4V和4.8M字幕数据（由ShareGPT4Video生成）得到了40K详细字幕。这些字幕包括丰富的世界知识、对象属性、相机运动和对事件的详细时间描述。本文广泛的实验验证了提出的数据集和标注器在增强视频理解和生成任务方面的有效性。</p><h2 id="架构相关"><a href="#架构相关" class="headerlink" title="架构相关"></a>架构相关</h2><h3 id="关键帧采样"><a href="#关键帧采样" class="headerlink" title="关键帧采样"></a>关键帧采样</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> functional <span class="token keyword">as</span> F<span class="token keyword">import</span> cv2<span class="token keyword">import</span> math<span class="token keyword">from</span> transformers <span class="token keyword">import</span> CLIPFeatureExtractor<span class="token punctuation">,</span>CLIPVisionModel<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npmodel_path <span class="token operator">=</span> <span class="token string">'openai/clip-vit-large-patch14-336'</span>feature_extractor <span class="token operator">=</span> CLIPFeatureExtractor<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model_path<span class="token punctuation">)</span>vision_tower <span class="token operator">=</span> CLIPVisionModel<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model_path<span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>vision_tower<span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">calculate_clip_feature_sim_2</span><span class="token punctuation">(</span>image_1<span class="token punctuation">,</span> image_2<span class="token punctuation">)</span><span class="token punctuation">:</span>    input_1 <span class="token operator">=</span> feature_extractor<span class="token punctuation">(</span>images<span class="token operator">=</span>image_1<span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    input_2 <span class="token operator">=</span> feature_extractor<span class="token punctuation">(</span>images<span class="token operator">=</span>image_2<span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    image_feature_1 <span class="token operator">=</span> vision_tower<span class="token punctuation">(</span><span class="token operator">**</span>input_1<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span>vision_tower<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> output_hidden_states<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hidden_states<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    image_feature_2 <span class="token operator">=</span> vision_tower<span class="token punctuation">(</span><span class="token operator">**</span>input_2<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span>vision_tower<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> output_hidden_states<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hidden_states<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    similarity <span class="token operator">=</span> F<span class="token punctuation">.</span>cosine_similarity<span class="token punctuation">(</span>image_feature_1<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">'cpu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> image_feature_2<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">'cpu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Sim: </span><span class="token interpolation"><span class="token punctuation">{</span>similarity<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> similarity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CLIPVisionModel</code> 是 <strong>OpenAI CLIP 模型的视觉部分，用于从图像中提取特征。</strong>它是基于 <strong>Vision Transformer (ViT)</strong> 或其他卷积神经网络架构（例如 ResNet）构建的模型。CLIP 的主要目标是通过视觉和语言的对比学习来使模型同时理解这两种模态。</p><p>在 CLIP 的视觉模型中，图像通过一个深度神经网络进行处理，该网络的目的是将图像嵌入到一个高维空间中，在这个空间里，视觉特征可以与文本特征对齐，从而使得图像和文本可以相互比较。</p><p><code>CLIPVisionModel</code> 内部结构主要由以下几个组件组成：</p><ol><li><strong>输入层</strong>：<ul><li>图像首先会被输入到一个预处理的特征提取器（如 <code>CLIPFeatureExtractor</code>），它会对图像进行缩放、裁剪和标准化等操作，确保图像符合模型的输入要求。</li></ul></li><li><strong>视觉模型（通常是 Vision Transformer）</strong>：<ul><li>CLIP 使用的是 <strong>Vision Transformer (ViT)</strong> 架构。ViT 是一种基于 Transformer 的视觉模型，使用自注意力机制来捕捉图像中的局部和全局信息。</li><li>具体来说，图像首先被分割成固定大小的补丁（patches），每个补丁被视为一个 token，类似于文本中的单词。然后这些补丁经过嵌入、线性变换，形成与文本输入类似的高维特征表示。</li><li>CLIP 中的 Vision Transformer 通常采用 <strong>ViT-B/16</strong>（Base model，16x16 图像补丁）或其他类似的架构。</li></ul></li><li><strong>图像嵌入（Image Embeddings）</strong>：<ul><li>通过 Vision Transformer 处理后，最后的隐藏状态（通常是 <code>[CLS]</code> token 对应的输出）被用作图像的特征向量（embedding）。</li><li>这个特征向量是一个高维的表示，它捕捉了图像的语义信息，并与文本嵌入对齐，可以用来进行图像与文本的匹配和相似度计算。</li></ul></li><li><strong>Transformer 层和多头自注意力机制</strong>：<ul><li>Vision Transformer 通过多层的自注意力机制对图像中的补丁进行建模，能够捕捉图像中复杂的关系和语义信息。每一层的输出会提供一个更加丰富的图像表示。</li></ul></li></ol><h3 id="IG-VLM策略"><a href="#IG-VLM策略" class="headerlink" title="IG-VLM策略"></a>IG-VLM策略</h3><p><strong>An Image Grid Can Be Worth a Video: Zero-shot Video Question Answering Using a VLM</strong></p><blockquote><p>标题:一个图像网格可以抵得上一段视频使用 VLM 进行零镜头视频答题<br>author:Wonkyun Kim, Changin Choi, Wonseok Lee, Wonjong Rhee<br>paper:<a href="https://arxiv.org/html/2403.18406v1">An Image Grid Can Be Worth a Video: Zero-shot Video Question Answering Using a VLM</a><br>publish:Our code is available at <a href="https://link.zhihu.com/?target=https://github.com/imagegridworth/IG-VLM">https://github.com/imagegridworth/IG-VLM</a><br>date Time:2024-03-27</p></blockquote><p>在最近的大型语言模型（LLM）的复杂推理能力的刺激下，人们设计出了多种连接视频模式的策略。视频语言模型（VideoLMs）是其中一个突出的策略，它利用视频数据训练可学习的界面，将高级视觉编码器与 LLMs 连接起来。最近，出现了另一种策略，即利用视频语言模型（VideoLMs）和 LLMs 等现成的基础模型，在多个阶段实现模态桥接。在本研究中，我们介绍了一种简单而新颖的策略，即<strong>只使用一个视觉语言模型（VLM）</strong>。我们的出发点是一个朴素的观点，即<strong>视频由一系列图像或帧组成，并与时间信息交织在一起</strong>。视频理解的精髓在于<strong>对每一帧图像的时间信息和空间信息进行有效管理</strong>。起初，我们<strong>通过将多个帧按网格布局排列，将视频转换成单一的合成图像。由此产生的单一图像被称为图像网格。这种格式在保持单幅图像外观的同时，有效保留了网格结构中的时间信息。因此，图像网格方法可以直接应用单一的高性能 VLM，而无需任何视频数据训练。</strong>我们对 10 个零样本视频问题解答基准（包括 5 个开放式基准和 5 个多项选择基准）进行了广泛的实验分析，结果表明所提出的图像网格视觉语言模型（IG-VLM）在 10 个基准中的 9 个基准中超越了现有方法。</p><img src="/2024/12/03/sharegpt4video-improving-video-understanding-and-generation-with-better-captions/image-20241209191753822.png" alt="image-20241209191753822" style="zoom:67%;"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[<a href="https://arxiv.org/abs/2406.04325">2406.04325] ShareGPT4Video: Improving Video Understanding and Generation with Better Captions</a></p><p>[ShareGPT4Omni/ShareGPT4Video: <a href="https://github.com/ShareGPT4Omni/ShareGPT4Video">NeurIPS 2024] An official implementation of ShareGPT4Video: Improving Video Understanding and Generation with Better Captions</a></p><p><a href="https://zhuanlan.zhihu.com/p/702413750">【LLM】ShareGPT4Video：借助更优质的标题提升视频理解和生成能力 - 知乎</a></p><p><a href="https://www.jiqizhixin.com/articles/2024-06-20-4">ShareGPT4V作者团队又一力作！百万高质量视频-字幕数据助力社区提升多模态大模型视频理解及生成能力 | 机器之心</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ShareGPT4Video&quot;&gt;&lt;a href=&quot;#ShareGPT4Video&quot; class=&quot;headerlink&quot; title=&quot;ShareGPT4Video&quot;&gt;&lt;/a&gt;ShareGPT4Video&lt;/h1&gt;&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot;</summary>
      
    
    
    
    <category term="论文" scheme="http://wolf-ll.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="MLLM" scheme="http://wolf-ll.github.io/tags/MLLM/"/>
    
    <category term="视频理解" scheme="http://wolf-ll.github.io/tags/%E8%A7%86%E9%A2%91%E7%90%86%E8%A7%A3/"/>
    
    <category term="字幕生成" scheme="http://wolf-ll.github.io/tags/%E5%AD%97%E5%B9%95%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>多模态架构相关</title>
    <link href="http://wolf-ll.github.io/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/"/>
    <id>http://wolf-ll.github.io/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/</id>
    <published>2024-12-02T08:44:24.000Z</published>
    <updated>2025-01-08T07:18:25.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多模态架构相关"><a href="#多模态架构相关" class="headerlink" title="多模态架构相关"></a>多模态架构相关</h1><p>MLLM通常包含以下几个组件：</p><ul><li>一个预训练的<strong>模态编码器</strong>：用于接收视觉/听觉输入等不同模态的输入并编码为模态特征。</li><li>一个输入投影器（<strong>模态接口</strong>）：用于将多模态的特征对齐到文本特征空间，并且和文本特征一起输入到llm。</li><li>一个预训练的<strong>大模型</strong>backbone：利用LLM对对齐后的特征做语义理解、推理和决策，并输出统一的信号。</li><li>可选的<strong>输出投影器</strong>：将语言模型输出的信号进一步转换为其他模态的特征，或者是投影到任务需要的输出范式中。</li><li>可选的<strong>模态生成器</strong>：负责生成其他模态的输出。</li></ul><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203105912970.png?lastModify=1733205528" alt="image-20241203105912970" style="zoom: 80%;"><h2 id="视觉编码器"><a href="#视觉编码器" class="headerlink" title="视觉编码器"></a>视觉编码器</h2><h3 id="CLIP-VIT"><a href="#CLIP-VIT" class="headerlink" title="CLIP VIT"></a>CLIP VIT</h3><p>CLIP的的核心思想是通过<strong>海量</strong>的<strong>弱监督文本对</strong>对比学习，将图片和文本通过各自的<strong>预训练</strong>模型获得的编码向量在向量空间上<strong>对齐</strong>。不足：clip可以实现图文匹配，但不具有文本生成能力。</p><blockquote><p>这里对提取的文本特征和图像特征进行对比学习。对于一个包含N个文本-图像对的训练batch，将N个文本特征和N个图像特征两两组合，CLIP模型会预测出N^2个可能的文本-图像对的相似度，这里的相似度直接<strong>计算文本特征和图像特征的余弦相似性（cosine similarity）</strong>，即上图所示的矩阵。这里共有N个正样本，即真正属于一对的文本和图像（矩阵中的对角线元素），而剩余的N^2−N个文本-图像对为负样本，那么CLIP的训练目标就是最大化N个正样本的相似度，同时最小化N^2−N个负样本的相似度</p></blockquote><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241021110850956.png" alt="image-20241021110850956" style="zoom: 67%;"><p>CLIP VIT是在大名鼎鼎的CLIP这项工作中，作者团队使用约<strong>4亿个图像-文本对数据</strong>训练得到的VIT权重，可以说是当前最强的VIT模型之一，<strong>Clip VIT已经成为目前多数多模态模型的首选。</strong></p><h3 id="EVA-CLIP"><a href="#EVA-CLIP" class="headerlink" title="EVA-CLIP"></a>EVA-CLIP</h3><blockquote><p>蒸馏版CLIP，训练消耗更小，速度更快，效果更好。</p></blockquote><p>EVA-CLIP，这是一种基于对比语言图像预训练(CLIP)技术改进的模型，通过引入新的<strong>表示学习、优化和增强技术</strong>，显著<strong>提高了CLIP的训练效率和效果</strong>。EVA-CLIP系列模型在<strong>保持较低训练成本</strong>的同时，实现了与先前具有相似参数数量的CLIP模型相比更高的性能。特别地，文中提到的EVA-02-CLIP-E/14+模型，使用90亿数据样本和5.0B(50亿)参数，在ImageNet-1K的val数据集上取得了82.0%的零样本准确率，而较小的EVA-02-CLIP-L14+模型，尽管仅使用了4.3亿参数和60亿数据样本，也达到了80.4%的准确率。这些结果表明，EVA-CLIP在图像分类任务中，特别是在零样本学习场景下，展现出了卓越的性能。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241202183416207.png" alt="image-20241202183416207" style="zoom: 67%;"><h3 id="SigLip"><a href="#SigLip" class="headerlink" title="SigLip"></a>SigLip</h3><p>CLIP 面临<strong>两个技术挑战：</strong>（1）它需要较大的批大小。例如，CLIP使用了 <strong>32K 的批量大小</strong>，这需要大量 GPU;（2）它需要这些 GPU 之间进行大量通信。</p><p>SigLip方法<strong>减少 了CLIP 的批量大小要求</strong>， 是<strong>Sig</strong>moid <strong>Language</strong> Image <strong>Pre</strong> -training 的缩写。SigLIP 的核心思想是使用 Sigmoid运算而不是Softmax<strong>运算</strong>。CLIP 使用 Softmax 函数，因此，给定正对（图像-文本）的损失取决于批量内的每个负对。相比之下，SigLIP 既不对称，也不需要全局归一化因子。因此，每对（正数和负数）的损失都与小批量内的其他对无关。</p><img src="https://i-blog.csdnimg.cn/blog_migrate/b2c95131902ea195a844a5ae763f9153.png" alt="img" style="zoom: 50%;"><h3 id="NFNet"><a href="#NFNet" class="headerlink" title="NFNet"></a>NFNet</h3><p><a href="https://arxiv.org/pdf/2102.06171"><strong>High-Performance Large-Scale Image Recognition Without Normalization (ICML 2021)</strong></a></p><p>NFNet（Normalizer-Free ResNets）是DeepMind提出的一种<strong>不需要Batch Normalization的基于ResNet的网络结构</strong>，其核心为一种AGC（adaptive gradient clipping technique，自适应梯度裁剪）技术。最小的NFNet版本达到了EfficientNet-B7的准确率，并且训练速度快了8.7倍，最大版本的模型实现了新的SOTA效果。</p><p><strong>NFNet 视觉大模型：匹敌 ViT 性能的大规模预训练</strong>：</p><blockquote><p>结论：<strong>当能够访问足够大的数据集时，CNN实际上可以与 ViT 竞争。</strong>决定一个视觉骨干模型性能的最重要因素是用于训练的<strong>计算预算</strong> 和<strong>训练的数据量</strong> 。尽管 ViT 在视觉任务上的成功让人印象深刻，但是在本文看来，没有强有力的证据表明预训练的视觉 Transformer 模型的性能在计算预算相当的条件下优于预训练的 ConvNet 模型。</p><p>但不可否认的是，Transformer 模型在特定的上下文中具有实际优势，比如能够在多种模态中使用相似的组件的能力。</p></blockquote><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241202224849112.png" alt="image-20241202224849112" style="zoom:80%;"><h2 id="视觉token压缩"><a href="#视觉token压缩" class="headerlink" title="视觉token压缩"></a>视觉token压缩</h2><p>为提升MLLM对图像、视频的理解能力，最有效的方式就是提升visual token的个数，随之而来的则是训练、推理耗时的增加。因此，<strong>对视觉token进行压缩以提取最有用的信息</strong>至关重要。</p><p>目前的视觉映射器分以下几种：</p><ol><li><p><strong>Resampler or Q-former</strong>：该方法通过引入可学习的 query 来自适应地来学习相关视觉表示，通过控制可学习 query 的个数来控制视觉 token 产生的数目。</p></li><li><p><strong>基于卷积的视觉映射器</strong>：典型的工作有 C-abstractor、LDPv1/v2， 通过引入卷积操作来<strong>建模局部视觉信息</strong>之间的关系，同时采用<strong>下采样</strong>减少视觉表示的长度。</p></li><li><p><strong>维度变换</strong>：将产生的视觉表示在 sequence 的维度<strong>变换到 channel 维度</strong>，如 PixelShuffle，虽然视觉信息没有减少但结构信息可能会被破坏。在 InternLM-XComposer2-4KHD 与 InternVL 1.5 的研究工作均采用了类似的操作。此外，在研究工作 MM1 中，也对常用的几种 Visual Projector 进行实验验证与性能分析。</p></li></ol><h3 id="Q-Former"><a href="#Q-Former" class="headerlink" title="Q-Former"></a>Q-Former</h3><p>Q-Former由两个transfomer子模块组成，左边为(learnable) query encoder，右边为text encoder &amp; decoder。记视觉模型的image encoder的输出为I。左边网络的(learnable) query为Q，右边网络的输入text为T。注意Q是一个向量集，非单个向量。它可以视为Q-Former的参数。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241022195840325.png" alt="image-20241022195840325" style="zoom:80%;"><h3 id="Perceiver-Resampler"><a href="#Perceiver-Resampler" class="headerlink" title="Perceiver Resampler"></a>Perceiver Resampler</h3><p>感知重采样技术（Perceiver Resampler）首次被引入 MLLM 是2022 年 4 月DeepMind 在论文 Flamingo 中提出的，Flamingo采用了感知重采样（<em>Perceiver Resampler</em>）技术和门控交叉注意力技术（Gated Cross-<em>Attention</em>）进行视觉多模态信息和LLM的融合，代表模型：Flamingo、Qwen-VL、MiniCPM-V、LLaVA-UHD</p><ul><li><strong>数据压缩与选择：</strong>图像通常具有很高的维度（例如，像素级别的数据），直接将这些高维数据输入到Transformer中会导致计算负担过重。Perceiver Resampler的主要目标是将这些高维视觉数据压缩到固定数量的紧凑表示，以适应后续的Transformer处理。</li><li><strong>模态对齐：</strong>在多模态任务中（如视觉语言任务），图像和文本往往具有不同的模态特性。Perceiver Resampler通过学习跨模态的映射，将图像数据转换为与文本表示形式相匹配的低维向量。这种转换可以使Transformer更容易处理和对齐不同模态的信息。</li><li><strong>自适应表征学习：</strong>Perceiver Resampler不是简单地对图像进行下采样，而是通过可学习的参数自适应地从输入中提取重要信息。这使得模型能够动态地选择与任务相关的视觉特征。</li></ul><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203024555554.png?lastModify=1733207896" alt="image-20241203024555554" style="zoom: 50%;"><h3 id="Linear-Projector"><a href="#Linear-Projector" class="headerlink" title="Linear Projector"></a><strong>Linear Projector</strong></h3><p><strong>Linear Projector（线性投影器</strong>）首次被引入 MLLM 是2023年4月 LLaVA1.0 的发布，论文中提出了一种更简单的投影方法，通过线性变换将Modality Encoder编码的特征映射到LLM的表示空间中。代表模型主要有：LLaVA、MiniGPT-4、NEXT-GPT。</p><img src="https://pic3.zhimg.com/v2-f1931fee783c332648242287ccdb39b4_1440w.jpg" alt="img" style="zoom:50%;"><p>Linear Projector结构比较简单，比Q-Former简单的多，非常易于实现和训练，但是效果上却一点也不弱于Q-Former。</p><h3 id="Multi-Layer-Perception"><a href="#Multi-Layer-Perception" class="headerlink" title="Multi-Layer Perception"></a>Multi-Layer Perception</h3><p><strong>多层感知机（Multi-Layer Perception， MLP）</strong>首次被引入 MLLM 是在2023 年 10 月 LLaVA1.5 中提出的，LLaVA1.5 在对比LLaVA1.0结构上，将视觉特征从线性映射（单个神经元），改进为多层感知机（MLP)。代表模型包括：LLaVA1.5/NeXT、CogVLM、DeepSeek-VL、Yi-VL。</p><img src="https://pic4.zhimg.com/v2-249d50464838d5f6a8340e9a2e567401_1440w.jpg" alt="img" style="zoom:50%;"><p>多层感知器由多层线性变换和非线性激活函数组成，能够捕捉输入数据的复杂非线性关系。</p><p>最近MLP结构成为了MLLM中模态对齐的主流结构，LLAVA 系列的技术路线被大家更认可，主要原因是：MLP用最简洁的结构在效果上碾压其他一众复杂结构，并且具有更快的收敛速度，对数据量的依赖也少。</p><h2 id="音频编码器"><a href="#音频编码器" class="headerlink" title="音频编码器"></a>音频编码器</h2><h3 id="Whisper"><a href="#Whisper" class="headerlink" title="Whisper"></a>Whisper</h3><p>Whisper是 OpenAI于 2022 年09月开放的一个超大规模的语音识别预训练模型，它使用端到端的方式进行多语言的预训练，在开放域的英语ASR （语音识别）能力上已经实现了与人类相对的水平。</p><p>Whisper 使用标准的 <strong>Transfomer 编码器-解码器架构</strong>对模型进行训练。每条语音数据输入长度为 30 秒，通过 25ms 的汉明窗和 10ms 的步移，在 16000 的采样帧率下，转化为 3000 帧长，80维度的对数梅尔频谱图。并使用两层1维的卷积神经网络和 GELU 激活函数对原始对数梅尔频谱图进行初始的特征提取。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203152120772.png" alt="image-20241203152120772" style="zoom:67%;"><h3 id="CLAP"><a href="#CLAP" class="headerlink" title="CLAP"></a>CLAP</h3><p>CLAP（Contrastive Language-Audio Pretraining）是在2023年提出的一种<strong>基于对比学习的预训练方法</strong>，旨在通过结合<strong>音频数据</strong>和相应的<strong>自然语言描述</strong>来学习音频的表示。这种方法的核心思想是利用对比学习范式，将音频和文本映射到一个共享的潜在空间中，并通过训练使得相关的音频-文本对在该空间中更接近，而不相关的对更远离。简单来说，CLAP是参考了CLIP的思路，将图像-文本对迁移至音频-文本对，并完成音频数据预训练的工作。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203153009849.png" alt="image-20241203153009849" style="zoom: 50%;"><h3 id="HuBERT"><a href="#HuBERT" class="headerlink" title="HuBERT"></a>HuBERT</h3><p>HuBERT 是 Meta 在 2021 年发表的模型，模型结构类似 Wav2vec 2.0，不同的是训练方法。Wav2vec 2.0 是在训练时将语音特征离散化作为自监督目标，而 HuBERT 则通过在 MFCC 特征或 HuBERT 特征上做 K-means 聚类，得到训练目标。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203154103891.png" alt="image-20241203154103891" style="zoom:67%;"><h2 id="早期图文匹配记录"><a href="#早期图文匹配记录" class="headerlink" title="早期图文匹配记录"></a>早期图文匹配记录</h2><ul><li><p>为了与配对文本的embedding序列对齐，图像V也将被表示为embedding向量的序列。将输入表示统一为两种模态的embedding序列。</p></li><li><p>早期做法：图片提取出来的区域特征，最好和文本的token特征在同一个level上。</p></li><li><p>为了生成图像的描述，模型被期望于推断图像中各种对象之间的复杂关系。</p><ul><li><p>因此，许多工作设计了不同的视觉编码器来对这些关系和对象的属性进行建模。</p></li><li><p>ViLBERT[Lu et al.，2019]和LXMERT[Tan和Bansal，2019]等早期工作首先利用Faster RCNN[Ren et al.，2015]从图像中检测对象区域序列，然后将其编码为感兴趣区域（ROI）特征序列。使用ROI feature作为内容信息，将bounding box作为位置信息</p></li><li><p>此外，一些VL-PTM去掉了边界框（bounding box），并将图像编码为像素级网格特征（pixel-level grid features）。例如，pixel-BERT[huang等人，2020]和SOHO[huang等人，2021]放弃了更快的R-CNN，转而支持ResNet，这样视觉编码器就可以将图像作为一个整体来查看，避免了忽略一些关键区域的风险。</p></li><li><p>除了这些方法之外，许多工作都试图遵循ViT的成功[多索维茨基等人，2020年]利用transformer来提取视觉特征。在这个场景中，vl-ptm中的transformer的任务是建模图像中的对象关系。首先将一个图像分割成几个flattened 2D patches。然后将图像patch的embedding按顺序排列，以表示原始图像。</p><ul><li>ALBEF [Li等人，2021a]和SimVLM [Wang等人，2021b]将patch提供给ViT编码器，以提取视觉特征，从而导致了full-transformer VL-PTM的产生。</li></ul></li></ul></li></ul><h3 id="文本embedding-图片ROI-embedding"><a href="#文本embedding-图片ROI-embedding" class="headerlink" title="文本embedding + 图片ROI embedding"></a>文本embedding + 图片ROI embedding</h3><ul><li><p>文本序列首先分为tokens，并与“[CLS]”和“[SEP]”token串联，表示为W = &lt;[CLS]，w1，…，wn，[SEP]&gt;。每个令牌wj都将映射到一个词嵌入。</p></li><li><p>此外，在嵌入一词中添加表示位置的 pos embbding 和 嵌入模态类型的seg embbding，以获得wj的最终嵌入。</p></li></ul><p><strong>视觉部分：如何设计一个比较好的视觉embedding，去适应一个语言方面的预训练模型？</strong></p><h4 id="OSCAR"><a href="#OSCAR" class="headerlink" title="OSCAR"></a>OSCAR</h4><p>OSCAR将object tag作为信息进行输入，object是将信息转化为一个文本标签，构建了视觉信息和文本信息之间的桥梁，达到了视觉和文本的一致性。</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203142613732.png" alt="image-20241203142613732" style="zoom:67%;"><p>问题：</p><p>1.需要额外训练一个roi提取模型，模型准确性影响预训练模型准确性</p><p>2.不同图片roi个数是不确定的，预训练模型需要相对固定roi个数导致信息丢失</p><p>3.roi数据集准备复杂，<strong>目标检测模型得到的都是矩形的目标，其不适合于不规则的物体，导致得到的bounding box中存在噪声。另外，除了bounding box以外，一些背景信息是无法提取出来的，相当于即存在噪声，也存在损失</strong>。对效果产生一些影响。</p><p>4.下游任务不一定适配用roi粒度特征，比如在一个domain预训练的目标检测模型，将其转换到另外的domain中，效果可能有相当大的gap，影响模型的效果。</p><h3 id="文本embedding-图片Grid-embedding"><a href="#文本embedding-图片Grid-embedding" class="headerlink" title="文本embedding + 图片Grid embedding"></a>文本embedding + 图片Grid embedding</h3><p>为了解决region特征表示问题，提出Grid embedding方式表示图像数据。放弃ROI，<strong>转而使用cnn或者resnet抽取Grid Embedding，以便图像编码器可以将图像作为一个整体查看</strong>，避免忽视一些关键区域的风险。</p><h4 id="Pixel-BERT"><a href="#Pixel-BERT" class="headerlink" title="Pixel-BERT"></a>Pixel-BERT</h4><p>Pixel-Bert用cnn抽取图像Grid embbeding</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203142642035.png" alt="image-20241203142642035" style="zoom:67%;"><h4 id="SOHO"><a href="#SOHO" class="headerlink" title="SOHO"></a>SOHO</h4><p>SOHO用resnet抽取Grid embedding</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203142829471.png" alt="image-20241203142829471" style="zoom: 50%;"><h3 id="文本embedding-图片Patch-embedding"><a href="#文本embedding-图片Patch-embedding" class="headerlink" title="文本embedding + 图片Patch embedding"></a>文本embedding + 图片Patch embedding</h3><p>随着VIT的兴起，出现了patch based的特征提取，将一张图片分为若干patch，并且使用线性变化的方式对其进行编码。</p><p>图像首先被拆分为拍平为2D patch，然后序列化embdding图像的patch，来表示原始图像特征。模型是端到端表示且用的transformer架构可以并行化计算，所以VIT做patch推理速度会快很多</p><img src="/2024/12/02/duo-mo-tai-jia-gou-xiang-guan/image-20241203143210158.png" alt="image-20241203143210158" style="zoom:67%;"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://waytoagi.feishu.cn/wiki/DPjOwD19iiAcMYkryZicYJMWnTf">‍⁠⁠﻿‍‬‌⁠‌⁠⁠‬⁠﻿⁠‬‍⁠﻿‍‌⁠‍‍﻿﻿‌⁠多模态大模型入门指南-长文慎入【持续更新】 - 飞书云文档</a></p><p><a href="https://blog.csdn.net/AIGCmagic/article/details/138287524">AI多模态模型架构之模态编码器：图像编码、音频编码、视频编码_多模态编码器-CSDN博客</a></p><p><a href="https://blog.csdn.net/AIBigModel/article/details/144150131">多模态视觉token压缩方法详解-CSDN博客</a></p><p><a href="https://arxiv.org/abs/2303.15389">EVA-CLIP: Improved Training Techniques for CLIP at Scale</a></p><p><a href="https://l12k1v7ghxm.feishu.cn/wiki/KeVmwU8W2iyWfZkb6iBcbcr6nEg">‍‬‬‌‌‍﻿‬‌⁠⁠‍‍⁠‌‌‌‌‌‌‌﻿‍‌‌‍‍‬‬‌‌3. 多模态架构 - 飞书云文档</a></p><p><a href="https://arxiv.org/pdf/2212.04356">arxiv.org/pdf/2212.04356</a></p><p><a href="https://arxiv.org/pdf/2004.06165">2004.06165</a></p><p>[<a href="https://arxiv.org/abs/2206.04769">2206.04769] CLAP: Learning Audio Concepts From Natural Language Supervision</a></p><p>[<a href="https://arxiv.org/abs/2106.07447">2106.07447] HuBERT: Self-Supervised Speech Representation Learning by Masked Prediction of Hidden Units</a></p><p>[<a href="https://arxiv.org/abs/2004.00849">2004.00849] Pixel-BERT: Aligning Image Pixels with Text by Deep Multi-Modal Transformers</a></p><p><a href="https://openaccess.thecvf.com/content/CVPR2021/html/Huang_Seeing_Out_of_the_Box_End-to-End_Pre-Training_for_Vision-Language_Representation_CVPR_2021_paper.html">CVPR 2021 Open Access Repository</a></p><p>[<a href="https://arxiv.org/abs/2108.10904">2108.10904] SimVLM: Simple Visual Language Model Pretraining with Weak Supervision</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多模态架构相关&quot;&gt;&lt;a href=&quot;#多模态架构相关&quot; class=&quot;headerlink&quot; title=&quot;多模态架构相关&quot;&gt;&lt;/a&gt;多模态架构相关&lt;/h1&gt;&lt;p&gt;MLLM通常包含以下几个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个预训练的&lt;strong&gt;模态编码器&lt;/</summary>
      
    
    
    
    <category term="笔记" scheme="http://wolf-ll.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LLM" scheme="http://wolf-ll.github.io/tags/LLM/"/>
    
    <category term="多模态" scheme="http://wolf-ll.github.io/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://wolf-ll.github.io/2024/11/18/vue/"/>
    <id>http://wolf-ll.github.io/2024/11/18/vue/</id>
    <published>2024-11-18T01:59:32.000Z</published>
    <updated>2024-12-20T03:43:49.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li>web里的网页里 有 三门基础的语言 HTML CSS JavaScript/js</li><li>HTML用于定义网页的基本内容</li><li>CSS样式用于调整网页内容的样式(外观相关的)</li><li>js 用于给网页内容 添加 功能</li></ul><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML（超文本标记语言）是一种用于创建网页标记语言。HTML使用标签来定义网页中的元素，如标题、段落、链接、图像等。它是一种静态语言，主要负责网页的结构和语义化。</p><h4 id="网页基本信息"><a href="#网页基本信息" class="headerlink" title="网页基本信息"></a>网页基本信息</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- DOCTYPE 文本类型，告诉浏览器使用的是什么规范--&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- head 网页头部 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- meta 描述性标签，可描述一些网站信息：比如编码、关键字、间接叙述--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>keywords<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>前端开始<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>这是三件套的开始<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- title 打开网站后看到的网站名称   --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>First HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 主体 内部是可在网页页面上显示的内容--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        Hello，HTML    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--标题标签--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--段落标签，每个标签自成一段--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--换行标签，只是换行，多行成一段--&gt;</span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--水平线标签--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--字体样式标签--&gt;</span>粗体：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">&gt;</span></span>斜体：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">&gt;</span></span>复习前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--特殊格式--&gt;</span>空<span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span>格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>块级标签,简称块</strong>：默认在页面布局里,自己独占一行。</p><ul><li><p>CSS盒子模型属性里的 宽高,内填充,外边框,边框 都可以单独控制且有效果</p></li><li><p>常用的块级元素有 h1~h6 p ul li ol table form div…</p></li></ul><p><strong>行级标签/元素</strong>：默认的在页面布局里,自己会跟其他行级标签挤在一行,除非这一行挤不下,才会换行</p><ul><li>CSS盒子模型属性里的 宽高,内填充,外边框,边框 有一部分是可以控制且有效果的</li><li>常用的行级元素有 a b span font img input select label…</li></ul><h4 id="特殊标签"><a href="#特殊标签" class="headerlink" title="特殊标签"></a>特殊标签</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--1.图片标签--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../resources/image/图片一.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>风景<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>落日<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>前端复习<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>alt图片加载失败时显式的文字，title鼠标悬停到图片显示的文字<span class="token comment">&lt;!--2.链接标签--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HelloHTML.html<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击跳转，文字跳转<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HelloHTML.html<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../resources/image/图片二.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>风景<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>前端复习<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>300<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>300<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--锚链接，定义一个锚标记，然后跳转到锚标记--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>顶部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#top<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>回到顶部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--邮件链接--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mailto:2869861273@qq.com<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击发送邮件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--3.列表标签--&gt;</span><span class="token comment">&lt;!--有序列表--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--无序列表，不是顺序杂乱，而是没有序号标明顺序--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>前端复习3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--自定义列表,dt标题，dd内容--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">&gt;</span></span>前端复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">&gt;</span></span>前端复习1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">&gt;</span></span>前端复习1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">&gt;</span></span>前端复习1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--4.表格标签，tr表格里的行，td表格里的列--&gt;</span>table 表格 默认不显示边框 border属性可以调整边框th 表头单元格 比普通单元格 多了 加粗字体,默认居中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1px<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 跨列合并，保留最左单元格，添加属性 colspan --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 跨行合并，保留最上单元格，添加属性 rowspan --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">rowspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>前端复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>前端复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 当设置了跨行和跨列时，后面所被影响的表格需要去掉从而对齐  --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>前端复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>前端复习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--5.音视频标签,controls显示进度条 autoplay设置自动播放--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">controls</span> <span class="token attr-name">autoplay</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>audio</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">controls</span> <span class="token attr-name">autoplay</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>audio</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--6.iframe内联标签，即在一个网页里还有一个内联框,内联框里是另一个网址--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://www.baidu.com<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h4><ul><li>表单是用来收集用户的不同输入的数据,然后发送给”服务器程序”</li><li>表单form标签,内部可以定义很多不同形式的”表单组件”.</li><li>表单组件有的表现为单行文本框,密码框,按钮,复选框,下拉菜单</li><li>form标签有method属性,设置 本表单的提交方式,默认值为get 可以设置为post</li><li>form标签有action属性,设置 本表单提交到的路径,通常是”服务器程序”的路径</li><li>form标签有enctype属性,设置 当表单里有文件上传时,表单的特殊编码形式</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--7.表单 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HelloHTML.html<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>get<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- name的值就是提交的时候的键 组件里用户输入的数据,就是提交的时候 键对应的值 --&gt;</span>    <span class="token comment">&lt;!-- value 可以设置默认值 --&gt;</span>    <span class="token comment">&lt;!-- placeholder 占位符,不输入的时候一个提示 --&gt;</span>    <span class="token comment">&lt;!-- size 输入框的长度 --&gt;</span>    <span class="token comment">&lt;!-- maxlength 能输入的字符的最大个数 --&gt;</span>    <span class="token comment">&lt;!-- required 表示必须填写,否则表单无法提交,属性名和值相同的,这样的属性 可以直接写属性 --&gt;</span>    <span class="token comment">&lt;!-- pattern 设置 正则表达式 --&gt;</span>    <span class="token comment">&lt;!-- 提交按钮 HTML中已经定义好的 可以提交表单的按钮,把表单里的数据发送出去 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>输入用户名<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30<span class="token punctuation">"</span></span>           <span class="token attr-name">required</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>required<span class="token punctuation">"</span></span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>^[a-zA-Z]\w{3,7}$<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 单选按钮 必须提供相同的name属性 才能成为互斥的一组    &lt;label&gt;Gender:&lt;/label&gt;    &lt;input type="radio" name="gender" value="1" checked/&gt;&lt;label&gt;Female&lt;/label&gt;&lt;img src="img/logo.png"/&gt;    &lt;input type="radio" name="gender" value="2"/&gt;&lt;label&gt;Male&lt;/label&gt;&lt;img src="img/logo.png"/&gt;    &lt;br/&gt;    input 单标签 它的值需要使用value来定义.后面的label/文本/图片 仅仅和它是排版上一起    单选按钮 默认选择的属性 checked --&gt;</span>        <span class="token comment">&lt;!-- 图片形式的提交按钮 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>image<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img/logo.png<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50px<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50px<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>普通按钮<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- js添加功能 --&gt;</span>    <span class="token comment">&lt;!-- 按钮这里 还有一个特殊的button双标签 根据type属性的不同 有不同的效果 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>普通按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>提交按钮:有功能<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>重置按钮:有功能<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--单选框 name表示组，只有在同一组的才能选择其一   --&gt;</span>    男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>girl<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>boy<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--多选框 checked默认选中 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>爱好：        游戏<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>play<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token punctuation">&gt;</span></span>        舞蹈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dance<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        吃<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>eat<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>secret<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>秘密数据<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- 隐藏域 用户看不到,但是可以跟随表单一起提交的数据,一般是程序员设置在此的一个数据 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>birthdayInput<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Birthday:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 日期，邮件等 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>date<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>birthdayInput<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emailInput<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Email:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emailInput<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>week<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>week<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>time<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>time<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 有文件上传时,必须将form的enctype 属性 改为enctype="multipart/form-data"(多组件表单数据)      并且 method 必须改为post,这里没有改 因为 并不能进行真正的上传     --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>photoChoose<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Photo:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>photo<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>photoChoose<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--8.下拉框 selected默认选择--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>下拉框：        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>列表名称<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>china<span class="token punctuation">"</span></span> <span class="token attr-name">selected</span> <span class="token attr-name">disabled</span><span class="token punctuation">&gt;</span></span>中国<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>us<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>英国<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ufo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>美国<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--9.文本域，cols，rows行列长度--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>文本域：        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>textarea<span class="token punctuation">"</span></span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30<span class="token punctuation">"</span></span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>文本框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS（层叠样式表）是一种用于描述网页样式和布局的样式表语言。它与HTML配合使用，负责网页的外观和样式。通过使用CSS，可以控制元素的大小、颜色、字体、布局，实现网页的美观效果和排版。</p><h4 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 1.内部样式--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">h1</span><span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 2.外部样式：链接外部样式表是指通过HTML的link链接标签，建立样式文件和网页的关联。--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css/style.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 3.行内样式--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span> <span class="token property">font-size</span><span class="token punctuation">:</span>30px<span class="token punctuation">;</span> <span class="token property">font-family</span><span class="token punctuation">:</span>黑体<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--     1.标签选择器，选择所有同一标签     --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token selector">标签名</span> <span class="token punctuation">{</span>属性1：属性值1<span class="token punctuation">;</span>属性2：属性值2<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token selector">h1</span> <span class="token punctuation">{</span>         <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>     <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--    2.类选择器，需先在标签里定义一个任意类属性，可多个标签定义同一个类名，然后在css中.类名--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">.类名</span> <span class="token punctuation">{</span>        属性1：属性值1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">.liy</span><span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--    使用类样式    --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标签名</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>类名<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> 标签内容 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>标签名</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>liy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>类选择器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>liy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>类选择器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--  3.id选择器，同样先定义一个id，再在css中#id选择，但一个id只能定义一个标签  --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token selector">#ID标识名</span> <span class="token punctuation">{</span>属性1：属性值1<span class="token punctuation">;</span>属性2：属性值2<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token selector">#gu</span><span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gu<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>id选择器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--  4.通配符选择器，查找页面所有标签，设置相同样式  --&gt;</span>* {  color: red;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="高级选择器"><a href="#高级选择器" class="headerlink" title="高级选择器"></a>高级选择器</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">body p</span><span class="token punctuation">{</span>   选中的是body下面的所有p标签 -- 后代选择器        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">body &gt; p</span><span class="token punctuation">{</span>   选中的是body下面的一代p标签 -- 子代选择器        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">p,.red,#header</span> <span class="token punctuation">{</span>   组合（并集）选择器，逗号分隔<span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span>12px<span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">.active+p</span> <span class="token punctuation">{</span>   选的是active标签之后的一个p标签  --  相邻兄弟选择器        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">.active~p</span> <span class="token punctuation">{</span>   选的是激活标签之后的所有p类型标签        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token comment">/* ：hover 鼠标悬浮时  :active 鼠标点击但未松开时  :focus 获取光标焦点时*/</span>    <span class="token selector">h1:hover,p:hover</span><span class="token punctuation">{</span>    伪类选择器：伪类表示元素状态，选中元素的某个状态设置样式。        <span class="token property">background-color</span><span class="token punctuation">:</span> azure<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">h1:active</span><span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> cornflowerblue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">/* :first-child 选择作为第一个子元素的 */</span>    <span class="token selector">tr:first-child:hover</span><span class="token punctuation">{</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/*    这里是对tr进行 筛选, 选出所有tr中 作为别人的第一个子元素的tr    并不是选取 tr内部的第一个孩子     */</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 首先搭建标签并设置标签的格式 */</span><span class="token selector">&lt;p class="demo"&gt; &lt;a href="www.baidu.com" class="links item first" id="first"&gt;1&lt;/a&gt; &lt;a href="" class="links item active" target="_blank" title="test"&gt;2&lt;/a&gt; &lt;a href="resources/image/图片一.jpg" class="links item" &gt;3&lt;/a&gt; &lt;a href="abc" class="links item"&gt;4&lt;/a&gt; &lt;a href="/a.pdf" class="links item"&gt;5&lt;/a&gt; &lt;a href="/abc.pdf" class="links item"&gt;6&lt;/a&gt; &lt;a href="abcd.docx" class="links item"&gt;7&lt;/a&gt; &lt;a href="abc.docx" class="links item"&gt;8&lt;/a&gt; &lt;/p&gt; &lt;style&gt;     .demo a</span><span class="token punctuation">{</span>         <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>         <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>         <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>         <span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>         <span class="token property">border-radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>         <span class="token property">background</span><span class="token punctuation">:</span> #2700ff<span class="token punctuation">;</span>         <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>         <span class="token property">color</span><span class="token punctuation">:</span> gainsboro<span class="token punctuation">;</span>         <span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>         <span class="token property">margin-right</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>         <span class="token property">font</span><span class="token punctuation">:</span> bold 20px/50px Arial<span class="token punctuation">;</span>     <span class="token punctuation">}</span> &lt;/style&gt;<span class="token comment">/*  在style中进行选择，属性选择器格式就是标签+[属性]  */</span><span class="token comment">/*    1.选择存在id的元素*/</span> <span class="token selector">a[id]</span> <span class="token punctuation">{</span>     <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">/*    2.选择id为first的标签*/</span> <span class="token selector">a[id="first"]</span> <span class="token punctuation">{</span>     <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">/*    3.选中class里有links的标签*/</span> <span class="token selector">a[class*="links"]</span> <span class="token punctuation">{</span>     <span class="token property">background</span><span class="token punctuation">:</span> bisque<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">/*    4.特定的开头和结尾  */</span> <span class="token selector">a[href^=w]</span> <span class="token punctuation">{</span>     <span class="token property">background</span><span class="token punctuation">:</span> cornflowerblue<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token selector">a[href$=x]</span> <span class="token punctuation">{</span>     <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="文字控制"><a href="#文字控制" class="headerlink" title="文字控制"></a>文字控制</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p</span><span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> 华文行楷<span class="token punctuation">;</span>   <span class="token comment">/* 字体类型  */</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span><span class="token comment">/* 字体大小  */</span>    <span class="token property">font-style</span><span class="token punctuation">:</span> oblique<span class="token punctuation">;</span><span class="token comment">/* 字体样式：italic斜体字，oblique倾斜的文字 */</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> 900<span class="token punctuation">;</span><span class="token comment">/* 字体粗细  */</span><span class="token punctuation">}</span><span class="token selector">span</span><span class="token punctuation">{</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> 2rem<span class="token punctuation">;</span>    <span class="token property">line-height</span><span class="token punctuation">:</span>25px<span class="token punctuation">;</span>  <span class="token comment">/* 设置行高（即行间距），常用取值为 25px、28px */</span>    <span class="token comment">/* 设置元素中文本的水平对齐方式，继承给子级 */</span>    <span class="token property">text-align</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token selector">&lt;style type="text/css"&gt;    #p1</span> <span class="token punctuation">{</span>        <span class="token property">text-indent</span><span class="token punctuation">:</span> 2em<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">#p1 &gt; a</span> <span class="token punctuation">{</span>        <span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token comment">/* 设置文本修饰， 常用的取值为underline（下划线）、none  */</span>        <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>        <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">#p1 &gt; a:hover</span> <span class="token punctuation">{</span>        <span class="token property">text-decoration</span><span class="token punctuation">:</span> underline<span class="token punctuation">;</span>        <span class="token property">color</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">.pp2</span> <span class="token punctuation">{</span>        <span class="token property">text-transform</span><span class="token punctuation">:</span> capitalize<span class="token punctuation">;</span>        <span class="token property">word-spacing</span><span class="token punctuation">:</span> 2em<span class="token punctuation">;</span>        <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token comment">/*  设置对齐方式，常用的取值为left、right 以及 center  */</span>    <span class="token punctuation">}</span>    <span class="token selector">.pp3</span> <span class="token punctuation">{</span>        <span class="token property">letter-spacing</span><span class="token punctuation">:</span> 1em<span class="token punctuation">;</span><span class="token comment">/* 设置字符间距，常用的取值为3px、8px */</span>    <span class="token punctuation">}</span>    <span class="token selector">ul</span> <span class="token punctuation">{</span>        <span class="token comment">/*list-style-position: inside;*/</span>        <span class="token comment">/*list-style-type: decimal;*/</span>        <span class="token comment">/*list-style-type: none;*/</span>        <span class="token comment">/*list-style-image: url("img/logo.png");*/</span>        <span class="token comment">/* 列表在设置时,一般会直接把列表项标志设置为none */</span>    <span class="token punctuation">}</span>    <span class="token selector">table</span> <span class="token punctuation">{</span>        <span class="token property">border-collapse</span><span class="token punctuation">:</span> collapse<span class="token punctuation">;</span>        <span class="token comment">/*border-spacing: 10px 15px;*/</span>        <span class="token comment">/*caption-side: bottom;*/</span>       <span class="token comment">/* empty-cells: hide;*/</span>        <span class="token comment">/* 列宽度算法 */</span>        <span class="token comment">/*table-layout: fixed;*/</span>    <span class="token punctuation">}</span>    <span class="token selector">button</span><span class="token punctuation">{</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token comment">/*background-color: transparent;*/</span><span class="token comment">/* 透明 */</span>    <span class="token punctuation">}</span>    <span class="token selector">button:hover</span><span class="token punctuation">{</span>        <span class="token comment">/*outline-style: solid;        outline-width: 2px;        outline-color: red;*/</span>        <span class="token property">outline</span><span class="token punctuation">:</span> green double 3px<span class="token punctuation">;</span>    <span class="token punctuation">}</span>&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="CSS特性"><a href="#CSS特性" class="headerlink" title="CSS特性"></a>CSS特性</h4><p>CSS特性：化简代码 / 定位问题，并解决问题</p><ul><li>继承性：子级默认继承父级的<strong>文字控制属性</strong>。 如果标签有默认文字样式会继承失败。</li><li>层叠性：相同属性后面的覆盖前面的，不同属性叠加。</li><li>优先级：当一个标签<strong>使用了多种选择器时</strong>，基于不同种类的选择器的<strong>匹配规则</strong>。</li></ul><p><strong>基础选择器</strong></p><p>规则：选择器<strong>优先级高的样式生效</strong>。</p><p>公式：<strong>通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内样式 &lt; !important</strong></p><p>​           <strong>（选中标签的范围越大，优先级越低）</strong></p><p><strong>复合选择器-叠加</strong></p><p>叠加计算：如果是复合选择器，则需要<strong>权重叠加</strong>计算。</p><p>公式：（每一级之间不存在进位）</p><img src="/2024/11/18/vue/1680319646205-1732170256083.png" alt="1680319646205" style="zoom:67%;"><p>规则：</p><ul><li>从左向右依次比较选个数，同一级个数多的优先级高，如果个数相同，则向后比较</li><li><strong>!important 权重最高</strong></li><li>继承权重最低</li></ul><h4 id="显示设置"><a href="#显示设置" class="headerlink" title="显示设置"></a>显示设置</h4><p>display 用于设置行内元素的排列。display方向不可以控制。</p><p>float浮动起来的话会脱离标准文档流，所以要解决父级边框塌陷的问题</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span><span class="token comment">/* 块级 */</span><span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span> <span class="token comment">/* 行内块 一行可以显示多个 */</span><span class="token property">display</span><span class="token punctuation">:</span> inline<span class="token punctuation">;</span> <span class="token comment">/* 行内 */</span><span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span> <span class="token comment">/* 独立于底层，设置浮动 */</span><span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span><span class="token property">clear</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span> <span class="token comment">/* 右侧不允许有浮动元素 */</span><span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span> <span class="token comment">/* 两侧都不允许有浮动元素 */</span><span class="token property">clear</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span><span class="token property">clear</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token selector">#d1</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> 2px solid dimgray<span class="token punctuation">;</span>    <span class="token comment">/* overflow 调整内容溢出 */</span>    <span class="token comment">/*overflow: hidden; */</span><span class="token comment">/*隐藏 */</span>    <span class="token comment">/*overflow: scroll;*/</span><span class="token comment">/* 滚动条*/</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token comment">/* 自动添加滚动条 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>盒子模型：即边距margin，边框border，填充padding，和实际内容。</p><p>外边距设置居中：margin: auto;（前提该标签需要在一个块元素内，即要有边界）</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">    <span class="token selector">&lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style type="text/css"&gt;        .div01</span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span><span class="token comment">/* width,height仅仅设置内容区域 */</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 2em 4em<span class="token punctuation">;</span><span class="token comment">/* padding是简写,简写了四个方向 */</span>            <span class="token comment">/* 如果是给1个值 那就是 4个方向都设置 */</span>            <span class="token comment">/* 如果给2个值 第一个值是 上下 第二个值是 左右 */</span>            <span class="token comment">/* 如果给3个值 第一个值是 上 第二个值 左右 第三个值 下 */</span>            <span class="token comment">/* 如果给4个值 分别是 上 右 下 左 顺时针 */</span>            <span class="token property">border</span><span class="token punctuation">:</span> 2px solid red<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector">span</span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token comment">/* 行级元素的 宽高属性 无效,根据内容的大小自动调整的 */</span>        <span class="token punctuation">}</span>        <span class="token selector">#span2</span><span class="token punctuation">{</span>            <span class="token comment">/*border: 10px solid red;*/</span><span class="token comment">/* 边框可以调整左右,上下不建议调整 */</span>            <span class="token comment">/*padding: 20px;*/</span><span class="token comment">/* 内填充可以调整左右,上下不建议调整 */</span>            <span class="token comment">/*margin: 20px;*/</span><span class="token comment">/* 外边距可以调整左右,上下不建议调整 */</span>            <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 2px solid purple<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector">.div01:first-child</span><span class="token punctuation">{</span>            <span class="token property">border</span><span class="token punctuation">:</span>2px solid blue<span class="token punctuation">;</span>            <span class="token property">margin</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span>            <span class="token comment">/* padding margin border 都可以写 xxx-方向 */</span>        <span class="token punctuation">}</span>    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;   &lt;!-- div 块级标签 没有任何显示效果<span class="token punctuation">,</span>需要结合css盒子模型属性的调整 --&gt;   &lt;div class=<span class="token string">"div01"</span> style=<span class="token string">"display: none"</span>&gt;       这是内容!   &lt;/div&gt;   &lt;div class=<span class="token string">"div01"</span> style=<span class="token string">"display: inline"</span>&gt;       这是内容!   &lt;/div&gt;   &lt;!-- 盒子模型/框模型 在 行级元素里的部分 不建议调整 --&gt;   &lt;span id=<span class="token string">"span1"</span>&gt;span1&lt;/span&gt;&lt;span id=<span class="token string">"span2"</span>&gt;span2&lt;/span&gt;&lt;span id=<span class="token string">"span3"</span>&gt;span3&lt;/span&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>文档流：默认的摆放形式，行级和行级在一行，实在放不下就换行，块级独占一行</p><ul><li>相对定位relative：相对于 自身加载的原始位置 的 定位 原来的位置是被保留的</li><li>绝对定位absolute：相对于 已经定位的父元素 的 定位 原来的位置不被保留.</li><li>固定定位fixed：相对于 视窗(浏览器窗口) 原来的位置不被保留.</li></ul><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">#move</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>    <span class="token comment">/* 固定定位 */</span>    <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> -1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#outer</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token comment">/* 相对定位 */</span>    <span class="token property">left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> <span class="token comment">/* 定位之后的位置 左边 100px 是原来的位置 */</span>    <span class="token property">top</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> <span class="token comment">/* 定位之后的位置 上边100px 是原来的位置 */</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> -1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#outer2</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span><span class="token comment">/* 绝对定位 父亲是body */</span>    <span class="token property">left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> -2<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript是一种基于<strong>对象和事件驱动</strong>的脚本语言，作用是给网页添加交互功能和动态效果。它可以操作网页元素、响应用户操作、发送网络请求、处理数据等。JavaScript使得网页具有更高级的交互性和动态性，可以实现表单验证、页面动画、实时数据更新等。</p><p>html中使用js有三种,标签内,内部,外部 使用js一般是两种,也就是内部和外部</p><p>标签内：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>javascript:alert('这是js的信息弹框!这样的用法几乎不使用')<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点我弹出一个信息框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内部：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>...  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">        <span class="token comment">/* 脚本 */</span>       <span class="token comment">/* alert("js的弹框000");*/</span>        <span class="token comment">//js 里函数 就是 java里的方法</span>        <span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'show方法里的弹框!'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>    通过在标签上的 事件动作 on在click点击 的时候 执行 js函数 show()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>外部：</p><p>把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。外部 JavaScript 文件的文件扩展名是 .js。如需使用外部文件，请在 &lt;script&gt; 标签的 “src” 属性中设置该 .js 文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myScript.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="JS输出"><a href="#JS输出" class="headerlink" title="JS输出"></a>JS输出</h4><p>JavaScript 可以通过不同的方式来输出数据：</p><ul><li>使用 <strong>window.alert()</strong> 弹出警告框。</li><li>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中。</li><li>使用 <strong>innerHTML</strong> 写入到 HTML 元素：如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(<em>id</em>) 方法。请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容</li><li>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>在编程语言中，一般固定值称为字面量，如 3.14。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">3.14</span>  <span class="token number">1001</span>  <span class="token number">123e5</span><span class="token string">"John Doe"</span>  <span class="token string">'John Doe'</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token literal-property property">firstName</span><span class="token operator">:</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token literal-property property">lastName</span><span class="token operator">:</span><span class="token string">"Doe"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token literal-property property">eyeColor</span><span class="token operator">:</span><span class="token string">"blue"</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 对象寻址方式</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">firstName</span><span class="token operator">:</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token literal-property property">lastName</span><span class="token operator">:</span><span class="token string">"Doe"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token literal-property property">eyeColor</span><span class="token operator">:</span><span class="token string">"blue"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>name <span class="token operator">=</span> person<span class="token punctuation">.</span>lastname<span class="token punctuation">;</span>name <span class="token operator">=</span> person<span class="token punctuation">[</span><span class="token string">"lastname"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript 使用关键字 <strong>var</strong> 来定义变量， 使用等号来为变量赋值。变量可以通过变量名访问。在指令式语言中，变量通常是可变的。字面量是一个恒定的值。</p><ul><li>js里语句最后的分号可加可不加</li><li>使用关键字 var let 可以声明变量,const声明常量<ul><li>var声明的变量 为 js顶级对象window的属性,为全局变量</li><li>let声明的变量 为 局部变量</li></ul></li></ul><p>**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。</p><p><strong>引用数据类型（对象类型）</strong>：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。</p><p>流程控制</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//遍历</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'============='</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//iter</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'============'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//forin</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'-------------'</span><span class="token punctuation">)</span><span class="token comment">//对象</span><span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'jacky'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    <span class="token literal-property property">gender</span><span class="token operator">:</span> <span class="token string">'男'</span><span class="token punctuation">,</span>    <span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token string">"长大"</span><span class="token punctuation">,</span>    <span class="token function-variable function">study</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"学习学习"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//for-in可以去遍历对象,遍历对象的时候,对象类似一个Map集合  let变量 是 键</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> stuKey <span class="token keyword">in</span> stu<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">[</span>stuKey<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 错误处理</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name <span class="token operator">+</span> person<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里有错误</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Map，Set：ES6新特性  Map,同java里的Map  js里只有这两个数组和集合</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"tom"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"okk"</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token number">10</span>map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"ggz"</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token parameter"><span class="token number">4</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token string">'tom'</span> <span class="token operator">=&gt;</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'jack'</span> <span class="token operator">=&gt;</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">'okk'</span> <span class="token operator">=&gt;</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">'ggz'</span> <span class="token operator">=&gt;</span> <span class="token number">8</span><span class="token punctuation">}</span>idea书写<span class="token keyword">var</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"tom"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"okk"</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">var</span> age1 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"qqz"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  是一个无序集合set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  添加set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  是否包含元素set<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  删除set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>array</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"lucy"</span><span class="token punctuation">,</span><span class="token string">"jacky"</span><span class="token punctuation">,</span><span class="token string">"candy"</span><span class="token punctuation">,</span><span class="token string">"joe"</span><span class="token punctuation">,</span><span class="token string">"tom"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">len3</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span>length<span class="token operator">&gt;=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span>len3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对数组的每一个数据 调用 len3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span>length<span class="token operator">&gt;=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对数组的每一个数据 调用 判断 长度是否&gt;=3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span>length<span class="token operator">===</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//过滤 得到 数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查找 只返回 第一个de 下标</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"^_^"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数组类的工具方法,从某个数组,经过某个计算,得到新数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"~"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用连接符把数组里的每个数据连接起来返回字符串</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"-_-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数组里的每个数据 进行映射 映射为新数组</span><span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">,</span><span class="token string">"show"</span><span class="token punctuation">,</span><span class="token string">"say"</span><span class="token punctuation">,</span><span class="token string">"setColor"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//弹栈,从数组末尾删除 并得到数据</span><span class="token punctuation">}</span><span class="token keyword">let</span> stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>stack2<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"="</span><span class="token operator">+</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//压栈,将数据添加到数组的末尾</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//total默认是第一个值 name是后面的每一个值,初始化total要放在reduce()中,不能放在log()中</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span>name</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token keyword">return</span> total<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"名字大联合:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span>name</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token keyword">return</span> total<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">,</span><span class="token string">"小妹"</span><span class="token punctuation">,</span><span class="token string">"小梅"</span><span class="token punctuation">,</span><span class="token string">"黎明"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"买饭要排队:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从数组开头删除 并 返回数据</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"部分人员名单:"</span><span class="token operator">+</span>names<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从倒数第二个开始 直到最后</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"部分人员名单:"</span><span class="token operator">+</span>names<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开始的下标 结束的下标(不包括)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token operator">=&gt;</span>name<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"j"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查找有没有一个数组的数据 符合 开头是j</span><span class="token comment">//let names = ["lucy","jacky","candy","joe","tom"];</span><span class="token comment">//splice 先删除 后添加</span><span class="token comment">/*names.splice(1,1,"小李","桃子")console.log(names);*/</span><span class="token operator">/</span><span class="token operator">/</span>在<span class="token number">1</span>下标处删除数据<span class="token punctuation">,</span>添加 后面的两个数据<span class="token punctuation">,</span>此方法会得到 删除的数据names<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"小小船"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在1小标出删除0个数据,添加后面1个数据</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//['lucy', '小小船', 'jacky', 'candy', 'joe', 'tom']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>    函数的定义方式一    <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>        <span class="token comment">//执行到retuen代表函数结束，返回结果，</span>        <span class="token comment">//如果没有执行return，函数执行完也会返回结果，结果为undefined</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>    函数的定义方式二    <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token comment">//这种形式就是把function (x)当成匿名内部类，但是可以把该类赋值给一个变量，通过变量调用函数</span><span class="token keyword">var</span> <span class="token function-variable function">abs2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>    规避参数不存在和多个参数问题    <span class="token operator">--</span><span class="token operator">&gt;</span>参数不存在时可设置抛出异常  ，<span class="token keyword">typeof</span>可判断变量类型<span class="token keyword">var</span> <span class="token function-variable function">abs3</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">!=</span><span class="token string">"number"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token string">"Not a Number"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>对于参数过长<span class="token comment">// es5所用方法，arguments关键子，代表一个数组，会把所有传进来的参数都放到里面</span><span class="token keyword">var</span> <span class="token function-variable function">abs4</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//e6所用方法，rest关键子，剩余的，会把除定义的参数外其他所有传进来的参数都放到里面。...在java代表可变参数</span><span class="token keyword">var</span> <span class="token function-variable function">abs5</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token operator">...</span>rest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>HTML 事件是发生在 HTML 元素上的事情。当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。HTML 元素中可以添加事件属性，使用 JavaScript 代码来添加 HTML 元素。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'demo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>现在的时间是?<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>现在的时间是?<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th align="left">事件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">onchange</td><td align="left">HTML 元素改变</td></tr><tr><td align="left">onclick</td><td align="left">用户点击 HTML 元素</td></tr><tr><td align="left">onmouseover</td><td align="left">鼠标指针移动到指定的元素上时发生</td></tr><tr><td align="left">onmouseout</td><td align="left">用户从一个 HTML 元素上移开鼠标时发生</td></tr><tr><td align="left">onkeydown</td><td align="left">用户按下键盘按键</td></tr><tr><td align="left">onload</td><td align="left">浏览器已完成页面的加载</td></tr></tbody></table><p>更多事件：<a href="https://www.runoob.com/jsref/dom-obj-event.html">HTML DOM 事件对象 | 菜鸟教程</a></p><p>事件可以用于处理表单验证，用户输入，用户行为及浏览器动作:</p><ul><li>页面加载时触发事件</li><li>页面关闭时触发事件</li><li>用户点击按钮执行动作</li><li>验证用户输入内容的合法性……</li></ul><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p>HTML 表单验证可以通过 JavaScript 来完成。</p><p>以下实例代码用于判断表单字段(fname)值是否存在， 如果不存在，就弹出信息，阻止表单提交：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">validateForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x <span class="token operator">=</span> document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token string">"myForm"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"fname"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> x <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"需要输入名字。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myForm<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo_form.php<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onsubmit</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token keyword">return</span> <span class="token function">validateForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    名字: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fname<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>提交<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>数据验证用于确保用户输入的数据是有效的。典型的数据验证有：</p><ul><li>必需字段是否有输入?</li><li>用户是否输入了合法的数据?</li><li>在数字字段是否输入了文本?</li></ul><p>大多数情况下，数据验证用于确保用户正确输入数据。数据验证可以使用不同方法来定义，并通过多种方式来调用。</p><p><strong>服务端数据验证</strong>是在数据提交到服务器上后再验证。<strong>客户端数据验证</strong>是在数据发送到服务器前，在浏览器上完成验证。</p><p>HTML5 新增了 HTML 表单的验证方式：约束验证（constraint validation）。约束验证是表单被提交时浏览器用来实现验证的一种算法。</p><p>HTML 约束验证基于：</p><ul><li><strong>HTML 输入属性</strong></li><li><strong>CSS 伪类选择器</strong></li><li><strong>DOM 属性和方法</strong></li></ul><p>约束验证 HTML 输入属性</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">disabled</td><td align="left">规定输入的元素不可用</td></tr><tr><td align="left">max</td><td align="left">规定输入元素的最大值</td></tr><tr><td align="left">min</td><td align="left">规定输入元素的最小值</td></tr><tr><td align="left">pattern</td><td align="left">规定输入元素值的模式</td></tr><tr><td align="left">required</td><td align="left">规定输入元素字段是必需的</td></tr><tr><td align="left">type</td><td align="left">规定输入元素的类型</td></tr></tbody></table><p>约束验证DOM方法：</p><ul><li>checkValidity()：如果 input 元素中的数据是合法的返回 true，否则返回 false。</li><li>setCustomValidity()：设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。</li></ul><p>input 元素的 <strong>validity 属性</strong>包含一系列关于 validity 数据属性:</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">customError</td><td align="left">设置为 true, 如果设置了自定义的 validity 信息。</td></tr><tr><td align="left">patternMismatch</td><td align="left">设置为 true, 如果元素的值不匹配它的模式属性。</td></tr><tr><td align="left">rangeOverflow</td><td align="left">设置为 true, 如果元素的值大于设置的最大值。</td></tr><tr><td align="left">rangeUnderflow</td><td align="left">设置为 true, 如果元素的值小于它的最小值。</td></tr><tr><td align="left">stepMismatch</td><td align="left">设置为 true, 如果元素的值不是按照规定的 step 属性设置。</td></tr><tr><td align="left">tooLong</td><td align="left">设置为 true, 如果元素的值超过了 maxLength 属性设置的长度。</td></tr><tr><td align="left">typeMismatch</td><td align="left">设置为 true, 如果元素的值不是预期相匹配的类型。</td></tr><tr><td align="left">valueMissing</td><td align="left">设置为 true，如果元素 (required 属性) 没有值。</td></tr><tr><td align="left">valid</td><td align="left">设置为 true，如果元素的值是合法的。</td></tr></tbody></table><p>例如：如果输入的值大于 100，显示一个信息</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"id1"</span> type<span class="token operator">=</span><span class="token string">"number"</span> max<span class="token operator">=</span><span class="token string">"100"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>button onclick<span class="token operator">=</span><span class="token string">"myFunction()"</span><span class="token operator">&gt;</span>验证<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">"demo"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> txt <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"id1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>validity<span class="token punctuation">.</span>rangeOverflow<span class="token punctuation">)</span> <span class="token punctuation">{</span>       txt <span class="token operator">=</span> <span class="token string">"输入的值太大了"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> txt<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>文档对象，每个网页都是一个DOM树形结构（HTML 文档中的所有内容都是节点），可以对它进行增删改查操作</p><p>增删改查：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//获取各个节点</span>document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'p2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取父节点</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'f1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取父节点下所有子节点</span>f1<span class="token punctuation">.</span>children<span class="token comment">// 删除dom</span><span class="token comment">//删除父节点下的一个子节点，需要先获取父节点，再删除子节点</span><span class="token keyword">var</span> son <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> father <span class="token operator">=</span> p1<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>father<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 更新dom</span><span class="token comment">//首先获取到一个节点</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'dom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//操作文本节点,需要全部使用冒号</span>dom<span class="token punctuation">.</span>innerText<span class="token operator">=</span><span class="token string">'123'</span><span class="token punctuation">;</span><span class="token comment">//操作html节点</span>dom<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">'888nbsp;999'</span><span class="token comment">//操作js节点</span>dom<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">;</span>dom<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize<span class="token operator">=</span><span class="token string">'100px'</span><span class="token punctuation">;</span><span class="token comment">// 插入dom</span><span class="token keyword">var</span> s1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'s1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> s2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'s2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//append插入一个已存在的节点</span>s2<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//插入一个新的节点</span><span class="token keyword">var</span> s5 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//新建一个空的p标签，这个标签叫s5，&lt;p&gt;</span>s5<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'s5'</span><span class="token punctuation">;</span> <span class="token comment">//给s5这个标签设置id为s5</span>s5<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'这是新建的一个p标签'</span><span class="token punctuation">;</span> <span class="token comment">//给s5设置内容</span>s2<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>s5<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span>   <span class="token comment">// 1 dom 获取 name属性是hobby 的4个input对象 组合的数组 的长度  把他弹出!</span>   <span class="token comment">// 2 修改 .hh2 的h2 标题 的 文本内容为   "我的标题2"</span>   <span class="token comment">// 3 将 #zstd 单元格 所在行 文本居中.</span>   <span class="token comment">// 4 鼠标悬浮到表格上时  #myjava 被选择!</span>   <span class="token comment">//文档加载完毕,才去执行,这样就能获得html内容了</span>   window<span class="token punctuation">.</span><span class="token function-variable function">onload</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">"hobby"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"hh2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">"我的标题2"</span><span class="token punctuation">;</span><span class="token comment">//这里也可以写innerHTML(标签,文本)</span>      <span class="token comment">//原生的css里是text-align js里变为驼峰了</span>      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"zstd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>textAlign <span class="token operator">=</span> <span class="token string">"center"</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"table"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onmouseover</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"myjava"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>checked<span class="token operator">=</span><span class="token string">"checked"</span><span class="token punctuation">;</span><span class="token comment">//true 修改浏览器内存里的对象属性 及时的反应在浏览效果上</span>         <span class="token comment">//document.getElementById("myjava").setAttribute("checked","checked");//修改源码里的对象的属性</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span class="token comment">// 事件</span><span class="token comment">//move是js里 封装的 事件对象,有很多属性可以调用,有阻止默认行为的方法</span><span class="token keyword">function</span> <span class="token function">momo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//circle跟随鼠标移动而移动!</span>   <span class="token comment">//鼠标指针的坐标</span>   <span class="token keyword">let</span> x <span class="token operator">=</span> event<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span><span class="token comment">//event为内置对象</span>   <span class="token keyword">let</span> y <span class="token operator">=</span> event<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"circle"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">50</span><span class="token operator">+</span><span class="token string">"px"</span><span class="token punctuation">;</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"circle"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> y <span class="token operator">-</span> <span class="token number">50</span><span class="token operator">+</span><span class="token string">"px"</span><span class="token punctuation">;</span><span class="token comment">//?????????????????????????</span><span class="token punctuation">}</span><span class="token comment">//演示 event对象 的 阻止默认行为的 方法</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"a1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">"确定要打开百度吗?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">===</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"province"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onchange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"你选择的省份: "</span><span class="token operator">+</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"province"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onfocus</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">"red"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onblur</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 导入 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../../lib/jquery-3.7.1.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 使用 --&gt;</span><span class="token comment">&lt;!-- 1.先创建一个标签--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jquery<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击事件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token number">2.</span>通过jquery进行操作   <span class="token operator">--</span><span class="token operator">&gt;</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#jquery'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//先选择这个id标签，再操作一个事件，这里操作的是点击事件click，事件里面有个函数</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'hello,jquery'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>u1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>u2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>ggz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>u3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>xmm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>u4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>qqz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token comment">// jquery获取值和设置值,都要加''</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#u1 li[id=u2]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">'jjz999'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'u3'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#u1 li[name=u4]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 操作css</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#u1 li[class=u3]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string-property property">"color"</span><span class="token operator">:</span><span class="token string">"red"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string-property property">"background"</span><span class="token operator">:</span><span class="token string">"blue"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#u2'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string-property property">"fontSize"</span><span class="token operator">:</span><span class="token string">"50px"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment">// 文档的显示与隐藏，先设置display: none;，再对某标签进行隐藏和显示</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#ul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#ul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Vue-1"><a href="#Vue-1" class="headerlink" title="Vue"></a>Vue</h2><p>Vue是一个构建用户界面UI的<strong>渐进式javascript框架</strong>，渐进式的框架是指可以一步一步的由浅入深的去使用这个框架，该框架可以逐步引入项目。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><p>Vue2官网（已停止维护）：<a href="https://v2.cn.vuejs.org/">https://v2.cn.vuejs.org/</a>。Vue2教程：<a href="https://v2.cn.vuejs.org/v2/guide/">介绍 — Vue.js</a></p><h3 id="创建Vue实例"><a href="#创建Vue实例" class="headerlink" title="创建Vue实例"></a>创建Vue实例</h3><ol><li>准备容器</li><li>引包（官网） — 开发版本/生产版本</li><li>创建Vue实例  new Vue()</li><li>指定配置项，渲染数据<ol><li>el：指定挂载点，即Vue所管理的容器</li><li>data：提供数据，使用插值表达式可以渲染出Vue提供的数据</li></ol></li></ol><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--   创建Vue实例，初始化渲染  1. 准备容器 (Vue所管理的范围)  2. 引包 (开发版本包 / 生产版本包) 官网  3. 创建实例  4. 添加配置项 =&gt; 完成渲染--&gt; &lt;!-- 不是Vue管理的范围 --&gt;&lt;div class="box2"&gt;  box2 -- {{ count }}&lt;/div&gt;&lt;div class="box"&gt;  box -- {{ msg }}&lt;/div&gt;-----------------------------------------------------&lt;!-- Vue所管理的范围 --&gt;&lt;div id="app"&gt;  &lt;!-- 插值表达式{{data}}，渲染data中的数据 --&gt;  &lt;h1&gt;{{ msg }}&lt;/h1&gt;  &lt;a href="#"&gt;{{ count }}&lt;/a&gt;&lt;/div&gt; &lt;!-- 引入的是开发版本包 - 包含完整的注释和警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"&gt;&lt;/script&gt; &lt;script&gt;  // 一旦引入 VueJS核心包，在全局环境，就有了 Vue 构造函数  const app = new Vue({    // 通过 el 配置选择器，指定 Vue 管理的是哪个盒子（这里app对应上面div id=app）    el: '#app',    // 通过 data 提供数据    data: {      msg: 'Hello 传智播客',      count: 666    }  }) &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="响应式特性"><a href="#响应式特性" class="headerlink" title="响应式特性"></a>响应式特性</h3><p>Vue 核心特性：响应式：<strong>数据变化，视图自动更新</strong>，数据驱动视图</p><img src="/2024/11/18/vue/1681888539340.png?lastModify=1733991844" alt="68188853934" style="zoom:67%;"><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><strong>概念：</strong>指令（Directives）是 Vue 提供的带有 <strong>v- 前缀</strong> 的 特殊 标签<strong>属性</strong>。Vue 会根据不同的指令，针对标签实现不同的功能</p><p>vue 中的指令按照不同的用途可以分为如下 6 大类：</p><ul><li>内容渲染指令（v-html、v-text）</li><li>条件渲染指令（v-show、v-if、v-else、v-else-if）</li><li>事件绑定指令（v-on）</li><li>属性绑定指令 （v-bind）</li><li>双向绑定指令（v-model）</li><li>列表渲染指令（v-for）</li></ul><h4 id="v-text-内容渲染"><a href="#v-text-内容渲染" class="headerlink" title="v-text 内容渲染"></a>v-text 内容渲染</h4><p>内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下2 个：</p><ul><li><p>v-text（类似innerText）</p></li><li><ul><li>使用语法：<code>&lt;p v-text="uname"&gt;hello&lt;/p&gt;</code>，意思是将 uame 值渲染到 p 标签中</li><li>类似 innerText，使用该语法，会覆盖 p 标签原有内容</li></ul></li><li><p>v-html（类似 innerHTML）</p></li><li><ul><li>使用语法：<code>&lt;p v-html="intro"&gt;hello&lt;/p&gt;</code>，意思是将 intro 值渲染到 p 标签中</li><li>类似 innerHTML，使用该语法，会覆盖 p 标签原有内容</li><li>类似 innerHTML，使用该语法，能够将HTML标签的样式呈现出来。</li></ul></li></ul><p>代码演示：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>个人信息<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span><span class="token comment">// 既然指令是vue提供的特殊的html属性，所以咱们写的时候就当成属性来用即可</span><span class="token operator">&lt;</span>p v<span class="token operator">-</span>text<span class="token operator">=</span><span class="token string">"uname"</span><span class="token operator">&gt;</span>姓名：<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>p v<span class="token operator">-</span>html<span class="token operator">=</span><span class="token string">"intro"</span><span class="token operator">&gt;</span>简介：<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>        <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">{</span>            <span class="token literal-property property">uname</span><span class="token operator">:</span><span class="token string">'张三'</span><span class="token punctuation">,</span>            <span class="token literal-property property">intro</span><span class="token operator">:</span><span class="token string">'&lt;h2&gt;这是一个&lt;strong&gt;非常优秀&lt;/strong&gt;的boy&lt;h2&gt;'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="v-if-条件渲染"><a href="#v-if-条件渲染" class="headerlink" title="v-if 条件渲染"></a>v-if 条件渲染</h4><ol><li><p><code>v-show</code> 原理是切换 <code>display:none</code> 控制元素显示隐藏。适合频繁切换显示隐藏的场景 </p><p>（v-show = “表达式”   表达式值为 true 显示， false 隐藏）</p></li><li><p><code>v-if</code>  基于条件判断，是否创建 或 移除元素节点。要么显示，要么隐藏，适合不频繁切换的场景</p></li></ol><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;h3 v-if="age &lt; 18"&gt;young&lt;/h3&gt;&lt;h3 v-else-if="age &lt; 40"&gt;mid&lt;/h3&gt;&lt;h3 v-else&gt;old&lt;/h3&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="v-on-事件绑定"><a href="#v-on-事件绑定" class="headerlink" title="v-on 事件绑定"></a>v-on 事件绑定</h4><ul><li>&lt;button v-on:事件名=”内联语句”&gt;按钮</li><li>&lt;button v-on:事件名=”处理函数”&gt;按钮</li><li>&lt;button v-on:事件名=”处理函数(实参)”&gt;按钮</li><li><code>v-on:</code> 简写为 <strong>@</strong></li></ul><p>双击事件：@dblclick</p><p>失去焦点事件：@blur</p><p>输入框内容改变、下拉列表改变：@change</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;button v-on:click="count++"&gt;按钮&lt;/button&gt; &lt;button @click="fn"&gt;按钮&lt;/button&gt;&lt;button @click="fn(a,b)"&gt;按钮&lt;/button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>v-on配置methods函数</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;body&gt;  &lt;div id="app"&gt;    &lt;button @click="fn"&gt;切换显示隐藏&lt;/button&gt;    &lt;h1 v-show="isShow"&gt;黑马程序员&lt;/h1&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    const app4 = new Vue({      el: '#app',      data: {        isShow: true      },      methods: {        fn () {          // 让提供的所有methods中的函数，this都指向当前实例          // console.log('执行了fn', app.isShow)          // console.log(app3 === this)          this.isShow = !this.isShow        }      }    })  &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数传递</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;body&gt;   &lt;div id="app"&gt;    &lt;div class="box"&gt;      &lt;h3&gt;小黑自动售货机&lt;/h3&gt;      &lt;button @click="buy(5)"&gt;可乐5元&lt;/button&gt;      &lt;button @click="buy(10)"&gt;咖啡10元&lt;/button&gt;      &lt;button @click="buy(8)"&gt;牛奶8元&lt;/button&gt;    &lt;/div&gt;    &lt;p&gt;银行卡余额：{{ money }}元&lt;/p&gt;  &lt;/div&gt;   &lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue({      el: '#app',      data: {        money: 100      },      methods: {        buy (price) {          this.money -= price        }      }    })  &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="v-bind-属性绑定"><a href="#v-bind-属性绑定" class="headerlink" title="v-bind 属性绑定"></a>v-bind 属性绑定</h4><p>**v-bind:**属性名=“表达式”。动态设置html的标签属性 比如：src、url、title</p><ol><li>**v-bind:**可以简写成 =&gt;   <strong>:</strong></li></ol><p>比如，有一个图片，它的 <code>src</code> 属性值，是一个图片地址。这个地址在数据 data 中存储。</p><p>则可以这样设置属性值：</p><ul><li><code>&lt;img v-bind:src="url" /&gt;</code></li><li><code>&lt;img :src="url" /&gt;</code>   （v-bind可以省略）</li></ul><h5 id="v-bind增强"><a href="#v-bind增强" class="headerlink" title="v-bind增强"></a>v-bind增强</h5><p>为了方便开发者进行样式控制， Vue 扩展了 v-bind 的语法，可以针对 <strong>class 类名</strong> 和 <strong>style 行内样式</strong> 进行控制 。</p><p>当class<strong>动态绑定</strong>的是<strong>对象</strong>时，<strong>键就是类名，值就是布尔值</strong>，如果值是<strong>true</strong>，就有这个类，否则没有这个类</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{ 类名1: 布尔值, 类名2: 布尔值 }<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    适用场景：一个类名，来回切换</p><p>当class动态绑定的是<strong>数组</strong>时 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>[ 类名1, 类名2, 类名3 ]<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   使用场景：批量添加或删除类</p><p>操作style</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;div class="box" :style="{ CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 }"&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="v-for-列表渲染"><a href="#v-for-列表渲染" class="headerlink" title="v-for 列表渲染"></a>v-for 列表渲染</h4><p>v-for 基于数据循环，多次渲染整个元素</p><p>v-for 指令需要使用 <code>(item, index) in arr</code> 形式的特殊语法，其中：</p><ul><li>item 是数组中的每一项</li><li>index 是每一项的索引，不需要可以省略</li><li>arr 是被遍历的数组</li></ul><p>此语法也可以遍历<strong>对象和数字</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;ul&gt;  // key作用：给元素添加的唯一标识，便于Vue进行列表项的正确排序复用  &lt;li v-for="(item,index) in booksList" :key="item.id"&gt;     &lt;span&gt;{{ item.name }}&lt;/span&gt;    &lt;span&gt;{{ item.author }}&lt;/span&gt;  &lt;/li&gt;&lt;/ul&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="v-model-双向绑定"><a href="#v-model-双向绑定" class="headerlink" title="v-model 双向绑定"></a>v-model 双向绑定</h4><p>v-model 用于表单元素。所谓双向绑定就是：</p><ol><li>数据改变后，呈现的页面结果会更新</li><li>页面结果更新后，数据也会随之而变</li></ol><p><strong>作用：</strong> 给<strong>表单元素</strong>（input、radio、select）使用，双向绑定数据，可以快速 <strong>获取</strong> 或 <strong>设置</strong> 表单元素内容</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    账户：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    密码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>login<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>重置<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>      <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>        <span class="token literal-property property">password</span><span class="token operator">:</span> <span class="token string">''</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token function">login</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>username<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>password<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">reset</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> <span class="token string">''</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> <span class="token string">''</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="v-model增强"><a href="#v-model增强" class="headerlink" title="v-model增强"></a>v-model增强</h5><p>常见的表单元素都可以用 <code>V-model</code> 绑定关联  →  快速 <strong>获取</strong> 或 <strong>设置</strong> 表单元素的值</p><p>会根据控件类型自动选取正确的方法来更新元素</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;input type="checkbox" v-model="isSingle"&gt; &lt;input v-model="gender" type="radio" name="gender" value="1"&gt;男&lt;input v-model="gender" type="radio" name="gender" value="2"&gt;女&lt;select v-model="cityId"&gt;&lt;option value="101"&gt;北京&lt;/option&gt;&lt;option value="102"&gt;上海&lt;/option&gt;&lt;/select&gt;const app = new Vue({  el: '#app',  data: {    isSingle: false,    gender: "1",    cityId: '101',  }})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指令修饰符"><a href="#指令修饰符" class="headerlink" title="指令修饰符"></a>指令修饰符</h4><p>所谓指令修饰符就是通过“.”指明一些指令<strong>后缀</strong> 不同的<strong>后缀</strong>封装了不同的处理操作  —&gt; 简化代码</p><p><code>@keyup.enter</code> 键盘回车enter键监听</p><p><code>v-model.trim</code> 去除首尾空格</p><p><code>v-model.number</code> 转数字</p><p><code>@click.stop</code> 阻止冒泡</p><h4 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h4><p>基于<strong>现有的数据</strong>，计算出来的<strong>新属性</strong>。 <strong>依赖</strong>的数据变化，<strong>自动</strong>重新计算。</p><ol><li>声明在 <strong>computed 配置项</strong>中，一个计算属性对应一个函数</li><li>使用起来和普通属性一样使用  </li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token function">计算属性名</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>基于现有数据，编写求值逻辑<span class="token keyword">return</span> 结果<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;body&gt;  &lt;div id="app"&gt;    &lt;h3&gt;小黑的礼物清单&lt;/h3&gt;    &lt;table&gt;      &lt;tr&gt;        &lt;th&gt;名字&lt;/th&gt;        &lt;th&gt;数量&lt;/th&gt;      &lt;/tr&gt;      &lt;tr v-for="(item, index) in list" :key="item.id"&gt;        &lt;td&gt;{{ item.name }}&lt;/td&gt;        &lt;td&gt;{{ item.num }}个&lt;/td&gt;      &lt;/tr&gt;    &lt;/table&gt;    &lt;!-- 目标：统计求和，求得礼物总数 --&gt;    &lt;p&gt;礼物总数：{{ totalCount }} 个&lt;/p&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue({      el: '#app',      data: {        // 现有的数据        list: [          { id: 1, name: '篮球', num: 1 },          { id: 2, name: '玩具', num: 2 },          { id: 3, name: '铅笔', num: 5 },        ]      },      computed:{        //注意是属性不是函数        totalCount(){          //0表示求和起始值，reduce遍历list，将每个item的值加上后返回给sum          let total= this.list.reduce((sum, item) =&gt; sum + item.num, 0)          return total        }      }    })  &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>computed计算属性</strong><br>作用：封装了一段对于<strong>数据</strong>的处理，求得一个<strong>结果</strong><br>缓存特性：计算属性会对计算出来的<strong>结果缓存</strong>，再次使用直接读取缓存，依赖项变化了，会<strong>自动</strong>重新计算 -&gt; 并<strong>再次缓存</strong></li><li><strong>methods方法：</strong><br>作用：给实例提供一个<strong>方法</strong>，调用以处理<strong>业务逻辑</strong></li></ul><h4 id="watch侦听器（监视器）"><a href="#watch侦听器（监视器）" class="headerlink" title="watch侦听器（监视器）"></a>watch侦听器（监视器）</h4><p><strong>监视数据变化</strong>，执行一些业务逻辑或异步操作</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>   words<span class="token operator">:</span> <span class="token string">'苹果'</span><span class="token punctuation">,</span>  obj<span class="token operator">:</span> <span class="token punctuation">{</span>    words<span class="token operator">:</span> <span class="token string">'苹果'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 该方法会在数据变化时，触发执行</span>  <span class="token function">数据属性名</span> <span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    一些业务逻辑 或 异步操作。   <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">'对象.属性名'</span> <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    一些业务逻辑 或 异步操作。   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;body&gt;    &lt;div id="app"&gt;        &lt;!-- 条件选择框 --&gt;        &lt;div class="query"&gt;            &lt;span&gt;翻译成的语言：&lt;/span&gt;            &lt;select&gt;                &lt;option value="italy"&gt;意大利&lt;/option&gt;                &lt;option value="english"&gt;英语&lt;/option&gt;                &lt;option value="german"&gt;德语&lt;/option&gt;            &lt;/select&gt;        &lt;/div&gt;        &lt;!-- 翻译框 --&gt;        &lt;div class="box"&gt;            &lt;div class="input-wrap"&gt;                &lt;textarea v-model="obj.words"&gt;&lt;/textarea&gt;                &lt;span&gt;&lt;i&gt;⌨️&lt;/i&gt;文档翻译&lt;/span&gt;            &lt;/div&gt;            &lt;div class="output-wrap"&gt;                &lt;div class="transbox"&gt;{{ result }}&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"&gt;&lt;/script&gt;    &lt;script&gt;        // 接口地址：https://applet-base-api-t.itheima.net/api/translate        // 请求方式：get        // 请求参数：        // （1）words：需要被翻译的文本（必传）        // （2）lang： 需要被翻译成的语言（可选）默认值-意大利        // -----------------------------------------------        const app = new Vue({            el: '#app',            data: {                // words: ''                obj: {                    words: ''                },                result:'',//翻译结果                timer: null            },            // 具体讲解：(1) watch语法 (2) 具体业务实现            watch: {                // 该方法会在数据变化时调用执行                // newValue新值, oldValue老值（一般不用）                // words (newValue) {                //   console.log('变化了', newValue)                // }                'obj.words' (newValue) {                    //console.log('变化了', newValue)                    //防抖：延迟执行 -&gt; 干啥事先等一等，延迟一会，一段时间内没有再次触发，才执行                    clearTimeout(this.timer)                    this.timer = setTimeout(async () =&gt; {                        //这里是ajax的内容                        const res = await axios({                            url: 'https://applet-base-api-t.itheima.net/api/translate',                            params:{                                words:newValue                            }                        })                        this.result = res.data.data                         console.log(res.data.data)                    }, 300)                }            }        })    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整写法<br>添加额外<strong>配置项</strong><br>（1）deep:true 对复杂类型深度监视<br>（2）immediate:true 初始化立刻执行一次handler方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 具体讲解：(1) watch语法 (2) 具体业务实现</span><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token literal-property property">obj</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//深度监视</span>            <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//立刻执行，一进入页面handler立刻执行</span>                <span class="token function">handler</span><span class="token punctuation">(</span> <span class="token parameter">newValue</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//  防抖：延迟执行 -&gt; 干啥事先等一等，延迟一会，一段时间内没有再次触发，才执行</span>                <span class="token function">clearTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer<span class="token punctuation">)</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>                      <span class="token comment">//这里是ajax的内容</span>                    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                        <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'https://applet-base-api-t.itheima.net/api/translate'</span><span class="token punctuation">,</span>                        <span class="token literal-property property">params</span><span class="token operator">:</span>newValue                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data                     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><ol><li>创建阶段：创建响应式数据  发送初始化渲染请求</li><li>挂载阶段：渲染模版   操作dom</li><li>更新阶段：修改数据、更新视图</li><li>销毁阶段：销毁实例</li></ol><img src="/2024/11/18/vue/1682065937815.png?lastModify=1734012561" alt="68206593781" style="zoom:67%;"><p>Vue生命周期过程中，会自动运行一些函数（created&amp;mounted），被称为生命周期钩子，让开发者可以在特定阶段运行<strong>自己的代码</strong></p><img src="/2024/11/18/vue/1682066040295.png?lastModify=1734057859" alt="68206604029" style="zoom:67%;"><h3 id="工程化开发"><a href="#工程化开发" class="headerlink" title="工程化开发"></a>工程化开发</h3><p>vue开发的两种方式：</p><ul><li>核心包传统开发模式：基于html / css / js 文件，直接引入核心包，开发 Vue。</li><li><strong>工程化开发模式：基于构建工具（例如：webpack）的环境中开发Vue。</strong></li></ul><p>Vue CLI 是 Vue 官方提供的一个<strong>全局命令工具</strong>  安装：<code>npm i @vue/cli -g</code><br>可以帮助我们<strong>快速创建</strong>一个开发Vue项目的<strong>标准化基础架子</strong>【集成 webpack 配置】</p><img src="/2024/11/18/vue/1682092148521.png?lastModify=1734058353" alt="68209214852" style="zoom:67%;"><ul><li>组件化：一个页面可以拆分成一个个组件，每个组件有着自己独立的结构、样式、行为<br>好处：便于维护，利于复用，有利于提升开发效率<br>组件分类：普通组件、根组件</li><li>根组件：整个应用最上层的组件，包括所有普通小组件</li></ul><h4 id="App-vue文件"><a href="#App-vue文件" class="headerlink" title="App.vue文件"></a>App.vue文件</h4><ul><li>template：结构（Vue2中有且只能一个元素）</li><li>script：js逻辑</li><li>style:样式（可支持less，需要装包）</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;!-- Vue2中只能有一个根元素 --&gt;&lt;div class="app" @click="fn()"&gt;    我是结构    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default{        methods:{            fn(){                alert("hello")            }        }    }&lt;/script&gt;&lt;style lang="less"&gt;    .app {        width: 400px;        height: 400px;        background-color: pink;    }&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><p><strong>局部注册</strong></p><ul><li>创建.vue文件（三个组成部分：Header,Main,Footer）</li><li>在<strong>使用的组件内</strong>（例如app.vue根组件）导入并注册</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- App.vue文件 --&gt;&lt;script&gt;import HmHeader from './components/HmHeader.vue'import HmMain from './components/HmMain.vue'import HmFooter from './components/HmFooter.vue'export default {  components:{    HmHeader:HmHeader,    HmMain,    HmFooter  }}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>全局注册</strong></p><ul><li>创建.vue文件（三个组成部分）</li><li><strong>main.js中进行全局注册</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//导入需要全局注册的组件</span><span class="token keyword">import</span> HmButton <span class="token keyword">from</span> <span class="token string">'./components/HmButton'</span><span class="token comment">//调用Vue.component进行全局注册</span><span class="token comment">//Vue.component('组件名',组件对象)</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'HmButton'</span><span class="token punctuation">,</span> HmButton<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="组件组成与通信"><a href="#组件组成与通信" class="headerlink" title="组件组成与通信"></a>组件组成与通信</h4><p>写在组件中的样式会 <strong>全局生效</strong> →  因此很容易造成多个组件之间的样式冲突问题。</p><ol><li><p><strong>全局样式</strong>: 默认组件中的样式会作用到全局，任何一个组件中都会受到此样式的影响</p></li><li><p><strong>局部样式</strong>: 可以给组件加上<strong>scoped</strong> 属性,可以<strong>让样式只作用于当前组件</strong></p></li></ol><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;style lang="less" scoped&gt;.el-menu-vertical-demo:not(.el-menu--collapse) {  width: 200px;  min-height: 400px;}.el-menu {  height: 100%;  border: none;  h4 {    color: #fff;    text-align: center;    line-height: 10px;  }}.router-link-active {  text-decoration: none;  color: #fff;  font-style: normal;}i {  text-decoration: none;  color: white;  font-style: normal;}&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个组件的 <strong>data</strong> 选项必须<strong>是一个函数</strong>。目的是为了：保证每个组件实例，维护<strong>独立</strong>的一份<strong>数据</strong>对象。</p><p>每次创建新的组件实例，都会新<strong>执行一次data 函数</strong>，得到一个新对象。</p><p><strong>组件通信</strong></p><p>组件通信，就是指<strong>组件与组件</strong>之间的<strong>数据传递</strong></p><ul><li>组件的数据是独立的，无法直接访问其他组件的数据。</li><li>想使用其他组件的数据，就需要组件通信</li></ul><p>两种组件关系分类 和 对应的组件通信方案</p><ul><li>父子关系 → props &amp; $emit<ul><li>props：组件上 注册的一些  自定义属性，用于父组件向子组件传递数据</li><li>可以 传递 <strong>任意数量/任意类型</strong> 的prop</li></ul></li><li>非父子关系 → provide &amp; inject 或 eventbys</li><li>通用方案 → vuex</li></ul><h5 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h5><p>父-&gt;子</p><img src="/2024/11/18/vue/1682318711785.png?lastModify=1734060490" alt="68231871178" style="zoom: 50%;"><p>子-&gt;父</p><img src="/2024/11/18/vue/1682318965635.png?lastModify=1734060558" alt="68231896563" style="zoom: 50%;"><h5 id="props校验"><a href="#props校验" class="headerlink" title="props校验"></a>props校验</h5><p> 为prop指定验证要求，不符合要求，控制台就会有错误提示→帮助开发者，快速发现错误</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>  校验的属性名<span class="token operator">:</span> <span class="token punctuation">{</span>    type<span class="token operator">:</span> 类型<span class="token punctuation">,</span>  <span class="token comment">// Number String Boolean ...</span>    required<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 是否必填</span>    <span class="token keyword">default</span><span class="token operator">:</span> 默认值<span class="token punctuation">,</span> <span class="token comment">// 默认值</span>    <span class="token function">validator</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 自定义校验逻辑</span>      <span class="token keyword">return</span> 是否通过校验    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token comment">// 完整写法（类型、默认值、非空、自定义校验）</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token literal-property property">w</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token literal-property property">type</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>      <span class="token comment">//required: true,</span>      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token function">validator</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// console.log(val)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&gt;=</span> <span class="token number">100</span> <span class="token operator">||</span> val <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'传入的范围必须是0-100之间'</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="props-data"><a href="#props-data" class="headerlink" title="props&amp;data"></a>props&amp;data</h5><p>共同点：都可以给组件提供数据<br>区别：</p><ul><li>data的数据是<strong>自己的</strong> → 随便改</li><li>props的数据是<strong>外部的</strong> → 不能直接改，要遵循单向数据流<br><strong>单向数据流</strong>：父级prop的数据更新，会向下流动，影响子组件。这个数据流动是单向的。</li></ul><h5 id="非父子通信"><a href="#非父子通信" class="headerlink" title="非父子通信"></a>非父子通信</h5><h5 id="event-bus-事件总线"><a href="#event-bus-事件总线" class="headerlink" title="event bus 事件总线"></a>event bus 事件总线</h5><ol><li><p>创建一个都能访问的事件总线 （空Vue实例）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">const</span> Bus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> Bus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>A组件（接受方），监听Bus的 $on事件</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">created () {&nbsp; Bus.$on('sendMsg', (msg) =&gt; {&nbsp; &nbsp; this.msg = msg&nbsp; })}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>B组件（发送方），触发Bus的$emit事件</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">Bus.$emit('sendMsg', '这是一个消息')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h5 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide&amp;inject"></a>provide&amp;inject</h5><p>跨层级数据共享</p><ol><li>父组件 provide提供数据</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">provide</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>       <span class="token comment">// 普通类型【非响应式】</span>       <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">,</span>        <span class="token comment">// 复杂类型【响应式】</span>       <span class="token literal-property property">userInfo</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userInfo<span class="token punctuation">,</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.子/孙组件 inject获取数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  inject<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'color'</span><span class="token punctuation">,</span><span class="token string">'userInfo'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userInfo<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>provide提供的简单类型的数据不是响应式的，复杂类型数据是响应式。（推荐提供复杂类型数据）</li><li>子/孙组件通过inject获取的数据，不能在自身组件内修改</li></ul><h4 id="组件双向绑定"><a href="#组件双向绑定" class="headerlink" title="组件双向绑定"></a>组件双向绑定</h4><p>表单类组件封装 → 实现子组件和父组件数据的双向绑定<br>①父传子：数据应该是父组件props传递过来的，v-model拆解绑定数据<br>②子传父：监听输入，子传父传值给父组件修改<br>本质：<strong>实现了子组件和父组件数据的双向绑定</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!--1.父组件给子组件传递属性cityId        4.父组件监听到'事件名'，更新selectID--&gt;&lt;BaseSelect :cityId="selectId" @事件名="selectId = $event"&gt;&lt;/BaseSelect&gt;&lt;!--3.子组件BaseSelect.vue触发事件handlechange--&gt;&lt;select :value="cityId" @change="handleChange"&gt;...&lt;/select&gt;&lt;script&gt;    // 2.子组件props接收父组件传值    props: {        cityId:String      },    methods: {      // 对应3.触发事件handlechange，给父组件发送消息通知      handleChange (e) {        this.$emit('事件名', e.target.value)       }     }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="v-model简化双向绑定"><a href="#v-model简化双向绑定" class="headerlink" title="v-model简化双向绑定"></a>v-model简化双向绑定</h5><p>父组件v-model简化代码，实现子组件和父组件数据双向绑定<br>①子组件中：props通过value接受，事件触发input<br>②父组件中：v-model给组件直接绑数据</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!--父组件--&gt;&lt;BaseSelect v-model="selectId"&gt;&lt;/BaseSelect&gt;&lt;!--子组件--&gt;&lt;select :value="value" @change="handleChange"&gt;...&lt;/select&gt;&lt;script&gt;    //子组件    props: {        value:String    },        methods: {            handleChange (e) {                this.$emit('input', e.target.value)            }        }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h5><p>作用：可以实现子组件和父组件数据的双向绑定，简化代码<br>特点：prop属性名，可以自定义，非固定为value<br>场景：<strong>封装弹框类的基础组件</strong>，visible属性 true显示 false隐藏<br>本质：就是 :属性名 和 @update:属性名 合写</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!--父组件--&gt;&lt;BaseDialog :visible.sync="isShow"&gt;&lt;/BaseDialog&gt;&lt;script&gt;    //子组件    props:{        visible:Boolean      },      methods:{         // 关闭弹窗，触发父组件属性隐藏        close () {          this.$emit('update:visible', false)        }      }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ref-和-refs"><a href="#ref-和-refs" class="headerlink" title="ref 和 $refs"></a>ref 和 $refs</h5><p>作用：利用 ref 和 $refs 可以用于 获取 dom 元素，或 组件实例<br>特点：查找范围 → 当前组件内（更精确稳定）<br>① 获取dom：</p><p>目标标签 - 添加 ref 属性</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>chartRef<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>我是渲染图标的容器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取时，通过 this.$refs.xxx,获取目标标签</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;    mounted() {        console.log(this.$refs.chartRef)    },&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：之前只用document.querySelect(‘.box’) 获取的是整个页面中的盒子</p><h5 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h5><ol><li>Vue是异步更新DOM的</li><li>想要在DOM更新完成之后做某件事，可以使用$nextTick</li></ol><p><strong>语法:</strong> this.$nextTick(函数体)</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>inp<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>$nextTick 内的函数体 一定是<strong>箭头函数</strong>，这样才能让函数内部的this指向Vue实例</p><h3 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h3><p>单页应用程序：SPA【Single Page Application】是指所有的功能都在<strong>一个html页面</strong>上实现</p><p>单页应用网站： 网易云音乐  <a href="https://music.163.com/">https://music.163.com/</a></p><p>多页应用网站：京东  <a href="https://jd.com/">https://jd.com/</a></p><img src="/2024/11/18/vue/1682441912977.png" alt="68244191297" style="zoom:67%;"><p>单页应用类网站：系统类网站 / 内部网站 / 文档类网站 / 移动端站点</p><p>多页应用类网站：公司官网 / 电商类网站 </p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>单页面应用程序，之所以开发效率高，性能好，用户体验好</p><p>最大的原因就是：<strong>页面按需更新</strong>。比如当点击【发现音乐】和【关注】时，<strong>只是更新下面部分内容</strong>，对于头部是不更新的</p><img src="/2024/11/18/vue/1682442699775.png?lastModify=1734415679" alt="68244269977" style="zoom: 80%;"><p>Vue中的路由：<strong>路径和组件</strong>的<strong>映射</strong>关系</p><ol><li><p>下载 VueRouter 模块到当前工程，版本3.6.5</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">yarn</span> <span class="token function">add</span> vue-router@3.6.5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>main.js中引入VueRouter</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">import VueRouter from 'vue-router'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装注册</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">Vue.use(VueRouter)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建路由对象</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">const router = new VueRouter({routes:[...]})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>注入，将路由对象注入到new Vue实例中，建立关联</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">new Vue({&nbsp; render: h =&gt; h(App),&nbsp; router:router}).$mount('#app')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>当我们配置完以上5步之后 就可以看到浏览器地址栏中的路由 变成了 /#/的形式。表示项目的路由已经被Vue-Router管理了</p><img src="/2024/11/18/vue/1682479207453-1734415794558.png" alt="68247920745" style="zoom:67%;"><p>配置导航，配置路由出口(路径匹配的组件显示的位置)</p><p>App.vue</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;div class="footer_wrap"&gt;&nbsp; &lt;a href="#/find"&gt;发现音乐&lt;/a&gt;&nbsp; &lt;a href="#/my"&gt;我的音乐&lt;/a&gt;&nbsp; &lt;a href="#/friend"&gt;朋友&lt;/a&gt;&lt;/div&gt;&lt;div class="top"&gt;&nbsp; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h2><p>经典（以此为准）：<a href="https://github.com/PanJiaChen/vue-element-admin">PanJiaChen/vue-element-admin: <span class="github-emoji"><span>🎉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> A magical vue admin https://panjiachen.github.io/vue-element-admin</a></p><p>文档：<a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/#%E5%8A%9F%E8%83%BD">介绍 | vue-element-admin</a></p><p>新：<a href="https://github.com/vbenjs/vue-vben-admin">vbenjs/vue-vben-admin: A modern vue admin panel built with Vue3, Shadcn UI, Vite, TypeScript, and Monorepo. It’s fast!</a></p><p>文档：<a href="https://doc.vben.pro/guide/introduction/vben.html#%E9%A1%B5%E9%9D%A2%E5%8E%86%E5%8F%B2">关于 Vben Admin | Vben Admin</a></p><h3 id="启动解析"><a href="#启动解析" class="headerlink" title="启动解析"></a>启动解析</h3><h4 id="1-main-js入口"><a href="#1-main-js入口" class="headerlink" title="1.main.js入口"></a>1.main.js入口</h4><p>示例结构：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>        <span class="token comment">// 引入 Vue</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token punctuation">;</span>   <span class="token comment">// 引入根组件</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token punctuation">;</span> <span class="token comment">// 引入路由（如果有）</span>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 禁用生产模式下的提示</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>   <span class="token comment">// 将 Vue 实例挂载到 id 为 'app' 的 DOM 元素上</span>  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 渲染根组件 App</span>  router<span class="token punctuation">,</span>               <span class="token comment">// 路由配置（如果有）</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-App-vue"><a href="#2-App-vue" class="headerlink" title="2.App.vue"></a>2.App.vue</h4><p>在 Vue 项目中，<code>App.vue</code> 是根组件。它通过 <code>&lt;router-view /&gt;</code> 渲染页面内容。</p><blockquote><p>Vue Router 是 Vue 官方的客户端路由解决方案。</p><p>客户端路由的作用是在单页应用 (SPA) 中将浏览器的 URL 和用户看到的内容绑定起来。当用户在应用中浏览不同页面时，URL 会随之更新，但页面不需要从服务器重新加载。</p><p>Vue Router 基于 Vue 的组件系统构建，你可以通过配置<strong>路由</strong>来告诉 Vue Router <strong>为每个 URL 路径显示哪些组件</strong>。</p></blockquote><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div id="app"&gt;    &lt;router-view /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: 'App'}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-router"><a href="#3-router" class="headerlink" title="3.router"></a>3.router</h4><p>Vue Router 管理应用中的路由和页面导航。路由配置文件<code>router/index.js</code>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'@/views/Home.vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">'@/views/About.vue'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Router<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Home'</span><span class="token punctuation">,</span>      <span class="token literal-property property">component</span><span class="token operator">:</span> Home    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/about'</span><span class="token punctuation">,</span>      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'About'</span><span class="token punctuation">,</span>      <span class="token literal-property property">component</span><span class="token operator">:</span> About    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实际页面内容的渲染</strong></p><ol><li><strong>加载根组件（<code>App.vue</code>）</strong>：<ul><li>当 Vue 应用启动时，<code>App.vue</code> 会被加载并渲染，其中包含了 <code>&lt;router-view /&gt;</code>。</li></ul></li><li><strong>匹配路由</strong>：<ul><li>根据 URL 路径，Vue Router 会匹配到相应的路由。</li><li>比如，当用户访问 <code>http://localhost:8080/</code> 时，Vue Router 会匹配到 <code>/</code> 路径，并加载 <code>Home.vue</code> 组件。</li></ul></li><li><strong>渲染对应的组件</strong>：<ul><li>Vue Router 会将匹配到的组件（例如 <code>Home.vue</code> 或 <code>About.vue</code>）插入到 <code>App.vue</code> 中的 <code>&lt;router-view /&gt;</code> 部分。</li><li>最终，用户在页面上看到的就是 <code>Home.vue</code> 或 <code>About.vue</code> 组件的内容。</li></ul></li></ol><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><p>页面整体布局是一个产品最外层的框架结构，往往会包含导航、侧边栏、面包屑以及内容等。 </p><p><strong>vue-router 路由嵌套</strong>：Vue Router 的路由嵌套机制允许在一个路由组件中嵌套显示另一个路由组件。通常在布局（如 <code>Layout</code>）中，使用嵌套路由来组织子页面或功能模块。这种嵌套机制通过 <code>&lt;router-view /&gt;</code> 占位符来渲染子路由组件。</p><p> <strong>一般情况下，你增加或者修改页面只会影响 <code>app-main</code>这个主体区域。其它配置在 <code>layout</code> 中的内容如：侧边栏或者导航栏都是不会随着你主体页面变化而变化的。</strong></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">/foo                                  /bar+------------------+                  +-----------------+| layout           |                  | layout          || +--------------+ |                  | +-------------+ || | foo.vue      | |  +------------&gt;  | | bar.vue     | || |              | |                  | |             | || +--------------+ |                  | +-------------+ |+------------------+                  +-----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然你也可以一个项目里面使用多个不同的 <code>layout</code>，只要在你想作用的路由父级上引用它就可以了。</p><p><strong>父路由和子路由</strong>：</p><ul><li><strong>父路由</strong>：是定义在路由配置中，包含子路由的路由。通常，父路由配置会有一个 <code>&lt;router-view /&gt;</code> 占位符，用于渲染子路由。</li><li><strong>子路由</strong>：是嵌套在父路由下的路由，子路由通过 <code>children</code> 属性来定义。</li></ul><p><strong>路由渲染顺序</strong>：</p><ul><li><p>当用户访问某个路径时，Vue Router 会根据路径匹配到父路由，再匹配到子路由。</p></li><li><p>父路由组件渲染时，会渲染一个 <code>&lt;router-view /&gt;</code> 作为占位符，子路由组件会被插入到这个占位符中。</p></li></ul><p><strong>1. 路由配置 (<code>router/index.js</code>)</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">javascript复制代码<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Layout <span class="token keyword">from</span> <span class="token string">'@/layouts/Layout'</span><span class="token punctuation">;</span>    <span class="token comment">// 引入 Layout 布局组件</span><span class="token keyword">import</span> Dashboard <span class="token keyword">from</span> <span class="token string">'@/views/dashboard/index'</span><span class="token punctuation">;</span>  <span class="token comment">// 引入 Dashboard 子页面</span><span class="token keyword">import</span> Profile <span class="token keyword">from</span> <span class="token string">'@/views/profile/index'</span><span class="token punctuation">;</span>      <span class="token comment">// 引入 Profile 子页面</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Router<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>      <span class="token literal-property property">component</span><span class="token operator">:</span> Layout<span class="token punctuation">,</span>  <span class="token comment">// 父路由使用 Layout 布局组件</span>      <span class="token literal-property property">redirect</span><span class="token operator">:</span> <span class="token string">'/dashboard'</span><span class="token punctuation">,</span>  <span class="token comment">// 默认重定向到 /dashboard</span>      <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'dashboard'</span><span class="token punctuation">,</span>  <span class="token comment">// 子路由的路径为 'dashboard'</span>          <span class="token literal-property property">component</span><span class="token operator">:</span> Dashboard<span class="token punctuation">,</span>  <span class="token comment">// 子路由渲染 Dashboard 组件</span>          <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Dashboard'</span><span class="token punctuation">,</span>  <span class="token comment">// 子路由的名称</span>          <span class="token literal-property property">meta</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'Dashboard'</span><span class="token punctuation">,</span> <span class="token literal-property property">icon</span><span class="token operator">:</span> <span class="token string">'dashboard'</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>          <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'profile'</span><span class="token punctuation">,</span>  <span class="token comment">// 另一个子路由的路径为 'profile'</span>          <span class="token literal-property property">component</span><span class="token operator">:</span> Profile<span class="token punctuation">,</span>  <span class="token comment">// 子路由渲染 Profile 组件</span>          <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Profile'</span><span class="token punctuation">,</span>          <span class="token literal-property property">meta</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'Profile'</span><span class="token punctuation">,</span> <span class="token literal-property property">icon</span><span class="token operator">:</span> <span class="token string">'user'</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 父路由布局组件 (<code>Layout.vue</code>)</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">vue复制代码&lt;template&gt;  &lt;div class="layout"&gt;    &lt;!-- 侧边栏组件 --&gt;    &lt;Sidebar /&gt;    &lt;!-- 主体内容区域 --&gt;    &lt;div class="main-content"&gt;      &lt;!-- 导航栏组件 --&gt;      &lt;Navbar /&gt;      &lt;!-- 子路由渲染区 --&gt;      &lt;router-view /&gt;  &lt;!-- 这个 &lt;router-view /&gt; 会渲染子路由组件 (如 Dashboard 或 Profile) --&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Sidebar from '@/components/Sidebar';import Navbar from '@/components/Navbar';export default {  name: 'Layout',  components: {    Sidebar,    Navbar  }}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 子路由组件 (<code>Dashboard.vue</code> 和 <code>Profile.vue</code>)</strong></p><p><strong>Dashboard.vue</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">vue复制代码&lt;template&gt;  &lt;div class="dashboard"&gt;    &lt;h1&gt;Dashboard&lt;/h1&gt;    &lt;p&gt;欢迎来到 Dashboard 页面&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: 'Dashboard'}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Profile.vue</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">vue复制代码&lt;template&gt;  &lt;div class="profile"&gt;    &lt;h1&gt;Profile&lt;/h1&gt;    &lt;p&gt;这是用户的个人资料页面&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: 'Profile'}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="实际layout代码"><a href="#实际layout代码" class="headerlink" title="实际layout代码"></a>实际layout代码</h5><p><a href="https://github.com/PanJiaChen/vue-element-admin/tree/master/src/layout">@/layout</a>  layout下index.vue</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div :class="classObj" class="app-wrapper"&gt;    &lt;div v-if="device==='mobile'&amp;&amp;sidebar.opened" class="drawer-bg" @click="handleClickOutside" /&gt;    &lt;sidebar class="sidebar-container" /&gt;    &lt;div :class="{hasTagsView:needTagsView}" class="main-container"&gt;      &lt;div :class="{'fixed-header':fixedHeader}"&gt;        &lt;navbar /&gt;        &lt;tags-view v-if="needTagsView" /&gt;      &lt;/div&gt;      &lt;!-- 子组件app-main里面定义了子路由router-view  -- 子路由渲染区 --&gt;      &lt;app-main /&gt;      &lt;right-panel v-if="showSettings"&gt;        &lt;settings /&gt;      &lt;/right-panel&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import RightPanel from '@/components/RightPanel'import { AppMain, Navbar, Settings, Sidebar, TagsView } from './components'import ResizeMixin from './mixin/ResizeHandler'import { mapState } from 'vuex'export default {  name: 'Layout',  // 引入并注册子组件，作为layout的一部分进行渲染  components: {    AppMain,    Navbar,    RightPanel,    Settings,    Sidebar,    TagsView  },  // 使用的 mixins，提供了组件间复用的功能  mixins: [ResizeMixin],  // 计算属性  computed: {    // 使用 mapState 辅助函数映射 Vuex store 中的状态到当前组件的计算属性    ...mapState({      // 获取 Vuex store 中的 sidebar 状态，表示侧边栏的开关      sidebar: state =&gt; state.app.sidebar,      device: state =&gt; state.app.device,      showSettings: state =&gt; state.settings.showSettings,      needTagsView: state =&gt; state.settings.tagsView,      fixedHeader: state =&gt; state.settings.fixedHeader    }),    // 计算类名对象，返回一个动态的 class 对象    classObj() {      return {        // 根据 sidebar 的状态动态切换类名        hideSidebar: !this.sidebar.opened, // 侧边栏关闭时，应用 'hideSidebar' 类        openSidebar: this.sidebar.opened, // 侧边栏打开时，应用 'openSidebar' 类        withoutAnimation: this.sidebar.withoutAnimation, // 判断是否禁用动画        mobile: this.device === 'mobile'      }    }  },  methods: {    // 处理点击外部区域的事件，用来关闭侧边栏    handleClickOutside() {      // 使用 Vuex 的 action 来关闭侧边栏      this.$store.dispatch('app/closeSideBar', { withoutAnimation: false })    }  }}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>**<code>&lt;router-view /&gt;</code>**：<code>Layout</code> 组件本身并不直接渲染内容，而是作为页面的框架，提供固定的布局部分（如侧边栏、导航栏等）。它通过 <code>&lt;router-view /&gt;</code> 来渲染子路由的内容。此处没有直接放置 <code>&lt;router-view /&gt;</code>，而是放置了 <code>AppMain</code> 组件，<code>AppMain</code> 组件会在其中继续嵌套一个 <code>&lt;router-view /&gt;</code>，从而实现多层嵌套。</p></li><li><p><strong><code>AppMain</code> 组件</strong>：<code>Layout</code> 渲染了 <code>AppMain</code> 组件，<code>AppMain</code> 内部还通过 <code>&lt;router-view /&gt;</code> 渲染子路由内容（例如 <code>Dashboard</code> 或 <code>Profile</code>）。</p></li></ul><h4 id="app-main"><a href="#app-main" class="headerlink" title="app-main"></a>app-main</h4><p><a href="https://github.com/PanJiaChen/vue-element-admin/blob/master/src/layout/components/AppMain.vue">@/layout/components/AppMain</a></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;!-- 主内容区域 --&gt;  &lt;section class="app-main"&gt;    &lt;!-- 过渡动画：fade-transform --&gt;    &lt;transition name="fade-transform" mode="out-in"&gt;      &lt;!-- keep-alive 用于缓存视图，以避免重新加载组件 --&gt;      &lt;keep-alive :include="cachedViews"&gt;        &lt;!-- 渲染路由的子组件，key 用于控制视图的缓存和刷新 --&gt;        &lt;router-view :key="key" /&gt;      &lt;/keep-alive&gt;    &lt;/transition&gt;  &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default {  name: 'AppMain',  computed: {    // 计算属性：获取要缓存的视图列表    cachedViews() {      // 从 Vuex 存储中获取缓存视图的列表      return this.$store.state.tagsView.cachedViews    },    // 计算属性：返回当前路由的路径    key() {      // 使用当前路由的路径作为唯一的 key 来控制视图缓存和刷新      return this.$route.path    }  }}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>transition</code>：使用 Vue 的过渡系统，为路由切换添加过渡动画。</p></li><li><p><code>&lt;keep-alive&gt;</code>标签：Vue 的内置组件，用于缓存页面组件，以避免频繁的销毁和重新创建。</p><ul><li><code>:include="cachedViews"</code>：指定要缓存的组件列表。<code>cachedViews</code> 是一个计算属性，从 Vuex 获取已缓存的视图。</li><li>这样配置后，只有在 <code>cachedViews</code> 中列出的视图才会被缓存，从而提升性能，避免频繁地销毁和创建页面组件。</li></ul></li><li><p><code>key</code>计算属性：返回当前路由的路径。</p><ul><li>这个 <code>key</code> 属性用于在每次路由切换时更新 <code>&lt;router-view&gt;</code>，确保组件在路由变化时重新渲染。</li><li>通过使用路由的 <code>path</code> 作为 <code>key</code>，可以让 Vue 在切换路由时正确地处理组件的缓存与更新。</li></ul></li></ul><h3 id="Vuex-store"><a href="#Vuex-store" class="headerlink" title="Vuex store"></a>Vuex store</h3><p><strong>Vuex store</strong> 是 Vue.js 官方提供的一个状态管理库，用于管理应用中的<strong>共享状态</strong>。在 Vue.js 中，状态通常指的是数据（如<strong>用户信息、产品列表、界面设置</strong>等），而这些状态需要在应用的多个组件之间共享和管理。Vuex 通过<strong>集中式的存储和管理这些状态</strong>，使得不同组件之间的数据流变得更加清晰和可维护。</p><p>Vuex store 中的状态是<strong>响应式</strong>的，任何使用到这些状态的组件都会在<strong>状态变化时自动更新</strong>。</p><p>Vuex store 基于以下几个核心概念：</p><ul><li><strong>State（状态）</strong>：用于存储应用的共享数据，Vuex 中的状态就类似于一个全局的数据源。</li><li><strong>Getters（获取器）</strong>：类似于计算属性（computed），用于从 Vuex store 中派生出数据。Getters 用来获取或过滤状态中的数据。</li><li><strong>Mutations（突变）</strong>：用来同步修改 Vuex store 中的状态。所有对状态的改变必须通过 mutation 来进行。</li><li><strong>Actions（动作）</strong>：用于处理异步操作和业务逻辑，它们会提交 mutations 来改变状态。</li><li><strong>Modules（模块）</strong>：Vuex 支持将 store 分割成多个模块，每个模块拥有自己的 state、mutations、actions 和 getters，以便组织大型应用的状态。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// store.js</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token punctuation">;</span><span class="token comment">// 安装 Vuex 插件</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment">// 状态 (store 中的数据)</span>  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 获取器 (计算属性，派生数据)</span>  <span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function-variable function">counterDouble</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>counter <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token function-variable function">userName</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>user <span class="token operator">?</span> state<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name <span class="token operator">:</span> <span class="token string">'Guest'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 突变 (同步修改状态)</span>  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">setUser</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>user <span class="token operator">=</span> user<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 动作 (可以进行异步操作)</span>  <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function">fetchUser</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 模拟异步获取用户数据</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'John Doe'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'setUser'</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 提交 mutation</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 模块 (支持模块化管理状态)</span>  <span class="token literal-property property">modules</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token comment">// 可以定义多个子模块来管理不同的 state</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> store<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置store：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./store'</span><span class="token punctuation">;</span>  <span class="token comment">// 引入 Vuex store</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>  store<span class="token punctuation">,</span>  <span class="token comment">// 将 Vuex store 注入到 Vue 实例</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>w3school：<a href="https://www.w3school.com.cn/html/index.asp">HTML 教程</a></p><p><a href="https://blog.csdn.net/qq_58667485/article/details/133761371">前端三件套复习笔记_js前端三件套-CSDN博客</a></p><p><a href="https://blog.csdn.net/kiddkid/article/details/136520569">前端三件套简要笔记_后端转前端 html js css怎么学习-CSDN博客</a></p><p><a href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程</a></p><p>vue：<a href="https://www.bilibili.com/video/BV1HV4y1a7n4/?spm_id_from=333.1007.top_right_bar_window_history.content.click">https://www.bilibili.com/video/BV1HV4y1a7n4/?spm_id_from=333.1007.top_right_bar_window_history.content.click</a></p><p><a href="https://blog.csdn.net/qq_55666248/article/details/143028853">黑马Vue2+Vue3笔记_vue学习笔记黑马-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_70675152/article/details/135439211?spm=1001.2014.3001.5502">VUE学习笔记（黑马2023版 第四天）_vue 黑马2023版 源码-CSDN博客</a></p><p><a href="https://github.com/PanJiaChen/vue-element-admin">PanJiaChen/vue-element-admin: <span class="github-emoji"><span>🎉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> A magical vue admin https://panjiachen.github.io/vue-element-admin</a></p><p><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/#%E5%8A%9F%E8%83%BD">介绍 | vue-element-admin</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h1&gt;&lt;h2 id=&quot;前端&quot;&gt;&lt;a href=&quot;#前端&quot; class=&quot;headerlink&quot; title=&quot;前端&quot;&gt;&lt;/a&gt;前端&lt;/h2&gt;&lt;u</summary>
      
    
    
    
    <category term="前端" scheme="http://wolf-ll.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="框架" scheme="http://wolf-ll.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="前端" scheme="http://wolf-ll.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>MVBench</title>
    <link href="http://wolf-ll.github.io/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/"/>
    <id>http://wolf-ll.github.io/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/</id>
    <published>2024-11-12T03:26:44.000Z</published>
    <updated>2025-01-07T12:59:43.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVBench-A-Comprehensive-Multi-modal-Video-Understanding-Benchmark"><a href="#MVBench-A-Comprehensive-Multi-modal-Video-Understanding-Benchmark" class="headerlink" title="MVBench: A Comprehensive Multi-modal Video Understanding Benchmark"></a>MVBench: A Comprehensive Multi-modal Video Understanding Benchmark</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>论文介绍了MVBench，这是一个全新的多模态视频理解基准测试，旨在评估多模态大型语言模型（MLLMs）在视频理解方面的能力。</p><ul><li>目前许多基准测试主要集中在<strong>静态图像任务的空间理解</strong>上，而<strong>忽视了动态视频任务中的时间理解</strong>。MVBench通过20个具有挑战性的<strong>视频任务</strong>来填补这一空白，这些任务无法通过单帧图像有效解决。</li><li>论文提出了一种新颖的<strong>静态到动态方法</strong>来定义与时间相关的任务，并将各种静态任务转化为动态任务，从而系统地生成各种视频任务，无需人工参与。</li><li>通过任务定义，研究者们自动<strong>将视频注释转换为多项选择的问答（QA）</strong>，以评估每个任务。</li><li>MVBench的构建高效且公平，避免了对LLMs的评分偏见。论文开发了一个强大的视频MLLM基线VideoChat2，并通过多样化的指令调整数据进行逐步多模态训练。</li><li>在MVBench上表明，现有的MLLMs在时间理解方面远未达到令人满意的水平，而VideoChat2在MVBench上的准确率超过了这些领先模型15%以上。</li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>多模态大模型（MLLM）通过在各种预先训练的LLM中嵌入视觉编码器，推动了视觉-语言学习任务的发展。一个很自然的问题是如何评估这些模型的视觉理解能力，<strong>这种评估对于确认其设计有效性和进一步改进它们以更广泛地理解开放世界的多种模态至关重要。</strong></p><p>为了满足这一需求，一些基准测试已经被提出。其主要方法是在各种感知任务上构造QA式以评估MLLM性能。然而，这些基准主要集中在基于图像的理解上，所有的问题都是为静态图像的空间感知设计的（如图一spatial understanding所示）。<strong>因此他们难以评估动态视频中的时间演化，而这对于现实世界中的程式化活动的理解是十分重要的。</strong></p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241113183819734.png" alt="image-20241113183819734" style="zoom: 80%;"><p>尽管最近已经有一些基准来评估视频中的时间感知任务，但它们要么只聚焦于非常基本的视频任务（如SEED-Bench中的行为识别和预测），要么聚焦特定领域（如FunQA）或受限的场景（如Perception Test中的室内场景）。因此，利用这些基准来对mllm的时间理解技能进行全面的评估是有限的。此外，它们通过劳动密集型标注收集，导致昂贵的人工成本。为了解决这些问题，<strong>本文提出了一个多模态视频理解基准（MVBench），它旨在全面评估开放世界中mllm的时间感知能力。</strong>与上面现有的基准相比，MVBench有两种不同的设计：</p><ol><li><p><strong>引入了从静态到动态的方法（a novel static-to-dynamic method）：</strong></p><p>为静态图像任务增加动态演化的时间上下文，得到了20个视频理解任务，这些任务需要对视频的时间维度有深入理解，涵盖了从感知到认知的广泛的时间理解技能。具体来说，作者在之前的多模态基准测试中使用静态图像任务作为定义参考。然后，<strong>用视频中的时间上下文来扩大这些静态任务的问题</strong>，例如，图像中的位置任务可以灵活地转换为视频中的移动方向任务(“男人在舞台上吗？”→“这个人的方向是什么？”)</p></li><li><p><strong>引入自动标注范式，实现自动问答生成（Automatic QA Generation）：</strong></p><p>利用现有的视频基准测试和大型语言模型(LLMs)，<strong>自动将视频注释转换为多项选择的问答对</strong>，用于评估MLLMs的性能。<br>选择了11个公共视频基准测试，并根据任务定义自动生成问题和答案选项。大大降低人工标注成本，涵盖了各种复杂的领域和不同的场景，从第一人称到第三人称的视角，以及从室内到室外的环境。这些基准为MVBench提供了基本事实，保证了评估的公平性和准确性，避免了LLM的有偏评分。</p></li></ol><p>最后，在MVBench上对多个著名的MLLM进行全面评估，结果表明这些图像和视频MLLM在各项任务上还远不能让人满意。因此，作者还开发了一个视频MLLM基线模型，即VideoChat2。该模型桥接了大模型和一个强大的视频基础模型。随后，<strong>引入了一个具有广泛的多模态指令的渐进式训练范式，允许视频和语言之间的有效对齐。</strong>评估表明，VideoChat2在MVBench上显著领先表现最好的VideoChat15%，并且在视频对话和零样本QA基准上（video conversation and zero-shot QA benchmarks）取得了最先进的结果。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="MLLM"><a href="#MLLM" class="headerlink" title="MLLM"></a>MLLM</h3><ul><li>多模态LLM（MLLM）旨在增强多种模式的理解和生成能力。开创性模型如Flamingo和PaLM-E无缝地融合了文本和视觉，在一系列多模态任务中展现出优越性。</li><li>近期开源的LLM进一步加速了公共MLLM的出现。LLaVA，MiniGPT-4，InstructBLIP提出了一系列视觉指令微调数据。</li><li>除了文本和静态图像，一些研究开始挖掘LLM在视频模态中的潜力。VideoChat，VideoChat-GPT和Valley利用LLM生成视频指令微调数据以增强指令遵循能力。</li><li>VideoChat2检验MLLM的基本的时间理解能力，为更优的MLLM提供有价值的设计理念。</li></ul><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><ul><li><p>传统的视觉语言（VL）benchmark集中在多模态检索和视觉QA。MLLM的发展催化了评估集成视觉语言任务的benchmark。</p></li><li><p>LVLM-eHub通过与图像相关的查询提供了一个交互式的模型比较平台。其他基准如OwlEval [94], MME [17], SEED-Bench [37],</p><p>MM-Vet [97], and MMBench 强调全面的VL能力，引入仅超越模型结构的评估指标。</p></li><li><p>视频领域有Perception Test，测试了<strong>多模态视频感知和推理</strong>；VideoChatGPT量化了<strong>从视频输入中生成对话的能力</strong>；FunQA通过反直觉和幽默的内容来限制视频推理。</p></li><li><p>与现有的视频基准相比，MVBench涵盖了广泛的时间任务，强调了<strong>对时间敏感的视频和</strong>对<strong>公共注释的有效使用</strong>，并对mllm的时间理解进行了全面的评估。</p></li></ul><h2 id="MVBench"><a href="#MVBench" class="headerlink" title="MVBench"></a>MVBench</h2><h3 id="时间任务定义"><a href="#时间任务定义" class="headerlink" title="时间任务定义"></a>时间任务定义</h3><p>静态到动态方法，使静态任务适应动态目标。使用静态图像的空间理解任务作为系统地设计从感知到认知的时间任务的参考。从图像benchmark里总结了上述9项空间理解任务，再思考延伸出20项时间理解任务如下：</p><ul><li><p><strong>Action.</strong> (1) <em>Action Sequence:</em> 检索在特定操作之前或之后发生的事件。 (2) <em>Action Prediction:</em> 根据当前操作推断后续事件。(3) <em>Action Antonym:</em> 将正确的操作与两个错误的操作区分开来。 (4) <em>Fine-grained Action:</em> 从一系列类似选项中确定准确的操作。 (5) <em>Unexpected Action:</em> 检测以幽默、创意或magic为特征的视频中的surprising actions。</p></li><li><p><strong>Object.</strong> (6) <em>Object Existence:</em> <strong>确定特定事件期间是否存在特定对象。</strong> (7) <em>Object Interaction:</em> 标识参与特定事件的对象。 (8) <em>Object Shuffle:</em> 在遮挡游戏中定位对象的最终位置。</p></li><li><p><strong>Position.</strong> (9) <em>Moving Direction:</em> 确定特定对象移动的轨迹。 (10) <em>Action Localization:</em> <strong>确定发生特定操作的时间段。</strong></p></li><li><p><strong>Scene.</strong> (11) <em>Scene transition:</em> 确定视频中场景的过渡方式。</p></li><li><p><strong>Count.</strong> (12) <em>Action Count:</em> 计算特定操作已执行的次数。(13) <em>Moving Count:</em> 计算执行了特定操作的对象数。</p></li><li><p><strong>Attribute.</strong> (14) <em>Moving Attribute:</em> 确定特定移动对象在给定时刻的表现/外观。 (15) <em>State Change:</em> <strong>确定某个对象的状态在整个视频中是否发生变化。</strong></p></li><li><p><strong>Pose.</strong> (16) <em>Fine-grained Pose:</em> 从一系列类似选项中确定准确的姿态类别。</p></li><li><p><strong>Character.</strong> (17) <em>Character Order:</em> 确定字母的显示顺序。</p></li><li><p><strong>Cognition.</strong> (18) <em>Egocentric Navigation:</em> Forecast the subsequent action, based on an agent’s current navigation instructions. 根据agent的当前指令预测后续操作。(19) <em>Episodic Reasoning:</em> 对电视连续剧一集中的人物、事件和对象进行推理。 (20) <em>Counterfactual Inference:</em> 思考如果发生某个事件会发生什么。</p></li></ul><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241115113421996.png" alt="image-20241115113421996" style="zoom:80%;"><h3 id="自动QA生成"><a href="#自动QA生成" class="headerlink" title="自动QA生成"></a>自动QA生成</h3><p>在时间任务定义的指导下，为每个任务收集和标注视频。具体来说，图2中设计了一个自动QA生成范式，它有效地将开源视频数据标注转换为评估mllm的多项选择QA。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241115162755492.png" alt="image-20241115162755492" style="zoom:80%;"><p><strong>数据过滤</strong></p><ul><li>考虑到<strong>视频多样性</strong>，仔细选择了11个视频数据集，覆盖广泛的领域和场景，尽可能地对不同的视频设计独立的问题；</li><li>考虑到<strong>时序敏感性</strong>，采取每个数据集中合适的视频长度（5~35秒），过短的视频往往动作幅度较小，而过长的视频包含过于复杂的上下文，问题过难会导致无法区分不同模型的能力；</li><li>考虑到<strong>问题复杂度</strong>，采取难度适中的问题，如在CLEVRER中，采取<strong>适当条件限制</strong>（排除需要超过10个条件的问题）的问题；如对于时间定位问题，不采用精细的秒级别定位任务，而采用粗略的时间段定位，如发生在视频的开始、中间还是结束。</li></ul><p><strong>QA生成</strong></p><p>之后便来到生成多选题的问题及选项，对于已有多选QA的数据，可以直接采用。但对于没有多选QA的数据，利用ChatGPT来自动生成多选QA格式。</p><ul><li>对于<strong>问题</strong>，根据任务定义，让ChatGPT生成3-5个对应的问题随机选其一；</li><li>对于<strong>选项</strong>，设计两种策略：(a)<strong>基于模版的构造</strong>，设计固定的选项模版，从ground truth annotations中构建候选集（例如，针对<em>Action Antonym</em>任务，包含正确选项，相反选项，不确定选项；在<em>Moving Direction</em>任务中，包含<em>up</em>, <em>down</em>, <em>left</em>, <em>right</em>四个方向以及固定状态），结合GPT匹配生成；(b)<strong>基于LLM的生成</strong>，针对类似<em>Unexpected Action</em>任务，将原始QA输入ChatGPT，并让ChatGPT生成新的问题以及选项。使用多选格式而不是开放格式，保证评估的正确性和公平性（如果引入开放答案，可能导致评估偏差或人工干预）。最终，本文为每个时间理解任务产生了<strong>200对多项选择QA对。</strong></li></ul><p><strong>问题选项处理</strong></p><p>对于每个问题，从可用的候选集中随机抽样三到五个答案选项，调整选项顺序以加强评估的稳健性。为了防止答案泄露，进一步使用LLM保证一个问题的所有答案选项具有相似和合理的长度。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241116140912529.png" alt="image-20241116140912529" style="zoom:80%;"><h3 id="evaluation的prompt设计"><a href="#evaluation的prompt设计" class="headerlink" title="evaluation的prompt设计"></a>evaluation的prompt设计</h3><p>对于具体的评测，作者设计了合理的system prompt和高效的answer prompt，其中<strong>system prompt</strong>用于<strong>激发模型的时间理解能力</strong>（见图2右下角），这一提示鼓励mllm仔细检查视频内容来回答问题，通过注意诸如人的动作和姿势，以及物体运动的细节和动作等因素。</p><blockquote><p><em>Carefully watch the video and pay attention to the <strong>cause and sequence of events, the detail and movement of objects and the action and pose of persons.</strong> Based on your observations, select the best option that accurately addresses the question.</em></p></blockquote><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241117103651589.png" alt="image-20241117103651589" style="zoom:80%;"><p>由于对话模型的输出倾向于输出完整的句子，难以直接输出选项，如何<strong>从对话的输出中抽取选项</strong>也成了一个难题。MMBench中使用多个模版匹配选项，对于无法匹配的选项，使用ChatGPT进行抽取。然而这种抽取效率低下， 和人类相比，只取得了87%的对齐率。SEED-Bench则比较不同选项的似然，选择最大似然对应的选项作为最终答案，这种方式仍不够直接，并且需要人为修改不同模型的forward函数。本文采取一种更简单直接的方式，通过<strong>构造带括号”()”的选项</strong>，接着显著地通过控制对话模型输出的起始字符”<strong>Best Option: (</strong>“，即<strong>answer prompt</strong>来指导mllm的选项生成，在本文实验里，这种方式不仅可以100%地保证不同模型输出选项，同时能够提高答案的准确率。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241117103831488.png" alt="image-20241117103831488" style="zoom:80%;"><h2 id="VideoChat2"><a href="#VideoChat2" class="headerlink" title="VideoChat2"></a>VideoChat2</h2><p>作者在MVBench上评估了现有的图像和视频对话模型（见实验部分表2），结果发现即便是最佳的视频对话模型VideoChat，性能与随机猜测相比也相差无几。分析原因可以发现，目前的视频对话模型存在两大缺陷：</p><ul><li><strong>缺乏多样的指令微调数据</strong>：由于视频数据难以标注，开源的指令微调数据仍规模较小；</li><li><strong>缺乏强视频编码器</strong>：目前主流的视频编码方法仍是选强多模态图像编码器CLIP-ViT，在上面进行时序改良，这难以本质地处理时序上的理解。</li></ul><p>为了弥补这些差距，本文开发了一个健壮的视频mllm基线模型VideoChat2。</p><h3 id="指令微调数据"><a href="#指令微调数据" class="headerlink" title="指令微调数据"></a>指令微调数据</h3><p>为了解决缺乏多样指令调优数据的问题，引入了如图3所示的丰富数据，其中包含了来自34个不同来源的2M个样本。效仿VideoChat和VideoLlama，在指令集中包含了图像和视频数据，以改进训练。</p><p>受M3IT的启发，本文以统一的格式重新组织了所有的数据样本，如图3的右下角所示。涉及两个key分别是{“image” or “video”}及{“QA”}。QA中包含instruction，question和answer。M3IT中要求研究人员为每一个数据集设计10组instruction，本文使用ChatGPT来生成指令（根据dataset_description，task_description，instruction_example）来生成。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241117105738621.png" alt="image-20241117105738621" style="zoom:80%;"><p>整个指令调优数据集可以粗略地分为6类：</p><ul><li>conversation：提高多轮对话能力。从LLaVA和VideoChat中收集对话数据；从VideoChatGPT中集成caption数据转为对话格式。</li><li>simple caption：提供基本的视觉描述能力。使用广泛使用的COCO和WebVid，以及来自YouCook2的一级视频字幕。</li><li>detailed caption：丰富视频细节的全面理解能力。利用MiniGPT-4, LLaVA和VideoChat的详细caption数据。</li><li>VQA：提高视觉问答能力。</li><li>reasoning：提高不同的推理能力。</li><li>classification：提高对目标识别和动作识别的鲁棒性。</li></ul><h3 id="渐进式跨模态训练范式"><a href="#渐进式跨模态训练范式" class="headerlink" title="渐进式跨模态训练范式"></a>渐进式跨模态训练范式</h3><p>促进mllm的另一个关键因素是如何有效地弥合视觉和语言表征之间的语义差距。为了解决这个问题，作者采用了如图4所示的渐进式多模态训练范式。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241117170157954.png" alt="image-20241117170157954" style="zoom:80%;"><p><strong>阶段1：视觉-语言对齐</strong></p><p>为了平衡效率和有效性，冻结视觉编码器，<strong>训练灵活的QFormer</strong>。它将冗余的视觉令牌（visual tokens）压缩为更少的查询令牌（query tokens），并<strong>通过多模态损失</strong>（即BLIP2训练的三种损失：视觉文本对比学习（VTC）、视觉文本匹配（VTM）和基于视觉的文本生成（VTG））<strong>将这些查询与文本令牌对齐。</strong>与BLIP2不同，本文选择了预训练过的<strong>UMT-L</strong>作为视觉编码器，因为它具有强大的时空表示学习能力。此外，训练CC3M和CC12M的15M图像字幕，WebVid-10M的10M视频字幕，以增强视频语言建模。</p><p><strong>阶段2：视觉-语言连接</strong></p><p>在初始对齐之后，将视觉编码器与预先训练过的llm连接起来，以构建视觉-语言理解能力。和BLIP2类似，作者应<strong>用一个线性投影来进一步转换查询标记，并将投影的标记与文本标记连接到LLM中</strong>，用于基于视觉的标题生成（即VTG）。与BLIP2不同的是，视觉编码器在这个阶段是非冻结的，以便更好地与LLM对齐。除了上述第一阶段的训练数据外，这一阶段进一步引入了2M图像caption（COCO、Visual Genome和SBU）和10M视频caption（InternVid），以丰富caption的多样性。</p><p><strong>阶段3：指令微调</strong></p><p>使用前面所述的指令微调数据进行微调。在冻结的LLM上进行lora低轶微调，通过VTG损失与视觉编码器和QFormer一起调整。此外，借鉴InstructBLIP，<strong>作者在QFormer中也插入了instruction</strong>，用于提取与指令相关的视觉token作为LLM的输入。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul><li>视觉编码器：UMT-L</li><li>大模型：Vicuna-7B</li><li>借鉴BLIP2，使用带有预训练Bert_base的QFormer，阶段1：32个query，阶段2和3：64个query</li><li>训练时：每个视频4帧，阶段1有10个epoch，阶段2有1个epoch；第3阶段转为8帧视频的3个epoch。</li><li>评估时：输入了16帧的视频，并提供了详细的prompt，以获得更好的结果。</li></ul><h3 id="MVBench整体评估"><a href="#MVBench整体评估" class="headerlink" title="MVBench整体评估"></a>MVBench整体评估</h3><p>表2展示了在MVBench上的评估结果，现有的图像和视频MLLM表现不佳。VideoChat2在15个任务上取得最佳性能，特别是在动作、物体、场景、属性和姿势识别（action, object, scene, attribute, and pose recognition）等方面表现出色。但也能看到，它在处理移动方向、动作定位、计数等任务上仍有不足。最近的一些图像对话模型，已经开始引入grouding数据增强相关能力，这也是后续视频对话模型可以突破的方向。</p><blockquote><p>值得一提的是，这里的VideoChat2_text，输入为空白视频，即QFormer输出噪声embedding，模型仅靠文本上下文进行输出，结果居然与前述最强模型接近。这个结果也揭示了<strong>目前对话模型，在时序理解任务上，仍有很大的不足</strong>。</p></blockquote><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241117104639154.png" alt="image-20241117104639154" style="zoom:80%;"><p>此外，作者还评估了功能强大的GPT-4V。结果表明，GPT-4V取得了令人满意的性能，证明了其时间理解能力，而VideoChat2超过了它，准确率提高了16.9%。这进一步强调了模型在处理更广泛的任务方面的优越性。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127143347889.png" alt="image-20241127143347889" style="zoom:80%;"><h3 id="更多比较"><a href="#更多比较" class="headerlink" title="更多比较"></a>更多比较</h3><p>仿照Video-chatgpt，本文使用ChatGPT在视频mllm之间进行定量比较。</p><p>（1）<strong>视频对话</strong>：表3显示了在Video-chatgpt中的基准上的结果。与VideoChatGPT相比，我VideoChat2在所有指标上都表现出了卓越的性能，在信息正确性、上下文和时间理解方面都取得了明显的进步。这表明，VideoChat2更<strong>擅长理解空间和时间细节，并提供一致和可靠的反应。</strong></p><p>（2）<strong>零样本视频QA</strong>：表4列出了视频QA数据集（Video question answering via gradually refined attention over appearance and motion. 及 Activitynet-qa: A dataset for understanding complex web videos via question answering.）上的结果，VideoChat2超过了所有其他方法，特别是在理解ActivityNet中的长视频方面。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127114104593.png" alt="image-20241127114104593" style="zoom:80%;"><p>图5中进一步进行了定性比较，其中VideoChat2提供了一个精确而彻底的响应。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127114508886.png" alt="image-20241127114508886" style="zoom:80%;"><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><ul><li><strong>指令微调数据</strong>：随着数据多样性和数量的增加，性能显著提高，其中<strong>视频数据的贡献大于图像数据</strong>（50.5% vs. 42.1%）。考虑到COCO和WebVid的简单caption数据中潜在的冗余性，对它们进行了随机压缩。这只对性能产生很小的影响（50.7% vs. 51.1%），但加速了微调1.7×。</li><li><strong>架构</strong>：（1）<strong>视觉编码器</strong>：表6中，使用本文构建的指令数据集+EVA-CLIP-g获得与原始VideoChat中模型相比6.9%的性能提升（42.4% vs 35.5%）。用UMT-L进行的进一步替换额外提高了6.2%的性能；（2）<strong>LLM</strong>：合并更大和更新的llm在结果中提供了一个最低限度的改进，这表明<strong>MVBench主要依赖于视觉编码器</strong>。值得注意的是，<strong>LoRA不断提高结果，可能是由于它增强了模型指令遵循的能力。</strong></li><li><strong>训练方法</strong>：只微调线性投影层，冻结视觉编码器和QFormer（参考MiniGPT-4），结果不佳（见表7，38.5%）。解冻Qformer，获得额外8.5%的性能提升；解冻视觉编码器获得更多的提升。</li><li><strong>提示设计</strong>：system prompt揭示了任务需求，增强任务完成能力。提取选项时，不同于不稳定的ChatGPT-extracting methods，和更耗时的log-likelihood comparisons，本文使用一种简单有效的answer prompt。表9证明了它能够准确地捕获选项，并提高了跨各种mllm的响应精度。VideoChat2即使没有提示，也能更好地按照指令返回选项。</li></ul><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127113600397.png" alt="image-20241127113600397" style="zoom:80%;"><p>对于QFormer，在第二第三阶段引入了额外可学习的token，用于和LLM对齐，结果显示<strong>额外引入64个token效果最佳</strong>。并且<strong>在QFormer中插入instruction引导，结果提升明显</strong>，而继续插入question则有副作用。过长的上下文（“指令+问题”）可能很难实现QFormer的信息提取。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127155131928.png" alt="image-20241127155131928" style="zoom:80%;"><p>对于训练和测试输入，实验表明训练使用8帧，测试使用16帧效果较好，训练开销也较小。但<strong>使用大分辨率，在MVBench上并没有提升，即增加分辨率并不能提高性能；然而，增加帧数可以提高，侧面验证了MVBench更依赖于模型的时序理解能力</strong>。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127161900211.png" alt="image-20241127161900211" style="zoom:80%;"><h3 id="定性结果"><a href="#定性结果" class="headerlink" title="定性结果"></a>定性结果</h3><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127162102966.png" alt="image-20241127162102966" style="zoom:80%;"><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241127162127244.png" alt="image-20241127162127244" style="zoom:80%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了MVBench，一个评估mllm的时间理解能力的综合基准。此外，本文针对现有视频对话模型的缺陷，构造了更丰富的指令微调数据，提出了一个健壮的视频MLLM基线模型，VideoChat2，在MVBench上比领先的模型表现超过15%。我们广泛的分析进一步指导了MLLM的时间理解的设计。</p><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="==项目配置=="></a>==项目配置==</h2><h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>以JSON格式提供了一个包含2M数据注释的综合数据集。annotation示例如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"image"</span><span class="token operator">:</span> <span class="token string">"two_col_103562.png"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"i"</span><span class="token operator">:</span> <span class="token string">"Examine the chart's visual features and the underlying data table closely to provide an accurate answer to the question."</span><span class="token punctuation">,</span> <span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"As of 2021, how many championship titles had Ferrari won?"</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"The answer is 16."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token punctuation">{</span><span class="token property">"image"</span><span class="token operator">:</span> <span class="token string">"two_col_2954.png"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"i"</span><span class="token operator">:</span> <span class="token string">"Analyze the visual and data components of the chart carefully and answer the question based on both the graphical representation and numerical data provided."</span><span class="token punctuation">,</span> <span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"What game topped the charts with 512.3 million hours watched on Twitch in the first half of 2019?"</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"The answer is League of Legends."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span> .....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>视频分类：</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241129145657121.png" alt="image-20241129145657121" style="zoom:80%;"><p>视频caption生成：</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20241129145746658.png" alt="image-20241129145746658" style="zoom:80%;"><h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p><strong>图像数据源</strong>：</p><p>M3IT（<a href="https://huggingface.co/datasets/MMInstruction/M3IT%EF%BC%89%EF%BC%8C%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8B%E6%96%B9%E5%BC%8F%E8%BF%87%E6%BB%A4%E5%87%BA%E8%B4%A8%E9%87%8F%E8%BE%83%E4%BD%8E%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A">https://huggingface.co/datasets/MMInstruction/M3IT），通过以下方式过滤出质量较低的数据：</a></p><ul><li>纠正拼写错误：大多数标点符号使用不正确的句子都得到了纠正。</li><li>改写错误答案：ChatGPT生成的一些回复，如“对不起，…”，是不正确的。这些用GPT-4重新表述。</li></ul><p><strong>视频数据源：</strong></p><ul><li>VideoChat（<a href="https://github.com/OpenGVLab/InternVideo/tree/main/Data/instruction_data%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EInternVid%E5%88%9B%E5%BB%BA%E4%BA%86%E9%A2%9D%E5%A4%96%E7%9A%84%E6%8C%87%E4%BB%A4%E6%95%B0%E6%8D%AEinstruction%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8GPT-4%E5%8E%8B%E7%BC%A9%E7%8E%B0%E6%9C%89%E6%95%B0%E6%8D%AE%E3%80%82">https://github.com/OpenGVLab/InternVideo/tree/main/Data/instruction_data）：基于InternVid创建了额外的指令数据instruction，并使用GPT-4压缩现有数据。</a></li><li>VideoChatGPT（<a href="https://github.com/mbzuai-oryx/Video-ChatGPT/tree/main/data%EF%BC%89%EF%BC%9A%E5%8E%9F%E5%A7%8Bcaption%E6%95%B0%E6%8D%AE%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%90%8C%E7%9A%84VideoID%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E3%80%82">https://github.com/mbzuai-oryx/Video-ChatGPT/tree/main/data）：原始caption数据基于相同的VideoID转换为对话数据。</a></li><li>Kinetics-710（<a href="https://github.com/OpenGVLab/UniFormerV2/blob/main/DATASET.md%EF%BC%89%E5%92%8CSthSthV2%EF%BC%88[Datasets](https://www.qualcomm.com/developer/artificial-intelligence/datasets)%EF%BC%89%EF%BC%9A%E9%80%89%E9%A1%B9%E5%80%99%E9%80%89%E6%98%AF%E6%A0%B9%E6%8D%AEUMT%E5%89%8D20%E5%90%8D%E7%9A%84%E9%A2%84%E6%B5%8B%E7%94%9F%E6%88%90%E7%9A%84%E3%80%82">https://github.com/OpenGVLab/UniFormerV2/blob/main/DATASET.md）和SthSthV2（[Datasets](https://www.qualcomm.com/developer/artificial-intelligence/datasets)）：选项候选是根据UMT前20名的预测生成的。</a></li><li>NExTQA（<a href="https://github.com/doc-doc/NExT-QA%EF%BC%89%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%8B%BC%E5%86%99%E9%94%99%E8%AF%AF%E5%B7%B2%E8%A2%AB%E7%BA%A0%E6%AD%A3%E3%80%82">https://github.com/doc-doc/NExT-QA）：原始句子中的拼写错误已被纠正。</a></li><li>CLEVRER（<a href="https://clevrer.csail.mit.edu/%EF%BC%89%EF%BC%9A%E5%AF%B9%E4%BA%8E%E5%8D%95%E9%A1%B9%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%8C%E5%8F%AA%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%8E%E9%A2%9C%E8%89%B2/%E6%9D%90%E6%96%99/%E5%BD%A2%E7%8A%B6%E6%9C%89%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82%E5%A4%9A%E9%A1%B9%E9%80%89%E6%8B%A9%E9%A2%98%E5%88%99%E5%88%A9%E7%94%A8%E4%BA%86%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E3%80%82">https://clevrer.csail.mit.edu/）：对于单项选择题，只使用了与颜色/材料/形状有关的问题。多项选择题则利用了所有数据。</a></li><li>WebVid（<a href="https://maxbain.com/webvid-dataset/%EF%BC%89%EF%BC%9A%E9%80%89%E6%8B%A9%E9%9D%9E%E9%87%8D%E5%8F%A0%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%AD%97%E5%B9%95%E5%92%8CQA%E3%80%82">https://maxbain.com/webvid-dataset/）：选择非重叠数据进行字幕和QA。</a></li><li>YouCook2（<a href="https://youcook2.eecs.umich.edu/%EF%BC%89%EF%BC%9A%E6%A0%B9%E6%8D%AE%E5%AE%98%E6%96%B9%E7%9A%84%E5%AF%86%E9%9B%86caption%EF%BC%8C%E5%8E%9F%E5%A7%8B%E8%A7%86%E9%A2%91%E8%A2%AB%E6%88%AA%E6%96%AD%E3%80%82">https://youcook2.eecs.umich.edu/）：根据官方的密集caption，原始视频被截断。</a></li><li>TextVR（[callsys/TextVR: <a href="https://github.com/callsys/textvr">PR 2024] A large Cross-Modal Video Retrieval Dataset with Reading Comprehension</a>）：所有数据均未经修改。</li><li>TGIF（<a href="https://github.com/YunseokJANG/tgif-qa">YunseokJANG/tgif-qa: Repository for our CVPR 2017 and IJCV: TGIF-QA</a>）：只使用了TGIF${frame}$和TGIF${Transition}$子集。</li><li>EgoQA（<a href="https://ego4d-data.org/">Egocentric 4D Perception (EGO4D)</a>）：一些以自我为中心的QA是从Ego4D数据中生成的。</li></ul><p>对于所有数据集，任务指令都是使用GPT-4自动生成的。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h3 id="conda配置"><a href="#conda配置" class="headerlink" title="conda配置"></a>conda配置</h3><ul><li>git clone拷贝远程仓库超时：设置全局代理，clash打开允许局域网接入。注意代理ip是本机电脑ip，不是服务器ip。</li></ul><p><strong>准备训练环境：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> videochat2 <span class="token assign-left variable">python</span><span class="token operator">=</span><span class="token number">3.9</span>conda activate videochat2pip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>注意这里pip install可能是系统的pip，而不是环境的pip，会导致当前虚拟环境并没有相应依赖</strong>：<a href="https://blog.csdn.net/qq_44856695/article/details/131378398">如何在conda环境中正确地使用pip_在conda构建的虚拟环境下可以进行pip操作吗-CSDN博客</a></p></li><li><p>CondaHTTPError: HTTP 000 CONNECTION FAILED</p><ul><li>conda换清华源：</li></ul></li></ul> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda config <span class="token parameter variable">--add</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config <span class="token parameter variable">--add</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config <span class="token parameter variable">--add</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config <span class="token parameter variable">--append</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/fastai/conda config <span class="token parameter variable">--append</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config <span class="token parameter variable">--append</span> channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ conda config <span class="token parameter variable">--set</span> show_channel_urls <span class="token function">yes</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>修改conda配置信息：<code>vim ~/.condarc</code>，<strong>删除 - defaults（重要！！）</strong> 增加 ssl_verify: false。保存后重新创建环境</p></li><li><p>ModuleNotFoundError: No module named ‘torch’</p><ul><li>离线下载对应版本：<a href="https://download.pytorch.org/whl/torchvision/">download.pytorch.org/whl/torchvision/</a></li></ul></li></ul><h3 id="阶段1训练"><a href="#阶段1训练" class="headerlink" title="阶段1训练"></a>阶段1训练</h3><p> Download <a href="https://huggingface.co/OpenGVLab/videochat2/resolve/main/l16_25m.pth">UMT-L/16</a> model and set <code>pretrained</code> in <a href="https://github.com/wolf-ll/Ask-Anything/blob/main/video_chat2/scripts/videochat_vicuna/config_7b_stage1.py">stage1_config</a></p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> scripts/videochat_vicuna/run_7b_stage1.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>AttributeError: module ‘numpy’ has no attribute ‘float’.</p><ul><li>重新安装<code>numpy</code>。出现这个问题是因为np.float从1.24起被删除。所用的代码是依赖于旧版本的Numpy。您可以将你的Numpy版本降级到1.23.5.</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> <span class="token assign-left variable">numpy</span><span class="token operator">==</span><span class="token number">1.23</span>.5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>linux环境下 python import不了自定义的包，即无法找到项目路径。</p><ul><li>手动导入项目根路径：</li></ul></li></ul> <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys <span class="token punctuation">,</span> osbase_dir <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>__file__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>base_dir<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>衍生报错：</strong>Traceback (most recent call last):  File “/home/bailey/Code/wyf/Ask-Anything/video_chat2/tasks/train_qformer.py”, line 298, in &lt;module&gt;。。。 File “/home/bailey/Code/wyf/Ask-Anything/video_chat2/utils/config_utils.py”, line 180, in setup_main    Config.dump(config, os.path.join(config.output_dir, “config.json”))。。。。**TypeError: Object of type module is not JSON serializable Traceback (most recent call last):**。。。<ul><li>本质是<strong>在<code>config</code>对象当中包含了对 Python 模块对象的引用，而这些引用与正在执行的操作（JSON 序列化和深拷贝）不兼容。</strong>因此需要<strong>去掉config对象中的sys和os这两个key对应的元素</strong>（这俩key的value都是module）</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">filter_module_refs</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token builtin">dict</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 对于字典类型，遍历每个键值对，对值进行递归处理</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>k<span class="token punctuation">:</span> filter_module_refs<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> obj<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> types<span class="token punctuation">.</span>ModuleType<span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token keyword">elif</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 对于列表类型，遍历每个元素，对元素进行递归处理</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>filter_module_refs<span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token keyword">for</span> element <span class="token keyword">in</span> obj <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> types<span class="token punctuation">.</span>ModuleType<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token comment"># 如果不是字典也不是列表，直接返回该元素（非模块类型的都返回）</span>        <span class="token keyword">return</span> obj <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> types<span class="token punctuation">.</span>ModuleType<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>衍生报错</strong>：在train_former197行set up model内部进行deepcopy时，报错 y[deepcopy(key, memo)] = deepcopy(value, memo)<br>  File “/home/bailey/anaconda3/envs/videochat2/lib/python3.9/copy.py”, line 161, in deepcopy<br>rv = reductor(4)<br>TypeError: <strong>cannot pickle ‘module’ object</strong>。。。</p><ul><li>本质还是因为python 试图序列化一个模块对象，但模块对象是不可序列化的。</li><li>解决思路：在train_former.py下改了很多次config对象都没有用，最后在utils/config_utils.py的<strong>Config.dump()前去掉config对象中的模块对象</strong>就解决了。</li><li>且这样改了以后，Found module object under key的提示会出现两次，也就是两个子线程分别去掉了模块对象，之后才在主线程中dump</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 这个判断module object的操作放在判断main进程前面</span>   <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> config<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>       <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> types<span class="token punctuation">.</span>ModuleType<span class="token punctuation">)</span><span class="token punctuation">:</span>           <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Found module object under key: </span><span class="token interpolation"><span class="token punctuation">{</span>key<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>           config<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span>   <span class="token keyword">if</span> is_main_process<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>       setup_output_dir<span class="token punctuation">(</span>config<span class="token punctuation">.</span>output_dir<span class="token punctuation">,</span> excludes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"code"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       setup_logger<span class="token punctuation">(</span>output<span class="token operator">=</span>config<span class="token punctuation">.</span>output_dir<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"vindlu"</span><span class="token punctuation">)</span>       <span class="token comment"># logger.info(f"config: {Config.pretty_text(config)}")</span>       Config<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>config<span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>config<span class="token punctuation">.</span>output_dir<span class="token punctuation">,</span> <span class="token string">"config.json"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>apt-get install报错文件尺寸不符：apt-get换国内镜像源</p><ul><li><a href="https://blog.csdn.net/qq_40765537/article/details/105936653">Ubuntu中apt-get命令以及修改apt-get镜像源-CSDN博客</a></li></ul></li><li><p>libcusparse.so.11: cannot open shared object file: No such file or dir报错：<a href="https://blog.csdn.net/qq_42727728/article/details/123857908">【最快解决方案】安装torch-geometric报错 libcusparse.so.11: cannot open shared object file: No such file or dir_oserror: libcusparse.so.11: cannot open shared obj-CSDN博客</a></p><ul><li>先<code>locate libcusparse.so.11</code>找一下服务器有没有对应文件，有的话直接复制到这个博客中说的路径下（发现bailey机器上libcusparse.so.11只有20kb，有一个libcusparse.so.11.7.4.91文件200+mb，把这俩一起复制过去也不行，最后用的llama项目虚拟环境下200+m的后缀11的文件替换就行了</li></ul></li><li><p>Failed to load image Python extension: libtorch_cuda_cu.so</p><ul><li>pytorch和torchvision的版本问题</li></ul></li><li><p><strong>ERROR:torch.distributed.elastic.multiprocessing.api:failed (exitcode: 1) local_rank: 0 (pid: 3938937) of binary:</strong> </p><ul><li>本来以为是PyTorch 的 CUDA 版本与系统上的 CUDA 版本不兼容的问题。从原来的<code>torch==1.13.1+cu117</code>换成<code>torch==1.12.0+cu113</code>，但问题依然存在。（系统cuda为11.5）</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token assign-left variable">torch</span><span class="token operator">==</span><span class="token number">1.12</span>.0+cu113 <span class="token assign-left variable">torchvision</span><span class="token operator">==</span><span class="token number">0.13</span>.0+cu113 <span class="token assign-left variable">torchaudio</span><span class="token operator">==</span><span class="token number">0.12</span>.0 --extra-index-url https://download.pytorch.org/whl/cu113<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>而且torch降低为1.12以后，与peft冲突（peft 0.4.0 requires torch&gt;=1.13.0），且bitsandbytes和cuda版本又会不匹配</li><li>最后torch又装回1.13.1了，cuda11.7（各种版本下载对应：<a href="https://pytorch.org/get-started/previous-versions/">Previous PyTorch Versions | PyTorch</a>）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token assign-left variable">torch</span><span class="token operator">==</span><span class="token number">1.13</span>.1+cu117 <span class="token assign-left variable">torchvision</span><span class="token operator">==</span><span class="token number">0.14</span>.1+cu117 <span class="token assign-left variable">torchaudio</span><span class="token operator">==</span><span class="token number">0.13</span>.1 --extra-index-url https://download.pytorch.org/whl/cu117<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>wandb：命令行输入<code>wandb login</code>在官网登录，并将api key复制回命令行</li></ul><h4 id="bert相关"><a href="#bert相关" class="headerlink" title="bert相关"></a>bert相关</h4><ul><li><p>在shared_utils_qformer中setup_model时，BertTokenizer.from_pretrained(config.model.text_encoder.pretrained, local_files_only=True)报错   <strong>OSError: Can’t load tokenizer for ‘bert-base-uncased’.</strong> If you were trying to load it from ‘<a href="https://huggingface.co/models">https://huggingface.co/models</a>‘, make sure you don’t have a local directory with the same name. Otherwise, make sure ‘bert-base-uncased’ is the correct path to a directory containing all relevant files for a BertTokenizer tokenizer.</p><ul><li><p>原因：主机<strong>或服务器</strong>不能访问<a href="https://huggingface.co/%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%BA%94%E7%9A%84%E6%9D%83%E9%87%8D%E3%80%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%AC%E5%9C%B0%E3%80%82">https://huggingface.co/页面，因此不能下载相应的权重。解决方法：手动下载文件到本地。</a></p></li><li><p><a href="https://blog.csdn.net/weixin_47187147/article/details/140004137">OSError: Can‘t load tokenizer for ‘bert-base-uncased‘. If you were trying to load it from_oserror: can’t load tokenizer for ‘bert-base-uncas-CSDN博客</a></p></li><li><p>下载后放到tasks/bert-base-uncased路径，修改configs/model.py</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">TextEncoders<span class="token punctuation">[</span><span class="token string">"bert"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>    name<span class="token operator">=</span><span class="token string">"bert_base"</span><span class="token punctuation">,</span>    pretrained<span class="token operator">=</span><span class="token string">"/home/…………/tasks/bert-base-uncased/"</span><span class="token punctuation">,</span>    ………………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>**’BertTokenizer’ object has no attribute ‘vocab’**：修改models/bert/tokenization_bert.py文件，将self.vocab = load_vocab(vocab_file)从init方法后移到前面去（参考：<a href="https://blog.csdn.net/bitttiolkk/article/details/136612497">Debug：AttributeError: ‘BertTokenizer‘ object has no attribute ‘vocab‘_attributeerror: ‘berttokenizer’ object has no attr-CSDN博客</a>）</p></li><li><p>OSError: We couldn’t connect to ‘<a href="https://huggingface.co/">https://huggingface.co</a>‘ to load this file, couldn’t find it in the cached files and it looks like bert-base-uncased is not the path to a directory containing a file named config.json.</p></li></ul><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20250103205905009.png" alt="image-20250103205905009" style="zoom:67%;"><blockquote><p>使用 .from_pretrained(“xxxxx”)方法加载，本地加载bert需要修改两个地方，一是tokenizer部分，二是model部分：<br>step1、导包： from transformers import BertModel，BertTokenizer<br>step2、载入词表： tokenizer = BertTokenizer.from_pretrained(“./bert_localpath/“) 这里要注意！！除了你自己建的文件夹名外，后面一定要加个/，才能保证该方法找到咱的vocab.txt<br>step3、载入模型： bert = BertModel.from_pretrained(“./bert_localpath”) 然后，这个地方又不需要加上/</p></blockquote><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><p><a href="https://github.com/salesforce/LAVIS/blob/main/lavis/datasets/download_scripts/DownloadConceptualCaptions/download_data_cc3m.py">LAVIS/lavis/datasets/download_scripts/DownloadConceptualCaptions/download_data_cc3m.py at main · salesforce/LAVIS</a></p><p>—- 最好别用这个下，开了多线程电脑会卡，内存可能不够</p><p><a href="https://opensource.salesforce.com/LAVIS//latest/getting_started.html#auto-downloading-and-loading-datasets">Dataset Zoo — LAVIS documentation</a></p><p><a href="https://github.com/rom1504/img2dataset/blob/main/dataset_examples/cc3m.md">img2dataset/dataset_examples/cc3m.md at main · rom1504/img2dataset</a></p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>dataset/init.py</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_media_type</span><span class="token punctuation">(</span>dataset_config<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>dataset_config<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">3</span> <span class="token keyword">and</span> dataset_config<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"video"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"video"</span><span class="token comment"># 视频数据集，由标注+源数据+类型标记video构成</span>    <span class="token keyword">elif</span> <span class="token builtin">len</span><span class="token punctuation">(</span>dataset_config<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">3</span> <span class="token keyword">and</span> dataset_config<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"text"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"text"</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"image"</span><span class="token comment"># 图像数据，list里只有标注+源数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dataset config.json</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"train_file"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span>      <span class="token string">"annotation/anno_pretrain/webvid_10m_train.json"</span><span class="token punctuation">,</span>      <span class="token string">"annotation/videos_images/webvid_10m"</span><span class="token punctuation">,</span>      <span class="token string">"video"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span>      <span class="token string">"annotation/anno_pretrain/cc3m_train.json"</span><span class="token punctuation">,</span>      <span class="token string">"annotation/videos_images/cc3m"</span>    <span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"test_file"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"msrvtt_1k_test"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token string">"annotation/anno_pretrain/msrvtt_test1k.json"</span><span class="token punctuation">,</span>      <span class="token string">"annotation/videos_images/MSRVTT_Videos"</span><span class="token punctuation">,</span>      <span class="token string">"video"</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"test_types"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"msrvtt_1k_test"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pt_dataset.py</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PTImgTrainDataset</span><span class="token punctuation">(</span>ImageVideoBaseDataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    media_type <span class="token operator">=</span> <span class="token string">"image"</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ann_file<span class="token punctuation">,</span> transform<span class="token punctuation">,</span> pre_text<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ann_file<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token keyword">and</span> ann_file<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"video"</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>media_type <span class="token operator">=</span> <span class="token string">"video"</span>              self<span class="token punctuation">.</span>media_name <span class="token operator">=</span> <span class="token string">"key"</span><span class="token comment"># 自己做的数据集，json文件里面对应图名称的是key</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>media_type <span class="token operator">=</span> <span class="token string">"image"</span>            self<span class="token punctuation">.</span>media_name <span class="token operator">=</span> <span class="token string">"key"</span>        self<span class="token punctuation">.</span>label_file<span class="token punctuation">,</span> self<span class="token punctuation">.</span>data_root <span class="token operator">=</span> ann_file<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>        logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"=========label file : </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>label_file<span class="token punctuation">}</span></span><span class="token string">, data root : </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>data_root<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>        <span class="token comment"># 对于第一阶段训练， =========label file : annotation/anno_pretrain/cc3m_train.json, data root : annotation/videos_images/cc3m     =========label file : annotation/anno_pretrain/webvid_10m_train.json, data root : annotation/videos_images/webvid_10m</span>        logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'Load json file'</span><span class="token punctuation">)</span>        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>label_file<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>anno <span class="token operator">=</span> json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>num_examples <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>anno<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>transform <span class="token operator">=</span> transform        self<span class="token punctuation">.</span>pre_text <span class="token operator">=</span> pre_text        logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Pre-process text: </span><span class="token interpolation"><span class="token punctuation">{</span>pre_text<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_anno</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 针对自己做的数据集做一些特定处理</span>        <span class="token keyword">if</span> <span class="token string">"cc3m"</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>label_file<span class="token punctuation">:</span>            filename <span class="token operator">=</span> self<span class="token punctuation">.</span>anno<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>media_name<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">".jpg"</span>        <span class="token keyword">elif</span> <span class="token string">"webvid"</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>label_file<span class="token punctuation">:</span>            filename <span class="token operator">=</span> self<span class="token punctuation">.</span>anno<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>media_name<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">".mp4"</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            filename <span class="token operator">=</span> self<span class="token punctuation">.</span>anno<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>media_name<span class="token punctuation">]</span>        caption <span class="token operator">=</span> self<span class="token punctuation">.</span>anno<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"caption"</span><span class="token punctuation">]</span>        anno <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"image"</span><span class="token punctuation">:</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>data_root<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"caption"</span><span class="token punctuation">:</span> caption<span class="token punctuation">}</span>        <span class="token keyword">return</span> anno<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>evaluate text-encoder修改（原来是None）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># tasks/retrieval_utils</span>text_encoder <span class="token operator">=</span> model<span class="token punctuation">.</span>get_text_encoder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># models/videochat2_qformer.py</span><span class="token keyword">def</span> <span class="token function">get_text_encoder</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> build_bert<span class="token punctuation">(</span>self<span class="token punctuation">.</span>config<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># models/bert/builder.py</span><span class="token keyword">def</span> <span class="token function">build_bert</span><span class="token punctuation">(</span>model_config<span class="token punctuation">,</span> pretrain<span class="token punctuation">,</span> checkpoint<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""build text encoder.    Args:        model_config (dict): model config.        pretrain (bool): Whether to do pretrain or finetuning.        checkpoint (bool): whether to do gradient_checkpointing.    Returns: TODO    """</span>    bert_config <span class="token operator">=</span> BertConfig<span class="token punctuation">.</span>from_json_file<span class="token punctuation">(</span>model_config<span class="token punctuation">.</span>text_encoder<span class="token punctuation">.</span>config<span class="token punctuation">)</span>    bert_config<span class="token punctuation">.</span>encoder_width <span class="token operator">=</span> model_config<span class="token punctuation">.</span>vision_encoder<span class="token punctuation">.</span>d_model    bert_config<span class="token punctuation">.</span>gradient_checkpointing <span class="token operator">=</span> checkpoint    bert_config<span class="token punctuation">.</span>fusion_layer <span class="token operator">=</span> model_config<span class="token punctuation">.</span>text_encoder<span class="token punctuation">.</span>fusion_layer    <span class="token keyword">if</span> <span class="token keyword">not</span> model_config<span class="token punctuation">.</span>multimodal<span class="token punctuation">.</span>enable<span class="token punctuation">:</span>        bert_config<span class="token punctuation">.</span>fusion_layer <span class="token operator">=</span> bert_config<span class="token punctuation">.</span>num_hidden_layers    <span class="token keyword">if</span> pretrain<span class="token punctuation">:</span>        text_encoder<span class="token punctuation">,</span> loading_info <span class="token operator">=</span> BertForMaskedLM<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>            model_config<span class="token punctuation">.</span>text_encoder<span class="token punctuation">.</span>pretrained<span class="token punctuation">,</span>            config<span class="token operator">=</span>bert_config<span class="token punctuation">,</span>            output_loading_info<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        text_encoder<span class="token punctuation">,</span> loading_info <span class="token operator">=</span> BertModel<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>            model_config<span class="token punctuation">.</span>text_encoder<span class="token punctuation">.</span>pretrained<span class="token punctuation">,</span>            config<span class="token operator">=</span>bert_config<span class="token punctuation">,</span>            add_pooling_layer<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>            output_loading_info<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>    <span class="token keyword">return</span> text_encoder<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="张量设备"><a href="#张量设备" class="headerlink" title="张量设备"></a>张量设备</h5><p><strong>训练时</strong></p><p>output = text_encoder( …………)  执行这个操作时报错  Expected all tensors to be on the same device, but found at least two devices, cpu and cuda:1! (when checking argument for argument mat1 in method wrapper_addmm)</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20250105172608783.png" alt="image-20250105172608783" style="zoom: 50%;"><p><strong>evaluate时</strong></p><p>RuntimeError: indices should be either on cpu or on the same device as the indexed tensor (cpu)</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20250106130038364.png" alt="image-20250106130038364" style="zoom:50%;"><h5 id="数据维度"><a href="#数据维度" class="headerlink" title="数据维度"></a>数据维度</h5><p>clip计算相似分数时报错：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">Traceback (most recent call last):  File "/home/bailey/Code/wyf/Ask-Anything/video_chat2/tasks/train_qformer.py", line 302, in &lt;module&gt;    main(cfg)  File "/home/bailey/Code/wyf/Ask-Anything/video_chat2/tasks/train_qformer.py", line 232, in main    res = evaluation_wrapper(  File "/home/bailey/anaconda3/envs/videochat2/lib/python3.9/site-packages/torch/autograd/grad_mode.py", line 27, in decorate_context    return func(*args, **kwargs)  File "/home/bailey/Code/wyf/Ask-Anything/video_chat2/tasks/retrieval_utils.py", line 75, in evaluation_wrapper    i2t_x, t2i_x, i2t_emb, t2i_emb = evaluation(  File "/home/bailey/anaconda3/envs/videochat2/lib/python3.9/site-packages/torch/autograd/grad_mode.py", line 27, in decorate_context    return func(*args, **kwargs)  File "/home/bailey/Code/wyf/Ask-Anything/video_chat2/tasks/retrieval_utils.py", line 258, in evaluation    score = model.itm_head(itm_embeds)[:, 1]  File "/home/bailey/anaconda3/envs/videochat2/lib/python3.9/site-packages/torch/nn/modules/module.py", line 1194, in _call_impl    return forward_call(*input, **kwargs)  File "/home/bailey/anaconda3/envs/videochat2/lib/python3.9/site-packages/torch/nn/modules/linear.py", line 114, in forward    return F.linear(input, self.weight, self.bias)RuntimeError: mat1 and mat2 shapes cannot be multiplied (128x768 and 1536x2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体来说，**<code>itm_embeds</code>** 的形状为 <code>(128, 768)</code>，而 <strong><code>itm_head</code></strong> 的权重矩阵的形状为 <code>(1536, 2)</code>，这两者的维度不匹配，无法进行矩阵乘法。</p><p>在videochat2_qformer里面可以看到，配置vtm_cat_text_cls=true，会使得矩阵形状变成2倍。因此在配置文件里把这个改成false即可。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20250106002754122.png" alt="image-20250106002754122" style="zoom:50%;"><h4 id="阶段一训练结果"><a href="#阶段一训练结果" class="headerlink" title="阶段一训练结果"></a>阶段一训练结果</h4><p>原始数据量：（本机路径D:\AMLLM-Video\annotation）</p><ul><li><p>图像cc3m  20184张</p></li><li><p>视频MSRVTT 10000个</p></li><li><p>视频webvid  1809个</p></li></ul><p>训练用cc3m和webvid，测试用了MSRVTT中的1000条数据。</p><img src="/2024/11/12/mvbench-a-comprehensive-multi-modal-video-understanding-benchmark/image-20250106150125960.png" alt="image-20250106150125960" style="zoom:67%;"><h3 id="阶段2训练"><a href="#阶段2训练" class="headerlink" title="阶段2训练"></a>阶段2训练</h3><p>新增数据集InternVID，见MLLM-Code。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yang_daxia/article/details/139950072">论文阅读MVBench: A Comprehensive Multi-modal Video Understanding Benchmark-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/669658267">CVPR2024 Highlight] MVBench多模态视频理解能力的全面评测 - 知乎</a></p><p>代码： <a href="https://github.com/OpenGVLab/Ask-Anything/tree/main/video_chat2">Ask-Anything/video_chat2 at main · OpenGVLab/Ask-Anything</a></p><p><a href="https://zhuanlan.zhihu.com/p/260034241">『技术随手学』解决CondaHTTPError: HTTP 000 CONNECTION 问题 - 知乎</a></p><p><a href="https://blog.csdn.net/kekechengxiao/article/details/134491661">import torchModuleNotFoundError: No module named ‘torch‘_import torch 找不到模块-CSDN博客</a></p><p>conda中使用pip的问题：<a href="https://blog.csdn.net/qq_44856695/article/details/131378398">如何在conda环境中正确地使用pip_在conda构建的虚拟环境下可以进行pip操作吗-CSDN博客</a></p><p><a href="https://pytorch.org/get-started/previous-versions/">Previous PyTorch Versions | PyTorch</a></p><p>wandb使用：<a href="https://blog.csdn.net/qq_40507857/article/details/112791111">wandb: 深度学习轻量级可视化工具入门教程_wandb教程-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_42730750/article/details/119249193">Pycharm远程连接服务器进行代码的运行与调试_remote sdk is saved in idesetting-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_47187147/article/details/140004137">OSError: Can‘t load tokenizer for ‘bert-base-uncased‘. If you were trying to load it from_oserror: can’t load tokenizer for ‘bert-base-uncas-CSDN博客</a></p><p><a href="https://huggingface.co/google-bert/bert-base-uncased/tree/main">google-bert/bert-base-uncased at main</a></p><p>[<a href="https://blog.csdn.net/weixin_57972634/article/details/143758599">实验日志·已解决] 如何下载 + 加载本地的BERT预训练模型 （OSError: Can‘t load tokenizer for ‘bert-base-uncased‘.）_本地加载bert-base包-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_56438555/article/details/144110166">（超全方法）尝试解决问题：torch.cuda.OutOfMemoryError: CUDA out of memory._torch.outofmemoryerror: cuda out of memory.-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_41185868/article/details/137062748">LLMs之Mistral：Mistral 7B v0.2的简介、安装和使用方法、案例应用之详细攻略_mistral-7b-instruct-v0.2-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVBench-A-Comprehensive-Multi-modal-Video-Understanding-Benchmark&quot;&gt;&lt;a href=&quot;#MVBench-A-Comprehensive-Multi-modal-Video-Understanding</summary>
      
    
    
    
    <category term="论文" scheme="http://wolf-ll.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="MLLM" scheme="http://wolf-ll.github.io/tags/MLLM/"/>
    
    <category term="视频理解" scheme="http://wolf-ll.github.io/tags/%E8%A7%86%E9%A2%91%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>TimeChat</title>
    <link href="http://wolf-ll.github.io/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/"/>
    <id>http://wolf-ll.github.io/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/</id>
    <published>2024-10-13T02:31:52.000Z</published>
    <updated>2024-12-16T07:25:31.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TimeChat-A-Time-sensitive-Multimodal-Large-Language-Model"><a href="#TimeChat-A-Time-sensitive-Multimodal-Large-Language-Model" class="headerlink" title="TimeChat: A Time-sensitive Multimodal Large Language Model"></a>TimeChat: A Time-sensitive Multimodal Large Language Model</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本研究提出的 TimeChat 是一种时间敏感的多模态大型语言模型，专为长视频理解而设计。模型包含两个关键的架构贡献：（1）<strong>时间戳感知帧编码器</strong>，可以将视觉内容与每个帧的时间戳绑定；（2）<strong>滑动视频 Q-Former</strong>，生成不同长度的视频token序列，以适应不同时长的视频。此外，本文还构建了一个<strong>指令微调（instruction-tuning）数据集，包含 6 个任务和总共 125K 个实例</strong>，以进一步提高 TimeChat 的instruction-following性能。各种视频理解任务（如dense captioning, temporal grounding, and highlight detection）的实验结果都证明了 TimeChat 强大的<strong>零样本时间定位和推理</strong>能力。例如，与最先进的视频大语言模型相比，TimeChat 在 YouCook2 上获得了 +9.2 的 F1  score和 +2.8 的 CIDEr 分数，在 QVHighlights 上获得了 +5.8 的 HIT@1 分数，在 Charades-STA 上获得了 +27.5 的 R@1 分数（IoU=0.5），有望成为<strong>长视频理解任务的多功能视频助手</strong>，满足用户的实际需求。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241013105855336.png" alt="image-20241013105855336" style="zoom:80%;"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>背景</strong></p><ul><li>从教育教程到故事电影，长格式的视频已经成为我们日常生活中的一个重要媒介。但筛选冗长的视频是相当耗时且无趣的工作。</li><li>人类的注意力总是被有意义的或突出的视觉片段所吸引，比如烹饪教程中的基本步骤或体育赛事中的精彩时刻。</li><li>一个智能的时间敏感视频助手，为用户分析长视频，包括<strong>时间定位、时间戳检测和关键时刻总结</strong>，是社会的长期需求。</li><li>大模型拥有强大的<strong>指令遵循</strong>能力，可以用于长视频理解任务，满足用户的现实需求。</li></ul><p><strong>现状</strong></p><ul><li>已经进行了一些初步探索以集成视觉编码器和LLM来实现基本的视频理解（说明字幕、问答）。</li><li>然而，现有的视频LLM（VidLLM）只能<strong>捕获短片段的全局视觉语义</strong>，而不能<strong>将重要的视频内容与准确的时间戳关联</strong>起来。<ul><li>例如，VideoLLaMA和VideoChat努力定位和描述未经修剪的视频中的有意义的事件，导致在Tab2中验证的准确性较低。</li><li>个人理解：上述两种模型侧重识别特定事件发生，本文模型侧重时间戳定位。<strong>在社区事件定位场景中需要取二者均衡。</strong></li></ul></li></ul><p>现有的VidLLM有两个问题：（1）刚性压缩将视频token转换为固定数字不适合长视频输入–它忽略了视频的持续时间，在处理长视频的大量帧时，导致严重的<strong>时空语义退化。</strong>（2）它们分别处理视频和时间戳信息，而不考虑显式的<strong>时间-视觉关联</strong>，因此无法准确地定位时间戳。</p><p><strong>本文贡献</strong></p><ul><li><p>提出TimeChat，一种时间敏感的多模态大语言模型，用于长视频理解和准确的时间定位。</p></li><li><p>为了处理长视频输入，提出了一种<strong>滑动视频Q-Former</strong>来适应视频特征提取和压缩过程中的自适应视频标记长度。视频Q-Former将滑窗内的帧压缩为视频token。移动窗口可以动态创建不同长度的视频token序列。它保留了<strong>长视频的重要视觉语义</strong>，并得到了更具表现力和可伸缩的视频表示。（<strong>捕获帧间时间信息</strong>）</p></li><li><p>为了增强<strong>视觉-时间戳的关联</strong>，提出了一个具有时间感知能力的<strong>帧编码器</strong>，它显式地将视觉上下文与每个帧的时间戳描述绑定起来。（<strong>绑定帧+时间戳信息</strong>）</p></li><li><p>为了提高TimeChat固有的时间戳定位能力，增强它的指令遵循能力，构建了一个新的指<strong>令调优数据集TimeIT</strong>，涉及不同的<strong>时间戳相关的用户指令</strong>。该数据集是由各种与时间戳相关的长视频数据集编译而来的，平均视频长度为<strong>190.8s</strong>。它由6个不同的任务、12个广泛使用的学术基准和总共125K实例组成。（<strong>增强时间-视觉关联能力</strong>）</p></li></ul><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>许多研究都在努力将llm与视频编码器集成起来，从而利用llm的强大理解和生成能力来进行视频任务。这些研究通常使用开源的llm，如Vicuna和LLaMA。它们的关键区别在于它们<strong>如何将视频编码为与llm兼容的视觉token</strong>。有代表性的工作，如VideoChat利用一个video transformer来编码视频features，随后实现一个Query Transformer（Q-Former）来压缩video tokens。VideoLLaMA首先使用vision transformer（ViT）和图像Q-Former对独立帧进行编码，然后使用视频Q-Former进行时间建模。然而，这些方法将视频token压缩到一个固定的数字，导致在处理长视频时视觉语义退化。相比之下，本文模型为视觉标记提供了可调的压缩率，增加了对不同视频长度的适应性。此外，模型明确地建立了一个帧级的视觉-时间戳关系，以提高时间定位能力。</p><p>视觉-语言指令微调需要使用人工指令生成高质量的数据，这可以分为两个技术分支。（1）合并可用的多模态基准数据集，将它们转化为指令格式；（2）利用GPT生成更多样化的对话式数据。</p><p>时间定位是视频理解任务的一个基本能力，特别是对于未修剪的长视频。有各种时间敏感的视频任务，包括视频时间定位、视频说明字幕、视频摘要、视频亮点检测、步长定位等。这些任务需要在视频语义和相应的时间戳之间进行显式的关联。以前的研究倾向于在专门的下游数据集上单独处理每个任务。尽管最近的工作对弥合一些任务进行了初步的尝试，但基于llm的通用范式仍在探索中。本文在语言建模上统一了一些时间敏感的视频任务，迈出了充分利用llm的通用能力的第一步。</p><h2 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h2><p>模型组件主要由三部分构成：1）时间感知帧编码器，2）视频滑窗Q-Former，3）LLM</p><p>给定一个输入视频，帧编码器首先<strong>独立地提取每个帧的视觉和时间戳特征</strong>。接下来，视频Q-Former建模<strong>滑动窗口内帧的时间关系</strong>，以生成视频token。最后，将这些视频token与可选的转录语音和用户指令连接起来，然后将这些指令输入LLM以生成响应。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241013153746315.png" alt="image-20241013153746315" style="zoom:80%;"><h3 id="Timestamp-aware-Frame-Encoder"><a href="#Timestamp-aware-Frame-Encoder" class="headerlink" title="Timestamp-aware Frame Encoder"></a>Timestamp-aware Frame Encoder</h3><p>以前的研究通常将视觉语义的建模和输入帧各自的时间戳信息分开。该方法不能直接捕获视觉事件发生时的时间。一些方法为视觉标记了可学习的位置（时间）嵌入。然而，<strong>这只能使模型能够识别帧的顺序，在确定精确的时间矩时缺乏精度。</strong></p><p>为了解决这些问题，引入受 InstructBLIP启发的时间戳感知帧编码器。给定一个视频输入V，首先使用一个<strong>预训练好的图像编码器</strong>即ViT对 每一帧进行编码获得<strong>帧特征（n*n*d）</strong>，随后，一个图像Q-Former进一步压缩帧token。如图2所示，Q-Former以Dq维的可学习查询作为输入。这些查询通过交叉注意力与frame feature进行交互，并将初始查询更新到维度Dq中的Ni视觉标记。值得注意的是，在视觉标记抽取过程中，添加了帧的时间戳例如“This frame is sampled at 2s.”作为Q-Former融合视觉和时间戳信息的一个条件。</p><blockquote><p>借鉴了InstructBLIP的Q-Former。首先通过ViT-G/14 from EVA-CLIP来抽取图片特征（n*n*d），再通过Q-Former来对feature做提取，并通过输入文本“This frame is sampled at 2s.”，来把时间戳信息也混合进去。一帧图像出来的特征是Ni*D的，Ni就是query向量的个数。这里的Q-Former是用InstructBLIP权重初始化的。</p></blockquote><h3 id="Sliding-Video-Q-Former"><a href="#Sliding-Video-Q-Former" class="headerlink" title="Sliding Video Q-Former"></a>Sliding Video Q-Former</h3><p>对于T帧的视频输入，使用时间戳感知帧编码器后，获取到T*Ni*D的视觉token。此时各帧独立编码，没有建模<strong>帧间时间信息</strong>。为此，引入Q-Former滑窗，在时间维度上增强特征融合。设计了一个长度为Lw的滑动窗口，并在每个窗口内<strong>利用视频Q-Former从Lw帧中提取Nv长度的视频token</strong>。（<strong>滑窗Lw，步长S，Q-former查询向量数Nv</strong>）最终可以将输入的视频表示为（T /S）×Nv的视频token。（上图黄色部分）</p><p>由于视频的三维特性，有大量冗余时空信息，原始视觉token会非常长（原始帧中的所有patch），需要压缩信息以降低LLM计算量。<strong>之前的工作一般都设置固定的视觉token数Nv比如32，当输入帧数T很大时，会造成严重的视觉语义退化。</strong></p><p><strong>本文采用固定的步长来保证长视频不会被过度压缩，即最终送入LLM的tokens数量会根据视频的长度变化而变化。在送入LLM之前还会</strong>经过一个线性映射层来使tokens的特征维度符合LLM的输入特征维度需求。</p><p>将压缩率R定义为<strong>原始视觉标记的数量与最终视频标记的数量之比</strong>。则以前Video-LLaMA的压缩率是：<br>$$<br>R=（T<em>N_P）/N_V<br>$$<br>其中，<strong>Np为每一帧的patch数</strong>。这个比率随着输入帧数T的增加而增加，并会导致长视频的过度压缩。使用滑动视频Q-Former，压缩率R’变成一个常数值：<br>$$<br>R’=\frac{T</em>N_P}{(T/S)<em>N_V}=\frac{S</em>N_P}{N_V}<br>$$<br>为长视频保留更丰富的语义。通过调整步幅S，可以根据计算预算来控制视频token的最终数量。最后，利用线性层对视频标记的维数DQ进行变换，以匹配LLM嵌入空间的维数DLLM。</p><h3 id="Large-Language-Model"><a href="#Large-Language-Model" class="headerlink" title="Large Language Model"></a>Large Language Model</h3><p>将多种模态的输入连接起来，包括视频token Xv，文本查询向量Xq（包括可选的转录语音和用户指令），并将其输入一个大型语言模型，以生成合理和连贯的响应Xa。在这里，Xv、Xq和Xa具有相同的标记embedding维数DLLM。</p><p>VidLLM的训练通常采用<strong>两阶段训练框架。</strong>第一阶段使用大规模图像/视频-文本对进行预训练，以实现<strong>视觉-语言对齐</strong>。第二阶段使用指令数据对模型进行微调，以实现<strong>指令遵循</strong>。考虑到计算效率，本文重用了在第一阶段训练后现有开源模型的检查点（模型用的是LLaMA-2 (7B)），<strong>仅进行指令微调</strong>。采用LoRA微调的方式来对LLM模型进行微调。在训练过程中，利用<strong>语言建模损失</strong>生成长度为LT的目标答案Xa：</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241014144753535.png" alt="image-20241014144753535" style="zoom:80%;"><h3 id="数据集TimeIT"><a href="#数据集TimeIT" class="headerlink" title="数据集TimeIT"></a>数据集TimeIT</h3><p>为了提高TimeChat对时间敏感的人类指令的理解能力，提出TimeIT，一个涉及时间戳的以视频为中心的指令调优数据集。该数据集集成了广泛的与时间戳相关的视频数据集，并以长篇视频为特征。</p><p>TimeIT包含了6个与时间戳相关的视频任务，即：**(1) 视频说明字幕生成，(2) 视频时间定位，(3) 步骤定位和文字生成，(4) 视频摘要，(5) 视频亮点检测，以及 (6) 转录语音生成**。它还整合了来自不同领域的12个特定数据集。数据集适应了在现实世界应用中与AI助手交互时涉及视频时间戳的普遍用户请求。</p><p>数据集构建方式分两步：1）Instruction Writing  和  2) Answer Formatting。</p><p><strong>指令构造</strong>：先通过人工进行构造，然后利用GPT-4进行扩写来产生更多样化的表达，最后通过人工检查和refine来形成最终的版本。对于<strong>每个task会产生6个高质量的指令</strong>（instructions）。</p><p><strong>答案模板</strong>：根据编写的指令，我们进一步将任务输出重新表述为用户友好的自然语言响应范式。考虑到所涉及的视频数据集是人工收集的，TimeIT数据的整体质量得到了保证。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241014164810146.png" alt="image-20241014164810146" style="zoom:80%;"><p>表1将TimeIT数据与现有的视频指令调优数据进行了比较，揭示了本文数据集在数据规模、任务多样性和视频长度方面的显著优势。附录C提供了每个任务对模型性能的贡献分析。总的来说，所有6个任务都是有益的。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241014165334936.png" alt="image-20241014165334936" style="zoom:80%;"><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>以EVA-CLIP中的ViT-G/14作为图像编码器，以LLaMA-2（7B）作为语言基础模型。图像Q-Former的参数从InstructBLIP的检查点初始化，而视频Q-Former从Video-LLaMA的检查点初始化。在TimeIT和Valley上调整了3个epoch，使用32的批处理大小，使用一台8-V100（32G）机器。如图2所示，ViT和LLM的参数被冻结，而图像Q-Former、视频Q-Former和线性层的参数被调整。窗口大小Lw、步幅S和每个窗口的视频token Nv数为32。输入帧数为96。其他超参数请参阅附录D。</p><ul><li><p>模型在三个任务上进行零样本长视频理解评估，即字幕（说明性文字）生成，时间定位，和亮点检测。评估数据集包括YouCook2、 Charades-STA和 QVHighlights。评价指标的细节详见附录E。</p></li><li><p>用于解析LLM输出的启发式规则：由llm生成的输出可能包括口语化表达式，从而导致较大的响应变化。因此，作者设计了大量的启发式规则，以保证能够准确地从模型的响应中提取预测的答案，以计算最终的度量。</p></li><li><p>方法比较：将模型与两个基线对比。（1）<strong>多模态pipeline</strong>： VideoChat-Text，InstructBLIP+ChatGPT。这些pipeline将专用的视觉模型与GPT集成，首先将视觉语义转换为文本描述，然后利用ChatGPT来处理所有输入来解决目标任务。（2）<strong>端到端模型</strong>：Valley，VideoChat-Embed，Video-LLaMA with 7B LLMs。这些模型直接将视频作为输入，并以端到端的方式生成响应。</p></li></ul><h3 id="零样本性能"><a href="#零样本性能" class="headerlink" title="零样本性能"></a>零样本性能</h3><p>表2显示了TimeChat(7B)的零样本性能，它在所有任务中都优于以前的VidLLM(7B/13B)。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241014173705687.png" alt="image-20241014173705687" style="zoom:80%;"><p><strong>密集字幕/说明文字生成</strong>：该任务在YouCook2上训练。模型需要在平均320秒的视频持续时间内，准确地识别出大约8个基本的烹饪步骤，并提供与视觉内容相匹配的忠实描述。烹饪的特殊性也提高了任务的复杂性，挑战了模型的通用性。现有的端到端VidLLM难以实现精确的moment定位，性能最好的VideoChat-Embed模型获得的低F1分数3.4就证明了这一点。<strong>这种momen定位的不精确显著影响了说明文字的评估，使得SODA_c和CIDEr指标都接近于零。</strong>与之相比，本文模型通过+1.0 SODA_c、+2.8 CIDEr和+9.2 F1评分获得了显著的SOTA。这表明TimeChat能够有效地处理长时间的视频，拥有精确的时间定位能力。此外，本文模型性能也显著超过了由ChatGPT提供的多模态pipeline（F1评分从8.4到12.6）。</p><p><strong>视频亮点检测</strong>：dense video captioning任务集中于在clip级别定位事件，而亮点检测任务需要在帧级别进行更细粒度的视频理解。对于输入视频，其目标是输出亮点帧的时间和突出分数。整体来看，本文模型在QVHhemict上达到了14.5 mAP和23.9 HIT@1，比之前的vidllm分别获得了+1.4和+5.8分。这突出了<strong>时间戳感知帧编码器在识别每个帧的显著语义方面</strong>的贡献。此外，该任务是TimeIT的held-out任务，表明了模型对新任务的泛化能力。<strong>多模态pipeline方法获得了更好的性能</strong>，作者推测，这是由于高亮检测的格式与他们的方法更兼容，鉴于模型接收到一系列的输入帧的联合的时间戳-视觉描述。这使得LLM能够逐帧进行评估，从而促进更准确的判断。</p><p><strong>时间定位</strong>：此任务旨在<strong>识别查询语句所描述的对应时间戳。</strong>TimeChat在Charades-STA数据集的“R@1，IoU=0.5”上达到32.2分，大大超过了之前的SOTA端到端VidLLM，即Valley（+27.5）。这表明，本文模型能够准确地定位给定文本查询的视频时刻。值得注意的是，TimeChat在时间定位任务上取得了最大的进步，作者认为该任务主要强调了<strong>长视频的时间定位能力</strong>，而这正是TimeChat的最佳优势。</p><h3 id="定性评估"><a href="#定性评估" class="headerlink" title="定性评估"></a>定性评估</h3><p>图4显示了在零样本设置下，TimeChat和其他VidLLM之间的定性比较。Video-LLaMA没有完全理解用户的指令，因为它只描述了步骤，而没有给出相应时间戳。VideoChat生成了符合请求格式的说明，但错位了所有步骤的时间。此外，VideoChat生成的描述包含一些幻觉。与之相比，TimeChat显示了改进的时间定位和总结功能。它成功地匹配了几乎所有提取的剪辑的视频内容。此外，幻觉的发生也明显减少了。然而，在增强模型生成的摘要的丰富性和细节方面仍有改进的空间。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241015171454792.png" alt="image-20241015171454792" style="zoom:80%;"><p><strong>领域推广</strong>：在附录G中，展示了新领域的定性结果，如movie和egocentric videos，展示了TimeChat对新场景的泛化。这种泛化是一个实用的视频助手的一个关键特征，它代表了基于LLM的TimeChat和当前为特定的下游数据集量身定制的专用模型之间的根本区别。</p><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><p>当<strong>删除滑动视频Q-Former</strong>时，最终视觉token的数量从96减少到32，导致信息压缩率为3倍。语义信息的减少导致了生成的描述和视频内容之间的对齐性的降低。具体来说，SODA_c度量减少了1.0，而CIDEr度量减少了2.8。此外，时间戳的准确性（以F1分数衡量）降低了3.0。在<strong>去除时间戳感知帧编码器</strong>的情况下，模型对时间基础描述的能力显著下降，F1分数下降了2.3。这些结果突出了模型中两个新模块的有效性。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241015173335537.png" alt="image-20241015173335537" style="zoom:80%;"><h3 id="其他分析"><a href="#其他分析" class="headerlink" title="其他分析"></a>其他分析</h3><p>为了证明模型的性能提高不仅归因于新的TimeIT数据集，而且还归因于模型架构的改进，<strong>只使用YouCook2数据集进行微调和评估</strong>。在这个设置中，使用现有的开源检查点初始化模型（参见4.1）。对于所有的模型，应用LoRA 并微调Q-Former。Tab.4给出了结果，显示模型在所有指标上都始终优于以前的模型。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241015174655078.png" alt="image-20241015174655078" style="zoom:80%;"><p>在图5中，作者检查了模型关于输入帧数的性能测量。如3.1.3中提到的，以前的模型如Video-LLaMA和VideoChat压缩了长视频的过多信息，当输入帧数从32增加到96时，性能表现最差。相比之下，本文模型使用滑动视频Q-Former解耦帧数T和压缩率R‘。随着帧数的增加，曲线表现出线性提高，显示出优越的可伸缩性。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241015175208335.png" alt="image-20241015175208335" style="zoom:80%;"><h3 id="与专用模型的比较"><a href="#与专用模型的比较" class="headerlink" title="与专用模型的比较"></a>与专用模型的比较</h3><p>比较TimeChat与在三个任务上分别拥有最先进性能的专用模型。鉴于所有专用模型都在特定数据集上做了微调，作者对自己的模型也做了微调以进行公平比较。如表5所示，微调后TimeChat进一步提升了性能（+6.9 F1 score on YouCook2, +16.9 HIT@1 on</p><p>QVHighlights, and +16.4 R@1 (IoU=0.5) on Charades-STA）。专用模型的优越性来自特定任务的设计，例如Vid2Seq在YT-Temporal-1B上做预训练，这个数据集具有更多高质量的长视频；QD-DETR采用一种特殊的显著性token进行显著性预测，并引入了4个损失函数用于训练，而本文模型纯粹通过语言建模进行训练。此外，这些模型还使用了更多的微调步骤，以更好地适应下游数据集。</p><p>而作为一个通用模型，TimeChat在零样本场景、多任务和多领域设置中表现出很强的泛化能力，而这在这些专家模型中是不存在的。在每项任务上实现最先进的性能并不是本文的主要目标。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241015190311946.png" alt="image-20241015190311946" style="zoom:80%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提出了TimeChat，一个用于长视频理解的时间敏感的VidLLM。得益于新的时间感知帧编码器、滑动视频Q-Former和TimeIT上的指令调优，本文模型显示了强大的时间定位能力，这是在以前的VidLLM中所没有的。通过在冗长的视频中识别重大事件，确定事件的开始和结束时间，并生成简明的总结，TimeChat向智能视频助手迈出了关键的一步。在未来，将进一步取得架构上的进步，以提高视频语义密度，同时减少时空冗余。作者还将收集更多样化和高质量的指令调优数据，以扩大与时间相关的应用。</p><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="==项目配置=="></a>==项目配置==</h2><h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><h3 id="video-annotations"><a href="#video-annotations" class="headerlink" title="video&amp;annotations"></a>video&amp;annotations</h3><ul><li>YouCook2: <a href="http://youcook2.eecs.umich.edu/download">http://youcook2.eecs.umich.edu/download</a></li><li>Charades-STA: <a href="https://github.com/jiyanggao/TALL#charades-sta-anno-download">https://github.com/jiyanggao/TALL#charades-sta-anno-download</a></li><li>QVHighlight: <a href="https://github.com/jayleicn/moment_detr/blob/main/data/README.md">https://github.com/jayleicn/moment_detr/blob/main/data/README.md</a></li><li>ActivityNet Captions: <a href="http://activity-net.org/download.html">http://activity-net.org/download.html</a></li><li>ViTT: <a href="https://github.com/google-research-datasets/Video-Timeline-Tags-ViTT">https://github.com/google-research-datasets/Video-Timeline-Tags-ViTT</a></li><li>DiDeMo: <a href="https://github.com/LisaAnne/LocalizingMoments?tab=readme-ov-file#dataset">https://github.com/LisaAnne/LocalizingMoments?tab=readme-ov-file#dataset</a></li><li>QuerYD: <a href="https://www.robots.ox.ac.uk/~vgg/data/queryd/">https://www.robots.ox.ac.uk/~vgg/data/queryd/</a></li><li>HiREST: <a href="https://github.com/j-min/HiREST">https://github.com/j-min/HiREST</a></li><li>TVSum: <a href="https://github.com/yalesong/tvsum">https://github.com/yalesong/tvsum</a></li><li>SumMe: <a href="http://classif.ai/dataset/ethz-cvl-video-summe/">http://classif.ai/dataset/ethz-cvl-video-summe/</a></li><li>COIN: <a href="https://github.com/coin-dataset/annotations">https://github.com/coin-dataset/annotations</a></li><li>YT-Temporal: <a href="https://rowanzellers.com/merlot/#data">https://rowanzellers.com/merlot/#data</a></li></ul><p>对视频进行预处理，降低 FPS 和维度，以减少存储空间并改进数据加载。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ls <span class="token operator">-</span>U <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>raw<span class="token operator">/</span>video <span class="token operator">&gt;&gt;</span> <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>video_names<span class="token punctuation">.</span>txt<span class="token comment"># for YouCook2</span>python utils<span class="token operator">/</span>compress_video_data<span class="token punctuation">.</span>py \<span class="token operator">-</span><span class="token operator">-</span>input_root<span class="token operator">=</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>raw<span class="token operator">/</span>videos<span class="token operator">/</span> \<span class="token operator">-</span><span class="token operator">-</span>output_root<span class="token operator">=</span>data<span class="token operator">/</span>YouCook2<span class="token operator">-</span>BB<span class="token operator">/</span>YouCook2_asr_denseCap<span class="token operator">/</span>youcook2_6fps_224<span class="token operator">/</span> \<span class="token operator">-</span><span class="token operator">-</span>input_file_list_path<span class="token operator">=</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>video_names<span class="token punctuation">.</span>txt \<span class="token operator">-</span><span class="token operator">-</span>fps<span class="token operator">=</span><span class="token number">6</span> <span class="token operator">-</span><span class="token operator">-</span>size<span class="token operator">=</span><span class="token number">224</span> <span class="token operator">-</span><span class="token operator">-</span>file_type<span class="token operator">=</span>video <span class="token operator">-</span><span class="token operator">-</span>num_workers <span class="token number">24</span><span class="token comment"># for ActivityNet Captions</span>python utils<span class="token operator">/</span>compress_video_data<span class="token punctuation">.</span>py \<span class="token operator">-</span><span class="token operator">-</span>input_root<span class="token operator">=</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>raw<span class="token operator">/</span>videos<span class="token operator">/</span> \<span class="token operator">-</span><span class="token operator">-</span>output_root<span class="token operator">=</span>data<span class="token operator">/</span>Activitynet_Captions<span class="token operator">/</span>anet_6fps_224 \<span class="token operator">-</span><span class="token operator">-</span>input_file_list_path<span class="token operator">=</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>video_names<span class="token punctuation">.</span>txt \<span class="token operator">-</span><span class="token operator">-</span>fps<span class="token operator">=</span><span class="token number">6</span> <span class="token operator">-</span><span class="token operator">-</span>size<span class="token operator">=</span><span class="token number">224</span> <span class="token operator">-</span><span class="token operator">-</span>file_type<span class="token operator">=</span>video <span class="token operator">-</span><span class="token operator">-</span>num_workers <span class="token number">24</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HiREST_STEP&amp;VALLEY：run <code>python utils/process_valley.py</code>及<code>python utils/process_hirest.py</code></p><h3 id="Automatic-speech-transcription"><a href="#Automatic-speech-transcription" class="headerlink" title="Automatic speech transcription"></a>Automatic speech transcription</h3><p>从视频中提取音频：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python utils<span class="token operator">/</span>extract_audio<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">dir</span> <span class="token operator">/</span>home<span class="token operator">/</span>v<span class="token operator">-</span>shuhuairen<span class="token operator">/</span>mycontainer<span class="token operator">/</span>data<span class="token operator">/</span>DiDeMo<span class="token operator">/</span> <span class="token operator">-</span><span class="token operator">-</span>video_folder videos<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">0.</span><span class="token number">.179</span><span class="token punctuation">}</span><span class="token punctuation">;</span> do python utils<span class="token operator">/</span>extract_audio<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">dir</span> <span class="token operator">/</span>home<span class="token operator">/</span>v<span class="token operator">-</span>shuhuairen<span class="token operator">/</span>mycontainer<span class="token operator">/</span>data<span class="token operator">/</span>COIN<span class="token operator">/</span> <span class="token operator">-</span><span class="token operator">-</span>video_folder videos_ali<span class="token operator">/</span>$<span class="token punctuation">{</span>i<span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">-</span>audio_folder audio_files<span class="token operator">/</span>$<span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token punctuation">;</span> done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用whisper：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python utils<span class="token operator">/</span>asr<span class="token operator">/</span>asr<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span>audio_dir audio_files <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">dir</span> <span class="token operator">/</span>home<span class="token operator">/</span>v<span class="token operator">-</span>shuhuairen<span class="token operator">/</span>mycontainer<span class="token operator">/</span>data<span class="token operator">/</span>DiDeMo<span class="token operator">/</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">0.</span><span class="token number">.179</span><span class="token punctuation">}</span><span class="token punctuation">;</span> do python utils<span class="token operator">/</span>asr<span class="token operator">/</span>asr<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">dir</span> <span class="token operator">/</span>home<span class="token operator">/</span>v<span class="token operator">-</span>shuhuairen<span class="token operator">/</span>mycontainer<span class="token operator">/</span>data<span class="token operator">/</span>COIN<span class="token operator">/</span> <span class="token operator">-</span><span class="token operator">-</span>audio_dir audio_files<span class="token operator">/</span>$<span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token punctuation">;</span> done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>清除ASR结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python utils<span class="token operator">/</span>clean_asr<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">dir</span> <span class="token operator">/</span>home<span class="token operator">/</span>v<span class="token operator">-</span>shuhuairen<span class="token operator">/</span>mycontainer<span class="token operator">/</span>data<span class="token operator">/</span>DiDeMo<span class="token operator">/</span>whisper_outputs_with_time<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将ASR结果纳入instruction中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Incorporate the ASR results into the instructions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="指令数据集"><a href="#指令数据集" class="headerlink" title="指令数据集"></a>指令数据集</h3><ul><li>TimeIT: <a href="https://huggingface.co/datasets/ShuhuaiRen/TimeIT">https://huggingface.co/datasets/ShuhuaiRen/TimeIT</a></li><li>Valley: <a href="https://huggingface.co/datasets/luoruipu1/Valley-Instruct-65k">https://huggingface.co/datasets/luoruipu1/Valley-Instruct-65k</a></li></ul><p>数据格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"ActivityNet_asr_denseCap/anet_6fps_224/v_MinmayCk2Nk.mp4"</span><span class="token punctuation">,</span>   <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Capture and describe the activity events in the given video, specifying their respective time intervals, and outputting the time intervals in the 'start - end seconds format'."</span><span class="token punctuation">,</span>       <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"0.0 - 9.1 seconds, We see a male gymnast prepare to use the pommel horse.  9.1 - 10.8 seconds, The man mounts the pommel horse and spins his legs around it.  29.9 - 35.2 seconds, The man does a handstand and dismounts.  35.7 - 38.6 seconds, The man takes a bow and starts walking away."</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token property">"source"</span><span class="token operator">:</span> <span class="token string">"Activitynet_Captions"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字幕（说明文本）生成：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"vitt/raw_videos/--L2yxB3CUg.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Detect and report the start timestamp of activity events in the video, along with descriptions."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"2.7 seconds, Introduction.  8.5 seconds, Ingredients needed.  38.4 seconds, Measuring cornstarch.  54.1 seconds, Adding water.  62.0 seconds, Mixing mixture.  106.3 seconds, Explaining quicksand.  189.0 seconds, Closure."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"YouCook2_asr_denseCap/youcook2_6fps_224/GLd3aX16zBg.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Localize a series of activity events in the video, output the start and end timestamp for each event, and describe each event with sentences. The output format of each predicted event should be like: start - end seconds, event description. An specific example is : 90.0 - 102.0 seconds, spread margarine on two slices of white bread in the video."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"90.0 - 102.0 seconds, spread margarine on two slices of white bread.  114.0 - 127.0 seconds, place a slice of cheese on the bread.  132.0 - 138.0 seconds, place the bread slices on top of each other and place in a hot pan.  139.0 - 145.0 seconds, flip the sandwich over and press down.  173.0 - 174.0 seconds, cut the sandwich in half diagonally. "</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>步骤定位：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"COIN/videos_ali/116/NLy71UrHElw.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Identify and mark the video segments corresponding to a series of actions or steps, specifying the timestamps and describing the steps."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"21.0 - 22.0 seconds, begin to run up.  23.0 - 24.0 seconds, begin to jump up.  25.0 - 26.0 seconds, fall to the ground."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"HiREST/clips/_7urSjT6sQY_35_79.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Find, identify, and determine the temporal boundaries of a series of distinct actions or steps occurring throughout the video. For each action, output the corresponding start and end timestamps, accompanied by a concise description."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"0.0 - 13.0 seconds, clean out the face.  13.0 - 25.0 seconds, apply tissue using water on face.  25.0 - 37.0 seconds, apply it for full face.  37.0 - 42.0 seconds, put it under the neck .  42.0 - 44.0 seconds, dry it out."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基于查询文本的视频切片定位：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"0"</span><span class="token operator">:</span> <span class="token string">"Localize the visual content described by the given textual query &lt;query_placeholder&gt; in the video, and output the start and end timestamps in seconds."</span><span class="token punctuation">,</span>    <span class="token property">"1"</span><span class="token operator">:</span> <span class="token string">"Detect and report the start and end timestamps of the video segment that semantically matches the given textual query &lt;query_placeholder&gt;."</span><span class="token punctuation">,</span>    <span class="token property">"2"</span><span class="token operator">:</span> <span class="token string">"Give you a textual query: &lt;query_placeholder&gt; When does the described content occur in the video? Please return the timestamp in seconds."</span><span class="token punctuation">,</span>    <span class="token property">"3"</span><span class="token operator">:</span> <span class="token string">"Locate and describe the visual content mentioned in the text query &lt;query_placeholder&gt; within the video, including timestamps."</span><span class="token punctuation">,</span>    <span class="token property">"4"</span><span class="token operator">:</span> <span class="token string">"The given natural language query &lt;query_placeholder&gt; is semantically  aligned with a video moment, please give the start time and end time of the video moment."</span><span class="token punctuation">,</span>    <span class="token property">"5"</span><span class="token operator">:</span> <span class="token string">"Find the video segment that corresponds to the given textual query &lt;query_placeholder&gt; and determine its start and end seconds."</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"Charades/videos/AO8RW.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"The given natural language query 'a person is putting a book on a shelf' is semantically  aligned with a video moment, please give the start time and end time of the video moment."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"The given query happens in 0.0 - 6.9 seconds."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>语音转录：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"0"</span><span class="token operator">:</span> <span class="token string">"After watching the video from the YTTemporal dataset, transcribe the spoken content into text and document the start and end time for each segment. The format should be: 'start time - end time, transcribed speech'."</span><span class="token punctuation">,</span>    <span class="token property">"1"</span><span class="token operator">:</span> <span class="token string">"Observe the video thoroughly and transcribe the speech in a maximum of 20 segments. Make sure to include the starting and ending times for each segment in the following format: 'start time - end time, transcribed speech'."</span><span class="token punctuation">,</span>    <span class="token property">"2"</span><span class="token operator">:</span> <span class="token string">"Watch the provided video and transcribe the audio content. For each transcribed speech segment, note down its duration in the format: 'start time - end time, transcribed speech'."</span><span class="token punctuation">,</span>    <span class="token property">"3"</span><span class="token operator">:</span> <span class="token string">"Review the video from the YTTemporal dataset. Identify segments where speech occurs and transcribe those into text. Record the start and end time for each segment in this format: 'start time - end time, transcribed speech'."</span><span class="token punctuation">,</span>    <span class="token property">"4"</span><span class="token operator">:</span> <span class="token string">"Transcribe the spoken words in the video and note down the timestamps for each segment. Your output should look like this: 'start time - end time, transcribed speech'."</span><span class="token punctuation">,</span>    <span class="token property">"5"</span><span class="token operator">:</span> <span class="token string">"Watch the video, transcribe the speech, and indicate when each segment starts and ends. Follow this format: 'start time - end time, transcribed speech'."</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>视频亮点检测：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"0"</span><span class="token operator">:</span> <span class="token string">"You are given a video from the QVHighlights dataset. Please find the highlight contents in the video described by a sentence query, determining the highlight timestamps and its saliency score on a scale from 1 to 5. The output format should be like: 'The highlight timestamps are in the 82, 84, 86, 88, 90, 92, 94, 96, 98, 100 seconds. Their saliency scores are 1.3, 1.7, 1.7, 1.7, 1.7, 1.3, 1.7, 2.3, 2.3, 2.3'. Now I will give you the sentence query: &lt;query_placeholder&gt;. Please return the query-based highlight timestamps and salient scores."</span><span class="token punctuation">,</span>    <span class="token property">"1"</span><span class="token operator">:</span> <span class="token string">"Watch the provided video and mark out the scenes that stand out based on the description: &lt;query_placeholder&gt;. Document the timestamps of these highlights and evaluate their saliency scores."</span><span class="token punctuation">,</span>    <span class="token property">"2"</span><span class="token operator">:</span> <span class="token string">"Perform a thorough review of the video content, extracting key highlight moments that align with &lt;query_placeholder&gt;. It is essential to record the times of these moments and assign a distinct saliency value to each."</span><span class="token punctuation">,</span>    <span class="token property">"3"</span><span class="token operator">:</span> <span class="token string">"Examine the video and, in accordance with query &lt;query_placeholder&gt;, highlight the standout moments. You're required to provide the exact timing alongside a saliency rating for each segment."</span><span class="token punctuation">,</span>    <span class="token property">"4"</span><span class="token operator">:</span> <span class="token string">"In the video presented, seek moments that are a perfect match with &lt;query_placeholder&gt;. It's vital to notate their timestamps and to score each based on their level of saliency."</span><span class="token punctuation">,</span>    <span class="token property">"5"</span><span class="token operator">:</span> <span class="token string">"Go through the video content, and upon identifying highlight moments that resonate with &lt;query_placeholder&gt;, list their timestamps. Subsequently, provide a saliency score for each identified highlight."</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"QVhighlights/videos/train/v_j7rJstUseKg_360.0_510.0.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"Watch the provided video and mark out the scenes that stand out based on the description: 'some military patriots takes us through their safety procedures and measures.'. Document the timestamps of these highlights and evaluate their saliency scores."</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"There are 29 highlight moments in the 72.0, 74.0, 76.0, 78.0, 80.0, 84.0, 86.0, 88.0, 90.0, 92.0, 96.0, 98.0, 100.0, 102.0, 104.0, 108.0, 110.0, 112.0, 114.0, 116.0, 120.0, 122.0, 124.0, 126.0, 128.0, 136.0, 138.0, 140.0, 144.0 second. Their saliency scores are 3.0, 2.7, 3.7, 2.3, 2.7, 2.7, 2.7, 2.7, 2.3, 2.7, 3.7, 3.3, 3.3, 3.7, 3.0, 2.3, 3.0, 2.3, 2.3, 2.3, 2.3, 3.0, 3.7, 2.7, 2.3, 2.3, 2.3, 2.3, 2.3."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>视频摘要：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"0"</span><span class="token operator">:</span> <span class="token string">"From the &lt;dataset_placeholder&gt; dataset, generate a summarized version of the video, focusing on extracting key frames that best represent the overall narrative. The output should be a list of timestamps in seconds and their corresponding salient scores"</span><span class="token punctuation">,</span>    <span class="token property">"1"</span><span class="token operator">:</span> <span class="token string">"You are given a video from the &lt;dataset_placeholder&gt; dataset. Please find the highlight contents in the video, determining the highlight timestamps and its saliency score on a scale from 1 to 5. The output format should be like: 'The highlight timestamps are in the 82, 84, 86, 88, 90, 92, 94, 96, 98, 100 second. Their saliency scores are 1.3, 1.7, 1.7, 1.7, 1.7, 1.3, 1.7, 2.3, 2.3, 2.3'. "</span><span class="token punctuation">,</span>    <span class="token property">"2"</span><span class="token operator">:</span> <span class="token string">"Identify and extract the most emotionally impactful moments from the video provided by &lt;dataset_placeholder&gt; dataset, rating their intensity on a scale from 1 to 5."</span><span class="token punctuation">,</span>    <span class="token property">"3"</span><span class="token operator">:</span> <span class="token string">"Watch the provided video from the &lt;dataset_placeholder&gt; dataset and mark out the timestamps with stand-out visual content. Document the timestamps of these highlights and evaluate their saliency scores."</span><span class="token punctuation">,</span>    <span class="token property">"4"</span><span class="token operator">:</span> <span class="token string">"In the video presented from &lt;dataset_placeholder&gt; dataset, seek moments that could serve as an executive summary for a busy stakeholder. It's vital to notate their timestamps and to score each based on their level of saliency."</span><span class="token punctuation">,</span>    <span class="token property">"5"</span><span class="token operator">:</span> <span class="token string">"Go through the video content from &lt;dataset_placeholder&gt; dataset, and upon identifying highlight moments, list their timestamps. Subsequently, provide a saliency score for each identified highlight."</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"video"</span><span class="token operator">:</span> <span class="token string">"SumMe/videos/Air_Force_One.mp4"</span><span class="token punctuation">,</span> <span class="token property">"QA"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"From the summe dataset, generate a summarized version of the video, focusing on extracting key frames that best represent the overall narrative. The output should be a list of timestamps in seconds and their corresponding salient scores"</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">"The highlight timestamps are in the 57.0, 62.4, 68.4, 73.2, 78.0, 79.2, 80.4, 84.6, 155.4, 156.6, 157.8, 159.6, 160.8, 161.4, 162.6, 164.4, 165.6, 167.4, 169.2, 171.0, 172.2 seconds. Their saliency scores are 2.1, 1.8, 2.1, 2.9, 4.2, 3.9, 3.7, 3.1, 1.8, 2.3, 2.9, 3.1, 3.4, 3.4, 3.7, 3.1, 3.1, 2.6, 2.1, 2.1, 1.8."</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="评估数据集"><a href="#评估数据集" class="headerlink" title="评估数据集"></a>评估数据集</h3><p>数据格式–对于字幕（说明文本）生成：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"annotations"</span><span class="token operator">:</span>     <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token string">"3MSZA.mp4"</span><span class="token punctuation">,</span>            <span class="token property">"duration"</span><span class="token operator">:</span> <span class="token number">206.86</span><span class="token punctuation">,</span>            <span class="token property">"segments"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">91</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">137</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">153</span><span class="token punctuation">,</span> <span class="token number">162</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">163</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"pick the ends off the verdalago. ..."</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        ...        eg<span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token string">"v_QOlSCBRmfWY.mp4"</span><span class="token punctuation">,</span> <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"A young woman is seen standing in a room and leads into her dancing. The girl dances around the room while the camera captures her movements. She continues dancing around the room and ends by laying on the floor."</span><span class="token punctuation">,</span> <span class="token property">"segments"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.83</span><span class="token punctuation">,</span> <span class="token number">19.86</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">17.37</span><span class="token punctuation">,</span> <span class="token number">60.81</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">56.26</span><span class="token punctuation">,</span> <span class="token number">79.42</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"duration"</span><span class="token operator">:</span> <span class="token number">82.73</span><span class="token punctuation">,</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据格式–对于视频切片定位：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"annotations"</span><span class="token operator">:</span>     <span class="token punctuation">[</span>      <span class="token punctuation">{</span>               <span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token string">"3MSZA.mp4"</span><span class="token punctuation">,</span>             <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"person turn a light on."</span><span class="token punctuation">,</span>            <span class="token property">"timestamp"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">24.3</span><span class="token punctuation">,</span> <span class="token number">30.4</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      ...      eg<span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token string">"AO8RW.mp4"</span><span class="token punctuation">,</span> <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"a person is putting a book on a shelf."</span><span class="token punctuation">,</span> <span class="token property">"timestamp"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">6.9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">"image_id"</span><span class="token operator">:</span> <span class="token string">"Y6R7T.mp4"</span><span class="token punctuation">,</span> <span class="token property">"caption"</span><span class="token operator">:</span> <span class="token string">"person begins to play on a phone."</span><span class="token punctuation">,</span> <span class="token property">"timestamp"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">20.8</span><span class="token punctuation">,</span> <span class="token number">30.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模型相关"><a href="#模型相关" class="headerlink" title="模型相关"></a>模型相关</h2><p>以下checkpoint存储可学习的参数（位置嵌入层、时间感知帧编码器、滑动视频Q-Former、线性投影层和lora）</p><table><thead><tr><th>Checkpoint</th><th>LLM backbone</th><th>Link</th><th>Note</th></tr></thead><tbody><tr><td>TimeChat-2-7B-Finetuned</td><td>LLaMA-2 7B</td><td><a href="https://huggingface.co/ShuhuaiRen/TimeChat-7b/blob/main/timechat_7b.pth">link</a></td><td>Fine-tuned on the instruction-tuning data from <a href="https://huggingface.co/datasets/ShuhuaiRen/TimeIT">TimeIT-104K</a> (asr version) and <a href="https://huggingface.co/datasets/ShuhuaiRen/TimeIT/blob/main/data/valley/Valley_instruct_73k.json">Valley-73K</a> (previous version of current Valley-65K)</td></tr></tbody></table><h3 id="ViT-g-from-EVA-CLIP"><a href="#ViT-g-from-EVA-CLIP" class="headerlink" title="ViT-g from EVA-CLIP"></a>ViT-g from EVA-CLIP</h3><p><strong>预训练的图编码器</strong><code>wget https://storage.googleapis.com/sfr-vision-language-research/LAVIS/models/BLIP2/eva_vit_g.pth</code></p><p>《EVA-CLIP: Improved Training Techniques for CLIP at Scale》</p><p>EVA-CLIP是一系列改进的CLIP模型，通过结合新表示学习、优化和增强技术，降低训练成本，提高训练效率和零次学习性能。最大模型EVA-02-CLIP-E/14+在ImageNet-1K上实现82.0%的零次学习准确率，而较小的EVA-02-CLIP-L/14+模型也有80.4%的准确率，但参数和样本量更少。</p><h4 id="CLIP"><a href="#CLIP" class="headerlink" title="CLIP"></a>CLIP</h4><blockquote><p>CLIP（Contrastive Language-Image Pre-Training）模型是一种<strong>多模态预训练神经网络</strong>，由OpenAI在2021年发布，是从自然语言监督中学习的一种有效且可扩展的方法。CLIP在预训练期间学习执行广泛的任务，包括OCR，地理定位，动作识别。</p><p>该模型的核心思想是<strong>使用大量图像和文本的配对数据进行预训练，以学习图像和文本之间的对齐关系。</strong>CLIP模型有两个模态，一个是<strong>文本模态</strong>，一个是<strong>视觉模态</strong>，包括两个主要部分：</p><p>i. Text Encoder：用于将文本转换为低维向量表示-Embeding。</p><p>ii. Image Encoder：用于将图像转换为类似的向量表示-Embedding。</p><p>在预测阶段，CLIP模型通过计算文本和图像向量之间的<strong>余弦相似度</strong>来生成预测。这种模型特别适用于<strong>零样本学习</strong>任务，即模型不需要看到新的图像或文本的训练示例就能进行预测。CLIP模型在多个领域表现出色，如图像文本检索、图文生成等。</p></blockquote><p>CLIP的的核心思想是通过<strong>海量</strong>的<strong>弱监督</strong>文本对通过<strong>对比学习</strong>，将图片和文本通过各自的<strong>预训练</strong>模型获得的编码向量在向量空间上<strong>对齐</strong>。<strong>不足：clip可以实现图文匹配，但不具有文本生成能力。</strong></p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241021110850956.png" alt="image-20241021110850956" style="zoom:80%;"><p><strong>流程解读：</strong></p><ul><li><p>主要分为两个分支，一个图像encoder、一个文本encoder。<strong>图像分支是ResNet50或是VIT，文本分支和bert的结构类似，采用12层transformer</strong>，8个head，词表大小是49,152。最大sequence长度76。并且添加[SOS]和[EOS]标识token，并且[EOS]对应位置的特征就是最后的文本特征。</p></li><li><p>通过encoder特征提取以后，图像分支获得的特征是[batch, embed_dim]，文本分支获得的特征是[batch, embed_dim]。其中对应位置上的embedding是匹配的，来自同一组图像-文本对。<strong>对于优化任务，一种自然的想法，就是拉近同一对embedding之间的距离，推远不同对的embedding之间的距离。作者采用了InfoNCE loss。</strong>特征间进行两两计算，[batch, embed_dim] * [embed_dim, batch] = [batch, batch]，获取到batch*batch对样本之间的距离。</p><ul><li>这里对提取的文本特征和图像特征进行对比学习。对于一个包含N个文本-图像对的训练batch，将N个文本特征和N个图像特征两两组合，CLIP模型会预测出N^2个可能的文本-图像对的相似度，这里的相似度直接<strong>计算文本特征和图像特征的余弦相似性（cosine similarity）</strong>，即上图所示的矩阵。这里共有N个正样本，即真正属于一对的文本和图像（矩阵中的对角线元素），而剩余的N^2−N个文本-图像对为负样本，那么CLIP的训练目标就是最大化N个正样本的相似度，同时最小化N^2−N个负样本的相似度</li></ul></li><li><p>作者采用的对称loss。针对每一个image特征，将text batch中对应的那个text特征拉近，而推远其余未配对的text特征。同样，针对每一个text特征，将image batch中对应的那个image特征拉进，而推远其余未配对的image特征。<strong>站在loss对称的角度，模型优化中图像、文本的地位是相同的。因此，论文标题想表达利用文本监督去学习视觉特征，但是这未尝不是利用图像监督去学习文本特征。</strong>对比纯图像领域的自监督学习方法，其实和上面的方法是类似的，只是将文本分支替换为图像分支，两个分支同时输入同一张图的图像增强版本。</p></li><li><p>CLIP之所以经典，在于其出色的zero-shot能力。</p></li><li><p>上面我们介绍了CLIP的原理，可以看到训练后的CLIP其实是两个模型，除了视觉模型外还有一个文本模型，那么如何对预训练好的视觉模型进行迁移呢？<strong>与CV中常用的先预训练然后微调不同，CLIP可以直接实现zero-shot的图像分类，即不需要任何训练数据，就能在某个具体下游任务上实现分类，</strong>这也是CLIP亮点和强大之处。用CLIP实现zero-shot分类很简单，只需要简单的两步：</p></li></ul><ol><li>根据任务的分类标签构建每个类别的描述文本：<code>A photo of {label}</code>，然后将这些文本送入Text Encoder得到对应的文本特征，如果类别数目为N，那么将得到N个文本特征；</li><li>将要预测的图像送入Image Encoder得到图像特征，然后与N个文本特征计算缩放的余弦相似度（和训练过程一致），然后选择相似度最大的文本对应的类别作为图像分类预测结果，进一步地，可以将这些相似度看成logits，送入softmax后可以到每个类别的预测概率。</li></ol><ul><li><p><strong>流程解读：</strong></p></li><li><p>输入单张图像，通过Image Encoder提取对应的embedding。然后设定想要查找的标签集合，如”plane”, “car”, “dog”等。然后<strong>利用prompt语句 “a photo of a {}”，分别构成”a photo of a plane”, “a photo of a dog”等文本</strong>。<strong>然后利用Text Encoder分别提取对应的文本embedding。最后利用文本embedding和图像embedding计算对应的相似度，然后对相似度进行softmax，获得最大的概率值，即为对应的label。</strong>实验结果显示CLIP在zero-shot上面具有较高的精度，表明CLIP的泛化性很好。</p></li><li><p>这里需要注意两点：<strong>一是标签集合是自行定义的</strong>，如果我们定义为imagenet的类别标签，那么这时zero-shot就相当于完成imagenet分类任务；<strong>二是prompt语句的改变，可能会影响最后的分类效果</strong>，论文指出不同的数据集，有自己最优的prompt语句，并且多个prompt语句的结果取平均，可能最终的效果更好。</p></li></ul><h4 id="VIT"><a href="#VIT" class="headerlink" title="VIT"></a>VIT</h4><p>ViT（vision transformer）是Google在2020年提出的<strong>直接将transformer应用在图像分类的模型</strong>，后面很多的工作都是基于ViT进行改进的。ViT的思路很简单：</p><ul><li><p>直接把图像分成固定大小的patchs，然后通过线性变换得到<strong>patch embedding</strong>，这就类比NLP的words和word embedding</p></li><li><p>由于transformer的输入就是a sequence of token embeddings，所以将图像的patch embeddings送入transformer后就能够进行特征提取从而分类了。</p></li><li><p>ViT模型原理如下图所示，其实<strong>ViT模型只是用了transformer的Encoder来提取特征</strong>（原始的transformer还有decoder部分，用于实现sequence to sequence，比如机器翻译）。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241021112226815.png" alt="image-20241021112226815" style="zoom:80%;"></li></ul><h3 id="InstructBLIP-Q-Former"><a href="#InstructBLIP-Q-Former" class="headerlink" title="InstructBLIP Q-Former"></a>InstructBLIP Q-Former</h3><p>图片Q-Former <code>wget https://storage.googleapis.com/sfr-vision-language-research/LAVIS/models/InstructBLIP/instruct_blip_vicuna7b_trimmed.pth</code></p><p><strong>BLIP-2：使用冻结图像编码器和大型语言模型进行语言图像预训练</strong></p><blockquote><p>InstructBLIP 是 BLIP 作者团队在多模态领域的又一续作。现代的大语言模型在无监督预训练之后会经过进一步的指令微调 (Instruction-Tuning) 过程，但是这种范式在视觉语言模型上面探索得还比较少。InstructBLIP 这个工作介绍了<strong>如何把指令微调的范式做在 BLIP-2 模型上面</strong>。用指令微调方法的时候会额外有一条 instruction，如何<strong>借助这个 instruction 提取更有用的视觉特征</strong>是本文的亮点之一。InstructBLIP 的架构和 BLIP-2 相似，<strong>从预训练好的 BLIP-2 模型初始化，由图像编码器、LLM 和 Q-Former 组成。</strong>在指令微调期间<strong>只训练 Q-Former</strong>，冻结图像编码器和 LLM 的参数。作者将26个数据集转化成指令微调的格式，把它们分成13个 held-in 数据集用于指令微调，和13个 held-out 数据集用于 Zero-Shot 能力的评估。</p></blockquote><p>Q-Former是一种轻量级transformer结构，采用一组可学习的查询向量来提取和压缩视觉特征。</p><p>Q-Former 的输入还包括<strong>可学习的 Queries (BLIP-2 的做法)</strong> 和 <strong>Instruction</strong>。Q-Former 的内部结构如图3黄色部分所示，其中可学习的 Queries 通过 Self-Attention 和 Instruction 交互，可学习的 Queries 通过 Cross-Attention 和输入图片的特征交互，鼓励提取与任务相关的图像特征。</p><p>Q-Former 的输出通过一个 FC 层送入 LLM，Q-Former 的预训练过程遵循 BLIP-2 的两步：1) 不用 LLM，固定视觉编码器的参数预训练 Q-Former 的参数，训练目标是视觉语言建模。2) 固定 LLM 的参数，训练 Q-Former 的参数，训练目标是文本生成。</p><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241022105848543.png" alt="image-20241022105848543" style="zoom:80%;"><h3 id="LLaMA-2-7B-Video-Q-Former-of-Video-LLaMA"><a href="#LLaMA-2-7B-Video-Q-Former-of-Video-LLaMA" class="headerlink" title="LLaMA-2-7B &amp; Video Q-Former of Video-LLaMA"></a>LLaMA-2-7B &amp; Video Q-Former of Video-LLaMA</h3><p>预训练的LLM及对应的视频编码器</p><p>Video-LLaMA：指令微调的用于视频理解的视听语言模型</p><p><code>git lfs install git clone https://huggingface.co/DAMO-NLP-SG/Video-LLaMA-2-7B-Finetuned</code></p><h2 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h2><h3 id="Q-Former"><a href="#Q-Former" class="headerlink" title="Q-Former"></a>Q-Former</h3><ul><li>Q-Former的实现基于BERT（BertModel），并包含自注意力和交叉注意力层。</li><li>交叉注意力机制在模型的不同层插入，用于处理视觉和语言特征之间的结合，这使得模型可以在多模态任务中有效地执行跨模态对齐。</li><li>模型包括输入embedding、编码器层和输出层，整体架构与BERT类似，但针对多模态任务进行了适配。</li></ul><img src="/2024/10/13/timechat-a-time-sensitive-multimodal-large-language-model/image-20241022195840325.png" alt="image-20241022195840325" style="zoom:80%;"><p>Q-Former由两个transfomer子模块组成，左边为(learnable) query encoder，右边为text encoder &amp; decoder。记视觉模型的image encoder的输出为I。左边网络的(learnable) query为Q，右边网络的输入text为T。注意Q是一个向量集，非单个向量。它可以视为Q-Former的参数。</p><ul><li>左边的transformer和视觉模型image encoder交互，提取视觉表征，右边的transformer同时作为text encoder和decoder。</li><li>左边的query encoder和右边的text encoder共享self-attention layer。</li><li>通过self attention layer，实现Q向量之间的交互。</li><li>通过cross attention layer，实现Q向量和I的交互。</li><li>Q和T之间的交互，也是通过共享的self attention layer实现的，不过根据训练目标的不同，通过不同的attention mask来实现不同的交互。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">BertSelfAttention</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> config<span class="token punctuation">,</span> is_cross_attention<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>config <span class="token operator">=</span> config        <span class="token keyword">if</span> config<span class="token punctuation">.</span>hidden_size <span class="token operator">%</span> config<span class="token punctuation">.</span>num_attention_heads <span class="token operator">!=</span> <span class="token number">0</span> <span class="token keyword">and</span> <span class="token keyword">not</span> <span class="token builtin">hasattr</span><span class="token punctuation">(</span>            config<span class="token punctuation">,</span> <span class="token string">"embedding_size"</span>        <span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span>                <span class="token string">"The hidden size (%d) is not a multiple of the number of attention "</span>                <span class="token string">"heads (%d)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span> config<span class="token punctuation">.</span>num_attention_heads<span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token comment"># 初始化--设置注意力头的数量和每个头的维度</span>        self<span class="token punctuation">.</span>num_attention_heads <span class="token operator">=</span> config<span class="token punctuation">.</span>num_attention_heads        self<span class="token punctuation">.</span>attention_head_size <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>hidden_size <span class="token operator">/</span> config<span class="token punctuation">.</span>num_attention_heads<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>all_head_size <span class="token operator">=</span> self<span class="token punctuation">.</span>num_attention_heads <span class="token operator">*</span> self<span class="token punctuation">.</span>attention_head_size        <span class="token comment"># 初始化查询query、键和值的线性变换</span>        self<span class="token punctuation">.</span>query <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">)</span>        <span class="token comment"># ===如果是交叉注意力（cross-attention），键和值从编码器获取，否则从隐层获取===</span>        <span class="token keyword">if</span> is_cross_attention<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>key <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>config<span class="token punctuation">.</span>encoder_width<span class="token punctuation">,</span> self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>value <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>config<span class="token punctuation">.</span>encoder_width<span class="token punctuation">,</span> self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>key <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>value <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">)</span>        <span class="token comment"># 注意力得分的dropout</span>        self<span class="token punctuation">.</span>dropout <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>config<span class="token punctuation">.</span>attention_probs_dropout_prob<span class="token punctuation">)</span>        <span class="token comment"># 获取位置嵌入类型，如果是相对位置嵌入，则初始化相关嵌入层</span>        self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>            config<span class="token punctuation">,</span> <span class="token string">"position_embedding_type"</span><span class="token punctuation">,</span> <span class="token string">"absolute"</span>        <span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>            self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key"</span>            <span class="token keyword">or</span> self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key_query"</span>        <span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>max_position_embeddings <span class="token operator">=</span> config<span class="token punctuation">.</span>max_position_embeddings            self<span class="token punctuation">.</span>distance_embedding <span class="token operator">=</span> nn<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span>                <span class="token number">2</span> <span class="token operator">*</span> config<span class="token punctuation">.</span>max_position_embeddings <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>attention_head_size            <span class="token punctuation">)</span>        <span class="token comment"># 是否保存注意力图（用于可视化或调试）</span>        self<span class="token punctuation">.</span>save_attention <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">save_attn_gradients</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> attn_gradients<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>attn_gradients <span class="token operator">=</span> attn_gradients    <span class="token comment"># 注意力梯度</span>    <span class="token keyword">def</span> <span class="token function">get_attn_gradients</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>attn_gradients    <span class="token keyword">def</span> <span class="token function">save_attention_map</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> attention_map<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>attention_map <span class="token operator">=</span> attention_map  <span class="token comment"># 注意力图</span>    <span class="token keyword">def</span> <span class="token function">get_attention_map</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>attention_map    <span class="token keyword">def</span> <span class="token function">transpose_for_scores</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 将输入的张量x转置为(num_attention_heads, attention_head_size)格式</span>        new_x_shape <span class="token operator">=</span> x<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>            self<span class="token punctuation">.</span>num_attention_heads<span class="token punctuation">,</span>            self<span class="token punctuation">.</span>attention_head_size<span class="token punctuation">,</span>        <span class="token punctuation">)</span>        x <span class="token operator">=</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">*</span>new_x_shape<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        hidden_states<span class="token punctuation">,</span>        attention_mask<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>    <span class="token comment"># 注意力掩码</span>        head_mask<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>     <span class="token comment"># 注意力头掩码</span>        encoder_hidden_states<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>        encoder_attention_mask<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>    <span class="token comment"># 编码器注意力掩码</span>        past_key_value<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>    <span class="token comment"># 前一个时间步的键值对</span>        output_attentions<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 如果是交叉注意力，键和值来自编码器，否则从当前隐藏状态获取</span>        is_cross_attention <span class="token operator">=</span> encoder_hidden_states <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span>        <span class="token keyword">if</span> is_cross_attention<span class="token punctuation">:</span>            <span class="token comment"># 计算交叉注意力的键和值</span>            key_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">(</span>encoder_hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>            value_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">(</span>encoder_hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>            attention_mask <span class="token operator">=</span> encoder_attention_mask     <span class="token comment"># 使用编码器的注意力掩码</span>        <span class="token keyword">elif</span> past_key_value <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 如果存在之前的键/值缓存，则将当前计算结果与缓存进行拼接</span>            key_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>            value_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>            key_layer <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>past_key_value<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key_layer<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>            value_layer <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>past_key_value<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> value_layer<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 计算自注意力的键和值</span>            key_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>            value_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 计算查询向量</span>        mixed_query_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>query<span class="token punctuation">(</span>hidden_states<span class="token punctuation">)</span>        query_layer <span class="token operator">=</span> self<span class="token punctuation">.</span>transpose_for_scores<span class="token punctuation">(</span>mixed_query_layer<span class="token punctuation">)</span>        <span class="token comment"># 保存当前的键/值对，用于后续步骤</span>        past_key_value <span class="token operator">=</span> <span class="token punctuation">(</span>key_layer<span class="token punctuation">,</span> value_layer<span class="token punctuation">)</span>        <span class="token comment"># Take the dot product between "query" and "key" to get the raw attention scores.</span>        <span class="token comment"># 计算查询和键的点积，得到注意力得分</span>        attention_scores <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>query_layer<span class="token punctuation">,</span> key_layer<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 处理相对位置嵌入的情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>            self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key"</span>            <span class="token keyword">or</span> self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key_query"</span>        <span class="token punctuation">)</span><span class="token punctuation">:</span>            seq_length <span class="token operator">=</span> hidden_states<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            position_ids_l <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>                seq_length<span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">,</span> device<span class="token operator">=</span>hidden_states<span class="token punctuation">.</span>device            <span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            position_ids_r <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>                seq_length<span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">,</span> device<span class="token operator">=</span>hidden_states<span class="token punctuation">.</span>device            <span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment"># 计算位置差</span>            distance <span class="token operator">=</span> position_ids_l <span class="token operator">-</span> position_ids_r            positional_embedding <span class="token operator">=</span> self<span class="token punctuation">.</span>distance_embedding<span class="token punctuation">(</span>                distance <span class="token operator">+</span> self<span class="token punctuation">.</span>max_position_embeddings <span class="token operator">-</span> <span class="token number">1</span>            <span class="token punctuation">)</span>            positional_embedding <span class="token operator">=</span> positional_embedding<span class="token punctuation">.</span>to<span class="token punctuation">(</span>                dtype<span class="token operator">=</span>query_layer<span class="token punctuation">.</span>dtype            <span class="token punctuation">)</span>  <span class="token comment"># fp16 compatibility</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key"</span><span class="token punctuation">:</span>                <span class="token comment"># 计算相对位置得分并加到注意力得分中</span>                relative_position_scores <span class="token operator">=</span> torch<span class="token punctuation">.</span>einsum<span class="token punctuation">(</span>                    <span class="token string">"bhld,lrd-&gt;bhlr"</span><span class="token punctuation">,</span> query_layer<span class="token punctuation">,</span> positional_embedding                <span class="token punctuation">)</span>                attention_scores <span class="token operator">=</span> attention_scores <span class="token operator">+</span> relative_position_scores            <span class="token keyword">elif</span> self<span class="token punctuation">.</span>position_embedding_type <span class="token operator">==</span> <span class="token string">"relative_key_query"</span><span class="token punctuation">:</span>                <span class="token comment"># 计算查询和键的相对位置得分，并加到注意力得分中</span>                relative_position_scores_query <span class="token operator">=</span> torch<span class="token punctuation">.</span>einsum<span class="token punctuation">(</span>                    <span class="token string">"bhld,lrd-&gt;bhlr"</span><span class="token punctuation">,</span> query_layer<span class="token punctuation">,</span> positional_embedding                <span class="token punctuation">)</span>                relative_position_scores_key <span class="token operator">=</span> torch<span class="token punctuation">.</span>einsum<span class="token punctuation">(</span>                    <span class="token string">"bhrd,lrd-&gt;bhlr"</span><span class="token punctuation">,</span> key_layer<span class="token punctuation">,</span> positional_embedding                <span class="token punctuation">)</span>                attention_scores <span class="token operator">=</span> <span class="token punctuation">(</span>                    attention_scores                    <span class="token operator">+</span> relative_position_scores_query                    <span class="token operator">+</span> relative_position_scores_key                <span class="token punctuation">)</span>        attention_scores <span class="token operator">=</span> attention_scores <span class="token operator">/</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>self<span class="token punctuation">.</span>attention_head_size<span class="token punctuation">)</span>        <span class="token keyword">if</span> attention_mask <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 添加注意力掩码（在BertModel前向传播中预计算）</span>            <span class="token comment"># Apply the attention mask is (precomputed for all layers in BertModel forward() function)</span>            attention_scores <span class="token operator">=</span> attention_scores <span class="token operator">+</span> attention_mask        <span class="token comment"># Normalize the attention scores to probabilities.</span>        <span class="token comment"># 归一化注意力得分为概率分布</span>        attention_probs <span class="token operator">=</span> nn<span class="token punctuation">.</span>Softmax<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span>attention_scores<span class="token punctuation">)</span>        <span class="token keyword">if</span> is_cross_attention <span class="token keyword">and</span> self<span class="token punctuation">.</span>save_attention<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>save_attention_map<span class="token punctuation">(</span>attention_probs<span class="token punctuation">)</span>            attention_probs<span class="token punctuation">.</span>register_hook<span class="token punctuation">(</span>self<span class="token punctuation">.</span>save_attn_gradients<span class="token punctuation">)</span>        <span class="token comment"># This is actually dropping out entire tokens to attend to, which might</span>        <span class="token comment"># seem a bit unusual, but is taken from the original Transformer paper.</span>        attention_probs_dropped <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>attention_probs<span class="token punctuation">)</span>        <span class="token comment"># Mask heads if we want to</span>        <span class="token comment"># 如果需要掩盖特定的注意力头</span>        <span class="token keyword">if</span> head_mask <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            attention_probs_dropped <span class="token operator">=</span> attention_probs_dropped <span class="token operator">*</span> head_mask        <span class="token comment"># 计算上下文向量（注意力概率与值的乘积）</span>        context_layer <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>attention_probs_dropped<span class="token punctuation">,</span> value_layer<span class="token punctuation">)</span>        <span class="token comment"># 调整上下文向量形状</span>        context_layer <span class="token operator">=</span> context_layer<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span>        new_context_layer_shape <span class="token operator">=</span> context_layer<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>all_head_size<span class="token punctuation">,</span><span class="token punctuation">)</span>        context_layer <span class="token operator">=</span> context_layer<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">*</span>new_context_layer_shape<span class="token punctuation">)</span>        outputs <span class="token operator">=</span> <span class="token punctuation">(</span>            <span class="token punctuation">(</span>context_layer<span class="token punctuation">,</span> attention_probs<span class="token punctuation">)</span> <span class="token keyword">if</span> output_attentions <span class="token keyword">else</span> <span class="token punctuation">(</span>context_layer<span class="token punctuation">,</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        outputs <span class="token operator">=</span> outputs <span class="token operator">+</span> <span class="token punctuation">(</span>past_key_value<span class="token punctuation">,</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> outputs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/672514787">TimeChat：基于Q-Former的时序感知VideoLLM - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/AIGCer/article/details/142799336">从秒级到小时级：TikTok等发布首篇面向长视频理解的多模态大语言模型全面综述_tiktok 语音大模型-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/650519771">https://zhuanlan.zhihu.com/p/650519771</a></p><p><a href="https://zhuanlan.zhihu.com/p/638103950">多模态超详细解读 (八)：InstructBLIP: 指令微调训练通用视觉语言模型 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/mieshizhishou/article/details/140719063">【有啥问啥】多模态大模型应用中的Q-Former是什么？_qformer-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TimeChat-A-Time-sensitive-Multimodal-Large-Language-Model&quot;&gt;&lt;a href=&quot;#TimeChat-A-Time-sensitive-Multimodal-Large-Language-Model&quot; clas</summary>
      
    
    
    
    <category term="论文" scheme="http://wolf-ll.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="MLLM" scheme="http://wolf-ll.github.io/tags/MLLM/"/>
    
    <category term="视频理解" scheme="http://wolf-ll.github.io/tags/%E8%A7%86%E9%A2%91%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud</title>
    <link href="http://wolf-ll.github.io/2024/10/08/springcloud/"/>
    <id>http://wolf-ll.github.io/2024/10/08/springcloud/</id>
    <published>2024-10-08T12:44:24.000Z</published>
    <updated>2025-02-28T06:00:20.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker 是一个开源的容器化平台，它使开发者能够自动化应用程序的部署、管理、扩展和运行。Docker 利用容器技术，允许在一个隔离的环境中运行应用程序，并确保不同环境（如开发、测试、生产环境）之间的一致性。这种技术使得应用程序可以在各种不同的操作系统和基础设施上运行，而不必担心兼容性问题。</p><ul><li><strong>镜像：</strong>在Docker中，镜像是一个轻量级、独立的<strong>可执行软件包</strong>，包含运行应用程序所需的所有内容，包括代码、运行时库、环境变量和配置文件。镜像是容器的基石，容器实际上是在镜像的基础上创建的运行实例。</li><li><strong>容器：</strong>容器是镜像的<strong>运行实例</strong>。它包含了应用程序及其所有依赖项，以隔离应用程序及其环境，确保它在任何环境中都能一致运行。容器是可移植和可部署的，可以在任何支持Docker的系统上运行。</li><li><strong>仓库：</strong>Docker仓库是用于存储和组织镜像的地方。仓库可以是公共的（如Docker Hub）或私有的，用户可以通过仓库来分享和获取镜像。</li></ul><img src="/2024/10/08/springcloud/image-20241031111502848.png" alt="image-20241031111502848" style="zoom:67%;"><p>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用。Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。</p><p>ubuntu18安装docker：<a href="https://blog.csdn.net/x7536987/article/details/124808845">Ubuntu18.04安装Docker完整教程_ubuntu 18 安装 docker-CSDN博客</a></p><p><strong>启动docker</strong></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 启动dockersudo systemctl enable dockersudo systemctl start docker# 设置docker开机自启动sudo systemctl enable docker.servicesudo systemctl enable containerd.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>建立docker用户组</strong></p><p>默认情况下，docker命令会使用Unix socket与Docker引擎通讯。而只有root用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">sudo groupadd docker# 将当前用户加入dockersudo usermod -aG docker $USER<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>部署应用的步骤：<br>1、搜索镜像<br>2、拉取镜像<br>3、创建容器<br>4、操作容器中的应用</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">docker run -d \  --name mysql \  -p 3306:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=123 \  mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li><li><code>--name mysql </code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射到容器内端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul><p>镜像的名称不是随意的，而是要到DockerRegistry中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在DockerHub网站或者软件的官方网站中都能找到。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><img src="/2024/10/08/springcloud/image-20241031111225467.png" alt="image-20241031111225467" style="zoom: 67%;"><h3 id="容器迁移"><a href="#容器迁移" class="headerlink" title="容器迁移"></a>容器迁移</h3><p>当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p>docker commit 的语法格式为：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker commit [options] &lt;container_ID或container_name&gt; [&lt;new_image_name&gt;[:&lt;label&gt;]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以用下面的命令将容器保存为镜像：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker commit \    --author "XX" \    --message "XX" \    container_name \    new_image_name:label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 –author 是指定修改的作者，而 –message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。我们可以在 docker image ls 中看到这个新定制的镜像。我们还可以用 docker history image_name[:label] 具体查看镜像内的历史记录。</p><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>docker的问题：docker容器删除后，在容器中产生的数据也会随之销毁；docker容器和外部机器不能直接交换文件（只能与宿主机进行）；容器之间不能进行数据交互。</p><p>容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机目录</strong>之间映射的桥梁。 </p><p>数据卷的作用：<br>1、容器数据持久化<br>2、外部机器与容器间接通信<br>3、容器之间数据交换</p><img src="/2024/10/08/springcloud/image-20241031143605424.png" alt="image-20241031143605424" style="zoom:67%;"><p>在上图中：</p><ul><li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p><blockquote><p><code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code>。</p><p><strong>为什么不让容器目录直接指向宿主机目录呢</strong>？</p><ul><li>因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变了。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了。</li><li>但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与宿主机目录之间的映射关系即可。</li></ul><p>不过，我们通过由于数据卷目录比较深，不好寻找，通常我们也<strong>允许让容器直接与宿主机目录挂载而不使用数据卷</strong></p></blockquote><p>数据卷的相关命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><h4 id="nginx的html目录挂载"><a href="#nginx的html目录挂载" class="headerlink" title="nginx的html目录挂载"></a>nginx的html目录挂载</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx# 2.然后查看数据卷docker volume ls# 结果DRIVER    VOLUME NAMElocal     44c23cc5778160c799ff3cc24c64f456e65c0442058cbcbf78a277ab8ff73623local     html# 3.查看数据卷详情docker volume inspect html# 结果[    {        "CreatedAt": "2024-10-31T14:48:10+08:00",        "Driver": "local",        "Labels": null,        "Mountpoint": "/var/lib/docker/volumes/html/_data",        "Name": "html",        "Options": null,        "Scope": "local"    }]# 4.查看/var/lib/docker/volumes/html/_data目录ll /var/lib/docker/volumes/html/_data# 结果total 8.0K-rw-r--r-- 1 root root 497 10月  2 23:13 50x.html-rw-r--r-- 1 root root 615 10月  2 23:13 index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="匿名卷"><a href="#匿名卷" class="headerlink" title="匿名卷"></a>匿名卷</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 1.查看MySQL容器详细信息docker inspect mysql# 关注其中.Config.Volumes部分和.Mounts部分        "Config": {            "Volumes": {                "/var/lib/mysql": {}# 容器声明了一个本地目录，需要挂载数据卷，但是数据卷未定义。这就是匿名卷            },            .......            "Mounts": [            {                "Type": "volume",                "Name": "44c23cc5778160c799ff3cc24c64f456e65c0442058cbcbf78a277ab8ff73623",                "Source": "/var/lib/docker/volumes/44c23cc5778160c799ff3cc24c64f456e65c0442058cbcbf78a277ab8ff73623/_data",                "Destination": "/var/lib/mysql",                "Driver": "local",                "Mode": "",                "RW": true,                "Propagation": ""            }        ],<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Mounts中的关键属性：</p><ul><li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。</li><li>Source：宿主机目录</li><li>Destination : 容器内的目录</li></ul><p>上述配置是将容器内的<code>/var/lib/mysql</code>这个目录，与数据卷<code>44c23cc5778160c799ff3cc24c64f456e65c0442058cbcbf78a277ab8ff73623</code>挂载。于是在宿主机中就有了<code>/var/lib/docker/volumes/44c23cc5778160c799ff3cc24c64f456e65c0442058cbcbf78a277ab8ff73623/_data</code>这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。</p><h4 id="挂载本地目录"><a href="#挂载本地目录" class="headerlink" title="挂载本地目录"></a>挂载本地目录</h4><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 挂载本地目录-v 本地目录:容器内目录# 挂载本地文件-v 本地文件:容器内文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"> # 删除原来的MySQL容器docker rm -f mysql# 创建并运行新mysql容器，挂载本地目录docker run -d \--name mysql \-p 3306:3306 \-e TZ=Asia/Shanghai \-e MYSQL_ROOT_PASSWORD=123 \-v /home/yf/mysql/data:/var/lib/mysql \-v /home/yf/mysql/conf:/etc/mysql/conf.d \-v /home/yf/mysql/init:/docker-entrypoint-initdb.d \--privileged=true  mysql  # 守护者模式进入容器，操作MySQL docker exec -it mysql mysql -uroot -p123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为<strong>镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</strong>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td></tr></tbody></table><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token comment"># 在jdk环境基础上制作java镜像</span><span class="token comment"># 基础镜像</span><span class="token instruction"><span class="token keyword">FROM</span> openjdk:11.0-jre-buster</span><span class="token comment"># 设定时区</span><span class="token instruction"><span class="token keyword">ENV</span> TZ=Asia/Shanghai</span><span class="token instruction"><span class="token keyword">RUN</span> ln -snf /usr/share/zoneinfo/<span class="token variable">$TZ</span> /etc/localtime &amp;&amp; echo <span class="token variable">$TZ</span> &gt; /etc/timezone</span><span class="token comment"># 拷贝jar包</span><span class="token instruction"><span class="token keyword">COPY</span> docker-demo.jar /app.jar</span><span class="token comment"># 入口</span><span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">"java"</span>, <span class="token string">"-jar"</span>, <span class="token string">"/app.jar"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了。</p><p>首先，将课前资料提供的<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录：</p><img src="/2024/10/08/springcloud/image-20241102184713448.png" alt="image-20241102184713448" style="zoom:67%;"><p>然后，执行命令，构建镜像：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 进入镜像目录cd /root/demo# 开始构建docker build -t docker-demo:1.0 .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>命令说明：</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：<pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 直接指定Dockerfile目录docker build -t docker-demo:1.0 /root/demo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>Nginx (engine x) 是一个<strong>高性能的HTTP和反向代理web服务器</strong>，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。</li><li>其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</li><li>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。</li><li>Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>正向代理</strong>： 平时需要访问国外的浏览器很慢，比如我们要看推特，看GitHub等等。我们直接用国内的服务器无法访问国外的服务器，或者是访问很慢。所以我们需要在本地搭建一个服务器来帮助我们去访问。这种就是正向代理。（<strong>浏览器中配置代理服务器</strong>）</p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudy46bdad36-d3e0-43b0-a223-43360b7e8fc7.png" alt="img" style="zoom:67%;"><p><strong>反向代理</strong>： 我们访问淘宝的时候，淘宝内部肯定不是只有一台服务器，它的内部有很多台服务器，那我们进行访问的时候，因为服务器中间session不共享，那我们是不是在服务器之间访问需要频繁登录，这个时候淘宝搭建一个过渡服务器，对我们是没有任何影响的，我们是登录一次，但是访问所有，这种情况就是反向代理。对我们来说，<strong>客户端对代理是无感知的，客户端不需要任何配置就可以访问，我们只需要把请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端</strong>，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器的地址。（<strong>在服务器中配置代理服务器</strong>）</p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudy62a15097-6e2a-4dbe-bcf5-f0d7cab81089.png" alt="img" style="zoom:67%;"><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。<br>负载均衡（Load Balance）其意思就是分<strong>摊到多个操作单元上进行执行</strong>，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。<br>Nginx给出来三种关于负载均衡的方式。</p><h4 id="轮询法（默认方法）"><a href="#轮询法（默认方法）" class="headerlink" title="轮询法（默认方法）"></a>轮询法（默认方法）</h4><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>适合服务器配置相当，无状态且短平快的服务使用。也适用于图片服务器集群和纯静态页面服务器集群。</p><h4 id="weight权重模式（加权轮询）"><a href="#weight权重模式（加权轮询）" class="headerlink" title="weight权重模式（加权轮询）"></a>weight权重模式（加权轮询）</h4><p>指定<strong>轮询几率</strong>，weight和访问比率成正比，用于后端服务器性能不均的情况。<br>这种方式比较灵活，当后端服务器性能存在差异的时候，通过配置权重，可以让服务器的性能得到充分发挥，有效利用资源。weight和访问比率成正比，用于后端服务器性能不均的情况。权重越高，在被访问的概率越大</p><h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>上述方式存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。<br>我们可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求<strong>通过哈希算法，自动定位到该服务器。</strong>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。<strong>让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来</strong>，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p><p>Nginx的静态处理能力很强，但是动态处理能力不足，因此，在企业中常用动静分离技术。动静分离技术其实是采用代理的方式，在server{}段中加入带正则匹配的location来指定匹配项针对PHP的动静分离：<strong>静态页面交给Nginx处理，动态页面交给PHP-FPM模块或Apache处理。</strong>在Nginx的配置中，是通过location配置段配合正则匹配实现静态与动态页面的不同处理方式。</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">cd /usr/local/nginx/sbin/./nginx  启动./nginx -s stop  停止./nginx -s quit  安全退出./nginx -s reload  重新加载配置文件  如果我们修改了配置文件，就需要重新加载。ps aux|grep nginx  查看nginx进程==防火墙相关==# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all# 查询端口是否开放firewall-cmd --query-port=8080/tcp# 开放80端口firewall-cmd --permanent --add-port=80/tcp# 移除端口firewall-cmd --permanent --remove-port=8080/tcp#重启防火墙(修改配置后要重启防火墙)firewall-cmd --reload# 参数解释1、firwall-cmd：是Linux提供的操作firewall的一个工具；2、--permanent：表示设置为持久；3、--add-port：标识添加的端口；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>单体架构（monolithic structure）</strong>：顾名思义，整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；项目的架构设计、开发模式都非常简单。（优点：架构简单、部署成本低）</p><p>当项目规模较小时，这种模式上手快，部署、运维也都很方便，因此早期很多小型项目都采用这种模式。但随着项目的业务规模越来越大，团队开发人员也不断增加，单体架构就呈现出越来越多的问题：</p><ul><li><strong>团队协作成本高</strong>：试想一下，你们团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊。最终要把功能合并到一个分支，你绝对会陷入到解决冲突的泥潭之中。</li><li><strong>系统发布效率低</strong>：任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时。</li><li><strong>系统可用性差</strong>：单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用。</li></ul><p>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。（优点：降低服务的耦合度，有利于服务的升级拓展）同时要满足下面的一些特点：</p><ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块。</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模不超过10人（2张披萨能喂饱）</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li></ul><p>微服务的特征：</p><p>1、单一职责：拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责<br>2、面向服务：微服务对外暴露业务接口<br>3、自治：团队独立、技术独立、数据独立、部署独立<br>4、隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</p><p><strong>缺点</strong>：不同的功能都做成了服务集群，方法之间不再那么方便互相调用了，因此我们需要进行服务的治理。</p><p>微服务架构解决了单体架构存在的问题，特别适合大型互联网项目的开发，因此被各大互联网公司普遍采用。大家以前可能听说过分布式架构，分布式就是服务拆分的过程，其实微服务架构正是分布式架构的一种最佳实践的方案。</p><h3 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h3><img src="/2024/10/08/springcloud/2310d1c901b6a9822ecdad5f634da19a.png" alt="img" style="zoom:67%;"><ul><li><strong>注册中心</strong>： 维护微服务中每个结点的信息，并且监控结点的状态。</li><li><strong>配置中心</strong>： 它可以统一去管理整个服务群体成千上百的这些配置。如果以后有些配置需要变更，只需要去找到配置中心便可。它可以去通知相关的微服务，实现配置的“热更新”。</li><li><strong>服务网关</strong>： 由网关将用户请求路由到微服务群，在路由过程中可以做负载均衡。<br>路由或者服务之间调用时做好服务的容错处理，避免因服务故障带来的级联失败。还要做好服务保护，隔离等措施。</li></ul><h3 id="SpringCloud-1"><a href="#SpringCloud-1" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><p>微服务拆分以后碰到的各种问题都有对应的解决方案和微服务组件，而SpringCloud框架可以说是目前Java领域最全面的微服务组件的集合了。</p><ul><li>SpringCloud是目前国内使用最广泛的微服务框架。<a href="https://spring.io/projects/spring-cloud">官网地址</a></li><li>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:</li></ul><table><thead><tr><th align="left"><strong>SpringCloud版本</strong></th><th align="left"><strong>SpringBoot版本</strong></th></tr></thead><tbody><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes">2022.0.x</a> aka Kilburn</td><td align="left">3.0.x</td></tr><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes">2021.0.x</a> aka Jubilee</td><td align="left">2.6.x, 2.7.x (Starting with 2021.0.3)</td></tr><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes">2020.0.x</a> aka Ilford</td><td align="left">2.4.x, 2.5.x (Starting with 2020.0.3)</td></tr><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td align="left">2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td align="left">2.1.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td align="left">2.0.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td align="left">1.5.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td align="left">1.5.x</td></tr></tbody></table><h3 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h3><p>目标：</p><blockquote><p>1、单一职责：不同微服务，不要重复开发相同业务，要保证微服务内部业务的完整性<br>2、数据独立：不要访问其它微服务的数据，否则会导致数据耦合<br>3、面向服务：将自己的业务暴露为接口，尽量保证接口外观不变，供其它微服务调用</p></blockquote><p>方式：</p><ul><li><strong>纵向拆分</strong>：按照项目的功能模块来拆分一个个服务。尽可能提高服务的内聚性。</li><li><strong>横向拆分</strong>：各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。</li></ul><p>一般微服务项目有两种不同的<strong>工程结构</strong>：</p><ul><li><strong>完全解耦</strong>：每一个微服务都创建为一个独立的工程，甚至可以使用不同的开发语言来开发，项目完全解耦。<ul><li>优点：服务之间耦合度低</li><li>缺点：每个项目都有自己的独立仓库，管理起来比较麻烦</li></ul></li><li><strong>Maven聚合</strong>：整个项目为一个Project，然后<strong>每个微服务是其中的一个Module</strong><ul><li>优点：项目代码集中，管理和运维方便（授课也方便）</li><li>缺点：服务之间耦合，编译时间较长</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><img src="/2024/10/08/springcloud/image-20241104102557229.png" alt="image-20241104102557229" style="zoom:67%;"><ul><li>将原始单体架构中的依赖项、配置信息、属于该服务的controller，service，mapper等复制到当前module</li><li>根据当前业务需要删除或新增（修改）依赖项/配置项</li><li>注意修改代码中引入的包的路径，包括sql语句引用的mapper路径</li><li><strong>特别注意：不同业务间有数据或服务调用的，不能再通过依赖注入的方式调用，需要做远程服务调用（见下方子标题）</strong></li></ul><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><img src="/2024/10/08/springcloud/image-20241104103234051.png" alt="image-20241104103234051" style="zoom:67%;"><p>就是购物车业务中需要查询商品信息，但商品信息查询的逻辑全部迁移到了<code>item-service</code>服务，导致我们无法查询。</p><p>最终结果就是查询到的购物车数据不完整，因此要想解决这个问题，我们就必须改造其中的代码，<strong>把原本本地方法调用，改造成跨微服务的远程调用</strong>（RPC，即<strong>R</strong>emote <strong>P</strong>roduce <strong>C</strong>all）。</p><p>回顾一下http请求原理，简单来说无非就是浏览器发出http请求信息，而服务中利用@GetMapping去接受请求，查询数据库后返还相应的信息给前端。因此，应该思考如何使得java代码发出http请求。</p><h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><p>Spring提供了一个工具叫做<strong>RestTemplate</strong>，专门用于在java代码中发起http请求。</p><ul><li>spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接，我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。</li><li>RestTemplate默认依赖JDK提供http连接的能力（HttpURLConnection），如果有需要的话也可以通过setRequestFactory方法替换为例如Apache HttpComponents、Netty或OkHttp等其它HTTP library。</li><li>其实spring并没有真正的去实现底层的http请求（3次握手），而是集成了别的http请求，spring只是在原有的各种http请求进行了规范标准，让开发者更加简单易用，底层默认用的是jdk的http请求。</li></ul><p>优点：连接池、超时时间设置、支持异步、请求和响应的编解码</p><p>缺点：依赖别的spring版块、参数传递不灵活</p><p><strong>使用–主要方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 在特定的<span class="token constant">URL</span>上对资源执行<span class="token constant">HTTP</span> <span class="token constant">DELETE</span>操作<span class="token function">exchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 在<span class="token constant">URL</span>上执行特定的<span class="token constant">HTTP</span>方法，返回包含对象的<span class="token class-name">ResponseEntity</span>，这个对象是从响应体中 映射得到的<span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 在<span class="token constant">URL</span>上执行特定的<span class="token constant">HTTP</span>方法，返回一个从响应体映射得到的对象<span class="token function">getForEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 发送一个<span class="token constant">HTTP</span> <span class="token constant">GET</span>请求，返回的<span class="token class-name">ResponseEntity</span>包含了响应体所映射成的对象<span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 发送一个<span class="token constant">HTTP</span> <span class="token constant">GET</span>请求，返回的请求体将映射为一个对象<span class="token function">postForEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token constant">POST</span> 数据到一个<span class="token constant">URL</span>，返回包含一个对象的<span class="token class-name">ResponseEntity</span>，这个对象是从响应体中映射得到的<span class="token function">postForObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token constant">POST</span> 数据到一个<span class="token constant">URL</span>，返回根据响应体匹配形成的对象<span class="token function">headForHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 发送<span class="token constant">HTTP</span> <span class="token constant">HEAD</span>请求，返回包含特定资源<span class="token constant">URL</span>的<span class="token constant">HTTP</span>头<span class="token function">optionsForAllow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 发送<span class="token constant">HTTP</span> <span class="token constant">OPTIONS</span>请求，返回对特定<span class="token constant">URL</span>的<span class="token class-name">Allow</span>头信息<span class="token function">postForLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token constant">POST</span> 数据到一个<span class="token constant">URL</span>，返回新创建资源的<span class="token class-name">URL</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token constant">PUT</span> 资源到特定的<span class="token constant">URL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.将RestTemplate注入到spring容器中。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">ClientHttpRequestFactory</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">SimpleClientHttpRequestFactory</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">RestTemplate</span></span><span class="token punctuation">;</span><span class="token comment">/** * RestTemplate配置类 */</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RestTemplateConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token class-name">ClientHttpRequestFactory</span> factory<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">ClientHttpRequestFactory</span> <span class="token function">simpleClientHttpRequestFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">SimpleClientHttpRequestFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleClientHttpRequestFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setReadTimeout</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//单位为ms</span>        factory<span class="token punctuation">.</span><span class="token function">setConnectTimeout</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//单位为ms</span>        <span class="token keyword">return</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.远程调用</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleCartItems</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CartVO</span><span class="token punctuation">&gt;</span></span> vos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// TODO 1.获取商品id</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> itemIds <span class="token operator">=</span> vos<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">CartVO</span><span class="token operator">::</span><span class="token function">getItemId</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.查询商品</span>    <span class="token comment">// List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);</span>    <span class="token comment">// 2.1.利用RestTemplate发起http请求，得到http的响应</span>    <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> response <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>            <span class="token string">"http://localhost:8081/items?ids={ids}"</span><span class="token punctuation">,</span><span class="token comment">// 请求路径</span>            <span class="token class-name">HttpMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span><span class="token comment">// 请求方式</span>            <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token comment">// 请求实体</span>            <span class="token keyword">new</span> <span class="token class-name">ParameterizedTypeReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">// 返回值类型</span>            <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"ids"</span><span class="token punctuation">,</span> <span class="token class-name">CollUtil</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>itemIds<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 请求参数</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.2.解析响应</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>response<span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">is2xxSuccessful</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 查询失败，直接结束</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span></span> items <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">CollUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 3.转为 id 到 item的map</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span></span> itemMap <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token class-name">ItemDTO</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.写入vo</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">CartVO</span> v <span class="token operator">:</span> vos<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ItemDTO</span> item <span class="token operator">=</span> itemMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">getItemId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        v<span class="token punctuation">.</span><span class="token function">setNewPrice</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v<span class="token punctuation">.</span><span class="token function">setStock</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个过程中，<code>item-service</code>提供了查询接口，<code>cart-service</code>利用Http请求调用该接口。因此<code>item-service</code>可以称为服务的提供者，而<code>cart-service</code>则称为服务的消费者或服务调用者。</p><h3 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h3><p>上一节内容中服务调用存在问题，服务调用使用http请求，网址直接定死了，<strong>如果我们有多个服务集群（多实例部署），亦或是网址在后续开发过程中出现变更，就会产生不方便。</strong></p><blockquote><p>服务提供者：一次业务中，被其它微服务调用的服务（提供接口给其他微服务）<br>服务消费者：一次业务中，调用其它微服务的服务（调用其它微服务提供的接口）</p><p>提供者与消费者的概念是相对的，<strong>一个服务既可以是提供者也可以是消费者</strong>。</p><p>服务消费者该如何获取服务提供者的地址信息？<br>如果有多个服务提供者，消费者该如何选择？<br>消费者如何得知服务提供者的健康状态？<br>新增的服务提供者如何被消费者感知？</p></blockquote><img src="/2024/10/08/springcloud/image-20241104113255813.png" alt="image-20241104113255813" style="zoom: 50%;"><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><img src="/2024/10/08/springcloud/image-20241104113924738.png" alt="image-20241104113924738" style="zoom: 50%;"><p>流程如下：</p><ul><li>服务启动时就会<strong>注册自己的服务信息</strong>（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心<strong>订阅</strong>想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表<strong>负载均衡</strong>，挑选一个实例</li><li>调用者向该实例发起<strong>远程调用</strong></li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会<strong>定期向注册中心发送请求，报告自己的健康状态</strong>（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中<strong>剔除</strong></li><li>当服务有新实例启动时，会<strong>发送注册服务请求</strong>，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心<strong>服务列表变更时，会主动通知微服务</strong>，更新本地服务列表<ul><li>微服务通常会维护一个<strong>本地缓存的服务列表</strong>，用于优化服务调用的性能（避免每次调用时都从注册中心获取）。当注册中心通知微服务服务列表变更时，微服务会根据收到的增量更新，及时刷新它们本地缓存的服务列表。这样，在下一次进行跨服务调用时，微服务可以确保使用的是最新的服务实例信息。</li></ul></li></ul><h4 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h4><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</li><li>Consul：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</li></ul><p>以上几种注册中心都遵循SpringCloud中的API规范，因此在业务开发使用上没有太大差异。由于Nacos是国内产品，中文文档比较丰富，而且同时具备<strong>配置管理</strong>功能（后面会学习），因此在国内使用较多。</p><p><strong>Nacos部署</strong>：</p><p><a href="https://b11et3un53m.feishu.cn/wiki/R4Sdwvo8Si4kilkSKfscgQX0niB">‌﻿⁠﻿﻿‬‌⁠‬﻿﻿‍﻿﻿﻿⁠‌‍‌‬‬﻿⁠﻿‌⁠day03-微服务01 - 飞书云文档</a></p><p><a href="https://blog.csdn.net/u013737132/article/details/132592040">Linux 通过 Docker 部署 Nacos 2.2.3 服务发现与配置中心_nacos2.2.3虚拟机安装详情-CSDN博客</a></p><img src="/2024/10/08/springcloud/image-20241104161640633.png" alt="image-20241104161640633" style="zoom:67%;"><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>将特定service注册到nacos：1.引入依赖；2.配置Nacos地址；3.重启实例</p><p><code>pom.xml</code>中添加依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--nacos 服务注册发现--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>application.yml</code>中添加nacos地址配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> item<span class="token punctuation">-</span>service <span class="token comment"># 服务名称</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment"># nacos地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：1.引入依赖；2.配置Nacos地址；3.发现并调用服务</p><ul><li>服务发现除了要引入nacos依赖（和服务注册的依赖一样）以外，由于还需要<strong>负载均衡</strong>，因此要引入SpringCloud提供的LoadBalancer依赖。</li><li>配置nacos地址–和服务注册的配置一样。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。所以依赖和配置都是一样的。</li><li>服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：随机，轮询，IP的hash，最近最少访问等。服务发现需要用到一个工具，DiscoveryClient，SpringCloud已经帮我们自动装配，我们可以直接注入使用：</li></ul><img src="/2024/10/08/springcloud/image-20241104174127926.png" alt="image-20241104174127926" style="zoom:67%;"><h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p>RestTemplate的问题：</p><blockquote><p>1、代码可读性差，方法调用不统一（一会远程调用，一会本地接口调用）<br>2、url参数比较复杂，难以维护</p></blockquote><p>因此，我们必须想办法改变远程调用的开发模式，让<strong>远程调用像本地方法调用一样简单</strong>。而这就要用到OpenFeign组件了。</p><p>Feign是一个声明式的http客户端，我们只需要把发http请求所需要的信息声明出来即可，剩下的东西都交给Feign来实现。</p><p>1.引入feign依赖和负载均衡器：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--openFeign--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--负载均衡器--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-loadbalancer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.在微服务的Application启动类添加开启Feign的功能：加注解@EnableFeignClients</p><p>3.编写feign客户端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">"userservice"</span><span class="token punctuation">)</span> <span class="token comment">//声明出服务名称</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/{id}"</span><span class="token punctuation">)</span>    <span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要是基于SpringMVC的注解来声明远程调用的信息</p><ul><li><code>@FeignClient("item-service")</code> ：声明服务名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping("/items")</code> ：声明请求路径</li><li><code>@RequestParam("ids") Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul><p>4.使用feign客户端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">OrderMapper</span> orderMapper<span class="token punctuation">;</span><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">UserClient</span> userClient<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//查询订单</span>    <span class="token class-name">Order</span> order <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//根据用户id来查询用户，用Feign实现远程调用</span>    <span class="token class-name">User</span> user <span class="token operator">=</span> userClient<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将用户注入到order中</span>    order<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.返回</span>    <span class="token keyword">return</span> order<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>网关的作用：<strong>身份认证和权限校验</strong>：通过才能去访问微服务；<strong>服务路由</strong>：当通过网关后，还需要根据请求的类型，将请求转发到对应的微服务中；<strong>负载均衡</strong>：确定了转发的微服务之后，微服务中的多个实例之间还应该做负载均衡；<strong>请求限流</strong>：限制访问的请求量</p><ul><li>统一配置管理，解决微服务的配置文件重复和配置热更新问题。</li></ul><p>在SpringCloud当中，提供了两种网关实现方案：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li></ul><h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><blockquote><p>网关路由，解决前端请求不同数据时要访问不同的入口，需要维护多个入口地址的问题。</p></blockquote><p>1.创建网关微服务</p><p>2.引入SpringCloudGateway、NacosDiscovery依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--网关--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--nacos discovery--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--负载均衡--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-loadbalancer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.编写启动类</p><p>4.编写网关的路由配置及Nacos地址（application.yaml）</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8848</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> item <span class="token comment"># 路由规则id，自定义，唯一</span>          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//item<span class="token punctuation">-</span>service <span class="token comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span>          <span class="token key atrule">predicates</span><span class="token punctuation">:</span> <span class="token comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span>            <span class="token punctuation">-</span> Path=/items/<span class="token important">**</span><span class="token punctuation">,</span>/search/<span class="token important">**</span> <span class="token comment"># 这里是以请求路径作为判断规则</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> cart          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//cart<span class="token punctuation">-</span>service          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> Path=/carts/<span class="token important">**</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//user<span class="token punctuation">-</span>service          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> Path=/users/<span class="token important">**</span><span class="token punctuation">,</span>/addresses/<span class="token important">**</span><span class="token comment"># 路径满足/user/开头的就符合要求，托管给userservice服务</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> trade          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//trade<span class="token punctuation">-</span>service          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> Path=/orders/<span class="token important">**</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> pay          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//pay<span class="token punctuation">-</span>service          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> Path=/pay<span class="token punctuation">-</span>orders/<span class="token important">**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>网关本身并没有做什么操作，但是可以访问到相应信息，也就是说网关只是把请求转发给微服务。</p><img src="/2024/10/08/springcloud/image-20241106103631894.png" alt="image-20241106103631894" style="zoom: 50%;"><h4 id="路由断言"><a href="#路由断言" class="headerlink" title="路由断言"></a>路由断言</h4><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被断言工厂（Predicate Factory）读取并处理，转变为路由判断的条件。</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie=chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header=X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">- Host=**.somehost.org,**.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method=GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path=/red/{segment},/blue/**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query=name, Jack或者- Query=name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr=192.168.1.1/24</td></tr><tr><td align="left">weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table><h3 id="网关登录校验"><a href="#网关登录校验" class="headerlink" title="网关登录校验"></a>网关登录校验</h3><blockquote><p>网关鉴权，解决统一登录校验和用户信息获取的问题。</p></blockquote><p>我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：</p><ul><li>每个微服务都需要知道JWT的秘钥，不安全</li><li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li></ul><p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：只需要在网关和用户服务保存秘钥；只需要在网关开发登录校验功能。</p><img src="/2024/10/08/springcloud/image-20241106104942057.png" alt="image-20241106104942057" style="zoom: 50%;"><h4 id="网关过滤器"><a href="#网关过滤器" class="headerlink" title="网关过滤器"></a>网关过滤器</h4><p>Gateway内部工作流程：</p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的<strong>路由规则</strong>（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理。</li><li><code>WebHandler</code>则会加载当前路由下需要执行的<strong>过滤器链</strong>（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）。</li><li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li><strong>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</strong></li><li>最终把响应结果返回。</li></ol><p>最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。<strong>如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<code>NettyRoutingFilter</code>之前</strong>，这就符合我们的需求了</p><p>网关过滤器链中的过滤器有两种：</p><ul><li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code>. </li><li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由，不可配置。</li></ul><blockquote><p>过滤器链之外还有一种过滤器，HttpHeadersFilter，用来处理传递到下游微服务的请求头。例如org.springframework.cloud.gateway.filter.headers.XForwardedHeadersFilter可以传递代理请求原本的host头到下游微服务。</p></blockquote><p><strong>使用</strong></p><p><code>Gateway</code>中内置了很多的<code>GatewayFilter</code>，详情可以参考官方文档：</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories</a></p><p><code>Gateway</code>内置的<code>GatewayFilter</code>过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个<code>Route</code>下，就作用于哪个<code>Route</code>.</p><p>例如，有一个过滤器叫做<code>AddRequestHeaderGatewayFilterFacotry</code>，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。</p><p>实际的使用只需要在application.yaml中这样配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> test_route        <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//test<span class="token punctuation">-</span>service        <span class="token key atrule">predicates</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span>Path=/test/<span class="token important">**</span>        <span class="token key atrule">filters</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> AddRequestHeader=key<span class="token punctuation">,</span> value <span class="token comment"># 逗号之前是请求头的key，逗号之后是value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证是否增加了该请求头，在test服务中获取并打印：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">,</span> <span class="token annotation punctuation">@RequestHeader</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"Truth"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token class-name">String</span> truth<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"truth = "</span> <span class="token operator">+</span> truth<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而如果我们希望全局都可以增加这个过滤器，也就是全局都会增加这个请求头，只需要：</p><img src="/2024/10/08/springcloud/image-20241106111049279.png" alt="image-20241106111049279" style="zoom: 80%;"><h4 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h4><blockquote><p>无论是<code>GatewayFilter</code>还是<code>GlobalFilter</code>都支持自定义，只不过<strong>编码</strong>方式、<strong>使用</strong>方式略有差别。</p></blockquote><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code>。(<strong>该类的名称一定要以<code>GatewayFilterFactory</code>为后缀</strong>)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintAnyGatewayFilterFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractGatewayFilterFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">GatewayFilter</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Object</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">GatewayFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 获取请求</span>                <span class="token class-name">ServerHttpRequest</span> request <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 编写过滤器逻辑</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"过滤器执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 放行</span>                <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">default-filters</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> PrintAny <span class="token comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>动态配置参数：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintAnyGatewayFilterFactory</span> <span class="token comment">// 父类泛型是内部类的Config类型</span>                <span class="token keyword">extends</span> <span class="token class-name">AbstractGatewayFilterFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PrintAnyGatewayFilterFactory<span class="token punctuation">.</span>Config</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">GatewayFilter</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Config</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span>        <span class="token comment">// - GatewayFilter：过滤器</span>        <span class="token comment">// - int order值：值越小，过滤器执行优先级越高</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrderedGatewayFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GatewayFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 获取config值</span>                <span class="token class-name">String</span> a <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> b <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> c <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 编写过滤器逻辑</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b = "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"c = "</span> <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 放行</span>                <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// ==========自定义配置属性，成员变量名称很重要，下面会用到===========</span>    <span class="token annotation punctuation">@Data</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Config</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> a<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> b<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">shortcutFieldOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 返回当前配置类的类型，也就是内部的Config</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Config</span><span class="token punctuation">&gt;</span></span> <span class="token function">getConfigClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Config</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>yaml中配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">default-filters</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> PrintAny=1<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token comment"># 注意，这里多个参数以","隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义GlobalFilter：直接实现GlobalFilter即可，而且也无法设置动态参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintAnyGlobalFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span><span class="token punctuation">,</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 编写过滤器逻辑</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未登录，无法访问"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 放行</span>        <span class="token comment">// return chain.filter(exchange);</span>        <span class="token comment">// 拦截</span>        <span class="token class-name">ServerHttpResponse</span> response <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setRawStatusCode</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 过滤器执行顺序，值越小，优先级越高</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过滤器链执行顺序"><a href="#过滤器链执行顺序" class="headerlink" title="过滤器链执行顺序"></a>过滤器链执行顺序</h4><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter。<br>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter合并到一个过滤器链中，排序后依次执行每个过滤器。</p><p>排序的规则：</p><blockquote><p>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前：<br>（1）GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由自己决定<br>（2）路由过滤器和defaultFilter的order是由Spring指定的，是按照配置文件中的声明顺序来递增的<br>当过滤器的order值一样时，会按照defaultFilter＞路由过滤器＞GlobalFilter的顺序执行</p></blockquote><h4 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">AuthProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthGlobalFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span><span class="token punctuation">,</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">JwtTool</span> jwtTool<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AuthProperties</span> authProperties<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AntPathMatcher</span> antPathMatcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AntPathMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1.获取Request</span>        <span class="token class-name">ServerHttpRequest</span> request <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.判断是否不需要拦截</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isExclude</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 无需拦截，直接放行</span>            <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 3.获取请求头中的token</span>        <span class="token class-name">String</span> token <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> headers <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">CollUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            token <span class="token operator">=</span> headers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 4.校验并解析token</span>        <span class="token class-name">Long</span> userId <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            userId <span class="token operator">=</span> jwtTool<span class="token punctuation">.</span><span class="token function">parseToken</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnauthorizedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 如果无效，拦截</span>            <span class="token class-name">ServerHttpResponse</span> response <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            response<span class="token punctuation">.</span><span class="token function">setRawStatusCode</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// ==================== TODO 5.如果有效，传递用户信息 ==============================</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"userId = "</span> <span class="token operator">+</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 6.放行</span>        <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isExclude</span><span class="token punctuation">(</span><span class="token class-name">String</span> antPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> pathPattern <span class="token operator">:</span> authProperties<span class="token punctuation">.</span><span class="token function">getExcludePaths</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>antPathMatcher<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>pathPattern<span class="token punctuation">,</span> antPath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="用户信息传递"><a href="#用户信息传递" class="headerlink" title="用户信息传递"></a>用户信息传递</h4><blockquote><p>由于网关发送请求到微服务依然采用的是<code>Http</code>请求，因此我们可以<strong>将用户信息以请求头的方式传递到下游微服务</strong>。然后微服务可以<strong>从请求头中获取登录用户信息</strong>。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。</p></blockquote><p>1.保存用户信息到请求头</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 发送给前端新token</span>response<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 暴露头</span>response<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Expose-Headers"</span><span class="token punctuation">,</span> <span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将当前请求头中已经过期的token替换成新的token</span><span class="token comment">// 将新的token转发给微服务</span><span class="token class-name">ServerHttpRequest<span class="token punctuation">.</span>Builder</span> requestBuilder <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 先删除，后新增</span>requestBuilder<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span>k <span class="token operator">-&gt;</span> k<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"Authorization"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>requestBuilder<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Authorization"</span><span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ServerHttpRequest</span> requestNew <span class="token operator">=</span> requestBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>exchange<span class="token punctuation">.</span><span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>requestNew<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.拦截器获取用户</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>hmall<span class="token punctuation">.</span>common<span class="token punctuation">.</span>interceptor</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">cn<span class="token punctuation">.</span>hutool<span class="token punctuation">.</span>core<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">StrUtil</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>hmall<span class="token punctuation">.</span>common<span class="token punctuation">.</span>utils<span class="token punctuation">.</span></span><span class="token class-name">UserContext</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">HandlerInterceptor</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletRequest</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletResponse</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserInfoInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 1.获取请求头中的用户信息</span>        <span class="token class-name">String</span> userInfo <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"user-info"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.判断是否为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 不为空，保存到ThreadLocal</span>                <span class="token class-name">UserContext</span><span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 3.放行</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 移除用户</span>        <span class="token class-name">UserContext</span><span class="token punctuation">.</span><span class="token function">removeUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>黑马SpringCloud：<a href="https://www.bilibili.com/video/BV1S142197x7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">2024最新SpringCloud微服务开发与实战，java黑马商城项目微服务实战开发（涵盖MybatisPlus、Docker、MQ、ES、Redis高级等）_哔哩哔哩_bilibili</a></p><p>配套文档：<a href="https://b11et3un53m.feishu.cn/wiki/space/7229522334074372099?ccm_open_type=lark_wiki_spaceLink&amp;open_tab_from=wiki_home">https://b11et3un53m.feishu.cn/wiki/space/7229522334074372099?ccm_open_type=lark_wiki_spaceLink&amp;open_tab_from=wiki_home</a></p><p>docker：<a href="https://blog.csdn.net/qq_41196612/article/details/131083964">docker全流程使用指南_docker工作流程-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_52380556/article/details/135483179?spm=1001.2014.3001.5502">一文快速学会Docker软件部署-CSDN博客</a></p><p>狂神说Nginx：<a href="https://www.kuangstudy.com/bbs/1353634800149213186">Nginx快速入门-KuangStudy-文章</a></p><p><a href="https://blog.csdn.net/hyfsbxg/article/details/122322125">Nginx详解（一文带你搞懂Nginx）-CSDN博客</a></p><p>微服务：<a href="https://blog.csdn.net/Eumenides_Suki/article/details/128487022">【1.2】认识微服务–微服务技术对比&amp;SpringCloud_springclould 和其他微服务框架比较-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_52380556/article/details/135583389?spm=1001.2014.3001.5502">详解SpringCloud微服务技术栈：认识微服务、服务拆分与远程调用_spring微服务之间调用-CSDN博客</a></p><p>docker部署minio：<a href="https://blog.csdn.net/Darling_qi/article/details/124743303">SpringBoot整合MinIO 「看这一篇就够了」_minio getpresignedobjecturl 预览图片-CSDN博客</a></p><p><a href="https://blog.csdn.net/BThinker/article/details/125412751">Docker 搭建 Minio 容器 (完整详细版)_docker minio-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud&quot;&gt;&lt;a href=&quot;#SpringCloud&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud&quot;&gt;&lt;/a&gt;SpringCloud&lt;/h1&gt;&lt;h2 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://wolf-ll.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="框架" scheme="http://wolf-ll.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="微服务" scheme="http://wolf-ll.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>多模态信息处理</title>
    <link href="http://wolf-ll.github.io/2024/09/09/duo-mo-tai-xin-xi-chu-li/"/>
    <id>http://wolf-ll.github.io/2024/09/09/duo-mo-tai-xin-xi-chu-li/</id>
    <published>2024-09-09T06:22:20.000Z</published>
    <updated>2024-10-12T06:42:48.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多模态信息处理"><a href="#多模态信息处理" class="headerlink" title="多模态信息处理"></a>多模态信息处理</h1><h2 id="综述（2022）"><a href="#综述（2022）" class="headerlink" title="==综述（2022）=="></a>==综述（2022）==</h2><p>《多模态信息处理前沿综述：应用、融合和预训练》 2022</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>人工智能研究经过70多年的探索，在视觉、语音与声学、语言理解与生成等单模态人工智能领域已取得了巨大的突破。</li><li>近些年，如何让计算机拥有更接近人类的理解和处理多模态信息的能力，进而实现高鲁棒性的推理决策成为热点问题。</li><li>各种应用的涌现，对多模态信息处理技术在用户理解、内容理解和场景理解上提出了更高的要求，同时也给多模态技术提供了海量的数据和丰富的应用场景。</li><li>多模态核心技术又分为：<strong>多模态表示（Representation）、多模态融合（Fusion）、多模态转换（Translation）、多模态对齐（Alignment）和模态协同学习（Co-learning）</strong></li><li>本文从自然语言处理的视角出发，介绍多模态信息处理技术的最新进展，组织结构如下：第１节介绍NLP领域关注度较高的多模态应用和相关的数据集。多模态融合是多模态信息处理的核心问题。第２节从单模态信息的表示方法、多模态信息的融合阶段、融合模型的网络结构、未对齐模态和模态缺失情况下的多模态融合等角度介绍主流的多模态融合方法。第３节介绍多模态预训练技术，并从模型的网络结构、模型的输入、预训练目标、预训练语料和下游任务等维度对比最新提出的多模态预训练模型。第４节介绍多模态技术在工业界的应用。最后一节是总结和对未来工作的展望。</li></ul><h2 id="多模态应用"><a href="#多模态应用" class="headerlink" title="多模态应用"></a>多模态应用</h2><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909145625058.png" alt="image-20240909145625058" style="zoom: 33%;"><h3 id="多模态情感识别"><a href="#多模态情感识别" class="headerlink" title="多模态情感识别"></a>多模态情感识别</h3><ul><li>在交互场景下，多模态情感识别研究如何从<strong>人的表情和动作手势、语音音调、语言</strong>等多模态信息中理解用户细颗粒度的情感表达，进而指导人机交互策略。</li><li>其主要研究内容有：<strong>①基于多模态信息互补性和异步性的动态融合；</strong>②高噪声环境下对于<strong>模态模糊或模态缺失问题</strong>的鲁棒性融合；③客服和营销等<strong>自然交互情境</strong>下的情感识别等。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909151102370.png" alt="image-20240909151102370" style="zoom:67%;"><h3 id="视觉-语言生成"><a href="#视觉-语言生成" class="headerlink" title="视觉-语言生成"></a>视觉-语言生成</h3><ul><li>视觉（图像或视频）到语言的生成和语言到视觉（图像或视频）的生成打破了计算机视觉和自然语言处理两个领域的边界</li><li>2021年初，OpenAI推出的基于GPT-3的语言到视觉的生成模型DALL-E可以根据自然语言的描述生成逼真的图像</li></ul><h4 id="图像描述"><a href="#图像描述" class="headerlink" title="图像描述"></a>图像描述</h4><ul><li>图像描述（Image Captioning）是<strong>对给定的一幅自然图像生成一句自然语言描述的任务。</strong></li><li>2015以前：基于模板–监测图像物体、动作，填充到模板主谓宾结构</li><li>2015以后：通过从视觉图像中解析出属性、关系和结构（hierarchy）等高层语义信息，并将这些语义信息融入<strong>视觉编码和语言解码</strong>中，提高了图像描述的生成效果。</li></ul><h4 id="视频描述"><a href="#视频描述" class="headerlink" title="**视频描述"></a>**视频描述</h4><ul><li>视频描述（Video Captioning）是对给定的一段视频（通常是几十秒的短视频）生成一句准确、细致描述的任务。</li><li>包含<strong>图像、声音、时序</strong>等信息。视频描述可提取的特征更多，技术挑战也更大。</li><li>ACTIONS是首个无需人工标注、从数以亿计的网页内容中自动提炼“视频，描述”对的视频描述数据集，总共包含了163183个GIF视频。</li></ul><h4 id="视觉叙事"><a href="#视觉叙事" class="headerlink" title="视觉叙事"></a>视觉叙事</h4><ul><li>视觉叙事（Visual Story Telling）要求模型对于给定的图像序列，在深度理解图像序列的基础上<strong>生成连贯的叙事故事</strong>。</li><li>视觉叙事的输入是<strong>有时序关联的图像序列</strong>，需要模型具备<strong>根据历史视觉事件推测当前的视觉事件</strong>的能力。</li><li>对比图像描述和视频描述中的客观文字描述，视觉叙事的输出由更多评价性、会话性和抽象性语言组成。</li></ul><h3 id="视觉问答和多模态对话"><a href="#视觉问答和多模态对话" class="headerlink" title="视觉问答和多模态对话"></a>视觉问答和多模态对话</h3><h4 id="视觉问答（VQA）"><a href="#视觉问答（VQA）" class="headerlink" title="视觉问答（VQA）"></a>视觉问答（VQA）</h4><ul><li>给定一幅图像和一个关于该图像的开放式自然语言问题，要求模型准确回答该问题</li><li>视觉问答是一个典型的多模态问题，需要模型具备<strong>物体定位、属性检测、事件分类、场景理解和推理及数学计算</strong>等能力。</li><li>根据图片类型不同，VQA又分为自然图像理解VQA、合成图像推理VQA和自然图像推理VQA</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909151819273.png" alt="image-20240909151819273" style="zoom:67%;"><h4 id="视觉对话"><a href="#视觉对话" class="headerlink" title="**视觉对话"></a>**视觉对话</h4><ul><li>视觉对话（Visual DIalog）是给定一幅图像（或视频等视觉内容）和一个上下文相关的问题，要求模型根据图片（或视频）内容回答该问题。</li><li>与视觉问答相比，视觉对话还要解决对话中特有的挑战，如共指（Co-references）和省略（Ellipsis）等。</li><li>视觉对话中的用户问题只与单个图像（视频）相关，且用户问题和模型回答都是文字的。</li></ul><h4 id="多模态对话"><a href="#多模态对话" class="headerlink" title="多模态对话"></a>多模态对话</h4><ul><li>多模态对话（Multi-model Dialog）关注更接近人类自然对话的多模态人机对话技术研究。它与上一节介绍视觉对话的主要差异有：<ul><li>①多模态对话给定的输入图像可能是多幅的；</li><li>② 随着对话的推进，<strong>图像是不断更新的；</strong></li><li>③用户问题和模型的回答可以是<strong>文本的、图像的或者图文结合的；</strong></li><li>④模型可能需要查询外部领域知识库才能回答用户的问题（如购物者希望看到更多与特定商品相似的商品，或者要求提供满足某些特征的商品，或者查询特定商品的属性等）；</li><li>⑤模型可能需要通过反问等对话策略澄清用户需求。</li></ul></li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909151958971.png" alt="image-20240909151958971" style="zoom:67%;"><h3 id="多模态摘要"><a href="#多模态摘要" class="headerlink" title="多模态摘要"></a>多模态摘要</h3><ul><li><p>多模态摘要是基于对多模态输入（文本、语音、图像和视频等）的理解，归纳并生成单模态或者多模态的概括性总结（摘要）任务。</p></li><li><p>根据具体任务类型，多模态摘要又可细分为<strong>视频会议摘要、教学视频摘要、多模态新闻摘要 和多模态商品摘要</strong></p></li></ul><h3 id="多模态对齐"><a href="#多模态对齐" class="headerlink" title="**多模态对齐"></a>**多模态对齐</h3><ul><li>多模态对齐研究多个模态不同颗粒度元素间的对齐关系，具体又分为显式对齐和隐式对齐。</li><li>视觉－语言跨模态的显式对齐任务研究<strong>图像和句子、图像和词、图像中的目标和句子中的短语间的</strong>对齐关系。</li><li>多模态对齐方法可直接应用于<strong>多模态检索</strong>等应用，也可作为<strong>图像描述、VQA、多模态预训练</strong>的训练语料，尤其是在缺乏大规模多模态人工标注语料的场景。</li><li>Tan等人提出了 Vokenization技术（图３），其通过给文本中的每一个词打上一幅图像的标签，实现在大规模文本语料上自动构建多模态对齐语料库。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909152259522.png" alt="image-20240909152259522" style="zoom: 33%;"><h4 id="图像短语定位"><a href="#图像短语定位" class="headerlink" title="图像短语定位"></a>图像短语定位</h4><ul><li>图像中的目标和文本中的短语对齐也被称为<strong>图像短语定位</strong>（Phrase Grounding），可用于提高图像描述、VQA、视觉导航等视觉-语言下游任务的性能。</li><li>Plummer等人发布了一个大规模的短语定位数据集Flickr30kEntities，如图4所示。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909152343325.png" alt="image-20240909152343325" style="zoom:67%;"><h4 id="视频定位"><a href="#视频定位" class="headerlink" title="**视频定位"></a>**视频定位</h4><ul><li>视频定位（Video Grounding）是多模态对齐中另一项重要且具有挑战性的任务。给定一个查询（Query），它要求模型从视频中定位出与查询语言对应的一个目标视频片段。该技术可应用<strong>于视频理解、视频检索和人机交互</strong>等场景。</li></ul><h3 id="多模态翻译"><a href="#多模态翻译" class="headerlink" title="多模态翻译"></a>多模态翻译</h3><ul><li>多模态翻译是将多模态输入（文本、图像或视频等）中的源语言文本转换为目标语言文本的过程。</li><li>Elliott等人将多模态机器翻译分解为两个子任务：<strong>文本翻译 和 基于视觉的文本表示</strong></li><li>Wu等人的研究表明，视觉特征对多模态翻译的帮助来自于正则化，视觉特征的合理选取对模型性能至关重要。</li></ul><h3 id="多模态信息抽取"><a href="#多模态信息抽取" class="headerlink" title="多模态信息抽取"></a>多模态信息抽取</h3><ul><li>命名实体识别（NER）是指识别自由文本中的具体特定意义的实体（如人名、地名和组织机构名等）。</li><li>多模态命名实体识别（ＭＮER）通过引入视觉、语音等其他模态作为文本模态的补充，识别社交媒体中高噪声短文本中的实体。</li><li>模型方面，Moon等人首次提出了融合图像和文本模态信息的通用多模态注意力模型。</li><li>Yu等人首次将 Transformer应用于多模态NER任务中，并提出了实体片段检测辅助任务，进一步消除视觉偏差，提升了模型效果</li></ul><h2 id="多模态融合"><a href="#多模态融合" class="headerlink" title="多模态融合"></a>多模态融合</h2><ul><li>多模态融合将多个单模态表征整合成为一个多模态信息表征，它是多模态信息处理的核心问题。</li><li>多模态融合的研究方向有：基于多模态互补性的全模态融合问题、模态模糊或者模态缺失下的鲁棒性融合问题、非对齐的多模态融合问题等。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909154906558.png" alt="image-20240909154906558" style="zoom: 80%;"><h3 id="根据单模态表示分类"><a href="#根据单模态表示分类" class="headerlink" title="根据单模态表示分类"></a>根据单模态表示分类</h3><ul><li>单模态的特征表示是多模态融合的基石。这一类方法重点研究如何在多模态融合之前提取更好的单模态特征表示。</li><li>以视觉－语言－音频多模态应用为例，如何从<strong>视觉内容中解析出高层语义信息</strong>以增强视觉特征表达是这一类方法的主要研究内容。</li><li>语言表示通常使用词的独热编码表示、词的上下文表示 、句子表示、句法依存关系表示、场景图表示等。</li><li>音频表示可使用基于VOVAREP提取底层声学特征表示、基于预训练模型wav2vec提取低维特征向量表示等。</li></ul><h4 id="视觉全局表示"><a href="#视觉全局表示" class="headerlink" title="视觉全局表示"></a>视觉全局表示</h4><ul><li>视觉全局表示（Global Representation）是从<strong>图像编码器的高层网络提取一个D维静态向量v</strong>表示一幅图像。</li><li>相关工作通常<strong>使用预训练的ResNet对图像编码</strong>，再提取ResNet的最后一个池化层作为视觉全局表示（ResNet152池化层输出是1*2048维向量，即D=2048）。</li><li>视觉全局表示可用来<strong>初始化多模态自动摘要模型的解码器</strong>，或作为一个<strong>特殊的字符与文本字符拼接</strong>，再用递归神经网络对拼接的字符序列编码，或通过注意力机制学习与其他模态特征的<strong>联合表示</strong>等。</li><li>由于视觉全局表示将图像信息压缩到一个静态的向量中，<strong>这可能会导致大量图像细节信息的丢失。</strong></li></ul><h4 id="视觉区域表示"><a href="#视觉区域表示" class="headerlink" title="视觉区域表示"></a>视觉区域表示</h4><ul><li>视觉区域表示（Regional Representation）是从图像编码器的高层网络中提取一组 Ｄ 维向量表示一幅图像。每个 Ｄ 维向量表示图像中特定的大小相同的区域</li><li>视觉区域表示与注意力机制相结合，通过在每一步解码过程中关注不同的图像区域可生成内容丰富的图像描述</li><li>视觉区域表示实现了图像的细颗粒度表示，但是每个特征的感受野大小和形状相同，<strong>同一个目标可能被切分到多个区域中，它无法表达视觉上完整的语义信息。</strong></li></ul><h4 id="视觉目标表示"><a href="#视觉目标表示" class="headerlink" title="视觉目标表示"></a>视觉目标表示</h4><ul><li>视觉目标表示也是用一组Ｄ 维向量表示一幅图像，但每个 Ｄ 维向量表示图像中的一个目标。</li><li>预训练Faster Ｒ-CNN 通常被用来检测目标所在的区域，再使用目标所在区域的视觉特征和边界框（Bounding-box）特征作为该视觉目标表示。</li><li>视觉目标表示通过目标定位与分类实现视觉图像的浅层语义理解，但<strong>它无法刻画图像中多个目标间的语义关系</strong></li></ul><h4 id="视觉场景图表示"><a href="#视觉场景图表示" class="headerlink" title="视觉场景图表示"></a>视觉场景图表示</h4><ul><li>视觉场景图表示（scene graph representation）是用场景图Ｇ=（V，R）表示一幅图像。</li><li>场景图中的节点V={v1, v2…vk}是图像中的目标集合，关系R={r1, r2…rk}是图像中目标和目标间的显式语义关系（如 wearing、eating）、空间位置关系（如 cover、intersect、in）和隐式语义关系的集合。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909155741554.png" alt="image-20240909155741554" style="zoom:67%;"><h3 id="根据融合阶段进行分类"><a href="#根据融合阶段进行分类" class="headerlink" title="根据融合阶段进行分类"></a>根据融合阶段进行分类</h3><ul><li>早期融合的特点是单模态表示学习简单，而多模态融合部分的模型深度大，融合策略复杂。例如，词的独热编码表示和视觉区域表示直接参与多模态融合</li><li>晚期融合的特点是单模态表示学习模型复杂，多模态融合一般采用拼接、按位乘／求平均等简单策略</li><li>在第３节介绍的多模态预训练模型中，基于单流架构（single stream）的预训练模型把融合操作放在早期阶段。</li><li>基于双流架构（two stream）的预训练模型则把融合操作放置在深层模型的中期阶段的多个层中</li></ul><h3 id="根据融合方式进行分类"><a href="#根据融合方式进行分类" class="headerlink" title="根据融合方式进行分类"></a>根据融合方式进行分类</h3><h4 id="门控融合"><a href="#门控融合" class="headerlink" title="门控融合"></a>门控融合</h4><ul><li>基于自编码和自回归的大规模预训练语言模型和在下游任务上的微调相结合是自然语言处理研究和应用的新方法</li><li>Rahman提出了一种多模态适应门（Multi-model Adaptation Gate，MAG）的网络结构将非语言特征（视觉和声学特征）与文本预训练语言模型融合，MAG与BERT结 合 （MAG-BERT）以 及MAG与XLNET结合（ＭＡＧ－ＸＬＮＥＴ）都可以有效融合三 个 模 态 信 息，并在多模态情感识别数据 集CMU-MOSI和CMU-MOSEI上获得当时最优性能。</li></ul><h4 id="注意力融合"><a href="#注意力融合" class="headerlink" title="注意力融合"></a>注意力融合</h4><ul><li>Bahdanau等人在2015年提出的注意力机制是为了让神经机器翻译模型中的<strong>解码器</strong>在每一步解码过程中，有针对性地选择源语言中<strong>“对齐”的词</strong>来指导目标语言的解码，包括全局注意力和局部注意力两种方法。</li><li>Yang等人提出了stacked attention networks（SANs），通过多层视觉注意力机制逐步过滤掉图像中的噪声区域，定位到与答案高度相关的图像区域，从而提高 ＶＱＡ 准确率。</li><li>Anderson等人提出一种“自底向上”和“自顶向下”相结合的注意力机制。具体的，基于Faster R-CNN的“自底向上”的注意力机制提取图像中的兴趣区域，“自顶向下”的注意力机制确定兴趣区域的权重。</li><li>Yu 等人提出了一种类 Transformer 结构的协同注意力机制，可实现文本中的任一词与图像中的任一区域间的完全交互。</li></ul><h4 id="Transformer融合"><a href="#Transformer融合" class="headerlink" title="Transformer融合"></a>Transformer融合</h4><ul><li>BERT凭借着 transformer强大的特征学习能力和掩码语言模型（Masked Language Model）实现双向编码，刷新了多个 NLP任务的最优性能。</li><li>基 于transformer的多模态融合又分为单流模型和双流模模型两大类。 单流模型使用一个transformer在一开始便对多模态信息进行充分的交互。双流模型则对不同的模态使用独立的transformer编码，再通过协同注意力机制实现不同模态间的融合，如图７所示。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909155859453.png" alt="image-20240909155859453" style="zoom: 80%;"><h4 id="图模型融合"><a href="#图模型融合" class="headerlink" title="图模型融合"></a>图模型融合</h4><p>图模型融合方法将不同模态数据建模为图结构，并利用图神经网络（Graph Neural Networks）等方法进行图结构的表示和学习，从而实现对多模态信息的融合和推理。Yin 等人将基于图的多模态融合编码器应用到多模态神经机器翻译模型中，把源语言中的词和图像中的物体放到了同一个图中，再堆叠多个基于图神经网络的多模态融合层（在每一层顺序执行模态内融合和模态间融合）。</p><h2 id="多模态预训练"><a href="#多模态预训练" class="headerlink" title="多模态预训练"></a>多模态预训练</h2><ul><li>通过预训练语言模型从海量无标注数据中学习通用知识，再在下游任务上用少量的标注数据进行微调，已经成为自然语言处理领域成熟的新范式。</li><li>相对于文本预训练语言模型，多模态预训练模型可以更好地对细颗粒度的多模态语义单元（词或者目标）间的相关性进行建模。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240909160214538.png" alt="image-20240909160214538" style="zoom: 67%;"><ul><li><p>从表５中的１１个图像－语言跨模态预训练模型的对比，我们发现的跨模态预训练模型的特点如下</p><ul><li><p>①单流模型和双流模型均被广泛采用。</p></li><li><p>②多模态预训练模型从应用于多模态理解任务或多模态生成任务发展到可兼顾多模态理解和生成两大任务的统一模型。</p></li><li><p>③相对动辄上百 Ｇ 甚至 Ｔ 级别的单模态数据，多模态对齐数据的规模有限。</p><p>最新的多模态预训练模型可以利用互联网上的大规模非对齐的文本数据、图像数据、以及文本－图像对齐数据学习更通用的文本和视觉表示，以提高模型在视觉和语言的理解和生成能力，如 M3P和UNIMO。</p></li><li><p>④多模态预训练模型从仅应用于多模态下游任务发展到可同时应用于单模态下游任务 和 多模态下游任务。</p></li></ul></li></ul><h2 id="多模态大模型"><a href="#多模态大模型" class="headerlink" title="==多模态大模型=="></a>==多模态大模型==</h2><p>多模态大语言模型（MLLM）是近年来以强大的大语言模型（LLM）作为大脑任务的多模态研究热点。MLLM令人惊讶的涌现能力，比如基于图像写故事和无ocr的数学推理，在传统方法中是罕见的，这表明了一条通往人工通用智能的潜在道路。本文旨在对MLLM的最新研究进展进行跟踪和总结。首先，我们提出了MLLM的公式，并描述了它的相关概念。然后，我们讨论了关键的技术和应用，包括多模态指令调整（M-IT）、多模态上下文学习（M-ICL）、多模态思维链（M-CoT）和llm辅助视觉推理（LAVR）。最后，我们讨论了现有的挑战，并指出了很有前景的研究方向。鉴于MLLM的时代才刚刚开始，我们将继续更新这项调查，并希望它能激发更多的研究。</p><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><p>LMM在上下文学习In-Context Learning (ICL)，指令遵循instruction following，以及思维链Chain of Thought (CoT) 等方面都表现良好。但是仅限于理解离散文本，对视觉不敏感。 作为对比，大视觉模型Large Vision Models (LVMs）可以捕获视觉特征，但是推理落后。</p><p>鉴于此，多模态大模型Multimodal Large Language Model (MLLM)应运而生。在形式上，它指的是基于llm的具有接收、推理和输出多模态信息的能力的模型。在MLLM之前，有很多关于多模态的研究，可以分为判别的，生成的。CLIP，作为前者的代表，将视觉和文本信息投射到一个统一的表示空间中，为下游的多模态任务建立了一个桥梁。相比之下，OFA 是后者的代表，它以序列到序列的方式统一了多模态任务。</p><p>MLLM与传统模型相比，有两个具有代表性的特征： (1) MLLM是基于具有十亿尺度参数的LLM，这在以往的模型中是没有的。(2) MLLM使用新的训练范式来充分释放其全部潜力，例如使用多模态指令调优来鼓励模型遵循新的指令。有了这两个特性，MLLM展示了新的功能，比如基于图像编写网站代码，理解模因的深层含义，以及无ocr的数学推理。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>MLLM通常包含以下三个组件：</p><ul><li>A pre-trained modality encoder  一个预训练的<strong>模态编码器</strong>（接收和处理视觉/听觉等信号）</li><li>A pre-trained LLM 一个预训练的<strong>大模型</strong>（理解和推理信号）</li><li>A modality interface to connect them 一个连接他们的<strong>模态接口</strong>（对齐不同的模态）</li><li>一些mllm还包括一个生成器，用于输出除文本之外的其他模式。</li></ul><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240912200539075.png" alt="image-20240912200539075" style="zoom:80%;"><h3 id="模态编码器"><a href="#模态编码器" class="headerlink" title="模态编码器"></a>模态编码器</h3><p>编码器将原始信息，如图像或音频，压缩成一个更紧凑的表示形式。一种常见的方法是，使用一个<strong>预先训练过的编码器</strong>，而不是从头开始进行训练。例如，CLIP通过对图像-文本对的大规模预训练，集成了一个在语义上与文本对齐的视觉编码器。通过对齐预训练，使用这种最初预对齐的编码器与llm对齐更容易。</p><p>表1总结了一系列常用的图像编码器的使用情况。</p><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240912203228022.png" alt="image-20240912203228022" style="zoom:80%;"><p>MiniGPT-4采用了EVA-CLIP编码器，在参数相同的情况下，相比CLIP性能更出色，需要的训练成本更低。而EVA-CLIP的改进主要基于三点：</p><ul><li>EVA-CLIP通过借用EVA模型的预训练权重来初始化EVA-CLIP的图像编码器。</li><li>使用LAMB优化器。LAMB优化器专门为大批量训练而设计，其自适应元素级更新和层级学习率提高了训练效率并加速了收敛速度。</li><li>我们利用FLIP来提高CLIP模型训练的时间效率。在训练过程中随机遮蔽50%的图像标记，显著地将时间复杂度减少了一半。这种方法还允许将批量大小增加2倍，而不需要额外的内存开销。</li></ul><blockquote><p>EVA模型是在更大数据集上利用Mask Image Modeling任务，以CLIP 模型输入为完整的图像，而 EVA 模型的输入为有遮盖的图像，训练过程是让 EVA 模型遮盖部分的输出去重构 CLIP 模型对应位置的输出，从而以简单高效的方式让 EVA 模型同时拥有了语义学习 CLIP 的能力和几何结构学习 MIM 的能力。EVA 证明了这种训练方式可以帮助模型将参数扩展到十亿量级，并且在这个参数量级下在广泛下游任务中取得出色的性能。</p></blockquote><p>Osprey引入了<strong>基于卷积的ConvNext-L编码器，以利用更高分辨率和多层次特征。</strong>在原文的Convolutional CLIP Vision Encoder篇章中，因为Osprey是基于在像素级别的任务，如果直接用VIT类型的模型作为encoder，图片大小仅支持224或336，而增加输入图像分辨率受到了与ViT架构中全局注意力相关的计算负担的限制。在开放词汇分割任务中，基于CNN的编码器允许高效训练和快速推理，而不牺牲性能。此外，CNN基础的CLIP视觉编码器生成的多尺度特征图可以直接用于后续每个目标区域的特征提取，总之就是在细颗粒度任务中CNN表现更好。</p><p>一些研究也探索了无编码器架构。Fuyu-8b是一款<strong>纯解码器转换器</strong>，<strong>图像块被线性投影到转换器的第一层</strong>，绕过嵌入查找，只是将普通Transformer解码器视为图像转换器（尽管没有池化和因果注意力）。这意味着对于灵活输入的分辨率图片，Fuyu-8b有很强适应性。</p><blockquote><p>在架构方面，其他多模态模型因为涉及单独的图像编码器，其输出往往通过交叉注意或某种直接输入到 LLM 嵌入空间的适配器连接到现有的在推理时，所有分辨率高于此的图像都必须进行下采样，并且所有长宽比不匹配的图像都必须进行填充或扭曲。</p></blockquote><p>在选择编码器时，通常会考虑<strong>分辨率、参数大小和预训练语料库</strong>等因素。许多工作已经验证，使用更高的分辨率可以实现显著的性能提高。放大输入分辨率的方法可以分为直接缩放和patch分割方法。</p><p>不同架构对于处理不同分辨率的图片有着不同的策略。</p><ul><li><strong>使用不同编码器编码后进行特征融合</strong>：CogAgent使用了两个vision encoders去分别对高分辨率图片和低分辩率图片去进行编码，在得到高分辨率特征和低分辨率特征后，使用cross- attention进行高低分辨率特征融合。</li><li><strong>图片切片方法</strong>（patch-division method）：将高分辨率图像分割成多个小块，再利用低分辨率编码器去执行。其中图片切片方法可能需要positional embedding去提示每个小块在原始图片中的相对位置。</li></ul><p>在众多因素当中，图片分辨率的重要性要大于模型参数量和和训练数据组成。</p><h3 id="预训练LLM"><a href="#预训练LLM" class="headerlink" title="预训练LLM"></a>预训练LLM</h3><p>与从头开始训练LLM相比，从预先训练好的LLM开始更有效和实用。通过对web语料库进行大量的预训练，llm嵌入了丰富的世界知识，并展示了很强的泛化和推理能力。表2中总结了常用的和公开使用的llm。大多数llm在GPT-3之后，属于因果解码器类别</p><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20240912205411017.png" alt="image-20240912205411017" style="zoom:80%;"><p>近年来，对混合专家模型（MoE）体系结构的探索越来越引起了[65]、[66]、[67]的关注。与密集模型相比，稀疏体系结构通过选择性地激活参数，可以在不增加计算成本的情况下放大总参数的大小。根据经验，MM1和MoE-LLaVA发现，MoE实现在几乎所有的基准测试上都比密集的实现获得了更好的性能。</p><h3 id="模态接口"><a href="#模态接口" class="headerlink" title="模态接口"></a>模态接口</h3><p>由于llm只能感知文本，因此弥合自然语言和其他模式之间的差距是必要的。然而，以端到端方式训练一个大型多模态模型将是昂贵的。一种更实用的方法是在预先训练过的视觉编码器和LLM之间引入一个可学习的连接器。另一种方法是在专家模型的帮助下将图像翻译成语言，然后将该语言发送到LLM。</p><h4 id="可学习的连接器"><a href="#可学习的连接器" class="headerlink" title="可学习的连接器"></a>可学习的连接器</h4><p>它负责弥合不同模式之间的差距。具体来说，该模块将信息投射到LLM能够有效理解的空间中。基于多模态信息的融合方式，大致有两种实现这种接口的方法，即token级融合和feature级融合。</p><h5 id="token级融合"><a href="#token级融合" class="headerlink" title="token级融合"></a>token级融合</h5><p>对于在token层面的融合，modality encoder输出的特征会被转化成与LLM输入等价的token表示，通过将text token representation和其他模态转化后的token representation进行拼接，可以作为“可以被理解”的LLM输入。</p><ul><li><p><strong>BLIP-2方案</strong>：利用一组可学习的查询token，以基于查询的方式提取信息。这种q-formers方法将视觉token压缩为更少的表示向量（在BLIP-2中，由256个visual-token压缩为32个query-token）。</p><blockquote><p>Q-Former初始化自一个BERT-Base模型，使用交叉注意力，其中KV的输入来自图像编码器，Q的输入由文本和可学习的查询标记拼接而来，目的是使用可学习标记和文本作为键，在视觉编码器输出的视觉标记中查询出与可学标记和文本相关的信息，作为后续输入给LLM的标记序列。</p></blockquote></li><li><p><strong>LLaVA方案：</strong>与之相对的，一些方法简单的使用基于MLP的接口来弥合模态差异。例如，LLaVA系列采用一两个线性MLP，将视觉token投影并将特征空间与词嵌入对齐。</p></li></ul><p>MM1已经通过消融实验验证了，对于token级融合，模态适配器的类型远不如<strong>视觉token的数量和输入分辨率</strong>重要。然而，在【What Matters in Training a GPT4-Style Language Model with Multimodal Inputs?】通过比较了token级和特征级融合的性能，并通过实证研究揭示，在视觉问答（VQA）基准测试方面，token级融合变体表现更好。关于这种性能差距，作者们认为，交叉注意力模型可能需要更复杂的超参数搜索过程才能达到相当的性能。</p><h5 id="feature级融合"><a href="#feature级融合" class="headerlink" title="feature级融合"></a>feature级融合</h5><p>特性级融合插入了额外的模块，支持文本特征和视觉特征之间的深度交互和融合。</p><ul><li>Flamingo在LLM的冻结 Transformer 层之间插入额外的交叉注意力层，从而用外部视觉线索增强语言特征。</li><li>CogVLM在每个 Transformer 层中插入视觉专家模块，实现视觉和语言特征之间的双向交互和融合。为了获得更好的性能，引入模块的 QKV 权重矩阵使用预训练 LLM 进行初始化。</li><li>LLaMA-Adapter在 Transformer 层中引入可学习的提示。这些提示首先嵌入视觉知识，然后作为前缀与文本特征连接。</li></ul><p>就参数规模而言，可学习接口通常与编码器和 LLM 相比只占很小的一部分。以 Qwen-VL为例，Q-Former 的参数规模约为 0.08B，占总参数的不到 1%，而编码器和 LLM 分别占约 19.8%（1.9B）和 80.2%（7.7B）。</p><h4 id="专家模型"><a href="#专家模型" class="headerlink" title="专家模型"></a>专家模型</h4><p>利用Expert modes，比如图生字幕的模型来弥合模态之间的gap，如Woodpecker，ChatCaptioner（Chatgpt问好问题，由BLIP2来回答问题），Caption Anything，Img2LLM。他们的核心思想，都是希望在不训练的情况下，能够将多模态的输入转换为语言，再输入LLM，相当于绕过了复杂的多模态建模和模态对齐的过程。</p><p>比如VideoChat-Text就是使用了一个<strong>预训练的视觉模型，来获取图像中的信息（如动作）</strong>，并通过一个Speech recognition model来丰富这些对图片的描述。</p><p>虽然使用专家模型很简单，但它可能不如采用可学习的interface那样灵活。将外部模态转换为文本会导致信息丢失。例如，将视频转换为文本描述会损失时空关系。</p><h2 id="训练策略与数据"><a href="#训练策略与数据" class="headerlink" title="训练策略与数据"></a>训练策略与数据</h2><p>完整的MLLM需要经过三个阶段的训练，包括预训练，指令微调和对齐微调。每个训练阶段需要不同类型的数据来实现不同的目标。在本章中，我们将讨论每个训练阶段的训练目标、数据采集和特点。</p><h3 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h3><p>作为第一个训练阶段，预训练旨在对齐不同模态以及学习多模态世界知识。预训练阶段通常需要大规模的文本对数据，一般都是一段描述性文本，对应其描述的图片/音频/视频。例如标题数据。</p><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20241012104042145.png" alt="image-20241012104042145" style="zoom:80%;"><p>在此，我们考虑一个常见的场景，训练一个MLLM用于<strong>对齐视觉和文本</strong>。如表3所示，给定一张图像，训练模型以标准的交叉熵损失自回归得预测图像的标题。通常做法有两种：冻结LLMs和visual encoders，只训练模态接口，这样不会对模型已有的预训练知识造成影响，代表有LLaVA、LLaVA-med、Detgpt；或者开放visual encoder的参数，这样可以在alignment的过程中有更多的参数可以训练，代表有Qwen-VL、mPLUG-Owl、VisionLLM。</p><p>值得注意的是，训练方案与数据质量密切相关。对于短而有噪声的标题数据，可以采用较低分辨率（比如224）来加速训练过程，而对于更长和更干净的数据，最好利用更高分辨率（如448或者更高）来减轻大模型幻觉。此外，ShareGPT4V发现<strong>在预训练阶段如果给予高质量的标题数据，解冻视觉编码器能获得更好的对齐效果。</strong></p><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20241012110008801.png" alt="image-20241012110008801" style="zoom:80%;"><p>用于预训练的数据集基本都是文本+X的pairs的形式，主要服务于两个目的，（1）对齐不同模态（2）提供世界知识。这些预训练语料库可以根据颗粒度分为coarse-grained和fine-grained。</p><ul><li>对于coarse-grained，数据集一般都是从互联网上爬取，caption一般都<strong>短而noisy</strong>，因为一般这些数据都是以Alt-text的形式来描述图片的（Alt-text是HTML中用于描述图像的属性，这些属性可能不够完整或准确）。因此都需要<strong>进行数据清洗，比如用CLIP过滤那些相似度低的图像文本对。</strong></li><li>对于fine-grained，近期更多的研究工作，如Sharegpt4、LVIS-INSTRUCT4V、Allava已经开始探索<strong>通过提示强大的多模态大语言模型（如GPT-4V）来生成高质量的细粒度数据。</strong>与粗粒度数据相比，这些数据通常包含更长且更准确的图像描述，从而实现图像和文本模态之间更精细的对齐。然而，由于这种方法通常需要调用商业用途的多模态大语言模型，成本较高，且数据量相对较小。值得注意的是，ShareGPT4V在这方面取得了平衡：首先使用GPT-4V生成的10万条数据训练一个图像描述生成器，然后使用这个预训练的生成器将数据量扩大到120万。</li></ul><h3 id="指令微调"><a href="#指令微调" class="headerlink" title="指令微调"></a>指令微调</h3><p>指令指的是任务的描述。直观的说，指令微调目的在<strong>于教会模型更好的理解用户的指令</strong>并完成所要求的任务。通过这种方式进行微调，LLMs可以通过遵循新的指令泛化到未曾见过的任务，以此来<strong>增强零样本能力</strong>。这种简单而有效的理念助推了后续NLP工作的成功，例如 ChatGPT、InstructGPT、FLAN和 OPT-IML。</p><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20241012142412742.png" alt="image-20241012142412742" style="zoom:80%;"><ul><li>监督微调方法通常需要大量特定任务的数据来<strong>训练特定任务的模型</strong>。</li><li>提示方法减少了对大规模数据的依赖，可以通过<strong>提示工程来完成特定任务</strong>。在这种情况下，虽然少样本性能有所提高，但零样本性能仍然相当平均。</li><li>与之不同，指令调优学习如何<strong>泛化到未见过的任务</strong>，而不是像另外两种方法那样适应特定任务。此外，指令调优与多任务提示高度相关。</li></ul><p>在这一节，我们会描述指令样本的格式、训练目标、收集指令数据的典型方法以及相应的常用数据集。</p><p><strong>数据格式</strong></p><p>多模态指令样本通常包括可选的指令和输入-输出对。其中指令通常是描述任务的自然语言句子，比如，“详细地描述这张图片”。输入可以是VQA任务中的图像-文本对，也可以是图像描述任务中的只有图片。输出则是以输入为条件的面向指令的答案。指令模版灵活，可以人为设计，正如表5中所示。注意，指令模版也可以推广到多轮对话的情况。</p><img src="/2024/09/09/duo-mo-tai-xin-xi-chu-li/image-20241012142750875.png" alt="image-20241012142750875" style="zoom:67%;"><p><strong>数据收集</strong></p><p>由于指令数据在格式上更加灵活，任务表述也更加多样化，收集数据样本通常更加棘手和昂贵。目前给出了三种大规模获取指令数据集的典型方法</p><ul><li><p><strong>Data Adaptation</strong></p><ul><li>总结来说，就是利用现有的高质量任务特定数据集，并将这些数据集转换为指令格式的数据集。如VQA类数据集，原始的格式是（图像+问题）——&gt;答案，可以转换为（指令+图像+问题）——&gt;答案。</li><li>有些工作如Minigpt-4、LLaVA-med、InstructBLIP、X-LLM、Multi-instruct、M3it，通过手工制作一个候选指令池，并在训练时从中采样。有些工作则是手动设计一些种子指令，并用这些来提示GPT生成更多指令，如Videochat、Visionllm、Multimodal-gpt。</li></ul></li><li><p><strong>Self-Instruction</strong></p><ul><li>尽管现有的多任务数据集可以提供丰富的数据来源，但它们通常<strong>无法很好地满足真实场景中的人类需求</strong>，比如多轮对话。为解决这个问题，一些研究采用了Self-Insruction方法收集样本，该方法利用大语言模型（LLMs）<strong>基于少量手工标注的样本生成文本指令数据</strong>。具体来说，一些指令样本被手工制作作为示范，然后<strong>提示ChatGPT/GPT-4根据这些示范指导生成更多的指令样本</strong>。</li><li>LLaVA将这种方法扩展到多模态领域，它通过<strong>将图像转换为文本描述和边界框信息</strong>，然后提示纯文本的GPT-4在需求和示范的指导下生成新数据。通过这种方式，构建了一个名为LLaVA-Instruct-150k的多模态指令数据集。</li><li>遵循这一思路，后续的工作如MiniGPT-4、ChatBridge、GPT4Tools 和DetGPT开发了满足不同需求的不同数据集。最近，随着更强大的多模态模型GPT-4V的发布，许多工作采用GPT-4V生成更高质量的数据，如LVIS-Instruct4V和ALLaVA。</li></ul></li><li><p><strong>Data Mixture</strong></p><ul><li>除了多模态指令数据之外，<strong>纯语言的user-assistant</strong>这种对话数据也可以用来提高对话能力和遵循指令的能力（mPLUG-Owl，Multimodal-gpt，LaVIN，Llama-adapter v2）。LaVIN直接通过从纯语言和多模态数据中随机采样来构建小批量（minibatch）。MultiInstruct探索了<strong>使用单模态和多模态数据融合进行训练</strong>的不同策略，包括混合指令调优（结合两种类型的数据并随机打乱）和顺序指令调优（先使用文本数据，然后是多模态数据）。</li></ul></li></ul><p><strong>数据质量</strong></p><p>最近的研究已经表明，在一个高质量的小型微调指令集（smaller but cleaner）上训练的模型，其效果要好于在一个大规模nosiy的image-pairs上训练的模型。在Lynx等研究中已经揭示，一个高质量的数据集应该包含更丰富多样的Prompt、且难度上应该涉及多一些的reasoning。比如用更多的视觉reasoning task，而不是captioning或QA任务，即要为大模型上难度。</p><h3 id="对齐微调"><a href="#对齐微调" class="headerlink" title="对齐微调"></a>对齐微调</h3><p>对齐微调通常用于模型需要与特定的人类偏好对齐的场景，例如幻觉较少的回答。目前，Reinforcement Learning with Human Feedback (RLHF) 和 Direct Preference Optimization (DPO) 是两种主要的对齐微调手段。</p><p>RLHF。该技术旨在利用强化学习算法将LLM与人类偏好对齐，该过程中使用了人工标注作为训练循环中的监督。如 InstructGPT 所示，RLHF 包含三个关键步骤：1）监督微调。2）奖励建模。3）强化学习。</p><p>DPO是通过使用简单的二元分类损失来从人类偏好标签中学习。与基于PPO的RLHF算法相比，DPO不需要学习显式的奖励模型，因此将整个流程简化为两个步骤：人类偏好数据收集和偏好学习。</p><p>除了以上两个耳熟能详的，还有RLHF-V通过纠正模型中的幻觉来收集细粒度（段落级别）的偏好数据对。Silkie则通过提示GPT-4V来收集偏好数据，并通过DPO将偏好监督蒸馏到一个经过指令微调的模型中。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>吴友政,李浩然,姚霆,等.多模态信息处理前沿综述：应用、融合和预训练[J].中文信息学报,2022,36(05):1-20.</p><p>A Survey on Multimodal Large Language Models</p><p><a href="https://github.com/BradyFU/Awesome-Multimodal-Large-Language-Models">BradyFU/Awesome-Multimodal-Large-Language-Models: <span class="github-emoji"><span>✨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>✨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Latest Advances on Multimodal Large Language Models (github.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/713777861">2024 多模态大模型综述总结 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多模态信息处理&quot;&gt;&lt;a href=&quot;#多模态信息处理&quot; class=&quot;headerlink&quot; title=&quot;多模态信息处理&quot;&gt;&lt;/a&gt;多模态信息处理&lt;/h1&gt;&lt;h2 id=&quot;综述（2022）&quot;&gt;&lt;a href=&quot;#综述（2022）&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="笔记" scheme="http://wolf-ll.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LLM" scheme="http://wolf-ll.github.io/tags/LLM/"/>
    
    <category term="多模态" scheme="http://wolf-ll.github.io/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Java</title>
    <link href="http://wolf-ll.github.io/2024/06/15/java/"/>
    <id>http://wolf-ll.github.io/2024/06/15/java/</id>
    <published>2024-06-15T00:50:20.000Z</published>
    <updated>2025-04-07T16:10:18.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>Java特点</strong>：面向对象（封装，继承，多态）；平台无关（基于JVM）；可靠安全（异常处理，自动内存管理，多重安全防护）；编译与解释并存-&gt;一次编译，到处运行；Java生态</p><p>Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><blockquote><p>编译型：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有C、C++、Go、Rust等等。<br>解释型：释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。<br>Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，这些字节码可以在任何安装了Java虚拟机的平台上运行，由解释器逐条将字节码解释为机器码来执行。这种方式使得Java程序具有了跨平台性，同一份Java代码可以在各种操作系统和硬件平台上运行，而不需要针对不同平台进行重新编译。</p></blockquote><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，<strong>在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</strong>。</p><p>JVM引入 <strong>JIT（Just in Time Compilation）</strong> 编译器， 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p><strong>Java和C++：</strong></p><ul><li>Java <strong>不提供指针</strong>来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有**自动内存管理垃圾回收机制(GC)**，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java <strong>只支持方法重载（</strong>操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h3 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h3><p>JDK（Java Development Kit）是一个功能齐全的 Java 开发工具包，供开发者使用，用于创建和编译 Java 程序。它包含了 JRE（Java Runtime Environment），以及编译器 javac 和其他工具，如 javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等。</p><p>JRE （Java运行时环境）是运行已编译 Java 程序所需的环境，主要包含以下两个部分：<strong>JVM</strong> : Java 虚拟机。<strong>Java 基础类库（Class Library）</strong>：一组标准的类库，提供常用的功能和 API（如 I/O 操作、网络通信、数据结构等）。</p><p>JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE，还包括用于开发和调试 Java 程序的工具。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><img src="/2024/06/15/java/image-20240615094911702.png" alt="image-20240615094911702" style="zoom:80%;"><h3 id="基本类型和包装类型"><a href="#基本类型和包装类型" class="headerlink" title="基本类型和包装类型"></a>基本类型和包装类型</h3><ul><li><strong>用途</strong>：基本类型用于定义一些<strong>常量和局部变量</strong>。方法参数/对象属性等多用包装类型。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本类型的<strong>局部变量</strong>存放在 Java 虚拟机<strong>栈</strong>中的局部变量表中，基本数据类型的<strong>成员变量</strong>（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的<strong>堆</strong>中。包装类型属于对象类型，存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， <strong>基本数据类型占用的空间往往非常小。</strong></li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code>，而<strong>成员变量基本类型有默认值</strong>且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说<strong>，<code>==</code> 比较的是对象的内存地址。</strong>所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p><strong>包装类型缓存机制：</strong>包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><p>自动拆装箱：</p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// 装箱 调用包装类的.valueOf方法 -- 等价于 Integer i = Integer.valueOf(10)</span><span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>   <span class="token comment">// 拆箱 调用包装类的xxxValue方法 -- 等价于int n = i.intValue();</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><ul><li><p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p></li><li><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p></li><li><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p></li><li><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p></li></ul><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><ul><li>重载（overload）是在一个类（或父类与子类）里面，方法名字相同，而<strong>参数不同</strong>。返回类型可以相同也可以不同。</li><li>重写（override）发生在<strong>运行期</strong>，是指子类定义了一个与其父类中具有<strong>相同名称和参数列表</strong>的方法，并且子类方法的实现覆盖了父类方法的实现。</li></ul><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">发生范围</td><td align="left">同一个类</td><td align="left">子类</td></tr><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可修改</td><td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td align="left">异常</td><td align="left">可修改</td><td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td align="left">访问修饰符</td><td align="left">可修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr><tr><td align="left">发生阶段</td><td align="left">编译期</td><td align="left">运行期</td></tr></tbody></table><p><strong>方法的重写要遵循“两同两小一大”</strong>：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：<code>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改</code>。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><p>另：类的构造方法<strong>不能被重写（override）</strong>，但<strong>可以被重载（overload）</strong>。因此，一个类中可以有多个构造方法，这些构造方法可以具有不同的参数列表，以提供不同的对象初始化方式。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指把一个对象的<strong>状态信息（也就是属性）隐藏在对象内部</strong>，不允许外部对象直接访问对象的内部信息。但是可以<strong>提供一些可以被外界访问的方法</strong>来操作属性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在<strong>程序运行期间才能确定</strong>；</li><li><strong>多态不能调用“只在子类存在但在父类不存在”的方法；</strong></li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul><p>另：<strong>静态方法不支持多态。</strong>多态是面向对象编程中的一个核心概念，它允许子类通过重写父类的方法来提供特定的实现。然而，由于静态方法不依赖于对象实例，它们不适用于多态。<strong>静态方法的调用在编译时就已经确定</strong>，这种机制被称为静态绑定或早期绑定。</p><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p><strong>抽象类</strong>：包含抽象方法的类。通过abstract关键字来创建抽象类，以及定义抽象方法。抽象类的存在就是为了被继承，所以抽象类中的抽象方法不能被private、static、final修饰，否则无法被继承。抽象类虽然不能被实例化，<strong>但是它可以有构造方法，供子类创建对象时，初始化父类成员。</strong></p><p><strong>接口</strong>：接口是一种引用数据类型，可以看成是多个类的公共规范。定义接口需要借助interface关键字，定义方式与定义类的方式相似</p><p><strong>共同点</strong>：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。<strong>每个抽象方法前都隐藏着public abstract修饰。</strong></li><li><strong>都可以有默认实现的方法</strong>（Java 8 开始可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li><strong>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为</strong>。抽象类主要用于代码复用，强调的是<strong>所属关系</strong>。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而<strong>抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</strong></li><li>接口中<strong>不能有</strong>静态代码块（<strong>可以有静态成员方法</strong>）、实例代码块以及构造方法；而<strong>抽象类可以有构造方法</strong>，供子类创建对象时，初始化父类成员。</li></ul><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说<strong>拷贝对象和原对象共用同一个内部对象。</strong></p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><img src="/2024/06/15/java/shallow&amp;deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图" style="zoom:80%;"><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>线程安全性：</strong><code>String</code> 中的对象是不可变的，也就可以理解为<strong>常量，线程安全</strong>。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了<strong>同步锁</strong>或者对调用的方法加了同步锁，所以是<strong>线程安全的</strong>。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能：</strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="String不可变"><a href="#String不可变" class="headerlink" title="String不可变"></a>String不可变</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为<strong>这个数组保存的字符串是可变的</strong>（<code>final</code> 修饰引用类型变量的情况）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为<strong>私有</strong>的，并且**<code>String</code> 类没有提供/暴露修改这个字符串的方法。**</li><li><code>String</code> 类被 <code>final</code> 修饰导致其<strong>不能被继承</strong>，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><p>在 Java 9 之后，<code>String</code>、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>    <span class="token comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span>    <span class="token annotation punctuation">@Stable</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，用于存储字符串常量，主要目的是为了避免字符串的重复创建。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 在字符串常量池中创建字符串对象 ab</span><span class="token comment">// 将字符串对象 ab 的引用赋值给 aa -- aa是在栈上存储的ab对象的引用</span><span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span><span class="token comment">// 直接返回字符串常量池中字符串对象 ab，赋值给引用 bb -- 此时不创建任何对象</span><span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa<span class="token operator">==</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了使用双引号创建字符串会自动放入常量池外，还可以使用 <code>String</code> 类的 <code>intern()</code> 方法手动将字符串添加到常量池中。<code>intern()</code> 方法会先检查常量池中是否已经存在该字符串，如果存在则返回常量池中的引用；如果不存在，则将该字符串添加到常量池中，并返回其引用<strong>。intern() 方法的主要作用是确保字符串引用在常量池中的唯一性。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InternExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true，因为 str2 和 str3 都引用常量池中的 "hello"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>位置变化：</p><ol><li><p>在JDK1.7前，运行时常量池+字符串常量池是存放在<strong>方法区</strong>中，HotSpot VM对方法区的实现称为<strong>永久代</strong>。</p><ul><li>方法区是<strong>各个线程共享的内存区域</strong>，是用于存储已经被<strong>JVM加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</li><li>很多人会把方法区称为<code>永久代</code>，其实本质上是不等价的，只不过HotSpot虚拟机设计团队是选择把GC分代收集扩展到了方法区，使用永久代来代替实现方法区。其实，在方法区中的垃圾收集行为还是比较少的，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，但是这个区域的回收总是不尽如人意的，如果该区域回收不完全就会出现内存泄露。</li></ul></li><li><p>在JDK1.7中，字符串常量池从方法区<strong>移到堆中</strong>，运行时常量池保留在方法区中。</p><ul><li><p>需要注意的是，永久代的大小是有限的，并且很难准确地确定一个应用程序需要多少永久代空间。如果我们在应用程序中使用了大量的类、方法、常量等静态数据，就有可能导致永久代空间不足。这种情况下，JVM 就会抛出 OutOfMemoryError 错误。</p></li><li><p>因此，从 Java 7 开始，为了解决永久代空间不足的问题，将字符串常量池从永久代中移动到堆中。这个改变也是为了更好地支持动态语言的运行时特性。</p></li></ul></li><li><p>在JDK1.8中，HotSpot<strong>移除永久代</strong>，使用<strong>元空间</strong>代替（也就是元空间成为了对“方法区”概念的实现），此时字符串常量池依然保留在堆中，运行时常量池保留在方法区（元空间）中，<strong>JVM内存变成了直接内存。</strong></p></li></ol><p>常量折叠：常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p><p>对于 <code>String str3 = "str" + "ing";</code> 编译器会给你优化成 <code>String str3 = "string";</code> 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><img src="/2024/06/15/java/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图" style="zoom:80%;"><p><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p><ul><li><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p></li><li><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(<strong>参数错误比如方法入参类型错误</strong>)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li></ul></li></ul><p>**<code>Error</code>**：<code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型，即“<strong>参数化类型</strong>”。在方法定义时，将方法签名中的<code>形参的数据类型</code>也设置为参数（也可称之为类型参数），在调用该方法时再从外部传入一个具体的数据类型和变量。<strong>泛型的本质是为了将类型参数化</strong>， 也就是说在泛型使用过程中，<strong>数据类型被设置为一个参数，在使用时再从外部传入一个数据类型</strong>；而一旦传入了具体的数据类型后，传入变量（实参）的数据类型如果不匹配，编译器就会直接报错。这种参数化类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><ul><li>泛型提供了一种<strong>扩展</strong>能力，更符合面向对象开发的软件编程宗旨。</li><li>泛型提高了程序代码的<strong>可读性</strong>。在定义泛型阶段（类、接口、方法）或者对象实例化阶段，由于 &lt; 类型参数 &gt; 需要在代码中显式地编写，所以程序员能够快速猜测出代码所要操作的数据类型，提高了代码可读性。</li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类型参数用于类的定义中，则该类被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>     <span class="token comment">// key 这个成员变量的数据类型为 T, T 的类型由外部传入  </span>    <span class="token keyword">private</span> <span class="token class-name">T</span> key<span class="token punctuation">;</span><span class="token comment">// 泛型构造方法形参 key 的类型也为 T，T 的类型由外部传入</span>    <span class="token keyword">public</span> <span class="token class-name">Generic</span><span class="token punctuation">(</span><span class="token class-name">T</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 泛型方法 getKey 的返回值类型为 T，T 的类型由外部指定</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>泛型类中的静态方法和静态变量不可以使用泛型类所声明的类型参数</strong></p><ul><li>泛型类中的<strong>类型参数的确定是在创建泛型类对象</strong>的时候（例如 ArrayList&lt; Integer &gt;）。</li><li>而静态变量和静态方法在类加载时已经初始化，直接使用类名调用；在泛型类的类型参数未确定时，静态成员有可能被调用，因此泛型类的类型参数是不能在静态成员中使用的。</li><li>静态泛型方法中可以使用自身的方法签名中<strong>新定义的类型参数</strong>（即泛型方法），而不能使用泛型类中定义的类型参数。</li></ul><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Inter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>泛型接口中的类型参数，在该接口被继承或者被实现时确定。</strong></p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>当在一个方法签名中的<strong>返回值前面声明了一个 &lt; T &gt; 时</strong>，该方法就被声明为一个<code>泛型方法</code>。&lt; T &gt;表明该方法声明了一个类型参数 T，并且这个类型参数 T 只能在该方法中使用。当然，泛型方法中也可以使用<code>泛型类中定义的泛型参数</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token comment">// 该方法只是使用了泛型类定义的类型参数，不是泛型方法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token class-name">U</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// &lt;T&gt; 真正声明了下面的方法是一个泛型方法</span><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">testMethod1</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>泛型类中定义的类型参数和泛型方法中定义的类型参数是相互独立的，它们一点关系都没有。<strong>也就是说，泛型方法始终以自己声明的类型参数为准。</strong></p><p>为了避免混淆，如果在一个泛型类中存在泛型方法，那么两者的类型参数最好不要同名。</p><p><strong>在静态成员中不能使用泛型类定义的类型参数，但我们可以将静态成员方法定义为一个泛型方法。</strong></p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>泛型的本质是将<code>数据类型参数化</code>，它通过<strong>擦除</strong>的方式来实现，即编译器会在编译期间<code>擦除</code>代码中的所有泛型语法并相应的做出一些类型转换动作。</p><p>换而言之，<strong>泛型信息只存在于代码编译阶段</strong>，在代码编译结束后，与泛型相关的信息会被擦除掉，专业术语叫做<code>类型擦除</code>。也就是说，<strong>成功编译过后的 class 文件中不包含任何泛型信息</strong>，泛型信息不会进入到<code>运行时阶段</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">T</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 将这个泛型类反编译, 结果如下</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 默认构造器，不用管</span><span class="token keyword">private</span> <span class="token class-name">Object</span> num<span class="token punctuation">;</span><span class="token comment">// T 被替换为 Object 类型</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以发现编译器<code>擦除</code>了 Caculate 类后面的泛型标识 &lt; T &gt;，并且将 num 的数据类型替换为 Object 类型，而替换了 T 的数据类型我们称之为<code>原始数据类型</code>。</li></ul><p><strong>那么是不是所有的类型参数被擦除后都以 Object 类进行替换呢？</strong></p><ul><li>答案是否定的，大部分情况下，类型参数 T 被擦除后都会以 Object 类进行替换；而有一种情况则不是，那就是使用到了 extends 和 super 语法的<code>有界类型参数</code>（即<code>泛型通配符</code>）。</li></ul><p>在现实编码中，确实有这样的需求，希望泛型能够处理<code>某一类型范围内</code>的类型参数，比如某个泛型类和它的子类，为此 Java 引入了<code>泛型通配符</code>这个概念。</p><blockquote><ol><li><!--?--> ：被称作无限定的通配符。**代表了任何一种数据类型。**</li><li><!--? extends T--> ：被称作有上界的通配符。 **逻辑上表示类型参数的范围是 T 和 T 的子类。**</li><li><!--? super T--> ：被称作有下界的通配符。 **逻辑上表示类型参数的范围是 T 和 T 的超类。**</li></ol></blockquote><ul><li><p>Object 本身也算是一种数据类型，但却不能代表任何一种数据类型，所以 ArrayList&lt; Object &gt; 和 ArrayList&lt;?&gt;的含义是不同的，前者类型是 Object，也就是继承树的最高父类，而后者的类型完全是未知的；ArrayList&lt;?&gt; 是 ArrayList&lt; Object &gt; 逻辑上的父类。</p></li><li><p>ArrayList&lt; Integer &gt; 和 ArrayList&lt; Number &gt; 之间不存在继承关系。而引入上界通配符的概念后，我们便可以在逻辑上将 ArrayList&lt;? extends Number&gt; 看做是 ArrayList&lt; Integer &gt; 的父类，<strong>但实质上它们之间没有继承关系。</strong></p></li><li><p>ArrayList&lt;? super Integer&gt; 在逻辑上表示为 Integer 类以及 Integer 类的所有父类，它可以代表 ArrayList&lt; Integer&gt;、ArrayList&lt; Number &gt;、 ArrayList&lt; Object &gt;中的某一个集合，但实质上它们之间没有继承关系。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">T</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caculate</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 默认构造器，不用管</span><span class="token keyword">private</span> <span class="token class-name">Number</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用到了 extends 语法的类型参数 T 被擦除后会替换为 Number 而不再是 Object。</li><li>extends 和 super 是一个<strong>限定类型参数边界的</strong>语法，extends 限定 T 只能是 Number 或者是 Number 的<strong>子类</strong>。 也就是说，在创建 Caculate 类对象的时候，尖括号 &lt;&gt; 中只能传入 Number 类或者 Number 的子类的数据类型，所以在创建 Caculate 类对象时无论传入什么数据类型，Number 都是其父类，于是可以使用 Number 类作为 T 的原始数据类型，进行类型擦除并替换。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>泛型信息被擦除了，如何保证我们在集合中只添加指定的数据类型的对象呢？</p><ul><li>其实在创建一个泛型类的对象时， Java 编译器是先检查代码中传入 &lt; T &gt; 的<strong>数据类型，并记录下来</strong>，然后再对代码进行编译，<code>编译的同时进行类型擦除</code>；如果需要对被擦除了泛型信息的对象进行操作，<strong>编译器会自动将对象进行类型转换。</strong></li></ul><blockquote><p>可以把泛型的类型安全检查机制和类型擦除想象成演唱会的验票机制：以 ArrayList&lt; Integer&gt; 泛型集合为例。</p><p>当我们在创建一个 ArrayList&lt; Integer &gt; 泛型集合的时候，ArrayList 可以看作是演唱会场馆，而&lt; T &gt;就是场馆的验票系统，Integer 是验票系统设置的门票类型；<br>当验票系统设置好为&lt; Integer &gt;后，只有持有 Integer 门票的人才可以通过验票系统，进入演唱会场馆（集合）中；若是未持有 Integer 门票的人想进场，则验票系统会发出警告（编译器报错）。<br>在通过验票系统时，门票会被收掉（类型擦除），但场馆后台（JVM）会记录下观众信息（泛型信息）。<br>进场后的观众变成了没有门票的普通人（原始数据类型）。但是，在需要查看观众的信息时（操作对象），场馆后台可以找到记录的观众信息（编译器会自动将对象进行类型转换）。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericType</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> arrayInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置验票系统   </span>        arrayInteger<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 观众进场，验票系统验票，门票会被收走（类型擦除）</span>        <span class="token class-name">Integer</span> n <span class="token operator">=</span> arrayInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取观众信息，编译器会进行强制类型转换</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>擦除 ArrayList&lt; Integer &gt; 的泛型信息后，get() 方法的返回值将返回 Object 类型，但编译器会自动插入 Integer 的强制类型转换。也就是说，编译器把 get() 方法调用翻译为两条字节码指令：</p><ul><li>对原始方法 get() 的调用，返回的是 Object 类型；</li><li>将返回的 Object 类型强制转换为 Integer 类型；</li></ul><p><strong>项目中哪里用到了泛型</strong></p><ul><li><strong>自定义接口通用返回结果</strong> <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li><li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li><li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射 (Reflection) 是 Java 的特征之一，它允许<strong>运行中的 Java 程序获取自身的信息</strong>，并且可以操作类或对象的内部属性。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p><p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。</p><p><strong>使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码），一切反射的操作都是从Class对象开始</strong></p><p>反射就是把java类中的各种成分映射成一个个的Java对象：在 Java 中，当程序启动时，类加载器会将 <code>.class</code> 文件加载到内存中，并创建对应的 <code>Class</code> 对象。每个类在 JVM 中都有且仅有一个对应的 <code>Class</code> 对象，它包含了该类的所有信息，如类的名称、父类、接口、字段、方法等。</p><p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把各个组成部分映射成一个个对象。</p><img src="/2024/06/15/java/20170513133210763" alt="img" style="zoom:80%;"><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>运行时动态获取类的信息</strong>：在编写代码时，对于类的信息是必须在编译时确定的，但在运行时，有时需要根据某些条件，动态获取某个类的信息，这时就可以使用Java中的反射机制。</li><li>动态生成对象：反射机制可以在<strong>运行时生成对象</strong>，这样就可以根据参数的不同，动态的创建不同的类的实例对象。</li><li>动态调用方法：通过反射机制可以调用类中的方法，不论这些方法是否是公共的，也不论这些方法的参数个数和类型是什么，反射机制都具有这样的能力。</li><li>动态修改属性：利用反射机制可以获取到类中的所有成员变量，并可以对其进行修改。</li><li><strong>实现动态代理：</strong>利用反射机制可以实现代理模式，<strong>通过代理对象完成原对象对某些方法的调用</strong>，同时也可以在这些方法的调用前后做一些额外的处理。</li></ul><p>Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。<strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p><h3 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h3><p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为你可以<strong>基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。</strong>你获取到注解之后，就可以做进一步的处理。</p><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种<strong>特殊的注释</strong>，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。注解的引入主要是为了简化某些编程模式和减轻开发者的负担。例如，它们可以用来自动生成代码、序列化/反序列化数据、配置框架和处理权限。</p><p><strong>注解本质是一个继承了<code>Annotation</code> 的特殊接口。</strong>基本语法：定义一个注解类似于定义一个接口，但是在关键字 <strong>interface</strong> 前加上 <strong>@</strong> 符号。例如定义一个简单的注解 <strong>@MyAnnotation</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">MyAnnotation</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注解本身只是一种标记，它不会自动执行任何操作。要使注解发挥作用，需要在运行时通过反射机制来读取和处理注解信息。具体步骤如下：</p><ul><li><strong>获取 <code>Class</code> 对象</strong>：通过类名、对象实例等方式获取目标类的 <code>Class</code> 对象。</li><li><strong>获取注解信息</strong>：使用 <code>Class</code> 对象、<code>Method</code> 对象、<code>Field</code> 对象等的方法来检查是否存在特定的注解，并获取注解的实例。</li><li><strong>处理注解信息</strong>：根据注解的属性值和类型，执行相应的逻辑。</li></ul><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的</li></ul><p><strong>反射机制使得注解可以在运行时动态地应用于不同的类、方法和字段，而不需要在编译时就确定具体的使用位置</strong>。这大大增强了注解的灵活性和可扩展性。例如，在 Spring 框架中，通过反射和注解的结合，可以实现依赖注入、面向切面编程等功能，使得代码更加简洁和易于维护。</p><p><strong>注解可以为反射操作提供额外的元数据信息，使得反射在处理类和对象时能够更加智能和灵活。</strong>例如，通过注解可以指定方法的执行顺序、字段的验证规则等，反射可以根据这些注解信息来执行相应的操作。</p><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span></span><span class="token punctuation">;</span><span class="token comment">// 定义注解</span><span class="token annotation punctuation">@interface</span> <span class="token class-name">MyAnnotation</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 使用注解</span><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@MyAnnotation</span><span class="token punctuation">(</span><span class="token string">"Hello, Annotation!"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This is my method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 处理注解</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationProcessor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchMethodException</span> <span class="token punctuation">{</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token class-name">Method</span> method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"myMethod"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 根据反射获取类方法，判断方法是否带有MyAnnotation注解</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">MyAnnotation</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">MyAnnotation</span> annotation <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">MyAnnotation</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取注解实例，读取属性</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotation<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token comment">// 调用类方法</span>                method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中，通过反射获取 <code>MyClass</code> 类的 <code>myMethod</code> 方法，检查该方法是否带有 <code>MyAnnotation</code> 注解。如果有，则获取注解的实例并读取其属性值，同时调用该方法。</p><h3 id="获取class对象"><a href="#获取class对象" class="headerlink" title="获取class对象"></a>获取class对象</h3><p>Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//  知道具体类的情况下可以使用 -- 类名.class</span><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">TargetObject</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment">//  通过 Class.forName()传入类的全路径获取</span><span class="token class-name">Class</span> clazz1 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.javaguide.TargetObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  通过对象实例instance.getClass()获取</span><span class="token class-name">TargetObject</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TargetObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Class</span> clazz2 <span class="token operator">=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  通过类加载器xxxClassLoader.loadClass()传入类路径获取</span><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"cn.javaguide.TargetObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 可以使用 Class 对象的 newInstance() 方法（在 Java 9 及以后版本已被弃用）或 Constructor 对象的 newInstance() 方法来创建对象</span><span class="token comment">// 反射实例化 -- 对象.newInstance()</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.javaguide.TargetObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TargetObject</span> targetObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TargetObject</span><span class="token punctuation">)</span> targetClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用无参构造函数创建对象</span><span class="token class-name">Person</span> person1 <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用有参构造函数创建对象</span><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> person2 <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>获得类中属性相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getField(String name)</td><td align="left">获得某个公有的属性对象</td></tr><tr><td align="left">getFields()</td><td align="left">获得所有公有的属性对象</td></tr><tr><td align="left">getDeclaredField(String name)</td><td align="left">获得某个属性对象</td></tr><tr><td align="left">getDeclaredFields()</td><td align="left">获得所有属性对象</td></tr></tbody></table><ul><li><strong>获得类中注解相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getAnnotation(Class annotationClass)</td><td align="left">返回该类中与参数类型匹配的公有注解对象</td></tr><tr><td align="left">getAnnotations()</td><td align="left">返回该类所有的公有注解对象</td></tr><tr><td align="left">getDeclaredAnnotation(Class annotationClass)</td><td align="left">返回该类中与参数类型匹配的所有注解对象</td></tr><tr><td align="left">getDeclaredAnnotations()</td><td align="left">返回该类所有的注解对象</td></tr></tbody></table><ul><li><strong>获得类中构造器相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getConstructor(Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类中与参数类型匹配的公有构造方法</td></tr><tr><td align="left">getConstructors()</td><td align="left">获得该类的所有公有构造方法</td></tr><tr><td align="left">getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类中与参数类型匹配的构造方法</td></tr><tr><td align="left">getDeclaredConstructors()</td><td align="left">获得该类所有构造方法</td></tr></tbody></table><ul><li><strong>获得类中方法相关的方法</strong></li></ul><table><thead><tr><th align="left">方法</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">getMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类某个公有的方法</td></tr><tr><td align="left">getMethods()</td><td align="left">获得该类所有公有的方法</td></tr><tr><td align="left">getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td align="left">获得该类某个方法</td></tr><tr><td align="left">getDeclaredMethods()</td><td align="left">获得该类所有方法</td></tr></tbody></table><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><ul><li><strong>序列化</strong>：将数据结构或对象转换成<strong>二进制字节流</strong>（或JSON、XML等存储格式）的过程。这些字节序列可以被存储到文件、数据库中，也可以通过网络传输到其他地方。序列化的主要目的是实现<strong>对象的持久化和远程通信。</strong></li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成原始数据结构或者对象的过程</li></ul><p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><blockquote><p>Java 序列化机制基于<strong>对象的类信息和对象的状态（即对象的字段值）</strong>来实现。在序列化过程中，Java 会将对象的类信息（包括类名、字段类型等）和对象的字段值按照一定的格式转换为字节序列。在反序列化过程中，Java 会根据字节序列中的类信息加载相应的类，并根据字段值恢复对象的状态。</p></blockquote><p><strong>应用场景</strong></p><ul><li><strong>对象持久化</strong>：将对象保存到文件或数据库中，以便在程序下次启动时可以恢复对象的状态。</li><li><strong>远程通信</strong>：在分布式系统中，通过网络传输对象时，需要将对象序列化后发送到远程节点，然后在远程节点进行反序列化。</li><li><strong>缓存</strong>：将对象序列化后存储在缓存中，如 Redis 等，以提高系统的性能。</li></ul><h3 id="JDK序列化"><a href="#JDK序列化" class="headerlink" title="JDK序列化"></a>JDK序列化</h3><ul><li>被序列化的类必须实现 <code>java.io.Serializable</code> 接口，该接口是一个标记接口，没有任何方法，只是用于标识该类的对象可以被序列化。</li><li>提供一个 <code>private static final long serialVersionUID</code> 字段，用于标识类的版本号，确保序列化和反序列化时使用的是同一个版本的类。如果不提供，Java 会根据类的结构自动生成一个 <code>serialVersionUID</code>，但在类结构发生变化时可能会导致反序列化失败。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Builder</span><span class="token annotation punctuation">@ToString</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcRequest</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1905122041950251207L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> requestId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> interfaceName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> methodName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameters<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> paramTypes<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">RpcMessageTypeEnum</span> rpcMessageTypeEnum<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列化号 <code>serialVersionUID</code> 属于版本控制的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。</p><blockquote><p><code>static</code> 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而，<code>serialVersionUID</code> 是一个特例，<code>serialVersionUID</code> 的序列化做了特殊处理。当一个对象被序列化时，<code>serialVersionUID</code> 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。</p></blockquote><p><strong>如果有些字段不想进行序列化怎么办？</strong></p><p>对于不想进行序列化的变量，可以使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：<strong>阻止实例中那些用此关键字修饰的的变量序列化</strong>；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，<strong>在反序列化后变量值将会被置成类型的默认值</strong>。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h3><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p><p>Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language * * @author shuang.kou * @createTime 2020年05月13日 19:29:00 */</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KryoSerializer</span> <span class="token keyword">implements</span> <span class="token class-name">Serializer</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Kryo</span><span class="token punctuation">&gt;</span></span> kryoThreadLocal <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">Kryo</span> kryo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Kryo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kryo<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">RpcResponse</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kryo<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> kryo<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ByteArrayOutputStream</span> byteArrayOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Output</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Output</span><span class="token punctuation">(</span>byteArrayOutputStream<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Kryo</span> kryo <span class="token operator">=</span> kryoThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Object-&gt;byte:将对象序列化为byte数组</span>            kryo<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>            kryoThreadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> output<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SerializeException</span><span class="token punctuation">(</span><span class="token string">"Serialization failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ByteArrayInputStream</span> byteArrayInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token class-name">Input</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Input</span><span class="token punctuation">(</span>byteArrayInputStream<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Kryo</span> kryo <span class="token operator">=</span> kryoThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// byte-&gt;Object:从byte数组中反序列化出对象</span>            <span class="token class-name">Object</span> o <span class="token operator">=</span> kryo<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>            kryoThreadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> clazz<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SerializeException</span><span class="token punctuation">(</span><span class="token string">"Deserialization failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据<strong>输入到计算机内存</strong>的过程即输入，反之<strong>输出到外部存储（比如数据库，文件，远程主机）</strong>的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">InputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Number of remaining bytes:"</span>            <span class="token operator">+</span> fis<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回输入流中可以读取的字节数。</span>    <span class="token keyword">int</span> content<span class="token punctuation">;</span>    <span class="token keyword">long</span> skip <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The actual number of bytes skipped:"</span> <span class="token operator">+</span> skip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The content read from file:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>content <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。</span>        <span class="token comment">// 如果未读取任何字节，则代码返回 -1 ，表示文件结束</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将ascii码转为读到的字符</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>输出：    <span class="token class-name">Number</span> of remaining bytes<span class="token operator">:</span><span class="token number">11</span><span class="token class-name">The</span> actual number of bytes skipped<span class="token operator">:</span><span class="token number">2</span><span class="token class-name">The</span> content read from file<span class="token operator">:</span><span class="token class-name">JavaGuide</span><span class="token comment">// 新建一个 BufferedInputStream 对象</span><span class="token class-name">BufferedInputStream</span> bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取文件的内容并复制到 String 对象中            读取输入流所有字节</span><span class="token class-name">String</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bufferedInputStream<span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileInputStream</span> fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//必须将fileInputStream作为构造参数才能使用</span><span class="token class-name">DataInputStream</span> dataInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span>fileInputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以读取任意具体的类型数据</span>dataInputStream<span class="token punctuation">.</span><span class="token function">readBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataInputStream<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataInputStream<span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ObjectInputStream 用于从输入流中读取 Java 对象（反序列化），ObjectOutputStream 用于将对象写入到输出流(序列化)。</span><span class="token class-name">ObjectInputStream</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"object.data"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">MyClass</span> object <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyClass</span><span class="token punctuation">)</span> input<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileOutputStream</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token string">"JavaGuide"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    output<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将数组写入到输出流，等价于 write(b, 0, b.length)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 字节缓冲输出流</span><span class="token class-name">FileOutputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span>fileOutputStream<span class="token punctuation">)</span><span class="token comment">// 输出流</span><span class="token class-name">FileOutputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">DataOutputStream</span> dataOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span>fileOutputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出任意数据类型</span>dataOutputStream<span class="token punctuation">.</span><span class="token function">writeBoolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataOutputStream<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 序列化，将对象写入到输出流</span><span class="token class-name">ObjectOutputStream</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Guide哥"</span><span class="token punctuation">,</span> <span class="token string">"JavaGuide作者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>output<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程比较耗时；</li><li><strong>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</strong></li><li>所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</li></ul><p>例如，如果你想从<code>InputStream</code>中读取字符，你需要考虑字符的编码方式。<strong>如果字符使用UTF-8编码，一个字符可能由一个或多个字节组成。因此，直接使用<code>InputStream</code>的<code>read()</code>方法可能无法完整地读取一个字符，因为它一次只读取一个字节。</strong></p><p>要正确地从<code>InputStream</code>中读取字符，你可以使用<code>Reader</code>类及其子类，如<code>InputStreamReader</code>。<code>Reader</code>是字符输入流，专门用于读取字符。<code>InputStreamReader</code>是一个桥接类，它可以将字节流转换为字符流，同时指定字符编码。</p><blockquote><p>1，ASCII码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。</p><p>2，UTF-8编码：一个英文字符等于一个字节，<strong>一个中文（含繁体）等于三个字节</strong>。中文标点占三个字节，英文标点占一个字节</p><p>3，Unicode编码：<strong>一个英文等于两个字节</strong>，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节</p><p>4，GBK：英文占 1 字节，中文占 2 字节。</p></blockquote><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 字节流转换为字符流的桥梁</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InputStreamReader</span> <span class="token keyword">extends</span> <span class="token class-name">Reader</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 用于读取字符文件</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileReader</span> <span class="token keyword">extends</span> <span class="token class-name">InputStreamReader</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileReader</span> fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> content<span class="token punctuation">;</span>    <span class="token keyword">long</span> skip <span class="token operator">=</span> fileReader<span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The actual number of bytes skipped:"</span> <span class="token operator">+</span> skip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The content read from file:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>content <span class="token operator">=</span> fileReader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 字符流转换为字节流的桥梁</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutputStreamWriter</span> <span class="token keyword">extends</span> <span class="token class-name">Writer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 用于写入字符到文件</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileWriter</span> <span class="token keyword">extends</span> <span class="token class-name">OutputStreamWriter</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Writer</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    output<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"你好，我是Guide。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>IO 操作是很消耗性能的，<strong>缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作</strong>，提高流的传输效率。</p><p>字节缓冲流这里采用了<strong>装饰器模式</strong>来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 新建一个 BufferedInputStream 对象</span><span class="token class-name">BufferedInputStream</span> bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，<strong>字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</strong></p><p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span><span class="token keyword">class</span> <span class="token class-name">BufferedInputStream</span> <span class="token keyword">extends</span> <span class="token class-name">FilterInputStream</span> <span class="token punctuation">{</span>    <span class="token comment">// 内部缓冲区数组</span>    <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token keyword">byte</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 缓冲区的默认大小</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_BUFFER_SIZE</span> <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">;</span>    <span class="token comment">// 使用默认的缓冲区大小</span>    <span class="token keyword">public</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> in<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> <span class="token constant">DEFAULT_BUFFER_SIZE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 自定义缓冲区大小</span>    <span class="token keyword">public</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> in<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Buffer size &lt;= 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字节缓冲输出流</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token string">"JavaGuide"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p><code>System.out</code> 实际是用于获取一个 <code>PrintStream</code> 对象，<code>print</code>方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。</p><p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p><h3 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h3><p>这里要介绍的随机访问流指的是<strong>支持随意跳转到文件的任意位置进行读写</strong>的 <code>RandomAccessFile</code> 。</p><p><code>RandomAccessFile</code> 的构造方法如下，我们可以指定 <code>mode</code>（读写模式）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span><span class="token keyword">public</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">,</span> <span class="token class-name">String</span> mode<span class="token punctuation">)</span>    <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 私有方法</span><span class="token keyword">private</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">,</span> <span class="token class-name">String</span> mode<span class="token punctuation">,</span> <span class="token keyword">boolean</span> openAndDelete<span class="token punctuation">)</span>  <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">{</span>  <span class="token comment">// 省略大部分代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">RandomAccessFile</span> randomAccessFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 内容ABCDEFG</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取之前的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">",当前读取到的字符"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，读取之后的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><span class="token comment">// 指针当前偏移量为 6</span>randomAccessFile<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取之前的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">",当前读取到的字符"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，读取之后的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7</span><span class="token comment">// 从偏移量 7 的位置开始往后写入字节数据</span>randomAccessFile<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'H'</span><span class="token punctuation">,</span> <span class="token char">'I'</span><span class="token punctuation">,</span> <span class="token char">'J'</span><span class="token punctuation">,</span> <span class="token char">'K'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 文件内容变为 ABCDEFGHIJK</span><span class="token comment">// 指针当前偏移量为 0，回到起始位置</span>randomAccessFile<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取之前的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">",当前读取到的字符"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，读取之后的偏移量："</span> <span class="token operator">+</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getFilePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间。</p><p><strong>我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间</li></ol><p>Java 的 I/O 模型主要有三种：BIO（Blocking I/O，阻塞 I/O）、NIO（Non-blocking I/O，非阻塞 I/O）和 AIO（Asynchronous I/O，异步 I/O）。</p><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会<strong>一直阻塞，直到内核把数据拷贝到用户空间</strong>。</p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h2 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h2><p>Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 <strong>对于高负载、高并发的（网络）应用，应使用 NIO</strong> 。Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过<strong>轮询</strong>操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，<strong>等内核把数据准备好了，用户线程再发起 read 调用。</strong>read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。<strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><blockquote><p>NIO采用了多路复用器（Selector）来实现非阻塞 I/O。一个线程可以管理多个连接，当某个连接有数据可读或可写时，Selector 会通知线程进行相应的处理。</p></blockquote><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png" alt="Buffer、Channel和Selector三者之间的关系" style="zoom:50%;"><ul><li><strong>Channel（通道）</strong>：类似于传统 I/O 中的流，但 Channel 是双向的，可以同时进行读写操作。常见的 Channel 有 <code>FileChannel</code>、<code>SocketChannel</code>、<code>ServerSocketChannel</code> 等。</li><li><strong>Buffer（缓冲区）</strong>：用于存储数据，所有的数据都必须先读到 Buffer 中，或者从 Buffer 中写入。常见的 Buffer 有 <code>ByteBuffer</code>、<code>CharBuffer</code> 等。</li><li><strong>Selector（选择器）</strong>：用于监听多个 Channel 的事件（如连接、读、写等），当某个 Channel 有事件发生时，Selector 会将其选中。</li></ul><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是<strong>基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</strong></p><table><thead><tr><th>I/O 模型</th><th>阻塞特性</th><th>线程管理</th><th>适用场景</th></tr></thead><tbody><tr><td>BIO</td><td>阻塞直到处理完成</td><td>每个连接一个线程</td><td>连接数少且固定</td></tr><tr><td>NIO</td><td>非阻塞，selector监听多个channel</td><td>一个线程管理多个连接</td><td>连接数多且连接时间短</td></tr><tr><td>AIO</td><td>异步，通知回调</td><td>异步回调，无需线程等待</td><td>连接数多且连接时间长</td></tr></tbody></table><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法<strong>，这种语法对编程语言的功能并没有影响</strong>。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要<strong>先通过编译器进行解糖</strong>，也就是在程序<strong>编译阶段将其转换成 JVM 认识的基本语法</strong>。这也侧面说明，Java 中<strong>真正支持语法糖的是 Java 编译器</strong>而不是 JVM。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。</p><p>Java 中最常用的语法糖主要有<strong>泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式</strong>等。</p><p>增强for循环：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Student</span> stu <span class="token operator">:</span> students<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stu<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        students<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>会抛出<code>ConcurrentModificationException</code>异常。</p><p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个<strong>指向原来对象的单链索引表</strong>，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p><p>所以 <strong><code>Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。</strong>但你可以使用 <code>Iterator</code> 本身的方法<code>remove()</code>来删除对象，<code>**Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。**</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java 集合，也叫作<strong>容器</strong>，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。</p><img src="/2024/06/15/java/java-collection-hierarchy.png" alt="Java 集合框架概览" style="zoom:80%;"><ul><li><code>List</code>: 存储的元素是有序的、可重复的。</li><li><code>Set</code>: 存储的元素不可重复的。</li><li><code>Queue</code>: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h3><table><thead><tr><th>接口</th><th>集合类</th><th>底层数据结构</th><th>线程安全性</th><th>元素顺序</th><th>允许 null 值</th><th>查找效率</th><th>插入 / 删除效率</th><th>适用场景</th></tr></thead><tbody><tr><td><code>List</code></td><td><code>ArrayList</code></td><td>动态数组</td><td>否</td><td>有序（插入顺序）</td><td>允许</td><td>快，（通过索引）</td><td>尾部插入快；中间或头部插入慢，</td><td>需要频繁随机访问元素，插入 / 删除操作主要在尾部的场景</td></tr><tr><td></td><td><code>LinkedList</code></td><td>双向链表</td><td>否</td><td>有序（插入顺序）</td><td>允许</td><td>慢</td><td>头部、尾部插入删除快；中间插入删除需遍历</td><td>需要频繁在列表头部、尾部进行插入 / 删除操作的场景</td></tr><tr><td></td><td><code>Vector</code></td><td><strong>动态数组</strong></td><td><strong>是</strong></td><td>有序（插入顺序）</td><td>允许</td><td>快，（通过索引）</td><td>尾部插入快；中间或头部插入慢</td><td>线程安全，get、set、add 这些方法都加了 <code>synchronized</code> 关键字，执行效率比较低，所以现在已经很少用了</td></tr><tr><td></td><td><code>Stack</code></td><td><strong>动态数组</strong></td><td><strong>是</strong></td><td>有序，后进先出</td><td></td><td></td><td></td><td>Stack 执行效率比较低（方法上同样加了 synchronized 关键字）</td></tr><tr><td><code>Set</code></td><td><code>HashSet</code></td><td><code>HashMap</code>（键存储元素，值为固定对象）</td><td>否</td><td>无序</td><td>允许一个</td><td>快，平均</td><td>快，平均</td><td>需要存储不重复元素，不关心元素顺序的场景</td></tr><tr><td></td><td><code>LinkedHashSet</code></td><td>哈希表 + 双向链表</td><td>否</td><td>有序（插入顺序）</td><td>允许一个</td><td>快，平均</td><td>快，平均</td><td>需要存储不重复元素，且希望保持插入顺序的场景</td></tr><tr><td></td><td><code>TreeSet</code></td><td><strong>红黑树</strong></td><td>否</td><td>有序（自然顺序或指定比较器顺序）</td><td>不允许</td><td>中</td><td>中</td><td>需要存储不重复元素，且需要元素按自然顺序或自定义顺序排序的场景</td></tr><tr><td><code>Queue</code></td><td><code>ArrayDeque</code></td><td>循环数组</td><td>否</td><td>先进先出（FIFO）</td><td>不允许</td><td>-</td><td>头部、尾部插入删除快</td><td>作为栈或队列使用，需要高效的双端操作场景</td></tr><tr><td></td><td><code>PriorityQueue</code></td><td><strong>堆（二叉堆）</strong></td><td>否</td><td>按元素优先级排序</td><td>不允许</td><td>-</td><td>插入 ，删除头部元素快</td><td>需要根据元素优先级进行排序和处理的场景</td></tr><tr><td><code>Map</code></td><td><code>HashMap</code></td><td>哈希表（数组 + 链表 / 红黑树）</td><td>否</td><td>无序</td><td>键允许一个 null，值允许多个 null</td><td>快，平均</td><td>快，平均</td><td>存储键值对，不关心键的顺序，需要快速查找的场景</td></tr><tr><td></td><td><code>LinkedHashMap</code></td><td>哈希表 + 双向链表</td><td>否</td><td>有序（插入顺序或访问顺序）</td><td>键允许一个 null，值允许多个 null</td><td>快，平均</td><td>快，平均</td><td>存储键值对，需要保持键的插入顺序或访问顺序的场景</td></tr><tr><td></td><td><code>TreeMap</code></td><td><strong>红黑树</strong></td><td>否</td><td>有序（<strong>键的自然顺序或指定比较器顺序</strong>）</td><td>键不允许 null，值允许多个 null</td><td>中</td><td>中</td><td>存储键值对，需要键按自然顺序或自定义顺序排序的场景</td></tr><tr><td></td><td><code>Hashtable</code></td><td>哈希表</td><td>是</td><td>无序</td><td>键和值都不允许 null</td><td>快，平均</td><td>快，平均</td><td>需要线程安全且对性能要求不高的存储键值对场景</td></tr><tr><td></td><td><code>ConcurrentHashMap</code></td><td>分段锁（JDK 7）/ CAS + synchronized（JDK 8）</td><td>是</td><td>无序</td><td>键和值都不允许 null</td><td>快，平均</td><td>快，平均</td><td>高并发场景下存储键值对的场景</td></tr></tbody></table><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><code>ArrayList</code> 的底层是<strong>数组队列</strong>，相当于<strong>动态数组</strong>。与 Java 中的数组相比，它的<strong>容量能动态增长</strong>。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以<strong>减少递增式再分配的数量</strong>。</p><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>List</code> : 表明它是一个列表，支持<strong>添加、删除、查找</strong>等操作，并且可以<strong>通过下标进行访问</strong>。</p></li><li><p><code>RandomAccess</code> ：这是一个<strong>标志接口</strong>，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p></li><li><p><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</p></li><li><p><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</p></li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>JDK1.8</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 默认初始容量为10</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_CAPACITY</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">// 若初始化时传入参数new ArrayList(0)，则创建空数组EMPTY_ELEMENTDATA</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 用于默认大小空实例的共享空数组实例。即无参构造函数，初始为空数组，添加第一个元素时容量变为DEFAULT_CAPACITY = 10</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 实际保存arraylist数据的数组</span><span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment">// arraylist包含元素的个数</span><span class="token comment">// 有参构造函数如下。无参函数 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//如果传入的参数等于0，创建空数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//其他情况，抛出异常</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span> <span class="token operator">+</span>                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p><code>ensureCapacity</code> 这个方法 <code>ArrayList</code> 内部没有被调用过，是给用户调用的。</p><p>理论上来说，最好在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p><p>public void ensureCapacity(int minCapacity)</p><ul><li>函数内部判断elementdata数据数组是否是DEFAULTCAPACITY_EMPTY_ELEMENTDATA，如果是的话赋值minExpand=10，表示已有的最大容量是10，否则为0，表示在初始化传参的情况下，动态数组可以扩容为任意大小。</li><li>若minCapacity &gt; minExpand，调用<strong>ensureExplicitCapacity(minCapacity);</strong> 以保证最小需求容量能够达到。</li><li>在ensureExplicitCapacity(minCapacity)内，<strong>若minCapacity&gt;当前elementdata元素数组的大小，则调用grow(minCapacity)方法进行扩容。</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/***  扩容：新容量扩大为Max(minCapacity, 1.5倍oldCapacity)，若超出了预定义的最大array大小，则一次性扩容为MAX_VALUE*/</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// oldCapacity为旧容量，newCapacity为新容量</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>    <span class="token comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span>    <span class="token comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>    <span class="token comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入删除时用到的扩容判断函数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 确保内部容量达到指定的最小容量。</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 否则直接返回最小容量</span>    <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="插入删除"><a href="#插入删除" class="headerlink" title="插入删除"></a>插入删除</h5><p>对于插入：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要<strong>扩容时，则需要执行一次 O(n) 的操作</strong>将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 尾部插入</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>    <span class="token comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 指定位置插入先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><span class="token comment">// 在容量判断方法内，若容量不足会进行扩容。若数组为空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，在第一次插入时扩容到10</span><span class="token comment">// 否则传入ensureExplicitCapacity的扩容参数是size+1，即当前数组大小+1。而在执行时实际newCapacity是原始1.5倍</span><span class="token comment">// 将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>    <span class="token comment">// arraycopy(Object src源数组, int srcPos起始位置, Object dest目标, int destPos目标位置, int length复制长度)</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                     size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于删除：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。</li></ul><h5 id="机制总结"><a href="#机制总结" class="headerlink" title="机制总结"></a>机制总结</h5><p>初始化时，默认无参构造函数给<code>elementData</code>（保存ArrayList数据的数组）赋值<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA={}</code>，也就是一个默认大小0的空实例。在第一次添加数据的时候才会真正分配容量<code>DEFAULT_CAPACITY = 10</code>。此后添加第2，3，，，一直到10个元素，<code>minCapacity - elementData.length &gt; 0</code>都不成立，也就是现有的Object数组的长度都大于需要的最小数组长度，所以不会扩容。到第11个元素时，进入<code>grow</code>方法扩容，新的容量<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>也就是原始大小的1.5倍。</p><p>此外，外部方法<code> ensureCapacity</code>可以供调用者手动传入<code> minCapacity</code>，这个值会在<code>grow</code>方法中与<code>newCapacity</code>比较， 如果1.5倍的<code>old </code>仍然小于需要的<code>minCapacity</code>，则更新<code>newCapacity</code>为<code>minCapacity</code>。</p><p>如果新容量大于 <code>MAX_ARRAY_SIZE</code>,进入(执行) <code>hugeCapacity()</code> 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p><h4 id="LinkeadList"><a href="#LinkeadList" class="headerlink" title="LinkeadList"></a>LinkeadList</h4><p><code>LinkedList</code> 是一个基于<strong>双向链表</strong>实现的集合类，经常被拿来和 <code>ArrayList</code> 做比较。</p><img src="/2024/06/15/java/bidirectional-linkedlist.png" alt="双向链表" style="zoom:80%;"><p>不过，我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好。</p><p><strong>LinkedList 为什么不能实现 RandomAccess 接口？</strong></p><p><code>RandomAccess</code> 是一个<strong>标记</strong>接口，用来表明<strong>实现该接口的类支持随机访问</strong>（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，<strong>内存地址不连续，只能通过指针来定位，不支持随机快速访问</strong>，所以不能实现 <code>RandomAccess</code> 接口。</p><p><code>LinkedList</code> 的类定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>  <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</p><p>阅读过 <code>ArrayList</code> 的源码我们就知道，<code>ArrayList</code> 同样继承了 <code>AbstractList</code> ， 所以 <code>LinkedList</code> 会有大部分方法和 <code>ArrayList</code> 相似。</p><p><code>LinkedList</code> 实现了以下接口：</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有<strong>双端队列</strong>的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li></ul><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p><code>LinkedList</code> 中的元素是通过 <code>Node</code> 定义的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">E</span> item<span class="token punctuation">;</span><span class="token comment">// 节点值</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span> <span class="token comment">// 指向的下一个节点（后继节点）</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span> <span class="token comment">// 指向的前一个节点（前驱结点）</span>    <span class="token comment">// 初始化参数顺序分别是：前驱结点、本身节点值、后继节点</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LinkedList</code> 中有一个无参构造函数和一个有参构造函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建一个空的链表对象</span><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="插入删除-1"><a href="#插入删除-1" class="headerlink" title="插入删除"></a>插入删除</h5><ul><li><code>add(E e)</code>：尾部插入，复杂度O(1)。调用<code>linkLast(E e)</code>方法。维护last引用为最后一个节点，创建新节点，新节点prev为last，next为null。如果是第一个节点，还要将其赋值给first。如果不是，则让原始的last的next指向新节点。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 将元素节点插入到链表尾部</span><span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 将最后一个元素赋值（引用传递）给节点 l</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>    <span class="token comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 last 引用指向新节点</span>    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token comment">// 判断尾节点是否为空</span>    <span class="token comment">// 如果 l 是null 意味着这是第一次添加元素</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token comment">// 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next</span>        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>add(int index, E element)</code>：指定位置插入，需要移动平均 n/4 个元素，时间复杂度为 O(n)。调用<code>linkBefore(element, node(index))</code>，先移动指针，再修改指针</p><ul><li>先判断index是否是尾部，如果是则调用linkLast进行尾部插入（尾部插入要更新last指针，所以单独处理</li><li><strong>node（int index）函数会遍历找到要插入位置的元素。根据index位置从前往后或从尾向前找。</strong></li><li>linkBefore中将定位到的node的prev指向新节点，新节点prev指向node的prev，next指向node。如果node之前的前驱为空，则插入的新节点为第一个节点，赋值first，否则node的前驱的后继指向新节点。</li></ul></li></ul><p>删除：</p><ul><li><code>removeFirst()</code>：删除并返回链表的第一个元素。内部调用unlinkFirst(first)方法：取出头节点用于返回。头节点item及next置空，帮助GC回收。first引用更新为next元素，如果next是空需要把last更新为null；否则将next的prev置null。</li><li><code>removeLast()</code>：删除并返回链表的最后一个元素。内部调用unlinkLast(last)方法：取出尾节点。尾节点item及prev置空，上一个节点赋值last，如果上一个节点为null说明原来只有last一个元素，设置first为null；否则让上一节点的next更新为null。</li></ul><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">private E unlinkLast(Node&lt;E&gt; l) {    // assert l == last &amp;&amp; l != null;    final E element = l.item;    final Node&lt;E&gt; prev = l.prev;    l.item = null;    l.prev = null; // help GC    last = prev;    if (prev == null)        first = null;    else        prev.next = null;    size--;    modCount++;    return element;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。通过遍历链表来找要删除的元素位置，然后调用unlink(node)方法。</li><li><code>remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。先检查下标是否越界，然后调用unlink(node(idx))。<ul><li>node(idx)是通过下标找到元素并返回Node元素。unlink(node)方法删除对应元素。</li></ul></li><li><code>void clear()</code>：移除此链表中的所有元素。</li></ul><h5 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h5><p>在定位第idx个元素时，调用node(index)方法，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。</p><p><code>unlink(x)</code> 方法的逻辑如下：</p><ol><li>首先获取待删除节点 x 的前驱和后继节点；</li><li>判断待删除节点是否为头节点或尾节点： <ul><li>如果 x 是头节点（x的prev为null），则直接将 first 指向 x 的后继节点 next</li><li>如果 x 是尾节点（x的next为null），则将 last 指向 x 的前驱节点 prev</li><li>如果 x 不是头节点也不是尾节点，执行345断开链接并清除元素</li></ul></li><li>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</li><li>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</li><li>将待删除节点 x 的元素置空（方便GC回收），修改链表长度。</li></ol><h4 id="ArrayList-vs-LinkedList"><a href="#ArrayList-vs-LinkedList" class="headerlink" title="ArrayList vs LinkedList"></a>ArrayList vs LinkedList</h4><ul><li><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是<strong>不同步的</strong>，也就是<strong>不保证线程安全；</strong></p><ul><li>当多个线程同时对ArrayList进行修改操作时，可能会导致数据不一致或者出现异常。这是因为ArrayList的内部结构不是线程安全的，它<strong>没有提供对并发修改的支持</strong>。例如，当一个线程正在向ArrayList中添加元素，而另一个线程同时在删除元素，就有可能导致<strong>索引越界或者元素丢失</strong>的问题。</li><li>推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</li></ul></li><li><p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）</p></li><li><p><strong>插入和删除是否受元素位置的影响：</strong></p><ul><li><code>ArrayList</code> 采用<strong>数组</strong>存储，所以插入和删除元素的时间复杂度<strong>受元素位置的影响</strong>。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li><code>LinkedList</code> 采用<strong>链表</strong>存储，所以在头尾插入或者删除元素<strong>不受元素位置的影响</strong>（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要<strong>先移动到指定位置</strong>再插入和删除。</li><li>总结：ArrayList查询O(1)，开头或指定位置插入删除O(n)。LinkedList查询O(n)，插入删除自身操作O(1)，所以在中间特定位置插入删除整体O(n)</li></ul></li><li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><ul><li>LinkedList是双向链表，不能根据下标直接取元素；ArrayList是动态数组，所以支持快速随机访问。</li></ul></li><li><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 <strong>list 列表的结尾会预留一定的容量空间</strong>，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为<strong>要存放直接后继和直接前驱</strong>以及数据）。</p></li></ul><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>在 JDK1.5 之前，如果想要使用<strong>并发安全</strong>的 <code>List</code> 只能选择 <code>Vector</code>。而 <code>Vector</code> 是一种老旧的集合，已经被淘汰。<code>Vector</code> 对于增删改查等方法基本都加了 <strong><code>synchronized</code><strong>，这种方式虽然能够保证同步，但这相当于对整个 <code>Vector</code> 加上了一把大锁，使得</strong>每个方法执行的时候都要去获得锁，导致性能非常低下</strong>。</p><p>JDK1.5 引入了 <code>Java.util.concurrent</code>（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 <code>List</code> 实现就是 <code>CopyOnWriteArrayList</code> 。</p><blockquote><p>对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该<strong>允许多个线程同时访问 <code>List</code> 的内部数据</strong>，毕竟对于读取操作来说是安全的。</p></blockquote><p>为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的<strong>读取操作是完全无需加锁的</strong>。<strong>写入操作也不会阻塞读取操作</strong>，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。</p><p><code>CopyOnWriteArrayList</code>名字中的“Copy-On-Write”即<strong>写时复制</strong>，简称 COW，是线程安全的核心。</p><blockquote><p>写入时复制（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同<strong>获取相同的指针指向相同的资源</strong>，直到某个调用者试图<strong>修改资源</strong>的内容时，<strong>系统才会真正复制一份专用副本（private copy）给该调用者</strong>，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p></blockquote><p>当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，不会直接修改原数组，而是会<strong>先创建底层数组的副本，对副本数组进行修改</strong>，修改完之后再将修改后的数组赋值给底层数组的引用，替换掉旧的数组，这样就可以保证写操作不会影响读操作了。写时复制机制非常<strong>适合读多写少</strong>的并发场景，能够极大地提高系统的并发性能。</p><p><strong>缺点：</strong></p><ul><li>内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。</li><li>写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以<strong>写操作的开销相对较大</strong>，在写入比较频繁的场景下，性能可能会受到影响。</li><li>数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。</li></ul><h5 id="核心机制-1"><a href="#核心机制-1" class="headerlink" title="核心机制"></a>核心机制</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token keyword">extends</span> <span class="token class-name">Object</span><span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span><span class="token punctuation">{</span>  <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现list，randomaccess，cloneable，serializable，和arraylist一样</p><p><code>CopyOnWriteArrayList</code> 的 <code>add()</code>方法有三个版本：</p><ul><li><code>add(E e)</code>：在 <code>CopyOnWriteArrayList</code> 的尾部插入元素。</li><li><code>add(int index, E element)</code>：在 <code>CopyOnWriteArrayList</code> 的指定位置插入元素。</li><li><code>addIfAbsent(E e)</code>：如果指定元素不存在，那么添加该元素。如果成功添加元素则返回 true。</li></ul><p>这里以<code>add(E e)</code>为例进行介绍：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    <span class="token comment">// 加锁</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取原来的数组</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 原来数组的长度</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 元素放在新数组末尾</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token comment">// array指向新数组</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment">// 解锁</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>add</code>方法内部用到了 <code>ReentrantLock</code> 加锁，保证了同步，<strong>避免了多线程写的时候会复制出多个副本出来。</strong>锁被<code>final</code>修饰保证了<strong>锁的内存地址肯定不会被修改</strong>，并且，释放锁的逻辑放在 <code>finally</code> 中，可以保证锁能被释放。</li><li>每次写操作都需要通过 <code>Arrays.copyOf</code> 复制底层数组，<strong>时间复杂度是 O(n) 的</strong>，且会占用额外的内存空间。因此，<code>CopyOnWriteArrayList</code> 适用于读多写少的场景，在写操作不频繁且内存资源充足的情况下，可以提升系统的性能表现。</li></ul><ul><li><code>CopyOnWriteArrayList</code> 中并没有类似于 <code>ArrayList</code> 的 <code>grow()</code> 方法扩容的操作。</li></ul><p><strong>读取元素</strong>：<code>CopyOnWriteArrayList</code> 的读取操作是基于内部数组 <code>array</code> 并没有发生实际的修改，因此在读取操作时不需要进行同步控制和锁操作，可以保证数据的安全性。这种机制下，多个线程可以同时读取列表中的元素。不过，<code>get</code>方法是弱一致性的，<strong>在某些情况下可能读到旧的元素值。</strong>（比如，线程1读数据，线程2写数据，线程1取值，此时取值就是旧的值）</p><p>删除元素：</p><p><code>CopyOnWriteArrayList</code>删除元素相关的方法一共有 4 个：</p><ol><li><code>remove(int index)</code>：移除此列表中指定位置上的元素。将任何后续元素向左移动（从它们的索引中减去 1）。</li><li><code>boolean remove(Object o)</code>：删除此列表中首次出现的指定元素，如果不存在该元素则返回 false。</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>：从此列表中删除指定集合中包含的所有元素。</li><li><code>void clear()</code>：移除此列表中的所有元素。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取可重入锁</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    <span class="token comment">// 加锁</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取当前array数组</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取当前array长度</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//获取指定索引的元素(旧值)</span>        <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> len <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 判断删除的是否是最后一个元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token comment">// 如果删除的是最后一个元素，直接复制该元素前的所有元素到新的数组</span>            <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 分段复制，将index前的元素和index+1后的元素复制到新数组</span>            <span class="token comment">// 新数组长度为旧数组长度-1</span>            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 将新数组赋值给array引用</span>            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>         <span class="token comment">// 解锁</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ArrayList-vs-Array"><a href="#ArrayList-vs-Array" class="headerlink" title="ArrayList vs Array"></a>ArrayList vs Array</h4><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><strong>无序性和不可重复性：</strong></p><ul><li>无序性不等于随机性 ，无序性是指<strong>存储的数据在底层数组中</strong>并非按照数组索引的顺序添加 ，而是根<strong>据数据的哈希值决定</strong>的。<ul><li>所以HashSet/HashMap是无序的，而LinkedHashSet通过链表维护了插入和取出的顺序，是有序的</li></ul></li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><code>HashSet</code> 内部使用一个 <code>HashMap</code> 来存储元素。<code>HashSet</code> 中的元素被存储为 <code>HashMap</code> 的键，而 <code>HashMap</code> 的值则统一使用一个静态的 <code>PRESENT</code> 对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// HashMap用于存储操作，HashSet底层封装类对象</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span><span class="token comment">// HashSet是将元素存放在HashMap的key中，因此使用一个静态常量来充当HashMap的value值</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回集合中是否包含指定元素o</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 添加指定元素e</span><span class="token comment">// 将e作为HashMap的key 常量PRESENT作为所有元素的value</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 移出指定元素o</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token operator">==</span><span class="token constant">PRESENT</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="HashSet、LinkedHashSet-vs-TreeSet"><a href="#HashSet、LinkedHashSet-vs-TreeSet" class="headerlink" title="HashSet、LinkedHashSet vs TreeSet"></a>HashSet、LinkedHashSet vs TreeSet</h4><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，<strong>都能保证元素唯一</strong>，并且<strong>都不是线程安全的。</strong><ul><li>不安全的原因是因为HashMap不是线程安全的。在HashSet中，底层源码，其实就是一个HashMap，HashMap的key为HashSet中的值，而value为一个Object对象常量。</li></ul></li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，<strong>元素的插入和取出顺序满足 FIFO</strong>。<code>TreeSet</code> 底层数据结构是<strong>红黑树</strong>，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于<strong>不需要保证元素插入和取出顺序的场景</strong>，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><p><strong>HashSet如何检查重复</strong></p><blockquote><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p></blockquote><p>在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Returns: true if this set did not already contain the specified element</span><span class="token comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><p><code>ArrayDeque</code> 允许在队列的两端（头部和尾部）进行快速的插入、删除和访问操作，底层数据结构为<strong>循环数组</strong>。既可以当作栈使用（后进先出，LIFO），也可以当作队列使用（先进先出，FIFO）。它不允许存储 <code>null</code> 元素，并且线程不安全，在单线程环境下使用。</p><p>当需要使用栈时，Java 已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>（双端队列），因为Stack的核心方法上都加了 <code>synchronized</code> 关键字以确保线程安全，当我们不需要线程安全（比如说单线程环境下）性能就会比较差。</p><p>ArrayDeque 又实现了 Deque 接口（Deque 又实现了 Queue 接口），因此，当我们需要使用队列的时候，也可以选择 ArrayDeque。</p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/arraydeque-1e7086a3-3d31-4553-aa16-5eaf2193649e.png" alt="img" style="zoom:67%;"><p><strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于 0，<code>tail</code>也不一定总是比<code>head</code>大。</p><ul><li><strong>插入和删除操作</strong>：在队列的头部和尾部进行插入和删除操作的时间复杂度都是 O(1)，因为只需要移动指针，不需要像链表那样修改节点的引用。</li><li><strong>随机访问操作</strong>：支持随机访问，通过索引可以直接访问数组中的元素，时间复杂度为 。</li><li><strong>扩容操作</strong>：当队列中的元素数量达到数组容量时，会触发扩容操作，新容量是原容量的两倍。扩容操作需要创建新数组并复制元素，会带来一定的性能开销，但平均情况下插入和删除操作的性能仍然较好。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//不允许放入null</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    elements<span class="token punctuation">[</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//2.下标是否越界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span><span class="token comment">//1.空间是否够用</span>        <span class="token function">doubleCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//扩容</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doubleCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> head <span class="token operator">==</span> tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> n <span class="token operator">-</span> p<span class="token punctuation">;</span> <span class="token comment">// head右边元素的个数</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//原空间的2倍</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Sorry, deque too big"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> p<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复制右半部分，对应上图中绿色部分</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> r<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复制左半部分，对应上图中灰色部分</span>    elements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    tail <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以<strong>插入元素的时候不用考虑空间问题。</strong></p><p>下标越界处理：<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。</p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/arraydeque-f1386b63-10be-4998-bb6d-bf6560cca7ee.png" alt="img" style="zoom:50%;"><h4 id="ArrayDeque-与-LinkedList"><a href="#ArrayDeque-与-LinkedList" class="headerlink" title="ArrayDeque 与 LinkedList"></a>ArrayDeque 与 LinkedList</h4><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于<strong>可变长的数组和双指针</strong>来实现，而 <code>LinkedList</code> 则通过<strong>双向链表</strong>来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，<strong>但 <code>LinkedList</code> 支持。</strong></li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过**均摊后的插入操作依然为 O(1)**。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li><li>从性能的角度上，<strong>选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。</strong>此外，<code>ArrayDeque</code> 也可以用于实现栈。</li><li><code>ArrayDeque</code> 和 <code>LinkedList</code> 都不是线程安全的。如果在多线程环境下使用，需要进行额外的同步操作，或者使用线程安全的替代类，如 <code>ConcurrentLinkedDeque</code>。</li></ul><h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><p>因为ArrayDeque 的底层实现是数组，而 LinkedList 的底层实现是链表。<strong>数组是一段连续的内存空间</strong>，而链表是由多个节点组成的，每个节点存储数据和指向下一个节点的指针。因此，<strong>在使用 LinkedList 时，需要频繁进行内存分配和释放</strong>，而 ArrayDeque 在创建时就一次性分配了连续的内存空间，不需要频繁进行内存分配和释放，这样可以更好地利用 CPU 缓存，提高访问效率。</p><p>现代计算机CPU对于<strong>数据的局部性</strong>有很强的依赖，如果需要访问的数据在内存中是连续存储的，那么就可以利用CPU的缓存机制，提高访问效率。而当数据存储在不同的内存块里时，每次访问都需要从内存中读取，效率会受到影响。</p><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于<strong>元素出队顺序是与优先级相关的</strong>，即总是<strong>优先级最高的元素先出队</strong>。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了<strong>二叉堆</strong>的数据结构来实现的，底层使用<strong>可变长的数组</strong>来存储数据。<ul><li>小顶堆是一个<strong>完全二叉树</strong>，任何一个非叶子节点的权值，都不大于其左右子节点的权值。</li><li>完全二叉树：除了最后一层，其他层的节点数都是满的，最后一层的节点都靠左对齐。</li><li>完全二叉树的结构比较规则，可以使用数组存储。对于数组中索引为 <code>i</code> 的元素，其左子节点的索引为 <code>2 * i + 1</code>，右子节点的索引为 <code>2 * i + 2</code>，父节点的索引为 <code>(i - 1) / 2</code>。</li></ul></li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 <strong>O(logn)</strong> 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是<strong>非线程安全</strong>的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><pre class="line-numbers language-none"><code class="language-none">     10                ------  0     /  \   20    15             ------ 1和2 = 2i+1和2i+2  /  \30   40                 ------ 3和4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 存储元素的数组</span><span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> queue<span class="token punctuation">;</span><span class="token comment">// 队列中元素的数量</span><span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 比较器，用于定义元素的排序规则</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">;</span><span class="token comment">// 修改次数，用于快速失败机制</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">// 不允许放入null元素</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 自动扩容</span>    size <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 队列原来为空，这是插入的第一个元素</span>        queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">siftUp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调整，维持堆的性质</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 将元素x插入到位置k，上浮操作维护堆的性质</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">// 如果指定了比较器，则使用带有比较器的上浮方法</span>        <span class="token function">siftUpUsingComparator</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> queue<span class="token punctuation">,</span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token comment">// 否则，使用基于元素自然顺序的上浮方法</span>        <span class="token function">siftUpComparable</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">siftUpComparable</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">T</span> x<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> es<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 将元素 x 转换为 Comparable 类型，以便进行比较</span>    <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 从插入位置 k 开始，不断向上比较并交换，直到满足堆的性质</span>        <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// parentNo = (nodeNo-1)/2</span>        <span class="token class-name">Object</span> e <span class="token operator">=</span> es<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 如果插入元素 x 大于或等于父节点的值，说明已经找到了合适的位置（满足小顶堆），停止上浮</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        es<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">// 否则，将父节点的值下移到当前位置 k（满足x作为根，比原父节点e及其子节点小）</span>        k <span class="token operator">=</span> parent<span class="token punctuation">;</span> <span class="token comment">// 更新当前位置 k 为父节点的位置，继续向上比较</span>    <span class="token punctuation">}</span>    es<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">siftUpUsingComparator</span><span class="token punctuation">(</span>    <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">T</span> x<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> es<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> cmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> e <span class="token operator">=</span> es<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 使用指定的比较器比较插入元素 x 和父节点的值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        es<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        k <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    es<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>将元素x插入到位置k，实际使用时poll弹出堆顶权值最小的元素，然后siftDown(0,  queue最后一个元素x)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> half <span class="token operator">=</span> size <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> half<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span>        <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//leftNo = parentNo*2+1</span>        <span class="token class-name">Object</span> c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span>            comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child <span class="token operator">=</span> right<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// x已经比孩子节点小了</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token comment">//然后用c取代原来的值</span>        k <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理如果是remove(object o)：</p><ol><li>删除的是最后一个元素。直接删除即可，不需要调整。</li><li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。</li></ol><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/PriorityQueue-e25ba931-2e6f-4c17-84b8-9b959733d541.png" alt="PriorityQueue_poll.png" style="zoom:50%;"><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><code>BlockingQueue</code> （阻塞队列）是一个<strong>接口</strong>，继承自 <code>Queue</code>。<code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><p><strong>实现类：</strong></p><p>Java 中常用的阻塞队列实现类有以下几种：</p><ol><li><code>ArrayBlockingQueue</code>：使用<strong>数组</strong>实现的有界阻塞队列。<strong>在创建时需要指定容量大小</strong>，并支持公平和非公平两种方式的锁访问机制。</li><li><code>LinkedBlockingQueue</code>：使用<strong>单向链表</strong>实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code>Integer.MAX_VALUE</code>。和<code>ArrayBlockingQueue</code>不同的是， 它仅支持<strong>非公平</strong>的锁访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的<strong>无界</strong>阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</li><li><code>SynchronousQueue</code>：<strong>同步队列</strong>，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：<strong>延迟队列</strong>，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li></ol><h4 id="ArrayBlockingQueue-和-LinkedBlockingQueue"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue"></a>ArrayBlockingQueue 和 LinkedBlockingQueue</h4><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 是 Java 并发包中常用的两种阻塞队列实现，它们都是<strong>线程安全</strong>的。它们之间存在下面这些区别：</p><ul><li><strong>底层实现</strong>：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li><li><strong>是否有界</strong>：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也<strong>可以指定</strong>队列大小，从而成为有界的。</li><li><strong>锁是否分离</strong>： <code>ArrayBlockingQueue</code>中的锁是没有分离的，即<strong>生产和消费用的是同一个锁</strong>；<code>LinkedBlockingQueue</code>中的锁是分离的，即**生产用的是<code>putLock</code>，消费是<code>takeLock</code>**，这样可以防止生产者和消费者线程之间的锁争夺。</li><li><strong>内存占用</strong>：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。这意味着，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是<strong>非线程安全</strong>的。</p><p><strong>JDK1.8 之前</strong></p><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 <strong>hash 值以及 key</strong> 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><p><strong>JDK1.8 之后</strong></p><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64，那么会选择先进行数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><img src="/2024/06/15/java/jdk1.8_hashmap.png" alt="jdk1.8之后的内部结构-HashMap" style="zoom:80%;"><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><p><strong><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token comment">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">362498820763181265L</span><span class="token punctuation">;</span>    <span class="token comment">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">// 最大容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token comment">// 默认的负载因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment">// 桶中结构转化为红黑树对应的table的最小容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment">// =====存储元素的数组，总是2的幂次倍=====</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token comment">// 一个包含了映射中所有键值对的集合视图</span>    <span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entrySet<span class="token punctuation">;</span>    <span class="token comment">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment">// 负载因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Node节点类，继承自 Map.Entry&lt;K,V&gt;</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span><span class="token comment">//键</span>       <span class="token class-name">V</span> value<span class="token punctuation">;</span><span class="token comment">//值</span>       <span class="token comment">// 指向下一个节点-&gt;链式结构</span>       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>       <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 树节点类 -- 红黑树</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">;</span>  <span class="token comment">// 父</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> left<span class="token punctuation">;</span>    <span class="token comment">// 左</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> right<span class="token punctuation">;</span>   <span class="token comment">// 右</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span>    <span class="token comment">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>           <span class="token comment">// 判断颜色</span>        <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> val<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 返回根节点</span>        <span class="token keyword">final</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>loadFactor 负载因子</strong><ul><li>loadFactor 负载因子是控制<strong>数组存放数据的疏密程度</strong>，loadFactor 越趋近于 1，那么 数组中能存放的数据(entry)也就越多（要达到临界值<strong>threshold = capacity * loadFactor</strong>的时候才会扩容），也就越密，也就是会让链表的长度增加（因为要很久才扩容，这段数组本身很密，冲突的数据也多，链表就长），loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</li><li><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</li><li>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li></ul></li></ul><h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><p>构造方法都初始化了负载因子 loadFactor，由于 HashMap 中没有 capacity 这样的字段，即使指定了初始化容量 initialCapacity ，也只是通过 tableSizeFor 将其<strong>扩容到与 initialCapacity 最接近的 2 的幂次方大小</strong>，然后暂时赋值给 threshold ，后续通过 resize 方法将 threshold 赋值给 newCap 进行 table 的初始化。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 默认构造函数。</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span> <span class="token comment">// all   other fields defaulted</span><span class="token punctuation">}</span><span class="token comment">// 包含另一个“Map”的构造函数</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span>    <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//下面会分析到这个方法</span><span class="token punctuation">}</span><span class="token comment">// 指定“容量大小”的构造函数</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 指定“容量大小”和“负载因子”的构造函数</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>        initialCapacity <span class="token operator">=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment">// 初始容量暂时存放到 threshold ，在resize函数中再赋值给 newCap 进行table初始化</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>putMapEntries 方法：</strong></p><p>final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</p><ul><li>先判断table是否已经初始化，如果没有，计算承载传入的m所有元素需要的最小容量 <code>ft = m的长度s / loadFactor + 1</code></li><li>如果计算出来的容量t大于初始化阈值容量threshold，执行tableSizeFor(t)，将阈值更新为邻近的2的幂次</li><li>如果table已经初始化，并且元素个人大于初始阈值，进行扩容</li><li>容量更新后，将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容</li></ul><h5 id="核心机制-2"><a href="#核心机制-2" class="headerlink" title="核心机制"></a>核心机制</h5><p>put方法插入元素：</p><ul><li><p>如果定位到的数组位置没有元素 就直接插入，对应<code>tab[i] = new Node(hash, key, value, null)</code>。</p></li><li><p>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖（将 数组位置元素p赋值给插入节点e）。</p></li><li><p>如果 key 不相同，遍历树/链表找插入位置：判断 桶内第一个元素p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>找到元素添加位置；如果不是就遍历链表插入（尾插法）</p></li></ul><p>只要数组铀元素，就是进行了hash冲突处理。通过判断首节点，或遍历树（链表），要插入的位置为e。e不为空就说明在现有元素中找到了key和hash相等的节点，此时直接将新值赋值给旧节点，返回旧值。e为空则为插入新节点，返回null表示没有旧值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token comment">// 对应桶的第一个节点赋值给p</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 桶中已经存在元素（处理hash冲突）</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>        <span class="token comment">// 快速判断第一个节点table[i]的key是否与插入的key一样</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">// 判断插入的是否是红黑树节点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 不是红黑树节点则说明为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span>                    <span class="token comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span>                    <span class="token comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 记录e的value</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="resize扩容"><a href="#resize扩容" class="headerlink" title="resize扩容"></a>resize扩容</h5><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><p><code>resize()</code> 方法的主要作用是调整 <code>HashMap</code> 的容量，具体包括以下几个方面：</p><ol><li><strong>扩容</strong>：将哈希表的容量扩大为原来的两倍。</li><li><strong>重新哈希</strong>：将原哈希表中的所有键值对重新计算哈希值，并放入新的哈希表中。</li><li><strong>更新阈值</strong>：根据新的容量更新阈值 <code>threshold</code>。</li></ol><p>过程：</p><p><strong>计算新容量和新阈值</strong></p><ul><li><p>如果旧容量已经达到最大容量（2^30），则无法再扩容，通过链表或红黑树添加元素。如果没超过最大值，新容量和新阈值扩充为原来的2倍。</p></li><li><p>如果旧容量为 0，但旧阈值大于 0，说明是通过构造函数指定了初始容量。此时新容量=设置的旧阈值。</p></li><li><p>如果旧容量和旧阈值都为 0，说明是使用默认构造函数创建的 HashMap。此时新容量=DEFAULT_INITIAL_CAPACITY;新阈值=(int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 阈值=Integer.MAX_VALUE,返回oldTab</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">&gt;=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>        newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 初始化容量</span><span class="token punctuation">}</span> <span class="token keyword">else</span>  <span class="token punctuation">{</span>    <span class="token comment">// 无参构造函数初始化容量</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 根据新容量和负载因子计算新阈值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建新的哈希表数组</strong>：根据新容量创建一个新的哈希表数组，并将其赋值给 <code>table</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 创建新的哈希表数组</span>table <span class="token operator">=</span> newTab<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 迁移元素</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>迁移元素</strong></p><ul><li>遍历旧的哈希表数组，对于每个位置的元素：<ul><li>如果该位置只有一个元素，直接重新计算哈希值并放入新表。</li><li>如果是树节点，调用树的拆分方法。<code>split()</code> 方法会根据元素在新哈希表中的位置将树拆分为两个部分，可能会将部分节点转换为链表，也可能会继续保持树结构。</li><li>如果是链表节点，将链表拆分为两个链表：<strong>一个链表中的元素在新表中的位置不变，另一个链表中的元素在新表中的位置为原位置加上旧容量。</strong>然后将这两个链表分别放入新表的相应位置。</li></ul></li></ul><blockquote><p>在 <code>HashMap</code> 中，<strong>元素存储位置的索引是通过 <code>hash &amp; (capacity - 1)</code> 计算得到的，</strong>其中 <code>hash</code> 是键的哈希值，<code>capacity</code> 是哈希表的容量。<strong>这种计算方式等价于对 <code>capacity</code> 取模运算</strong>，但由于位运算的效率更高，所以采用了按位与运算。</p><ul><li>例如，当 <code>capacity = 4</code> 时，<code>capacity - 1 = 3</code>，二进制表示为 <code>0011</code>。假设某个元素的哈希值 <code>hash = 5</code>，二进制表示为 <code>0101</code>，则 <code>hash &amp; (capacity - 1) = 0101 &amp; 0011 = 0001</code>，所以该元素在容量为 4 的哈希表中存储在索引为 1 的位置。</li></ul><p><code>HashMap</code> 的扩容规则是将容量扩大为原来的两倍，即 <code>newCap = oldCap * 2</code>。在二进制表示中，**<code>newCap</code> 相当于 <code>oldCap</code> 左移一位。<strong>在二进制层面，</strong><code>newCap - 1</code> 相比于 <code>oldCap - 1</code> 只是多了一位高位。**举例如下：假设旧容量 <code>oldCap = 4</code>（二进制 <code>0100</code>），那么 <code>oldCap - 1 = 3</code>（二进制 <code>0011</code>）；新容量 <code>newCap = 8</code>（二进制 <code>1000</code>），<code>newCap - 1 = 7</code>（二进制 <code>0111</code>）。</p><p>对于一个元素的哈希值 <code>hash</code>，在旧哈希表中的索引是 <code>hash &amp; (oldCap - 1)</code>，在新哈希表中的索引是 <code>hash &amp; (newCap - 1)</code>。而 <code>(e.hash &amp; oldCap) == 0</code> 这个判断，本质上就是在检查 <code>hash</code> 的二进制表示中对应 <code>oldCap</code> 为 1 的那一位是否为 0。</p><ul><li>如果 <code>(e.hash &amp; oldCap) == 0</code>，说明 <code>hash</code> 在这一位是 0，那么 <code>hash &amp; (newCap - 1)</code> 的结果和 <code>hash &amp; (oldCap - 1)</code> 的结果是一样的，也就是元素在新哈希表中的位置和旧哈希表中相同。</li><li>如果 <code>(e.hash &amp; oldCap) != 0</code>，说明 <code>hash</code> 在这一位是 1，那么 <code>hash &amp; (newCap - 1)</code> 的结果就等于 <code>hash &amp; (oldCap - 1)</code> 再加上 <code>oldCap</code>，即元素在新哈希表中的位置是旧位置加上 <code>oldCap</code>。</li></ul><p>所以，通过 <code>(e.hash &amp; oldCap) == 0</code> 判断得到的元素在新哈希表中的位置和重新计算 <code>hash &amp; (newCap - 1)</code> 得到的位置是完全一致的。这种设计的主要依据是为了在扩容时能够高效地将元素分配到新的哈希表中，避免对每个元素都重新计算完整的哈希值和索引。通过简单的按位与运算，可以快速判断元素在新哈希表中的位置是保持不变还是需要移动到新的位置（原位置 + <code>oldCap</code>），从而减少了计算开销，提高了扩容的效率。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 遍历旧的哈希表数组</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 释放旧表的引用，帮助垃圾回收</span>        oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 如果该位置只有一个元素，直接重新计算哈希值并放入新表</span>            newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment">// 如果是树节点，调用树的拆分方法</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>             <span class="token comment">// 链表节点处理</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment">// 将位置不变的链表放入新表的原位置</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 将位置变化的链表放入新表的新位置（原位置 + 旧容量）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="长度问题"><a href="#长度问题" class="headerlink" title="长度问题"></a>长度问题</h5><p>总结一下 <code>HashMap</code> 的长度是 2 的幂次方的原因：</p><ol><li>位运算效率更高：位运算(&amp;)比取余运算(%)更高效。当长度为 2 的幂次方时，<code>hash % length</code> 等价于 <code>hash &amp; (length - 1)</code>。</li><li>可以更好地保证哈希值的均匀分布：扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。</li><li>扩容机制变得简单和高效：扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。</li></ol><h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><p><code>HashMap</code> 线程不安全主要体现在多线程环境下进行并发操作时可能会出现数据不一致、死循环等问题</p><p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有<strong>数据覆盖</strong>的风险。</p><p>举个例子：</p><ul><li>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</li><li>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</li><li>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</li></ul><p>JDK1.7及以前： 多线程下的 resize 操作可能导致死循环。在 JDK 7 及以前，<code>HashMap</code> 的 <code>resize</code> 方法在扩容时采用头插法将原链表中的元素插入到新链表中。在多线程环境下，当多个线程同时触发 <code>resize</code> 操作时，可能会导致链表形成环形结构，从而造成死循环。</p><p>综上所述，由于 <code>HashMap</code> 在多线程环境下的 <code>put</code>、<code>resize</code> 和 <code>size</code> 等操作没有进行有效的同步控制，所以它是线程不安全的。在多线程环境中，如果需要使用线程安全的哈希表，可以考虑使用 <code>ConcurrentHashMap</code> 或 <code>Hashtable</code>。</p><h4 id="HashMap-vs-HashTable"><a href="#HashMap-vs-HashTable" class="headerlink" title="HashMap vs HashTable"></a>HashMap vs HashTable</h4><ul><li><p><strong>线程是否安全：</strong> <strong><code>HashMap</code> 是非线程安全的</strong>，<code>Hashtable</code> 是线程安全的，因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p></li><li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>对 Null key 和 Null value 的支持：</strong> <strong><code>HashMap</code> 可以存储 null 的 key 和 value</strong>，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。（ConcurrentHashMap也不支持存储null）</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。**<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。<strong>② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其</strong>扩充为 2 的幂次方大小**（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，上面给出了源代码）。也就是说=== <strong><code>HashMap</code> 总是使用 2 的幂作为哈希表的大小</strong>==。</p><ul><li>Hash函数的算法设计：<strong>取余</strong>(%)操作中如果除数是 2 的幂次则<strong>等价于</strong>与其除数减一的与(&amp;)操作（也就是说 <code>hash%length==hash&amp;(length-1)</code>的前提是 length 是 2 的 n 次方）。并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</li></ul></li><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树</strong>（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</strong>），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</p></li></ul><h4 id="HashMap-vs-TreeMap"><a href="#HashMap-vs-TreeMap" class="headerlink" title="HashMap vs TreeMap"></a>HashMap vs TreeMap</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p><code>NavigableMap</code> 接口提供了丰富的方法来探索和操作键值对，可以对集合元素进行<strong>搜索</strong>:</p><ol><li><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位<strong>大于、小于、大于等于、小于等于给定键</strong>的最接近的键值对。</li><li><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</li><li><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</li><li><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素。</li></ol><p>这些方法都是基于<strong>红黑树</strong>数据结构的属性实现的，红黑树保持平衡状态，从而保证了<strong>搜索操作的时间复杂度为 O(log n)<strong>，这让 <code>TreeMap</code> 成为了处理</strong>有序集合搜索问题</strong>的强大工具。</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><p><strong>综上，相比于<code>HashMap</code>来说， <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</strong></p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="1-7版本"><a href="#1-7版本" class="headerlink" title="1.7版本"></a>1.7版本</h5><p>1.7版本：Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code> 组合，而每一个 <code>Segment</code> 是一个类似于 <code>HashMap</code> 的结构，所以<strong>每一个 <code>HashMap</code> 的内部可以进行扩容</strong>。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> <strong>默认支持最多 16 个线程并发。</strong></p><img src="/2024/06/15/java/java7_concurrenthashmap.png" alt="Java 7 ConcurrentHashMap 存储结构" style="zoom:80%;"><p>在 Java 7 中 ConcurrentHashMap 的<strong>初始化</strong>逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 <code>concurrencyLevel</code> 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li><li>寻找并发级别 <code>concurrencyLevel</code> 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 <code>segmentShift</code> 偏移量，这个值为【容量 = 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li><li>记录 <code>segmentMask</code>，默认是 ssize - 1 = 16 -1 = 15.</li><li><strong>初始化 <code>segments[0]</code><strong>，</strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩容。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// 创建 Segment 数组，设置 segments[0]</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> s0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cap <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token punctuation">[</span>ssize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> <span class="token constant">SBASE</span><span class="token punctuation">,</span> s0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ordered write of segments[0]</span><span class="token keyword">this</span><span class="token punctuation">.</span>segments <span class="token operator">=</span> ss<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>========put========</strong></p><p><code>ConcurrentHashMap</code> 在**put **一个数据时的处理流程：</p><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 <code>Segment</code>。</p></li><li><p>如果指定位置的 <code>Segment</code> 为空，则初始化这个 <code>Segment</code>.</p><p><strong>初始化 Segment 流程：</strong></p><ol><li>检查计算得到的位置的 <code>Segment</code> 是否为 null.</li><li>为 null 继续初始化，使用 <code>Segment[0]</code> 的容量和负载因子创建一个 <code>HashEntry</code> 数组。</li><li>再次检查计算得到的指定位置的 <code>Segment</code> 是否为 null。<strong>因为这时可能有其他线程进行了操作</strong></li><li>使用创建的 <code>HashEntry</code> 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 <code>Segment</code> 是否为 null，使用 CAS 在这个位置赋值为 <code>Segment</code></li></ol></li><li><p><strong><code>Segment.put</code> 插入 key,value 值。</strong></p><p><strong>由于 <code>Segment</code> 继承了 <code>ReentrantLock</code>，</strong>所以 <code>Segment</code> 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p><code>tryLock()</code> 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p></li><li><p>CAS计算 put 的数据要放入的 index 位置，然后获取这个位置上的 <code>HashEntry</code> 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 <code>HashEntry</code> 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p><p>如果这个位置上的 <strong><code>HashEntry</code> 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接头插法插入。</li></ol><p>如果这个位置上的 <strong><code>HashEntry</code> 存在</strong>：</p><ol><li>判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li><li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表遍历完毕没有相同的。 <ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表头插法插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p></li></ol></li></ol><p><strong>========扩容rehash========</strong></p><p><code>ConcurrentHashMap</code> 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 <code>index+ oldSize</code>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><p><strong>===========get=========</strong></p><ol><li>计算得到 key 的存放的segment的对应HashEntry数组位置。</li><li>遍历指定位置的链表查找相同 key 的 value 值。</li></ol><h5 id="1-8版本"><a href="#1-8版本" class="headerlink" title="1.8版本"></a>1.8版本</h5><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><img src="/2024/06/15/java/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）" style="zoom: 80%;"><p><strong>==========初始化==========</strong></p><p><code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> （sizeControl 的缩写），它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化，其他线程需要<strong>自旋等待</strong></li><li>-N 说明 table 正在进行扩容，高 16 位表示扩容的标识戳，低 16 位减 1 为正在进行扩容的线程数</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Initializes table, using the size recorded in sizeCtl. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment">// 让出 CPU 使用权，自旋等待</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lost initialization race; just spin</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">;</span>                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>==========put===========</strong></p><ol><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足(桶里有数据，数组不需要扩容），则利用 synchronized 锁写入数据，写入时判断结构是链表还是红黑树，执行对应的插入操作。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</li></ol><p><strong>==========get===========</strong></p><ol><li>根据 hash 值计算node数组位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，使用find查找。</li><li>如果是链表，遍历查找之。</li></ol><h5 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h5><ul><li><p>JDK1.8之前：首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。<code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。**<code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁**，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p></li><li><p>JDK1.8之后：<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <strong><code>Node + CAS + synchronized</code></strong> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p><p>Java 8 中，锁粒度更细，<code>synchronized</code> <strong>只锁定当前链表或红黑二叉树的首节点</strong>，这样<strong>只要 hash 不冲突，就不会产生并发</strong>，就不会影响其他 Node 的读写，效率大幅提升。</p></li></ul><p>总结：1.7中使用segment分段锁，锁范围较大，最大并发数为segment数量，默认是16。1.8中使用Node+CAS+synchronized，只锁定链表或红黑树的头节点，锁粒度更细，最大并发数是node数组的大小。</p><h4 id="ConcurrentHashMap-vs-Hashtable"><a href="#ConcurrentHashMap-vs-Hashtable" class="headerlink" title="ConcurrentHashMap vs Hashtable"></a>ConcurrentHashMap vs Hashtable</h4><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+HashEntry</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，<strong>数组+链表/红黑二叉树</strong>。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p></li><li><p><strong>实现线程安全的方式</strong>（重要）：</p></li><li><p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割<strong>分段</strong>(<code>Segment</code>，分段锁)，<strong>每一把锁只锁容器其中一部分数据</strong>，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p></li><li><p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是<strong>直接用 <code>Node</code> 数组+链表+红黑树</strong>的数据结构来实现，并发控制使用 <strong><code>synchronized</code> 和 CAS</strong> 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是**优化过且线程安全的 <code>HashMap</code>**，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p></li><li><p><strong>Hashtable(同一把锁) <strong>:使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入</strong>阻塞或轮询</strong>状态，如使用 put 添加元素，<strong>另一个线程不能使用 put 添加元素，也不能使用 get</strong>，竞争会越来越激烈效率越低。</p></li></ul><img src="/2024/06/15/java/image-20240619175017147.png" alt="image-20240619175017147" style="zoom:80%;"><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p><code>LinkedHashMap</code> 是 Java 提供的一个集合类，它继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条<strong>双向链表</strong>，使得具备如下特性:</p><ol><li>支持遍历时会<strong>按照插入顺序</strong>有序进行迭代。–<code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序。因此，当使用迭代器迭代元素时，元素的顺序与它们最初插入的顺序相同。</li><li>支持按照元素<strong>访问</strong>顺序<strong>排序</strong>，用于<strong>封装 LRU 缓存</strong>工具。–<code>LinkedHashMap</code> 可以通过构造函数中的 <code>accessOrder</code> 参数<strong>指定按照访问顺序迭代元素</strong>。当 <code>accessOrder</code> 为 true 时，每次访问一个元素时，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</li><li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。</li></ol><p><code>LinkedHashMap</code> 逻辑结构如下图所示，它是在 <code>HashMap</code> 基础上<strong>在各个节点之间维护一条双向链表</strong>，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。</p><img src="/2024/06/15/java/linkhashmap-structure-overview.png" alt="LinkedHashMap 逻辑结构" style="zoom:67%;"><h5 id="核心机制-3"><a href="#核心机制-3" class="headerlink" title="核心机制"></a>核心机制</h5><ul><li><p><code>LinkedHashMap</code> 的<strong>节点内部类 <code>Entry</code></strong> 基于 <code>HashMap</code> 的基础上，增加 <code>before</code> 和 <code>after</code> 指针使节点具备双向链表的特性。</p></li><li><p><code>HashMap</code> 的树节点 <code>TreeNode</code> 继承了具备双向链表特性的 <code>LinkedHashMap</code> 的 <code>Entry</code>。</p></li></ul><p>总结：Entry类是LinkedHashMap中的节点类，充当HashMap中Node类的作用。</p><p>HashMap 的节点集合 Node则仅包含kv对和下一个元素指针，避免使用HashMap的时候也出现无关的双向链表元素。</p><p>TreeNode用于在内部链表转化为红黑树的时候使用，继承enry类来获取双向链表指针。但是这样做，也使得使用 <code>HashMap</code> 时的 <code>TreeNode</code> 多了两个没有必要的引用。对于这个问题,引用作者的一段注释，作者们认为<strong>在良好的 <code>hashCode</code> 算法时，<code>HashMap</code> 转红黑树的概率不大。就算转为红黑树变为树节点，也可能会因为移除或者扩容将 <code>TreeNode</code> 变为 <code>Node</code>，所以 <code>TreeNode</code> 的使用概率不算很大，对于这一点资源空间的浪费是可以接受的。</strong></p><img src="/2024/06/15/java/map-hashmap-linkedhashmap.png" alt="LinkedHashMap 和 HashMap 之间的关系" style="zoom: 50%;"><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><p><strong><code>get</code> 方法是 <code>LinkedHashMap</code> 增删改查操作中唯一一个重写的方法。</strong><code>accessOrder</code> 为 true 的情况下， 它会在元素查询完成之后，将当前访问的元素移到链表的末尾。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>     <span class="token comment">//获取key的键值对,若为空直接返回</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>     <span class="token comment">//若accessOrder为true，则调用afterNodeAccess将当前元素移到链表末尾</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>         <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//返回键值对的值</span>     <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// move node to last</span>    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>    <span class="token comment">//如果accessOrder 且当前节点不为链表尾节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//获取当前节点、以及前驱节点和后继节点</span>        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>            <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> <span class="token punctuation">)</span> e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        <span class="token comment">//将当前节点的后继节点指针指向空，使其和后继节点断开联系（清除p-&gt;p.after）</span>        p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">//如果前驱节点为空，则说明当前节点是链表的首节点，故将后继节点设置为首节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            head <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">//如果前驱节点不为空，则让前驱节点指向后继节点(清除p.before-&gt;p)</span>            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token comment">//如果后继节点不为空，则让后继节点指向前驱节点(清除p.after-&gt;p)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">//如果后继节点为空，则说明当前节点在链表最末尾，直接让last 指向前驱节点,这个 else其实 没有意义，因为最开头if已经确保了p不是尾结点了，自然after不会是null</span>            last <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token comment">//如果last为空，则说明当前链表只有一个节点p，则将head指向p</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            head <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//反之让p的前驱指针指向尾节点，再让尾节点的前驱指针指向p(构建last&lt;-p &amp; last-&gt;p)</span>            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//tail指向p，自此将节点p移动到链表末尾（更新last为p）</span>        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>remove 方法后置操作——afterNodeRemoval</strong>：<code>LinkedHashMap</code> 并没有对 <code>remove</code> 方法进行重写，而是直接继承 <code>HashMap</code> 的 <code>remove</code> 方法，为了保证键值对移除后双向链表中的节点也会同步被移除，<code>LinkedHashMap</code> 重写了 <code>HashMap</code> 的空实现方法 <code>afterNodeRemoval</code>。<code>afterNodeRemoval</code> 方法的整体操作就是让当前节点 p 和前驱节点、后继节点断开联系，等待 gc 回收</p></li><li><p><strong>put 方法后置操作——afterNodeInsertion</strong>：同样的 <code>LinkedHashMap</code> 并没有实现插入方法，而是直接继承 <code>HashMap</code> 的所有插入方法交由用户使用，但为了维护双向链表访问的有序性，它做了这样两件事:</p><ol><li><p>重写 <code>afterNodeAccess</code>(上文提到过),如果当前被插入的 key 已存在与 <code>map</code> 中，因为 <code>LinkedHashMap</code> 的插入操作会将新节点追加至链表末尾，所以对于存在的 key 则调用 <code>afterNodeAccess</code> 将其放到链表末端。</p></li><li><p>重写了 <code>HashMap</code> 的 <code>afterNodeInsertion</code> 方法，<strong>当 <code>removeEldestEntry</code> 返回 true 时，会将链表首节点移除。</strong></p></li></ol></li></ul><h5 id="实现LRU缓存"><a href="#实现LRU缓存" class="headerlink" title="实现LRU缓存"></a>实现LRU缓存</h5><ul><li>继承 <code>LinkedHashMap</code>;</li><li>构造方法中指定 <code>accessOrder</code> 为 true（遍历时，需要访问顺序则为 true，需要插入顺序则为 false） ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；</li><li>重写<code>removeEldestEntry</code> 方法，该方法会返回一个 boolean 值，告知 <code>LinkedHashMap</code> 是否需要移除链表首元素（缓存容量有限）。</li></ul><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {    private final int capacity;    public LRUCache(int capacity) {        super(capacity, 0.75f, true);        this.capacity = capacity;    }    /**     * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)     */    @Override    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {        return size() &gt; capacity;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LinkedHashMap-vs-HashMap"><a href="#LinkedHashMap-vs-HashMap" class="headerlink" title="LinkedHashMap vs HashMap"></a>LinkedHashMap vs HashMap</h4><p><code>LinkedHashMap</code> 和 <code>HashMap</code> 都是 Java 集合框架中的 Map 接口的实现类。它们的最大区别在于<strong>迭代元素的顺序</strong>。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照<strong>插入顺序或访问顺序</strong>迭代元素的功能。此外，<code>LinkedHashMap</code> 内部维护了一个<strong>双向链表，</strong>用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 的插入性能可能会比 <code>HashMap</code> 略低，但它提供了更多的功能并且<strong>迭代效率相较于 <code>HashMap</code> 更加高效</strong>。</p><blockquote><p><code>LinkedHashMap</code> 维护了一个双向链表来记录数据插入的顺序，因此在迭代遍历生成的迭代器的时候，是按照双向链表的路径进行遍历的。这一点相比于 <code>HashMap</code> 那种遍历整个 bucket 的方式来说，高效许多。</p></blockquote><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 由红黑树实现，可以保持key元素的自然顺序，或者实现了 Comparator 接口的自定义顺序。</p><blockquote><p>红黑树（英语：Red–black tree）是一种自平衡的二叉查找树（Binary Search Tree），结构复杂，但却有着良好的性能，完成查找、插入和删除的时间复杂度均为 log(n)。</p><p>常见的平衡二叉树包括AVL树、红黑树等等，它们都是通过旋转操作来调整树的平衡，使得左子树和右子树的高度尽可能接近。</p></blockquote><p>AVL树是一种高度平衡的二叉查找树，它要求左子树和右子树的高度差不超过1。由于AVL树的平衡度比较高，因此在进行插入和删除操作时需要进行更多的旋转操作来保持平衡，但是在查找操作时效率较高。AVL树适用于读操作比较多的场景。</p><p>红黑树，顾名思义，就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持二叉树的平衡：</p><ul><li>1）每个节点都只能是红色或者黑色</li><li>2）<strong>根节点是黑色</strong></li><li>3）<strong>每个叶节点（NIL 节点，空节点）是黑色的。</strong></li><li>4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说<strong>在一条路径上不能出现相邻的两个红色节点。</strong></li><li>5）从任一节点到其每个叶子的<strong>所有路径都包含相同数目的黑色节点。</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">implements</span> <span class="token class-name">NavigableMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>    <span class="token comment">// 自定义比较器</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"serial"</span><span class="token punctuation">)</span> <span class="token comment">// Conditionally serializable</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">;</span>    <span class="token comment">// 元素根节点</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> root<span class="token punctuation">;</span>    <span class="token comment">// entry数量</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 修改记录</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token class-name">K</span> key<span class="token punctuation">;</span>        <span class="token class-name">V</span> value<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> left<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> right<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> color <span class="token operator">=</span> <span class="token constant">BLACK</span><span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// 将根节点赋值给变量t</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果根节点为null，说明TreeMap为空</span>        <span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// type (and possibly null) check，检查key的类型是否合法</span>        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个新节点作为根节点</span>        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// size设置为1</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 返回null，表示插入成功</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> cmp<span class="token punctuation">;</span>    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">;</span>    <span class="token comment">// split comparator and comparable paths，根据使用的比较方法进行查找</span>    <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> cpr <span class="token operator">=</span> comparator<span class="token punctuation">;</span> <span class="token comment">// 获取比较器</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cpr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果使用了Comparator</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">// 将当前节点赋值给parent</span>            cmp <span class="token operator">=</span> cpr<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> t<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用Comparator比较key和t的键的大小</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果key小于t的键</span>                t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">// 在t的左子树中查找</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果key大于t的键</span>                t <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">// 在t的右子树中查找</span>            <span class="token keyword">else</span> <span class="token comment">// 如果key等于t的键</span>                <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接更新t的值</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果没有使用Comparator</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果key为null</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 抛出NullPointerException异常</span>            <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> key<span class="token punctuation">;</span> <span class="token comment">// 将key强制转换为Comparable类型</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">// 将当前节点赋值给parent</span>            cmp <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用Comparable比较key和t的键的大小</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果key小于t的键</span>                t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">// 在t的左子树中查找</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果key大于t的键</span>                t <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">// 在t的右子树中查找</span>            <span class="token keyword">else</span> <span class="token comment">// 如果key等于t的键</span>                <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接更新t的值</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果没有找到相同的键，需要创建一个新节点插入到TreeMap中</span>    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个新节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果key小于parent的键</span>        parent<span class="token punctuation">.</span>left <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 将e作为parent的左子节点</span>    <span class="token keyword">else</span>        parent<span class="token punctuation">.</span>right <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 将e作为parent的右子节点</span>    <span class="token function">fixAfterInsertion</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  ======== 注意这里，插入节点后需要进行平衡操作</span>    size<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// size加1</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 返回null，表示插入成功</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="fail-fast-fail-safe"><a href="#fail-fast-fail-safe" class="headerlink" title="fail-fast / fail-safe"></a>fail-fast / fail-safe</h3><blockquote><p>快速失败的思想即针对可能发生的异常进行提前表明故障并停止运行，通过尽早的发现和停止错误，降低故障系统级联的风险。</p></blockquote><p><code>fail-fast</code> 是 Java 集合（如 <code>ArrayList</code>、<code>HashMap</code> 等）中一种错误检测机制。当一个线程正在迭代集合时，<strong>如果其他线程对该集合的结构进行了修改（例如添加、删除元素等），迭代器会立即抛出 <code>ConcurrentModificationException</code> 异常，从而快速失败</strong>并终止迭代过程。</p><p><code>fail-fast</code> 机制的实现依赖于集合中的一个计数器 <code>modCount</code>。每当集合的结构发生变化时，<code>modCount</code> 的值就会增加。迭代器在创建时会记录当前的 <code>modCount</code> 值（记为 <code>expectedModCount</code>），在每次迭代操作时，会检查 <code>modCount</code> 和 <code>expectedModCount</code> 是否相等。如果不相等，说明集合的结构在迭代过程中被修改了，迭代器会立即抛出 <code>ConcurrentModificationException</code> 异常。</p><p><strong><code>fail-fast</code> 机制主要用于检测并发修改错误，适用于单线程环境下快速发现程序中的错误。在多线程环境中，如果需要对集合进行并发操作，使用 <code>fail-fast</code> 集合可能会导致频繁抛出异常，因此不适合。</strong></p><blockquote><p><code>fail-safe</code>也就是安全失败的含义，它旨在即使面对意外情况也能恢复并继续运行，这使得它特别适用于不确定或者不稳定的环境</p></blockquote><p><code>fail-safe</code> 是一种相对安全的迭代机制。当一个线程正在迭代集合时，如果其他线程对该集合的结构进行了修改，迭代器不会抛出 <code>ConcurrentModificationException</code> 异常，而是继续迭代，使用的是集合的一个副本，因此不会影响原集合的迭代过程。</p><p><code>fail-safe</code> 机制的实现通常是在迭代时创建集合的一个副本，迭代器在副本上进行操作。由于副本和原集合是相互独立的，因此在迭代过程中对原集合的修改不会影响副本，也就不会抛出异常。</p><p><strong><code>fail-safe</code> 机制适用于多线程环境下对集合进行并发操作的场景，它可以避免因并发修改而导致的异常。但由于需要创建集合的副本，会消耗额外的内存，并且在迭代过程中可能无法及时反映原集合的最新状态。</strong></p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/fail-fast-and-fail-safe-copyonwritearraylist.png" alt="img" style="zoom:67%;"><h3 id="Comparable-Comparator"><a href="#Comparable-Comparator" class="headerlink" title="Comparable / Comparator"></a>Comparable / Comparator</h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p><code>Comparable</code> 接口位于 <code>java.lang</code> 包下，它定义了一个<strong>对象本身</strong>的自然排序规则。一个类实现了 <code>Comparable</code> 接口，就意味着<strong>该类的对象可以进行自我比较，从而支持使用一些排序算法（如 <code>Arrays.sort()</code>、<code>Collections.sort()</code>）对对象数组或集合进行排序</strong></p><ul><li>当一个类的排序规则是固定的、唯一的，并且该类的对象在大多数情况下都按照这个规则进行排序时，适合实现 <code>Comparable</code> 接口。例如，<code>String</code> 类就实现了 <code>Comparable</code> 接口，其 <code>compareTo()</code> 方法按照字典序对字符串进行比较。</li></ul><p><code>Comparator</code> 接口位于 <code>java.util</code> 包下，它提供了一种<strong>外部比较器</strong>的机制。与 <code>Comparable</code> 不同，<code>Comparator</code> 允许在不修改类本身的情况下，为类的对象定义多种不同的排序规则。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// void sort(List list),按自然排序的升序排序</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collections.sort(arrayList):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 定制排序的用法</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// person对象没有实现Comparable接口，所以必须实现，===这样才可以使treemap中的数据按顺序排列===</span><span class="token comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span><span class="token comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// set, get methods</span>    <span class="token comment">/**     * T重写compareTo方法实现按年龄来排序     * 若返回值小于 0，表示当前对象小于传入对象。若返回值大于 0，表示当前对象大于传入对象。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Person</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">-</span> o<span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pdata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"wangwu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"小红"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"xiaohong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 得到key的值的同时得到key所对应的值</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> pdata<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Person</span> key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> key<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位。线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程<strong>共享</strong>进程的<strong>堆</strong>和<strong>方法区</strong>（<strong>JDK1.8 之后的元空间</strong>）资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为<strong>轻量级进程</strong>。</p><p><strong>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p><p>私有：</p><ul><li><strong>程序计数器</strong>：字节码解释器通过<strong>改变程序计数器来依次读取指令</strong>，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。计数器私有是为了<strong>各线程之间切换，便于恢复到正确的执行位置。</strong></li><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储===<strong>局部变量表、操作数栈、常量池引用</strong>===等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。如果虚拟机栈是共享的，多个线程可能会同时修改栈中的数据，导致数据不一致和程序崩溃。<ul><li>例如，线程 A 和线程 B <strong>同时调用同一个方法</strong>，若共享虚拟机栈，线程 A 的<strong>局部变量可能会被线程 B 覆盖</strong>，从而产生不可预期的结果。线程私有可以保证每个线程的<strong>方法调用和局部变量的独立性</strong>，避免线程间的干扰，确保线程安全。</li></ul></li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<ul><li>本地方法栈用于支持本地方法（使用非 Java 语言编写的方法，如 C、C++ 等）的执行。本地方法在执行过程中也需要自己的栈空间来存储相关信息。</li></ul></li></ul><blockquote><p>为了<strong>保证线程中的===局部变量===不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p></blockquote><p>公有：</p><p>堆和方法区是所有线程共享的资源，其中<strong>堆是进程中最大的一块内存</strong>，主要用于存放新创建的<strong>对象</strong> (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p><p>================================================</p><ul><li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li><li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li><li>用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。</li></ul><p><strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p><p>线程模型：线程模型是用户线程和内核线程之间的关联方式。</p><ol><li>一对一（一个用户线程对应一个内核线程）</li><li>多对一（多个用户线程映射到一个内核线程）</li><li>多对多（多个用户线程映射到多个内核线程）</li></ol><p>在 Windows 和 Linux 等主流操作系统中，<strong>Java 线程采用的是一对一的线程模型</strong>，也就是一个 Java 线程对应一个系统内核线程。</p><h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>Java语言的JVM允许程序运行多个线程，使用<code>java.lang.Thread</code>类代表<strong>线程，所有的线程对象都必须是Thread类或其子类的实例。</strong></p><p>Thread类的特性</p><ul><li><p><strong>每个线程都是通过某个特定Thread对象的run()方法来完成操作的</strong>，因此把run()方法体称为<strong>线程执行体</strong>。</p><ul><li>实现Runnable、Callable接口，包括继承Thread类重写run()方法，都是创建线程体的方式。</li><li>线程是一个独立的执行单元，可以被操作系统调度；而线程体仅仅只是任务，就类似于一段普通的代码，需要线程作为载体才能运行。<strong>线程是执行线程体的容器，线程体是一个可运行的任务</strong>。</li></ul></li><li><p><strong>通过该Thread对象的start()方法来启动这个线程</strong>，而非直接调用run()。</p><ul><li><p><strong>在<code>Java</code>中，创建线程的方式就只有一种：调用<code>Thread.start()</code>方法</strong>！只有这种形式，才能在真正意义上创建一条线程！</p><p>而例如<code>ExecutorService</code>线程池、<code>ForkJoin</code>线程池、<code>CompletableFuture</code>类、<code>Timer</code>定时器类、<code>parallelStream</code>并行流……，它们最终都依赖于<code>Thread.start()</code>方法创建线程。</p></li></ul></li><li><p>要想实现多线程，必须在主线程中创建新的线程对象。</p></li></ul><p><strong>继承Thread类</strong>，重写run方法。创建该类的实例，并调用 start() 方法启动线程。</p><p>优点：编写简单；缺点：因为继承了Thread，不能再继承其他类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExtendsThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">ExtendsThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现Runnable接口</strong>，重写run方法。创建该类的实例，<strong>将其作为参数传递给 Thread 类的构造函数</strong>，创建 Thread 对象，最后调用 start() 方法启动线程。</p><p>优点：只是实现了Runnable接口，可以继承其他类。可以多线程共享同一个目标对象。缺点：编程稍微复杂，访问当前线程需要Thread.currentThread()方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImplementsRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ImplementsRunnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImplementsRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现Callable接口并结合 FutureTask</strong>：和上一种方式类似，只不过<strong>这种方式可以拿到线程执行完的返回值</strong>。方法可以抛出异常。支持泛型的返回值（需要借助FutureTask类，获取返回结果）</p><p>创建该类的实例，将其作为参数传递给 FutureTask 类的构造函数，创建 FutureTask 对象。将 FutureTask 对象作为参数传递给 Thread 类的构造函数（FutureTask实现了Runnable接口），创建 Thread 对象，调用 start() 方法启动线程。</p><p>优缺点同Runnable。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImplementsCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"zhuZi"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">ImplementsCallable</span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImplementsCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取线程执行结果</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用ExecutorService线程池</strong>：使用 Executors 工具类创建线程池，或者直接使用 ThreadPoolExecutor 类创建自定义线程池。提交任务到线程池，可以提交 Runnable 或 Callable 任务。</p><p>优点：</p><ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，降低创建和销毁线程的开销）</li><li>便于线程管理（统一分配，调优和监控）</li></ul><p>缺点：程序复杂度高。错误的配置可能导致线程死锁或资源耗尽。缺乏异步组合能力：对于多个异步任务的组合和编排支持不够方便，需要手动编写大量的代码来处理任务之间的依赖关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ublic <span class="token keyword">class</span> <span class="token class-name">UseExecutorService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ExecutorService</span> poolA <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolA<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"4A......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolA<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 又或者自定义线程池</span>        <span class="token class-name">ThreadPoolExecutor</span> poolB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolB<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"4B......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolB<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用CompletableFuture类</strong>：CompletableFuture是JDK1.8引入的新类，可以用来执行异步任务。</p><ul><li>优点<ul><li><strong>强大的异步组合能力</strong>：可以方便地对多个异步任务进行组合和编排，如任务的串行执行、并行执行、合并结果等。例如，可以使用 <code>thenApply()</code>、<code>thenCompose()</code> 等方法实现任务的串行执行，使用 <code>allOf()</code>、<code>anyOf()</code> 等方法实现任务的并行执行。</li><li><strong>链式调用</strong>：支持链式调用，代码更加简洁易读。可以通过链式调用的方式将多个异步操作连接起来，形成一个异步操作链。</li><li><strong>异常处理方便</strong>：提供了丰富的异常处理方法，如 <code>exceptionally()</code>、<code>handle()</code> 等，可以方便地处理任务执行过程中的异常。</li></ul></li><li>缺点<ul><li><strong>学习成本较高</strong>：由于 <code>CompletableFuture</code> 提供了丰富的功能和方法，对于初学者来说，学习和掌握这些方法的使用需要花费一定的时间和精力。</li><li><strong>线程管理不够精细</strong>：<code>CompletableFuture</code> 默认使用 <code>ForkJoinPool.commonPool()</code> 线程池，对于一些对线程管理有特殊要求的场景，可能无法满足需求。例如，无法像 <code>ExecutorService</code> 那样灵活地创建和配置线程池。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UseCompletableFuture</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cf <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"5......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">"zhuZi"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 需要阻塞，否则看不到结果</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>基于ThreadGroup线程组</strong>：Java线程可以分组，可以创建多条线程作为一个组。</p><p>优点：</p><ul><li><p><strong>统一管理</strong>：<code>ThreadGroup</code> 提供了一种简单的方式来对一组线程进行统一管理。可以通过线程组一次性对组内的所有线程进行操作，例如中断组内的所有线程，调用 <code>ThreadGroup</code> 的 <code>interrupt()</code> 方法就可以中断组内所有未被中断的线程。</p></li><li><p><strong>层次结构清晰</strong>：<code>ThreadGroup</code> 可以形成树形的层次结构，便于组织和管理大量的线程。例如，在一个大型的应用程序中，可以根据不同的功能模块创建不同的线程组，每个线程组下再包含具体的线程，这样可以使线程的管理更加清晰。</p></li></ul><p>缺点：</p><ul><li><strong>功能有限</strong>：<code>ThreadGroup</code> 的主要功能集中在线程的分组和统一管理上，对于线程的执行控制和任务调度功能相对较弱。与 <code>ExecutorService</code> 相比，它不能像线程池那样灵活地控制线程的数量、复用线程以及处理任务队列。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UseThreadGroup</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ThreadGroup</span> group <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadGroup</span><span class="token punctuation">(</span><span class="token string">"groupName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"6-T1......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"T1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"6-T2......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"T2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul><li><p>线程创建之后它将处于 <strong>NEW（新建/初始）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><ul><li>在操作系统层面，线程有 <strong>READY 和 RUNNING</strong> 状态；而<strong>在 JVM 层面，只能看到 RUNNABLE 状态</strong>， Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。JVM没有区分这两种状态，时分（time-sharing）多任务（multi-task）操作系统架构通常都是用“时间分片”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，<strong>一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态）</strong>，也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</li></ul></li><li><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需<strong>要依靠其他线程的通知</strong>才能够返回到运行状态。（等待状态，表示<strong>该线程需要等待其他线程做出一些特定动作如通知或中断</strong>）</p></li><li><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p></li><li><p>当线程进入 <code>synchronized</code> 方法/块或者调用 <code>wait</code> 被 <code>notify</code>重新进入 <code>synchronized</code> 方法/块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。、</p></li><li><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p></li></ul><img src="/2024/06/15/java/640.png" alt="Java 线程状态变迁图" style="zoom:80%;"><p><strong>线程上下文切换：</strong>保存当前线程的上下文（线程运行过程中的条件和状态），留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。线程切换可能发生在这些场景：<strong>主动让出 CPU</strong>，比如调用了 sleep(), wait() 等。<strong>时间片用完</strong>，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。调用了阻塞类型的<strong>系统中断</strong>，比如请求 IO，线程被阻塞。<strong>被终止</strong>或<strong>结束运行</strong>。</p><h4 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h4><p><strong>Thread#sleep() 方法和 Object#wait() 方法</strong>：都可以暂停线程的执行。区别是sleep是让当前线程休眠一会，之后就会自动恢复，所以不会释放锁。而wait（）对应线程生命周期中的等待状态，目的是线程之间的通信和交互，需要释放锁等待其他线程通知才能回到运行状态。<code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</p><ul><li><code>wait()</code> 是让获得<strong>对象锁</strong>的线程实现等待，会自动释放当前线程占有的对象锁。<strong>每个对象（<code>Object</code>）都拥有对象锁</strong>，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要<strong>操作对应的对象</strong>（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</li><li><code>sleep()</code> 是让当前<strong>线程</strong>暂停执行，不涉及到对象类，也不需要获得对象锁。所以定义在Thread中。</li></ul><p>关于run和start：调用 <code>start()</code> 方法启动线程并使线程进入就绪状态，会执行线程的相应准备工作，然后<strong>自动执行 <code>run()</code> 方法</strong>的内容。如果开发者手动直接执行 <code>run()</code> 方法的话，<strong>会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，</strong>不会以多线程的方式执行。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><p>操作系统主要通过两种线程调度方式来管理多线程的执行：</p><ul><li><strong>抢占式调度（Preemptive Scheduling）</strong>：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。这种切换通常是由系统时钟中断（时间片轮转）或其他高优先级事件（如 I/O 操作完成）触发的。这种方式存在上下文切换开销，但公平性和 CPU 资源利用率较好，不易阻塞。</li><li><strong>协同式调度（Cooperative Scheduling）</strong>：线程执行完毕后，主动通知系统切换到另一个线程。这种方式可以减少上下文切换带来的性能开销，但公平性较差，容易阻塞。</li></ul><p>Java 使用的线程调度是抢占式的。也就是说，JVM 本身不负责线程的调度，而是<strong>将线程的调度委托给操作系统</strong>。操作系统通常会基于线程优先级和时间片来调度线程的执行，高优先级的线程通常获得 CPU 时间片的机会更多。</p><p>并发编程的目的就是为了能提高程序的执行效率进而提高程序的运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等等。</p><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。</p><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是多线程或多进程并发编程中的一种常见问题，它发生在<strong>两个或多个线程（或进程）相互等待对方释放资源</strong>的情况下，导致它们都无法继续执行下去的状态。这种情况下，每个线程都在等待某个资源，而同时也拥有一些资源。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 1</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 2</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li><strong>请求与保持</strong>/占有并等待条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>非抢占条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p><strong>预防死锁（破坏死锁的产生的必要条件即可）</strong>：</p><p>1.破坏占有并等待条件：一次性申请所有资源；</p><p>2.破坏非抢占条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p>3.破坏循环等待条件：对资源进行排序，按照固定的顺序请求资源，反序释放资源。</p><blockquote><p>例如为系统中的所有资源分配唯一的编号，进程在请求资源时，必须按照编号从小到大的顺序进行请求。这样可以保证不会出现循环等待的情况，因为如果一个进程已经持有了编号较大的资源，它就不能再请求编号较小的资源，从而打破了循环等待的环路。</p></blockquote><p><strong>避免死锁</strong>：避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>Java 内存模型（Java Memory Model，JMM）是 Java 语言规范中定义的一种抽象概念（并不真实存在），它屏蔽了各种硬件和操作系统的内存访问差异，以实现 Java 程序在不同平台下都能达到一致的内存访问效果。<strong>JMM 规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步地访问共享变量。</strong></p><ul><li><strong>定义</strong>：Java 内存模型是一组规则，它规定了<strong>一个线程对共享变量的写入何时对另一个线程可见</strong>，即解决了多线程环境下共享变量的可见性、有序性和原子性问题。</li><li><strong>主要目标</strong>：提供一种跨平台的内存访问协议，保证 Java 程序在不同的硬件和操作系统上都能具有一致的并发行为，使得开发者可以更方便地编写多线程程序，而无需关心底层硬件的内存访问细节。</li></ul><h4 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h4><ul><li><strong>主内存（Main Memory）</strong>：主内存是<strong>所有线程共享</strong>的内存区域，它存储了<strong>对象实例、静态变量</strong>等共享数据。可以把主内存看作是计算机的物理内存，它是数据的最终存储位置。</li><li><strong>工作内存（Working Memory）</strong>：每个线程都有自己独立的工作内存，它是<strong>线程私有</strong>的。线程在工作内存中保存了该线程使用到的主内存中<strong>共享变量的副本</strong>。线程对共享变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。</li></ul><h4 id="数据交互流程"><a href="#数据交互流程" class="headerlink" title="数据交互流程"></a>数据交互流程</h4><p>当一个线程要访问共享变量时，会先从主内存中读取该变量的值到自己的工作内存中，形成一个副本。线程对副本进行操作后，在某个时刻（具体由 JMM 决定）<strong>将修改后的值刷新回主内存</strong>。由于不同线程的工作内存是相互独立的，所以一个线程对共享变量的修改需要通过刷新到主内存，然后其他线程再从主内存中读取新值，才能被其他线程看到。</p><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ul><li><strong>原子性</strong>：指一个操作是不可中断的，要么全部执行成功，要么全部执行失败。在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作，但像 <code>i++</code> 这种复合操作不是原子性的。可以使用 <code>synchronized</code> 或 <code>Lock</code> 来保证操作的原子性。</li><li><strong>可见性</strong>：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。JMM 通过控制主内存和工作内存之间的交互，来实现可见性。例如，使用 <code>volatile</code> 关键字可以保证变量的可见性，当一个变量被声明为 <code>volatile</code> 时，它会保证对该变量的写操作会立即刷新到主内存，读操作会直接从主内存中读取。</li><li><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。但在实际执行过程中，为了提高性能，编译器和处理器可能会对指令进行重排序。JMM 提供了 <code>happens-before</code> 原则来<strong>保证一定的有序性</strong>，确保在某些情况下指令不会被重排序。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是Java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色。<code>volatile</code> 关键字可以保证变量的可见性， <strong>所谓可见性，是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更</strong>。如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是<strong>共享且不稳定</strong>的，每次使用它都到<strong>主存</strong>中进行读取。<code>volatile</code> 关键字能保证数据的可见性，<strong>但不能保证数据的原子性</strong>。<code>synchronized</code> 关键字两者都能保证。</p><p><strong>JMM规定了所有的变量都存储在主内存中</strong>。普通变量不能保证内存可见性。而volatile则保证了<strong>可见性和有序性</strong>。</p><ul><li>当<strong>写</strong>一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值<strong>立即刷新回主内存中</strong>。</li><li>当<strong>读</strong>一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存<strong>中读取最新共享变量</strong>。</li></ul><p>有序性，即<strong>禁止指令重排序</strong>。在对volatile变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><ul><li>重排序是指编译器和处理器为了优化程序性能<strong>面对指令序列进行重新排序</strong>的一种手段，有时候会改变程序予以的先后顺序。（但重排后的指令绝对不能改变原有串行语义）<ul><li>不存在数据依赖关系，可以重排序；</li><li>存在数据依赖关系，禁止重排序。</li></ul></li></ul><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p><ul><li><strong>读屏障</strong>(Load Memory Barrier) ：在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据。</li><li><strong>写屏障</strong>(Store Memory Barrier) ：在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中。</li></ul><p>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。一句话：<strong>对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读，也叫写后读。</strong></p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//类对象加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。<strong>指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。</strong>例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。使用volatile修饰，就能禁止指令重排。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><blockquote><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p></blockquote><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用<strong>版本号机制或 CAS 算法</strong>）。</p><p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><blockquote><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p></blockquote><p>理论上来说：</p><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以<strong>避免频繁失败和重试影响性能</strong>，悲观锁的<strong>开销是固定的</strong>。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以<strong>避免频繁加锁影响性能</strong>。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于<strong>实现乐观锁</strong>，被广泛应用于各大框架中。CAS 的思想很简单，就是<strong>用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</strong></p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令：</p><ul><li>在Java中，通过 <code>sun.misc.Unsafe</code> 类调用本地（Native）方法实现。</li><li>示例：<code>Unsafe.compareAndSwapInt()</code>、<code>Unsafe.compareAndSwapObject()</code>。</li></ul><p>CAS 涉及到三个操作数：<strong>V</strong>：要更新的变量值(Var)；<strong>E</strong>：预期值(Expected)；<strong>N</strong>：拟写入的新值(New)</p><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。（和版本号机制思想一致）</p><p><code>Unsafe#getAndAddInt</code>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 原子地获取并增加整数值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment">// 以 volatile 方式获取对象 o 在内存偏移量 offset 处的整数值</span>        v <span class="token operator">=</span> <span class="token function">getIntVolatile</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v <span class="token operator">+</span> delta<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回旧值</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>getAndAddInt</code> 使用了 <code>do-while</code> 循环：在<code>compareAndSwapInt</code>操作失败时，会不断重试直到成功。也就是说，<code>getAndAddInt</code>方法会通过 <code>compareAndSwapInt</code> 方法来尝试更新 <code>value</code> 的值，如果更新失败（当前值在此期间被其他线程修改），它会重新获取当前值并再次尝试更新，直到操作成功。</p><p>由于 CAS 操作可能会因为并发冲突而失败，因此通常会与<code>while</code>循环搭配使用，在失败后不断重试，直到操作成功。这就是 <strong>自旋锁机制</strong>。</p><p>问题：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>解决方案：在变量前面追加上<strong>版本号或者时间戳</strong>。<code>AtomicStampedReference</code> 类的 <code>compareAndSet()</code> 方法就是首先检查当前<strong>引用</strong>是否等于预期引用，并且当前<strong>标志</strong>是否等于预期标志，如果<strong>全部相等</strong>，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>另一个问题：<strong>循环时间长开销大</strong>。CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升。</p><h4 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h4><p>Java 中的 <code>Atomic</code> 原子类是一组基于 <strong>CAS（Compare and Swap）</strong> 实现的无锁线程安全工具类，位于 <code>java.util.concurrent.atomic</code> 包中。它们提供了一种高效的方式来操作共享变量，避免了传统锁机制带来的性能开销。</p><ul><li>所有操作都是原子的，确保多线程环境下的数据一致性。</li></ul><ul><li>直接操作内存，通过硬件指令保证原子性。</li><li>支持多种数据类型包括基本类型（如 int、long）、数组类型和引用类型（如对象）。</li></ul><h3 id="JUC-常用的类"><a href="#JUC-常用的类" class="headerlink" title="JUC 常用的类"></a>JUC 常用的类</h3><ol><li><code>java.util.concurrent</code>这是 JUC 最核心的包，包含了大量用于并发编程的类和接口，主要有以下几类：</li></ol><ul><li>线程池相关类<ul><li><code>ExecutorService</code>：线程池的<strong>核心接口</strong>，定义了线程池的基本操作，如提交任务、关闭线程池等。</li><li><code>ThreadPoolExecutor</code>：<code>ExecutorService</code> 的一个具体实现类，开发者可以<strong>通过它自定义线程池的各种参数</strong>，如核心线程数、最大线程数、线程空闲时间等。</li><li><code>Executors</code>：线程池<strong>工厂类</strong>，提供了一系列静态方法用于创建不同类型的线程池，如 <code>newFixedThreadPool</code>（固定大小线程池）、<code>newCachedThreadPool</code>（缓存线程池）、<code>newSingleThreadExecutor</code>（单线程线程池）等。</li></ul></li><li>锁相关类<ul><li><code>Lock</code>：一个<strong>接口</strong>，定义了锁的基本操作，如加锁、解锁等。与传统的 <code>synchronized</code> 关键字相比，<code>Lock</code> 提供了更灵活的锁机制。</li><li><code>ReentrantLock</code>：<code>Lock</code> 接口的一个实现类，是可重入锁，支持公平锁和非公平锁。</li><li><code>ReadWriteLock</code>：一个<strong>接口</strong>，定义了读写锁的基本操作，将锁分为读锁和写锁，允许多个线程同时获取读锁，但写锁是排他的。</li><li><code>ReentrantReadWriteLock</code>：<code>ReadWriteLock</code> 接口的一个实现类。</li></ul></li><li>并发容器类<ul><li><code>ConcurrentHashMap</code>：<strong>线程安全的哈希表</strong>，在多线程环境下可以高效地进行读写操作。</li><li><code>ConcurrentLinkedQueue</code>：<strong>线程安全的链表队列</strong>，适用于多线程环境下的队列操作。</li><li><code>CopyOnWriteArrayList</code>：<strong>线程安全的动态数组</strong>，在进行写操作时会复制一份原数组，适用于读多写少的场景。</li></ul></li><li>同步工具类<ul><li><code>CountDownLatch</code>：一种同步辅助工具，允许一个或多个线程等待其他线程完成操作后再继续执行。</li><li><code>CyclicBarrier</code>：也是一种同步辅助工具，它允许一组线程相互等待，直到所有线程都到达某个屏障点后再继续执行，并且可以重复使用。</li><li><code>Semaphore</code>：用于控制同时访问某个资源的线程数量，通过获取和释放许可证来实现。</li><li><code>Exchanger</code>：用于两个线程之间交换数据，当两个线程都到达交换点时，它们会交换彼此的数据。</li></ul></li></ul><ol start="2"><li><code>java.util.concurrent.atomic</code></li></ol><p>该包提供了一些原子类，这些类可以在多线程环境下进行原子操作，避免了使用传统的同步机制带来的性能开销。常见的原子类有：</p><ul><li><code>AtomicInteger</code>：用于对整数进行原子操作，如自增、自减等。</li><li><code>AtomicLong</code>：用于对长整数进行原子操作。</li><li><code>AtomicBoolean</code>：用于对布尔值进行原子操作。</li><li><code>AtomicReference</code>：用于对引用类型进行原子操作。</li></ul><h4 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h4><p> <strong>CountDownLatch</strong></p><ul><li><strong>功能</strong>：<code>CountDownLatch</code> 是一个同步辅助类，<strong>允许一个或多个线程等待其他线程完成操作</strong>。它使用一个<strong>计数器</strong>来实现，初始化时设置计数器的值，当某个线程完成操作后，调用 <code>countDown()</code> 方法将计数器减 1，当计数器的值变为 0 时，等待的线程将被唤醒继续执行。**<code>CountDownLatch</code> 是一次性的**，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</li><li><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。<strong>直到<code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</strong></li><li><strong>使用场景</strong>：适用于一个或多个线程需要等待其他一组线程完成任务后再继续执行的场景，比如主线程等待多个子线程完成数据加载或计算任务。</li></ul><p> <strong>CyclicBarrier</strong></p><ul><li><strong>功能</strong>：<code>CyclicBarrier</code> 也是一个同步辅助类，它允许<strong>一组线程在某个屏障点等待，直到所有线程都到达该屏障点</strong>后，再一起继续执行后续操作。与 <code>CountDownLatch</code> 不同的是，**<code>CyclicBarrier</code> 的计数器可以重置**，因此可以重复使用。</li><li>CyclicBarrier 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</li><li><strong>使用场景</strong>：在并行计算中，当多个线程需要协同工作，在某个阶段等待所有线程都完成部分任务后，再进行下一步计算时，<code>CyclicBarrier</code> 非常有用。</li></ul><p><code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</p><p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p><p><strong>Semaphore</strong></p><ul><li><strong>功能</strong>：<code>Semaphore</code> 是一个计数信号量，用于<strong>控制同时访问某个资源的线程数量</strong>。它有一个初始值，表示可用的资源数量。线程在访问资源前需要先获取信号量，如果信号量的值大于 0，则获取成功，信号量的值减 1；如果信号量的值为 0，则线程会被阻塞，直到有其他线程释放信号量。</li><li><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为<strong>许可证的数量</strong>，只有拿到许可证的线程才能执行。</li><li><strong>使用场景</strong>：常用于限制对有限资源的访问，如数据库连接池、线程池的最大并发数控制等。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 初始共享资源数量</span><span class="token keyword">final</span> <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取1个许可</span>semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放1个许可</span>semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Semaphore</code> 有两种模式：<strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；<strong>非公平模式：</strong> 抢占式的。</p><p><strong>Future 和 Callable</strong></p><ul><li><p><code>Callable</code> 是一个泛型接口，类似于 <code>Runnable</code>，但 <code>Callable</code> 可以有返回值并且可以抛出异常。</p></li><li><p><code>Future</code> 是一个接口，用于获取 <code>Callable</code> 任务的执行结果或取消任务的执行。<code>FutureTask</code> 类实现了 <code>RunnableFuture</code> 接口（继承自 <code>Runnable</code> 和 <code>Future</code>），既可以作为 <code>Runnable</code> 被线程执行，又可以作为 <code>Future</code> 获取 <code>Callable</code> 任务的执行结果。</p></li><li><p><strong>使用场景</strong>：在需要异步执行任务并获取任务执行结果的场景中，如异步计算、异步数据加载等。</p></li></ul><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><code>synchronized</code> 是 Java 中的一个<strong>关键字</strong>，翻译成中文是同步的意思，主要解决的是<strong>多个线程之间访问资源的同步性</strong>，可以保证<strong>被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p><p>在 Java 6以前，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。它的实现依赖于操作系统的互斥量（Mutex），线程在获取锁和释放锁时需要进行<strong>用户态和内核态的切换</strong>，这种切换的开销非常大，导致性能较低。（也就是挂起或唤醒线程进行线程上下文切换时，<strong>都需要从用户态转换成内核态</strong>）</p><p>在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。（JDK18 中，偏向锁已经被彻底废弃）锁主要存在四种状态，依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，他们会随着竞争的激烈而逐渐升级。注意<strong>锁可以升级不可降级</strong>，这种策略是为了提高获得锁和释放锁的效率。</p><ul><li><strong>偏向锁</strong>：偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无需做任何同步操作，这样可以在单线程环境下提高性能。偏向锁适用于大多数情况下只有一个线程访问同步块的场景。</li><li><strong>轻量级锁</strong>：轻量级锁是为了在没有多线程竞争的情况下减少传统重量级锁使用操作系统互斥量产生的性能开销。当线程尝试获取锁时，如果<strong>发现锁是偏向锁且偏向的线程不是自己，会尝试将偏向锁升级为轻量级锁</strong>。轻量级锁使用 CAS（Compare and Swap）操作来获取和释放锁，避免了用户态和内核态的切换。</li><li><strong>锁粗化</strong>：锁粗化是指将多个连续的加锁、解锁操作合并为一个更大范围的加锁、解锁操作。例如，在一个循环中多次对同一个对象加锁和解锁，JVM 会将锁的范围扩大到循环外部，减少锁的竞争和同步开销。</li><li><strong>锁消除</strong>：锁消除是指 JVM 在编译时，通过逃逸分析技术，发现某些代码块中的锁是不必要的，就会将这些锁消除。例如，在方法内部创建的对象，并且该对象不会被其他线程访问，那么对该对象的加锁操作就是不必要的，JVM 会将其消除。</li></ul><img src="https://cdn.xiaolincoding.com//picgo/1721808326210-cce43537-20e7-4b7d-bed3-737dc7904d9a.png" alt="image.png" style="zoom: 33%;"><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 修饰实例方法，给当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 。</span><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//业务代码</span><span class="token punctuation">}</span><span class="token comment">// 修饰静态方法，当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。</span><span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//业务代码</span><span class="token punctuation">}</span><span class="token comment">// 修饰代码块，对括号里指定的对象/类加锁：synchronized(object)或synchronized(类.class)</span><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//业务代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>synchronized 关键字底层原理属于 JVM 层面的东西。</p><p><strong>同步语句块</strong></p><p><code>synchronized</code> <strong>同步语句块</strong>的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>同步方法</strong></p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。<strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong>JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h4 id="synchronized-vs-volatile"><a href="#synchronized-vs-volatile" class="headerlink" title="synchronized vs volatile"></a>synchronized vs volatile</h4><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个<strong>互补</strong>的存在，而不是对立的存在！</p><ul><li><code>volatile</code> 关键字是线程同步的<strong>轻量级</strong>实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字<strong>只能用于变量</strong>而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><code>volatile</code> 关键字能保证<strong>数据的可见性</strong>，但不能保证数据的原子性。<code>synchronized</code> 关键字<strong>两者都能保证</strong>。</li><li><code>volatile</code>关键字主要用于解决<strong>变量在多个线程之间的可见性</strong>，而 <code>synchronized</code> 关键字解决的是<strong>多个线程之间访问资源的同步性</strong>。</li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个<strong>可重入且独占式</strong>的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了<strong>轮询、超时、中断、公平锁和非公平锁</strong>等高级功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>ReentrantLock</code> 里面有一个**内部类 <code>Sync</code>**，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><code>ReentrantLock</code> <strong>默认使用非公平锁</strong>，也可以通过构造器来显式的指定使用公平锁。<code>ReentrantLock</code> 的底层就是由 AQS 来实现的。</p><img src="/2024/06/15/java/reentrantlock-class-diagram.png" alt="img" style="zoom: 50%;"><p><strong>公平锁</strong> : 锁被释放之后，<strong>先申请的线程先得到锁</strong>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，<strong>上下文切换更频繁</strong>。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，<strong>cpu唤醒阻塞线程的开销会很大</strong>。</li></ul><p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。<strong>性能更好</strong>，但可能会导致某些线程永远无法获取到锁。</p><ul><li>非公平锁比公平锁效率高的原因主要在于<strong>减少了线程切换和同步操作的次数</strong>。</li><li>当线程在运行期间直接抢占到锁资源时，不需要进行“执行<strong>现场保存和恢复</strong>”的操作，从而能够更快地执行业务代码。相比之下，如果一个就绪态的线程想要获得锁资源，首先需要恢复现场，之后争抢锁（可能成功也可能失败），这个过程浪费了大量的CPU资源，只有在获取锁成功后才能继续执行业务代码。因此，非公平锁在效率上优于公平锁，主要原因就在于是否需要进行现场恢复和不同态之间的切换。<strong>非公平锁减少了线程挂起的几率</strong>，后来的线程有一定几率逃离被挂起的开销。</li></ul><h3 id="synchronized-vs-ReentrantLock"><a href="#synchronized-vs-ReentrantLock" class="headerlink" title="synchronized vs ReentrantLock"></a>synchronized vs ReentrantLock</h3><ul><li>两者都是可重入锁。<strong>可重入锁</strong> 也叫<strong>递归锁</strong>，指的是<strong>线程可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，<strong>如果是不可重入锁的话，就会造成死锁。</strong><ul><li>可重入锁主要用在线程需要多次进入临界区代码时，需要使用可重入锁。</li><li>每一个锁关联一个<strong>线程持有者和计数器</strong>，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会<strong>记下锁的持有线程</strong>，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以<strong>再次拿到这个锁，同时计数器会递增</strong>；当线程<strong>退出同步代码块时，计数器会递减</strong>，如果计数器为 0，则释放该锁。</li></ul></li><li><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是<strong>这些优化都是在虚拟机层面实现的，并没有直接暴露给我们</strong>。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以<strong>通过查看它的源代码，来看它是如何实现的</strong>。</li><li>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能：<ul><li><strong>支持超时</strong> ：<code>ReentrantLock</code> 提供了 <code>tryLock(timeout)</code> 的方法，可以指定等待获取锁的最长等待时间，如果超过了等待时间，就会获取锁失败，不会一直等待。</li><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够<strong>中断等待锁的线程</strong>的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说<strong>正在等待的线程可以选择放弃等待，改为处理其他事情。</strong><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能<strong>等到拿到锁以后才能进行其他的逻辑处理</strong>。 <code>synchronized</code> 就属于是不可中断锁。</li></ul></li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而**<code>synchronized</code>只能是非公平锁**。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。<ul><li><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现<strong>多路通知功能</strong>也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即<strong>对象监视器</strong>），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，</strong>在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知” ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而**<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例<strong>，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而</strong><code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。**</li></ul></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRentrantlock</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">ReentrantLock</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 1.1、第一次尝试获取锁，可以获取成功</span>            r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 1.2、此时锁的重入次数为 1</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lock() : lock count :"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 2、中断当前线程，通过 Thread.currentThread().isInterrupted() 可以看到当前线程的中断状态为 true</span>            <span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current thread is intrupted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 3.1、尝试获取锁，可以成功获取</span>            r<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 3.2、此时锁的重入次数为 2</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tryLock() on intrupted thread lock count :"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment">// 4、打印线程的中断状态为 true，那么调用 lockInterruptibly() 方法就会抛出 InterruptedException 异常</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current Thread isInterrupted:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                r<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lockInterruptibly() --NOt executable statement"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 5、打印锁的重入次数，可以发现 lockInterruptibly() 方法并没有成功获取到锁</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lockInterruptibly() not able to Acqurie lock: lock count :"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lock count :"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lock count :"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">MyRentrantlock</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRentrantlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token punctuation">.</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个<strong>可重入的读写锁</strong>，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><blockquote><p><code>ReentrantReadWriteLock</code> 内部维护了两个锁，一个是读锁（共享锁），一个是写锁（排他锁）。这两个锁是通过 AQS（AbstractQueuedSynchronizer，抽象队列同步器）来实现的。AQS 是一个用于构建锁和同步器的框架，它通过一个状态变量（<code>state</code>）来表示锁的状态。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantReadWriteLock</span>        <span class="token keyword">implements</span> <span class="token class-name">ReadWriteLock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ReadWriteLock</span> <span class="token punctuation">{</span>    <span class="token class-name">Lock</span> <span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Lock</span> <span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。<strong>读锁是共享锁，写锁是独占锁</strong>。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。<code>ReentrantReadWriteLock</code> 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</p><p>在<strong>读多写少</strong>的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能。</p><ul><li><strong>共享锁</strong>：一把锁可以被多个线程同时获得。</li><li><strong>独占锁</strong>：一把锁只能被一个线程获得。</li></ul><p>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</p><p><strong>在线程持有读锁的情况下，该线程不能取得写锁。</strong>在线程持有写锁的情况下，该线程可以继续获取读锁（可重入）。</p><p><strong>当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</strong></p><ol><li>读锁的获取与释放<ul><li><strong>获取读锁</strong>：多个线程可以同时获取读锁，只要没有线程持有写锁。在获取读锁时，会检查当前是否有线程持有写锁，如果没有，则将读锁的持有线程数增加。读锁的持有线程数是通过对 <code>state</code> 的高 16 位进行记录的。</li><li><strong>释放读锁</strong>：当线程释放读锁时，会将读锁的持有线程数减少。当读锁的持有线程数为 0 时，表示没有线程持有读锁。</li></ul></li><li>写锁的获取与释放<ul><li><strong>获取写锁</strong>：写锁是排他锁，同一时间只能有一个线程持有写锁。在获取写锁时，会检查当前是否有线程持有读锁或写锁，如果有，则当前线程会被阻塞，进入等待队列。如果没有，则将写锁的持有者设置为当前线程，并将 <code>state</code> 的低 16 位设置为 1，表示持有写锁。</li><li><strong>释放写锁</strong>：当线程释放写锁时，会将 <code>state</code> 的低 16 位设置为 0，表示不再持有写锁，并唤醒等待队列中的线程。</li></ul></li></ol><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的<strong>性能更好的读写锁</strong>，相比于 <code>ReentrantReadWriteLock</code> 等传统读写锁，它提供了更灵活和高效的并发控制方式。<strong>不可重入且不支持条件变量</strong> <code>Condition</code>。</p><p><code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。<code>StampedLock</code> 通过 CLH 队列进行线程的管理，通过同步状态值 <code>state</code> 来表示锁的状态和类型。</p><p><code>StampedLock</code> 使用一个 <code>stamp</code>（时间戳）来表示锁的状态。<code>stamp</code> 是一个长整型数值，它在每次获取锁或释放锁时都会发生变化。<code>StampedLock</code> 支持三种锁模式：写锁（独占锁）、悲观读锁和乐观读锁。</p><ul><li><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是<strong>不可重入</strong>的。</li><li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</li><li><strong>乐观读</strong>：<strong>允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</strong></li></ul><p><code>StampedLock</code> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是<code>StampedLock</code>不可重入的原因。</p><p><strong>StampedLock比ReentrantReadWriteLock性能更好，主要体现在以下几个方面：</strong><br>1、增加乐观读功能，减少写线程饥饿现象出现</p><p>​当线程尝试获取乐观读锁时，StampedLock 会检查当前是否有写锁被持有。如果没有，它会增加一个读锁计数器并返回一个 stamp（通常是当前状态的一个快照）。<strong>乐观读锁不会阻塞其他读线程或写线程</strong>，但可能在写线程获得锁后读取到不一致的数据。</p><p>2、StampedLock要比ReentrantReadWriteLock消耗小</p><p>3、StampedLock<strong>增加了更多的无锁操作</strong>，使线程间阻塞减少到最小。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，拥有自己的私有数据（专属本地变量）。如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的<strong>每个线程都会有这个变量的本地副本</strong>，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而<strong>避免了线程安全问</strong>题。</p><p>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</p><p><strong>对比synchronized</strong></p><p>ThreadLocal和Synchonized都用于解决<strong>多线程并发访问</strong>。但是ThreadLocal与synchronized有本质的区别：</p><p>1、Synchronized用于线程间的<strong>数据共享</strong>，而ThreadLocal则用于线程间的<strong>数据隔离</strong>。</p><p>2、Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的<strong>并不是同一个对象</strong>，这样就隔离了多个线程对数据的数据共享。</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><blockquote><p>一句话理解ThreadLocal，ThreadLocal是作为<strong>当前线程Thread中</strong>  属性ThreadLocalMap集合  中的<strong>某一个Entry的key值</strong>Entry（threadlocal, value），虽然不同的线程之间ThreadLocal这个key值是一样，但是不同的线程所拥有的<strong>ThreadLocalMap是独一无二的</strong>，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。</p></blockquote><p><strong>ThreadLocal的set()方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token comment">//......</span>    <span class="token comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护。存储线程本地变量</span>    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span>    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//......</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程<strong>调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法</strong>时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p><p><strong><code>ThreadLocalMap</code> 的结构</strong></p><p><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的静态内部类，本质是一个<strong>自定义哈希表</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>    <span class="token comment">// Entry 继承自 WeakReference，键是 ThreadLocal 实例</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token class-name">Object</span> value<span class="token punctuation">;</span>  <span class="token comment">// 实际存储的值</span>        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 键是弱引用</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>  <span class="token comment">// 哈希表数组</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>       <span class="token comment">// 元素数量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>  <span class="token comment">// 扩容阈值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//1、获取当前线程</span>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，</span>    <span class="token comment">//则直接更新要保存的变量值，否则创建threadLocalMap，并赋值</span>    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 初始化thradLocalMap 并赋值</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ThreadLocal set赋值的时候首先会获取当前线程thread，并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap，并将value值初始化。</p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong>比如在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 <strong>key 就是 <code>ThreadLocal</code>对象</strong>，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p><img src="/2024/06/15/java/threadlocal-data-structure.png" alt="ThreadLocal 数据结构" style="zoom:80%;"><h4 id="ThreadLocal-内存泄露问题是怎么导致的"><a href="#ThreadLocal-内存泄露问题是怎么导致的" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的"></a>ThreadLocal 内存泄露问题是怎么导致的</h4><p><code>ThreadLocalMap</code> 中使用的 <strong>key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。</strong>所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。<strong>AQS 就是一个抽象类，主要用来构建锁和同步器。</strong>使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractOwnableSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>AQS 解决了开发者在实现同步器时的复杂性问题。它提供了一个通用框架，用于实现各种同步器，例如 <strong>可重入锁</strong>（<code>ReentrantLock</code>）、<strong>信号量</strong>（<code>Semaphore</code>）和 <strong>倒计时器</strong>（<code>CountDownLatch</code>）。通过封装底层的线程同步机制，AQS 将复杂的线程管理逻辑隐藏起来，使开发者只需专注于具体的同步逻辑。</p><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>AQS 提供了一种通用的机制来实现阻塞锁和相关的同步器，其核心思想是通过一个 <strong>FIFO 队列</strong> 和一个 <strong>状态变量</strong> 来管理线程的阻塞和唤醒。如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为<strong>有效的工作线程</strong>，将共享资源设置为<strong>锁定状态</strong>；如果共享资源被占用，就需要一定的<strong>阻塞等待唤醒机制</strong>来保证锁分配。这个机制主要用的是<strong>CLH队列的变体</strong>实现的，将暂时获取不到锁的线程加入到队列中。<br>CLH:Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的<strong>虚拟双向队列(FIFO）</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），AQS是通过<strong>将每条请求共享资源的线程封装成一个节点</strong>来实现锁的分配。</p><p>CLH 锁通过引入一个队列来组织并发竞争的线程，对自旋锁进行了改进：</p><ul><li>每个线程会作为一个节点加入到队列中，并通过<strong>自旋监控前一个线程节点的状态</strong>，而不是直接竞争共享变量。</li><li>线程按顺序排队，确保公平性，从而避免了 “饥饿” 问题。</li></ul><p>AQS（AbstractQueuedSynchronizer）在 CLH 锁的基础上进一步优化，形成了其内部的 <strong>CLH 队列变体</strong>。主要改进点有以下两方面：</p><ul><li><p><strong>自旋 + 阻塞：</strong> CLH 锁使用纯自旋方式等待锁的释放，但<strong>大量的自旋操作会占用过多的 CPU 资源</strong>。AQS 引入了 自旋 + 阻塞 的混合机制： 如果线程获取锁失败，会先<strong>短暂自旋尝试获取锁</strong>；如果仍然失败，则线程会<strong>进入阻塞状态</strong>，等待被唤醒，从而减少 CPU 的浪费。</p></li><li><p><strong>单向队列改为双向队列</strong>：CLH 锁使用单向队列，节点只知道前驱节点的状态，而当某个节点释放锁时，需要通过队列唤醒后续节点。AQS 将队列改为 <strong>双向队列</strong>，新增了 <code>next</code> 指针，使得节点不仅知道前驱节点，也可以<strong>直接唤醒后继节点</strong>，从而<strong>简化了队列操作</strong>，提高了唤醒效率。</p></li></ul><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/clh-queue-state.png" alt="CLH 变体队列" style="zoom: 67%;"><p><strong>核心组件：</strong></p><ol><li><strong>状态变量（state）</strong>：表示<strong>共享资源的状态</strong>，可以是锁的持有次数、信号量的许可数等。通过 <code>getState()</code>、<code>setState()</code> 和 <code>compareAndSetState()</code> 方法操作。<ul><li>这里state的具体含义，会根据具体实现类的不同而不同：比如在Semapore里，他表示剩余许可证的数量；在CountDownLatch里，它表示还需要倒数的数量；在ReentrantLock中，state用来表示”锁”的占有情况，包括可重入计数，当state的值为O的时候，标识该Lock不被任何线程所占有。</li><li><strong>state是volatile修饰的</strong>，并被并发修改，所以修改state的方法都需要保证线程安全，比如getState、setState以及compareAndSetState操作来读取和更新这个状态。这些方法都依赖于unsafe类。</li></ul></li><li><strong>FIFO 队列</strong>：一个双向链表，用于存储等待获取资源的线程。每个节点（<code>Node</code>）包含线程（<code>thread</code>）、等待状态（<code>waitStatus</code>）和前驱/后继指针。<ul><li>这个队列用来存放“等待的线程，AQS就是“排队管理器”，当多个线程争用同一把锁时，必须有排队机制将那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁。</li></ul></li><li><strong>节点状态（waitStatus）</strong>：<code>CANCELLED</code>（1）：线程已取消。<code>SIGNAL</code>（-1）：当前节点的后继节点需要被唤醒。<code>CONDITION</code>（-2）：节点在条件队列中等待。<code>PROPAGATE</code>（-3）：共享模式下，释放资源时需要传播给后续节点。<ul><li>在 AQS 中，一个节点加入队列之后，初始状态为 <code>0</code> 。</li><li>当有新的节点加入队列，此时新节点的前继节点状态就会由 <code>0</code> 更新为 <code>SIGNAL</code> ，表示前继节点释放锁之后，需要对新节点进行唤醒操作。</li><li>如果一个节点在队列中等待获取锁锁时，因为某种原因失败了，该节点的状态就会变为 <code>CANCELLED</code> ，表明取消获取锁，这种状态的节点是异常的，无法被唤醒，也无法唤醒后继节点。</li></ul></li></ol><p><strong>同步状态的获取和释放</strong></p><ul><li>独占模式<ul><li><code>acquire(int arg)</code>：尝试以独占模式获取同步状态，如果获取失败则将当前线程加入到队列中等待。</li><li><code>release(int arg)</code>：尝试以独占模式释放同步状态，如果释放成功则唤醒队列中的后继节点。</li></ul></li><li>共享模式<ul><li><code>acquireShared(int arg)</code>：尝试以共享模式获取同步状态，如果获取失败则将当前线程加入到队列中等待。</li><li><code>releaseShared(int arg)</code>：尝试以共享模式释放同步状态，如果释放成功则唤醒队列中的后继节点。</li></ul></li></ul><p>基于 AQS 可以实现自定义的同步器， AQS 提供了 5 个模板方法（<strong>模板方法模式</strong>）。如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>自定义的同步器继承 <code>AbstractQueuedSynchronizer</code> 。</li><li>重写 AQS 暴露的模板方法。</li></ol><p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>什么是钩子方法呢？</strong> 钩子方法是一种被声明在抽象类中的方法，一般使用 <code>protected</code> 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p><p>获取资源：</p><ul><li><strong>acquire(int)<strong>：acquire是一种</strong>以独占方式获取资源</strong>，如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。该方法是独占模式下线程获取共享资源的顶层入口。获取到资源后，线程就可以去执行其临界区代码了。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>tryAcquire()</code> ：尝试获取锁（模板方法），<code>AQS</code> 不提供具体实现，由子类实现。</p></li><li><p><code>addWaiter()</code> ：如果获取锁失败，会将当前线程封装为 Node 节点加入到 AQS 的 CLH 变体队列中等待获取锁。</p></li><li><p><code>acquireQueued()</code> ：CAS对线程进行<strong>阻塞、唤醒</strong>，并调用 <code>tryAcquire()</code> 方法让队列中的线程尝试获取锁。</p></li></ul><p>在 <code>AQS</code> 中，当前节点的唤醒需要依赖于上一个节点。如果上一个节点取消获取锁，它的状态就会变为 <code>CANCELLED</code> ，<code>CANCELLED</code> 状态的节点没有获取到锁，也就无法执行解锁操作对当前节点进行唤醒。因此<strong>在阻塞当前线程之前，需要跳过 <code>CANCELLED</code> 状态的节点。</strong></p><p>shouldParkAfterFailedAcquire(Node pred, Node node)：调整前驱节点的waitStatus为SIGNAL，确保后续唤醒。</p><p>关于selfInterrupt：</p><ul><li>当 <code>if</code> 判断为 <code>true</code> 时，需要 <code>tryAcquire()</code> 返回 <code>false</code> ，并且 <code>acquireQueued()</code> 返回 <code>true</code> 。</li><li>其中 <code>acquireQueued()</code> 方法返回的是线程被唤醒之后的 <strong>中断状态</strong> ，通过执行 <code>Thread.interrupted()</code> 来返回。该方法在返回中断状态的同时，会清除线程的中断状态。</li><li>因此如果 <code>if</code> 判断为 <code>true</code> ，表明线程的中断状态为 <code>true</code> ，但是调用 <code>Thread.interrupted()</code> 之后，线程的中断状态被清除为 <code>false</code>，因此需要重新执行 <code>selfInterrupt()</code> 来重新设置线程的中断状态。</li></ul><blockquote><p>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；<br>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；<br>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果<strong>在整个等待过程中被中断过，则返回true</strong>（在true的情况下，才会执行selfInterrupt()），否则返回false。<br>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</p></blockquote><p>释放资源：</p><p>AQS 中以独占模式释放资源的入口方法是 <code>release()</code> ，主要做两件事：尝试释放锁和唤醒后继节点。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 1、尝试释放锁 -- 计算释放锁之后的 state 值，为0表明完全释放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 2、唤醒后继节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><p>核心参数，拒绝策略，任务提交流程，线程创建时机，销毁时机，线程池关闭</p><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h3><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p><strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。（池化技术，减少每次获取资源的消耗，提高对资源的利用率）</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的<strong>分配，调优和监控</strong>。</li></ul><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * 用给定的初始参数创建一个新的ThreadPoolExecutor。     */</span><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的核心线程数量</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的最大线程数</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment">//===当线程数大于核心线程数时===，多余的空闲线程存活的最长时间</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span><span class="token comment">//时间单位</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span><span class="token comment">//任务队列，用来储存等待执行任务的队列</span>                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span><span class="token comment">//线程工厂，用来创建线程，一般默认即可</span>                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token comment">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>                         <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最重要的三个参数：</p><ul><li><code>corePoolSize</code> : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><code>maximumPoolSize</code> : 任务队列中存放的任务达到队列容量的时候，<strong>当前可以同时运行的线程数量变为最大线程数。</strong></li><li><code>workQueue</code>: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><strong>使用示例</strong></p><ul><li>execute用于提交不需要返回值的任务。</li><li>submit用于提交需要返回值的任务。</li><li>shutdown平缓关闭线程池，不再接受新任务，<strong>已提交任务继续执行。</strong></li><li>shutdownNow试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 实际项目中使用ThreadPoolExecutor的示例</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">RequestHandler</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maxPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">int</span> queueCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>queueCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maxPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 提交一个任务</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 停止线程池的方法，通常在服务停止时调用</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><p>如果<strong>当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时</strong>，<code>ThreadPoolExecutor</code> 定义一些策略:</p><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行自己的线程运行任务，也就是<strong>直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务</strong>。因此这种策略会<strong>降低对于新任务提交速度</strong>，影响程序的整体性能。如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。<ul><li>将任务回退给调用者，使用调用者的线程来执行任务。除非线程池被停止或任务队列已有空缺。</li></ul></li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：不做任何处理，直接丢弃掉，静默拒绝新任务。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃最早的未处理的任务请求，然后执行当前任务。</li><li>自定义拒绝策略：实现RejectedExecutionHandler接口来自定义拒绝策略。</li></ul><p>如果不允许丢弃任务，只能选择CallerRunsPolicy，<strong>问题</strong>：如果走到<code>CallerRunsPolicy</code>的任务是个非常耗时的任务，且处理提交任务的线程是主线程，可能会<strong>导致主线程阻塞，影响程序的正常运行。</strong></p><p><strong>解决思路</strong></p><p>我们从问题的本质入手，调用者采用<code>CallerRunsPolicy</code>是<strong>希望所有的任务都能够被执行</strong>，暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中。这样的话，在内存允许的情况下，我们可以<strong>增加阻塞队列<code>BlockingQueue</code>的大小</strong>并调整堆内存以容纳更多的任务，确保任务能够被准确执行。</p><p>为了充分利用 CPU，我们还可以调整线程池的<code>maximumPoolSize</code> （最大线程数）参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</p><p><strong>进一步：为了保证任务不被丢弃且后续能被处理，可以把任务持久化到数据库/缓存/消息队列</strong></p><p>如果服务器资源已达到可利用的极限，这就意味我们要在<strong>设计策略</strong>上改变线程池的调度了，我们都知道，导致主线程卡死的本质就是因为我们不希望任何一个任务被丢弃。换个思路，有没有办法<strong>既能保证任务不被丢弃且在服务器有余力时及时处理呢？</strong></p><p>这里提供的一种<strong>任务持久化</strong>的思路，这里所谓的任务持久化，包括但不限于:</p><ol><li>设计一张任务表将任务存储到 MySQL 数据库中。</li><li><code>Redis</code>缓存任务。</li><li>将任务提交到消息队列中。</li></ol><h3 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h3><p><strong>1. 固定大小的线程池（FixedThreadPool）</strong></p><ul><li><p>核心线程数（corePoolSize）和最大线程数（maximumPoolSize）相等。</p></li><li><p>使用<strong>无界队列</strong>（<code>LinkedBlockingQueue</code>）存储任务。</p></li><li><p><strong>线程池中的线程数量固定，不会动态增加或减少。</strong></p></li><li><p>适合任务数量稳定且需要限制并发线程数的场景。例如：Web 服务器的请求处理。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> fixedThreadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 10 个线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>2. 缓存线程池（CachedThreadPool）</strong></p><ul><li><p>核心线程数为 0，最大线程数为 <code>Integer.MAX_VALUE</code>。（<strong>线程数量不固定</strong></p></li><li><p>使用<strong>直接传递队列</strong>（<code>SynchronousQueue</code>），<strong>任务不会排队，直接交给线程执行。</strong></p></li><li><p>空闲线程的存活时间为 60 秒，超过时间后会被回收。</p></li><li><p>适合任务数量不确定且任务处理时间短的场景。例如：短时异步任务处理。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> cachedThreadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>3. 单线程线程池（SingleThreadExecutor）</strong></p><ul><li><p>核心线程数和最大线程数均为 1。</p></li><li><p>使用<strong>无界队列</strong>（<code>LinkedBlockingQueue</code>）存储任务。</p></li><li><p><strong>保证所有任务按顺序执行。</strong></p></li><li><p>适合需要顺序执行任务的场景。例如：日志记录、任务调度。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> singleThreadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>4. 定时任务线程池（ScheduledThreadPool）</strong></p><ul><li><p>核心线程数由用户指定，最大线程数为 <code>Integer.MAX_VALUE</code>。</p></li><li><p>使用<strong>延迟队列</strong>（<code>DelayedWorkQueue</code>）存储任务。</p></li><li><p>支持定时任务和周期性任务。</p></li><li><p>适合需要定时执行或周期性执行任务的场景。例如：定时数据同步、心跳检测。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ScheduledExecutorService</span> scheduledThreadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 延迟 10 秒后执行任务</span>scheduledThreadPool<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task executed"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 延迟 10 秒后，每隔 5 秒执行一次任务</span>scheduledThreadPool<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task executed"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>5.单线程定时任务线程池（SingleThreadScheduledExecutor）</strong></p><p>用于在单个线程中调度定时任务或周期性任务。</p><p><strong>6. 工作窃取线程池（WorkStealingPool）</strong></p><ul><li><p>基于 ForkJoinPool 实现。</p></li><li><p>线程池中的线程可以窃取其他线程的任务，充分利用 CPU 资源。</p></li><li><p>默认线程数为 CPU 核心数。</p></li><li><p>适合任务可以拆分为子任务的场景。例如：并行计算、分治算法。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> workStealingPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newWorkStealingPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>7. 自定义线程池（ThreadPoolExecutor）</strong></p><ul><li>通过 <code>ThreadPoolExecutor</code> 类自定义线程池参数。</li><li>可以灵活设置核心线程数、最大线程数、队列类型、线程存活时间、拒绝策略等。</li></ul><h3 id="线程池常用阻塞队列"><a href="#线程池常用阻塞队列" class="headerlink" title="线程池常用阻塞队列"></a>线程池常用阻塞队列</h3><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code><strong>（无界队列）</strong>：<code>FixedThreadPool</code>（可重用固定线程数的线程池） 和 <code>SingleThreadExector</code> 。<code>FixedThreadPool</code>最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code>SingleThreadExector</code>只能创建一个线程（核心线程数和最大线程数都是 1），二者的<strong>任务队列永远不会被放满。</strong></li><li><code>SynchronousQueue</code><strong>（同步队列）</strong>：<code>CachedThreadPool</code>（根据需要创建新线程的线程池） 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为<strong>线程数是可以无限扩展的，可能会创建大量线程</strong>，从而导致 OOM。<ul><li><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</li></ul></li><li><code>DelayedWorkQueue</code><strong>（延迟阻塞队列）</strong>：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会<strong>按照延迟的时间长短对任务进行排序</strong>，内部采用的是“堆”的数据结构，可以保证<strong>每次出队的任务都是当前队列中执行时间最靠前的</strong>。<code>DelayedWorkQueue</code> <strong>添加元素满了之后会自动扩容</strong>原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><p>对比：Java 中常用的阻塞队列实现类有以下几种：</p><ol><li><code>ArrayBlockingQueue</code>：使用<strong>数组</strong>实现的有界阻塞队列。<strong>在创建时需要指定容量大小</strong>，并支持公平和非公平两种方式的锁访问机制。</li><li><code>LinkedBlockingQueue</code>：使用<strong>单向链表</strong>实现的<strong>可选有界</strong>阻塞队列。在创建时可以指定容量大小，如果<strong>不指定则默认为<code>Integer.MAX_VALUE</code><strong>。和<code>ArrayBlockingQueue</code>不同的是， 它仅支持</strong>非公平</strong>的锁访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的<strong>无界</strong>阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</li><li><code>SynchronousQueue</code>：<strong>同步队列</strong>，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：<strong>延迟队列</strong>，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li></ol><p>假如我们需要实现一个优先级任务线程池的话，那可以考虑使用 <code>PriorityBlockingQueue</code> （<strong>优先级阻塞队列</strong>）作为任务队列（<code>ThreadPoolExecutor</code> 的构造函数有一个 <code>workQueue</code> 参数可以传入任务队列）。</p><h4 id="优先级任务队列"><a href="#优先级任务队列" class="headerlink" title="优先级任务队列"></a>优先级任务队列</h4><p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列，可以看作是线程安全的 <code>PriorityQueue</code>，两者底层都是使用小顶堆形式的二叉堆，即值最小的元素优先出队。不过，<code>PriorityQueue</code> 不支持阻塞操作。</p><p>要想让 <code>PriorityBlockingQueue</code> 实现对任务的排序，<strong>传入其中的任务必须是具备排序能力</strong>的，方式有两种：</p><ol><li>提交到线程池的任务实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来指定任务之间的优先级比较规则。</li><li><strong>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</strong></li></ol><p>不过，这存在一些风险和问题，比如：</p><ul><li><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。<ul><li>解决：继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，<strong>当插入的元素数量超过指定值就返回 false 。</strong></li></ul></li><li>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。<ul><li>解决：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</li></ul></li><li>由于需要对队列中的元素进行<strong>排序操作以及保证线程安全</strong>（并发控制采用的是可重入锁 <code>ReentrantLock</code>），因此会降低性能。</li></ul><h3 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h3><img src="/2024/06/15/java/thread-pool-principle.png" alt="图解线程池实现原理" style="zoom:80%;"><ul><li>如果当前运行的线程数小于核心线程数，那么就会<strong>新建一个线程</strong>来执行任务。<ul><li>当提交一个新任务到线程池时，如果线程池中的线程数量小于核心线程数，<strong>即使其他工作线程是空闲的，也会创建一个新线程来处理该任务。</strong></li></ul></li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（<strong>任务队列已经满了</strong>），但是当前运行的线程数是小于最大线程数的，就<strong>创建一个新线程来执行当前提交的任务</strong>。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ul><h3 id="线程异常后，销毁还是复用"><a href="#线程异常后，销毁还是复用" class="headerlink" title="线程异常后，销毁还是复用"></a>线程异常后，销毁还是复用</h3><p><strong>使用<code>execute()</code>提交任务</strong>：当任务通过<code>execute()</code>提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么<strong>该异常会导致当前线程终止</strong>，并且异常会被打印到控制台或日志文件中。<strong>线程池会检测到这种线程终止，并创建一个新线程来替换它</strong>，从而保持配置的线程数不变。</p><p><strong>使用<code>submit()</code>提交任务</strong>：对于通过<code>submit()</code>提交的任务，如果在任务执行中发生异常，<strong>这个异常不会直接打印出来</strong>。相反，异常会被<strong>封装在由<code>submit()</code>返回的<code>Future</code>对象</strong>中。当调用<code>Future.get()</code>方法时，可以捕获到一个<code>ExecutionException</code>。在这种情况下，<strong>线程不会因为异常而终止</strong>，它会继续存在于线程池中，准备执行后续的任务。</p><h3 id="execute和submit区别"><a href="#execute和submit区别" class="headerlink" title="execute和submit区别"></a>execute和submit区别</h3><p>1、<strong>返回结果</strong>：submit()方法可以接受并<strong>返回Future对象，用于表示异步任务的结果</strong>。你可以通过Future对象获取任务的执行结果，或者等待任务执行完成。而execute()方法没有返回值，无法获取任务的执行结果。<br>2、<strong>异常处理</strong>：submit()方法能够处理任务执行过程中抛出的异常。你可以通过调用Future对象的get()方法来获取任务执行过程中的异常，或者通过捕获ExecutionException异常来处理异常情况。而execute()方法无法处理任务执行过程中的异常，异常会被传播到线程池的未捕获异常处理器(UncaughtExceptionHandler)。<br>3、<strong>方法重载</strong>：submit()方法有多种重载形式，可以接受<strong>Runnable、Callable和其他可执行任务作为参数</strong>。它们的返回值类型分别为Future、Future和Future，其中T为Callable返回结果的类型。这使得submit()方法更加灵活，可以处理不同类型的任务。而<strong>execute()方法只接受Runnable类型的任务作为参数</strong>，没有方法重载的选项。</p><h3 id="Runnable与Callable"><a href="#Runnable与Callable" class="headerlink" title="Runnable与Callable"></a>Runnable与Callable</h3><ul><li>Callable规定的方法是 call(), Runnable规定的方法是 run()。</li><li>Callable的任务执行后可返回值，而 Runnable的任务是不能返回值。</li><li>call方法可以抛出异常， run方法不可以。</li><li>运行 Callable任务可以拿到一个 Future对象</li></ul><h3 id="shutdown-VS-shutdownNow"><a href="#shutdown-VS-shutdownNow" class="headerlink" title="shutdown()  VS  shutdownNow()"></a>shutdown()  VS  shutdownNow()</h3><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是<strong>队列里的任务得执行完毕。</strong></li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程池的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated()  VS  isShutdown()"></a>isTerminated()  VS  isShutdown()</h3><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h3 id="设定线程池大小"><a href="#设定线程池大小" class="headerlink" title="设定线程池大小"></a>设定线程池大小</h3><ul><li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现<strong>任务队列满了之后任务/请求无法处理</strong>的情况，或者<strong>大量任务堆积在任务队列导致 OOM</strong>。这样很明显是有问题的，CPU 根本没有得到充分利用。</li><li>如果我们设置线程数量太大，<strong>大量线程可能会同时在争取 CPU 资源</strong>，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li></ul><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。<strong>过多的线程会导致频繁的上下文切换，反而降低性能。</strong>比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。<ul><li><strong>最大线程数（maximumPoolSize）</strong>：与核心线程数相同，避免创建过多线程。</li><li><strong>队列容量（workQueue）</strong>：使用有界队列（如 <code>ArrayBlockingQueue</code>），防止任务堆积。</li><li><strong>拒绝策略（RejectedExecutionHandler）</strong>：根据业务需求选择。</li></ul></li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。<strong>由于任务会频繁等待 IO，可以创建更多线程以充分利用 CPU。</strong><ul><li><strong>最大线程数（maximumPoolSize）</strong>：根据任务的平均等待时间和 CPU 负载动态调整。<ul><li>可以设置为较大的值（如 <code>2 * CPU 核心数 + 1</code> 或更高）。</li></ul></li></ul></li></ul><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><img src="/2024/06/15/java/image-20250313151853353.png" alt="image-20250313151853353" style="zoom: 67%;"><img src="/2024/06/15/java/image-20250313152029216.png" alt="image-20250313152029216" style="zoom:67%;"><h3 id="线程池实践规范"><a href="#线程池实践规范" class="headerlink" title="线程池实践规范"></a>线程池实践规范</h3><p>线程池必须手动通过 <code>ThreadPoolExecutor</code> 的构造函数来声明，避免使用<code>Executors</code>类创建线程池，会有 OOM 风险。<strong>使用有界队列，控制线程创建数量。</strong></p><p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p><ul><li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该<strong>显示地给我们的线程池命名</strong>，这样有助于我们定位问题。</li></ul><p><strong>不同的业务使用不同的线程池</strong>，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。如果<strong>父业务和子业务调用同一个线程池，可能产生死锁；</strong></p><p>当线程池不再需要使用时，应该<strong>显式地关闭线程池</strong>，释放线程资源。</p><p>调用完 <code>shutdownNow</code> 和 <code>shuwdown</code> 方法后，并不代表线程池已经完成关闭操作，它只是<strong>异步的通知线程池进行关闭处理</strong>。如果要同步等待线程池彻底关闭后才继续往下执行，需要调用<code>awaitTermination</code>方法进行同步等待。</p><p>在调用 <code>awaitTermination()</code> 方法时，应该设置合理的超时时间，以避免程序长时间阻塞而导致性能问题。另外。由于线程池中的任务可能会被取消或抛出异常，因此在使用 <code>awaitTermination()</code> 方法时还需要进行异常处理。<code>awaitTermination()</code> 方法会抛出 <code>InterruptedException</code> 异常，需要捕获并处理该异常，以避免程序崩溃或者无法正常退出。</p><p>线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。</p><p>因此，在使用线程池时，我们应该<strong>尽量避免将耗时任务提交到线程池中执行</strong>。对于一些比较耗时的操作，如网络请求、文件读写等，可以采用<strong>异步操作</strong>的方式来处理，以避免阻塞线程池中的线程</p><p>线程池和 <code>ThreadLocal</code>共用，可能会导致线程从<code>ThreadLocal</code>获取到的是旧值/脏数据。这是因为<strong>线程池会复用线程对象</strong>，与线程对象绑定的类的静态属性 <code>ThreadLocal</code> 变量也会被重用，这就导致一个线程可能获取到其他线程的<code>ThreadLocal</code> 值。</p><h2 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h2><p><code>Future</code> 是 Java 提供的一个接口，用于表示异步计算的结果。它允许我们在一个线程中提交一个任务，然后在另一个线程中获取任务的执行结果。虽然 <code>Future</code> 提供了一种简单的方式来进行异步编程，但它的功能有限，不能很好地处理复杂的并发场景。这其实就是<strong>多线程中</strong>经典的 <strong>Future 模式</strong>，你可以将其看作是<strong>一种设计模式，核心思想是异步调用，主要用在多线程领域</strong>，并非 Java 语言独有。</p><ul><li><strong>Callable</strong>：代表一个可异步执行的任务，通常包含需要返回结果的逻辑。</li></ul><ul><li><strong>Future</strong>：作为异步计算的<strong>句柄</strong>，用于跟踪任务状态（如是否完成、取消）和获取结果。任务提交后立即返回 Future，允许程序继续执行其他操作。</li></ul><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；mayInterruptIfRunning参数表示是否允许中断已经</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// V 代表了Future执行的任务返回值的类型</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">// 取消任务执行</span>    <span class="token comment">// 成功取消返回 true，否则返回 false</span>    <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断任务是否被取消</span>    <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断任务是否已经执行完成</span>    <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取任务执行结果</span>    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">;</span>    <span class="token comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span>    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>FutureTask 提供了 Future 接口的基本实现</strong>，常用来封装 Callable 和 Runnable。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。FutureTask 实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p><p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为<code>Callable</code> 对象。</p><p><strong><code>FutureTask</code>相当于对<code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建线程池</span>        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 提交任务并获取 Future 对象</span>        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 模拟耗时操作</span>            <span class="token keyword">return</span> <span class="token string">"Task completed"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task submitted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">// 获取任务结果（阻塞直到任务完成）</span>            <span class="token class-name">String</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task result: "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> <span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 关闭线程池</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p><code>Future</code> 在实际使用过程中存在一些局限性比如<strong>不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</strong></p><p>Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了<strong>函数式编程、异步任务编排组合</strong>（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><p><code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。</p><img src="/2024/06/15/java/completablefuture-class-diagram.jpg" alt="img" style="zoom:80%;"><p><code>CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。<code>CompletionStage</code> 接口中的方法比较多，**<code>CompletableFuture</code> 的函数式能力就是这个接口赋予的。**</p><p><strong>创建方式：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> supplier<span class="token punctuation">)</span><span class="token comment">//自定义线程，根据supplier构建执行任务  -- supply支持返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> supplier<span class="token punctuation">,</span> <span class="token class-name">Executor</span> executor<span class="token punctuation">)</span><span class="token comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据runnable构建执行任务</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">)</span> <span class="token comment">//自定义线程，根据runnable构建执行任务   --- run不支持返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">,</span>  <span class="token class-name">Executor</span> executor<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>获取结果：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCompletableGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span> <span class="token punctuation">{</span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cp1 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">"商品A"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// getNow方法测试 -- 立即获取结果不阻塞，结果计算已完成将返回结果或计算过程中的异常，如果未计算完成将返回设定的 valueIfAbsent 参数值，这里会输出商品B，因为cp1没有执行完成，getNow就已经获取了</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cp1<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token string">"商品B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//join方法测试 </span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> cp2 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// join 方法获取结果方法里不会抛异常，但是执行结果会抛异常，抛出的异常为 CompletionException</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cp2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//get方法测试</span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> cp3 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// get 方法获取结果方法里将抛出异常，执行结果抛出的异常为 ExecutionException</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cp3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>异步回调：</strong></p><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>作用</strong></th><th align="left"><strong>返回值</strong></th></tr></thead><tbody><tr><td align="left"><code>thenApply</code></td><td align="left">对任务结果进行转换，<strong>有传参，有返回值</strong></td><td align="left"><code>CompletableFuture&lt;U&gt;</code></td></tr><tr><td align="left"><code>thenAccept</code></td><td align="left"><strong>消费任务结果</strong>，有传参，不返回新值</td><td align="left"><code>CompletableFuture&lt;Void&gt;</code></td></tr><tr><td align="left"><code>thenRun</code></td><td align="left"><strong>在任务完成后执行操作</strong>，无传参，无返回值</td><td align="left"><code>CompletableFuture&lt;Void&gt;</code></td></tr><tr><td align="left"><code>thenCompose</code></td><td align="left">将两个任务串联。</td><td align="left"><code>CompletableFuture&lt;U&gt;</code></td></tr><tr><td align="left"><code>thenCombine</code></td><td align="left">将两个任务的结果合并。</td><td align="left"><code>CompletableFuture&lt;U&gt;</code></td></tr><tr><td align="left"><code>allOf</code></td><td align="left"><strong>等待所有任务完成。</strong></td><td align="left"><code>CompletableFuture&lt;Void&gt;</code></td></tr><tr><td align="left"><code>anyOf</code></td><td align="left">等待任意一个任务完成。</td><td align="left"><code>CompletableFuture&lt;Object&gt;</code></td></tr><tr><td align="left"><code>exceptionally**</code></td><td align="left"><strong>处理异常，返回默认值。</strong></td><td align="left"><code>CompletableFuture&lt;T&gt;</code></td></tr><tr><td align="left"><code>handle</code></td><td align="left">处理结果和异常，返回新结果。</td><td align="left"><code>CompletableFuture&lt;U&gt;</code></td></tr><tr><td align="left"><code>whenComplete</code></td><td align="left"><strong>在任务完成后执行操作，可访问结果和异常。</strong></td><td align="left"><code>CompletableFuture&lt;T&gt;</code></td></tr><tr><td align="left"><code>supplyAsync</code></td><td align="left">异步执行有返回值的任务。</td><td align="left"><code>CompletableFuture&lt;T&gt;</code></td></tr><tr><td align="left"><code>runAsync</code></td><td align="left">异步执行无返回值的任务。</td><td align="left"><code>CompletableFuture&lt;Void&gt;</code></td></tr><tr><td align="left"><code>complete</code></td><td align="left">手动完成任务并设置结果。</td><td align="left"><code>boolean</code></td></tr><tr><td align="left"><code>completeExceptionally</code></td><td align="left">手动完成任务并设置异常。</td><td align="left"><code>boolean</code></td></tr><tr><td align="left"><code>getNow</code></td><td align="left">获取任务结果，未完成则返回默认值。</td><td align="left"><code>T</code></td></tr></tbody></table><p><strong>「thenRun 和 thenRunAsync 有什么区别呢？」</strong></p><p>如果你执行第一个任务的时候，传入了一个自定义线程池：</p><ul><li>调用 thenRun 方法执行第二个任务时，则第二个任务和第一个任务是共用同一个线程池。</li><li>调用 thenRunAsync 执行第二个任务时，则第一个任务使用的是你自己传入的线程池，第二个任务使用的是 ForkJoin 线程池。</li></ul><p><code>说明</code>:  thenAccept 和 thenAcceptAsync，thenApply 和 thenApplyAsync 等，它们之间的区别也是这个。</p><hr><img src="https://cdn.tobebetterjavaer.com/paicoding/2be0942bcbe746228e00b7f87a70c3a4.jpg" alt="img" style="zoom:50%;"><p><strong><code>thenCompose</code></strong></p><ul><li><p><strong>作用</strong>：将两个任务串联起来，前一个任务的结果作为后一个任务的输入。</p></li><li><p><strong>返回值</strong>：返回一个新的 <code>CompletableFuture</code>。</p></li><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">thenCompose</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> s <span class="token operator">+</span> <span class="token string">" World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p><strong><code>thenCombine</code></strong></p><ul><li><p><strong>作用</strong>：将两个任务的结果合并。</p></li><li><p><strong>返回值</strong>：返回一个新的 <code>CompletableFuture</code>。</p></li><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future1 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future2 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> future1<span class="token punctuation">.</span><span class="token function">thenCombine</span><span class="token punctuation">(</span>future2<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> s1 <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong><code>allOf</code></strong></p><ul><li><p><strong>作用</strong>：等待所有任务完成。</p></li><li><p><strong>返回值</strong>：返回一个 <code>CompletableFuture&lt;Void&gt;</code>。</p></li><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future1 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future2 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> allFutures <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>future1<span class="token punctuation">,</span> future2<span class="token punctuation">)</span><span class="token punctuation">;</span>allFutures<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待所有任务完成</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>注意事项：Future 需要获取返回值，才能获取到异常信息。如果不加 <code>get()/join()</code>方法，看不到异常信息。</p><p><strong>自定义线程池</strong></p><p><code>CompletableFuture</code> 默认使用全局共享的 <code>ForkJoinPool.commonPool()</code> 作为执行器，所有未指定执行器的异步任务都会使用该线程池。这意味着应用程序、多个库或框架（如 Spring、第三方库）若都依赖 <code>CompletableFuture</code>，<strong>默认情况下它们都会共享同一个线程池</strong>。</p><p>虽然 <code>ForkJoinPool</code> 效率很高，但<strong>当同时提交大量任务时，可能会导致资源竞争和线程饥饿</strong>，进而影响系统性能。</p><p>为避免这些问题，建议为 <code>CompletableFuture</code> 提供自定义线程池，带来以下优势：</p><ul><li><strong>隔离性</strong>：为不同任务分配独立的线程池，避免全局线程池资源争夺。</li><li><strong>资源控制</strong>：根据任务特性调整线程池大小和队列类型，优化性能表现。</li><li><strong>异常处理</strong>：通过自定义 <code>ThreadFactory</code> 更好地处理线程中的异常情况。</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>字节码文件(.class)会通过类加载器加载到JVM虚拟机中，接下来JVM虚拟机就会执行其中的字节码指令。我们把<strong>JVM虚拟机被分配的内存</strong>叫做运行时数据区域。而<strong>内存模型</strong>就是指<strong>运行时数据区域中被划分的不同区域。</strong></p><ul><li>JDK1.6：<strong>字符串常量池</strong>存放在<strong>方法区</strong>中，方法区存放在<strong>堆中</strong>；此时方法区的实现叫永久代。</li><li>JDK1.7：字符串常量池离开方法区，直接存放在堆内存；</li><li>JDK1.8：方法区发生移动，从<strong>JVM虚拟机内存</strong>中，移动到<strong>本地内存</strong>中。此时方法区的实现叫元空间。<ul><li><strong>运行时常量池在元空间</strong>，元空间和直接内存都属于本地内存。</li><li>元空间属于JVM 运行时数据区域，而直接内存不属于。</li></ul></li></ul><p><code>Java</code>虚拟机（<code>JVM</code>）的内存模型是<code>Java</code>程序<strong>运行时内存管理的基础</strong>。它定义了<code>Java</code>程序如何<strong>在内存中分配、使用和回收资源</strong>。</p><img src="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" alt="img" style="zoom:67%;"><p>线程私有程序计数器，虚拟机栈，本地方法栈（在并发–线程里面也记录了）</p><p>JVM内存结构如下：</p><ul><li><strong>元空间：</strong>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存。</strong><ul><li>从Java 8开始，永久代(Permanent Generation)被元空间取代，用于存储类的元数据信息，如类的结构信息(如字段、方法信息等）。元空间并不在Java堆中，而是使用本地内存，这<strong>解决了永久代容易出现的内存溢出问题。</strong></li><li><strong>方法区存储内容：类信息（结构信息、访问修饰符、父类与接口信息）、类中常量、类和方法的符号引用及运行时常量池、常量池缓存、静态变量、方法字节码</strong></li></ul></li><li><strong>Java虚拟机栈：</strong>每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了<strong>局部变量表（基本数据类型和对象引用）、操作数栈、方法出口</strong>等信息。栈的大小可以固定也可以动态扩展。</li><li><strong>本地方法栈：</strong>与虚拟机栈类似，区别是虚拟机栈执行Java方法，<strong>本地方法栈执行native方法</strong>。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。</li><li><strong>程序计数器：</strong>程序计数器可以看成是当前线程所执行的<strong>字节码的行号指示器</strong>。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有”内存。</li><li><strong>堆内存：</strong>堆内存是JVM所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的<strong>对象实例和数组</strong>都在堆上分配，这部分空间<strong>可通过GC进行回收</strong>。当申请不到空间时会抛出OutOfMemoryError。堆是JVM内存占用最大、管理最复杂的一个区域。</li><li><strong>直接内存：</strong>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在JDK1.4中新加入了NIO类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以<strong>使用native函数库直接分配堆外内存</strong>，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引l用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li></ul><p>为啥要把方法区从JVM内存（永久代）移到本地内存（元空间）？主要有两个原因：</p><ol><li>本地内存属于本地系统的IO操作，具有更高的一个IO操作性能，而JVM的堆内存这种，<strong>如果有IO操作，也是先复制到直接内存，然后再去进行本地IO操作</strong>。经过了一系列的中间流程，性能就会差一些。非直接内存操作：<code>本地IO操作——&gt;直接内存操作——&gt;非直接内存操作——&gt;直接内存操作——&gt;本地IO操作</code>，而直接内存操作：<code>本地IO操作——&gt;直接内存操作——&gt;本地IO操作</code>。</li><li>永久代有一个无法调整更改的JVM固定大小上限，回收不完全时，会出现<code>OutOfMemoryError</code>问题；而<strong>本地内存（元空间）是受到本地机器内存的限制，不会有这种问题。</strong></li></ol><img src="/2024/06/15/java/constant-pool-20240604095423.png" alt="字符串常量池的位置变化" style="zoom: 33%;"><h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><p>JVM内存模型里堆vs栈：</p><ul><li><strong>用途：</strong>栈存储<strong>局部变量、方法调用参数、方法返回地址和临时数据</strong>，每个线程有独立的栈，用于支持方法执行。每当一个方法被调用，一个<strong>栈帧</strong>就会在栈中创建，用于存储该方法的信息，方法执行完毕栈帧就被移除。堆存储所有<strong>对象实例</strong>和<strong>数组</strong>，是JVM中最大的一块内存区域。所有线程共享堆内存。</li><li><strong>可见性：</strong>堆-所有线程共享，需处理并发安全问题（如通过锁或CAS）。栈-线程私有，生命周期与线程一致，无需考虑多线程同步。</li><li><strong>生命周期：</strong>堆-<strong>对象的生命周期由垃圾回收</strong>器（GC）管理，对象不再被引用时会被回收。<strong>栈-内存自动分配和释放。</strong>方法执行时创建栈帧，方法结束后<strong>栈帧弹出，内存立即回收。</strong></li><li><strong>存储内容：</strong>堆-存储对象实例（如 new Object()）和静态变量（在方法区，Java 8后移至元空间）。栈-存储基本数据类型（如 int、boolean）和对象引用（如 Object obj = new MyObject（）中的 obj）。</li><li><strong>存取速度：</strong>栈-访问速度更快（直接操作栈顶，后进先出，无碎片问题）。堆-访问较慢（对象在堆上的分配和回收耗时长，需通过引用寻址，可能涉及内存碎片和GC开销）。</li></ul><h4 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h4><p>在Java虚拟机（JVM）中，<strong>堆（Heap）</strong> 是内存管理的核心区域，用于存储<strong>对象实例</strong>和<strong>数组</strong>。为了提高垃圾回收（GC）效率，<strong>堆被划分为不同的代（Generations）</strong>，每个代针对对象的生命周期特点采用不同的管理策略。</p><p>堆的分代基于<strong>分代收集理论（Generational Collection Theory）</strong>，核心思想是：</p><ul><li><strong>大部分对象是“朝生夕死”的</strong>（如临时对象、局部变量）。</li><li><strong>存活较久的对象</strong>（如缓存、全局配置）会逐渐晋升到老年代。</li><li>不同代的GC频率和策略不同，以优化性能。</li></ul><img src="https://cdn.xiaolincoding.com//picgo/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png" alt="img" style="zoom:67%;"><ul><li><strong>新生代(Young Generation)<strong>：新生代分为Eden Space和Survivor Space。在Eden Space中，大多数新创建的对象首先存放在这里。当Eden区满时，会触发一次MinorGC(新生代垃圾回收)。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0(Survivor 0)和S1(Survivor 1)。在每次MinorGC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。</strong>这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</strong></li><li><strong>Eden区</strong><ul><li><strong>作用</strong>：大多数<strong>新创建的对象</strong>首先分配在Eden区。</li><li><strong>特点</strong>：<ul><li>占新生代的绝大部分空间（默认比例：<code>Eden : Survivor（s0和s1） = 8:1:1</code>，可通过 <code>-XX:SurvivorRatio</code> 调整）。</li><li>频繁触发<strong>Minor GC</strong>（针对新生代的垃圾回收）。</li></ul></li><li><strong>对象分配</strong>：<ul><li>当Eden区满时，触发Minor GC，<strong>存活对象被复制到Survivor区。</strong></li><li>若对象过大（如大数组），可能直接进入老年代（避免复制开销）。</li></ul></li></ul></li><li><strong>Survivor区（From &amp; To）</strong><ul><li><strong>作用</strong>：存放<strong>从Eden区或另一个Survivor区晋升的存活对象</strong>。</li><li><strong>特点</strong>：<ul><li>两个Survivor区（From和To）大小相等，始终有一个是空的。</li><li>采用<strong>复制算法</strong>：Minor GC时，存活对象从Eden和From区复制到To区，并清空原区域。</li><li>对象每经历一次Minor GC，年龄（Age）加1。</li></ul></li><li><strong>晋升老年代</strong>：<ul><li>对象年龄达到阈值（默认15，通过 <code>-XX:MaxTenuringThreshold</code> 配置）。</li><li>Survivor区空间不足时，存活对象直接进入老年代。</li></ul></li></ul></li><li><strong>老年代(Old Generation/TenuredGeneration)：</strong>经过一次或多次MinorGC仍存活的对象会被移动到老年代。<strong>老年代中的对象生命周期较长</strong>，因此MajorGC(也称为Full GC，涉及老年代的垃圾回收)发生的频率相对较低，<strong>但其执行时间通常比MinorGC长</strong>。老年代的空间通常比新生代大，以存储更多的长期存活对象。<ul><li><strong>大对象区(Large Object Space/Humongous Objects)：</strong>在某些JVM实现中(如G1垃圾收集器)，为大对象分配了专门的区域，称为大对象区或HumongousObjects区域。<strong>大对象是指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代</strong>，以避免因频繁的年轻代晋升而导致的内存碎片化问题。</li></ul></li></ul><h5 id="堆的工作流程示例"><a href="#堆的工作流程示例" class="headerlink" title="堆的工作流程示例"></a><strong>堆的工作流程示例</strong></h5><ol><li><strong>对象分配</strong>：新对象进入Eden区。</li><li><strong>Minor GC</strong>：Eden满时触发，存活对象复制到Survivor区（To）。</li><li><strong>Survivor区轮换</strong>：From和To区角色交换，清空旧的From区。</li><li><strong>晋升老年代</strong>：对象年龄达标或Survivor区不足时晋升。</li><li><strong>Full GC</strong>：老年代不足时触发，回收整个堆，可能导致应用暂停。</li></ol><h5 id="堆分代的优势"><a href="#堆分代的优势" class="headerlink" title="堆分代的优势"></a>堆分代的优势</h5><ul><li><strong>降低GC开销</strong>：高频Minor GC仅处理新生代（小区域），减少停顿时间。</li><li><strong>适应对象生命周期</strong>：区分短命和长命对象，针对性优化回收策略。</li><li><strong>提升内存利用率</strong>：避免频繁扫描老年代对象。</li></ul><h4 id="方法执行过程"><a href="#方法执行过程" class="headerlink" title="方法执行过程"></a>方法执行过程</h4><p>当程序中通过对象或类直接调用某个方法时，主要包括以下几个步骤：</p><ul><li><strong>解析方法调用：</strong>JVM会根据方法的符号引用找到实际的<strong>方法地址</strong>(如果之前没有解析过的话）。</li><li><strong>栈帧创建：</strong>在调用一个方法前，JVM会在当前线程的Java虚拟机栈中为该方法分配一个新的<strong>栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<ul><li>局部变量表（用于存储局部变量和参数）。</li><li>操作数栈（用于存储计算过程中的<strong>临时数据</strong>）。</li><li>动态链接（指向方法所属类的运行时常量池的引用）。</li><li>方法返回地址（记录方法执行完毕后返回的位置）。</li></ul></li><li><strong>执行方法：</strong>执行方法内的字节码指令，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等</li><li><strong>返回处理：</strong>方法执行完毕后，可能会返回一个结果给调用者，并清理当前栈帧，<strong>恢复调用者的执行环境。</strong></li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期，这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p><ul><li><strong>强引用</strong>指的就是代码中普遍存在的赋值方式，比如<code>A a=new A()</code>这种。强引用关联的对象，<strong>永远不会被GC回收。</strong>当内存空间不足时，JVM 宁愿抛出 OutOfMemoryError异常。如果强引用对象不使用时，需要弱化从而使GC能够回收（如对象赋值null）<ul><li>显式地设置强引用对象为null，或让其超出对象的生命周期范围，则GC认为该对象不存在引用，这时就可以回收这个对象，具体什么时候收集这要取决于GC算法。</li></ul></li><li><strong>软引用</strong>可以用SoftReference来描述，指的是那些<strong>有用但是不是必须要的对象</strong>。系统在发生内存<strong>溢出前</strong>会对这类引用的对象进行回收（在OOM前触发）。<ul><li>软引用通常用在对内存敏感的程序中，比如<strong>高速缓存</strong>就有用到软引用，内存够用的时候就保留，不够用就回收。</li></ul></li><li><strong>弱引用</strong>可以用WeakReference来描述，他的强度比软引用更低一点，弱引I用的对象<strong>下一次GC的时候一定会被回收</strong>，而不管内存是否足够。</li><li><strong>虚引用</strong>也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。<ul><li>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</li><li><strong>无法通过虚引用获取对象</strong>（<code>get()</code>始终返回<code>null</code>）。</li><li>虚引用仅用于跟踪对象被回收的状态。</li><li>对象被回收时，虚引用会被加入关联的<code>ReferenceQueue</code>。</li></ul></li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>我们看下 Mybatis 缓存类 SoftCache 用到的软引用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Object</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> softReference <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>delegate<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>softReference <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> softReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>delegate<span class="token punctuation">.</span><span class="token function">removeObject</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hardLinksToAvoidGarbageCollection<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>hardLinksToAvoidGarbageCollection<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hardLinksToAvoidGarbageCollection<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numberOfHardLinks<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>hardLinksToAvoidGarbageCollection<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的，就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p><strong>WeakHashMap</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeakHashMapDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token function">myHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">myWeakHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">myHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token string">"v1"</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">myWeakHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">WeakHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//String key = "weak";</span>        <span class="token comment">// 刚开始写成了上边的代码</span>        <span class="token comment">//思考一下，写成上边那样会怎么样？ 那可不是引用了</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"weak"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token string">"map"</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//去掉强引用</span>        key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当key只有弱引用时，GC发现后会自动清理键和值，作为简单的缓存表解决方案。</p><p><strong>ThreadLocal</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token class-name">Object</span> value<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//......}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ThreadLocal.ThreadLocalMap.Entry 继承了<strong>弱引用</strong>，key为当前线程实例，和WeakHashMap基本相同。</p><h4 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h4><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>内存泄漏（Memory Leak）</strong></th><th align="left"><strong>内存溢出（Out of Memory）</strong></th></tr></thead><tbody><tr><td align="left"><strong>定义</strong></td><td align="left">对象不再使用，但无法被回收，导致内存占用增加。</td><td align="left">内存不足，无法分配新对象，导致程序崩溃。</td></tr><tr><td align="left"><strong>原因</strong></td><td align="left">长生命周期对象持有短生命周期对象的引用：如静态数据结构存储对象，事件监听，未停止的线程、数据库连接</td><td align="left">内存泄漏、内存设置过小、大对象或频繁创建对象（深度递归导致栈溢出）。</td></tr><tr><td align="left"><strong>表现</strong></td><td align="left">内存逐渐耗尽，程序性能下降。</td><td align="left">直接抛出 <code>OutOfMemoryError</code>，程序崩溃。</td></tr><tr><td align="left"><strong>解决方法</strong></td><td align="left">清理无用对象、使用弱引用、分析内存泄漏。</td><td align="left">增加内存、优化代码、分析内存泄漏。</td></tr><tr><td align="left"><strong>关系</strong></td><td align="left">内存泄漏可能导致内存溢出。</td><td align="left">内存溢出可能是内存泄漏的结果。</td></tr></tbody></table><p>内存溢出：</p><img src="/2024/06/15/java/my-hexo-blog\blogs\source\_posts\Java\image-20250318134026910.png" alt="image-20250318134026910" style="zoom:67%;"><h5 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h5><img src="https://cdn.xiaolincoding.com//picgo/image-20240820112835783.png" alt="image-20240820112835783" style="zoom: 50%;"><p><code>ThreadLocal</code> 为每个线程维护一个独立的变量副本。</p><p>每个线程内部有一个 <code>ThreadLocalMap</code>，用于存储该线程的 <code>ThreadLocal</code> 变量。</p><p><code>ThreadLocalMap</code> 的键是 <code>ThreadLocal</code> 对象，值是该线程的变量副本。</p><p><strong>键的弱引用</strong></p><ul><li><code>ThreadLocalMap</code> 的键（即 <code>ThreadLocal</code> 对象）是 <strong>弱引用（WeakReference）</strong>。</li><li>弱引用的特点是：如果只有弱引用指向某个对象，则下一次GC时该对象会被垃圾回收器回收。</li><li>当 <code>ThreadLocal</code> 对象没有强引用时（例如设置为 <code>null</code>），它会被垃圾回收，导致 <code>ThreadLocalMap</code> 中的键为 <code>null</code>。</li></ul><p><strong>值的强引用</strong></p><ul><li><code>ThreadLocalMap</code> 的值（即线程的变量副本）是 <strong>强引用</strong>。</li><li>即使 <code>ThreadLocal</code> 对象被回收，**<code>ThreadLocalMap</code> 中的值仍然存在，**因为值是被强引用的。</li></ul><p><strong>线程的生命周期</strong></p><ul><li>如果线程是线程池中的线程（如 <code>ThreadPoolExecutor</code>），线程不会被销毁，而是会被复用。</li><li>如果 <code>ThreadLocal</code> 对象被回收，但 <code>ThreadLocalMap</code> 中的值没有被清理，<strong>这些值会一直占用内存</strong>，导致内存泄漏。</li></ul><p><strong>ThreadLocal内存泄漏示例：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalLeakExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置一个大对象</span>            <span class="token comment">// 使用完后未清理</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 模拟长时间运行</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// ...</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中：</p><ol><li>线程池中的线程执行任务时，<code>threadLocal</code> 设置了一个大对象。</li><li>任务执行完后，<code>threadLocal</code> 没有被清理。</li><li>由于线程池中的线程不会被销毁，<code>ThreadLocalMap</code> 中的值会一直存在，导致内存泄漏。</li></ol><p>如何解决此问题？</p><ul><li>第一，使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除;</li><li>第二，<strong>不要使用ThreadLocal.set(null)<strong>的方式清除value，它实际上并没有清除值，而是</strong>查找与当前线程关联的Map并将键值对分别设置为当前线程和null。</strong></li><li>第三，最好将ThreadLocal视为需要在finally块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源。</li></ul><h3 id="类初始化和加载"><a href="#类初始化和加载" class="headerlink" title="类初始化和加载"></a>类初始化和加载</h3><h4 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h4><img src="https://cdn.xiaolincoding.com//picgo/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp" alt="img" style="zoom: 50%;"><p><strong>Step1:类加载检查</strong></p><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到这个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类<strong>是否已被加载过、解析和初始化过</strong>。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</p><p><strong>Step2:分配内存</strong></p><p>在类加载检查通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的<strong>内存大小</strong>在类加载完成后便可确定，为对象分配空间的任务等同于<strong>把一块确定大小的内存从 Java 堆中划分出来</strong>。分配方式有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><strong>内存分配的两种方式</strong> ：</p><ul><li>指针碰撞： <ul><li>适用场合：堆<strong>内存规整</strong>（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，<strong>只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</strong></li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表： <ul><li>适用场合：<strong>堆内存不规整</strong>的情况下。</li><li>原理：虚拟机会维护一个列表，<strong>该列表中会记录哪些内存块是可用的</strong>，在分配的时候，<strong>找一块儿足够大的内存块</strong>儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p><strong>Step3:初始化零值</strong></p><p>内存分配完成后，虚拟机需要将<strong>分配到的内存空间都初始化为零值</strong>（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以<strong>不赋初始值就直接使用</strong>，程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>Step4:进行必要设置如对象头</strong></p><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p><strong>Step5:执行 init 方法</strong></p><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，构造函数，即class文件中的方法还没有执行（<code>&lt;init&gt;</code> 方法还没有执行），所有的字段都还为零，<strong>对象需要的其他资源和状态信息</strong>还没有按照预定的意图构造好。所以一般来说，<strong>执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法</strong>，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h4 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h4><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</strong>。</p><p><strong>对象头：</strong>对象头是对象内存布局的第一部分，主要用于存储对象的<strong>元数据和运行时信息</strong>。它包括以下两部分：</p><ul><li><strong>标记字段（Mark Word）</strong>：用于存储对象自身的运行时数据， 如<strong>哈希码</strong>（HashCode）、GC 分代年龄、<strong>锁状态</strong>标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li><li><strong>类型指针（Klass pointer）</strong>：指向对象的类元数据（即类的 Class 对象），用于确定对象属于哪个类的实例。</li></ul><p><strong>实例数据：</strong>实例数据部分是对象真正存储的有效信息，包括程序中定义的<strong>各种类型的字段内容</strong>。</p><p><strong>对齐填充（Padding）</strong>：对齐填充是对象内存布局的最后一部分，用于确保对象的大小是 8 字节的整数倍。</p><ul><li>对象填充不是必然存在，只是用于占位。</li><li>HotSpot 虚拟机要求对象的起始地址必须是 8 字节的整数倍。</li><li>对象头部分正好是 8 字节的倍数（1 倍或 2 倍）。如果实例数据部分未对齐，则通过对齐填充来补全。</li></ul><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><img src="https://cdn.xiaolincoding.com//picgo/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp" alt="img" style="zoom: 50%;"><p>在 Java 中，类的生命周期是指<strong>从类被加载到虚拟机内存中，到类被卸载出内存</strong>的整个过程。类的生命周期包括以下几个阶段。其中验证、准备和解析可以统称为<strong>连接</strong>。</p><ol><li><p><strong>加载：将字节码文件加载到内存。</strong>触发条件：创建类的实例。访问类的静态字段或静态方法。使用反射加载类。初始化类的子类时，父类会被加载。</p><ul><li>通过<strong>全类名</strong>获取定义此类的<strong>二进制字节流</strong>。</li><li>将字节流所代表的<strong>静态存储结构</strong>转换为方法区的<strong>运行时数据结构</strong>。</li><li>在<strong>内存</strong>中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li></ul></li><li><p><strong>验证：确保字节码文件合法</strong>。确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><ul><li>文件格式验证（如魔数、版本号）。</li><li>元数据验证（如类是否有父类、字段和方法是否合法）。</li><li>字节码验证（如操作数栈类型是否匹配）。</li><li>符号引用验证（如引用的类、字段和方法是否存在）。</li></ul><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-process-verification.png" alt="验证阶段示意图" style="zoom:67%;"></li><li><p><strong>准备</strong>：为类中的<strong>静态字段</strong>分配内存并设置默认的初始值。final修饰的static字段不设置，因为编译时候已经分配过了。</p></li><li><p><strong>解析</strong>：将常量池的<strong>符号引用替换为直接引用</strong>。</p><ul><li><strong>符号引用</strong>：一组符号描述所引用的目标（如类、字段、方法）。</li><li><strong>直接引用</strong>：指向目标的指针、偏移量或句柄。</li><li><strong>目的</strong>：将符号引用转换为可以直接使用的内存地址或偏移量。</li></ul><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/symbol-reference-and-direct-reference.png" alt="符号引用和直接引用" style="zoom:80%;"></li><li><p><strong>初始化</strong>：类加载过程的最后一个阶段，执行类的<strong>静态初始化代码</strong>（如静态代码块和静态变量赋值）。</p><ul><li>静态代码块和静态变量赋值按代码顺序执行。</li><li>初始化是线程安全的，JVM 会加锁确保只有一个线程执行初始化。</li></ul></li><li><p><strong>使用</strong>：类的实例化和方法调用。</p></li><li><p><strong>卸载</strong>：当类不再被使用时，从内存中移除。</p></li></ol><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>在 JVM 中，类加载器（ClassLoader）负责<strong>将类的字节码文件（<code>.class</code> 文件）加载到内存中，</strong>并生成对应的 <code>java.lang.Class</code> 对象。JVM 提供了以下几种类加载器，它们按照层次结构组织，共同完成类的加载任务。</p><ul><li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</li><li>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</li><li><strong>数组类</strong>不是通过 <code>ClassLoader</code> 创建的（数组类没有对应的二进制字节流），<strong>是由 JVM 直接生成的</strong>。</li><li>除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。</li></ul><p>JVM 启动的时候，<strong>并不会一次性加载所有的类，而是根据需要去动态加载</strong>。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。<strong>对于已经加载的类会被放在 <code>ClassLoader</code> 中。</strong>在类加载的时候，系统会首先判断当前类是否被加载过。<strong>已经被加载的类会直接返回，否则才会尝试加载。</strong></p><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p><ol><li><p><strong><code>BootstrapClassLoader</code>(启动类加载器)<strong>：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，</strong>主要用来加载 JDK 内部的核心类库如 <code>java.lang.*</code>、<code>java.util.*</code> 等（</strong> <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</p><ul><li><p><strong>特点</strong>：</p><ul><li>由 C/C++ 实现，是 JVM 的一部分。</li><li><strong>是最高层次的类加载器，没有父类加载器。</strong></li><li>加载的类在 <code>java.lang.ClassLoader</code> 中返回 <code>null</code>。</li></ul></li><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 null</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>**<code>ExtensionClassLoader</code>(扩展类加载器)**：加载 JVM <strong>扩展类库</strong>（如 <code>javax.*</code> 等），这些类库位于 <code>JAVA_HOME/lib/ext</code> 目录下，或者通过 <code>java.ext.dirs</code> 系统属性指定的路径。</p><ul><li><p><strong>特点</strong>：</p><ul><li>由 Java 实现，是 <code>sun.misc.Launcher$ExtClassLoader</code> 的实例。</li><li>父类加载器是启动类加载器。</li></ul></li><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>parsers<span class="token punctuation">.</span></span>DocumentBuilderFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 sun.misc.Launcher$ExtClassLoader</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>**<code>AppClassLoader</code>(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath（用户类路径） 下的所有 jar 包和类。通常是程序的入口类（如包含 <code>main()</code> 方法的类）。</p><ul><li><strong>特点</strong>：<ul><li>由 Java 实现，是 <code>sun.misc.Launcher$AppClassLoader</code> 的实例。</li><li>父类加载器是扩展类加载器。</li><li><strong>是默认的类加载器</strong>，如果没有自定义类加载器，JVM 会使用它来加载类。</li></ul></li></ul><ul><li><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 sun.misc.Launcher$AppClassLoader</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ol><hr><p><strong>4. 自定义类加载器（Custom ClassLoader）</strong></p><ul><li><p><strong>作用</strong>：用户可以通过继承 <code>java.lang.ClassLoader</code> 类，实现自定义的类加载器，用于加载特定路径或来源的类。</p></li><li><p><strong>特点</strong>：</p><ul><li>可以打破双亲委派模型，实现类的动态加载。</li><li>常用于热部署、模块化加载、加密类加载等场景。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>        <span class="token comment">// 自定义加载逻辑</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token function">loadClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">loadClassData</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从文件或网络加载字节码</span>        <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><strong>双亲委派模型（Parent Delegation Model）</strong> 是 Java 类加载器（ClassLoader）的一种工作机制，它定义了类加载器在加载类时的协作方式。双亲委派模型是 Java 类加载机制的核心设计原则之一，确保了类的<strong>唯一性、安全性和一致性</strong>。</p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom: 67%;"><p>这些类加载器之间的关系形成了双亲委派模型，其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是<strong>把这个请求委派给父类加载器去完成</strong>，每一层次的类加载器都是如此，因此<strong>所有的加载请求最终都应该传送到顶层的启动类加载器中</strong>。只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><ul><li><code>ClassLoader</code> 类使用<strong>委托模型</strong>来搜索类和资源。</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li><li><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，<strong>将搜索类或资源的任务委托给其父类加载器。</strong></li></ul><p>流程：</p><ol><li>当前类加载器检查是否已加载过该类。</li><li>如果没有，将加载请求委派给父类加载器。</li><li>如果父类加载器无法加载，当前类加载器尝试加载。</li></ol><p>双亲委派模型是 Java 类加载机制的重要组成部分，它通过委派父加载器优先加载类的方式，实现了两个关键的安全目标：<strong>避免类的重复加载和防止核心 API 被篡改。</strong></p><ul><li><strong>保证类的唯一性：</strong>通过委托机制，确保了所有加载请求<strong>都会传递到启动类加载器</strong>，<strong>避免</strong>了不同类加载器<strong>重复加载</strong>相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。</li><li><strong>保证安全性：</strong>由于Java<strong>核心库被启动类加载器</strong>加载，而<strong>启动类加载器只加载信任的类路径中的类</strong>，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个Java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。</li><li><strong>支持隔离和层次划分：</strong>双亲委派模型支持<strong>不同层次的类加载器服务于不同的类加载需求</strong>，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。</li><li><strong>简化了加载流程：</strong>通过委派，大部分类能够被正确的类加载器加载，<strong>减少了每个加载器需要处理的类的数量</strong>，简化了类的加载过程，提高了加载效率。</li></ul><p><strong>打破双亲委派模型</strong></p><p>在某些场景下，可能需要打破双亲委派模型。例如：</p><ul><li><strong>热部署</strong>：动态加载类而不受父类加载器的限制。</li><li><strong>模块化加载</strong>：如 OSGi 框架，每个模块有自己的类加载器。</li></ul><p>如何打破双亲委派模型：自定义类加载器时，<strong>重写 <code>loadClass()</code> 方法，直接加载类而不委派给父类加载器。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>        <span class="token comment">// 直接加载类，不委派给父类加载器</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>Java 的自动内存管理主要是针对<strong>对象内存的回收和对象内存的分配</strong>。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>Java 的垃圾回收（Garbage Collection, GC）是 JVM <strong>自动管理内存</strong>的机制，<strong>用于回收不再使用的对象，释放内存空间</strong>。Java 开发者不需要手动释放内存，垃圾回收器会<strong>自动检测并回收</strong>无用的对象。用于避免内存泄漏和内存管理错误，减少手动管理内存的复杂性。</p><p><strong>回收对象：</strong>堆内存–垃圾回收主要针对堆内存中的对象。方法区–方法区（元空间）中的类元数据和常量池也可能被回收。</p><p>垃圾回收的触发：</p><ul><li><strong>内存不足时</strong>：当JVM检测到堆内存不足，无法为新的对象分配内存时，会自动触发垃圾回收。</li><li><strong>手动请求</strong>：虽然垃圾回收是自动的，开发者可以通过调用System.gc(或Runtime.getRuntime().gc()建议JVM进行垃圾回收。不过这只是一个建议，并不能保证立即执行。</li><li><strong>JVM参数</strong>：启动Java应用时可以通过JVM参数来调整垃圾回收的行为，比如：-Xmx（最大堆大小)、-Xms（初始堆大小）等。</li><li><strong>对象数量或内存使用达到阈值</strong>：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阀值时触发垃圾回收。</li></ul><h4 id="判断垃圾"><a href="#判断垃圾" class="headerlink" title="判断垃圾"></a>判断垃圾</h4><p>垃圾回收器通过以下算法判断对象是否可回收：</p><p><strong>引用计数法</strong></p><ul><li><strong>原理</strong>：每个对象维护一个引用计数器，记录有多少引用指向它。当引用计数为 0 时，对象可被回收。</li><li><strong>缺点</strong>：无法解决循环引用问题（如两个对象互相引用，但无外部引用）。</li></ul><p><strong>可达性分析法</strong></p><ul><li><strong>原理</strong>：从根对象（如栈中的局部变量、静态变量等）出发，遍历所有可达对象。不可达的对象可被回收。</li><li><strong>根对象（GC Roots）</strong>：栈中的局部变量。静态变量。JNI 引用（Native 方法引用的对象）。活跃线程。</li><li><strong>优点</strong>：解决了循环引用问题。</li></ul><img src="https://cdn.xiaolincoding.com//picgo/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png" alt="img" style="zoom:67%;"><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是<strong>废弃常量</strong>呢？</p><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p><ul><li>该类<strong>所有的实例都已经被回收</strong>，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象<strong>没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p><strong>标记-清除算法（Mark-Sweep）</strong>：分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在<strong>标记完成后统一回收</strong>掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p><p>缺点：<strong>产生内存碎片。效率较低。</strong>在申请大块内存的时候可能因为没有足够的内连续空间导致再次GC。</p><p><strong>复制算法（Copying）</strong>：将内存分为两块，<strong>每次申请内存时只使用一块</strong>。当内存不够时，将这一块内存中所有存活的对象复制到另一块内存。然后再把已使用的内存整个清理掉。<strong>优点</strong>：无内存碎片。<strong>缺点</strong>：内存利用率低（只能使用一半内存）。<strong>不适合老年代</strong>–如果存活对象数量比较大，复制性能会变得很差。</p><p><strong>标记-整理算法（Mark-Compact）</strong>：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是<strong>让所有存活的对象向一端移动</strong>，然后直接清理掉端边界以外的内存。<strong>优点</strong>：无内存碎片。内存利用率高。<strong>缺点</strong>：效率较低。</p><p><strong>分代收集算法（Generational Collection）</strong>：根据对象的生命周期将堆内存分为新生代（Young Generation）和老年代（Old Generation），对不同代采用不同的回收算法。</p><ul><li><strong>新生代</strong>：使用复制算法。分为 Eden 区和两个 Survivor 区（From 和 To）。</li><li><strong>老年代</strong>：使用标记-清除或标记-整理算法。</li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8: Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK22: G1</li></ul><p><strong>1. Serial 收集器</strong></p><ul><li><p><strong>特点</strong>：单线程收集（只使用一条垃圾收集线程，<strong>在进行垃圾收集时必须暂停其他所有工作线程</strong>，直到它收集结束）。适用于单核 CPU 或小型应用。新生代使用复制算法，老年代使用标记-整理算法。</p></li><li><p><strong>适用场景</strong>：客户端应用或单核服务器。  没有线程交互的开销，自然可以获得很高的单线程收集效率。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseSerialGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>2. Parallel 收集器（吞吐量优先收集器）</strong></p><ul><li><p><strong>特点</strong>：多线程收集。新生代使用复制算法，老年代使用标记-整理算法。<strong>注重吞吐量</strong>（Throughput）（高效率地利用cpu）。</p></li><li><p><strong>适用场景</strong>：多核 CPU 和<strong>吞吐量优先</strong>的应用（如批处理任务）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseParallelGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>3. Parallel Old 收集器</strong></p><ul><li><p><strong>特点</strong>：Parallel 收集器的老年代版本。多线程收集。使用标记-整理算法。</p></li><li><p><strong>适用场景</strong>：需要高吞吐量的多核服务器。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseParallelOldGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>4. CMS 收集器（Concurrent Mark-Sweep）</strong></p><ul><li><p><strong>特点：并发收集，减少停顿时间。</strong>新生代使用复制算法，老年代使用标记-清除算法。注重低延迟。</p></li><li><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。它非常符合在<strong>注重用户体验</strong>的应用上使用。CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了<strong>让垃圾收集线程与用户线程（基本上）同时工作。</strong></p></li><li><p><strong>缺点</strong>：产生内存碎片。对 CPU 资源敏感。</p></li><li><p><strong>适用场景</strong>：响应时间优先的应用（如 Web 服务）。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseConcMarkSweepGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>5. G1 收集器（Garbage-First）</strong></p><ul><li><p><strong>特点</strong>：将堆内存划分为多个区域（Region）。并发收集，兼顾吞吐量和响应时间。使用标记-整理算法。可预测的停顿时间（通过设置最大停顿时间）。另外，G1回收的范围是整个java堆，而之前的仅限于新生代或老年代。</p></li><li><p><strong>适用场景</strong>：大内存和多核 CPU 的应用。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseG1GC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h4 id="6-ZGC-收集器（Z-Garbage-Collector）"><a href="#6-ZGC-收集器（Z-Garbage-Collector）" class="headerlink" title="6. ZGC 收集器（Z Garbage Collector）"></a><strong>6. ZGC 收集器（Z Garbage Collector）</strong></h4><ul><li><p><strong>特点</strong>：低延迟（停顿时间不超过 10ms）。支持超大堆内存（TB 级别）。并发收集，使用染色指针（Colored Pointers）和读屏障（Load Barrier）。</p></li><li><p>ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。</p></li><li><p><strong>适用场景</strong>：大内存和低延迟场景（如实时系统）。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseZGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>7. Shenandoah 收集器</strong></p><ul><li><p><strong>特点</strong>：低延迟（停顿时间与堆大小无关）。并发收集，使用 Brooks 指针和读屏障。支持大内存。</p></li><li><p><strong>适用场景</strong>：大内存和低延迟场景。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseShenandoahGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><p><strong>8. Epsilon 收集器</strong></p><ul><li><p><strong>特点</strong>：不进行垃圾回收，仅分配内存。适用于性能测试或极短生命周期的应用。</p></li><li><p><strong>适用场景</strong>：测试环境或不需要垃圾回收的场景。</p></li><li><p><strong>启用参数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+UseEpsilonGC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p><p><a href="https://javabetter.cn/string/constant-pool.html">深入理解Java字符串常量池 | 二哥的Java进阶之路</a></p><p>泛型：<a href="https://blog.csdn.net/weixin_45395059/article/details/126006369">Java 中的泛型（两万字超全详解）_java 泛型-CSDN博客</a></p><p>反射：<a href="https://blog.csdn.net/weixin_74268571/article/details/131345164">Java反射详解-CSDN博客</a></p><p>注解：<a href="https://segmentfault.com/a/1190000044576598">Spring注解是如何实现的？万字详解 - 架构师技术栈 - SegmentFault 思否</a></p><p>hashset源码：<a href="https://blog.csdn.net/weixin_45663027/article/details/135825567">Java集合系列 HashSet底层源码 细致解读（超通俗易懂）_hashset 初始化长度的源代码-CSDN博客</a></p><p>ArrayDeque源码：<a href="https://javabetter.cn/collection/arraydeque.html">详解 Java 中的双端队列（ArrayDeque附源码分析） | 二哥的Java进阶之路</a></p><p>线程创建：<a href="https://mp.weixin.qq.com/s/NspUsyhEmKnJ-4OprRFp9g">大家都说Java有三种创建线程的方式！并发编程中的惊天骗局！</a></p><p>多线程：<a href="https://nan-ying.github.io/2023/03/25/Java%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%9310-%E5%A4%9A%E7%BA%BF%E7%A8%8B/#8-JDK5-0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F">Java知识整理和总结10-多线程 | Nan-ying’s Blog</a></p><p>volatile：<a href="https://blog.csdn.net/m0_49183244/article/details/125493673">Java中的volatile_java volatile-CSDN博客</a></p><p><a href="https://www.xiaolincoding.com/interview/juc.html#syncronized%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AE%B2%E4%B8%80%E4%B8%8B">Java并发编程面试题 | 小林coding</a></p><p><a href="https://blog.csdn.net/2301_78320637/article/details/142900288">【JVM】内存模型_jvm内存模型-CSDN博客</a></p><p><a href="https://segmentfault.com/a/1190000042313862">Java四大引用详解：强引用、软引用、弱引用、虚引用 - BAT架构技术与大厂面试 - SegmentFault 思否</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="后端" scheme="http://wolf-ll.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://wolf-ll.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SSM</title>
    <link href="http://wolf-ll.github.io/2024/05/21/ssm/"/>
    <id>http://wolf-ll.github.io/2024/05/21/ssm/</id>
    <published>2024-05-21T06:28:16.000Z</published>
    <updated>2024-10-08T13:22:53.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>Spring 5.X版本模块：</p><img src="/2024/05/21/ssm/1.png" alt="Spring5.x主要模块"><table><thead><tr><th align="left"><strong>功能模块</strong></th><th align="left"><strong>功能介绍</strong></th></tr></thead><tbody><tr><td align="left">Core Container</td><td align="left">核心容器，<strong>主要提供 IoC 依赖注入功能的支持</strong>。在 Spring 环境下使用任何功能都必须基于 <strong>IOC 容器</strong>。</td></tr><tr><td align="left">AOP&amp;Aspects</td><td align="left">面向切面编程</td></tr><tr><td align="left">Testing</td><td align="left">提供了对 junit 或 TestNG 测试框架的整合。</td></tr><tr><td align="left">Data Access/Integration</td><td align="left">提供了对数据访问/集成的功能。</td></tr><tr><td align="left">Spring MVC</td><td align="left">提供了面向Web应用程序的集成功能。</td></tr></tbody></table><h4 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h4><ul><li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong>：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong>：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul><li><strong>spring-aspects</strong>：该模块为与 AspectJ 的集成提供支持。</li><li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li><li><strong>spring-instrument</strong>：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li></ul><h4 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access/Integration"></a>Data Access/Integration</h4><ul><li><strong>spring-jdbc</strong>：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li><strong>spring-tx</strong>：提供对事务的支持。</li><li><strong>spring-orm</strong>：提供对 Hibernate、JPA、iBatis 等 ORM（对象关系映射） 框架的支持。</li><li><strong>spring-oxm</strong>：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li></ul><h4 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h4><ul><li><strong>spring-web</strong>：对 Web 功能的实现提供一些最基础的支持。</li><li><strong>spring-webmvc</strong>：提供对 Spring MVC 的实现。</li><li><strong>spring-websocket</strong>：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li><strong>spring-webflux</strong>：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li></ul><h4 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h4><ul><li><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</li></ul><h4 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h4><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="==Spring IOC=="></a>==Spring IOC==</h3><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是<strong>将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</strong>(对象创建控制权由程序转移到外部)。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><ul><li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。IOC容器的作用：</p><ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为==Bean==</li><li>IOC容器中放的就是一个个的Bean对象</li></ul><p>当IOC容器中创建好service和dao对象后，程序能正确执行么?</p><ul><li>不行，因为service运行需要依赖dao对象</li><li>IOC容器中虽然有service和dao对象，但是service对象和dao对象没有任何关系</li><li>需要把dao对象交给service,也就是说<strong>要绑定service和dao对象之间的关系</strong></li></ul><p>像这种在容器中建立对象与对象之间的绑定关系就要用到<strong>DI依赖注入</strong></p><ul><li><p>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入</p></li><li><p>如业务层需要依赖数据层，service就要和dao建立依赖关系</p></li></ul><p>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:==充分解耦==，具体实现靠:</p><ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul><blockquote><p>总结：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种具体实现。</p></blockquote><h3 id="IOC在Spring中的实现"><a href="#IOC在Spring中的实现" class="headerlink" title="IOC在Spring中的实现"></a>IOC在Spring中的实现</h3><p>resources下添加spring配置文件applicationContext.xml，并完成bean的配置</p><img src="/2024/05/21/ssm/1629734336440.png" alt="1629734336440" style="zoom: 67%;"><h4 id="bean基础配置-id与class"><a href="#bean基础配置-id与class" class="headerlink" title="bean基础配置(id与class)"></a>bean基础配置(id与class)</h4><p>对于bean的基础配置，在前面的案例中已经使用过:</p><pre class="line-numbers language-none"><code class="language-none">&lt;bean id="" class=""/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下</p><img src="/2024/05/21/ssm/image-20210729183500978.png" alt="image-20210729183500978" style="zoom: 50%;"><ul><li><p>bean依赖注入的ref属性指定bean，必须在容器中存在</p><img src="/2024/05/21/ssm/1629771744003.png" alt="1629771744003" style="zoom: 67%;"></li></ul><h4 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h4><p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p><p>就需要研究下<code>bean的实例化过程</code>，在这块内容中主要解决两部分内容，分别是</p><ul><li>bean是如何创建的</li><li>实例化bean的三种方式，<code>构造方法</code>,<code>静态工厂</code>和<code>实例工厂</code></li></ul><h5 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h5><blockquote><p>Spring 底层默认通过反射技术<strong>调用组件类的无参构造器</strong>来创建组件对象，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出异常。</p></blockquote><p>将类配置到Spring容器</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写运行程序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppForInstanceBook</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span>             <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BookDao</span> bookDao <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BookDao</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类中提供构造函数测试</p><p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">BookDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao constructor is running ...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数。将构造函数改成private测试，运行程序，能执行成功,说明内部走的依然是构造函数,能访问到类中的私有构造方法,显而易见Spring底层用的是反射。</p><h5 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h5><p>在spring的配置文件application.properties中添加以下内容:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>orderDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.factory.OrderDaoFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getOrderDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>class:工厂类的类全名</p><p>factory-mehod:具体工厂类中创建对象的方法名</p><p>对应关系如下图:</p><img src="/2024/05/21/ssm/image-20210729195248948.png" alt="image-20210729195248948" style="zoom:80%;"><p>在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppForInstanceOrder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">OrderDao</span> orderDao <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">OrderDao</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"orderDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，这些操作必不可少。这种方式一般是用来兼容早期的一些老系统，所以==了解为主==。</p><h5 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h5><p>在spring的配置文件中添加以下内容:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.factory.UserDaoFactory<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getUserDao<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userFactory<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实例化工厂运行的顺序是:</p><ul><li><p>创建实例化工厂对象,对应的是第一行配置</p></li><li><p>调用对象中的方法来创建bean，对应的是第二行配置</p><ul><li><p>factory-bean:工厂的实例对象</p></li><li><p>factory-method:工厂对象中的具体创建对象的方法名,对应关系如下:</p><img src="/2024/05/21/ssm/image-20210729200203249.png" alt="image-20210729200203249" style="zoom:80%;"></li></ul></li></ul><p>factory-mehod:具体工厂类中创建对象的方法名</p><p>(2)在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppForInstanceUser</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span>             <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">UserDao</span> userDao <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserDao</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例工厂实例化的方式就已经介绍完了，配置的过程还是比较复杂，所以Spring为了简化这种配置方式就提供了一种叫<code>FactoryBean</code>的方式来简化开发。</p><h5 id="FactoryBean的使用"><a href="#FactoryBean的使用" class="headerlink" title="FactoryBean的使用"></a>FactoryBean的使用</h5><p>具体的使用步骤为:</p><p>(1)创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDaoFactoryBean</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserDao</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//代替原始实例工厂中创建对象的方法</span>    <span class="token keyword">public</span> <span class="token class-name">UserDao</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回所创建类的Class对象</span>    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">UserDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)在Spring的配置文件中进行配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.factory.UserDaoFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(3)AppForInstanceUser运行类不用做任何修改，直接运行</p><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><ol><li>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</li></ol><ul><li>在bean中定义引用类型属性，并<strong>提供可访问的==set==方法</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">BookDao</span> bookDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBookDao</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span> bookDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bookDao <span class="token operator">=</span> bookDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置中使用==property==标签==ref==属性注入引用类型对象</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.imipl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.注入简单数据类型：和引用类型类似</p><blockquote><p>1.在BookDaoImpl类中声明对应的简单数据类型的属性</p><p>2.为这些属性提供对应的setter方法</p><p>3.在applicationContext.xml中配置</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> databaseName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> connectionNum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setConnectionNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> connectionNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>connectionNum <span class="token operator">=</span> connectionNum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token class-name">String</span> databaseName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>databaseName <span class="token operator">=</span> databaseName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token operator">+</span>databaseName<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>connectionNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置文件中使用property标签注入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>databaseName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>connectionNum<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookService</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">BookDao</span> bookDao<span class="token punctuation">;</span>    <span class="token comment">// 利用构造器传参</span>    <span class="token keyword">public</span> <span class="token class-name">BookServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span> bookDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bookDao <span class="token operator">=</span> bookDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book service save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标签<constructor-arg>中</constructor-arg></p><ul><li><p>name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。</p></li><li><p>ref属性指向的是spring的IOC容器中其他bean对象。</p></li></ul><p><strong>注入简单数据类型</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> databaseName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> connectionNum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">BookDaoImpl</span><span class="token punctuation">(</span><span class="token class-name">String</span> databaseName<span class="token punctuation">,</span> <span class="token keyword">int</span> connectionNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>databaseName <span class="token operator">=</span> databaseName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>connectionNum <span class="token operator">=</span> connectionNum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token operator">+</span>databaseName<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>connectionNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>databaseName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>connectionNum<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>666<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变</li><li>这两块存在紧耦合，具体该如何解决?</li></ul><p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，大家都以了解为主。</p><p>方式一:删除name属性，添加type属性，按照类型注入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种方式可以解决构造函数形参名发生变化带来的耦合问题</li><li>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</li></ul><p>方式二:删除type属性，添加index属性，按照索引下标注入，下标从0开始</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种方式可以解决参数类型重复问题</li><li>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</li></ul><p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul><li>强制依赖指对象在创建的过程中必须要注入指定的参数</li></ul></li><li>可选依赖使用setter注入进行，灵活性强<ul><li>可选依赖指对象在创建过程中注入的参数可有可无</li></ul></li></ol><h4 id="依赖自动装配"><a href="#依赖自动装配" class="headerlink" title="依赖自动装配"></a>依赖自动装配</h4><p>IoC容器根据bean所依赖的资源<strong>在容器中自动查找并注入到bean中的过程称</strong>为自动装配</p><p>自动装配只需要修改applicationContext.xml配置文件即可:</p><p>(1)将<code>&lt;property&gt;</code>标签删除</p><p>(2)在<code>&lt;bean&gt;</code>标签中添加autowire属性</p><p>首先来实现按照类型注入的配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byType<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意事项:==</p><ul><li>需要注入属性的类中<strong>对应属性的setter方法不能省略</strong></li><li><strong>被注入的对象必须要被Spring的IOC容器管理</strong></li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li></ul><p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要<strong>按照名称注入</strong>，配置方式为:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl.BookServiceImpl<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byName<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意事项:==</p><ul><li><p><strong>按照名称注入中的名称指的是什么?</strong></p><img src="/2024/05/21/ssm/1629806856156.png" alt="1629806856156" style="zoom:80%;"><ul><li>bookDao是private修饰的，外部类无法直接方访问</li><li>外部类只能通过属性的set方法进行访问</li><li>==========<strong>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名</strong>=============<ul><li>为什么是去掉set首字母小写?</li><li>这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名</li></ul></li><li>所以按照名称注入，其实是和对应的set方法有关，但是<strong>如果按照标准起名称，属性名和set对应的名是一致的</strong></li></ul></li><li><p>如果按照名称去找对应的bean对象，<strong>找不到则注入Null</strong></p></li><li><p>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</p></li></ul><p>两种方式介绍完后，以后用的<strong>更多的是==按照类型==注入。</strong></p><p>最后对于依赖注入，需要注意一些其他的配置特征:</p><ol><li>自动装配<strong>用于引用类型依赖注入</strong>，因为被注入的对象必须要被Spring的IOC容器管理，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中<strong>相同类型的bean唯一</strong>，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中<strong>具有指定名称的bean</strong>，因<strong>变量名与配置耦合，不推荐使用</strong></li><li>自动装配优先级低于setter注入与构造器注入，<strong>同时出现时自动装配配置失效</strong></li></ol><h4 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h4><p>下面的配置方式，都是在bookDao的bean标签中使用<property>进行注入</property></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注入数组类型数据"><a href="#注入数组类型数据" class="headerlink" title="注入数组类型数据"></a>注入数组类型数据</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>array<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>100<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>200<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>300<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注入Map"><a href="#注入Map" class="headerlink" title="注入Map"></a>注入Map</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>country<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>china<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>province<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>henan<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>kaifeng<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注入Properties类型数据"><a href="#注入Properties类型数据" class="headerlink" title="注入Properties类型数据"></a>注入Properties类型数据</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>properties<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>props</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>country<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>china<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>province<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>henan<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>kaifeng<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>props</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BeanFactory-与-FactoryBean-的区别"><a href="#BeanFactory-与-FactoryBean-的区别" class="headerlink" title="BeanFactory 与 FactoryBean 的区别"></a>BeanFactory 与 FactoryBean 的区别</h3><p><strong>BeanFactory</strong></p><ul><li><p>BeanFactory<strong>定义了IOC容器的最基本形式</strong>，并提供了IOC容器应遵守的的最基本的接口，也就是SpringIOC所遵守的最底层和最基本的编程规范。</p></li><li><p>它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。在Spring代码中，BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，都是附加了某种功能的实现。</p></li><li><p>BeanFactory</p><ul><li>使用BeanFactory创建的容器是延迟加载</li><li>使用ApplicationContext创建的容器是立即加载</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">BeansException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">ResolvableType</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token constant">FACTORY_BEAN_PREFIX</span> <span class="token operator">=</span> <span class="token string">"&amp;"</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> var1<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isTypeMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">ResolvableType</span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isTypeMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchBeanDefinitionException</span><span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAliases</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>FactoryBean</strong></p><ul><li>一般情况下，Spring通过反射机制利用的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案.</li><li>Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean的形式</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">T</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在该接口中还定义了以下3个方法：</p><ul><li>T getObject()返回由FactoryBean创建的Bean实例，如果isSingleton()返回true，则该实例会放到Spring容器中单实例缓存池中；</li><li>boolean isSingleton()：返回由FactoryBean创建的Bean实例的作用域是singleton还是prototype；</li><li>Class getObjectType()：返回FactoryBean创建的Bean类型。当配置文件中的class属性配置的实现类是FactoryBean时，通过getBean()方法返回的不是FactoryBean本身，而是FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。<br>例：如果使用传统方式配置下面Car的时，Car的每个属性分别对应一个元素标签。</li></ul><h3 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h3><p><strong>创建 Bean 的实例</strong>：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</p><p><strong>Bean 属性赋值/填充</strong>：为 Bean 设置相关属性和依赖，例如<code>@Autowired</code> 等注解注入的对象、<code>@Value</code> 注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</p><p><strong>Bean 初始化</strong>： </p><ul><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li><strong>给bean对象设置属性</strong>：如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li><strong>bean对象初始化之前操作</strong>：如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 <code>init-method</code> 属性，执行指定的方法。</li><li><strong>bean对象初始化之后操作</strong>：如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法。</li></ul><p><strong>销毁 Bean</strong>：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。 </p><ul><li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li></ul><img src="/2024/05/21/ssm/spring-bean-lifestyle.png" alt="img" style="zoom:80%;"><h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。</p><h4 id="注解开发定义bean（2-5）"><a href="#注解开发定义bean（2-5）" class="headerlink" title="注解开发定义bean（2. 5）"></a>注解开发定义bean（2. 5）</h4><p><strong>步骤1:删除原XML配置</strong></p><p>将配置文件中的<code>&lt;bean&gt;</code>标签删除掉</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.dao.impl.BookDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>步骤2:Dao上添加注解</strong></p><p>在BookDaoImpl类上添加<code>@Component</code>注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意:@Component注解不可以添加在接口上，因为接口是无法创建对象的。==</p><p>XML与注解配置的对应关系:</p><img src="/2024/05/21/ssm/1629990315619.png" alt="1629990315619" style="zoom:80%;"><p><strong>步骤3:配置Spring的注解包扫描</strong></p><p>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明:</strong></p><p>component-scan</p><ul><li>component:组件,<strong>Spring将管理的bean视作自己的一个组件</strong></li><li>scan:扫描</li></ul><p>base-package<strong>指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</strong></p><ul><li>包路径越多[如:com.itheima.dao.impl]，扫描的范围越小速度越快</li><li>包路径越少[如:com.itheima],扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下[如:com.itheima]即可。</li></ul><h4 id="纯注解开发（3-0）"><a href="#纯注解开发（3-0）" class="headerlink" title="纯注解开发（3.0）"></a>纯注解开发（3.0）</h4><p>实现思路：将配置文件applicationContext.xml删除掉，使用类来替换。</p><ul><li><p>Java类（SpringConfig）替换Spring核心配置文件（ApplicationContext）</p><img src="/2024/05/21/ssm/1630029254372.png" alt="1630029254372" style="zoom:80%;"></li><li><p>@Configuration注解用于设定当前类为配置类</p></li><li><p>@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</p><pre class="line-numbers language-none"><code class="language-none">@ComponentScan({com.itheima.service","com.itheima.dao"})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 加载配置文件初始化容器</span><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 加载配置类初始化容器</span><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="注解相关问题"><a href="#注解相关问题" class="headerlink" title="注解相关问题"></a>注解相关问题</h3><h4 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些"></a>将一个类声明为 Bean 的注解有哪些</h4><ul><li><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</li></ul><p>通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是<strong>在@Component注解的基础上起了三个新的名字</strong>。</p><p>对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。</p><p>注意：虽然它们<strong>本质上一样</strong>，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。</p><h4 id="Component-和-Bean-的区别是什么"><a href="#Component-和-Bean-的区别是什么" class="headerlink" title="@Component 和 @Bean 的区别是什么"></a>@Component 和 @Bean 的区别是什么</h4><ul><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。**<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。**</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的<strong>自定义性更强</strong>，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我<strong>们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</strong></li></ul><p><code>@Bean</code>注解使用示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码相当于下面的 xml 配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transferService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.acme.TransferServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>@Bean注解的作用是将方法的返回值制作为Spring管理的一个bean对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">DataSource</span> <span class="token function">dataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">DruidDataSource</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DruidDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/spring_db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ds<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意:不能使用<code>DataSource ds = new DruidDataSource()</code></strong></p><p>因为DataSource接口中没有对应的setter方法来设置属性。</p><h4 id="注入-Bean-的注解有哪些"><a href="#注入-Bean-的注解有哪些" class="headerlink" title="注入 Bean 的注解有哪些"></a>注入 Bean 的注解有哪些</h4><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th>Annotation</th><th>Package</th><th>Source</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td><code>org.springframework.bean.factory</code></td><td>Spring 2.5+</td></tr><tr><td><code>@Resource</code></td><td><code>javax.annotation</code></td><td>Java JSR-250</td></tr><tr><td><code>@Inject</code></td><td><code>javax.inject</code></td><td>Java JSR-330</td></tr></tbody></table><p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p><h4 id="Autowired-和-Resource-的区别是什么"><a href="#Autowired-和-Resource-的区别是什么" class="headerlink" title="@Autowired 和 @Resource 的区别是什么"></a>@Autowired 和 @Resource 的区别是什么</h4><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会<strong>优先根据接口类型去匹配并注入 Bean</strong> （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> <strong>当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了</strong>，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p><strong>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。</strong>就比如说下面代码中的 <code>smsService</code> 就是我这里所说的名称，这样应该比较好理解了吧。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// smsService 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><span class="token comment">// smsServiceImpl1 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还是建议通过 <code>@Qualifier</code> 注解来显式指定名称而不是依赖变量的名称。</p><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p><p>简单总结一下：</p><ul><li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li><li><strong><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用</strong>。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li></ul><p>为什么不需要set方法：</p><ul><li>@Autowired可以写在属性上，也可也写在setter方法上，最简单的处理方式是<code>写在属性上并将setter方法删除掉</code></li><li>为什么setter方法可以删除呢?<ul><li><strong>自动装配基于反射设计创建对象并通过暴力反射为私有属性进行设值</strong></li><li>普通反射只能获取public修饰的内容</li><li><strong>暴力反射除了获取public修饰的内容还可以获取private修改的内容</strong></li><li>所以此处无需提供setter方法</li></ul></li></ul><h3 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h3><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p><p><strong>步骤1：resource下准备properties文件</strong></p><p>jdbc.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">name</span><span class="token punctuation">=</span><span class="token value attr-value">itheima888</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>步骤2: 使用注解加载properties配置文件</strong></p><p>在配置类上添加<code>@PropertySource</code>注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.itheima"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token string">"jdbc.properties"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤3：使用@Value读取配置文件中的内容</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Repository</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${name}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bean作用范围"><a href="#bean作用范围" class="headerlink" title="bean作用范围"></a>bean作用范围</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 <strong>bean 默认都是单例的</strong>，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，<strong>连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</strong></li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application/global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml 方式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>singleton<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注解方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">personPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bean-是线程安全的吗"><a href="#Bean-是线程安全的吗" class="headerlink" title="Bean 是线程安全的吗"></a>Bean 是线程安全的吗</h3><p>Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。</p><p>我们这里以最常用的两种作用域 prototype 和 singleton 为例介绍。几乎所有场景的 Bean 作用域都是使用默认的 singleton ，重点关注 singleton 作用域即可。</p><blockquote><p>prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。<strong>如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。</strong></p><p>不过，大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p></blockquote><p>对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：</p><ol><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="==Spring AOP=="></a>==Spring AOP==</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它是通过预编译方式和运行期动态代理方式实现在<strong>不修改源代码的情况下给程序动态统一添加额外功能</strong>的一种技术。</p></li><li><p>OOP(Object Oriented Programming)面向对象编程</p></li><li><p>作用：在不修改原始设计的基础上为其进行功能增强。利用Aop可以对业务逻辑的<strong>各个部分进行隔离</strong>，从而使得业务逻辑各个部分之间的**<code>耦合度</code>降低<strong>，提高程序的</strong>可重用性**，同时提高可开发效率</p></li></ul><blockquote><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些<strong>与业务无关，却为业务模块所共同调用的逻辑或责任</strong>（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是<strong>基于动态代理</strong>的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p></blockquote><img src="/2024/05/21/ssm/230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess"><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p><strong>1.横切关注点</strong></p><p>从每个方法中抽取出来的<strong>同一类非核心业务</strong>。在同一个项目中，我们可以使用多个横切关注点对相关的方法进行多个不同方面的增强。</p><p>这个概念不是语法层面天然存在的，而是<strong>根据附加功能的逻辑上的需要</strong>：有十个附加功能，就有十个横切关注点。</p><p><strong>2.通知</strong></p><p>每一个横切关注点上<strong>要做的事情</strong>都需要写一个方法来实现，这样的方法就叫<strong>通知方法</strong>。</p><ul><li><p>前置通知：在被代理的目标方法前执行</p></li><li><p>返回通知：在被代理的目标方法成功结束后执行（寿终正寝）</p></li><li><p>异常通知：在被代理的目标方法异常结束后执行（死于非命）</p></li><li><p>后置通知：在被代理的目标方法最终结束后执行（盖棺定论）</p></li><li><p>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</p></li></ul><p><strong>3.切面</strong></p><p>封装通知方法的类</p><p><strong>4.目标</strong></p><p>被代理的目标对象</p><p><strong>5.代理</strong></p><p>向目标对象应用通知之后创建的代理对象</p><p><strong>6.连接点</strong></p><p>这也是一个纯逻辑概念，不是语法定义的。</p><ul><li>把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。</li><li><strong>程序执行过程中的任意位置</strong>，粒度为执行方法、抛出异常、设置变量等</li></ul><img src="/2024/05/21/ssm/23.png" alt="23" style="zoom: 67%;"><p><strong>7.切入点</strong></p><p>定位连接点的方式。（<strong>匹配连接点的式子</strong>）</p><p>如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。</p><p>Spring 的 AOP 技术可以通过切入点定位到特定的连接点。切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。<br>连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是<strong>连接点的方法就不一定要被增强，所以可能不是切入点。</strong></p><h3 id="基于注解的AOP"><a href="#基于注解的AOP" class="headerlink" title="基于注解的AOP"></a>基于注解的AOP</h3><p>案例设定：测算接口执行效率，但是这个案例稍微复杂了点，我们对其进行简化。</p><p>简化设定：在方法执行前输出当前系统时间。</p><blockquote><p>1.导入坐标(pom.xml)</p><p>2.制作连接点(原始操作，Dao接口与实现类)</p><p>3.制作共性功能(通知类与通知)</p><p>4.定义切入点</p><p>5.绑定切入点与通知关系(切面)</p></blockquote><ul><li><p>pom.xml添加Spring依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.2.10.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加BookDao和BookDaoImpl类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Repository</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book dao update ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建Spring的配置类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.itheima"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写App运行类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BookDao</span> bookDao <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>我们要使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能。</p><h4 id="AOP实现"><a href="#AOP实现" class="headerlink" title="AOP实现"></a>AOP实现</h4><p><strong>步骤1:添加依赖</strong></p><p>pom.xml</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.aspectj<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aspectjweaver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.9.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤2:定义接口与实现类</strong></p><pre class="line-numbers language-none"><code class="language-none">环境准备的时候，BookDaoImpl已经准备好，不需要做任何修改<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>步骤3:定义通知类和通知</strong></p><p>通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类名和方法名没有要求，可以任意。</p><p><strong>步骤4:定义切入点</strong></p><p>BookDaoImpl中有两个方法，分别是save和update，我们<strong>要增强的是update方法</strong>，该如何定义呢?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明:</strong></p><ul><li>切入点定义<strong>依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</strong></li><li>execution及后面编写的内容，后面会有章节专门去学习。</li></ul><p><strong>步骤5:制作切面</strong></p><p>切面是用来描述通知和切入点之间的关系，如何进行关系的绑定?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span><span class="token comment">// 设置切入点方法</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span><span class="token comment">// 设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行==位置==</strong></p><img src="/2024/05/21/ssm/1630148447689.png" alt="1630148447689" style="zoom:80%;"><p><strong>说明:</strong>@Before翻译过来是之前，也就是说<strong>通知会在切入点方法执行之前执行，</strong>除此之前还有其他四种类型，后面会讲。</p><p><strong>步骤6:将通知类配给容器并标识其为切面类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token comment">// 设置当前类为AOP切面类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤7:开启注解格式AOP功能</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.itheima"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token comment">// 开启注解格式AOP功能</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤8:运行程序</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BookDao</span> bookDao <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">BookDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookDao<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到在执行update方法之前打印了系统时间戳，说明对原始方法进行了增强，AOP编程成功。</p><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul><li>切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类/接口名.方法名(参数) 异常名）</li></ul><p>对于这个格式，我们不需要硬记，通过一个例子，理解它:</p><pre class="line-numbers language-none"><code class="language-none">execution(public User com.itheima.service.UserService.findById(int))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>public:访问修饰符,还可以是public，private等，可以省略</li><li>User：返回值，写返回值类型</li><li>com.itheima.service：包名，多级包使用点连接</li><li>UserService:类/接口名称</li><li>findById：方法名</li><li>int:参数，直接写参数的类型，多个类型用逗号隔开</li><li>异常名：方法定义中抛出指定异常，可以省略</li></ul><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>我们使用通配符描述切入点，主要的目的就是简化之前的配置，具体都有哪些通配符可以使用?</p><ul><li><p><code>*</code>:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><pre class="line-numbers language-none"><code class="language-none">execution（public * com.itheima.*.UserService.find*(*))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p></li><li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p><pre class="line-numbers language-none"><code class="language-none">execution（public User com..UserService.findById(..))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法</p></li><li><p><code>+</code>：专用于匹配子类类型</p><pre class="line-numbers language-none"><code class="language-none">execution(* *..*Service+.*(..))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个使用率较低，描述子类的，咱们做JavaEE开发，继承机会就一次，使用都很慎重，所以很少用它。*Service+，表示所有以Service结尾的接口的子类。</p></li></ul><h5 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h5><ul><li>描述切入点通**==常描述接口==**，而不描述实现类,如果描述到实现类，就出现紧耦合了</li><li>访问控制修饰符针对接口开发均采用public描述（**==可省略访问控制修饰符描述==**）</li><li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述</li><li>**==包名==<strong>书写</strong>==尽量不使用..匹配==**，效率过低，常用*做单个包描述匹配，或精准匹配</li><li>**==接口名/类名==<strong>书写名称与模块相关的</strong>==采用*匹配==**，例如UserService书写成*Service，绑定业务层接口名</li><li>**==方法名==<strong>书写以</strong>==动词==<strong>进行</strong>==精准匹配==*<em>，名词采用</em>匹配，例如getById书写成getBy*,selectAll书写成selectAll</li><li>参数规则较为复杂，根据业务方法灵活调整</li><li>通常**==不使用异常==<strong>作为</strong>==匹配==**规则</li></ul><h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><img src="/2024/05/21/ssm/1630166147697.png" alt="1630166147697" style="zoom:80%;"><p>(1)前置通知，追加功能到方法执行前,类似于在代码1或者代码2添加内容</p><p>(2)后置通知,追加功能到方法执行后,不管方法执行的过程中有没有抛出异常都会执行，类似于在代码5添加内容</p><p>(3)返回后通知,追加功能到方法执行后，只有方法正常执行结束后才进行,类似于在代码3添加内容，如果方法执行抛出异常，返回后通知将不会被添加</p><p>(4)抛出异常后通知,追加功能到方法抛出异常后，只有方法执行出异常才进行,类似于在代码4添加内容，只有方法抛出异常后才会被添加</p><p>(5)环绕通知,环绕通知功能比较强大，它可以追加功能到方法执行的前后，这也是比较常用的方式，它可以实现其他四种通知类型的功能，具体是如何实现的，需要我们往下学习。</p><p><strong>各种通知</strong></p><p>如果我们使用环绕通知的话，要根据原始方法的返回值来设置环绕通知的返回值，具体解决方案为:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdvice</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(void com.itheima.dao.BookDao.update())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(int com.itheima.dao.BookDao.select())"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"pt2()"</span><span class="token punctuation">)</span><span class="token comment">// 返回后通知</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterReturning</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"afterReturning advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"pt2()"</span><span class="token punctuation">)</span>    <span class="token comment">// 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">aroundSelect</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> pjp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"around before advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//表示对原始操作的调用</span>        <span class="token class-name">Object</span> ret <span class="token operator">=</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"around after advice ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明:</strong></p><p>​为什么返回的是Object而不是int的主要原因是Object类型更通用。</p><p>​在环绕通知中是可以对原始方法返回值就行修改的。</p><h3 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h3><p><strong>流程1:Spring容器启动</strong></p><ul><li>容器启动就需要去加载bean,哪些类需要被加载呢?</li><li><strong>需要被增强的类，如:BookServiceImpl</strong></li><li><strong>通知类，如:MyAdvice</strong></li><li>注意此时<strong>bean对象还没有创建成功</strong></li></ul><p><strong>流程2:读取所有切面配置中的切入点</strong></p><ul><li><p>上面这个例子中有两个切入点的配置，但是第一个<code>ptx()</code>并没有被使用，所以不会被读取。</p><img src="/2024/05/21/ssm/1630151682428.png?lastModify=171635275" alt="1630151682428" style="zoom: 67%;"></li></ul><p><strong>流程3:初始化bean</strong></p><p>判定bean对应的<strong>类中的方法是否匹配到任意切入点</strong></p><ul><li>注意第1步在容器启动的时候，bean对象还没有被创建成功。</li><li>要被实例化bean对象的类中的方法和切入点进行匹配</li><li>匹配失败，创建原始对象,如<code>UserDao</code><ul><li>匹配失败说明不需要增强，直接调用原始对象的方法即可。</li></ul></li><li>匹配成功，<strong>创建原始对象（==目标对象==）的==代理==对象,如:<code>BookDao</code></strong><ul><li>匹配成功说明需要对其进行增强</li><li>对哪个类做增强，这个类对应的对象就叫做目标对象</li><li>因为<strong>要对目标对象进行功能增强，而采用的技术是动态代理，所以会为其创建一个代理对象</strong></li><li>最终运行的是<strong>代理对象的方法</strong>，在该方法中会对原始方法进行功能增强</li></ul></li></ul><p><strong>流程4:获取bean执行方法</strong></p><ul><li>获取的bean是原始对象时，调用方法并执行，完成操作</li><li>获取的bean是代理对象时，<strong>根据代理对象的运行模式运行原始方法与增强的内容</strong>，完成操作</li></ul><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><p>在上面介绍AOP的工作流程中，我们提到了两个核心概念，分别是:</p><ul><li>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</li><li>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li></ul><p>上面这两个概念比较抽象，简单来说，</p><p>目标对象就是要增强的类[如:BookServiceImpl类]对应的对象，也叫原始对象，不能说它不能运行，只能说它在运行的过程中对于要增强的内容是缺失的。</p><p>SpringAOP是在不改变原有设计(代码)的前提下对其进行增强的，它的底层采用的是<strong>代理模式</strong>实现的，所以要对原始对象进行增强，就需要对原始对象创建代理对象，<strong>在代理对象中的方法把通知[如:MyAdvice中的method方法]内容加进去，就实现了增强,这就是我们所说的代理(Proxy)。</strong></p><h3 id="AOP的优点"><a href="#AOP的优点" class="headerlink" title="AOP的优点"></a>AOP的优点</h3><ol><li><p><strong>模块化</strong>: AOP可以将横向关注点与纵向业务逻辑分离，从而实现模块化，使代码更加清晰易懂，易于维护和扩展；</p></li><li><p><strong>可重用性</strong>: AOP可以将横向关注点作为独立的模块，从而使这些模块可以被多个应用程序共用，提高代码的可重用性；</p></li><li><p><strong>简化代码</strong>: AOP可以用比传统方法更少的代码来实现同样的功能，从而简化代码，提高代码的可读性和可维护性；</p></li><li><p><strong>提高程序的灵活性</strong>: AOP可以通过将横向关注点独立出来，使得程序的各个模块之间的耦合度降低，从而提高程序的灵活性，便于进行功能扩展和修改；</p></li><li><p><strong>提高程序的安全性</strong>: AOP<strong>可以通过将安全控制与业务逻辑分离，提高程序的安全性，减少潜在的安全漏洞。</strong></p></li></ol><hr><p>可以使用@Order注解来控制切面的顺序。在同一个方法上应用多个切面时，可以为每个切面添加不同的@Order值，值越小的切面将先执行，值越大的切面将后执行。如果没有指定@Order值，则默认优先级为0。</p><h3 id="拦截器和aop的区别"><a href="#拦截器和aop的区别" class="headerlink" title="拦截器和aop的区别"></a>拦截器和aop的区别</h3><p>拦截器和AOP在以下四个方面存在区别：</p><blockquote><p>定义和用途：拦截器是一种<strong>设计模式</strong>，拦截器可以在方法调用之前、之后或异常发生时插入额外的逻辑，常见于各种编程语言和框架，如Java的Servlet过滤器、Spring的拦截器等。在Java中，拦截器通常与AOP框架结合使用。拦截器可以在<strong>方法级别或类级别</strong>进行配置，并按照一定的顺序依次执行。</p><p>AOP是一种<strong>编程范式</strong>，旨在通过<strong>将跨越多个对象和层的功能（称为“切面”）从业务逻辑中解耦出来，实现横切关注点的复用</strong>。AOP可以在不修改原始代码的情况下，将切面应用于一个或多个目标对象，以增加特定功能，例如<strong>日志记录、事务管理、性能监控</strong>等。</p><p>拦截对象：拦截器主要针对<strong>URL</strong>进行拦截，而AOP针对的是<strong>具体的代码</strong>，能够实现更加复杂的业务逻辑。</p><p>灵活性：AOP更加灵活，可以对方法进行拦截，也可以对类进行拦截，而拦截器只能对特定的URL或者action进行拦截。</p><p>实现方式：拦截器和AOP都是使用<strong>代理模式</strong>实现，但AOP还包含一种特殊的代理，即CGLib代理。这种代理可以针对类进行代理，而不仅仅是对接口进行代理。</p></blockquote><p>总结来说，拦截器和AOP在定义和用途、拦截对象、灵活性和实现方式上存在区别。拦截器主要用于过滤和拦截特定URL或action，而AOP主要用于解耦和复用横切关注点。</p><h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别"></a>Spring AOP 和 AspectJ AOP 有什么区别</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>SpringMVC是一种<strong>基于Java实现MVC模型</strong>的轻量级Web框架，隶属于Spring框架的一部分，对Servlet进行了封装。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC 是<strong>模型(Model)、视图(View)、控制器(Controller)<strong>的简写，其核心思想是通过将</strong>业务逻辑、数据、显示</strong>分离来组织代码。</p><img src="/2024/05/21/ssm/image-20210809181452421.png" alt="img"><blockquote><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><p>MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p></blockquote><h3 id="SpringMVC-的核心组件"><a href="#SpringMVC-的核心组件" class="headerlink" title="SpringMVC 的核心组件"></a>SpringMVC 的核心组件</h3><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p><ul><li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h3 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h3><img src="/2024/05/21/ssm/de6d2b213f112297298f3e223bf08f28.png" alt="img"><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li><li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><h3 id="Spring-框架用到了哪些设计模式"><a href="#Spring-框架用到了哪些设计模式" class="headerlink" title="Spring 框架用到了哪些设计模式"></a>Spring 框架用到了哪些设计模式</h3><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h3 id="Spring循环依赖-三级缓存"><a href="#Spring循环依赖-三级缓存" class="headerlink" title="Spring循环依赖-三级缓存"></a>Spring循环依赖-三级缓存</h3><p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%86%E8%A7%A3%E5%90%97-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%86%E8%A7%A3%E5%90%97-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3</a></p><p>Spring 框架通过使用三级缓存来解决这个问题，确保即使在循环依赖的情况下也能正确创建 Bean。</p><p>Spring 中的三级缓存其实就是三个 Map，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 一级缓存</span><span class="token comment">/** Cache of singleton objects: bean name to bean instance. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 二级缓存</span><span class="token comment">/** Cache of early singleton objects: bean name to bean instance. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 三级缓存</span><span class="token comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>一级缓存（singletonObjects）</strong>：存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。一般情况我们获取 Bean 都是从这里获取的，但是并不是所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。</p><p><strong>二级缓存（earlySingletonObjects）</strong>：存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中<code>ObjectFactory</code>产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用<code>ObjectFactory#getObject()</code>都是会产生新的代理对象的。</p><p><strong>三级缓存（singletonFactories）</strong>：存放<code>ObjectFactory</code>，<code>ObjectFactory</code>的<code>getObject()</code>方法（最终调用的是<code>getEarlyBeanReference()</code>方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。</p></blockquote><p>接下来说一下 Spring 创建 Bean 的流程：</p><ol><li>先去 <strong>一级缓存 <code>singletonObjects</code></strong> 中获取，存在就返回；</li><li>如果不存在或者对象正在创建中，于是去 <strong>二级缓存 <code>earlySingletonObjects</code></strong> 中获取；</li><li>如果还没有获取到，就去 <strong>三级缓存 <code>singletonFactories</code></strong> 中获取，通过执行 <code>ObjectFacotry</code> 的 <code>getObject()</code> 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。</li></ol><p>解决循环依赖的流程如下：</p><ul><li>当 Spring 创建 A 之后，发现 A 依赖了 B ，又去创建 B，B 依赖了 A ，又去创建 A；</li><li>在 B 创建 A 的时候，那么此时 A 就发生了循环依赖，由于 A 此时还没有初始化完成，因此在 <strong>一二级缓存</strong> 中肯定没有 A；</li><li>那么此时就去三级缓存中调用 <code>getObject()</code> 方法去获取 A 的 <strong>前期暴露的对象</strong> ，也就是调用上边加入的 <code>getEarlyBeanReference()</code> 方法，生成一个 A 的 <strong>前期暴露对象</strong>；</li><li>然后就将这个 <code>ObjectFactory</code> 从三级缓存中移除，并且将前期暴露对象放入到二级缓存中，那么 B 就将这个前期暴露对象注入到依赖，来支持循环依赖。</li></ul><blockquote><p><strong>最后总结一下 Spring 如何解决三级缓存</strong>：</p><p>在三级缓存这一块，主要记一下 Spring 是如何支持循环依赖的即可，也就是如果发生循环依赖的话，就去 <strong>三级缓存 <code>singletonFactories</code></strong> 中拿到三级缓存中存储的 <code>ObjectFactory</code> 并调用它的 <code>getObject()</code> 方法来获取这个循环依赖对象的前期暴露对象（虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了），并且将这个前期暴露对象放到二级缓存中，这样在循环依赖时，就不会重复初始化了！</p><p>不过，这种机制也有一些缺点，比如增加了内存开销（需要维护三级缓存，也就是三个 Map），降低了性能（需要进行多次检查和转换）。并且，还有少部分情况是不支持循环依赖的，比如非单例的 bean 和<code>@Async</code>注解的 bean 无法支持循环依赖。</p></blockquote><h4 id="Lazy能解决循环依赖吗"><a href="#Lazy能解决循环依赖吗" class="headerlink" title="@Lazy能解决循环依赖吗"></a>@Lazy能解决循环依赖吗</h4><p><code>@Lazy</code> 用来标识类是否需要懒加载/延迟加载，可以作用在类上、方法上、构造器上、方法参数上、成员变量中。</p><p>Spring Boot 2.2 新增了全局懒加载属性，开启后全局 bean 被设置为懒加载，需要时再去创建。</p><p>配置文件配置全局懒加载：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#默认false</span><span class="token key attr-name">spring.main.lazy-initialization</span><span class="token punctuation">=</span><span class="token value attr-value">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编码的方式设置全局懒加载：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SpringApplication</span> springApplication<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">Start</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>springApplication<span class="token punctuation">.</span><span class="token function">setLazyInitialization</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>springApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如非必要，尽量不要用全局懒加载。<strong>全局懒加载会让 Bean 第一次使用的时候加载会变慢，并且它会延迟应用程序问题的发现</strong>（当 Bean 被初始化时，问题才会出现）。</p><p>如果一个 Bean 没有被标记为懒加载，那么它会在 Spring IoC 容器启动的过程中被创建和初始化。如果一个 Bean 被标记为懒加载，那么<strong>它不会在 Spring IoC 容器启动时立即实例化，而是在第一次被请求时才创建</strong>。这可以帮助减少应用启动时的初始化时间，也可以用来解决循环依赖问题。</p><p>循环依赖问题是如何通过<code>@Lazy</code> 解决的呢？这里举一个例子，比如说有两个 Bean，A 和 B，他们之间发生了循环依赖，那么 A 的构造器上添加 <code>@Lazy</code> 注解之后（延迟 Bean B 的实例化），加载的流程如下：</p><ul><li>首先 Spring 会去创建 A 的 Bean，创建时需要注入 B 的属性；</li><li>由于在 A 上标注了 <code>@Lazy</code> 注解，因此 <strong>Spring 会去创建一个 B 的代理对象，将这个代理对象注入到 A 中的 B 属性；</strong></li><li>之后开始执行 B 的实例化、初始化，在注入 B 中的 A 属性时，此时 A 已经创建完毕了，就可以将 A 给注入进去。</li></ul><p>通过 <code>@Lazy</code> 就解决了循环依赖的注入， <strong>关键点就在于对 A 中的属性 B 进行注入时，注入的是 B 的代理对象，因此不会循环依赖。</strong></p><p>之前说的发生循环依赖是因为在对 A 中的属性 B 进行注入时，注入的是 B 对象，此时又会去初始化 B 对象，发现 B 又依赖了 A，因此才导致的循环依赖。</p><p>一般是不建议使用循环依赖的，但是如果项目比较复杂，可以使用 <code>@Lazy</code> 解决一部分循环依赖的问题。</p><h2 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h2><ul><li><p>==REST==（Representational State Transfer），表现形式状态转换,它是一种<strong>软件架构==风格==</strong></p><p>当我们想表示一个网络资源的时候，可以使用两种方式:</p><ul><li>传统风格资源描述形式<ul><li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li><li><code>http://localhost/user/saveUser</code> 保存用户信息</li></ul></li><li>REST风格描述形式<ul><li><code>http://localhost/user/1</code> </li><li><code>http://localhost/user</code></li></ul></li></ul></li></ul><p>传统方式一般是一个请求url对应一种操作，这样做不仅麻烦，也不安全。查看REST风格的描述，你会发现请求地址变的简单了，并且光看请求URL并不是很能猜出来该URL的具体功能</p><p>所以REST的优点有:</p><ul><li><strong>隐藏资源的访问行为</strong>，无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul><p>根据REST风格对资源进行访问称为==RESTful==。</p><h3 id="传递路径参数"><a href="#传递路径参数" class="headerlink" title="传递路径参数"></a>传递路径参数</h3><p>前端发送请求的时候使用:<code>http://localhost/users/1</code>,路径中的<code>1</code>就是我们想要传递的参数。</p><p>后端获取参数，需要做如下修改:</p><ul><li>修改@RequestMapping的value属性，将其中修改为<code>/users/{id}</code>，目的是和路径匹配</li><li>在方法的形参前添加@PathVariable注解：绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应</li></ul><img src="/2024/05/21/ssm/1630506231379.png" alt="1630506231379" style="zoom:80%;"><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token comment">//设置当前请求方法为PUT，表示REST风格中的修改操作</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/users"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">PUT</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user update..."</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'user update'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>将请求路径更改为<code>/users</code></p><ul><li>访问该方法使用 PUT: <code>http://localhost/users</code></li></ul></li><li><p>访问并携带参数:</p><img src="/2024/05/21/ssm/1630506507096.png" alt="1630506507096" style="zoom:80%;"></li></ul><p>关于接收参数，我们学过三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>,这三个注解之间的区别和应用分别是什么?</p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h3 id="RESTful快速开发"><a href="#RESTful快速开发" class="headerlink" title="RESTful快速开发"></a>RESTful快速开发</h3><p>做完了RESTful的开发，你会发现==好麻烦==，麻烦在哪?</p><img src="/2024/05/21/ssm/1630507339724.png" alt="1630507339724" style="zoom:80%;"><p>问题1：每个方法的@RequestMapping注解中都定义了访问路径/books，重复性太高。</p><p>问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。</p><p>问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。</p><p>对于上面所提的这三个问题，具体该如何解决?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span> <span class="token comment">// 设置当前控制器类为RESTful风格，等价于@Controller + ReponseBody</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">)</span><span class="token comment">// 将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookController</span> <span class="token punctuation">{</span>    <span class="token comment">//@RequestMapping(method = RequestMethod.POST)</span>    <span class="token annotation punctuation">@PostMapping</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book save..."</span> <span class="token operator">+</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book save'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(value = "/{id}",method = RequestMethod.DELETE)</span>    <span class="token comment">// 使用@GetMapping  @PostMapping  @PutMapping  @DeleteMapping代替requestmapping</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book delete..."</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book delete'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(method = RequestMethod.PUT)</span>    <span class="token annotation punctuation">@PutMapping</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book update..."</span> <span class="token operator">+</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book update'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(value = "/{id}",method = RequestMethod.GET)</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book getById..."</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book getById'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//@RequestMapping(method = RequestMethod.GET)</span>    <span class="token annotation punctuation">@GetMapping</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book getAll..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"{'module':'book getAll'}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h3><p>分模块开发：将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享。</p><img src="/2024/05/21/ssm/1630768869208.png" alt="1630768869208" style="zoom: 50%;"><p>对于项目的拆分，大致会有如下几个步骤:</p><p>(1) 创建Maven模块</p><p>(2) 书写模块代码：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。拆分方式可以按照功能拆也可以按照模块拆。</p><p>(3)通过maven指令安装模块到本地仓库(install 指令)，在不同模块间引入依赖</p><p>团队内部开发需要发布模块功能到团队内部可共享的仓库中(私服)</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>依赖是具有传递性的:</p><img src="/2024/05/21/ssm/1630853726532.png" alt="1630853726532" style="zoom: 50%;"><p>**说明:**A代表自己的项目；B,C,D,E,F,G代表的是项目所依赖的jar包；D1和D2 E1和E2代表是相同jar包的不同版本</p><p>(1) A依赖了B和C,B和C有分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递</p><p>(2) 依赖传递有直接依赖和间接依赖</p><ul><li>相对于A来说，A直接依赖B和C,间接依赖了D1,E1,G，F,D2和E2</li><li>相对于B来说，B直接依赖了D1和E1,间接依赖了G</li><li>直接依赖和间接依赖是一个相对的概念</li></ul><p>(3)因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题，Maven是如何解决冲突的?</p><p>如果想避免传递依赖：</p><p><strong>方案1-可选依赖</strong>：可选依赖指对外隐藏当前所依赖的资源—不透明<optional>true</optional></p><p><strong>方案2-排除依赖</strong>：排除依赖指主动断开依赖的资源，被排除的资源无需指定版本—不需要</p><h3 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h3><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li>所谓聚合：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的”空”工程（有且仅有一个pom文件）</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建<ul><li>当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。</li></ul></li></ul><p>聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>所谓继承：描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</li><li>作用：简化配置；减少版本冲突</li></ul><p>步骤1:创建一个空的Maven项目并将其打包方式设置为pom</p><p>步骤2:在子项目中设置其父工程</p><p>步骤3:优化子项目共有依赖导入问题（将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中）</p><p>步骤4:优化子项目依赖版本问题</p><p><strong>父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</strong>。</p><p>聚合和继承的作用:</p><ul><li>聚合用于快速构建项目，对项目进行管理</li><li>继承用于快速配置和管理子项目中所使用jar包的版本</li></ul><p>聚合和继承的相同点:</p><ul><li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>聚合与继承均属于设计型模块，并无实际的模块内容</li></ul><p>聚合和继承的不同点:</p><ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul><h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3><ul><li><p>父工程中定义多环境</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profiles</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>环境名称<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">&gt;</span></span>value<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activation</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activation</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">&gt;</span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profiles</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用多环境(构建过程)</p><pre class="line-numbers language-none"><code class="language-none">mvn 指令 -P 环境定义ID[环境定义中获取]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p><code>SpringBoot</code> 是由Pivotal团队提供的全新框架，其设计目的是用来==简化==Spring应用的==初始搭建==以及==开发过程==。</p><p>原始 <code>Spring</code> 环境搭建和开发存在以下问题：</p><ul><li>配置繁琐</li><li>依赖设置繁琐</li></ul><p><code>SpringBoot</code> 程序优点恰巧就是针对 <code>Spring</code> 的缺点</p><ul><li>自动配置。这个是用来解决 <code>Spring</code> 程序配置繁琐的问题</li><li>起步依赖。这个是用来解决 <code>Spring</code> 程序依赖设置繁琐的问题</li><li>辅助功能（内置服务器,…）。我们在启动 <code>SpringBoot</code> 程序时既没有使用本地的 <code>tomcat</code> 也没有使用 <code>tomcat</code> 插件，而是使用 <code>SpringBoot</code> 内置的服务器。</li></ul><img src="/2024/05/21/ssm/image-20210911172200292.png" alt="image-20210911172200292" style="zoom:80%;"><h3 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h3><p>我们使用 <code>Spring Initializr</code>  方式创建的 <code>Maven</code> 工程的的 <code>pom.xml</code> 配置文件中自动生成了很多包含 <code>spring-boot-starter</code> 的依赖，如下图</p><img src="/2024/05/21/ssm/image-20210918220338109.png" alt="image-20210918220338109" style="zoom: 80%;"><p>从上面的文件中可以看到指定了一个父工程，我们进入到父工程，发现父工程中又指定了一个父工程，如下图所示</p><img src="/2024/05/21/ssm/image-20210918220855024.png" alt="image-20210918220855024" style="zoom:80%;"><p>再进入到该父工程中，在该工程中我们可以看到配置内容结构如下图所示</p><img src="/2024/05/21/ssm/image-20210918221042947.png" alt="image-20210918221042947" style="zoom:80%;"><p>在 <code>properties</code> 中我们找 <code>servlet</code>  和 <code>mysql</code> 的版本如下图</p><img src="/2024/05/21/ssm/image-20210918221511249.png" alt="image-20210918221511249" style="zoom:80%;"><blockquote><p>上图中的 <code>properties</code> 标签中定义了各个技术软件依赖的版本，避免了我们在使用不同软件技术时考虑版本的兼容问题。</p><p><code>dependencyManagement</code> 标签是进行依赖版本锁定，但是并没有导入对应的依赖；如果我们工程需要那个依赖只需要引入依赖的 <code>groupid</code> 和 <code>artifactId</code> 不需要定义 <code>version</code>。</p></blockquote><p>而 <code>build</code> 标签中也对插件的版本进行了锁定，如下图</p><img src="/2024/05/21/ssm/image-20210918221942453.png" alt="image-20210918221942453" style="zoom:80%;"><p>看完了父工程中 <code>pom.xml</code> 的配置后不难理解我们工程的的依赖为什么都没有配置 <code>version</code>。</p><p>在我们创建的工程中的 <code>pom.xml</code> 中配置了如下依赖</p><img src="/2024/05/21/ssm/image-20210918222321402.png" alt="image-20210918222321402" style="zoom:80%;"><p>进入到该依赖，查看 <code>pom.xml</code> 的依赖会发现它引入了如下的依赖</p><img src="/2024/05/21/ssm/image-20210918222607469.png" alt="image-20210918222607469" style="zoom:80%;"><p>里面引入了 <code>spring-web</code> 和 <code>spring-webmvc</code> 的依赖，这就是为什么我们的工程中没有依赖这两个包还能正常使用 <code>springMVC</code> 中的注解的原因。</p><p>而依赖 <code>spring-boot-starter-tomcat</code> ，从名字基本能确认内部依赖了 <code>tomcat</code>，所以我们的工程才能正常启动。</p><p>==结论：以后需要使用技术，只需要引入该技术对应的起步依赖即可==</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><a href="https://blog.csdn.net/dreamstar613/article/details/90265078">https://blog.csdn.net/dreamstar613/article/details/90265078</a></p><img src="/2024/05/21/ssm/image-20240531092335394.png" alt="image-20240531092335394" style="zoom:80%;"><h2 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h2><p>MybatisPlus(简称MP)是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提供效率。</p><p>MP是MyBatis的一套增强工具，它是在MyBatis的基础上进行开发的，我们虽然使用MP但是底层依然是MyBatis的东西，也就是说我们也可以在MP中写MyBatis的内容。</p><p>官方文档：<a href="https://baomidou.com/introduce/">https://baomidou.com/introduce/</a></p><p>MP的特性:</p><ul><li>无侵入：只做增强不做改变，引入它不会对现有工程产生影响。</li><li>损耗小：启动即会自动注入基本CURD，性能基本无损耗，直接面向对象操作。</li><li>强大的CRUD操作：内置通用Mapper、通用Service，仅仅通过少量配置即可实现单表大部分CRUD操作，更有强大的条件构造器，满足各类使用需求。</li><li>支持Lambda形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错。</li><li>支持主键自动生成：支持多达4种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题。</li><li><strong>支持ActiveRecord模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作。</li><li>支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）。</li><li>内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎。</li><li>内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询。分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库。</li><li>内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询。</li><li>内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作。</li></ul><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>Lombok常见的注解有:</p><ul><li>@Setter:为模型类的属性提供setter方法</li><li>@Getter:为模型类的属性提供getter方法</li><li>@ToString:为模型类的属性提供toString方法</li><li>@EqualsAndHashCode:为模型类的属性提供equals和hashcode方法</li><li><strong>==@Data:是个组合注解，包含上面的注解的功能==</strong></li><li>==@NoArgsConstructor:提供一个无参构造函数==</li><li>==@AllArgsConstructor:提供一个包含所有参数的构造函数==</li></ul><h3 id="标准数据层开发"><a href="#标准数据层开发" class="headerlink" title="标准数据层开发"></a>标准数据层开发</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 插入一条记录</span><span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 entity 条件，删除记录</span><span class="token keyword">int</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除（根据ID 批量删除）</span><span class="token keyword">int</span> <span class="token function">deleteBatchIds</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">COLLECTION</span><span class="token punctuation">)</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> idList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 ID 删除，传入id</span><span class="token keyword">int</span> <span class="token function">deleteById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 columnMap 条件，删除记录</span><span class="token keyword">int</span> <span class="token function">deleteByMap</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">COLUMN_MAP</span><span class="token punctuation">)</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 whereEntity 条件，更新记录</span><span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">ENTITY</span><span class="token punctuation">)</span> <span class="token class-name">T</span> entity<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> updateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据 ID 修改，传入的是entity</span><span class="token keyword">int</span> <span class="token function">updateById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">ENTITY</span><span class="token punctuation">)</span> <span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据条件，查询记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectList</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 查询，传入id</span><span class="token class-name">T</span> <span class="token function">selectById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span> <span class="token comment">// 查询（根据 columnMap 条件）</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectByMap</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">COLUMN_MAP</span><span class="token punctuation">)</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectMaps</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录。注意： 只返回第一个字段的值</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectObjs</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录（并分页）</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectPage</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询全部记录（并分页）</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectMapsPage</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据条件，查询总记录数</span><span class="token class-name">Integer</span> <span class="token function">selectCount</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span><span class="token constant">WRAPPER</span><span class="token punctuation">)</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DQL编程"><a href="#DQL编程" class="headerlink" title="DQL编程"></a>DQL编程</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">Mybatisplus02DqlApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testGetAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 模拟页面传递过来的查询数据</span>        <span class="token class-name">UserQuery</span> uq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        uq<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        uq<span class="token punctuation">.</span><span class="token function">setAge2</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">LambdaQueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> lqw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LambdaQueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查询指定字段，对应语句 SELECT id,name,age FROM user</span>        lqw<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果前端传来的age2属性不为空，则添加 where age &lt; xx 的条件</span>        <span class="token comment">// 类名::方法名的lambda表达式获取查询条件，避免自己写"age"出错</span>        lqw<span class="token punctuation">.</span><span class="token function">lt</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">!=</span>uq<span class="token punctuation">.</span><span class="token function">getAge2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">,</span> uq<span class="token punctuation">.</span><span class="token function">getAge2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lqw<span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">!=</span>uq<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">,</span> uq<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 聚合和分组查询，不能用lambda</span>        lqw<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"count(*) as count,tel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lqw<span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span><span class="token string">"tel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/**         * condition ：条件，返回boolean，         当condition为true，进行排序，如果为false，则不排序         * isAsc:是否为升序，true为升序，false为降序         * columns：需要操作的列，这里是按id降序         */</span>        lqw<span class="token punctuation">.</span><span class="token function">orderBy</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> userList <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>lqw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MP只是对MyBatis的增强，如果MP实现不了，我们可以直接在DAO接口中使用MyBatis的方式实现</p><h3 id="映射兼容"><a href="#映射兼容" class="headerlink" title="映射兼容"></a>映射兼容</h3><p><strong>问题1:表字段与编码属性设计不同步</strong></p><p>当表的列名和模型类的属性名发生不一致，就会导致数据封装不到模型对象。</p><p>MP给我们提供了一个注解<code>@TableField</code>,使用该注解可以实现<strong>模型类属性名和表的列名之间的映射</strong>关系</p><p><strong>问题2:编码中添加了数据库中未定义的属性</strong></p><p>当模型类中多了一个数据库表不存在的字段，就会导致生成的sql语句中在select的时候查询了数据库不存在的字段，程序运行就会报错，错误信息为:  ==Unknown column ‘多出来的字段名称’ in ‘field list’==</p><p>具体的解决方案用到的还是<code>@TableField</code>注解，它有一个属性叫<code>exist</code>，设置该字段是否在数据库表中存在，如果设置为false则不存在，生成sql语句查询的时候，就不会再查询该字段了。</p><p><strong>问题3：采用默认查询开放了更多的字段查看权限</strong></p><p>查询表中所有的列的数据，就可能把一些敏感数据查询到返回给前端，这个时候我们就需要<strong>限制哪些字段默认不要进行查询</strong>。解决方案是<code>@TableField</code>注解的一个属性叫<code>select</code>，该属性设置默认是否需要查询该字段的值，true(默认值)表示默认查询该字段，false表示默认不查询该字段。</p><p><strong>问题4:表名与编码开发设计不同步</strong></p><p>该问题主要是表的名称和模型类的名称不一致，导致查询失败，这个时候通常会报如下错误信息:==Table ‘databaseName.tableNaem’ doesn’t exist==,翻译过来就是数据库中的表不存在。解决方案是使用MP提供的另外一个注解<code>@TableName</code>来设置表与模型类之间的对应关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@TableName</span><span class="token punctuation">(</span><span class="token string">"tbl_user"</span><span class="token punctuation">)</span><span class="token comment">// 映射数据库名</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"pwd"</span><span class="token punctuation">,</span>select<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">// 映射数据库表字段pwd，默认不要查询</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> tel<span class="token punctuation">;</span>    <span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>exist<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">// 表中不存在的字段</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> online<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DML编程"><a href="#DML编程" class="headerlink" title="DML编程"></a>DML编程</h3><h4 id="id生成"><a href="#id生成" class="headerlink" title="id生成"></a>id生成</h4><table><thead><tr><th>名称</th><th>@TableId</th></tr></thead><tbody><tr><td>类型</td><td>==属性注解==</td></tr><tr><td>位置</td><td>模型类中用于表示主键的属性定义上方</td></tr><tr><td>作用</td><td>设置当前类中主键属性的生成策略</td></tr><tr><td>相关属性</td><td>value(默认)：设置数据库表主键名称<br>type:设置主键属性的生成策略，值查照IdType的枚举值</td></tr></tbody></table><p> @TableId(type = IdType.AUTO) – 自增</p><ul><li>NONE: 不设置id生成策略</li><li>INPUT:用户手工输入id</li><li>ASSIGN_ID:雪花算法生成id(可兼容数值型与字符串型)</li><li>ASSIGN_UUID:以UUID生成算法作为id生成策略</li><li>其他的几个策略均已过时，都将被ASSIGN_ID和ASSIGN_UUID代替掉。</li></ul><p>对比：</p><ul><li>NONE: 不设置id生成策略，MP不自动生成，约等于INPUT,所以这两种方式都需要用户手动设置，但是手动设置第一个问题是容易出现相同的ID造成主键冲突，为了保证主键不冲突就需要做很多判定，实现起来比较复杂</li><li>AUTO:数据库ID自增,这种策略适合在数据库服务器只有1台的情况下使用,不可作为分布式ID使用</li><li>ASSIGN_UUID:可以在分布式的情况下使用，而且能够保证唯一，但是生成的主键是32位的字符串，长度过长占用空间而且还不能排序，查询性能也慢</li><li>ASSIGN_ID:可以在分布式的情况下使用，生成的是Long类型的数字，可以排序性能也高，但是生成的策略和服务器时间有关，如果修改了系统时间就有可能导致出现重复主键</li></ul><h4 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h4><p><strong>模型类主键策略设置</strong></p><p>对于主键ID的策略已经介绍完，但是如果要在项目中的每一个模型类上都需要使用相同的生成策略，如：</p><img src="/2024/05/21/ssm/1631245676125-1717399291442.png" alt="1631245676125" style="zoom:80%;"><p>确实是稍微有点繁琐，我们能不能在某一处进行配置，就能让所有的模型类都可以使用该主键ID策略呢?</p><p>答案是肯定有，我们只需要在配置文件中添加如下内容:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>    <span class="token key atrule">id-type</span><span class="token punctuation">:</span> assign_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成后，每个模型类的主键ID策略都将成为assign_id.</p><p><strong>数据库表与模型类的映射关系</strong></p><p>MP会默认将模型类的类名名首字母小写作为表名使用，假如数据库表的名称都以<code>tbl_</code>开头，那么我们就需要将所有的模型类上添加<code>@TableName</code>，如:</p><img src="/2024/05/21/ssm/1631245757169-1717399327044.png" alt="1631245757169" style="zoom:80%;"><p>配置起来还是比较繁琐，简化方式为在配置文件中配置如下内容:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>    <span class="token key atrule">table-prefix</span><span class="token punctuation">:</span> tbl_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置表的前缀内容，这样MP就会拿 <code>tbl_</code>加上模型类的首字母小写，就刚好组装成数据库的表名。</p><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><p><strong>@TableLogic</strong></p><table><thead><tr><th>名称</th><th>@TableLogic</th></tr></thead><tbody><tr><td>类型</td><td>==属性注解==</td></tr><tr><td>位置</td><td>模型类中用于表示删除字段的属性定义上方</td></tr><tr><td>作用</td><td>标识该字段为进行逻辑删除的字段</td></tr><tr><td>相关属性</td><td>value：逻辑未删除值<br>delval:逻辑删除值</td></tr></tbody></table><h3 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h3><h4 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>com<span class="token punctuation">.</span>baomidou<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>mybatis<span class="token operator">-</span>plus<span class="token operator">-</span>generator<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">3.5</span><span class="token number">.6</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于代码生成器用到了模板引擎，请自行引入您喜好的模板引擎。MyBatis-Plus Generator 支持如下模板引擎：</p><ul><li>VelocityTemplateEngine(Default)</li><li>FreemarkerTemplateEngine</li><li>BeetlTemplateEngine</li><li>EnjoyTemplateEngine</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>velocity<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>velocity<span class="token operator">-</span>engine<span class="token operator">-</span>core<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">2.3</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码生成类"><a href="#代码生成类" class="headerlink" title="代码生成类"></a>代码生成类</h5><p>在 CodeGenerator 中的 main 方法中直接添加生成器代码，并进行相关配置，然后直接运行即可生成代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">FastAutoGenerator</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">,</span> <span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">)</span>        <span class="token comment">// 全局配置</span>            <span class="token punctuation">.</span><span class="token function">globalConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                builder<span class="token punctuation">.</span><span class="token function">author</span><span class="token punctuation">(</span><span class="token string">"baomidou"</span><span class="token punctuation">)</span> <span class="token comment">// 设置作者</span>                        <span class="token punctuation">.</span><span class="token function">enableSwagger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 开启 swagger 模式</span>                        <span class="token punctuation">.</span><span class="token function">outputDir</span><span class="token punctuation">(</span><span class="token string">"D://"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指定输出目录</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token comment">// 数据源配置</span>            <span class="token punctuation">.</span><span class="token function">dataSourceConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span>                    builder<span class="token punctuation">.</span><span class="token function">typeConvertHandler</span><span class="token punctuation">(</span><span class="token punctuation">(</span>globalConfig<span class="token punctuation">,</span> typeRegistry<span class="token punctuation">,</span> metaInfo<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> typeCode <span class="token operator">=</span> metaInfo<span class="token punctuation">.</span><span class="token function">getJdbcType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token constant">TYPE_CODE</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>typeCode <span class="token operator">==</span> <span class="token class-name">Types</span><span class="token punctuation">.</span><span class="token constant">SMALLINT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment">// 自定义类型转换</span>                            <span class="token keyword">return</span> <span class="token class-name">DbColumnType</span><span class="token punctuation">.</span><span class="token constant">INTEGER</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">return</span> typeRegistry<span class="token punctuation">.</span><span class="token function">getColumnType</span><span class="token punctuation">(</span>metaInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token comment">// 包配置</span>            <span class="token punctuation">.</span><span class="token function">packageConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span>                    builder<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token string">"com.baomidou.mybatisplus.samples.generator"</span><span class="token punctuation">)</span> <span class="token comment">// 设置父包名</span>                            <span class="token punctuation">.</span><span class="token function">moduleName</span><span class="token punctuation">(</span><span class="token string">"system"</span><span class="token punctuation">)</span> <span class="token comment">// 设置父包模块名</span>                            <span class="token punctuation">.</span><span class="token function">pathInfo</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonMap</span><span class="token punctuation">(</span><span class="token class-name">OutputFile</span><span class="token punctuation">.</span>xml<span class="token punctuation">,</span> <span class="token string">"D://"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 设置mapperXml生成路径</span>            <span class="token punctuation">)</span>        <span class="token comment">// 策略配置</span>            <span class="token punctuation">.</span><span class="token function">strategyConfig</span><span class="token punctuation">(</span>builder <span class="token operator">-&gt;</span>                    builder<span class="token punctuation">.</span><span class="token function">addInclude</span><span class="token punctuation">(</span><span class="token string">"t_simple"</span><span class="token punctuation">)</span> <span class="token comment">// 设置需要生成的表名</span>                            <span class="token punctuation">.</span><span class="token function">addTablePrefix</span><span class="token punctuation">(</span><span class="token string">"t_"</span><span class="token punctuation">,</span> <span class="token string">"c_"</span><span class="token punctuation">)</span> <span class="token comment">// 设置过滤表前缀</span>            <span class="token punctuation">)</span>        <span class="token comment">// 模板引擎</span>            <span class="token punctuation">.</span><span class="token function">templateEngine</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FreemarkerTemplateEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 使用Freemarker引擎模板，默认的是Velocity引擎模板</span>            <span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Service-Interface"><a href="#Service-Interface" class="headerlink" title="Service Interface"></a>Service Interface</h3><p>IService是 MyBatis-Plus 提供的一个通用 Service 层接口，它封装了常见的 CRUD 操作，包括插入、删除、查询和分页等。通过继承 IService 接口，可以快速实现对数据库的基本操作，同时保持代码的简洁性和可维护性。</p><p><strong>IService 接口中的方法命名遵循了一定的规范，如 get 用于查询单行，remove 用于删除，list 用于查询集合，page 用于分页查询，这样可以避免与 Mapper 层的方法混淆。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token keyword">extends</span> <span class="token class-name">IService</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserDao</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 插入一条记录（选择字段，策略插入）</span><span class="token keyword">boolean</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 插入（批量）</span><span class="token keyword">boolean</span> <span class="token function">saveBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 插入（批量）</span><span class="token keyword">boolean</span> <span class="token function">saveBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">,</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*  根据实体对象的主键 ID 进行判断，存在则更新记录，否则插入记录。 */</span><span class="token comment">// TableId 注解属性值存在则更新记录，否则插入一条记录</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdate</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据updateWrapper尝试更新，否则继续执行saveOrUpdate(T)方法</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdate</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> updateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 批量修改插入</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdateBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 批量修改插入</span><span class="token keyword">boolean</span> <span class="token function">saveOrUpdateBatch</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">,</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 queryWrapper 设置的条件，删除记录</span><span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 删除</span><span class="token keyword">boolean</span> <span class="token function">removeById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 columnMap 条件，删除记录</span><span class="token keyword">boolean</span> <span class="token function">removeByMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 删除（根据ID 批量删除）</span><span class="token keyword">boolean</span> <span class="token function">removeByIds</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> idList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span><span class="token keyword">boolean</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> updateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 whereWrapper 条件，更新记录</span><span class="token keyword">boolean</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">T</span> updateEntity<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> whereWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 选择修改</span><span class="token keyword">boolean</span> <span class="token function">updateById</span><span class="token punctuation">(</span><span class="token class-name">T</span> entity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据ID 批量更新</span><span class="token keyword">boolean</span> <span class="token function">updateBatchById</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据ID 批量更新</span><span class="token keyword">boolean</span> <span class="token function">updateBatchById</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> entityList<span class="token punctuation">,</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 ID 查询</span><span class="token class-name">T</span> <span class="token function">getById</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last("LIMIT 1")</span><span class="token class-name">T</span> <span class="token function">getOne</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录</span><span class="token class-name">T</span> <span class="token function">getOne</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">,</span> <span class="token keyword">boolean</span> throwEx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper，查询一条记录</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">V</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询所有</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询列表</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询（根据ID 批量查询）</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">listByIds</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> idList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询（根据 columnMap 条件）</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">listByMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> columnMap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询所有列表</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">listMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询列表</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">listMaps</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询全部记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询全部记录</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询全部记录</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询全部记录</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">listObjs</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 无条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">page</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">page</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 无条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">pageMaps</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 条件分页查询</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">pageMaps</span><span class="token punctuation">(</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> page<span class="token punctuation">,</span> <span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查询总记录数</span><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询总记录数</span><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自3.4.3.2开始,返回值修改为long</span><span class="token comment">// 查询总记录数</span><span class="token keyword">long</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 Wrapper 条件，查询总记录数</span><span class="token keyword">long</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token class-name">Wrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员SSM：<a href="https://www.bilibili.com/video/BV1Fi4y1S7ix/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1Fi4y1S7ix/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>JavaGuide：<a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></p><p>spring中BeanFactory和FactoryBean的区别：<a href="https://blog.csdn.net/dongyang2019/article/details/113725058">https://blog.csdn.net/dongyang2019/article/details/113725058</a></p><p>Nan-ying’s blog：<a href="https://nan-ying.github.io/2023/07/10/Spring/#%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A6%82%E5%BF%B5">https://nan-ying.github.io/2023/07/10/Spring/#%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A6%82%E5%BF%B5</a></p><p>牛客高启盛同学资料：<a href="https://github.com/viego1999/JavaWxy">https://github.com/viego1999/JavaWxy</a></p><p>MybatisPlus官方文档：<a href="https://baomidou.com/guides/data-interface/">https://baomidou.com/guides/data-interface/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSM&quot;&gt;&lt;a href=&quot;#SSM&quot; class=&quot;headerlink&quot; title=&quot;SSM&quot;&gt;&lt;/a&gt;SSM&lt;/h1&gt;&lt;h2 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="后端" scheme="http://wolf-ll.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="框架" scheme="http://wolf-ll.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>黑马点评</title>
    <link href="http://wolf-ll.github.io/2024/05/13/hei-ma-dian-ping/"/>
    <id>http://wolf-ll.github.io/2024/05/13/hei-ma-dian-ping/</id>
    <published>2024-05-13T12:04:03.000Z</published>
    <updated>2024-10-28T11:51:08.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h1><h2 id="MySQL表"><a href="#MySQL表" class="headerlink" title="MySQL表"></a>MySQL表</h2><ul><li>tb_user：用户表</li><li>tb_user_info：用户详情表</li><li>tb_shop：商户信息表</li><li>tb_shop_type：商户类型表</li><li>tb_blog：用户日记表（达人探店日记）</li><li>tb_follow：用户关注表</li><li>tb_voucher：优惠券表</li><li>tb_voucher_order：优惠券的订单表</li></ul><h2 id="当前模型"><a href="#当前模型" class="headerlink" title="当前模型"></a>当前模型</h2><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的是HTTP协议，可以实现<strong>基于Lua直接绕开tomcat访问redis</strong>，也可以作为<strong>静态资源服务器</strong>，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p><p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们<strong>在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群对外提供更好的服务。</strong></p><h2 id="用户鉴权"><a href="#用户鉴权" class="headerlink" title="用户鉴权"></a>用户鉴权</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>cookie 是一个非常具体的东西，指的就是<strong>浏览器里面能永久存储</strong>的一种数据，仅仅是浏览器实现的一种数据存储功能。</p><p>cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。</p><p>由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p><p><strong>Cookie 技术主要用于：</strong></p><ul><li>身份验证：保存用户登录状态，实现持久登录。</li><li>会话管理：追踪用户的会话信息，例如购物车内容。</li><li>个性化设置：存储用户偏好设置，以提供个性化的用户体验。</li></ul><p>Cookie 的相关操作和属性可以通过 JavaScript 的 document.cookie 对象进行访问和修改。可以设置 Cookie 的<strong>过期时间、作用域、路径</strong>等属性，以控制其有效性和访问范围。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session（会话）是一种<strong>在服务器端存储用户状态和数据的机制</strong>。它通过在服务器端创建一个唯一的会话标识（通常是一个 Session ID），并将该标识发送给客户端，实现在不同的请求中跟踪和管理用户的状态。</p><p>当用户访问一个网站时，服务器会为该用户创建一个会话，并将会话 ID 存储在 Cookie 中，或者通过其他方式将其发送给客户端。客户端的浏览器会自动在后续的请求中<strong>将会话 ID 发送给服务器，在服务器端找到对应的会话数据。</strong></p><p>会话数据存储在服务器端的临时存储区域，通常是在服务器的内存中或在数据库中。服务器会根据会话 ID 来检索和更新相应的数据，从而实现用户状态的管理和维护。</p><p><strong>Session 技术的主要作用：</strong></p><ul><li>身份验证：存储用户登录信息和权限，实现用户认证。</li><li>会话管理：追踪用户的操作和活动，在请求之间保持连续性。</li><li>数据存储：存储用户数据，例如购物车、表单数据等。</li></ul><p>需要注意的是，为了保护用户数据的安全性和隐私，开发人员应采取适当的安全措施：</p><ul><li>使用安全的传输协议（如 HTTPS）来保护会话数据在网络传输中的安全性。</li><li>针对会话 ID 的保护，包括生成安全的随机会话 ID、设置合适的过期时间，以及通过 HttpOnly 和 Secure 标志来防止跨站脚本攻击和会话劫持。</li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>Token（令牌）是一种<strong>在身份验证和授权中使用的字符串</strong>，用于验证客户端的身份和权限。它作为客户端和服务器之间进行安全通信的一种方式，来确保用户的身份和访问权限。</p><p>Token 的主要特点是它是<strong>无状态</strong>的，<strong>即服务器不需要在存储设备中维护任何信息</strong>。服务器在生成 Token 后，将其发送给客户端，客户端在以后的请求中将 Token 作为身份凭证发送给服务器。服务器通过验证 Token 的有效性，来确认客户端的身份和权限。</p><p>Token 的生成和验证过程一般包含以下步骤：</p><ul><li>客户端向服务器发送身份验证请求，通常是提供用户名和密码。</li><li>服务器验证客户端提供的身份信息，并生成一个 Token。</li><li>服务器将生成的 Token 发送给客户端，客户端将其保存。</li><li>客户端在以后的请求中将 Token 添加到请求头中，作为身份凭证。</li><li>服务器在接收到请求时，验证 Token 的有效性和权限，并相应地处理请求。</li></ul><p><strong>Token 的主要作用：</strong></p><ul><li>身份验证：通过 Token 来验证客户端的身份，替代传统的基于会话的身份验证机制，不需要在服务器端存储会话信息，减轻服务器的负担。</li><li>授权：服务器可以根据 Token 中的信息来判断客户端的权限，决定是否允许相应的操作。</li><li>单点登录（SSO）：Token 可以在不同的应用程序之间共享，实现用户的单点登录功能。</li></ul><p>Token 可以有不同的类型和格式，常见的包括 JSON Web Token（JWT）、OAuth 2.0 的访问令牌等。同时，Token 也可以通过加密和签名等方式来保证其安全性。</p><h2 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h2><h3 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h3><blockquote><p>1、用户提交手机号<br>2、校验手机号是否合法<br>3、生成验证码<br>4、将生成的验证码保存到session中，用于后续的验证<br>5、发送验证码给用户</p></blockquote><p><strong>接口地址</strong>:<code>/user/code</code></p><p><strong>请求方式</strong>:<code>POST</code></p><p><strong>请求数据类型</strong>:<code>application/json</code></p><p><strong>请求参数</strong>:</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>请求类型</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>phone</td><td></td><td>query</td><td>true</td><td>string</td><td></td></tr><tr><td>session</td><td></td><td>query</td><td>true</td><td>HttpSession</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">{</span><span class="token string-property property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string-property property">"errorMsg"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token string-property property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token string-property property">"total"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="登录-注册"><a href="#登录-注册" class="headerlink" title="登录/注册"></a>登录/注册</h3><blockquote><p>1、提交手机号和验证码<br>2、校验验证码<br>3、根据手机号查询数据库信息<br>4、用户存在就保存到session，否则就创建新用户并保存到数据库，最后也保存到session中</p></blockquote><p><strong>接口地址</strong>:<code>/user/login</code></p><p><strong>请求方式</strong>:<code>POST</code></p><p><strong>请求数据类型</strong>:<code>application/json</code></p><p><strong>请求参数</strong>:</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>请求类型</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>loginForm</td><td>loginForm</td><td>body</td><td>true</td><td>LoginFormDTO</td><td>LoginFormDTO</td></tr><tr><td>  code</td><td></td><td></td><td>false</td><td>string</td><td></td></tr><tr><td>  password</td><td></td><td></td><td>false</td><td>string</td><td></td></tr><tr><td>  phone</td><td></td><td></td><td>false</td><td>string</td><td></td></tr><tr><td>session</td><td></td><td>query</td><td>true</td><td>HttpSession</td><td></td></tr></tbody></table><h3 id="校验登录状态-拦截器"><a href="#校验登录状态-拦截器" class="headerlink" title="校验登录状态-拦截器"></a>校验登录状态-拦截器</h3><p>首先我们要知道怎么基于session进行校验，session是基于cookie的（每一个session的id都会保存到cookie中），当用户访问的时候会携带cookie，所以我们可以根据cookie中的session_id来查询session中是否有这个用户：</p><blockquote><p>1、用户发送请求并携带cookie<br>2、从session中获取用户<br>3、判断用户是否存在：<br>（1）没有这个用户就拦截<br>（2）有这个用户就保存用户信息到ThreadLocal用于登录缓存（ThreadLocal是一个线程域对象，<strong>每一个请求到达服务都会是一个独立线程，直接保存到本地变量会出现并发修改的安全问题，而ThreadLocal会将数据保存到每个线程内部，在线程内部创建一个Map来进行保存</strong>），保存完后就放行该用户即可</p></blockquote><p>基于session校验需要<strong>在跨各种组件和页面的时候都访问session，编写重复的校验代码</strong>，增加了访问session的开销。所以使用ThreadLocal，使得每一个线程只需要访问一次session。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MvcConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoginInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span>   <span class="token comment">// 白名单</span>                        <span class="token string">"/shop/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/shop-type/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/voucher/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/upload/**"</span><span class="token punctuation">,</span>                        <span class="token string">"/blog/hot"</span><span class="token punctuation">,</span>                        <span class="token string">"/user/code"</span><span class="token punctuation">,</span>                        <span class="token string">"/user/login"</span>                <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取客户端请求传进来的session</span>        <span class="token class-name">HttpSession</span> session <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取user</span>        <span class="token class-name">Object</span> user <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 用户不存在，拦截，返回401状态码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 用户存在session中，保存到localthread，放行</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">UserDTO</span><span class="token punctuation">)</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 线程执行后移除用户</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">removeUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="集群的session共享问题"><a href="#集群的session共享问题" class="headerlink" title="集群的session共享问题"></a>集群的session共享问题</h3><p><strong>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同Tomcat服务时导致数据丢失的问题。</strong><br>这是因为我们为了我们将来系统的<strong>高并发性</strong>，就需要<strong>水平拓展，形成负载均衡的集群</strong>，<strong>每个Tomcat都会有一个对应的session。当我们在某一台Tomcat上进行登录以后，第二次登录的时候，要是被负载均衡到了另一台Tomcat，就会造成没办法获得之前登录时的session，就没办法再做验证了。</strong><br>这个问题听起来好像也挺容易解决，如果每台Tomcat都互相拷贝，保存相同的数据，那肯定就不至于发生如上的问题，但是这样的解决方式太浪费空间了，而且拷贝的过程还是比较费时的，如果这时候已经有访问请求，就可能会出现数据不一致的情况。<br>因此，我们的session信息共享的解决方案应该满足以下特点：<br><strong>1、数据共享</strong><br>2、内存存储<br>3、key-value结构<br>这时候我们就回到了Redis了，我们知道Redis是独立于Tomcat的，单独进行存储，且任何一台Tomcat都可以访问到Redis，因此可以实现数据共享</p><h4 id="基于Redis实现共享session"><a href="#基于Redis实现共享session" class="headerlink" title="基于Redis实现共享session"></a>基于Redis实现共享session</h4><h5 id="发送验证码-1"><a href="#发送验证码-1" class="headerlink" title="发送验证码"></a>发送验证码</h5><p>验证码保存到redis中，Redis的结构是key-value的，且value是很多种类型的，在这里我们选择最简单的String类型即可。</p><blockquote><p>一个需要考虑的问题是key的选取，在session中我们选用了“code”来作为key，但在这里却不行。这是因为<strong>每一个不同的浏览器在发送请求的时候都会有一个不同的独立的session，也就是说Tomcat的内部维护了很多的session，互相之间是不会干扰的</strong>。但是Redis是一个共享的内存空间，如果直接使用key会造成<strong>覆盖</strong>，所以我们不能直接选用“code”来作为key。因此我们可以<strong>用手机号作为key（因为同一账号同一时刻仅在一个平台登录）。</strong></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">sendCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> phone<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 校验手机号，正则，不合法则返回错误信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">RegexUtils</span><span class="token punctuation">.</span><span class="token function">isPhoneInvalid</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"手机号格式错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 生成验证码</span>    <span class="token class-name">String</span> code <span class="token operator">=</span> <span class="token class-name">RandomUtil</span><span class="token punctuation">.</span><span class="token function">randomNumbers</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保存验证码到redis，用phone为key，限制有效期5min</span>    <span class="token comment">//        session.setAttribute("code", code);  这个是存到session</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">LOGIN_CODE_KEY</span><span class="token operator">+</span>phone<span class="token punctuation">,</span> code<span class="token punctuation">,</span> <span class="token constant">LOGIN_CODE_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送验证码，调用第三方平台</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"发送验证码："</span> <span class="token operator">+</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="验证码登录与注册"><a href="#验证码登录与注册" class="headerlink" title="验证码登录与注册"></a>验证码登录与注册</h5><p>最终的用户信息不再保存到session中，而是保存都Redis中去了，同样要考虑key跟value的选择：<br>（1）value的选取：我们要保存的是用户的信息，这是一个对象。我们用Hash结构是最合适的。<br>（2）key的选取：这里并不建议用phone作为key，而是<strong>以随机token（服务器生成的令牌）为key来存储用户数据</strong>，因为<strong>这里的token要存到前端，使用手机号为key不安全，容易泄露。</strong></p><p>在之前我们校验登录状态的时候，是从cookie中获取session再得到用户信息，而现在我们校验登录的时候<strong>要访问的凭证就是这个随机token了</strong>，但Tomcat不会将这个token自动写到浏览器上面。所以我们<strong>把数据保存到Redis以后还需要手动的把token返回到前端</strong>，流程就得修改：</p><blockquote><p>1、提交手机号和验证码<br>2、校验验证码<br>3、根据手机号查询用户信息<br>4、<strong>用户保存到Redis</strong><br>5、<strong>返回token给客户端（重要一步）</strong></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">LoginFormDTO</span> loginForm<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> phone <span class="token operator">=</span> loginForm<span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 校验手机号</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">RegexUtils</span><span class="token punctuation">.</span><span class="token function">isPhoneInvalid</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"手机号格式错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 校验验证码，从redis中获取验证码</span>    <span class="token comment">//        Object cacheCode = session.getAttribute("code");</span>    <span class="token class-name">String</span> cacheCode <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">LOGIN_CODE_KEY</span> <span class="token operator">+</span> phone<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> code <span class="token operator">=</span> loginForm<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 不一致，报错</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheCode <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>cacheCode<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"验证码错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 一致，查数据库tb_user</span>    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"phone"</span><span class="token punctuation">,</span> phone<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 不存在，创建新用户</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        user <span class="token operator">=</span> <span class="token function">createUserWithPhone</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 保存用户信息DTO(id，昵称，头像信息)到redis，需要生成token</span>    <span class="token class-name">String</span> token <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">UserDTO</span> userDTO <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token class-name">UserDTO</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将user对象转为map类型，拆分所有字段，以哈希结构存到redis里 -- 对象中的数据类型都应该是string</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> userMap <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">beanToMap</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 将Java对象（Bean）转换为Map类型</span>                                                     <span class="token class-name">CopyOptions</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 对象转换时的配置项</span>                                                     <span class="token punctuation">.</span><span class="token function">setIgnoreNullValue</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>   <span class="token comment">// 是否忽略空值，当源对象的值为null时，true: 忽略而不注入此值，false: 注入null</span>                                                     <span class="token punctuation">.</span><span class="token function">setFieldValueEditor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">,</span> fieldValue<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> fieldValue<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 对转换过程中的字段值进行编辑处理，对象值转为string</span>    <span class="token class-name">String</span> user_token <span class="token operator">=</span> <span class="token constant">LOGIN_USER_KEY</span> <span class="token operator">+</span> token<span class="token punctuation">;</span>    <span class="token comment">// 这里long id直接转string会报错</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>user_token<span class="token punctuation">,</span> userMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置token有效期（超过30分钟没有访问就删除）</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>user_token<span class="token punctuation">,</span> <span class="token constant">LOGIN_USER_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//        session.setAttribute("user", BeanUtil.copyProperties(user, UserDTO.class));</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/05/13/hei-ma-dian-ping/image-20240515164315155.png"><h5 id="校验登录状态"><a href="#校验登录状态" class="headerlink" title="校验登录状态"></a>校验登录状态</h5><p>我们不再是从浏览器中的cookie指定的session来获取用户信息，而是以随机token为key来从Redis中获取信息，流程如下：</p><blockquote><p>1、用户发送请求并<strong>携带token</strong><br>2、从Redis中获取用户（以随机token为key）<br>3、判断用户是否存在：<br>（1）没有这个用户就拦截<br>（2）有这个用户就保存用户信息到ThreadLocal，并放行</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token comment">// 这个拦截器类不是由spring管理的，所以需要手动构造stringRedisTemplate而不能用依赖注入</span>    <span class="token comment">// 通过调用该类的spring类注入stringRedisTemplate，然后传递参数到拦截器来完成构造</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">LoginInterceptor</span><span class="token punctuation">(</span><span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取客户端请求头传进来的token</span>        <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        HttpSession session = request.getSession();</span>        <span class="token comment">// token为空或仅包含空白字符</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 基于token构造redis中存的用户信息的key</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_KEY</span> <span class="token operator">+</span> token<span class="token punctuation">;</span>        <span class="token comment">// 基于token获取redis中存的user</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> userMap <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 用户不存在，拦截，返回401状态码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>userMap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">UserDTO</span> userDTO <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">fillBeanWithMap</span><span class="token punctuation">(</span>userMap<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 用户存在，保存到localthread，放行</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新过期时间 -- 也就是每次访问新的页面，进行拦截器判断，更新过期时间</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 线程执行后移除用户</span>        <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">removeUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="解决状态登录刷新的问题——登录拦截器的优化"><a href="#解决状态登录刷新的问题——登录拦截器的优化" class="headerlink" title="解决状态登录刷新的问题——登录拦截器的优化"></a>解决状态登录刷新的问题——登录拦截器的优化</h5><p>上述代码实现完还有一点小问题，之前的拦截器并不会拦截掉一切路径，而是所有需要登录的路径，那么会出现一个问题：我们的首页并不需要登录就可以直接访问，那么<strong>已经登录过的用户一直在首页进行操作，拦截器中的登录状态并不会刷新，就可能造成明明一直在操作系统，却被视为不算是在登录状态。</strong><br>解决方法是<strong>再加上一个拦截器，用户的请求要先经过这个拦截器，这个拦截器会拦截一切的路径，所以我们可以在这个拦截器里面进行token有效期的刷新操作：</strong></p><blockquote><p>1、获取token<br>2、查询Redis的用户<br>3、保存到ThreadLocal<br>4、刷新token有效期<br>5、放行</p></blockquote><p>这样的话，一切的请求都会触发刷新的操作。那么<strong>之前的拦截器只需要查询ThreadLocal的用户，存在则继续，不存在则拦截。</strong></p><p>新的拦截一切的拦截器做用户校验，存到threadlocal并放行一切：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取客户端请求头传进来的token</span>    <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// token为空或仅包含空白字符，直接放行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 基于token构造redis中存的用户信息的key</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_KEY</span> <span class="token operator">+</span> token<span class="token punctuation">;</span>    <span class="token comment">// 基于key获取redis中存的user</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> userMap <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用户不存在，直接放行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>userMap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">UserDTO</span> userDTO <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">fillBeanWithMap</span><span class="token punctuation">(</span>userMap<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用户存在，保存到localthread，更新放行</span>    <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新过期时间</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">RedisConstants</span><span class="token punctuation">.</span><span class="token constant">LOGIN_USER_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>旧的拦截器只检查threadlocal有没有用户：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token comment">// 在login拦截器中只需要校验threadlocal里面有没有存用户，没有则拦截</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="==商户查询缓存=="></a>==商户查询缓存==</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h3><p>缓存：数据交换的缓冲区（Cache），是<strong>存储数据的临时地方，读写性能高。</strong>俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">例<span class="token number">1</span><span class="token operator">:</span><span class="token class-name">Static</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 本地用于高并发例<span class="token number">2</span><span class="token operator">:</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token constant">USER_CACHE</span> <span class="token operator">=</span> <span class="token class-name">CacheBuilder</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 用于redis等缓存例<span class="token number">3</span><span class="token operator">:</span><span class="token class-name">Static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 本地缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;</p><p>我们的浏览器有浏览器缓存，在浏览器未命中数据，就会在tomcat的应用层缓存中取数据，再没有命中的话就去数据库进行查询检索。<br><strong>缓存的作用：</strong><br>1、降低后端负载<br>2、提高读写效率，降低响应时间<br><strong>缓存的成本：</strong><br>1、数据的一致性成本<br>2、代码维护成本（解决一致性问题的时候带来的代码复杂）<br>3、运维的成本</p><h3 id="商户查询添加缓存"><a href="#商户查询添加缓存" class="headerlink" title="商户查询添加缓存"></a>商户查询添加缓存</h3><p>如果直接查数据库，逻辑是这样的。速度慢</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryShopById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//这里是直接查询数据库</span>    <span class="token keyword">return</span> shopService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改成缓存，用string类型存商户json信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 查缓存，若存在直接返回，不存在就查数据库</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 存在店铺信息，反序列化json为bean对象并返回</span>            <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span>  <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 查数据库</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>shop <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"店铺不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 数据库中存在，将店铺信息序列化为json字符串，存储到redis缓存中</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="商户类型序列缓存"><a href="#商户类型序列缓存" class="headerlink" title="商户类型序列缓存"></a>商户类型序列缓存</h3><p>shopTypeController</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"list"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//        List&lt;ShopType&gt; typeList = typeService</span>    <span class="token comment">//                .query().orderByAsc("sort").list();</span>    <span class="token keyword">return</span> typeService<span class="token punctuation">.</span><span class="token function">queryShopTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shopTypeServiceImpl</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShopTypeServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShopTypeMapper</span><span class="token punctuation">,</span> <span class="token class-name">ShopType</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">IShopTypeService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryShopTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 要返回的商户列表</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShopType</span><span class="token punctuation">&gt;</span></span> typeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 存到redis中的商户类型list，是商户这个类型的json字符串的list集合</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisTypeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查询redis缓存</span>        <span class="token class-name">Long</span> size <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOPTYPE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 缓存有数据就返回</span>            redisTypeList <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOPTYPE_KEY</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 利用stream流和map将string类型的json list转换为bean list</span>            typeList <span class="token operator">=</span> redisTypeList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token class-name">ShopType</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>typeList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 缓存没有，查数据库，存缓存，返回</span>        typeList <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orderByAsc</span><span class="token punctuation">(</span><span class="token string">"sort"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>typeList <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> typeList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"不存在商户类型数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查到的bean list通过stream流转为string list，存到缓存</span>        redisTypeList <span class="token operator">=</span> typeList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>shopType<span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>shopType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPushAll</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOPTYPE_KEY</span><span class="token punctuation">,</span> redisTypeList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>typeList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>上面的作用模型可能会造成数据一致性问题，当我们对数据库进行修改的时候，缓存并没有同步进行修改，页面在缓存中获取数据的时候，其实并不是最新的数据。这肯定是不允许的。</p><p>下面是缓存更新策略：</p><table><thead><tr><th></th><th align="center">内存淘汰</th><th align="center">超时剔除</th><th align="center">主动更新</th></tr></thead><tbody><tr><td>说明</td><td align="center">不用自己维护，利用Redis的内存淘汰机制，<strong>内存不足时自动淘汰部分数据</strong>，下次查询时更新缓存</td><td align="center">给缓存数据添加TTL时间，<strong>到期后自动删除缓存</strong>。下次查询即可实现缓存的更新</td><td align="center">自己编写业务逻辑，在修改数据库的同时，更新缓存</td></tr><tr><td>一致性</td><td align="center">差</td><td align="center">一般</td><td align="center">好</td></tr><tr><td>维护成本</td><td align="center">无</td><td align="center">低</td><td align="center">高</td></tr></tbody></table><p>上述的策略选择要根据具体的业务场景：<br>1、低一致性需求/数据很少更新：使用内存淘汰机制。例如店铺类型的查询缓存。<br>2、高一致性需求：<strong>主动更新，以超时剔除作兜底方案。例如店铺详情查询的缓存。</strong></p><h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p>1、<strong>Cache Aside Pattern（最常用）</strong> – 由缓存的调用者，在更新数据库的同时更新缓存<br>2、<strong>Read/Write Through Pattern</strong> – 缓存与数据库整合为一个<strong>服务</strong>，由服务来维护一致性（调用者不知道服务内部）。调用者调用该服务无需关注一致性问题。但这种服务的成本肯定是很高的。<br>3、<strong>Write Behind Caching Pattern（写回）</strong> – 调用<strong>者只操作缓存</strong>，<strong>由其它线程异步的将缓存数据持久化到数据库</strong>，保证最终一致。<br>比如我们一直对缓存进行更新，更新10次以后轮到这个线程工作，就维护一下数据库的数据为更新10次后的数据，中途的其他9次更新操作根本不重要，这样的<strong>性能显然是很高的</strong>。这种方式当然也有很大问题，比如<strong>长期的数据不一致、缓存宕机造成的严重后果</strong>等。</p><p>操作缓存和数据库时要考虑如下几个问题：</p><ul><li>删除缓存还是更新缓存？ <ul><li>更新缓存：每次更新数据库都更新缓存，<strong>无效写操作较多</strong>。（写多读少的情况，假设更新100次数据，读1次数据，这边会有100次无效更新缓存）</li><li>删除缓存：<strong>更新数据库时让缓存失效，查询时再更新缓存</strong>（<strong>更优</strong>） 。（写多读少时，更新100次也只需要删一次缓存，避免无效写操作）</li></ul></li><li>如何保证缓存和数据库的操作的同时成功或失败？（原子性） <br>- 单体系统：<strong>事务控制</strong>，将缓存与数据库操作放在一个事务 <br>- 分布式系统：利用TCC等<strong>分布式事务方案</strong> </li><li>先操作缓存还是先操作数据库？（线程安全） <br>- 先删除缓存，再操作数据库 <br>- 先操作数据库，再删除缓存 - 由于 redis 的速度远比MySQL要快，所以方案二为优选</li></ul><p><strong>先删缓存再操作数据库的线程安全问题：</strong>正常情况如左图，两个线程得到的数据一致。异常情况下如果线程2（读操作）在线程1写数据库之前查缓存，就会使得缓存与数据库不同步。因为写MySQL数据库操作比查Redis缓存操作慢，所以异常情况很容易发生。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516121851596.png" style="zoom:80%;"><p><strong>先操作数据库再删缓存的线程安全问题</strong>：正常情况如左图。异常情况如右图。异常情况发生条件是（1）线程并行（2）缓存失效（3）在线程1（读操作）查数据库过程中，线程2完成了更新数据库和删缓存两个操作。由于MySQL写数据比查数据慢，在微秒级别内完成更新数据库和删除缓存概率很低。所以这个方式更好。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516122155989.png" alt="image-20240516122155989" style="zoom:80%;"><h3 id="总结Redis读写策略"><a href="#总结Redis读写策略" class="headerlink" title="总结Redis读写策略"></a>总结Redis读写策略</h3><p>读操作：</p><ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li></ul><p>写操作：</p><ul><li><strong>先写数据库，然后再删除缓存</strong></li><li>要确保数据库与缓存操作的原子性</li></ul><h2 id="商铺缓存与双写一致"><a href="#商铺缓存与双写一致" class="headerlink" title="商铺缓存与双写一致"></a>商铺缓存与双写一致</h2><p>现在我们要给查询商铺的缓存添加<strong>主动更新</strong>和<strong>超时剔除</strong>策略。<br>修改ShopController的业务逻辑满足：<br>（1）根据id查询店铺，没命中就查数据库，然后写入缓存，<strong>并设置超时时间</strong><br>（2）根据id<strong>修改</strong>店铺，<strong>先操作数据库，再删除缓存</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span>  <span class="token comment">// 通过事务控制数据库和缓存操作的原子性</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Shop</span> shop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Long</span> id <span class="token operator">=</span> shop<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"店铺不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新数据库</span>    <span class="token function">updateById</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 删除缓存</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="缓存穿透、雪崩、击穿"><a href="#缓存穿透、雪崩、击穿" class="headerlink" title="缓存穿透、雪崩、击穿"></a>缓存穿透、雪崩、击穿</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透</strong>是指<strong>客户端请求的数据在缓存和数据库中都不存在</strong>，这样缓存永远不会生效，这些请求都会打到数据库。不断发起这样的请求，给数据库带来巨大压力。过程即：<br>（1）客户端访问Redis，未命中（2）接着访问数据库，未命中<br>这样的话，如果有人恶意多线程地访问不存在的内容，可能就把我们的系统弄垮了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>1、缓存空对象：</strong><br>（1）客户端请求Redis，未命中<br>（2）接着访问数据库，未命中<br>（3）<strong>数据库将空值null缓存到Redis里</strong><br>这样如果继续访问的话，<strong>就会访问Redis了，不会一直去对数据库造成攻击</strong>，尽管访问Redis以后返回的内容是NULL。<br><strong>优点</strong>：实现简单，维护方便<br><strong>缺点</strong>：<strong>额外内存消耗</strong>（每次进行不同的访问，都创建null，不过设置TTL可以解决）；可能<strong>造成短期的不一致</strong>（设置为NULL之后，数据库真的新增了这个数据，不过设置TTL可以有效缓解这种情况的出现概率）</p><p><strong>2、布隆过滤：</strong><br>这其实是一种算法，它<strong>在客户端与Redis交互之间加了一个布隆过滤器</strong>：<br>（1）用户请求布隆过滤器，<strong>不存在就直接拒绝</strong><br>（2）存在的话就放行，让客户端去访问Redis，有就返回，没有就访问数据库<br>布隆过滤器存储的一系列的二进制位，<strong>这种二进制数是先对数据库数据进行某种哈希运算以后再转成二进制存储到布隆过滤器的</strong>，具体原理可以自行查询，这种算法实现方式决定了<strong>过滤器存在概率性</strong>：如果过滤器返回<strong>不存在</strong>，那就是不存在；如果返回<strong>存在</strong>，那就不一定了。</p><p><strong>优点</strong>：<strong>内存占用较少</strong>，没有多余key<br><strong>缺点</strong>：实现复杂（不过Redis里面存在，可以简化开发）；存在<strong>误判可能</strong>。</p><p>因为布隆过滤器存在误判，所以我们的开发过程中，会选择<strong>缓存空对象</strong>的方式来解决缓存穿透。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516130239055.png" alt="image-20240516130239055"><p><strong>缓存穿透的其他解决方案：</strong></p><ul><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="解决商铺查询的缓存穿透问题"><a href="#解决商铺查询的缓存穿透问题" class="headerlink" title="解决商铺查询的缓存穿透问题"></a>解决商铺查询的缓存穿透问题</h3><p>1、我们需要在之前业务流程环节中增加缓存空对象的环节，即可解决，也就是根据id查询数据库的时候，判断商铺不存在之后，不再直接结束，而是将空值写入Redis。<br>2、那么我们之后的查询，可以在缓存中查询出null值，因此我们的查询就需要对查询出来的值进行判断，不是空值的话才能返回商铺信息到前端。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516214714449.png" alt="image-20240516214714449" style="zoom:80%;"><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩</strong>是指在同一时段<strong>大量的缓存key同时失效或者Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</p><p>正常情况下，大量请求会到达Redis，少数请求到达数据库。而Redis一旦宕机，或者Redis中的大量key都因为TTL到期而失效了，这时候的很多请求都会指向数据库。<br>针对这个问题，我们可以提出一些解决方案：<br>1、给不同的key的<strong>TTL添加随机值</strong>，避免大量的key在同一个小时段内失效<br>2、利用<strong>Redis集群</strong>提高服务的可用性（Redis哨兵机制可以实现服务的监控，<strong>发现宕机的主Redis，就可以立刻将从Redis替代上去</strong>），这个内容相对比较高级，在之后讲。<br>3、给<strong>缓存业务添加降级限流策略（微服务部分）</strong>（如果整个集群的Redis全部都宕机了，我们可以提前做容错处理，当这些Redis都失效的时候，我们要<strong>及时的拒绝请求</strong>，防止大量请求到达数据库）<br>4、给业务添加<strong>多级缓存</strong></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>也叫作热点key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><blockquote><p>我们可以这么理解，网站中有一些内容是非常的重要的，很可能<strong>在同一时段被多个用户给同时访问，也就是高并发访问</strong>，而这个<strong>被高并发访问的key失效了，这时候访问就会到达数据库</strong>，大量请求到达数据库是很危险的，很容易造成缓存雪崩。<br>即便数据库比较坚强，也有可能用户进行访问的内容是很复杂的，可能涉及到了多表查询，也可能其转换到Redis中进行存储的时候需要进行一系列的业务。当缓存重建业务复杂的时候，如此大的请求在那一瞬间给数据库带来的冲击是非常巨大的。</p></blockquote><p>缓存击穿问题，有两种比较主流的解决方法：<br>1、互斥锁<br>2、逻辑过期</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>1、当第一个线程<strong>未命中缓存</strong>的时候，<strong>获取互斥锁，直到这个线程查询数据库完，并且重建了缓存数据并存入Redis，才能释放互斥锁；</strong><br>2、后面的线程在缓存数据存入Redis的过程中，同样会发生查询Redis未命中的情况，那么这些线程无法获得互斥锁，只能进行<strong>休眠，休眠一段时间后再重试，直到锁被解开</strong>（Redis中已经有数据了）。</p><h4 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><p>缓存击穿会出现的原因，其实无非就是TTL到期，Redis失效了，因此我们可以<strong>不给其设置TTL</strong>。但是我们该如何知道key过期了呢？我们要给这个key设置一个逻辑过期，类似：</p><table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>wxj:user:1</td><td>{name:“Jack”, age:21, expire:151467}</td></tr></tbody></table><p>这里的expire不是TTL，而是我们添加到Redis之前设定的，用<strong>代码逻辑来进行维护</strong>。</p><p>那么这个key一旦存储到了Redis里面，没有任何干预的情况下是永不过期的。</p><p>也就是说有线程在查询缓存的时候，代码逻辑里发现<strong>逻辑时间过期了，我们也直接把旧数据返还给客户端</strong>，同时数据更新交给另一个线程去做。此时有更多线程要查缓存，因为拿不到锁所以直接返回旧数据，避免了等待。</p><p>毕竟已经是高并发，一时的旧数据在很多时候也能接受，在我看来这是一种牺牲策略，客户端无须等待新数据到来，当然了，<strong>旧数据迟早要进行修改，但数据的更新操作完全可以交给其他线程，这样可以提高效率</strong>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>解决方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>互斥锁</td><td>没有额外内存消耗；保持一致性；实现简单</td><td>线程要等待，性能受影响；可能死锁</td></tr><tr><td>逻辑过期</td><td>线程无需等待，性能较好</td><td><strong>不保证一致性</strong>；有<strong>额外内存消耗</strong>；实现复杂</td></tr></tbody></table><img src="/2024/05/13/hei-ma-dian-ping/image-20240516215835297.png" alt="image-20240516215835297" style="zoom:80%;"><h3 id="解决商铺查询的缓存击穿问题"><a href="#解决商铺查询的缓存击穿问题" class="headerlink" title="解决商铺查询的缓存击穿问题"></a>解决商铺查询的缓存击穿问题</h3><h4 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>加互斥锁。获取锁与释放锁的方法定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 利用redis setnx - 向Redis中添加一个key，只用当key不存在的时候才添加并返回1</span>    <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 直接返回flag的话，拆箱可能拿到空指针</span>    <span class="token keyword">return</span> <span class="token class-name">BooleanUtil</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整合了缓存穿透和缓存击穿的代码。和前面的代码相比主要是在没有命中缓存，且没有存储空值的情况下，<strong>在查数据库前要先获取互斥锁。防止多个线程同时打到数据库。</strong>拿到锁以后查了数据库同步重建缓存返回数据，也就是<strong>这个线程的任务完成后，才能释放锁给其他线程用</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Shop</span> <span class="token function">queryWithMutex</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 查缓存，若存在直接返回，不存在就查数据库</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>    <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 存在店铺信息，反序列化json为bean对象并返回</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>  shop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果没有命中缓存。命中空值，也就是shopJson是“” 空字符串，而非null，返回错误</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shopJson <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// ====== 没缓存，没空值，需要查数据库 -- 查之前先尝试获取互斥锁，拿到锁以后才能查数据库 ======</span>    <span class="token class-name">String</span> lockKey <span class="token operator">=</span> <span class="token string">"lock:shop:"</span> <span class="token operator">+</span> id<span class="token punctuation">;</span> <span class="token comment">// 每个商户都对应一个锁</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断是否获取成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">// 失败则休眠并重试（递归）</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 单位：ms</span>            <span class="token comment">// 如果担心递归造成爆栈，可以用循环，一样的</span>            <span class="token keyword">return</span> <span class="token function">queryWithMutex</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 拿到了锁，查数据库</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 模拟重建的延时，测试用</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>shop <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 空值有效期相对更短</span>            stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token constant">CACHE_NULL_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 数据库中存在，将店铺信息序列化为json字符串，存储到redis缓存中，并添加超时剔除</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">CACHE_SHOP_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放锁</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Jmeter做并发测试，设定并发量为1000。配置好路径和接口。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516223930023.png" alt="image-20240516223930023" style="zoom: 80%;"><p>运行完以后打开查看结果树：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516224240314.png" alt="image-20240516224240314" style="zoom:80%;"><p>打开汇总报告可以看到我们的吞吐量为204</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516224424100.png" alt="image-20240516224424100" style="zoom:80%;"><p>如此大的数据量打下去，但是我们的日志显示我们的数据库只执行了一次的查询语句：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240516224134785.png" alt="image-20240516224134785" style="zoom:80%;"><p>说明我们已经使用互斥锁成功避免了缓存击穿。</p><h4 id="逻辑过期-1"><a href="#逻辑过期-1" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><p>其实通常情况，因为是热点key，一般都是会出现在Redis里面的，且因为我们没有设置TTL，所以热点key是一定会一直存在的，但为了严谨起见，还是在判定缓存未命中的时候返回空。</p><p>主要流程：</p><blockquote><p>1、我们判断一下缓存是否逻辑过期了，如果没有过期，我们直接返回信息到客户端即可<br>2、如果缓存逻辑过期了，这个线程就尝试获取互斥锁，<strong>如果获取成功，说明它是第一个访问Redis的这个过期key的线程</strong>，那么这个线程要做2件事：<br>（1）返回这个旧数据给客户，虽然数据是旧的，但是这是一种暂时的牺牲<br>（2）<strong>开辟新的线程来进行缓存数据的重建，重建完毕就释放这个互斥锁</strong><br>3、除了第2种情况说的这个线程，其他线程<strong>在知道自己访问的数据过期之后，获取互斥锁都会失败，那么这时候只需要直接返还数据给客户就好了</strong>，可能是旧数据，也可能是新数据（第一个线程释放锁或者缓存数据重建成功了）</p></blockquote><img src="/2024/05/13/hei-ma-dian-ping/image-20240517164654459.png" alt="image-20240517164654459"><p>首先我们要对Shop类增加逻辑过期时间这样一个字段，一种方案是<strong>直接添加，这种会违背开闭原则</strong>，一种是可以<strong>新增加一个类</strong>，并且类中包含了逻辑过期时间expireTime，但是该怎么把这个属性添加到Shop里面呢？可以让Shop继承这个类，就可以获得这个类中的属性，但同样会修改Shop这个类的源代码，同样违背开闭原则，所以最好的方法就<strong>是用关联来代替继承：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisData</span> <span class="token punctuation">{</span>    <span class="token comment">/**     *  万能的逻辑过期数据类     */</span>    <span class="token keyword">private</span> <span class="token class-name">LocalDateTime</span> expireTime<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>商铺查询逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 线程池</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ExecutorService</span> <span class="token constant">CACHE_REBUILD_EXECUTOR</span> <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Shop</span> <span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 查缓存，若不存在直接返回空</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>    <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 命中，将json反序列化为对象，判断过期时间。</span>    <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">RedisData</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取到的redisdata存的数据本质是jsonobject类型</span>    <span class="token class-name">JSONObject</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JSONObject</span><span class="token punctuation">)</span> redisData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">LocalDateTime</span> expireTime <span class="token operator">=</span> redisData<span class="token punctuation">.</span><span class="token function">getExpireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 没过期直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>expireTime<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token comment">// 过期了重建缓存，尝试获取互斥锁</span>    <span class="token class-name">String</span> lockKey <span class="token operator">=</span> <span class="token constant">LOCK_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span> <span class="token comment">// 每个商户都对应一个锁</span>    <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断是否获取成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">// 失败说明已经有别的线程处理了，不需要再尝试重建</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 拿到了锁，开启独立线程重建缓存</span>    <span class="token constant">CACHE_REBUILD_EXECUTOR</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token comment">// 为了便于测试缓存重建机制设置20秒逻辑缓存</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">saveShop2Redis</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token number">20L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment">//释放锁</span>            <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> shop<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Jmeter测试，100个线程，1s执行完。查看idea后台，可以发现我们只执行了一次重构，说明只有一个线程操作了数据库，其他返回的在重建前是旧数据，重建完是新数据。这也证明了逻辑过期方法会造成短暂的数据不一致的情况。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240517172349168.png" alt="image-20240517172349168" style="zoom:80%;"><h2 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h2><p>基于StringRedisTemplate封装一个缓存工具类，可以满足以下的需求：<br>1、将<strong>任意</strong>Java对象序列化为json并<strong>存储在string类型的key</strong>中，并且可以设置TTL过期时间。— 存储对象<br>2、将任意Java对象序列化为json并存储在string类型的key中，并且可以<strong>设置逻辑过期时间</strong>，用于处理缓存击穿问题。— 存储逻辑过期对象<br>3、根据<strong>指定的key查询</strong>缓存，并反序列化为<strong>指定类型</strong>，利用<strong>缓存空值</strong>的方式解决缓存穿透问题。— 取对象<br>4、根据指定的key查询缓存，并反序列化指定类型，需要利用<strong>逻辑过期解决缓存击穿</strong>问题。— 取逻辑过期对象<br>1+3：存储普通对象；2+4：存储热点数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CacheClient</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">CacheClient</span><span class="token punctuation">(</span><span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 将任意Java对象序列化为json并存储在string类型的key中</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 带逻辑过期的存储方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWithLogicalExpire</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 逻辑过期类</span>        <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        redisData<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置逻辑过期时间</span>        redisData<span class="token punctuation">.</span><span class="token function">setExpireTime</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">plusSeconds</span><span class="token punctuation">(</span>unit<span class="token punctuation">.</span><span class="token function">toSeconds</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>redisData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 解决缓存穿透，这里用泛型接收任意类型id和对象类型，以便返回对应类型bean     * 参数：key的前缀，对应对象的id，以及对象类型     * 这里的id也同样是泛型，因为没办法保证用户传过来的id类型是Int还是Long或者其他     * 如果redis不存在，需要查询数据库，通用的函数根本不知道从数据库的哪张表进行查询（如果写到service可以利用mybatis-plus getById查对应类型），这里要自行传入 -- 函数式编程     * Function&lt;T, R&gt;表示有参数有返回值的类型，“dbFallback”表示数据库降级逻辑，代表查询Redis失败后要去做的后备方案     */</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">,</span> ID<span class="token punctuation">&gt;</span></span> <span class="token class-name">R</span> <span class="token function">queryWithPassThrough</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyPrefix<span class="token punctuation">,</span> <span class="token class-name">ID</span> id<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> dbFallback<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> keyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>json <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 传入的函数，参数T=id，返回值R为对象类型</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> dbFallback<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//不存在，返回错误</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//存一个null到Redis中，避免缓存穿透</span>            stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//存在，写入Redis，直接用set方法</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> r<span class="token punctuation">,</span> time<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//返回</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//逻辑过期解决缓存击穿问题</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ExecutorService</span> <span class="token constant">CACHE_REBUILD_EXECUTOR</span> <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">R</span> <span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyPrefix<span class="token punctuation">,</span> <span class="token class-name">String</span> lockKeyPrefix<span class="token punctuation">,</span> <span class="token class-name">ID</span> id<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> dbFallback<span class="token punctuation">,</span> <span class="token class-name">Long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> keyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断redis中是否存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 未命中，直接返回</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 命中，先把json反序列化成对象</span>        <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> <span class="token class-name">RedisData</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">JSONObject</span> data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JSONObject</span><span class="token punctuation">)</span> redisData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取到对象类型的r</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">LocalDateTime</span> expireTime <span class="token operator">=</span> redisData<span class="token punctuation">.</span><span class="token function">getExpireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断是否过期，未过期直接返回r</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>expireTime<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> r<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 已过期，缓存重建。尝试获取互斥锁。互斥锁key由参数传递</span>        <span class="token class-name">String</span> lockKey <span class="token operator">=</span> lockKeyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//判断是否获取锁成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isLock<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//成功获取锁，开启独立线程来实现缓存重建，用线程池来做</span>            <span class="token constant">CACHE_REBUILD_EXECUTOR</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment">//查询数据库，这里依旧使用函数式编程</span>                    <span class="token class-name">R</span> r1 <span class="token operator">=</span> dbFallback<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//写入Redis</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setWithLogicalExpire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> r1<span class="token punctuation">,</span> time<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment">//释放锁</span>                    <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//没有拿到锁，直接返回信息</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// opsForValue里面没有真正的setNx，而是setIfAbsent，表示如果不存在就执行set</span>        <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">BooleanUtil</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工具类调用"><a href="#工具类调用" class="headerlink" title="工具类调用"></a>工具类调用</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 缓存穿透</span>    <span class="token comment">// Shop shop = queryWithPassTrough(id);</span>    <span class="token comment">// 缓存击穿 -- 互斥锁</span>    <span class="token comment">// Shop shop = queryWithMutex(id);</span>    <span class="token comment">// 缓存击穿 -- 逻辑过期</span>    <span class="token comment">// Shop shop = queryWithLogicalExpire(id);</span>    <span class="token comment">// 封装的工具类，解决缓存穿透</span>    <span class="token comment">// Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span>    <span class="token comment">// 封装的工具类，解决缓存击穿</span>    <span class="token class-name">Shop</span> shop <span class="token operator">=</span> cacheClient<span class="token punctuation">.</span><span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span><span class="token constant">CACHE_SHOP_KEY</span><span class="token punctuation">,</span> <span class="token constant">LOCK_SHOP_KEY</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">::</span><span class="token function">getById</span><span class="token punctuation">,</span> <span class="token number">10L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shop <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"商铺不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="==优惠券秒杀=="></a>==优惠券秒杀==</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><p>每个店铺都可以发布优惠券（代金券），当用户抢购的时候，就会生成订单并且保存到tb_voucher_order这张表中：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tb_voucher_order<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>user_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'下单的用户id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>voucher_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'购买的代金券id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>pay_type<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span> <span class="token keyword">COMMENT</span> <span class="token string">'支付方式 1：余额支付；2：支付宝；3：微信'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>status<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span> <span class="token keyword">COMMENT</span> <span class="token string">'订单状态，1：未支付；2：已支付；3：已核销；4：已取消；5：退款中；6：已退款'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'下单时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>pay_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'支付时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>use_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'核销时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>refund_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'退款时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，我们的主键ID没有使用自增长，这是因为如果使用数据库自增ID就会存在一些问题：<br>1、ID的规律性太明显，容易让别人猜测到信息（比如商城在一天时间内，卖出了多少单）<br>2、受单表数据量的限制（<strong>订单可能数据非常大，可能会分多表进行存储</strong>，但表的自增长相互之间不受影响，所以不同表之间可能会出现ID相同的情况，也就是说这种时候会违背ID的唯一性，这显然是不可以的）<br><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：<strong>1、唯一性  2、高可用  3、高性能  4、递增性  5、安全性</strong></p><p>除了第5点，Redis及其数据结构已经可以直接满足前4点的要求了，为了增加ID的安全性，不要直接使用Redis自增的数值，而是拼接一些其他信息，最终我们将ID组成定义为64位的二进制数，分别是<strong>1位符号位，31位时间戳，32位序列号。</strong></p><h4 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisIdWorker</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token comment">/**     * 开始时间戳由main函数运行得到     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token constant">BEGIN_TIMESTAMP</span> <span class="token operator">=</span> <span class="token number">1716076800L</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 序列号的位数：32bit，秒内的计数器，支持每秒产生2^32个不同ID     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">nextId</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyPrefix<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//获得当前时间</span>        <span class="token class-name">LocalDateTime</span> now <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> nowSecond <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">toEpochSecond</span><span class="token punctuation">(</span><span class="token class-name">ZoneOffset</span><span class="token punctuation">.</span><span class="token constant">UTC</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//生成时间戳：31bit，以秒为单位，可以使用69年</span>        <span class="token keyword">long</span> timestamp <span class="token operator">=</span> nowSecond <span class="token operator">-</span> <span class="token constant">BEGIN_TIMESTAMP</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 接下来生成序列号         * 我们的key的设置除了加上icr表示是自增长的，还需要在最后拼接一个日期字符串         * 这是因为我们的序列号上限是2^32，并不大，如果每天的key都是一样的，这是很有可能超过上限的         * 在后面拼接一个日期字符串，可以保证每一天的key都是不一样的，而且一天内也基本不可能到达2^32的上限         * 这样做还有一个好处，我们以后可以根据每天或者每月来查看value值，起到统计效果         */</span>        <span class="token comment">//获取当前日期，精确到天</span>        <span class="token class-name">String</span> date <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"yyyy:MM:dd"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> count <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token string">"icr:"</span> <span class="token operator">+</span> keyPrefix <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//拼接并返回，这里灵活用位运算</span>        <span class="token keyword">return</span> timestamp <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">|</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//定义时间为2024年5月19日00:00:00</span>        <span class="token class-name">LocalDateTime</span> time <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将时间变成变成秒数的形式</span>        <span class="token keyword">long</span> second <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">toEpochSecond</span><span class="token punctuation">(</span><span class="token class-name">ZoneOffset</span><span class="token punctuation">.</span><span class="token constant">UTC</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//在这里运行出来的时间作为BEGIN_TIMESETAMP</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全局唯一ID生成策略"><a href="#全局唯一ID生成策略" class="headerlink" title="全局唯一ID生成策略"></a>全局唯一ID生成策略</h3><ul><li>UUID：优点使用简单，不依赖其他组件，不影响数据库扩展；缺点数据库索引效率低，太过于无意义.用户不友好，空间占用大，集群环境容易重复</li><li>Redis自增：优点利用redis操作原子性的特征,可以保证在并发的时候不会重复，拓展性强,可以方便的结合业务进行处理；缺点增加一侧网络开销 需要对reids服务实现高可用</li><li>snowflake算法：优点性能较优,速度快 无需第三方依赖,实现也简单 可以根据实际情况调整和拓展算法,方便灵活；缺点依赖时间机器,如果发生回拨会导致生成id重复</li><li>数据库自增：优点无需编码，性能也过得去，索引友好；缺点大表不能做水平分表,否则插入删除易出现问题，依赖前期规划,拓展麻烦 依赖mysql内部维护自增锁,高并发下插入数据影响性能</li></ul><h3 id="秒杀数据表"><a href="#秒杀数据表" class="headerlink" title="秒杀数据表"></a>秒杀数据表</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券，平价券可以任意购买，而特价券需要秒杀抢购，表关系如下</p><p>tb_voucher（平价与秒杀券都有）：优惠券基本信息（金额，规则等）:上面的type可以表示标识出是平价券还是特价券，如果是特价券我们也需要一些特定的信息，因此我们会专门拓展出一张表。<br>tb_seckill_voucher（对应秒杀券）：优惠券库存、开始抢购时间、结束抢购时间（特价券需要此表）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tb_voucher<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>shop_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'商铺id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>title<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'代金券标题'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>sub_title<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'副标题'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>rules<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'使用规则'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>pay_value<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'支付金额，单位是分。例如200代表2元'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>actual_value<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'抵扣金额，单位是分。例如200代表2元'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>type<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span> <span class="token keyword">COMMENT</span> <span class="token string">'0,普通券；1,秒杀券'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>status<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span> <span class="token keyword">COMMENT</span> <span class="token string">'1,上架; 2,下架; 3,过期'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tb_seckill_voucher<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>voucher_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'关联的优惠券的id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>stock<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'库存'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>begin_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'生效时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>end_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'失效时间'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>voucher_id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_general_ci <span class="token keyword">COMMENT</span> <span class="token operator">=</span> <span class="token string">'秒杀优惠券表，与优惠券是一对一关系'</span> ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h3><p>在VoucherController中提供一个接口，调用就可以实现添加普通券。mapper中普通券除了定义对应tb_voucher的内容，还添加了库存、生效时间和失效时间字段。这样添加普通券和添加秒杀券都可以通过这个类传递对象，传递过来以后如果是普通券，这几个字段默认exsit=false（也就是没有该字段到数据库表的映射），直接利用VoucherServiceImpl的save方法保存即可。如果是秒杀券，就首先save到tb_voucher，再对库存、生效时间、失效时间等手动保存，利用seckillVoucherService添加到tb_seckill_voucher表。也就实现了通过前端一次传递，就在后端保存两张表的信息，简化代码逻辑。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519145646945.png" alt="image-20240519145646945" style="zoom:80%;"><h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><p><strong>接口地址</strong>:<code>/voucher-order/seckill/{id}</code></p><p><strong>请求方式</strong>:<code>POST</code></p><p><strong>请求参数</strong>:</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>请求类型</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>id</td><td>优惠券id</td><td>path</td><td>true</td><td>integer(int64)</td><td></td></tr></tbody></table><p><strong>返回值</strong>：订单id</p><p>基础功能实现（不考虑并发）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span>  <span class="token comment">// 涉及多表操作，添加事务以便回滚</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">seckillVoucher</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 查询优惠券</span>    <span class="token class-name">SeckillVoucher</span> voucher <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀券不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 判断时间区间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getBeginTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀尚未开始！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀已经结束！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 判断库存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 扣减库存</span>    <span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 创建订单</span>    <span class="token class-name">VoucherOrder</span> voucherOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VoucherOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> orderId <span class="token operator">=</span> redisIdWorker<span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token string">"order"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    voucherOrder<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 从threadlocal中取用户id</span>    <span class="token class-name">Long</span> userId <span class="token operator">=</span> <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>userId <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"用户未登录！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    voucherOrder<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>    voucherOrder<span class="token punctuation">.</span><span class="token function">setVoucherId</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保存订单</span>    <span class="token function">save</span><span class="token punctuation">(</span>voucherOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回订单id</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h2><p>以上代码存在线程安全问题。高并发场景下会有库存超卖 – 在库存为1的时候，多个线程同时查询库存，得到库存1，后面的线程读到的都是脏数据。</p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：</p><p><strong>悲观锁</strong>：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保<strong>线程串行执行</strong>。（Synchronized、Lock等）</p><p><strong>乐观锁</strong>：认为线程安全问题不一定会发生，因此<strong>不加锁</strong>，只是<strong>在更新数据时去判断有没有其它线程对数据做了修改</strong>。（如果没有修改，那就是安全的；<strong>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常</strong>）</p><p>显然乐观锁的性能会好很多，但是实现起来会更复杂，我们要处理好关键的一点，那就是更新数据的时候，该<strong>如何去判断有没有其它线程对数据做了修改</strong>。</p><p>乐观锁的实现方式有2种方法（其实思想相同）：<br><strong>1、版本号法：</strong><br>给数据增加一个字段version，初始值为1，每次我们<strong>要修改库存量之前都需要先查询库存量与版本号</strong>，然后线程执行SQL语句，执行SQL语句必须要确定数据库中的这条数据的版本号就是查询出来的版本号，<strong>如果不相同说明有其他线程修改了数据</strong>，导致当前数据的版本号与之前查询的不一样：<br><strong>2、CAS法</strong><br>上面的方法加一个版本号其实是一种标识，但是我们不一定要借助version，实际上我们可以<strong>直接依靠库存量来做标识</strong>，在对数据库进行修改的时候，我们要首先判断当前数据的库存量与之前线程查询出来的库存量是否相同，不相同则说明发生线程安全问题，不能修改</p><h3 id="乐观锁解决超卖"><a href="#乐观锁解决超卖" class="headerlink" title="乐观锁解决超卖"></a>乐观锁解决超卖</h3><p>我们选用CAS法来解决超卖，根据上述思想，我们只需要在SQL语句那增加一个判断库存量的条件：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 扣减库存</span><span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"stock"</span><span class="token punctuation">,</span> voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用Jmeter测试发现200个线程抢100张票，只卖出了20+张票。</p><p><strong>问题</strong>：假设stock=100，当线程查询出来的stock与数据库的stock不一致的时候，并不能说明票卖完了，只能说明其他线程抢先了票。理论上库存量大概率不为0，该线程还是应该要能够实现买票操作，但全都因为查询的stock与数据库不一致导致有大量线程买票失败。</p><p><strong>修改</strong>：只需要查询数据库中的stock是否大于0即可。— <code>.gt("stock", 0)</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token string">"stock"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// /where id = ? and stock &gt; 0</span>    <span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新测试发现能够正好下单100份秒杀券。</p><blockquote><p>但是这不代表乐观锁就是完美的，很显然代码逻辑中要操作数据库，大量的线程就会给数据库带来压力，仅仅使用乐观锁在更高并发的场景下还是不太够的。</p></blockquote><h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单。</p><p>解决：只需要判断当前尝试抢优惠券的线程，其用户id在订单表中是否已经存在了，如果存在则不允许下单。</p><p>这里仍然会有多线程问题，由于这段逻辑不涉及数据库更新而是要插入数据，所以<strong>加悲观锁</strong>。这里锁放在函数内部，因为如果在方法上加锁，那么不管是哪个用户来下单都变成串行了，所以我们需要在内部调用synchronized，并指定锁定对象为userId。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoucherOrderServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">VoucherOrderMapper</span><span class="token punctuation">,</span> <span class="token class-name">VoucherOrder</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">IVoucherOrderService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">ISeckillVoucherService</span> seckillVoucherService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">RedisIdWorker</span> redisIdWorker<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">seckillVoucher</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 查询优惠券</span>        <span class="token class-name">SeckillVoucher</span> voucher <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀券不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 判断时间区间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getBeginTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀尚未开始！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"秒杀已经结束！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 判断库存</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Transactional</span>    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">createVoucherOrder</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从threadlocal中取用户id</span>        <span class="token class-name">Long</span> userId <span class="token operator">=</span> <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * userId值一样的，我们用同一把锁，即为同一个用户的多线程访问加锁。         * 但是每个请求一来，我们的id对象都是全新的（toString得到的是新的string对象）         * 所以要加上intern()方法，从字符串常量池中返回字符串的规范表示，保证多个请求访问一个用户字符串时得到的是同样的地址         */</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>userId<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 查询用户是否已经下单了对应优惠券</span>            <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"user_id"</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"用户已经购买！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 没买过，扣减库存</span>            <span class="token keyword">boolean</span> success <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setSql</span><span class="token punctuation">(</span><span class="token string">"stock = stock - 1"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"voucher_id"</span><span class="token punctuation">,</span> voucherId<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token string">"stock"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"库存不足！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 创建订单</span>            <span class="token keyword">long</span> orderId <span class="token operator">=</span> redisIdWorker<span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token string">"order"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">VoucherOrder</span> voucherOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VoucherOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            voucherOrder<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>            voucherOrder<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>            voucherOrder<span class="token punctuation">.</span><span class="token function">setVoucherId</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 保存订单</span>            <span class="token function">save</span><span class="token punctuation">(</span>voucherOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回订单id</span>            <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意一个细节，<strong>上面代码还是会发生并发安全问题：</strong></p><blockquote><p>我们这边的整个函数已经是被Spring托管了，所以<strong>事务的提交会在函数执行完毕之后</strong>，也就是说我们会<strong>先释放锁，再提交事务</strong>，当我们事务还没有提交完成，<strong>修改数据还没写入数据库，却又有其他线程进来了</strong>，再次发生线程并发问题。</p></blockquote><h3 id="事务与锁顺序"><a href="#事务与锁顺序" class="headerlink" title="事务与锁顺序"></a>事务与锁顺序</h3><p>所以，锁的范围太小了，我们应该要把整个函数都锁起来。这样就是<strong>先获取锁，提交事务，再释放锁。</strong></p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519174917100.png" alt="image-20240519174917100"><h3 id="事务生效问题"><a href="#事务生效问题" class="headerlink" title="事务生效问题"></a>事务生效问题</h3><p>直接调用createVoucherOrder方法是不行的，因为它相当于调用了this.createVoucherOrder，然而当前类并不是代理对象，这会导致Sping代理失效。</p><blockquote><p>Spring的事务是通过AOP来实现的，只有通过代理对象调用<code>@Transactional</code>注解的对象方法时，事务才会生效，也就是直接调用<code>createVoucherOrder()</code>方法事务才会生效，调用<code>seckillVoucher()</code>方法后间接调用<code>createVoucherOrder()</code>方法事务是不会生效的。因为这次调用并不是通过代理对象来实现的。</p></blockquote><img src="/2024/05/13/hei-ma-dian-ping/image-20240519175418682.png" alt="image-20240519175418682"><p>所以我们要先获得当前对象的代理对象，然后再去调用这个函数（这个函数也要创建在service接口中，表明它属于代理对象能调用的方法）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>userId<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">IVoucherOrderService</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IVoucherOrderService</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要引入依赖：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">&lt;dependency<span class="token punctuation">&gt;</span>        &lt;groupId<span class="token punctuation">&gt;</span>org.aspectj&lt;/groupId<span class="token punctuation">&gt;</span>        &lt;artifactId<span class="token punctuation">&gt;</span>aspectjweaver&lt;/artifactId<span class="token punctuation">&gt;</span>&lt;/dependency<span class="token punctuation">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>并且在启动类中需要暴露代理对象：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519180101176.png" alt="image-20240519180101176" style="zoom:80%;"><p>使用Jmeter测试，同一用户200个线程，最终只插入一条数据。问题解决。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519222713031.png" alt="image-20240519222713031" style="zoom:80%;"><h2 id="集群下的线程并发安全问题"><a href="#集群下的线程并发安全问题" class="headerlink" title="集群下的线程并发安全问题"></a>集群下的线程并发安全问题</h2><p>现在已经通过加锁解决一人一单问题安全，但是这只能解决单机情况的，集群模式依旧不行。</p><p>利用idea模拟集群模式，复制一个新的服务，设置端口8082（program arguments）</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519225432012.png" alt="image-20240519225432012" style="zoom:80%;"><p>重启形成2个机子的集群：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519231204101.png" alt="image-20240519231204101"><p>修改nginx的conf目录下的nginx.conf文件，配置反向代理、负载均衡：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240519230039737.png" alt="image-20240519230039737" style="zoom:80%;"><p>最后重新加载一下Nginx：<code>nginx.exe -s reload</code></p><p>最后访问网址，并连续刷新2次：</p><blockquote><p><a href="http://localhost:8080/api/voucher/list/1">http://localhost:8080/api/voucher/list/1</a></p></blockquote><p>查看后台可以发现两个启动服务都可以接受到信息，因为api（8080）包括了8081与8082，访问是以<strong>轮询</strong>的方式进行的。这样就实现了负载均衡。</p><p>测试：需要在锁那里打个断点，并且在postman里面分别抢券（都用同一个用户）来进行优惠券抢购，可以发现只用1个用户信息，数据库中却少了2张券，说明又一次发生了并发问题。</p><blockquote><p>我们部署另外一台Tomcat，这是<strong>锁的锁监视器</strong>，<strong>其监视的内容和之前锁中的监视器内容是不一样的</strong>，那么新Tomcat的线程获取锁就会成功（获取的userId.toString()是不一样的，不理解的可以去看toString方法的源码），并成功的操作数据库，因此才会造成线程并行问题。<br>如下图，线程1、3发生了线程安全问题。因此我们只能保证单个JVM下的线程安全，却无法保证集群中多个JVM的线程安全，我们需要在集群中加锁，也就是<strong>分布式锁</strong>，将在后续讲解。</p></blockquote><img src="/2024/05/13/hei-ma-dian-ping/image-20240519231759949.png" alt="image-20240519231759949" style="zoom:80%;"><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="==分布式锁=="></a>==分布式锁==</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><strong>JVM内</strong>的线程之间可以用<strong>锁</strong>实现互斥，synchronized锁只能保证单个JVM内部的多个线程之间互斥，不能保证多JVM下多进程的互斥。因为每个JVM都只有一个锁监视器，但是多个JVM就会有多个锁监视器，导致多个线程获取到锁，从而发生线程安全问题。<br>因此，要实现互斥，可以<strong>让多个JVM都共用一个锁监视器</strong>，这样让JVM与JVM之间、每个JVM的线程之间都共用这个锁，就不会发生线程安全问题了。</p><p>由此引出<strong>分布式锁</strong>的定义：<strong>满足分布式系统或集群模式下多进程可见并且互斥的锁。</strong><br>需要满足的特点：多进程可见、互斥、高可用、高性能、安全性</p><h3 id="不同实现方式对比"><a href="#不同实现方式对比" class="headerlink" title="不同实现方式对比"></a>不同实现方式对比</h3><table><thead><tr><th></th><th>MySQL</th><th>Redis</th><th>Zookeeper</th></tr></thead><tbody><tr><td>互斥</td><td>本身的互斥锁机制</td><td>利用互斥命令setnx</td><td>利用节点的唯一性和有序性实现互斥</td></tr><tr><td>高可用</td><td>好</td><td>好</td><td>好</td></tr><tr><td>高性能</td><td>一般</td><td>好</td><td>一般</td></tr><tr><td>安全性</td><td>断开连接，自动释放锁</td><td>利用锁超时时间，到时释放</td><td>临时节点，断开连接自动释放</td></tr></tbody></table><h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul></li></ul><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可。（解决缓存击穿的互斥锁方案就用了）</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520153020729.png" alt="image-20240520153020729"><h3 id="实现分布式锁版本1"><a href="#实现分布式锁版本1" class="headerlink" title="实现分布式锁版本1"></a>实现分布式锁版本1</h3><p>直接在utils包下创建ILock接口与SimpleRedisLock 类，这个内容和之前的差不多</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleRedisLock</span> <span class="token keyword">implements</span> <span class="token class-name">ILock</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_PREFIX</span> <span class="token operator">=</span> <span class="token string">"lock:"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">// 不同业务有不同的锁，业务name即为锁的name</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SimpleRedisLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//获取线程表示</span>        <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取锁</span>        <span class="token class-name">Boolean</span> success <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                <span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> threadId <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">,</span> timeoutSec<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//防止拆箱操作，不能直接返回success</span>        <span class="token keyword">return</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着修改我们的下单业务的impl，改变之前的加锁逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建锁对象，key需要加上用户id，因为不同的用户无所谓，只有同一个用户才要锁起来，因此要指定好用户id</span><span class="token class-name">SimpleRedisLock</span> simpleRedisLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleRedisLock</span><span class="token punctuation">(</span><span class="token string">"order:"</span> <span class="token operator">+</span> userId<span class="token punctuation">,</span> stringRedisTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isLock <span class="token operator">=</span> simpleRedisLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">1200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取锁失败，由于是对一个人限制锁，所以获取失败直接返回</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"不允许重复下单！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token class-name">IVoucherOrderService</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IVoucherOrderService</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>    simpleRedisLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>集群下测试：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520155946888.png" alt="image-20240520155946888" style="zoom:80%;"><img src="/2024/05/13/hei-ma-dian-ping/image-20240520160019728.png" alt="image-20240520160019728" style="zoom:80%;"><h2 id="Redis分布式锁误删问题"><a href="#Redis分布式锁误删问题" class="headerlink" title="Redis分布式锁误删问题"></a>Redis分布式锁误删问题</h2><p><strong>情况：</strong>持有锁的线程<strong>在锁的内部出现了阻塞，导致他的锁自动释放</strong>，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，<strong>线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑</strong>，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p><strong>解决方案：</strong>解决方案就是在每个线程释放锁的时候，<strong>去判断一下当前这把锁是否属于自己，如果不属于自己，则不进行锁的删除</strong>，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前<strong>这把锁不是属于自己，于是不进行删除锁逻辑，</strong>当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><img src="/2024/05/13/hei-ma-dian-ping/1653385920025.png" alt="1653385920025" style="zoom:80%;"><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>根据上述的分析，我们需要修改一下分布式锁，使得满足：<br>1、在获取锁时存入线程标识</p><blockquote><p>在这里增加了UUID来作为线程的标识，不再使用线程自己的ID了，这是因为虽然每个JVM的线程都是递增的，每个JVM内部之间的都会维护线程的唯一ID，但是不同的JVM之间还是会产生冲突，因此让JVM自己去维护线程的ID，会导致不同JVM之间的ID冲突。<br>事实上，也可以用UUID来表示不同的JVM，用线程ID来区分JVM内部的线程，两者拼接在一块。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 增加线程标识的前缀</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、在释放锁时限获取锁中的线程标识，判断是否与当前线程标识一致（一致才可释放）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//获取线程表示</span>    <span class="token class-name">String</span> threadId <span class="token operator">=</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取锁</span>    <span class="token class-name">Boolean</span> success <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>        <span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> threadId <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">,</span> timeoutSec<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//防止拆箱操作，不能直接返回success</span>    <span class="token keyword">return</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取线程表示</span>    <span class="token class-name">String</span> threadId <span class="token operator">=</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取线程中的id，判断是否一致</span>    <span class="token class-name">String</span> redisId <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>redisId<span class="token punctuation">)</span><span class="token punctuation">)</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h2><p>上述的方式已经可以解决业务阻塞导致的误删操作，但是还会有一些问题：</p><blockquote><p>如果我们阻塞的不是业务，而是业务执行完了，并且<strong>判断锁标识成功，即将释放锁的时候发生的阻塞</strong>（这种阻塞不是业务阻塞，而可能是JVM内部的垃圾回收机制异常导致阻塞），这时候还会发生新的问题。<br>如果被阻塞的时间足够长，导致锁的TTL到期了，一旦释放，其他线程又开始乘虚而入，成功获取锁，执行业务。<br>这时候，被阻塞的线程恢复正常了，但是因为已经进行锁标识的逻辑判断了，这时候被阻塞的线程就可以完成这个释放锁的操作，再次造成误删问题。</p></blockquote><p>分析一下问题发生的原因，之所以会出现这种情况，主要原因是<strong>锁标识的逻辑判断与锁的释放操作，是两个不同的操作，不满足原子性，所以当在两个操作之间发生了阻塞，那么线程并发问题依旧会出现。</strong><br>所以，我们必须要保证<strong>判断锁标识</strong>的动作与<strong>释放锁</strong>的动作必须得保证<strong>原子性</strong>。</p><h2 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h2><p>想到原子性，我们很容易就想到MySQL中的事务，但是Redis中的事务却不太一样<strong>，Redis事务虽然能保障原子性，但是无法保证事务的一致性</strong>。Redis事务的操作是一系列的批处理，是在最终一次性执行的，必须要有乐观锁来做判断，会麻烦很多。</p><p>Lua语言能够保证原子性，是因为它在执行原子操作时会将其他线程或进程阻塞，直到该操作完成。</p><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AF%AD%E6%B3%95%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，语法如下：</a></p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'命令名称'</span><span class="token punctuation">,</span> <span class="token string">'key'</span><span class="token punctuation">,</span> <span class="token string">'其它参数'</span><span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我们要执行set name jack，则脚本是这样：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">#</span> 执行 set name jackredis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'jack'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">#</span> 先执行 set name jackredis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'Rose'</span><span class="token punctuation">)</span><span class="token operator">#</span> 再执行 get name<span class="token keyword">local</span> name <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token operator">#</span> 返回<span class="token keyword">return</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写好脚本以后，需要用Redis命令来调用脚本</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">EVAL script numkeys key… arg…<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，要执行redis.call(‘set’, ‘name’, ‘jack’)这个脚本。0表示key类型的参数的个数</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">EVAL “<span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>‘set’<span class="token punctuation">,</span> ‘name’<span class="token punctuation">,</span> ‘jack’<span class="token punctuation">)</span>” <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数 – 1代表key类型的参数有一个，也就是紧接着的name，会放入KEYS[1]，而Rose则放入ARGV[1]中</p><img src="/2024/05/13/hei-ma-dian-ping/1653392438917.png" alt="1653392438917"><h3 id="Java调用Lua脚本改造分布式锁"><a href="#Java调用Lua脚本改造分布式锁" class="headerlink" title="Java调用Lua脚本改造分布式锁"></a>Java调用Lua脚本改造分布式锁</h3><p>在resources下新建Lua文件：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- 锁中的线程标识与当前线程一致</span><span class="token keyword">if</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">then</span>    <span class="token comment">-- 释放锁</span>    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'del'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment">-- 不一致则什么也不做</span><span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在impl中增加静态变量，防止每次调用unLock函数都要重新调用Lua脚本。修改unLock函数，调用Lua脚本。</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520171239197.png" alt="image-20240520171239197"><h2 id="分布式锁-Redisson"><a href="#分布式锁-Redisson" class="headerlink" title="==分布式锁-Redisson=="></a>==分布式锁-Redisson==</h2><p>基于setnx的分布式锁存在下面的问题：<br><strong>1、不可重入</strong>：同一个线程无法多次获取同一把锁（当同一个线程内，方法A获取了锁，然后调用方法B，方法B中没办法获取同一把锁）<br><strong>2、不可重试</strong>：获取锁只尝试一次就返回false，没有重试机制<br><strong>3、超时释放</strong>：虽然可以避免死锁，但如果业务耗时很长，也会导致锁释放，会再次发生线程安全问题<br><strong>4、主从一致性问题</strong>：若Redis提供了主从集群，主从同步存在延迟。当主节点宕机时，从节点充当主节点。如果从节点没有同步主节点中的锁数据，即没有锁标识，则会让其他节点拿到锁</p><p>Redisson是一个在Redis基础上实现的<strong>分布式工具集合</strong>，提供了很多分布式服务，包含了各种分布式锁的实现。</p><h3 id="Redisson快速入门"><a href="#Redisson快速入门" class="headerlink" title="Redisson快速入门"></a>Redisson快速入门</h3><p>引入依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.23.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置客户端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedissonConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RedissonClient</span> <span class="token function">redissonClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//配置</span>        <span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//添加Redis地址，这里添加的是单点的地址，也可以使用config.userClusterServer()来添加集群的地址</span>        config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"redis://ip:6379"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建客户端</span>        <span class="token keyword">return</span> <span class="token class-name">Redisson</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Redisson的分布式锁：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520185500237.png" alt="image-20240520185500237" style="zoom:80%;"><p>订单业务中的修改：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建锁对象，key需要加上用户id，因为不同的用户无所谓，只有同一个用户才要锁起来，因此要指定好用户id</span><span class="token comment">//        SimpleRedisLock simpleRedisLock = new SimpleRedisLock("order:" + userId, stringRedisTemplate);</span><span class="token comment">//        boolean isLock = simpleRedisLock.tryLock(1200);</span><span class="token comment">// 获取锁（可重入），指定锁的名称</span><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock:order:"</span> <span class="token operator">+</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>…………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Redisson的可重入锁原理"><a href="#Redisson的可重入锁原理" class="headerlink" title="Redisson的可重入锁原理"></a>Redisson的可重入锁原理</h2><img src="/2024/05/13/hei-ma-dian-ping/image-20240520192526025.png" alt="image-20240520192526025" style="zoom:80%;"><p>我们需要找到一种数据结构，能够<strong>在一个key里面获取多个东西</strong>——Hash：</p><p>Hash结构（hset）的KEY对应的VALUE包含了field与value，因此我们可以<strong>让KEY对应锁名称，让field对应线程标识，让value位置记录锁的重入次数</strong>（初始为0）。</p><p>因此，发生上述情况的时候，虽然线程的标识是相同的，但我们可以<strong>将重入次数+1，代表第二次获取锁，这时候整体的VALUE是不相同的。</strong><br>需要注意的是，method2执行完毕以后不能直接释放这个key对应的锁，因为这样的话会导致method1没有执行完毕就被删掉了，解决的方法是让重入次数-1，只有<strong>所有业务都执行完了（重入次数=0）的时候才能真正释放。</strong><br>这样我们的流程就会发生变化（哈希结构没有直接的EX来设置有效期）：</p><img src="/2024/05/13/hei-ma-dian-ping/image-20240520193101664.png" alt="image-20240520193101664"><p>用Lua脚本来保证代码的原子性，而Lua代码获取锁与释放锁的逻辑已经是保存到RedissonLock类中了，我们只需要直接调用tyrLock与unlock方法就行。</p><blockquote><p>总结：Redisson的可重入原理的核心就是因为我们使用了hash结构，记录了获取锁的线程以及可重用的次数</p></blockquote><h2 id="Redisson的锁重试和WatchDog机制"><a href="#Redisson的锁重试和WatchDog机制" class="headerlink" title="Redisson的锁重试和WatchDog机制"></a>Redisson的锁重试和WatchDog机制</h2><p>redisson在尝试获取锁的时候，如果传了时间参数，就不会在获取锁失败时立即返回失败，而是会进行重试。</p><ul><li><p><strong>waitTime：</strong>是<strong>最大等待时间</strong>，如果使用 <strong>tryLock()</strong> 的时候，<strong>有传参数</strong>表明是<strong>可重试的锁</strong>；反之，不是！</p></li><li><p><strong>leaseTime</strong>：超时释放时间，默认是-1，建议不要设定，Redisson<strong>看门狗机制</strong>可以进行<strong>锁续约</strong></p></li></ul><h3 id="锁重试"><a href="#锁重试" class="headerlink" title="锁重试"></a>锁重试</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>tryLock()</strong> ：里面实现了<strong>重试机制</strong>。通过<strong>消息订阅</strong>和<strong>信号量机制</strong>，避免了 <strong>while(true)</strong> 让其一直无效尝试，避免了<strong>CPU空转问题</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token comment">// 转成毫秒，后面都是以毫秒为单位</span>    <span class="token keyword">long</span> time <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前时间</span>    <span class="token keyword">long</span> current <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 线程ID-线程标识</span>    <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 尝试获取锁，返回锁的剩余过期时间（对应获取锁的lua脚本的返回值） tryAcquire() ==========!!!</span>    <span class="token class-name">Long</span> ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果上面尝试获取锁返回的是null，表示成功；如果返回的是时间则表示失败。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 剩余等待时间 = 最大等待时间 -（用现在时间 - 获取锁前的时间）</span>    time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> current<span class="token punctuation">;</span>    <span class="token comment">// 剩余等待时间 &lt; 0 失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 再次获取当前时间</span>    current <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ==================重试逻辑，但不是简单的直接重试！==================</span>    <span class="token comment">// subscribe是订阅的意思，订阅锁的释放事件</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">&gt;</span></span> subscribeFuture <span class="token operator">=</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待一段时间，看是否能获取到锁的释放事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 如果等待超时，则取消订阅并获取锁失败，返回false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            subscribeFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token comment">// 取消订阅</span>                    <span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscribeFuture<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 获取锁失败</span>        <span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// =======循环重试=======</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// 减去已经消耗的时间</span>        time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> current<span class="token punctuation">;</span>        <span class="token comment">// 如果还有剩余等待时间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token comment">// 获取当前时间戳</span>                <span class="token keyword">long</span> currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 再次尝试获取锁，返回锁的剩余过期时间</span>                ttl <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果锁成功获取</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 减去已经消耗的时间</span>                time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> currentTime<span class="token punctuation">;</span>                <span class="token comment">// 如果等待时间已经用完，则获取锁失败，返回false</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 根据剩余时间尝试获取锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">&gt;=</span> <span class="token number">0L</span> <span class="token operator">&amp;&amp;</span> ttl <span class="token operator">&lt;</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 这里采用====信号量机制=======，等待释放锁的线程释放锁</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">)</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                        <span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>ttl<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">// 如果这个ttl时间比当前线程尝试获取锁的时间还长</span>                    <span class="token comment">// 那么就直接等待尝试获取锁的时间</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">)</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                        <span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 减去已经消耗的时间</span>                time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> currentTime<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果还有剩余等待时间，则继续尝试获取锁</span>            <span class="token comment">// 如果等待时间已经用完，则获取锁失败，返回false</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 如果等待时间已经用完，则获取锁失败，返回false</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">acquireFailed</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment">// 释放订阅</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscribeFuture<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在 tryLock() 中调 tryAcquire() 执行获取锁的操作</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Long</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 尝试以异步方式获取锁的剩余过期时间。 * @param waitTime 等待时间 * @param leaseTime 锁的租期时间 * @param unit 时间单位 * @param threadId 当前线程ID * @return 表示剩余过期时间的Future对象 */</span><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 锁自动释放时间为默认的-1，所以会走else。如果设定了释放时间，走if</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leaseTime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_LONG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// leaseTime我们没有传，这里设定默认值（看门狗）30s</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> ttlRemainingFuture <span class="token operator">=</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span>            commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCfg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_LONG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在获取剩余过期时间的异步结果完成后，执行回调、回调函数 ttlRemaining：剩余有效期，e：异常</span>    ttlRemainingFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ttlRemaining<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 剩余有效期为null，表示获取锁成功！</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlRemaining <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 锁续约</span>            <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ttlRemainingFuture<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 把 leaseTime锁释放时间 记录成一个本地的成员变量</span>    internalLockLeaseTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取锁成功返回nil（空），失败返回时间，锁的剩余有效期（pttl是以毫秒为单位）</span>    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> command<span class="token punctuation">,</span>            <span class="token string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return nil; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return nil; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"return redis.call('pttl', KEYS[1]);"</span><span class="token punctuation">,</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="超时续约"><a href="#超时续约" class="headerlink" title="超时续约"></a>超时续约</h3><p><strong>那么此时还有一个问题，如果当前持有锁的线程业务阻塞了，TTL到期了别其它线程获取到了锁，那么此时就会有安全问题了</strong></p><p>而Redisson是通过看门狗来解决这个问题的</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 更新锁的有效期 * @param threadId 当前线程ID */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 这个entry里主要存储了两个东西，一个是更新锁释放时间的定时任务，还有一个就是线程ID</span>    <span class="token class-name">ExpirationEntry</span> entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExpirationEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将entry添加到ConcurrentHashMap中，如果是第一次添加则会返回null</span>    <span class="token comment">// 保证每次重入拿到的是同一个extry</span>    <span class="token class-name">ExpirationEntry</span> oldEntry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEntry <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 将当前线程ID添加到旧的entry中</span>        oldEntry<span class="token punctuation">.</span><span class="token function">addThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token comment">// 如果旧的条目为null，说明是第一次添加该条目</span>        <span class="token comment">// 将当前线程ID添加到map中</span>        entry<span class="token punctuation">.</span><span class="token function">addThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 第一次来，就需要创建的更新释放时间的定时任务</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 续约锁的过期时间。 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取锁的过期续约条目</span>    <span class="token class-name">ExpirationEntry</span> ee <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果续约条目不为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ee <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建一个定时任务，用于===定时执行续约操作===</span>        <span class="token class-name">Timeout</span> task <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newTimeout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Timeout</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                <span class="token comment">// 获取锁的过期续约条目</span>                <span class="token class-name">ExpirationEntry</span> ent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果续约条目不为null</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 获取第一个等待续约的线程ID</span>                    <span class="token class-name">Long</span> threadId <span class="token operator">=</span> ent<span class="token punctuation">.</span><span class="token function">getFirstThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 如果线程ID不为null</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 异步执行续约操作</span>                        <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 在续约操作完成后执行回调</span>                        future<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment">// 如果续约操作出现异常，则记录日志</span>                                <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Can't update lock "</span> <span class="token operator">+</span> <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" expiration"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token comment">// 如果更新超时时间成功，继续递归更新超时时间</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    <span class="token class-name">RedissonLock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>internalLockLeaseTime <span class="token operator">/</span> <span class="token number">3L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新间隔为看门狗时间的1/3也就是30秒</span>        <span class="token comment">// 将定时任务设置到续约条目中</span>        ee<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看一下释放锁的源码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 异步释放锁。 * @param threadId 当前线程ID * @return 表示释放结果的Future对象 */</span><span class="token keyword">public</span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">unlockAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 创建一个Promise对象，用于表示释放结果</span>    <span class="token class-name">RPromise</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedissonPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 异步执行内部的解锁操作</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unlockInnerAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在解锁操作完成后执行回调</span>    future<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>opStatus<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token comment">// 取消锁的自动更新释放时间</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果解锁操作出现异常</span>            <span class="token comment">// 设置Promise为失败状态，并将异常作为失败原因</span>            result<span class="token punctuation">.</span><span class="token function">tryFailure</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>opStatus <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果操作状态为null，说明锁未被当前线程持有</span>            <span class="token comment">// 设置Promise为失败状态，并抛出IllegalMonitorStateException异常</span>            <span class="token class-name">IllegalMonitorStateException</span> cause <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token string">"attempt to unlock lock, not locked by current thread by node id: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">+</span> <span class="token string">" thread-id: "</span> <span class="token operator">+</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">tryFailure</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 否则，解锁成功</span>            <span class="token comment">// 设置Promise为成功状态</span>            result<span class="token punctuation">.</span><span class="token function">trySuccess</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回表示释放结果的Future对象</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>取消自动更新锁的释放时间方法</p><p>EXPIRATION_RENEWAL_MAP对应上面添加更新任务，这个Map里存的是一个个ExpirationEntry，ExpirationEntry里主要包含定时更新锁释放时间的任务和线程ID</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 取消锁的过期续约。 * @param threadId 要取消续约的线程ID，如果为null，则表示取消所有线程的续约 */</span><span class="token keyword">void</span> <span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span><span class="token class-name">Long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取锁的过期续约任务</span>    <span class="token class-name">ExpirationEntry</span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExpirationEntry</span><span class="token punctuation">)</span><span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果过期续约任务不为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 如果线程ID不为null，则移除指定线程的续约</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            task<span class="token punctuation">.</span><span class="token function">removeThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 如果线程ID为null，或者任务已经没有任何线程在续约</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> task<span class="token punctuation">.</span><span class="token function">hasNoThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 获取任务的定时器任务</span>            <span class="token class-name">Timeout</span> timeout <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">getTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果定时器任务不为null，则取消定时器任务</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                timeout<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 从过期续约映射中移除该任务</span>            <span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>首先线程来获<strong>尝试获取锁（调用Lua脚本）</strong>，判断Lua脚本的返回值TTL是否为NULL（为剩余释放时间说明获取失败）</p></li><li><p>ttl为空说明获取成功，判断锁的释放时间是否设置，<strong>为-1表示未设置，则开启看门狗（看门狗的释放锁时间为30秒）</strong></p></li><li><p>如果自己设置了锁的释放时间则不会启用开门狗，也就是是<strong>不会自动更新释放时间</strong></p></li><li><p>如果获取TTL<strong>不为null说明锁被其他线程给占用了</strong>，被占用就去判断当前线程的剩余等待时间是否大于0</p></li><li><p>剩余等待时间不大于0则说明等待超时直接返回false表示获取锁失败</p></li><li><p>剩余等待时间大于0则<strong>订阅等待锁的释放信号</strong>，等待别的线程的剩余释放时间</p></li><li><p>如果<strong>别的线程的释放时间大于等于当前获取锁线程的最大等待时间，则当前线程直接等待最大等待时间</strong></p></li><li><p>等待完毕后判断等待时间是否超时，是则返回false获取锁失败</p></li><li><p>没有超时则继续尝试获取锁</p></li></ul><img src="/2024/05/13/hei-ma-dian-ping/image-20240520194740741.png" alt="image-20240520194740741"><p>Redisson分布式锁原理：<br>1、可重入：利用hash结构记录线程id和重入次数<br>2、可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制<br>3、超时续约：利用watchDog，每隔一段时间（releaseTime/3），重置超时时间</p><h2 id="Redisson锁的MutiLock原理"><a href="#Redisson锁的MutiLock原理" class="headerlink" title="Redisson锁的MutiLock原理"></a>Redisson锁的MutiLock原理</h2><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，<strong>哨兵会发现主机宕机，并且选举一个slave变成master</strong>，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><img src="/2024/05/13/hei-ma-dian-ping/1653553998403.png" alt="1653553998403" style="zoom: 50%;"><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，<strong>每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功</strong>，假设现在某个节点挂了，那么他去获得锁的时候，<strong>只要有一个节点拿不到，都不能算是加锁成功</strong>，就保证了加锁的可靠性。</p><img src="/2024/05/13/hei-ma-dian-ping/1653554055048.png" alt="1653554055048" style="zoom: 50%;"><p>那么MutiLock 加锁原理是什么呢？</p><p>当我们去设置了多个锁时，redission<strong>会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁</strong>，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，<strong>那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</strong></p><img src="/2024/05/13/hei-ma-dian-ping/1653553093967.png" alt="1653553093967"><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>1）不可重入Redis分布式锁：</p><p>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示<br>缺陷：不可重入、无法重试、锁超时失效</p><p>2）可重入的Redis分布式锁：</p><p>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待<br>缺陷：redis宕机引起锁失效问题</p><p>3）Redisson的multiLock：</p><p>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功<br>缺陷：运维成本高、实现复杂</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员Redis部分资料</p><p>Cookie、Session、Token概念、区别、如何实现：<a href="https://blog.csdn.net/weixin_44369049/article/details/132062232">https://blog.csdn.net/weixin_44369049/article/details/132062232</a></p><p>CSDN笔记：<a href="https://blog.csdn.net/m0_52380556?type=blog">https://blog.csdn.net/m0_52380556?type=blog</a></p><p>redisson：<a href="https://blog.csdn.net/weixin_53946852/article/details/137270519">https://blog.csdn.net/weixin_53946852/article/details/137270519</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;黑马点评&quot;&gt;&lt;a href=&quot;#黑马点评&quot; class=&quot;headerlink&quot; title=&quot;黑马点评&quot;&gt;&lt;/a&gt;黑马点评&lt;/h1&gt;&lt;h2 id=&quot;MySQL表&quot;&gt;&lt;a href=&quot;#MySQL表&quot; class=&quot;headerlink&quot; title=&quot;MySQL</summary>
      
    
    
    
    <category term="后端" scheme="http://wolf-ll.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Redis" scheme="http://wolf-ll.github.io/tags/Redis/"/>
    
    <category term="项目" scheme="http://wolf-ll.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>DepGraph: Towards Any Structural Pruning</title>
    <link href="http://wolf-ll.github.io/2024/05/13/depgraph-towards-any-structural-pruning/"/>
    <id>http://wolf-ll.github.io/2024/05/13/depgraph-towards-any-structural-pruning/</id>
    <published>2024-05-13T06:19:41.000Z</published>
    <updated>2024-09-09T06:47:06.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DepGraph-Towards-Any-Structural-Pruning"><a href="#DepGraph-Towards-Any-Structural-Pruning" class="headerlink" title="DepGraph: Towards Any Structural Pruning"></a>DepGraph: Towards Any Structural Pruning</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>结构化剪枝通过从神经网络中<strong>删除结构化分组的参数</strong>来实现模型加速。然而，参数分组模式在不同的模型中存在很大差异，这使得特定于体系结构的修剪器<strong>依赖于手工设计的分组方案，无法推广到新的体系结构中</strong>。</p><p>本工作在结构化剪枝的<strong>自动化上做了改进</strong>，提出了一种非深度图算法DepGraph，实现了<strong>架构通用的结构化剪枝</strong>，适用于CNNs,，Transformers, RNNs, GNNs等网络。DepGraph能够显式地建模层之间的依赖关系，并对耦合参数进行综合剪枝。自动地分析复杂的结构耦合，从而正确地移除参数实现网络加速。基于DepGraph算法，作者开发了PyTorch结构化剪枝框架 Torch-Pruning。不同于依赖Masking实现的“模拟剪枝”，该框架能够<strong>实际地移除参数和通道，降低模型推理成本</strong>。在DepGraph的帮助下，研究者和工程师无需再与复杂的网络结构斗智斗勇，可以轻松完成复杂模型的一键剪枝。</p><p>本文在几个架构和任务包括ResNe (X)t，DenseNet，MobileNet，VIT，GAT，DGCNN，LSTM上进行广泛评估。并证明提出的方法始终产生令人满意的性能。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>模型部署优化：通过减小模型大小，提高推理速度等，使得模型能够成功部署在各个硬件之中去并且实时有效的运作</p><h3 id="模型剪枝"><a href="#模型剪枝" class="headerlink" title="模型剪枝"></a>模型剪枝</h3><p>深度学习网络模型从卷积层到全连接层存在着大量冗余的参数，大量神经元激活值趋近于0，将这些神经元去除后可以表现出同样的模型表达能力，这种情况被称为过参数化，而对应的技术则被称为模型剪枝。</p><p>Dropout和DropConnect代表着非常经典的模型剪枝技术。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/3e76176a7a84934ac3c2773f8ce98490.png" alt="img" style="zoom:80%;"><p>Dropout中随机的将一些<strong>神经元的输出置零</strong>，这就是<strong>神经元剪枝</strong>。DropConnect则随机的将一些<strong>神经元之间的连接置零</strong>，使得<strong>权重连接矩阵变得稀疏</strong>，这便是<strong>权重连接剪枝</strong>。它们就是最细粒度的剪枝技术，只是这个操作仅仅发生在训练中，对最终的模型不产生影响，因此没有被称为模型剪枝技术。</p><p>当然，模型剪枝不仅仅只有对神经元的剪枝和对权重连接的剪枝，根据粒度的不同，至少可以粗分为4个粒度。</p><ul><li>细粒度剪枝(fine-grained)：即对连接或者神经元进行剪枝，它是粒度最小的剪枝。</li><li>向量剪枝(vector-level)：它相对于细粒度剪枝粒度更大，属于对<strong>卷积核内部(intra-kernel)的剪枝</strong>。</li><li>核剪枝(kernel-level)：即<strong>去除某个卷积核</strong>，它将丢弃对输入通道中对应计算通道的响应。</li><li>滤波器剪枝(Filter-level)：对<strong>整个卷积核组进行剪枝</strong>，会造成推理过程中输出特征通道数的改变。</li></ul><blockquote><p>细粒度剪枝(fine-grained)，向量剪枝(vector-level)，核剪枝(kernel-level)方法在参数量与模型性能之间取得了一定的平衡，但是<strong>网络的拓扑结构本身发生了变化</strong>，需要专门的算法设计来支持这种稀疏的运算，被称之为<strong>非结构化剪枝</strong>。</p><p>而滤波器剪枝(Filter-level)只改变了<strong>网络中的滤波器组和特征通道数目</strong>，所获得的模型不需要专门的算法设计就能够运行，被称为<strong>结构化剪枝</strong>。除此之外还有对整个网络层的剪枝，它可以被看作是滤波器剪枝(Filter-level)的变种，即所有的滤波器都丢弃。</p></blockquote><p>Google在《To prune, or not to prune: exploring the efficacy of pruning for model compression》[1]中探讨了具有同等参数量的稀疏大模型和稠密小模型的性能对比，在图像和语音任务上表明<strong>稀疏大模型普遍有更好的性能</strong>。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>首先训练一个大模型至最佳性能。</li><li>对模型的权重进行分析，去除那些对模型输出影响最小的权重。</li><li>对经过剪枝的模型重新进行微调，以恢复因剪枝造成的性能下降。</li></ul><h3 id="模型量化"><a href="#模型量化" class="headerlink" title="模型量化"></a>模型量化</h3><p>我们知道为了保证较高的精度，大部分的科学运算都是采用浮点型进行计算，常见的是32位浮点型和64位浮点型，即float32和double64。</p><p>对于深度学习模型来说，<strong>乘加计算量是非常大的</strong>，往往需要GPU等专用的计算平台才能实现实时运算，这对于端上产品来说是不可接受的，而模型量化是一个有效降低计算量的方法。</p><p><strong>量化，即将网络的权值，激活值等从高精度转化成低精度的操作过程</strong>，例如将32位浮点数转化成8位整型数int8，同时我们期望转换后的模型准确率与转化前相近。</p><p>模型量化可以带来几方面的优势，如下。</p><p>(1) 更小的模型尺寸。以8bit量化为例，与32bit浮点数相比，我们可以<strong>将模型的体积降低为原来的四分之一，</strong>这对于模型的存储和更新来说都更有优势。</p><p>(2) 更低的功耗。移动8bit数据与移动32bit浮点型数据相比，前者比后者高4倍的效率，而在一定程度上内存的使用量与功耗是成正比的。</p><p>(3) 更快的计算速度。相对于浮点数，大多数处理器都支持8bit数据的更快处理，如果是二值量化，则更有优势。</p><h3 id="知识蒸馏"><a href="#知识蒸馏" class="headerlink" title="知识蒸馏"></a>知识蒸馏</h3><p>一般地，大模型往往是单个复杂网络或者是若干网络的集合，拥有良好的性能和泛化能力，而小模型因为网络规模较小，表达能力有限。<strong>利用大模型学习到的知识去指导小模型训练</strong>，使得小模型具有与大模型相当的性能，但是参数数量大幅降低，从而可以实现模型压缩与加速，就是知识蒸馏与迁移学习在模型优化中的应用。Hinton等人最早在文章“Distilling the knowledge in a neural network”中提出了知识蒸馏这个概念，其核心思想是一旦复杂网络模型训练完成，便可以用另一种训练方法<strong>从复杂模型中提取出来更小的模型</strong>，因此知识蒸馏框架通常包含了一个大模型(被称为teacher模型)，和一个小模型(被称为student模型)。</p><p>具体的方法是在训练小模型时，在损失函数中添加额外的损失函数，损失函数的添加方式有以下几种：</p><p><strong>1.输出层的差异损失</strong>：这种方法是对比学生网络和教师网络在输出层上的概率分布之间的差异；</p><p><strong>2.隐藏层的相似度损失（余弦相似度损失）</strong>：这种方法是对比学生网络和教师网络在隐藏层的相似度差异；</p><p><strong>3.中间层的回归损失（均方误差，mse）</strong>：计算学生网络和教师网络在中间层的均方误差</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>边缘计算应用需要深度神经网络的压缩。在众多的网络压缩范式中，剪枝已经被证明是高效和实用的。网络剪枝的目标是<strong>从给定的网络中去除冗余参数，以使模型更轻量化，并潜在地加快推理速度。</strong>主流剪枝方法大致可分为两类：结构化剪枝和非结构化剪枝。</p><ul><li>结构化剪枝：通过从物理上去除分组参数来改变神经网络的结构；</li><li>非结构化剪枝：对部分权值进行调零，而不修改网络结构。</li></ul><p>在实践中非结构化剪枝能够直接地实现并且天然适用于各种网络，但它通常需要专门的人工智能加速器或软件来实现模型加速。而结构化剪枝不依赖于特定的人工智能加速器或软件来减少内存消耗和计算成本，应用更广泛。</p><p>挑战1：</p><p>深度神经网络建立在大量的基本模块之上，如卷积、标准化或激活，然而这些模块，无论参数化或未参数化，都是通过复杂的连接内在耦合的。因此，<strong>即使我们试图从CNN中只删除一个channel（如图1a），我们必须同时处理它对所有层的相互依赖关系</strong>。（这张图中，残差连接需要两个conv的参数来共享channel，所以修改conv2需要同时修改conv1，BN1，BN2）</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240513144816132.png" style="zoom:80%;"><p>（<em>图1：来自不同层的参数在跨网络架构中本质上是相互依赖的，这迫使多个层必须同时被修剪。本文引入了一个通用的方案，称为依赖图，以显式地解释这种依赖，并以全自动的方式对任意架构执行修剪。</em>）</p><ul><li>依赖性不仅出现在残差结构中，在现代模型中可能是无限复杂的。现有的结构化剪枝方案都依赖于个案分析，也就是<strong>针对于特定的网络</strong>。虽然效果好但费时费力且不能推广。</li><li>本文模型为了跟踪不同层之间的依赖关系，<strong>将依赖链分解并建模为一个递归过程</strong>，这自然可以归结为<strong>在图中寻找最大连通分量</strong>的问题，并且可以通过图遍历来实现O (N)复杂度。具体来说，对于网络中要修剪的层，可以将其作为根来触发相邻耦合层上的修剪，然后继续以被触发层为起点递归重复触发过程。通过这样做，可以全面收集所有耦合层以进行修剪。</li></ul><p>挑战2：</p><p>在结构剪枝中，分组层同时被修剪，这期望<strong>同一组中所有被删除的参数都是不重要的</strong>。这样的话，由于和其他层之间的关联，在单层中的参数重要性就不能反映真实情况。在不同的层上估计的重要性很可能是非加性的，有时甚至是相互矛盾的，这使得很难选择真正不重要的组来进行修剪。</p><p>为了解决这个问题，本文利用DepGraph的依赖建模能力设计了一个“分组级别”的重要性标准，该准则学习组内的一致稀疏性，以便可以安全地删除那些归零的层，而不会造成太多的性能损失。通过依赖建模，在实验中表明了一个简单的L2范数准则可以达到与现代方法相当的性能。</p><p>总之，本文的贡献是针对任何结构修剪的通用修剪方案，称为依赖图（DepGraph），它允许自动参数分组，并有效地提高了各种网络架构（包括CNN、RNN、GNN和Vision Transformer）上结构修剪的可推广性。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul><li><p>剪枝：剪枝算法的设计空间包括一系列方面，包括<strong>剪枝方案、参数选择、层稀疏性和训练技术</strong>。近年来，人们引入了许多稳健的标准，如基于幅度的标准和基于梯度的标准。另一种类型的方法通过稀疏训练来区分不重要的参数，稀疏训练将一些参数推到零以进行修剪。与那些静态标准相比，稀疏训练更可能找到不重要的参数，但由于需要网络训练，因此需要更多的计算资源。最近，还进行了一项综合性研究，以评估各种标准的效果，并提供一个公平的基准。</p></li><li><p>修剪分组参数：依赖性建模是任何结构修剪的关键和前提步骤，因为它涉及同时删除由于复杂的网络架构而在结构上彼此耦合的参数。剪枝分组参数的概念从结构剪枝的早期就已被研究。例如，<strong>当修剪两个连续卷积层时，修剪第一层内的卷积核会导致在后续层中去除与该滤波器相关的核</strong>。最近，已经提出了一些试点工作来解决层之间的复杂关系，并利用分组属性来提高结构修剪性能。</p><p>不幸的是，现有的技术仍然依赖于经验规则或预定义的架构模式，这使得它们在所有结构剪枝应用程序中都不够通用。在本研究中，我们提出了一种解决这一挑战的通用方法，证明了解决参数依赖性有效地推广了广泛网络的结构剪枝，从而在多个任务上获得令人满意的性能。</p></li></ul><h2 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h2><h3 id="神经网络的依赖性"><a href="#神经网络的依赖性" class="headerlink" title="神经网络的依赖性"></a>神经网络的依赖性</h3><p>不失一般性，在全连接层开发本文方法。从由三个连续层组成的线性神经网络开始，如图2 (a)所示，分别由二维<strong>权重矩阵</strong>wl、wl+1和wl+2参数化。这种简单的神经网络可以通过<strong>去除神经元的结构</strong>修剪而变得轻量化。在这种情况下，很容易发现参数之间存在一些依赖关系，表示为wl⇔wl+1, 这<strong>迫使二者同时被修剪</strong>。具体而言，为了修剪连接wl和wl+1的第k个神经元，将移除wl [k, :]和wl+1[:, k]。</p><blockquote><p>当我们希望通过剪枝某个神经元（高亮表示）实现加速时，与该神经元相连的多组参数需要被同时移除，<strong>这些参数就组成了结构化剪枝的最小单元，通常称为组（Group）</strong>。然而，在不同的网络架构中，参数的分组方式通常千差万别。图2（b）-（d）分别可视化了残差结构、拼接结构、以及降维度结构所致的参数分组情况，这些结构甚至可以互相嵌套，从而产生更加复杂的分组模式。</p></blockquote><p>通过手动设计和模型特定的方案来处理层依赖性，以逐个案例的方式手动分析所有这些依赖关系是很难的，更不用说简单的依赖关系可以嵌套或组合成更任意复杂的模式。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240513160026964.png"><p>（<em>图2：在不同的结构中具有相互依赖性的分组参数。必须同时修剪所有突出显示的参数。</em>）</p><p>为了解决结构修剪中的依赖问题，在本文工作中引入了依赖关系图，它为依赖关系建模提供了一种通用的、全自动的机制。</p><h3 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h3><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>为了实现结构化剪枝，首先需要根据层之间的相互依赖关系进行分组。形式上，目标是找到一个分组矩阵G∈R^L*L，其中L是一个待修剪网络的深度，Gij=1表示第i层和第j层之间存在依赖关系。令Diag(G)=1^1×L来保证自依赖。使用分组矩阵，很容易<strong>找到所有与第i层相互依赖的耦合层</strong>，即找到组：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240513161232441.png"><p>然而，由于现代深度网络可能由<strong>数千层复杂的连接</strong>组成，从神经网络中估计分组模式并不简单，他可能产生一个<strong>大而复杂的分组矩阵G</strong>。在这个矩阵中，Gij不仅由第i层和第j层决定，而且还受到它们之间的中间层的影响。这种非局部隐式关系在大多数情况下都不能用简单的规则来处理。为了克服这一挑战，作者没有直接估计分组矩阵G，而是<strong>提出了一种等效但易于估计的依赖建模方法，即依赖图，从中可以有效地推导出G</strong>。</p><h4 id="依赖图-1"><a href="#依赖图-1" class="headerlink" title="依赖图"></a>依赖图</h4><p>考虑一个分组g = {w1, w2, w3}，其中存在依赖关系w1⇔w2，w2⇔w3和1⇔w3。可以观察到<strong>冗余依赖</strong>（例如w1到w3可以通过w1w2，w2w3来推出传递依赖）。首先，我们以w1为起点，并检查它对其他层的依赖性，例如w1⇔w2。此时w2作为新的起点以递归扩展依赖，触发w2⇔w3，<strong>这个递归过程最终以一个传递关系结束</strong>，w1⇔w2⇔w3。在这种情况下，我们只需要两个依赖关系来描述组g中的关系。类似地，第3.2节中讨论的分组矩阵对于依赖关系建模也是冗余的，因此可以在保留相同信息的同时，压缩成更少的边和更紧凑的形式。</p><p><strong>一种新的图D测量相邻层之间的局部相互依赖性，称为依赖图，可以作为分组矩阵G的有效约简。</strong></p><p><strong>依赖图只记录具有直接连接的相邻层之间的依赖关系。</strong>他具有和G一样的顶点，但是有尽可能少的边。形式上，D被构造为，对于所有的Gij = 1，在顶点i和j之间存在一条路径。因此，Gij可以通过检验D中顶点i和j之间的路径的存在来得到。</p><h4 id="网络分解"><a href="#网络分解" class="headerlink" title="网络分解"></a>网络分解</h4><p>在层级之间构建依赖图在实践中可能存在问题。一些基本层，如全连接层，可能有两种不同的修剪方案，如w[k, : ]和w[ : , k]，它们<strong>分别压缩输入和输出的维度</strong>（如前面图2所示，同样的全连接层，要考虑两种剪枝）。此外，网络还包含<strong>非参数化的操作，如跳跃连接</strong>，这也会影响层[40]之间的依赖性。</p><p>对于一个卷积层而言，我们可以对参数的不同维度进行独立的修剪，从而分别剪枝输入通道或者输出通道。然而，上述的依赖图D却无法对这一现象进行建模。为此，我们提出了一种更细粒度的模型描述符，<strong>将网络F（x；w）分解为更精细、更基本的组件</strong>，记为F = {f1，f2，…，fL}，其中每个组件f表示（1）一个参数层如卷积层 或者（2）一个非参数操作如残差连接。<strong>关注层的输入和输出之间的关系而不是在层之间建模</strong>。具体地说，将分量fi的输入和输出分别表示为𝑓𝑖−和𝑓𝑖+。对于任何网络，最终的分解都可以形式化为F = {𝑓1−，𝑓1+，…，𝑓L−，𝑓L+}。这种表示法更容易进行依赖关系建模，并允许<strong>对同一层使用不同的剪枝方案。</strong></p><h4 id="依赖建模"><a href="#依赖建模" class="headerlink" title="依赖建模"></a>依赖建模</h4><p>利用这种符号，我们将神经网络重新定义为方程2，其中可以识别出两种主要的依赖类型，即层间依赖和层内依赖，如下所示：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240516144322342.png" alt="image-20240516144322342" style="zoom:80%;"><p><strong>符号↔表示两个相邻层之间的连通性。</strong>对这两个依赖关系的检查产生了简单但通用的<strong>依赖关系建模规则</strong>：</p><ul><li><p>层间依赖性：依赖性fi−⇔fj+持续出现在连接层中，其中𝑓𝑖−↔𝑓j+。由于一个层的输出和下一层的输入对应的是同一个中间特征（Feature），这就导致两者需要被同时剪枝。例如在通道剪枝中，“某一层的的输出通道剪枝”和“相邻后续层的输入通道剪枝”是等价的。</p></li><li><p>层内依赖性：在神经网络中，我们可以把各种层分为两类：第一类层的输入输出可以独立地进行剪枝，分别拥有不同的剪枝布局（pruning scheme），记作 𝑠𝑐ℎ(𝑓𝑖+) 或者 𝑠𝑐ℎ(𝑓𝑖−) 。例如对于全连接层的2D参数矩阵 𝑤 ，可以得到 𝑤[𝑘,:] 和 𝑤[:,𝑘] 两种不同的布局。这种情况下，输入 𝑓𝑖− 和输出 𝑓𝑖+ 在依赖图中是相互独立、非耦合的；而另一类层输入输出之间存在耦合，例如逐元素运算、Batch Normalization等。他们的参数（如果有）仅有一种剪枝布局，且同时影响输入输出的维度。如果 𝑓𝑖− 和 𝑓𝑖+ 共享相同的修剪方案，则存在依赖 𝑓𝑖− ⇔ 𝑓𝑖+ ，用𝑠𝑐ℎ(𝑓𝑖-) =𝑠𝑐ℎ(𝑓𝑖+) 表示。实际上，相比于复杂的参数耦合类型，深度网络中的层类型是非常有限的，我们可以预先定义不同层的剪枝布局来确定图中的依赖关系。</p></li></ul><p>正式定义如下的依赖关系建模：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240517110026498.png" alt="image-20240517110026498" style="zoom:80%;"><p>其中 ∨ 和 ∧ 分别表示逻辑”OR“和“AND”。第一项检查由<strong>网络连接引起的层间依赖关系</strong>，而第二项检查由<strong>层输入和输出之间的共享剪枝方案所引入的层内依赖关系。</strong></p><p>我们在算法1和算法2中总结了依赖图构建和参数分组的过程，其中参数分组是一个递归的连通分量（Connected Component）搜索问题，可以通过简单深度(DFS)或者宽度(BFS)优先搜索实现。算法2简要描述了这一过程，即以某个节点i作为起始分组g，找到依赖图D中与之相连的新节点j，合并入当前组，直到不存在新的联通节点为止。此处省略了分组的去重处理。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240517112155305.png" alt="image-20240517112155305" style="zoom:80%;"><p>将上述算法应用于一个具体的残差结构块，我们可以得到如下可视化结果。在具体剪枝时，以任意一个节点作为起始点，例如以 𝑓4+ 作为起点，递归地搜索能够访问到的所有其他节点，并将它们归入同一个组进行剪枝。值得注意的是，卷积网络由于输入输出使用了不同的剪枝布局（ 𝑠𝑐ℎ(𝑓4−)≠𝑠𝑐ℎ(𝑓4+) ），在依赖图中其输入输出节点间不存在层内依赖，但是由于skip连接 𝑓7 的存在，递归搜索过程中 𝑓4−和 𝑓4+ 会被分入同一组，即他们依旧需要被同时裁剪。其他层例如Batch Normalization的输入输出则存在简单的层内依赖。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240517105422995.png" alt="image-20240517105422995" style="zoom:80%;"><p>图3。层分组是通过在DepGraph上递归传递实现的（从f4+开始）</p><h3 id="组级别剪枝"><a href="#组级别剪枝" class="headerlink" title="组级别剪枝"></a>组级别剪枝</h3><p>依赖图的一个重要作用是<strong>参数自动分组</strong>，从而实现任意架构的模型剪枝。实际上，依赖图的自动分组能力还可以帮助设计<strong>组级别剪枝（Group-level Pruning）</strong>。在结构化剪枝中，属于同一组的参数会被同时移除，这一情况下需要保证这些被移除参数是“一致冗余”的，如果这些参数中包含对网络预测至关重要的参数，那么移除这些参数难免会损伤性能。</p><p>一个重要问题<strong>是如何在涉及多个耦合层的情况下评估分组参数的重要性程度</strong>。在本节中，作者利用一个简单的norm-based标准来建立一个实用的组级剪枝方法。给定一个参数组g = {w1，w2，…，w|g|}，现有的标准如<strong>L2-norm重要性可以对每一个w产生独立的分数</strong>。估计组重要性的一种自然方法是计算一个聚合分数I(g)=每层分数的求和。但独立估计的各层重要性程度是非加性的，且由于分布和大小的散度而毫无意义。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240605144536610.png" alt="image-20240605144536610"><p>为了使这个简单的聚合能够作用于重要性估计，我们<strong>提出了一种稀疏训练方法来在组级别上稀疏参数</strong>（如图4(c)），这些零化的组就可以安全地从网络中移除。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524101302850.png" alt="image-20240524101302850" style="zoom:80%;"><p>如图4 (c)所示，目标是<strong>学习所有分组层之间的一致稀疏性，同时将某些维度归零为零。</strong>作者<strong>将分组参数扁平化并合并为一个大的参数矩阵（也就是对于分组中的每一层，获取到特定通道的独立的参数组重要性后，展平，然后添加到分组重要性list，构成二维矩阵），其中检索所有属于第k个可调维数的参数，就像CNN块的第k个通道一样</strong>。现在，<strong>一致的稀疏性可以通过一个简单的加权收缩来促进</strong>（采用一个L2正则项，通过赋予参数组的不同正则权重 𝛾 来进行组稀疏化）</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524104156855.png" alt="image-20240524104156855" style="zoom:80%;"><p>其中k用于<strong>可剪枝参数的切片</strong>（Slicing），用于定位当前参数内<strong>第k组参数子矩阵</strong>，上述稀疏算法会得到<strong>k组不同程度稀疏的耦合参数</strong>，我们选择整体L2 norm最小的耦合参数进行剪枝。我们使用一个可控的指数策略来确定γk如下：</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524104920144.png" alt="image-20240524104920144" style="zoom:80%;"><p>经过稀疏训练后，作者进一步使用了一个相对分数<img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524105432943.png" alt="image-20240524105432943" style="zoom: 67%;">来识别和删除不重要的参数。</p><p>实际上，依赖图还可以用于设计各种更强大的<strong>组剪枝方法</strong>，但由于稀疏训练、重要性评估等技术并非DepGraph的主要内容，这里也就不再赘述。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>本文主要关注分类任务，在各种数据集上进行广泛的实验，如用于图像分类的CIFAR和ImageNet，用于图形分类的PPI，用于三维分类的ModelNet，用于文本分类的AGNews。使用模型如概要所述。为了进行ImageNet实验，使用了Torchvision 的现成模型作为原始模型。修剪后，所有模型都将按照与预训练阶段相似的协议进行微调，使用更小的学习率和更少的迭代。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>CIFAR是一个小型的图像数据集，被广泛用于验证剪枝算法的有效性。</p><p>我们利用DepGraph和一致性稀疏构建了一个非常简单的剪枝器，能够在这两种数据集上取得不错的性能。 当然，我们在Imagenet上并没有达到SOTA，因为我们的目标在于通用性而非特定架构上的性能。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524110639744.png" alt="image-20240524110639744" style="zoom:80%;"><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524113933711.png" alt="image-20240524113933711"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="一致性稀疏"><a href="#一致性稀疏" class="headerlink" title="一致性稀疏"></a>一致性稀疏</h4><p>在分析实验中，首先我们首先评估了一致性稀疏和逐层独立稀疏的差异，结论符合3.3中的分析，即<strong>逐层算法无法实现依赖参数的一致稀疏</strong>。例如下图中绿色的直方图表示传统的逐层稀疏策略，相比于本文提出的一致性稀疏，其整体稀疏性表现欠佳。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240524114128417.png" alt="image-20240524114128417" style="zoom:80%;"><h4 id="分组策略"><a href="#分组策略" class="headerlink" title="分组策略"></a>分组策略</h4><p>我们同样对分组策略进行了评估，我们考虑了<strong>无分组（No Grouping）、卷积分组（Conv-only）和全分组（Full Grouping）</strong>三种策略：无分组对参数进行独立稀疏；卷积分组只考虑卷积层而忽略其他参数化的层；全分组将所有参数化的层进行一致性稀疏。实验表明全稀疏在得到更优的结果同时，剪枝的稳定性更高，不容易出现过度剪枝的情况（性能显著下降）。</p><p>另外剪枝的稀疏度如何分配也是一个重要问题，我们测试了算法在<strong>逐层相同稀疏度（Uniform Sparsity）和可学习稀疏度（Learned Sparsity）</strong>下的表现。可学习稀疏度根据稀疏后的参数L2 Norm进行全局排序，从而决定稀疏度。<strong>这一方法假设参数冗余并不是平均分布在所有层的</strong>，对不同层应用了不同的剪枝率，因此一般情况下可以取得更好的性能，这类方法通常也称为全局剪枝（Global Pruning）。但与此同时，<strong>可学习的稀疏度存在过度剪枝风险，即在某一层中移除过多的参数</strong>。下图中可以看到VGG网络出现了过度剪枝的问题，导致Learned Sparsity效果显著低于Uniform Sparsity。在实际应用中，还是需要根据具体网络、评估指标的特点选择合适的稀疏度分配策略。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240601163320807.png" alt="image-20240601163320807" style="zoom:80%;"><h5 id="可学习稀疏度"><a href="#可学习稀疏度" class="headerlink" title="可学习稀疏度"></a>可学习稀疏度</h5><p>层的稀疏性也是剪枝的一个重要因素，它决定了剪枝神经网络的最终结构。表2提供了关于层稀疏性的一些结果。本研究主要关注两种稀疏性，即逐层相同稀疏性和可学习稀疏性。在相同稀疏性的情况下，由于假设了冗余参数通过网络均匀分布，所以对不同的层采用相同的剪枝比。然而，图5中之前的实验表明，不同的层并不是相同的。在大多数情况下，可学习的稀疏性优于均匀的稀疏性，尽管有时它可能会过度修剪某些层，导致精度下降。</p><h5 id="DepGraph的通用性"><a href="#DepGraph的通用性" class="headerlink" title="DepGraph的通用性"></a>DepGraph的通用性</h5><p>表2中的结果也证明了我们的框架的通用性，它能够处理各种卷积神经网络。此外，我们强调我们的方法与DenseNet和GoogleNet兼容，它们包含密集的连接和并行结构。</p><h4 id="依赖图可视化"><a href="#依赖图可视化" class="headerlink" title="依赖图可视化"></a>依赖图可视化</h4><p>由于参数分组的复杂过程，修剪大型神经网络是一个相当大的挑战。然而，通过利用深度图，可以毫不费力地得到所有的耦合群。下图中我们可视化了DenseNet-121、ResNet-18、ViT-Base的依赖图和递归推导得到的分组矩阵，可以发现不同网络的参数依赖关系是复杂且各不相同的。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240601165302830.png" alt="image-20240601165302830" style="zoom:80%;"><h4 id="非图像模型结构化剪枝"><a href="#非图像模型结构化剪枝" class="headerlink" title="非图像模型结构化剪枝"></a>非图像模型结构化剪枝</h4><p> 深度模型不仅仅只有CNN和transformer，我们还对其他架构的深度模型进行了初步验证，包括用于文本分类的LSTM，用于3D点云分类的DGCNN以及用于图数据的GAT，我们的方法都取得了令人满意的结果。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240601165426443.png" alt="image-20240601165426443" style="zoom:80%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提出了一种面向任意架构的结构化剪枝技术DepGraph，极大简化了剪枝的流程。目前，我们的框架已经覆盖了Torchvision模型库中95%的模型，涵盖分类、分割、检测等任务。总体而言，本文工作是第一次尝试开发一种可应用于多种架构（CNNs, RNNs, GNNs, and Transformers）的通用算法。此外，当前大多数剪枝算法都是针对单层设计的，我们的工作为将来“组级别剪枝”的研究提供了一些有用的基础资源。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="权值剪枝器（Magnitude-Pruner）"><a href="#权值剪枝器（Magnitude-Pruner）" class="headerlink" title="权值剪枝器（Magnitude Pruner）"></a>权值剪枝器（Magnitude Pruner）</h3><p>MagnitudePruner是一种利用权值大小定位冗余参数的经典算法，相关技术发表于“Pruning Filters for Efficient ConvNets”一文。作者讨论了一种神经网络中最基础的依赖关系（卷积和残差连接）</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240604114918956.png" alt="image-20240604114918956"><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240604115208636.png" alt="image-20240604115208636"><h4 id="tp实现"><a href="#tp实现" class="headerlink" title="tp实现"></a>tp实现</h4><p>类tp.importance.Importance要求我们实现一个非常简单的接口__call__，其中输入参数是一个group，它包含了多个相互耦合的层。该函数的输出则是一个<strong>一维的重要性得分向量</strong>，其含义是每个通道的重要性，因此他的维度和通道数通常是相同的。由于输入的Group通常会包含多个可剪枝层，因此我们<strong>首先对这些层进行独立的重要性计算，然后通过求平均值得到最终结果</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch_pruning <span class="token keyword">as</span> tp<span class="token keyword">class</span> <span class="token class-name">MyMagnitudeImportance</span><span class="token punctuation">(</span>tp<span class="token punctuation">.</span>importance<span class="token punctuation">.</span>Importance<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> group<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 1. 首先定义一个列表用于存储分组内==每一层==的重要性</span>        group_imp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token comment"># 2. 迭代分组内的各个层，对Conv层计算重要性</span>        <span class="token keyword">for</span> dep<span class="token punctuation">,</span> idxs <span class="token keyword">in</span> group<span class="token punctuation">:</span> <span class="token comment"># idxs是一个包含所有可剪枝索引的列表，用于处理DenseNet中的局部耦合的情况</span>            layer <span class="token operator">=</span> dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span>module <span class="token comment"># 获取 nn.Module</span>            prune_fn <span class="token operator">=</span> dep<span class="token punctuation">.</span>handler    <span class="token comment"># 获取 剪枝函数</span>            <span class="token comment"># 3. 这里我们简化问题，仅计算卷积输出通道的重要性</span>            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>layer<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">)</span> <span class="token keyword">and</span> prune_fn <span class="token operator">==</span> tp<span class="token punctuation">.</span>prune_conv_out_channels<span class="token punctuation">:</span>                w <span class="token operator">=</span> layer<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">[</span>idxs<span class="token punctuation">]</span><span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 用索引列表获取耦合通道对应的参数，并展开成2维</span>                local_norm <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 计算==每个通道参数子矩阵的 L1 Norm==</span>                group_imp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>local_norm<span class="token punctuation">)</span> <span class="token comment"># 将其保存在列表中</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>group_imp<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span> <span class="token comment"># 跳过不包含卷积层的分组</span>        <span class="token comment"># 4. 按通道计算平均重要性</span>        group_imp <span class="token operator">=</span> torch<span class="token punctuation">.</span>stack<span class="token punctuation">(</span>group_imp<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> group_imp <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于每个Group，我们计算了其中卷积层输出通道的重要性，然后求平均值得到最终的评估结果。基于上述代码，一个MagnitudePruner实际上已经完成了，但是参数修剪由谁来执行呢？Torch-Pruning库定义了一个元剪枝器tp.pruner.MetaPruner，能够帮助我们完成除了重要性评估之外的所有工作。因此，我们现在可以开始执行剪枝了。为了增加难度，这里我们对一个DenseNet模型进行剪枝：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> torchvision<span class="token punctuation">.</span>models <span class="token keyword">import</span> densenet121<span class="token keyword">import</span> torch_pruning <span class="token keyword">as</span> tpmodel <span class="token operator">=</span> densenet121<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>example_inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token comment"># 1. 使用我们上述定义的重要性评估</span>imp <span class="token operator">=</span> MyMagnitudeImportance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 2. 忽略无需剪枝的层，例如最后的分类层</span>ignored_layers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> m <span class="token keyword">in</span> model<span class="token punctuation">.</span>modules<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">)</span> <span class="token keyword">and</span> m<span class="token punctuation">.</span>out_features <span class="token operator">==</span> <span class="token number">1000</span><span class="token punctuation">:</span>        ignored_layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token comment"># DO NOT prune the final classifier!</span><span class="token comment"># 3. 初始化剪枝器</span>iterative_steps <span class="token operator">=</span> <span class="token number">5</span> <span class="token comment"># 迭代式剪枝，重复5次Pruning-Finetuning的循环完成剪枝。</span>pruner <span class="token operator">=</span> tp<span class="token punctuation">.</span>pruner<span class="token punctuation">.</span>MetaPruner<span class="token punctuation">(</span>    model<span class="token punctuation">,</span>    example_inputs<span class="token punctuation">,</span> <span class="token comment"># 用于分析依赖的伪输入</span>    importance<span class="token operator">=</span>imp<span class="token punctuation">,</span> <span class="token comment"># 重要性评估指标</span>    iterative_steps<span class="token operator">=</span>iterative_steps<span class="token punctuation">,</span> <span class="token comment"># 迭代剪枝，设为1则一次性完成剪枝</span>    ch_sparsity<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token comment"># 目标稀疏性，这里我们移除50%的通道 ResNet18 = {64, 128, 256, 512} =&gt; ResNet18_Half = {32, 64, 128, 256}</span>    ignored_layers<span class="token operator">=</span>ignored_layers<span class="token punctuation">,</span> <span class="token comment"># 忽略掉最后的分类层</span><span class="token punctuation">)</span><span class="token comment"># 4. Pruning-Finetuning的循环</span>base_macs<span class="token punctuation">,</span> base_nparams <span class="token operator">=</span> tp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>count_ops_and_params<span class="token punctuation">(</span>model<span class="token punctuation">,</span> example_inputs<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>iterative_steps<span class="token punctuation">)</span><span class="token punctuation">:</span>    pruner<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 执行裁剪，本例子中我们每次会裁剪10%，共执行5次，最终稀疏度为50%</span>    macs<span class="token punctuation">,</span> nparams <span class="token operator">=</span> tp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>count_ops_and_params<span class="token punctuation">(</span>model<span class="token punctuation">,</span> example_inputs<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"  Iter %d/%d, Params: %.2f M =&gt; %.2f M"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> iterative_steps<span class="token punctuation">,</span> base_nparams <span class="token operator">/</span> <span class="token number">1e6</span><span class="token punctuation">,</span> nparams <span class="token operator">/</span> <span class="token number">1e6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"  Iter %d/%d, MACs: %.2f G =&gt; %.2f G"</span><span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> iterative_steps<span class="token punctuation">,</span> base_macs <span class="token operator">/</span> <span class="token number">1e9</span><span class="token punctuation">,</span> macs <span class="token operator">/</span> <span class="token number">1e9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># finetune your model here</span>    <span class="token comment"># finetune(model)</span>    <span class="token comment"># ...</span><span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Slimming剪枝器"><a href="#Slimming剪枝器" class="headerlink" title="Slimming剪枝器"></a>Slimming剪枝器</h3><p>在上文中，我们介绍了如何快速实现一个简单的权值剪枝算法，它直接作用于模型的参数上，选取那些相对较小的参数进行裁剪。然而，实际上<strong>一个模型中的各个参数权值大小可能非常接近，因此我们难以直接根据参数大小来判断其重要性</strong>。针对这一问题，于ICCV2017会议上发表的slimming算法提出了一种经典的解决方案：利用Batch Normalization的scale参数完成重要性评估。</p><p>…………</p><h2 id="LLM剪枝"><a href="#LLM剪枝" class="headerlink" title="LLM剪枝"></a>LLM剪枝</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>LLM压缩与传统网络压缩区别：</p><ol><li><p><strong>模型规模：</strong>第一个主要差异来自LLM的巨大参数量，这导致许多侧重训练（Training-heavy）的压缩方案，例如知识蒸馏[1]变得较为困难.</p></li><li><p><strong>海量训练语料</strong>：许多LLMs经历了1万亿甚至更大规模的tokens上的训练[3]，这导致许多依赖于原始数据或收集替代数据的方案变得尤其昂贵。</p></li><li><p><strong>任务无关的模型压缩：</strong>现有的压缩算法通常针对单一、特定的任务进行压缩，而LLMs是很优秀的多任务处理器，在压缩过程中我们不希望折损LLM的通用性和多功能性。</p></li></ol><p>我们需要一种能够避免大规模重新训练、且能保持模型原有能力的压缩方法。现有的较为可行的两种方案是【模型量化】和【网络剪枝】<strong>。</strong>其中模型量化侧重于降低推理阶段的存储开销以及提升计算速度，而网络剪枝则移除部分参数实现压缩，两种方案可以相互结合达到最优性能。</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240605165433575.png" alt="image-20240605165433575" style="zoom:80%;"><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><p><strong>1.训练语料库规模巨大</strong>：以往的压缩方法严重依赖于训练语料库。LLM已经将语料库规模升级到1万亿token。巨大的存储需求和漫长的传输时间使数据集难以获取。</p><p><strong>2.修建后的LLM的后训练时间巨大</strong>：现有的方法需要大量的时间来后训练生成的小模型。例如，在TinyBERT中的一般蒸馏大约需要14 GPU天。即使是后训练特定任务的BERT压缩模型也需要大约33小时。随着llm的模型和语料库的大小迅速增加，这一步骤必然会消耗更长的时间。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>遵循常规的剪枝流程，LLM-Pruner包含三个步骤：发现阶段，估计阶段，恢复阶段。</p><p>(1) 发现阶段：这一步聚焦于识别LLM内部相互依赖的结构，这些相互依赖的结构需要被同时移除已确保剪枝后结构的正确性。</p><p>(2) 估计阶段：一旦耦合结构被分组，第二步就包含估计每个组对模型总体性能的贡献，并决定要剪枝的组。</p><p>(3) 恢复阶段：这一步涉及到快速的后训练，用于缓解由于结构删除而可能引起的性能降级。</p><h4 id="依赖分组"><a href="#依赖分组" class="headerlink" title="依赖分组"></a>依赖分组</h4><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240605170758309.png" alt="image-20240605170758309" style="zoom:80%;"><p>Ni指向Nj，且Nj入度为1。则Nj依赖于Ni。</p><p>Nj唯一依赖于Ni，则Ni与Nj在同一组</p><img src="/2024/05/13/depgraph-towards-any-structural-pruning/image-20240606144246633.png" alt="image-20240606144246633" style="zoom:80%;"><p>图2: LLaMA中耦合结构的示例。我们简化了每层的神经元以清晰地展示依赖组。剪枝的起始神经元被铃图案所标记，这一操作会导致具有依赖性的权重被剪枝（虚线），并继续传播到耦合神经元（虚线圆圈）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>CVPR 2023 | DepGraph 通用结构化剪枝：<a href="https://zhuanlan.zhihu.com/p/619146631">https://zhuanlan.zhihu.com/p/619146631</a></p><p>模型加速｜CNN与ViT模型都适用的结构化剪枝方法（一）：<a href="https://developer.aliyun.com/article/1231617">https://developer.aliyun.com/article/1231617</a></p><p>【深度学习之模型优化】模型剪枝、模型量化、知识蒸馏概述：<a href="https://blog.csdn.net/qq_51831335/article/details/126660743">https://blog.csdn.net/qq_51831335/article/details/126660743</a></p><p>Torch-Pruning | 轻松实现结构化剪枝算法： <a href="https://zhuanlan.zhihu.com/p/619482727">https://zhuanlan.zhihu.com/p/619482727</a></p><p>YOLOv8模型剪枝实战： <a href="https://www.bilibili.com/video/BV1iA4m1F7zf/?vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1iA4m1F7zf/?vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>NeurIPS 2023 | LLM-Pruner: 大语言模型的结构化剪枝： <a href="https://zhuanlan.zhihu.com/p/630902012">https://zhuanlan.zhihu.com/p/630902012</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DepGraph-Towards-Any-Structural-Pruning&quot;&gt;&lt;a href=&quot;#DepGraph-Towards-Any-Structural-Pruning&quot; class=&quot;headerlink&quot; title=&quot;DepGraph: Towa</summary>
      
    
    
    
    <category term="论文" scheme="http://wolf-ll.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="LLM" scheme="http://wolf-ll.github.io/tags/LLM/"/>
    
    <category term="压缩" scheme="http://wolf-ll.github.io/tags/%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="推理加速" scheme="http://wolf-ll.github.io/tags/%E6%8E%A8%E7%90%86%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://wolf-ll.github.io/2024/05/11/redis/"/>
    <id>http://wolf-ll.github.io/2024/05/11/redis/</id>
    <published>2024-05-11T06:14:39.000Z</published>
    <updated>2025-03-19T09:18:52.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>使用阿里云hit账号数据库，密码首字母大写</p><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li><strong>单线程</strong>，每个命令具备原子性</li><li>低延迟，速度快（<strong>基于内存</strong>、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p>NoSql</p></li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json</p><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。也称为<strong>非关系型数据库</strong>。</p><p>sql vs nosql：</p><ul><li><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：<strong>字段名、字段数据类型、字段约束</strong>等等信息，插入的数据必须遵守这些约束。而NoSql则对数据库格式没有严格约束，往往<strong>形式松散，自由</strong>。可以是键值型，也可以是文档型或者图格式。</p></li><li><p>传统数据库的表与表之间往往存在关联，例如外键。而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  name<span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>  orders<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>       id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>       item<span class="token operator">:</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">"荣耀6"</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token number">4999</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>       id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>       item<span class="token operator">:</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">"小米11"</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token number">3999</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><img src="/2024/05/11/redis/AzaHOTF.png" style="zoom:67%;"></li><li><p>传统关系型数据库能满足事务ACID的原则。而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现<strong>基本的一致性</strong>。</p></li></ul><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><img src="/2024/05/11/redis/1.png" style="zoom: 67%;"><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的<strong>磁盘IO</strong>，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是<strong>依赖于内存来操作，内存的读写速度会非常快</strong>，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以<strong>将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展</strong>。</li><li><strong>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</strong></li></ul></li></ul><h2 id="初识redis"><a href="#初识redis" class="headerlink" title="初识redis"></a>初识redis</h2><h3 id="linux启动"><a href="#linux启动" class="headerlink" title="linux启动"></a>linux启动</h3><h4 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h4><p>安装完成后，在任意目录输入redis-server命令即可启动Redis</p><img src="/2024/05/11/redis/v7xWsqC.png" style="zoom:67%;"><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h4 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf</p><p>我们先将这个配置文件备份一份：</p><pre class="line-numbers language-none"><code class="language-none">cp redis.conf redis.conf.bck<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>然后修改redis.conf文件中的一些配置：</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><span class="token key attr-name">bind</span> <span class="token value attr-value">0.0.0.0</span><span class="token comment"># 守护进程，修改为yes后即可后台运行</span><span class="token key attr-name">daemonize</span> <span class="token value attr-value">yes </span><span class="token comment"># 密码，设置后访问Redis必须输入密码</span><span class="token key attr-name">requirepass</span> <span class="token value attr-value">123321</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis的其它常见配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 监听的端口</span><span class="token key attr-name">port</span> <span class="token value attr-value">6379</span><span class="token comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><span class="token key attr-name">dir</span> <span class="token value attr-value">.</span><span class="token comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><span class="token key attr-name">databases</span> <span class="token value attr-value">1</span><span class="token comment"># 设置redis能够使用的最大内存</span><span class="token key attr-name">maxmemory</span> <span class="token value attr-value">512mb</span><span class="token comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><span class="token key attr-name">logfile</span> <span class="token value attr-value">"redis.log"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>启动Redis：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入redis安装目录 </span><span class="token builtin class-name">cd</span> /usr/local/src/redis-6.2.6<span class="token comment"># 启动</span>redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>停止服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><span class="token comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span>redis-cli <span class="token parameter variable">-u</span> <span class="token number">123321</span> <span class="token function">shutdown</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512130026010.png" style="zoom:67%;"><h4 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h4><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/systemd/system/redis.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容如下：</p><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>然后重载系统服务：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们可以用下面这组命令来操作redis了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动</span>systemctl start redis<span class="token comment"># 停止</span>systemctl stop redis<span class="token comment"># 重启</span>systemctl restart redis<span class="token comment"># 查看状态</span>systemctl status redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行下面的命令，可以让redis开机自启：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Redis桌面客户端"><a href="#Redis桌面客户端" class="headerlink" title="Redis桌面客户端"></a>Redis桌面客户端</h3><h4 id="命令行客户端"><a href="#命令行客户端" class="headerlink" title="命令行客户端"></a>命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-cli <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>commonds<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的<strong>IP地址</strong>，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p><strong>不指定commond时，会进入<code>redis-cli</code>的交互控制台</strong></p><img src="/2024/05/11/redis/OYYWPNo.png" style="zoom:80%;"><h4 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h4><p>RedisDesktopManager：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><p>Redis默认有20个仓库，编号从0至19.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><img src="/2024/05/11/redis/image-20240512133415507.png" style="zoom:67%;"><h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h2><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><img src="/2024/05/11/redis/8tli2o9.png" style="zoom:67%;"><p>官方文档与数据类型分组：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></p><img src="/2024/05/11/redis/image-20240512133753203.png" style="zoom:67%;"><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">keys *查看当前库所有key exits key  判断某个key是否存在 <span class="token builtin class-name">type</span> key  查看key是什么类型 del key删除指定的key数据 unlink key根据value选择非阻塞删除（仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作） expire key <span class="token number">10</span>  为给定的key设置过期时间（10s） ttl key查看还有多少秒过期：-1表示永不过期，-2表示已经过期 <span class="token keyword">select</span>切换数据库 dbsize查看当前数据库的key数量 flushdb清空当前库 flushall  通杀全部库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  添加或修改键值对（key存在时，set覆盖旧值） get <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  查询对应键值 append <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  将给定的value追加到原值的末尾 strlen <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  获得值的长度 setnx <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  只有key不存在时，设置key值 incr <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  将key中储存的数字值增1，<span class="token operator">==</span><span class="token operator">=</span>只能对数字值操作<span class="token operator">==</span><span class="token operator">=</span>，如果为空，新增值为1incrby <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> xx 让一个整型的key自增并指定步长，例如：incrby num <span class="token number">2</span> 让num值自增2incrbyfloat <span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span> xx 让一个浮点型的key自增并指定步长decr <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  将key中储存的数字值建减1，只能对数字值操作，如果为空，新增值为-1 incrby / decrvy <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>步长<span class="token operator">&gt;</span>  将key中储存的数字值增减，自定义步长 mset <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……  批量添加一个或多个 key-value 对 mget <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span>……  批量获取一个或多个value msetnax  <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……  同时设置一个或多个key-value对，当且仅当所有给定key都不存在 getrange <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>起始位置<span class="token operator">&gt;</span><span class="token operator">&lt;</span>结束位置<span class="token operator">&gt;</span>  获得值的范围，类似java中的substring，前包，后包 setrange <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>起始位置<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  用<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>覆写<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>所存储的字符串值，从起始位置开始（索引从0开始） setex <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>过期时间<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  设置键值的同时，设置过期时间（单位：秒） getset <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  以新换旧，设置了新值的同时获得旧值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="key结构"><a href="#key结构" class="headerlink" title="key结构"></a>key结构</h4><p>Redis没有类似MySQL中的Table的概念，我们该如何区分<strong>不同类型的key</strong>呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分：Redis的key允许<strong>有多个单词形成层级结构，多个单词之间用’:’隔开</strong>，格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">项目名:业务名:类型:id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样我们就可以把不同类型的数据区分开了。从而<strong>避免了key的冲突问题。</strong></p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以<strong>将对象序列化为JSON字符串后存储：</strong></p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><img src="/2024/05/11/redis/image-20240512143035672.png" style="zoom:80%;"><p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p><img src="/2024/05/11/redis/image-20240512143224071.png" style="zoom:80%;"><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash类型，也叫散列，其value是一个无序字典（<code>Hash</code>是一个<code>String</code>类型的<code>Field</code>和<code>Value</code>的映射表），类似于HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便；<strong>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。</strong></p><img src="/2024/05/11/redis/VF2EPt0.png"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hset <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  给<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>集合中的<span class="token operator">&lt;</span>filed<span class="token operator">&gt;</span>键赋值<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>，可以添加也可以修改 hget <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span>  从<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>集合<span class="token operator">&lt;</span>field<span class="token operator">&gt;</span>取出value hmset <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……  批量设置hash的值hmget <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>field<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token punctuation">..</span>.  批量获取hash的field的值 hexits <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>filed<span class="token operator">&gt;</span>  查看哈希表key中，给定域field是否存在 hkeys <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  列出该hash集合key的所有field hvals <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  列出该hash集合的所有value hincrby <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span><span class="token operator">&lt;</span>increment<span class="token operator">&gt;</span>  为哈希表key中的域field的值加上增量（自增自减）并指定步长 hsetnx <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>field<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  将哈希表key中的域field的值设置为value，当且仅当域field不存在hgetall <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> 获取一个hash类型的key中的所有的field和value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512144509760.png" style="zoom:80%;"><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li><strong>有序</strong></li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lpush / rpush <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span>……  从左边（头插法）/右边（尾插法）插入一个或多个值 lpop / rpop <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  从左边/右边移除并返回第一个值，没有则返回null rpoplpush <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>  从<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>列表右边移除一个值，插到<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>列表左边 lrange <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>start<span class="token operator">&gt;</span><span class="token operator">&lt;</span>stop<span class="token operator">&gt;</span>  按照索引下标获得元素（从左到右） eg：lrange mylist <span class="token number">0</span> <span class="token parameter variable">-1</span>  <span class="token number">0</span>左边第一个，-1右边第一个（0 <span class="token parameter variable">-1</span> 表示获取所有） lindex <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>index<span class="token operator">&gt;</span>  按照索引下标获得元素（从左到右） llen <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  获得列表长度 linsert <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> before <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span><span class="token operator">&lt;</span>newvalue<span class="token operator">&gt;</span>  在<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>后面插入<span class="token operator">&lt;</span>newvalue<span class="token operator">&gt;</span>插入值 lrem <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>n<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  从左起删除n个vlaue（从左到右） lset <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>index<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  将列表key下标为index的值替换成value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">LPUSH <span class="token function">users</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>RPUSH <span class="token function">users</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>结果是users中包含 <span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>LRANGE <span class="token function">users</span> <span class="token number">1</span> <span class="token number">2</span>结果是<span class="token punctuation">[</span><span class="token string">"1"</span>,<span class="token string">"4"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li><strong>元素不可重复</strong></li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sadd <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……将一个或多个元素加入到集合key中，已经存在的元素将被忽略srem <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>……删除集合中的指定元素 smembers <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>取出该集合的所有值 sismember <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>判断集合<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>是否包含该<span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>值，有1，没有0 scard <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>返回该集合的元素个数 spop <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>随机从该集合中吐出一个值 srandmember <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>n<span class="token operator">&gt;</span>随机从该集合中取出n个值，不会从集合中删除 smove <span class="token operator">&lt;</span>source<span class="token operator">&gt;</span><span class="token operator">&lt;</span>destination<span class="token operator">&gt;</span>value把集合中的一个值从一个集合移动到另一额集合 sinter<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>返回两个集合的交集元素 sunion <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>返回两个集合的并集元素 <span class="token function">sdiff</span> <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>返回两个集合的差集元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sadd s1 a b c<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> smembers s1<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"c"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"b"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"a"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> srem s1 a<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>    <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SISMEMBER s1 a<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>    <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SISMEMBER s1 b<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>    <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SCARD s1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SortedSet（Zset）"><a href="#SortedSet（Zset）" class="headerlink" title="SortedSet（Zset）"></a>SortedSet（Zset）</h3><p>Redis的SortedSet是一个<strong>可排序的set集合</strong>，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于<strong>score属性对元素排序</strong>，底层的实现是<strong>一个跳表（SkipList）加 hash表</strong>。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><pre class="line-numbers language-none"><code class="language-none">zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;……  将一个或多个member元素及其score值加入到有序集key中，若已存在则覆盖score值 zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]  返回有序集key中，下标在strart到stop之间的元素（带WITHSCORES，可以让分数一起返回） zrangebyscore key min max [withscores][limit offset count]  返回有序集key中，所有score值介于min和max之间的成员(从小到大) zrevrangebyscore key max min [withscores][limit offet count]  同上，从大到小排序 zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;  让sorted set中的指定元素自增，步长为指定的increment值 zrem &lt;key&gt;&lt;value&gt;  删除该集合下，指定元素value zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;  统计该集合，分数区间内的元素个数 zrank &lt;key&gt;&lt;value&gt;  返回该值在集合中的排名，从0开始zscore &lt;key&gt;&lt;value&gt; 获取sorted set中的指定元素的score值zcard &lt;key&gt; 获取sorted set中的元素个数ZDIFF.ZINTER.ZUNION：求差集.交集.并集<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>将班级的下列学生得分存入Redis的SortedSet中：</p><p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p><p>并实现下列功能：</p><ul><li>删除Tom同学</li><li>获取Amy同学的分数</li><li>获取Rose同学的排名</li><li>查询80分以下有几个学生</li><li>给Amy同学加2分</li><li>查出成绩前3名的同学</li><li>查出成绩80分以下的所有同学</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ZADD studs <span class="token number">85</span> Jack <span class="token number">89</span> Lucy <span class="token number">82</span> Rose <span class="token number">95</span> tom <span class="token number">78</span> Jerry <span class="token number">92</span> Amy <span class="token number">76</span> Miles<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512152116142.png" style="zoom:80%;"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zrem studs tomzrank studs Rose排名2zrevrank studs Rose排名3（倒数4）zcount studs <span class="token number">0</span> <span class="token number">80</span>结果2人zincrby studs <span class="token number">2</span> Amy结果94.0分zrange studs <span class="token number">0</span> <span class="token number">2</span>结果<span class="token punctuation">[</span><span class="token string">"Miles"</span>,<span class="token string">"Rose"</span>,<span class="token string">"Jerry"</span><span class="token punctuation">]</span>zrangebyscore studs <span class="token number">0</span> <span class="token number">80</span>结果<span class="token punctuation">[</span><span class="token string">"Miles"</span>,<span class="token string">"Jerry"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><pre class="line-numbers language-none"><code class="language-none">setbit &lt;key&gt;&lt;offset&gt;&lt;value&gt;  设置Bitmaps中某个偏移量的值（0或1）（offset：偏移量从0开始） getbit &lt;key&gt;&lt;offset&gt;  获取Bitmaps中某个偏移量的值 bitcount &lt;key&gt;[start end]  统计字符串从start字节到end字节比特值为1的量 bitop and(or/not/xor) &lt;destkey&gt; [key] 复合操作，可以做多个bitmaps的交集(and)、并集(or)、非(not)、异或(xor)操作并将结果保存在destkey中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><pre class="line-numbers language-none"><code class="language-none">pfadd &lt;key&gt;&lt;element&gt;[element……]  添加指定元素到HyperLogLog中 pfcount &lt;key&gt; [key……]  计算HLL的近似基数，可以计算多个HLL（比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可） pfmerge &lt;destkey&gt;&lt;sourcekey&gt;[sourcekey……]  将一个或多个HLL合并后的结果存储在另一个HLL中（比如每月活跃用户可以使用每天的活页用户来合并计算可得）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><pre class="line-numbers language-none"><code class="language-none">geoadd &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;&lt;member&gt;[longitude lattitude member……] 添加地理位置（经度、维度、名称） geopos &lt;key&gt;&lt;member&gt;[member……]  获得指定地区的坐标值 geodist &lt;key&gt;&lt;member1&gt;&lt;member2&gt; [m|km|ft|mi]  获取两个位置之间的直线距离 georadius &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;radius m|km|ft|mi以给定的经纬度为中心，找出某一半径内的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p>其中Java客户端也包含很多：</p><img src="/2024/05/11/redis/image-20240512153303012.png"><p>标记为*的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而<strong>SpringDataRedis又对这两种做了抽象和封装</strong>，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是<strong>在Redis基础上实现了分布式的可伸缩的java数据结构</strong>，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h3 id="Jedis客户端"><a href="#Jedis客户端" class="headerlink" title="Jedis客户端"></a>Jedis客户端</h3><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> redisTest <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Jedis</span> jedis<span class="token punctuation">;</span>    <span class="token annotation punctuation">@BeforeEach</span>    <span class="token keyword">void</span> <span class="token function">setUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 建立连接</span>        jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"ip"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 选择库</span>        jedis<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 存入数据</span>    <span class="token class-name">String</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"虎哥"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result = "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取数据</span>    <span class="token class-name">String</span> name <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 插入hash数据</span>    jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hgetAll</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>释放资源</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@AfterEach</span><span class="token keyword">void</span> <span class="token function">tearDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>jedis <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="jedis连接池"><a href="#jedis连接池" class="headerlink" title="jedis连接池"></a>jedis连接池</h4><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisConnectionFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">JedisPool</span> jedisPool<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token comment">// 配置连接池</span>        <span class="token class-name">JedisPoolConfig</span> poolConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 最大空闲连接</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMinIdle</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 最小空闲连接</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 没有连接时，最多等待1000ms</span>        <span class="token comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span>        jedisPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>poolConfig<span class="token punctuation">,</span> <span class="token string">"ip"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Jedis</span> <span class="token function">getJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了<strong>对不同Redis客户端的整合（Lettuce和Jedis）</strong></li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><img src="/2024/05/11/redis/UFlNIV0.png" style="zoom:80%;"><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- spring-data-redis--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--common-pool--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--Jackson依赖--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h4><p>application.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># REDIS (RedisProperties)</span><span class="token comment"># Redis数据库索引（默认为0）</span><span class="token key attr-name">spring.data.redis.database</span><span class="token punctuation">=</span><span class="token value attr-value">0</span><span class="token comment"># Redis服务器地址</span><span class="token key attr-name">spring.data.redis.host</span><span class="token punctuation">=</span><span class="token value attr-value">ip</span><span class="token comment"># Redis服务器连接端口</span><span class="token key attr-name">spring.data.redis.port</span><span class="token punctuation">=</span><span class="token value attr-value">6379</span><span class="token comment"># Redis服务器连接密码（默认为空）</span><span class="token key attr-name">spring.data.redis.password</span><span class="token punctuation">=</span><span class="token value attr-value">pwd</span><span class="token comment"># 连接池最大连接数（使用负值表示没有限制）</span><span class="token key attr-name">spring.data.redis.jedis.pool.max-active</span><span class="token punctuation">=</span><span class="token value attr-value">8</span><span class="token comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><span class="token key attr-name">spring.data.redis.jedis.pool.max-wait</span><span class="token punctuation">=</span><span class="token value attr-value">1000</span><span class="token comment"># 连接池中的最大空闲连接</span><span class="token key attr-name">spring.data.redis.jedis.pool.max-idle</span><span class="token punctuation">=</span><span class="token value attr-value">8</span><span class="token comment"># 连接池中的最小空闲连接</span><span class="token key attr-name">spring.data.redis.jedis.pool.min-idle</span><span class="token punctuation">=</span><span class="token value attr-value">0</span><span class="token comment"># 连接超时时间（毫秒）</span><span class="token key attr-name">spring.data.redis.timeout</span><span class="token punctuation">=</span><span class="token value attr-value">5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注入RedisTemplate，测试"><a href="#注入RedisTemplate，测试" class="headerlink" title="注入RedisTemplate，测试"></a>注入RedisTemplate，测试</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">SpringRedisApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 写入string</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"胡歌"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取string数据</span>        <span class="token class-name">Object</span> name <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> name <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user:2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h4><p><strong>RedisTemplate默认采用JDK的序列化工具，可以接收任意Object作为值写入Redis，序列化为字节形式，在redis中可读性很差且内存占用大。</strong><br>修改默认的序列化方式为jackson</p><p>我们可以自定义RedisTemplate的序列化方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> connectionFactory<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 创建RedisTemplate对象</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置连接工厂</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建JSON序列化工具</span>        <span class="token class-name">GenericJackson2JsonRedisSerializer</span> jsonRedisSerializer <span class="token operator">=</span>             <span class="token keyword">new</span> <span class="token class-name">GenericJackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置Key的序列化</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置Value的序列化</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/05/11/redis/image-20240512170814734.png" style="zoom:80%;"><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><img src="/2024/05/11/redis/image-20240512170944012.png"><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，<strong>其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</strong></p><h4 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h4><p>为了<strong>节省内存空间</strong>，我们可以<strong>不使用JSON序列化器来处理value，而是统一使用String序列化器</strong>，要求<strong>只能存储String类型的key和value</strong>。当需要存储Java对象时，<strong>手动完成对象的序列化和反序列化。</strong></p><p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">RedisStringTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 写入一条String数据</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"verify:phone:13600527634"</span><span class="token punctuation">,</span> <span class="token string">"124143"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取string数据</span>        <span class="token class-name">Object</span> name <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// JSON序列化工具</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ObjectMapper</span> mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testSaveUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">JsonProcessingException</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建对象</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"虎哥"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 手动序列化</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写入数据</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user:200"</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取数据</span>        <span class="token class-name">String</span> jsonUser <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user:200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 手动反序列化</span>        <span class="token class-name">User</span> user1 <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>jsonUser<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user1 = "</span> <span class="token operator">+</span> user1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user:400"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"虎哥"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user:400"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> entries <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token string">"user:400"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"entries = "</span> <span class="token operator">+</span> entries<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h3><p>性能优化（1）Redis <strong>基于内存</strong>，内存的访问速度比磁盘快很多；（2）Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是<strong>单线程事件循环和 IO 多路复用</strong>（Redis 线程模式后面会详细介绍到）；（3）Redis 内置了多种<strong>优化过后的数据类型/结构实现</strong>，性能非常高。（4）Redis 通信协议实现简单且解析高效。</p><img src="https://javaguide.cn/assets/why-redis-so-fast-TbWX24ja.png" alt="why-redis-so-fast" style="zoom: 33%;"><h3 id="分布式缓存方案"><a href="#分布式缓存方案" class="headerlink" title="分布式缓存方案"></a>分布式缓存方案</h3><p><strong>Memcached</strong></p><ul><li><p><strong>简介</strong>：Memcached 是一个高性能的分布式内存对象缓存系统，它最初是为了加速动态 Web 应用程序而开发的，通过在内存中缓存数据和对象，减少对数据库等后端存储的访问，从而提高应用程序的响应速度。</p></li><li><p><strong>适用场景</strong>：适用于对缓存读写性能要求极高、数据更新频率不高且<strong>允许数据丢失</strong>的场景，如网页缓存、热门数据缓存等。</p></li></ul><p>对比：</p><ul><li><strong>数据类型</strong>：Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Memcached 只支持最简单的 k/v 数据类型。</li><li><strong>数据持久化</strong>：Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 把数据全部存在内存之中，一旦服务器重启或崩溃，内存中的数据将全部丢失。也就是说，Redis 有灾难恢复机制而 Memcached 没有。</li><li><strong>集群模式支持</strong>：Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 自 3.0 版本起是原生支持集群模式的。</li><li><strong>线程模型</strong>：Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 针对网络数据的读写引入了多线程）</li><li><strong>特性支持</strong>：Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</li><li><strong>过期数据删除</strong>：Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</li></ul><h3 id="redis优点"><a href="#redis优点" class="headerlink" title="redis优点"></a>redis优点</h3><p><strong>1、访问速度更快</strong> 传统数据库数据保存在磁盘，而 Redis 基于内存，内存的访问速度比磁盘快很多。引入 Redis 之后，我们可以把一些高频访问的数据放到 Redis 中，这样下次就可以直接从内存中读取，速度可以提升几十倍甚至上百倍。</p><p><strong>2、高并发</strong> 一般像 MySQL 这类的数据库的 QPS 大概都在 4k 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 5w+，甚至能达到 10w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p><blockquote><p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p></blockquote><p>由此可见，<strong>直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的</strong>，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也<strong>就提高了系统整体的并发。</strong></p><p><strong>3、功能全面</strong> Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景，</p><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><img src="https://i-blog.csdnimg.cn/blog_migrate/388f43060891ccdae94082a154e1ad54.png" alt="img" style="zoom:50%;"><h4 id="String底层"><a href="#String底层" class="headerlink" title="String底层"></a>String底层</h4><p>应用场景：</p><ul><li>常规数据（比如 <strong>Session、Token、序列化后的对象、图片的路径</strong>）的缓存；</li><li><strong>计数</strong>比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数</li><li><strong>分布式锁</strong>(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li></ul><p>存储对象时和Hash对比：</p><ul><li>String适合存储嵌套结构较多或结构复杂的对象，可以直接存储整个对象序列化数据，操作简单，读写性能好，多数情况下更适合；</li><li>Hash适合需要频繁对指定字段做修改或查询的对象，占用内存比String小，特别是字段多且字段长度短的情况（底层ziplist存储优化），操作开销大</li></ul><h5 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h5><p>Redis基于C语言编写了 <strong>SDS（Simple Dynamic String，简单动态字符串）</strong> 作为底层实现。在 Redis 中，当存储的字符串长度小于 44 字节时（Redis 3.2 版本之前是 39 字节），默认使用 SDS 来存储。SDS 有多种不同的结构定义，以适应不同长度的字符串，常见的有 <code>sdshdr5</code>、<code>sdshdr8</code>、<code>sdshdr16</code>、<code>sdshdr32</code> 和 <code>sdshdr64</code>。SDS 可以存储字符串，也可以存储二进制数据，包括空字符，因此在处理二进制数据时更为灵活，不受空字符的限制。</p><p>与C语言中的字符串相比：（1）<strong>可以避免缓冲区溢出</strong>（先根据len检查空间大小）；（2）<strong>获取字符串长度的复杂度低</strong>（C要遍历）；（3）<strong>动态扩容，减少内存分配次数</strong>（扩容时，空间预分配；字符串缩短时，惰性空间释放-即标记多余空间为可用，等待后续使用）；（4）<strong>二进制安全</strong>（C语言以空字符\0作为结束标记）</p><p>采用了空间预分配和惰性空间释放的策略。在进行扩容时，除了分配实际需要的空间外，还会<strong>额外分配一些空间</strong>，以便后续的操作使用，减少了内存分配的次数。在进行<strong>字符串缩短</strong>操作时，不会立即释放多余的空间，而是<strong>将其标记为可用，等待后续使用</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, and 5 msb of string length */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span>  <span class="token comment">// 字符串的实际长度 -- 获取串长度为O(1)，C语言字符串是遍历计数，复杂度O(n)</span>    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">// 分配的内存空间大小，不包含头部和结尾的空字符 -- 在进行字符串拼接等操作时，SDS 会先检查分配的内存空间是否足够，如果不够会自动进行扩容，避免了 C 字符串可能出现的缓冲区溢出问题。</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">// 标志位，用于标识 SDS 的类型</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 存储字符串的字符数组</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span>    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span>    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ziplist-早期使用"><a href="#ziplist-早期使用" class="headerlink" title="ziplist 早期使用"></a>ziplist 早期使用</h5><p>在 Redis 早期版本中，对于长度较短的字符串，可能会使用<strong>压缩列表（ziplist）</strong>来存储。压缩列表是一种为了节省内存而设计的连续内存块数据结构，它将多个元素紧凑地存储在一起。不过，随着 Redis 的发展，现在对于较短字符串更多使用 SDS 来存储。</p><h4 id="list底层"><a href="#list底层" class="headerlink" title="list底层"></a>list底层</h4><p>Redis 的 <code>List</code> 类型是一个有序的字符串列表，它的底层数据结构主要有两种：<strong>压缩列表（ziplist）和双向链表（linkedlist）</strong>，在 Redis 3.2 版本之后，引入了<strong>快速列表（quicklist）</strong>作为 <code>List</code> 的底层实现。</p><h5 id="ziplist-早期使用-1"><a href="#ziplist-早期使用-1" class="headerlink" title="ziplist 早期使用"></a>ziplist 早期使用</h5><p>压缩列表（ZipList）是一种用于在 Redis 中<strong>紧凑存储列表和哈希表数据</strong>的数据结构。它是由一系列<strong>特定编码格式</strong>的<strong>连续内存块</strong>组成的<strong>顺序型数据结构</strong>，每个<strong>内存块</strong>称为一个<strong>节点（entry）</strong>。每个节点可以存储一个<strong>字节数组或整数值</strong>，并且可以根据实际存储的数据<strong>动态地调整节点的长度。</strong>列表或hash键元素较少且每个元素占用空间较小时使用压缩列表，目的是利用紧凑连续块来节省内存。</p><blockquote><ul><li><strong>优点</strong>：紧凑存储，可变长度，支持多种数据类型，适合小规模数据，需要遍历访问</li></ul><ul><li><strong>缺点</strong>：在插入或删除元素时，可能需要对内存进行重新分配和数据移动，时间复杂度较高。（插入或删除元素可能导致多个 entry 的 <code>prevlen</code> 字段扩展，触发连锁内存重分配（性能风险））</li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ziplist 头部结构定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zlentry</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlensize<span class="token punctuation">;</span> <span class="token comment">// 编码前一个节点长度所需的字节数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlen<span class="token punctuation">;</span>     <span class="token comment">// 前一个节点的实际长度</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lensize<span class="token punctuation">;</span>        <span class="token comment">// 编码当前节点长度所需的字节数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>            <span class="token comment">// 当前节点的实际长度</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> headersize<span class="token punctuation">;</span>     <span class="token comment">// 当前节点的头部大小（prevrawlensize + lensize）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> encoding<span class="token punctuation">;</span>      <span class="token comment">// 当前节点的编码方式</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>            <span class="token comment">// 指向当前节点的指针</span><span class="token punctuation">}</span> zlentry<span class="token punctuation">;</span><span class="token comment">// ziplist 整体结构定义</span><span class="token comment">// zlbytes: 记录整个压缩列表占用的内存字节数</span><span class="token comment">// zltail: 记录压缩列表表尾节点距离压缩列表起始地址的偏移量--O(1)复杂度内找到表尾节点，支持反向遍历</span><span class="token comment">// zllen: 记录压缩列表包含的节点（entry）数量</span><span class="token comment">// entry: 压缩列表中的每个节点，存储具体的数据元素--每个元素存储为 [prevlen][encoding][content]。</span><span class="token comment">// zlend: 一个特殊的结束标记，值为 0xFF</span><span class="token comment">// ziplist 内存布局（无显式结构体，通过字节操作）-- redis3.0  ziplist.c</span><span class="token comment">// &lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;...&lt;entry&gt;&lt;zlend&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="双向链表-早期使用"><a href="#双向链表-早期使用" class="headerlink" title="双向链表 早期使用"></a>双向链表 早期使用</h5><p>当列表元素较多或者元素占用空间较大时，Redis 会使用双向链表作为 <code>List</code> 的底层数据结构。双向链表在插入和删除元素时具有较好的性能。</p><ul><li><strong>内存不连续</strong>：每个节点独立分配内存，通过指针连接。意味着与压缩列表相比，⽆法很好利⽤ CPU 缓存</li><li><strong>操作高效</strong>：头尾插入/删除时间复杂度为 O(1)，但随机访问为 O(n)。</li><li><strong>内存开销大</strong>：每个节点需额外存储两个指针（每个指针占 8 字节）。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 数据结构定义（Redis 3.0，adlist.h）</span><span class="token comment">// 双向链表节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>  <span class="token comment">// 前驱节点指针</span>    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">// 后继节点指针</span>    <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>            <span class="token comment">// 存储的实际数据</span><span class="token punctuation">}</span> listNode<span class="token punctuation">;</span><span class="token comment">// 双向链表结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> <span class="token punctuation">{</span>    listNode <span class="token operator">*</span>head<span class="token punctuation">;</span>         <span class="token comment">// 头节点</span>    listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>         <span class="token comment">// 尾节点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>      <span class="token comment">// 链表长度（元素数量）</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 节点值复制函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 节点值释放函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 节点值比较函数</span><span class="token punctuation">}</span> list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="quicklist-新版"><a href="#quicklist-新版" class="headerlink" title="quicklist 新版"></a>quicklist 新版</h5><p>为了综合压缩列表和双向链表的优点，Redis 3.2 版本之后引入了快速列表作为 <code>List</code> 的底层实现。快速列表<strong>结合了压缩列表节省内存和双向链表插入删除高效</strong>的特点。</p><ul><li>快速列表是一个双向链表，链表中的**每个节点(quicklistNode)是一个压缩列表(ziplist)**。</li><li>当插入元素导致 ziplist 超过 <code>fill</code> 限制时，节点会分裂；删除元素可能导致相邻节点合并。</li><li><code>head</code> 和 <code>tail</code> 指针使得 LPUSH、RPUSH、LPOP、RPOP 的时间复杂度为 **O(1)**。通过 <code>prev</code> 和 <code>next</code> 指针支持双向遍历。</li><li>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// quicklist 结构（src/quicklist.h）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token punctuation">{</span>    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>        <span class="token comment">// 指向头节点的指针</span>    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>        <span class="token comment">// 指向尾节点的指针</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>        <span class="token comment">// 所有 ziplist 中的元素总数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>          <span class="token comment">// quicklist 的节点数量（即 ziplist 的数量）</span>    <span class="token keyword">int</span> fill <span class="token operator">:</span> QL_FILL_BITS<span class="token punctuation">;</span>    <span class="token comment">// 单个 ziplist 的最大容量限制（由 list-max-ziplist-size 配置）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">// 压缩深度（由 list-compress-depth 配置）</span><span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span><span class="token comment">// quicklist 节点结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span> <span class="token comment">// 前驱节点指针</span>    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 后继节点指针</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>          <span class="token comment">// 指向 ziplist 的指针（未压缩时）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>            <span class="token comment">// ziplist 的字节大小</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token comment">// ziplist 的元素数量</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 编码方式：RAW（原始 ziplist）或 LZF（压缩存储）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 容器类型（固定为 2，表示使用 ziplist）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 是否正在被解压</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 测试用</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> extra <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// 预留位</span><span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="hash底层"><a href="#hash底层" class="headerlink" title="hash底层"></a>hash底层</h4><h5 id="Ziplist-HashTable-早期"><a href="#Ziplist-HashTable-早期" class="headerlink" title="Ziplist+HashTable 早期"></a>Ziplist+HashTable 早期</h5><p>当哈希对象满足以下两个条件时，Redis 会使用压缩列表作为 <code>Hash</code> 的底层数据结构：</p><ul><li>哈希对象保存的<strong>所有</strong>键值对的<strong>键和值的字符串长度都小于 64 字节</strong>（可以通过 <code>hash-max-ziplist-value</code> 配置项进行修改）。</li><li>哈希对象保存的键值对<strong>数量小于 512 个</strong>（该阈值可以通过 <code>hash-max-ziplist-entries</code> 配置项进行修改）。</li></ul><blockquote><p>在压缩列表中，哈希对象的键值对是<strong>按顺序依次存储</strong>的。每个键值对由<strong>两个连续的节点</strong>表示，前一个节点存储键，后一个节点存储值。例如，对于哈希对象 <code>{"name": "John", "age": 30}</code>，在压缩列表中的存储顺序可能是：<code>"name", "John", "age", 30</code>。</p></blockquote><p>Ziplist 的每个元素（entry）由三部分组成：</p><pre class="line-numbers language-none"><code class="language-none">[prevlen][encoding][content]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**<code>prevlen</code>**：存储前一个元素的长度（支持反向遍历）。</li><li>**<code>encoding</code>**：当前元素的数据类型和长度。</li><li>**<code>content</code>**：实际数据。</li></ul><p>局限：</p><ul><li><strong>级联更新</strong>：插入或删除元素可能导致多个 entry 的 <code>prevlen</code> 字段扩展，触发连锁内存重分配（性能风险）。</li><li><strong>遍历效率低</strong>：查找<strong>特定键</strong>需要遍历整个 ziplist（时间复杂度 O(n)）。</li></ul><p>当哈希对象不满足使用压缩列表的条件时，Redis 会将底层数据结构转换为<strong>哈希表。</strong></p><ul><li><strong>渐进式 rehash</strong>：当哈希表需要扩容或缩容时，<strong>数据逐步迁移到新哈希表</strong>，避免一次性操作阻塞服务。</li><li><strong>高效随机访问</strong>：平均时间复杂度为 O(1)。</li><li><strong>链地址法解决冲突</strong>：哈希冲突时，通过链表将多个键值对连接在同一个桶中。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 哈希表结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{</span>    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>      <span class="token comment">// 哈希桶数组</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>      <span class="token comment">// 哈希表大小（桶的数量）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>  <span class="token comment">// 哈希掩码（用于计算索引，等于 size-1）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>      <span class="token comment">// 已使用的桶数量（键值对总数）</span><span class="token punctuation">}</span> dictht<span class="token punctuation">;</span><span class="token comment">// 字典结构（Redis 哈希的顶层结构）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>         <span class="token comment">// 类型特定函数（如哈希函数）</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>         <span class="token comment">// 私有数据</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">// 两个哈希表（用于渐进式 rehash）</span>    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span>         <span class="token comment">// rehash 进度索引（-1 表示未进行 rehash）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> iterators<span class="token punctuation">;</span> <span class="token comment">// 当前运行的迭代器数量</span><span class="token punctuation">}</span> dict<span class="token punctuation">;</span><span class="token comment">// 哈希表节点（键值对）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>              <span class="token comment">// 键</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>        <span class="token class-name">uint64_t</span> u64<span class="token punctuation">;</span>        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span>        <span class="token keyword">double</span> d<span class="token punctuation">;</span>    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>                    <span class="token comment">// 值</span>    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 指向下一个节点（解决哈希冲突）</span><span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://i-blog.csdnimg.cn/blog_migrate/4bf663222bb37404c915b58dec8e8cbd.png" alt="img" style="zoom: 67%;"><h5 id="listpack-HashTable-新版"><a href="#listpack-HashTable-新版" class="headerlink" title="listpack+HashTable 新版"></a>listpack+HashTable 新版</h5><p>在 Redis 的最新版本（如 <strong>7.0 及以上</strong>）中，<strong>listpack</strong> 已逐步替代 <strong>ziplist</strong>，成为某些数据结构的底层实现，以解决 ziplist 的级联更新问题，并提升内存效率和操作性能。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// listpack 内存布局（源码：listpack.c）</span><span class="token comment">// &lt;总字节数&gt;&lt;元素数量&gt;&lt;element&gt;...&lt;element&gt;&lt;结束符&gt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">lpInsert</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>lp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> size<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> where<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 计算新元素所需内存</span>    <span class="token class-name">uint32_t</span> poff <span class="token operator">=</span> p <span class="token operator">?</span> p <span class="token operator">-</span> lp <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> enclen <span class="token operator">=</span> <span class="token function">lpEncodeGetType</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>enctype<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> backlen_size <span class="token operator">=</span> <span class="token function">lpEncodeBacklen</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> enclen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> old_listpack_bytes <span class="token operator">=</span> <span class="token function">lpGetTotalBytes</span><span class="token punctuation">(</span>lp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> new_elements <span class="token operator">=</span> <span class="token function">lpGetNumElements</span><span class="token punctuation">(</span>lp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 分配新内存并插入元素</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>newlp <span class="token operator">=</span> <span class="token function">lp_realloc</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> old_listpack_bytes <span class="token operator">+</span> enclen <span class="token operator">+</span> backlen_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新元素位置和元数据...</span>    <span class="token keyword">return</span> newlp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>总字节数（4 Bytes）</strong>：整个 listpack 占用的内存大小。</li><li><strong>元素数量（2 Bytes）</strong>：元素个数（若超过 65535，需遍历统计）。</li><li><strong>元素（element）</strong>：每个元素独立编码，格式为 <code>[编码类型][数据内容][元素长度]</code>。</li><li><strong>结束符（1 Byte）</strong>：固定值 <code>0xFF</code>。</li></ul><blockquote><p>每个元素（entry）的元数据（如长度）存储在其自身末尾，而非依赖前驱节点，<strong>彻底消除了级联更新</strong>的可能性。<strong>级联更新（Cascade Update）</strong> 指的是在数据结构中，修改一个元素可能导致后续多个元素的内存布局被迫调整，从而引发连锁反应。</p><p>例如，插入新元素时，仅需修改自身及后续元素的长度字段，无需回溯前驱节点。</p></blockquote><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>Listpack</strong></th><th align="left"><strong>Ziplist</strong></th></tr></thead><tbody><tr><td align="left"><strong>级联更新</strong></td><td align="left"><strong>无</strong>（长度信息存储在自身末尾）</td><td align="left">有（依赖前驱节点的 <code>prevlen</code> 字段）</td></tr><tr><td align="left"><strong>内存连续性</strong></td><td align="left">连续内存块</td><td align="left">连续内存块</td></tr><tr><td align="left"><strong>插入/删除性能</strong></td><td align="left">稳定 O(n)</td><td align="left">最坏 O(n²)（级联更新时）</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">高频插入、删除的紧凑数据</td><td align="left">已逐步被 listpack 替代</td></tr></tbody></table><p>消除级联更新的本质：</p><ul><li><strong>解耦元素长度依赖</strong>：每个元素的长度信息仅影响自身，不依赖前驱或后继元素。</li><li><strong>内存操作局部化</strong>：插入或删除操作仅需处理当前元素及后续元素的位置，不触发连锁更新。</li></ul><h4 id="Set底层"><a href="#Set底层" class="headerlink" title="Set底层"></a>Set底层</h4><p>Redis 的集合（Set）底层数据结构根据元素类型和数量动态选择 <strong>intset（整数集合）</strong> 或 <strong>hashtable（哈希表）</strong>，以优化内存和性能。</p><p>在redis.conf中配置<code>set-max-intset-entries 512</code>，表示<strong>当元素数量&lt;=512且所有元素为整数</strong>时，使用intset。</p><ul><li><strong>小规模整数集合</strong>：使用 <code>intset</code>（内存紧凑，连续存储）。</li><li><strong>其他情况</strong>：使用 <code>hashtable</code>（支持任意类型元素，高效随机访问）。</li></ul><h5 id="intset-整数集合"><a href="#intset-整数集合" class="headerlink" title="intset 整数集合"></a>intset 整数集合</h5><p>intset是一个由整数组成的有序集合，可以进行二分查找。整数集合在存储整数值的过程中，会根据需要动态调整存储空间，避免了固定大小数组可能带来的空间浪费或溢出问题。用途：用于<strong>存储用户 ID、商品 ID</strong> 等。由于其高效的存储方式和快速的查找性能，使得整数集合成为了处理<strong>整数集合类数据</strong>的首选数据结构之一。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">intset</span> <span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> encoding<span class="token punctuation">;</span>  <span class="token comment">// 编码类型（INTSET_ENC_INT16/32/64）</span>    <span class="token class-name">uint32_t</span> length<span class="token punctuation">;</span>    <span class="token comment">// 元素数量</span>    <span class="token class-name">int8_t</span> contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 实际存储元素的数组</span><span class="token punctuation">}</span> intset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>内存连续</strong>：元素按升序存储在 <code>contents</code> 数组中，无指针开销。</li><li><strong>编码升级</strong>：插入新元素时，若超出当前编码范围（例如插入 <code>int32</code> 到 <code>int16</code> 集合），自动升级编码并重新分配内存。</li></ul><p>集合元素包含非整数或数量超过阈值时，使用与 Redis <strong>哈希类型相同的 <code>dict</code> 结构（</strong>源码：dict.h），但 <strong>值部分为 NULL</strong>（仅存储键）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>     <span class="token comment">// 类型特定函数</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 双哈希表（用于渐进式 rehash）</span>    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span> dict<span class="token punctuation">;</span><span class="token comment">// 哈希表节点（仅存储键）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>          <span class="token comment">// 集合元素（值存储在 key 字段）</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span> v<span class="token punctuation">;</span>    <span class="token comment">// 值字段未被使用（设为 NULL）</span>    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SortedSet底层"><a href="#SortedSet底层" class="headerlink" title="SortedSet底层"></a>SortedSet底层</h4><p>zset中的**每个元素包含数据本身和一个对应的分数(score)**。经典例子：一个zset的key是”math”，代表数学课的成绩，然后可以往这个key里插入很多数据。输入数据的时候，每次需要输入一个姓名和一个对应的成绩。那么这个姓名就是数据本身，成绩就是它的score。</p><p>zset的数据本身不允许重复，但是score允许重复。</p><p>zset底层实现原理：</p><ul><li>数据少时，使用ziplist：ziplist占用连续内存，<strong>每项元素都是（数据+score）的方式连续存储，按照score从小到大排序</strong>。ziplist为了节省内存，每个元素占用的空间可以不同，对于大的数据（long long），就多用一些字节来存储，而对于小的数据（short），就少用一些字节来存储。因此查找的时候需要按顺序遍历。ziplist省内存但是查找效率低。<ul><li>在有序集合<strong>元素小于 64 字节且个数小于 128</strong> 的时候，会使用 ziplist。</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">zset<span class="token operator">-</span>max<span class="token operator">-</span>listpack<span class="token operator">-</span>entries <span class="token number">128</span>  # 元素数量 ≤ <span class="token number">128</span> 时，使用 listpack（Redis <span class="token number">7.0</span><span class="token operator">+</span>）zset<span class="token operator">-</span>max<span class="token operator">-</span>listpack<span class="token operator">-</span>value <span class="token number">64</span>     # 元素值长度 ≤ <span class="token number">64</span> 字节时，使用 listpack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>数据多时，使用字典+跳表。<strong>字典用来根据数据查score，跳表用来根据score查找数据（查找效率高）。</strong>成员和分值在跳表和字典中各存一份，以空间换时间。</li></ul><img src="https://i-blog.csdnimg.cn/blog_migrate/d28bf11bb5b5e2d9957c316d6c7f2b8b.png" alt="img" style="zoom: 67%;"><h5 id="dict哈希字典-skiplist跳表"><a href="#dict哈希字典-skiplist跳表" class="headerlink" title="dict哈希字典+skiplist跳表"></a>dict哈希字典+skiplist跳表</h5><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005436.png" alt="img" style="zoom:80%;"><p>跳跃表是一种随机化的数据结构，它通过在每个节点中维护多个指向其他节点的指针，从而实现快速的查找、插入和删除操作。跳跃表的平均时间复杂度为O(log n) ，与平衡二叉树相当，但实现起来更加简单。</p><ul><li><strong>多层结构</strong>：跳跃表由多个层（level）组成，每层都是一个有序的链表。最底层的链表包含了所有的元素，而<strong>上面的层则是下面层的索引</strong>。通过这种分层的结构，查找元素时可以从高层开始快速定位到大致的位置，然后再逐层向下查找，降低了查找的时间复杂度。</li><li><strong>随机层数</strong>：<strong>每个节点的层数是随机确定的</strong>，通常是通过一个随机函数来决定。这样可以保证跳跃表的平衡性，避免出现极端情况下的性能下降。</li><li><strong>分数有序</strong>：跳跃表中的节点按照分数从小到大排序，如果分数相同，则按照元素的字典序排序。这种排序方式使得有序集合可以方便地进行范围查找，如根据分数范围获取元素。</li></ul><blockquote><p>时间复杂度：时间复杂度 = 索引的层数 * 每层索引遍历元素的个数。</p><p>首先看索引层数，假设每两个节点抽一个出来作为上一级索引的结点，而且最高一级索引有3个节点，则索引层数为log2(n)。</p><p>然后看每层遍历多少个元素，首先最高层最多遍历3个节点，就能往下走了，同理，次高层也最多遍历三个节点，就能往下走。取平均之后，可以认为每层遍历2个节点。</p><p>因此时间复杂度=2log2(n)，同理，如果是每k个节点取一个索引的话，就是klogk(n)</p><p>空间复杂度：也是以每两个节点取一个索引为例，第一层n个节点，第二层n/2，第三次n/4，等比序列求和，或者取极限，可以认为索引节点数量无限接近于n，所以空间复杂度为O(n)。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 有序集合结构（源码：server.h）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">{</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>          <span class="token comment">// 字典（和哈希结构里的dict一样）：存储 member -&gt; score 的映射（O(1) 查找）</span>    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>      <span class="token comment">// 跳表：按分值排序，支持范围操作</span><span class="token punctuation">}</span> zset<span class="token punctuation">;</span><span class="token comment">// 跳表节点（源码：server.h）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{</span>    sds ele<span class="token punctuation">;</span>                         <span class="token comment">// 成员（member）</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span>                    <span class="token comment">// 分值（score）</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>  <span class="token comment">// 后向指针（双向链表）</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>  <span class="token comment">// 前向指针</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> span<span class="token punctuation">;</span>             <span class="token comment">// 跨度（用于计算排名）</span>    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                          <span class="token comment">// 多层索引：从原始节点逐层往上记录其后继元素（即forward）</span><span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span><span class="token comment">// 跳表结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>  <span class="token comment">// 头尾节点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>                 <span class="token comment">// 元素数量</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span>                            <span class="token comment">// 最大层数</span><span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Redis 跳表的特点</strong>：</p><ol><li>采用<strong>双向链表</strong>，存在一个回退指针。主要用于简化操作，例如删除某个元素时，还需要找到该元素的前驱节点，使用回退指针会非常方便。</li><li><code>score</code> 值可以重复，如果 <code>score</code> 值一样，则按照 ele（节点存储的值，为 sds）字典排序</li><li>Redis 跳跃表默认允许最大的层数是 32，被源码中 <code>ZSKIPLIST_MAXLEVEL</code> 定义。</li></ol><p><strong>插入（平均 O(logn)：依赖跳表的多层索引，快速跳过无关节点）：</strong></p><p>1.<strong>计算随机层数</strong>：生成新节点的层数 <code>level</code>（1~32），遵循 <strong>幂次定律</strong>（越高层数概率越小）。</p><p>2.<strong>查找插入位置</strong>：从跳表的最高层开始，向右遍历，找到每一层中最后一个 <strong>小于新节点分值</strong> 的节点（或同分值但成员字典序较小的节点），记录到 <code>update</code> 数组中。</p><p>3.<strong>创建新节点</strong>：分配内存，存储 <code>member</code> 和 <code>score</code>，并初始化各层的 <code>forward</code> 指针。</p><p>4.<strong>调整指针和跨度</strong>：基于update数组将新节点的各层 <code>forward</code> 指针指向后续节点，并更新前驱节点的 <code>forward</code> 指针指向新节点。更新各层的 <strong>跨度（span）</strong>，维护后续节点的排名信息。</p><p>5.<strong>更新跳表元数据</strong>：如果新节点的层数超过当前跳表的最大层数，更新跳表的 <code>level</code> 字段。更新跳表长度 <code>length</code>。</p><p><strong>删除（O(logn)）：</strong></p><p>1.<strong>查找待删除节点</strong>：从最高层开始遍历，记录每层中 <strong>可能指向待删除节点</strong> 的<strong>前驱节点</strong>到 <code>update</code> 数组。</p><p>2.<strong>验证节点存在性</strong>：检查找到的节点是否匹配 <code>member</code> 和 <code>score</code>（避免哈希冲突误删）。</p><p>3.<strong>调整指针和跨度</strong>：遍历各层，将前驱节点的 <code>forward</code> 指针指向待删除节点的后续节点。更新各层的 <strong>跨度（span）</strong>，减去被删除节点的跨度值。</p><p>4.<strong>释放内存</strong>：释放节点内存，并更新跳表长度 <code>length</code>。如果删除的是头节点或尾节点，更新跳表的 <code>header</code> 或 <code>tail</code> 指针。</p><p><strong>按成员查询分值（ZSCORE）</strong>：直接通过哈希表。ZSET 的 dict 哈希表存储了 member -&gt; score 的映射，时间复杂度 O(1)。</p><p><strong>查询–按分值的范围查询（ZRANGE）：</strong></p><p>1.<strong>定位起始节点</strong>：从跳表的最高层开始，向右遍历找到 <strong>第一个 ≥ 最小分值</strong> 的节点。</p><p>2.<strong>遍历链表</strong>：从起始节点开始，沿底层（<code>level[0]</code>）指针向右遍历，直到节点分值超过最大分值。收集遍历路径上的所有节点。</p><p><strong>按排名查询（ZRANK/ZREVRANK）</strong>：<strong>利用跨度（span）字段</strong>：在查找节点的过程中，累加各层的跨度值，得到节点的排名。</p><h3 id="为什么ZSet底层用跳表"><a href="#为什么ZSet底层用跳表" class="headerlink" title="为什么ZSet底层用跳表"></a>为什么ZSet底层用跳表</h3><p>Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？</p><p>与平衡树相比</p><ul><li>平衡树我们又会称之为 <strong>AVL 树</strong>，是一个严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过 1，即平衡因子为范围为 <code>[-1,1]</code>）。平衡树的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong> 。</li><li>对于范围查询来说，它也可以通过中序遍历的方式达到和跳表一样的效果。但是它的<strong>每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡</strong>，这个过程是比较耗时的。</li><li>跳表是一种可以用来代替平衡树的数据结构。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</li></ul><p>与红黑树相比：</p><ul><li><p>红黑树（Red Black Tree）也是一种自平衡二叉查找树，它的查询性能略微逊色于 AVL 树，但插入和删除效率更高。红黑树的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong> 。</p></li><li><p>按照<strong>区间查找</strong>数据这个操作，红黑树的效率没有跳表高。跳表可以<strong>定位区间的起点，然后在原始链表中顺序向后</strong>查询就可以了。</p></li><li><p>相比于红黑树，跳表还具有代码更容易实现、可读性好、不容易出错、更加灵活等优点。</p></li><li><p>插入、删除时跳表只需要调整少数几个节点，红黑树需要<strong>颜色重涂和旋转</strong>，开销较大。（比起AVL要好一点）</p></li></ul><p>与B+树相比：</p><ul><li><strong>节省内存</strong>：B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到<strong>尽可能多的索引</strong>来获得查询数据。对于 Redis 这种内存数据库来说，它对这些并不感冒，因为 Redis 作为内存数据库它不可能存储大量的数据，所以<strong>对于索引不需要通过 B+树这种方式进行维护</strong>，只需按照概率进行随机维护即可，<strong>节约内存</strong>。</li><li><strong>简单好用，容易实现</strong>：而且使用跳表实现 zset 时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，也<strong>不需要像 B+树那样插入时发现失衡时还需要对节点分裂与合并</strong>。</li></ul><h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><p>Redis 的线程模型是其高性能设计的核心，其核心思想是 <strong>单线程处理命令 + 多线程辅助任务</strong>。</p><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p><ul><li><p>单线程主逻辑：所有<strong>客户端命令的执行</strong>（如 GET、SET、INCR 等）由 <strong>单个主线程</strong> 顺序处理。</p><ul><li><strong>避免多线程竞争锁</strong>的开销，简化实现。天然保证操作的<strong>原子性</strong>，无需考虑并发问题。基于<strong>事件循环（Event Loop）和 I/O 多路复用（如 epoll）</strong>实现高并发。</li></ul></li><li><p>多线程辅助任务：<strong>后台异步任务</strong>：如持久化（RDB/AOF）、大键删除（UNLINK）、网络 I/O（Redis 6.0+）等，由后台线程处理。</p><ul><li>避免主线程阻塞，保持低延迟。充分利用多核CPU资源。</li><li><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</li></ul></li></ul><p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>Redis 通过<strong>过期字典</strong>（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的<strong>值是一个 long long 类型的整数</strong>，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><ul><li><strong>缓解内存的消耗</strong>：如果不设置TTL，内存占用会不断增长，可能导致OOM。设置TTL可以自动删除暂时不需要的数据，腾出空间；</li><li><strong>临时数据存储</strong>：部分业务场景下数据只在一段时间内有效，如短信验证码，用户登录token。</li></ul><p>过期字典是存储在 redisDb 这个结构里的。在查询一个 key 的时候，Redis 首先检查该 key 是否存在于过期字典中（时间复杂度为 O(1)），如果不在就直接返回，在的话需要判断一下这个 key 是否过期，过期直接删除 key 然后返回 null。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>     <span class="token comment">//数据库键空间,保存着数据库中所有键值对</span>    dict <span class="token operator">*</span>expires   <span class="token comment">// 过期字典,保存着键的过期时间</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-expired-dictionary.png" alt="Redis 过期字典" style="zoom: 33%;"><p><strong>过期删除策略</strong></p><p>常用的过期数据的删除策略就下面这几种：</p><ol><li><strong>惰性删除</strong>：只会在取出/查询 key 的时候才对数据进行过期检查。这种方式<strong>对 CPU 最友好</strong>，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong>：<strong>周期性地随机</strong>从设置了过期时间的 key 中<strong>抽查</strong>一批，然后逐个检查这些 key 是否过期，过期就删除 key。相比于惰性删除，定期删除<strong>对内存更友好</strong>，对 CPU 不太友好。</li><li><strong>延迟队列</strong>：把设置过期时间的 key 放到一个延迟队列里，到期之后就删除 key。这种方式可以保证每个过期 key 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。</li><li><strong>定时删除</strong>：每个设置了过期时间的 key 都会在设置的时间到达时立即被删除。这种方法可以确保内存中不会有过期的键，但是它对 CPU 的压力最大，因为它需要<strong>为每个键都设置一个定时器</strong>。</li></ol><p>Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 结合的策略，这也是大部分缓存框架的选择。定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，结合起来使用既能兼顾 CPU 友好，又能兼顾内存友好。</p><p>Redis 的定期删除过程是随机的（周期性地随机从设置了过期时间的 key 中抽查一批），所以并不保证所有过期键都会被立即删除。这也就解释了为什么有的 key 过期了，并没有被删除。并且，Redis 底层会通过<strong>限制删除操作执行的时长和频率来减少删除操作对 CPU 时间</strong>的影响。</p><p>另外，定期删除还会受到执行时间和过期 key 的比例的影响：</p><ul><li>执行时间已经超过了阈值，那么就<strong>中断</strong>这一次定期删除循环，以<strong>避免使用过多的 CPU 时间。</strong></li><li>如果这一批过期的 key 比例超过一个比例，就会重复执行此删除流程，以更积极地清理过期 key。相应地，如果<strong>过期的 key 比例低于这个比例，就会中断这一次定期删除循环</strong>，避免做过多的工作而获得很少的内存回收。</li></ul><p><code>expire.c</code>中定义了每次随机抽查的数量，Redis 7.2 版本为 20 ，也就是说每次会随机选择 20 个设置了过期时间的 key 判断是否过期。定期删除的频率是由 <strong>hz</strong> 参数控制的。hz 默认为 10，代表每秒执行 10 次，也就是每秒钟进行 10 次尝试来查找并删除过期的 key。hz 的取值范围为 1~500。增大 hz 参数的值会提升定期删除的频率。<strong>如果你想要更频繁地执行定期删除任务，可以适当增加 hz 的值，但这会加 CPU 的使用率。</strong>根据 Redis 官方建议，hz 的值不建议超过 100</p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>Redis 的内存淘汰策略只有在<strong>运行内存达到了配置的最大内存阈值</strong>时才会触发，这个阈值是通过<code>redis.conf</code>的<code>maxmemory</code>参数来定义的。64 位操作系统下，<code>maxmemory</code> 默认为 0 ，表示不限制内存大小。32 位操作系统下，默认的最大内存值是 3GB。</p><p>Redis 提供了 6 种内存淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li><li><strong>allkeys-lru（least recently used）</strong>：从数据集（<code>server.db[i].dict</code>）中移除最近最少使用的数据淘汰。</li><li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li><li><strong>no-eviction</strong>（默认内存淘汰策略）：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu（least frequently used）</strong>：从数据集（<code>server.db[i].dict</code>）中移除最不经常使用的数据淘汰。</li></ol><p><code>allkeys-xxx</code> 表示从所有的键值中淘汰数据，而 <code>volatile-xxx</code> 表示从设置了过期时间的键值中淘汰数据。</p><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis 事务提供了一种<strong>将多个命令请求打包</strong>的功能。然后，再<strong>按顺序执行打包</strong>的所有命令，并且<strong>不会被中途打断</strong>（满足隔离性）。</p><ul><li><strong>原子操作，不满足原子性</strong>：事务内的命令按顺序执行，但 <strong>不支持回滚</strong>（若某个命令失败，<strong>后续命令仍会执行</strong>）。</li><li><strong>满足隔离性</strong>：事务执行期间不会被其他客户端命令打断。</li><li><strong>不满足一致性</strong>：执行事务前后数据不一定一致，命令可能部分成功。</li><li><strong>持久性</strong>：Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式：快照（snapshotting，RDB）、只追加文件（append-only file, AOF）、RDB 和 AOF 的混合持久化(Redis 4.0 新增)。AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。<strong>always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</strong>因此，Redis 事务的持久性也是没办法保证的。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">MULTISET key1 value1SET key2 value2EXEC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Redis 事务实际开发中<strong>使用的非常少</strong>。除了不满足原子性和持久性之外，<strong>事务中的每条命令都会与 Redis 服务器进行网络交互</strong>（性能较差），这是比较浪费资源的行为。<strong>Redis 事务是不建议在日常开发中使用的。</strong></p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis的读写操作都是在内存中，所以Redis性能才会高，但是当Redis重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在Redis重启就能够从磁盘中恢复原有的数据。Redis共有三种数据持久化的方式：</p><ul><li><strong>AOF日志：</strong>每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里;</li><li><strong>RDB快照：</strong>将某一时刻的内存数据，以二进制的方式写入磁盘；</li></ul><h4 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h4><p><strong>AOF（Append-Only File）</strong>：Redis在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后Redis重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p><img src="https://cdn.xiaolincoding.com//picgo/1719110103188-58f6e37a-6bf9-41a5-9209-7683b21b6b04.webp" alt="img" style="zoom:50%;"><p>AOF 提供了三种同步策略（通过 <code>appendfsync</code> 配置）：</p><ul><li><strong>always</strong>：每次写操作都同步到磁盘，数据安全性最高，但性能最差。</li><li><strong>everysec</strong>：每秒同步一次，性能和安全性平衡（默认配置）。</li><li><strong>no</strong>：由操作系统决定何时同步，性能最好，但数据丢失风险最高。</li></ul><p>优点：</p><ul><li><strong>数据安全性高</strong>：AOF 可以做到秒级数据持久化，数据丢失风险低。即使文件损坏，还提供了redis-check-aof工具修复。</li><li><strong>可读性强</strong>：AOF 文件是文本文件，记录了所有写操作，便于分析和修复。</li></ul><p>缺点：</p><ul><li><strong>文件体积大</strong>：AOF 文件通常比 RDB 文件大（记录了每一个写操作）。</li><li><strong>性能影响</strong>：频繁的磁盘IO操作（特别是always同步策略）影响Redis的写入性能。</li><li><strong>恢复速度慢</strong>：AOF 文件需要逐条执行命令来恢复数据，速度较慢。</li></ul><h4 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h4><p><strong>RDB（Redis Database）</strong>：RDB 是 Redis 默认的持久化方式，它通过生成数据快照（Snapshot）将内存中的数据保存到磁盘上的二进制文件（<code>.rdb</code> 文件）中。</p><p>优点：</p><ul><li><strong>性能高</strong>：RDB 文件是紧凑的二进制文件，恢复速度快。</li><li><strong>适合备份</strong>：可以定期生成 RDB 文件，用于数据备份和灾难恢复。</li><li><strong>文件体积小</strong>：相比 AOF，RDB 文件占用的磁盘空间更小。</li></ul><p>缺点：</p><ul><li><strong>数据丢失风险、数据不一致</strong>：如果 Redis 崩溃，最后一次快照之后的数据会丢失。</li><li><strong>不适合实时持久化</strong>：RDB 是定时快照，无法做到秒级数据持久化。</li></ul><h3 id="Redis性能优化"><a href="#Redis性能优化" class="headerlink" title="Redis性能优化"></a>Redis性能优化</h3><h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p><p><strong>原生批量操作</strong>：mget，mset，hmget，sadd……单条批量命令本身是原子的。<strong>分片集群方案下，存在问题</strong>–<code>MGET</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>MGET</code>可能<strong>还是需要多次网络传输</strong>，原子操作也无法保证。</p><p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p><ol><li>找到 key 对应的所有 hash slot；</li><li><strong>分别</strong>向对应的 Redis 节点发起 <code>MGET</code> 请求获取数据；</li><li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li></ol><blockquote><p>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公式找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p></blockquote><p><strong>pipeline</strong>：对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令<strong>封装成一组</strong>，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。</p><ul><li><p>与原生操作对比：原生批量操作命令是原子操作，<strong>pipeline 是非原子操作</strong>（命令逐个执行）。pipeline 可以打包不同的命令，原生批量操作命令不可以。原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</p></li><li><p>与事务对比：事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。<strong>Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次</strong>，请求次数更少。</p><ul><li>事务可以看作原子操作，但并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰。</li></ul></li></ul><p><strong>Lua脚本</strong>：它的功能和事务非常类似。我们可以利用 Lua 脚本来<strong>批量执行多条 Redis 命令</strong>，一段 Lua 脚本可以视作一条命令执行，<strong>一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行</strong>，保证了操作不会被其他指令插入或打扰。支持复杂逻辑（条件判断、循环、组合多命令）。</p><ul><li>如果 Lua 脚本运行时出错并中途结束，后续命令是不会被执行的（和事务对比！！）。并且，出错之前执行的命令是无法被撤销的。因此， 严格来说的话，<strong>通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></li></ul><p>Redis 7.0 新增了 Redis functions 特性，可以看作是比 Lua 更强大的脚本。</p><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>事务</strong></th><th align="left"><strong>原生批量操作</strong></th><th align="left"><strong>Pipeline</strong></th><th align="left"><strong>Lua 脚本</strong></th></tr></thead><tbody><tr><td align="left"><strong>原子性</strong></td><td align="left">部分（无回滚）</td><td align="left">单命令原子</td><td align="left">无</td><td align="left">全原子</td></tr><tr><td align="left"><strong>网络开销</strong></td><td align="left">高（多次往返）</td><td align="left">低（单次往返）</td><td align="left">低（单次往返）</td><td align="left">低（单次往返）</td></tr><tr><td align="left"><strong>灵活性</strong></td><td align="left">低（仅顺序执行）</td><td align="left">低（固定命令）</td><td align="left">高（任意命令组合）</td><td align="left">高（支持复杂逻辑）</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">低</td><td align="left">最高</td><td align="left">高</td><td align="left">中（依赖脚本复杂度）</td></tr><tr><td align="left"><strong>错误处理</strong></td><td align="left">需手动处理</td><td align="left">自动回滚</td><td align="left">需解析响应</td><td align="left">脚本内处理</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">简单批量操作</td><td align="left">同类型数据批量处理</td><td align="left">高吞吐非原子操作</td><td align="left">复杂原子操作</td></tr></tbody></table><h4 id="Bigkey"><a href="#Bigkey" class="headerlink" title="Bigkey"></a>Bigkey</h4><p>单个 Key 的 Value 占用内存过大，或数据结构中元素过多。例如：</p><ul><li><strong>String 类型</strong>：Value 超过1MB。</li><li><strong>Hash/List/Set/ZSet</strong>：元素数量超过 1 万，或总内存超过 1MB。</li></ul><p>bigkey 通常是由于下面这些原因产生的：</p><ul><li>程序设计不当，比如直接使用 String 类型存储较大的文件对应的二进制数据。</li><li>对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。</li><li>未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。</li></ul><p>危害：</p><ol><li><strong>内存不均衡</strong>：导致集群数据倾斜，部分节点<strong>内存压力大</strong>。</li><li><strong>阻塞主线程</strong>：删除 BigKey 时可能触发内存回收阻塞（如删除大 Hash）。</li><li><strong>网络拥塞</strong>：序列化/反序列化耗时增加，影响吞吐量。</li><li><strong>持久化问题</strong>：<code>fork</code> 子进程生成 RDB 时，内存拷贝延迟高。</li></ol><p>检测方法：</p><ol><li><p><strong><code>redis-cli --bigkeys</code> 命令</strong>：<strong>缺点</strong>：线上慎用（全表扫描可能阻塞服务）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-cli <span class="token parameter variable">-h</span> <span class="token number">127.0</span>.0.1 <span class="token parameter variable">-p</span> <span class="token number">6379</span> <span class="token parameter variable">--bigkeys</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>自定义扫描（SCAN + 类型分析）</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 扫描 Hash 类型 Key 的元素数量</span>redis-cli <span class="token parameter variable">--scan</span> <span class="token parameter variable">--pattern</span> <span class="token string">'*'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-L</span> <span class="token number">1</span> redis-cli <span class="token builtin class-name">type</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token builtin class-name">hash</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-L</span> <span class="token number">1</span> redis-cli hlen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>监控工具</strong>：<strong>RedisInsight</strong>：可视化分析内存分布。<strong>监控报警</strong>：通过 <code>INFO memory</code> 观察内存波动。</p></li></ol><p>解决方案：</p><ol><li><strong>拆分 Key</strong>：将大 Hash 拆分为多个子 Hash（如 <code>user:1000:info</code> → <code>user:1000:base</code> + <code>user:1000:contact</code>）。</li><li><strong>使用合适的数据结构</strong>：替代大 String：使用 Hash 存储字段。替代大 List：分片为多个 List（如 <code>list:part1</code>、<code>list:part2</code>）。</li><li><strong>异步删除</strong>：使用 <code>UNLINK</code> 替代 <code>DEL</code>（Redis 4.0+）。</li><li><strong>设置 TTL</strong>：对非核心数据设置过期时间，避免长期驻留。</li></ol><h4 id="Hotkey"><a href="#Hotkey" class="headerlink" title="Hotkey"></a>Hotkey</h4><p>某个 Key 的访问频率远高于其他 Key（如每秒数万次读/写），通常出现在缓存击穿、高频计数器等场景。</p><p>危害：</p><ol><li><strong>单节点压力大</strong>：若 Key 集中在某一节点（如集群模式），导致 CPU 和网络过载。</li><li><strong>性能瓶颈</strong>：高并发访问可能触发连接数限制或线程阻塞。</li><li><strong>缓存击穿</strong>：热 Key 突然过期，大量请求直接穿透到数据库。</li></ol><p>检测方法：</p><ol><li><p><strong><code>redis-cli --hotkeys</code> 命令</strong>（需启用 LFU 策略）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 配置 LFU（redis.conf）</span>maxmemory-policy volatile-lfuredis-cli <span class="token parameter variable">--hotkeys</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>监控工具</strong>：<strong>Redis 监控系统</strong>（如 Prometheus + Grafana）：观察 QPS 分布。<strong>业务日志分析</strong>：统计高频访问的 Key。</p></li><li><p><strong>代理层统计</strong>：通过代理（如 Redis Cluster Proxy）记录 Key 访问频率。</p></li></ol><p>解决方案：</p><ol><li><strong>本地缓存</strong>：客户端缓存热 Key（如 Guava Cache），降低 Redis 压力。设置合理的本地缓存过期时间，避免数据不一致。</li><li><strong>分片打散</strong>：对热 Key 增加随机后缀（如 <code>hotkey:1234</code> → <code>hotkey:1234_{1..N}</code>），分散到多个 Key。</li><li><strong>读写分离</strong>：读操作分流到从节点（注意数据同步延迟）。</li><li><strong>使用 Redis 集群</strong>：通过集群模式分散热 Key 到不同节点（需确保 Hash Tag 合理）。</li></ol><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>执行时间超过阈值的命令（默认 10ms），常见于复杂操作或 BigKey 操作。</p><p>危害：</p><ol><li><strong>阻塞主线程</strong>：单线程模型下，慢查询会阻塞后续所有命令。</li><li><strong>超时风险</strong>：客户端等待响应时间过长，触发连接超时。</li><li><strong>资源消耗</strong>：长时间占用 CPU 和内存。</li></ol><p>检测方法：</p><ol><li><p><strong>慢查询日志</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 配置慢查询阈值（redis.conf）</span>slowlog-log-slower-than <span class="token number">10000</span>  <span class="token comment"># 单位微秒（默认 10ms）</span>slowlog-max-len <span class="token number">128</span>            <span class="token comment"># 最多记录 128 条慢查询</span><span class="token comment"># 查看慢查询日志</span>SLOWLOG GET <span class="token number">10</span>  <span class="token comment"># 获取最近 10 条慢查询</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>监控系统</strong>：通过 <code>INFO commandstats</code> 统计命令耗时。集成 APM 工具（如 SkyWalking）追踪 Redis 操作。</p></li></ol><p>常见慢查询场景：</p><ol><li><strong>大 Key 操作</strong>：<code>HGETALL</code> 大 Hash、<code>LRANGE</code> 大 List。</li><li><strong>复杂命令</strong>：<code>ZUNIONSTORE</code>、<code>SINTER</code> 等多集合操作。</li><li><strong>低效查询</strong>：<code>KEYS *</code>、<code>FLUSHALL</code>（阻塞式命令）。</li></ol><p>解决方案：</p><ol><li><strong>优化命令</strong>：使用 <code>SCAN</code> 替代 <code>KEYS</code>，<code>HSCAN</code> 替代 <code>HGETALL</code>。<strong>避免在循环中执行 Redis 命令。</strong></li><li><strong>拆分操作</strong>：将 <code>ZUNIONSTORE</code> 分批执行，或提前计算并缓存结果。</li><li><strong>使用 Pipeline/Lua 脚本</strong>：减少网络往返（但需控制脚本复杂度）。</li></ol><h3 id="生产问题"><a href="#生产问题" class="headerlink" title="生产问题"></a>生产问题</h3><h4 id="缓存穿透、击穿、雪崩"><a href="#缓存穿透、击穿、雪崩" class="headerlink" title="缓存穿透、击穿、雪崩"></a>缓存穿透、击穿、雪崩</h4><ul><li><p>穿透：大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。大量请求打到数据库。</p><ul><li>解决：做好参数校验，防止非法参数请求。缓存无效Key，缓解非法key变化不频繁的情况。布隆过滤器，请求值不存在直接返回参数错误。接口限流，根据用户或ip的异常频繁访问，采取黑名单机制。</li></ul></li><li><p>击穿：热点key<strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。导致瞬时大量请求打到数据库。</p><ul><li>解决：延长过期时间。提前预热（推荐）。互斥锁保证失效后只有一个请求去查询数据库并更新缓存。</li></ul></li><li><p>雪崩：多个缓存在同一时间大面积失效，导致大量请求落到数据库。</p><ul><li>解决：redis集群。多级缓存。随机失效时间。提前预热。持久缓存策略。</li></ul></li></ul><p>常见的缓存预热方式有两种：</p><ol><li>使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li><li>使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li></ol><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>1、先删除缓存，再更新数据库</p><p>如果删除了缓存更新数据库的操作没有成功，此时查询数据的请求会把旧数据存储到缓存中。</p><p>2、先更新数据库，再删除缓存。</p><ul><li><p>如果更新了数据库，删除缓存的操作失败了，此时查询数据的请求查到的数据仍然是旧数据。</p></li><li><p>线程A读取商品数据，刚好缓存失效了，去查询数据库数据，刚要执行放入redis缓存时，CPU发生上下文切换，线程A暂时得不到执行，此时线程B修改数据，执行update商品操作，然后删除缓存，线程A执行时，将之前查询到的旧的数据存到redis缓存中，此时就会出现redis和数据库的数据不一致的情况。</p></li></ul><p><a href="https://blog.csdn.net/oldboy1999/article/details/126180530">为什么是删除缓存而不是更新缓存？</a></p><p>3、延迟双删，先删除缓存、再更新数据库，再延迟一定的时间去删除缓存。</p><ul><li><p>为什么要两次删除缓存，因为有可能第一次删除缓存后其它查询请求将旧数据存储到了缓存。</p></li><li><p>为什么要延迟一定的时间去删除缓存，为了给mysql主向从同步的时间，如果立即删除缓存很可能其它请求读到的数据还是旧数据。</p></li><li><p>延迟的时间不好确定，延迟双删仍然可能导致脏数据。</p></li></ul><p><strong>所以结论：以上方案当存在高并发时都无法解决数据库和缓存强一致性的问题。</strong></p><p>如何做缓存一致性？需要根据需求来定：</p><p>1、<strong>实现强一致性 需要使用分布式锁控制</strong>，修改数据和向缓存存储数据使用同一个分布式锁。（数据修改的同时更新缓存-同一个事务）</p><p>2、实现最终一致性，缓存数据要加过期时间，即使出现数据不致性当过期时间一到缓存失效又会从数据库查询最新的数据存入缓存。</p><p>3、对于实时性要求强的，要实现数据强一致性要尽量避免使用缓存，可以直接操作数据库。</p><p>使用工具对数据进行同步方案如下：</p><p>1、使用任务表加任务调度的方案进行同步。</p><p>2、使用Canal基于MySQL的binlog进行同步。</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h4><p>主从同步是 Redis 实现 <strong>数据冗余</strong> 和 <strong>高可用性</strong> 的核心机制。通过将一台 Redis 服务器（主节点，Master）的数据复制到其他服务器（从节点，Replica），实现以下目标：</p><ul><li><strong>数据备份</strong>：从节点作为主节点的数据副本，防止数据丢失。</li><li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求，提升吞吐量。</li><li><strong>故障恢复</strong>：当主节点宕机时，从节点可提升为新的主节点，保障服务可用性。</li></ul><p>主从同步分为 <strong>全量同步（Full Sync）</strong> 和 <strong>增量同步（Partial Sync）</strong> 两种模式：</p><ul><li><p><strong>全量同步</strong>：发生在 初次同步/从服务器数据丢失/主服务器数据发生变化 这些情况下。流程如下：</p><img src="https://cdn.xiaolincoding.com//picgo/1720157699223-d4aa2235-35e2-42ec-84a8-522600f531c2.png" alt="img" style="zoom:50%;"><ol><li><strong>初次连接</strong>：从节点向主节点发送 <code>PSYNC</code> 命令请求同步。</li><li><strong>生成 RDB 快照</strong>：主节点执行 <code>BGSAVE</code> 生成当前数据的 RDB 文件。</li><li><strong>传输 RDB</strong>：主节点将 RDB 文件发送给从节点，从节点加载到内存。</li><li><strong>主节点缓存写命令</strong>：主节点在生成 RDB 期间，将新的写命令缓存到 <code>replication buffer</code>。</li><li><strong>同步增量数据</strong>：RDB 传输完成后，主节点将缓冲的写命令发送给从节点，确保数据一致性。</li></ol></li><li><p><strong>增量同步</strong><br>当从节点与主节点短暂断开后重新连接时，主节点仅发送<strong>断开期间缺失的写命令</strong>，依赖以下机制：</p><img src="https://cdn.xiaolincoding.com//picgo/1720157758362-f61b89b5-5194-4d63-8cbd-f00ca524a417.png" alt="img" style="zoom:67%;"><ul><li><strong>Replication ID</strong>：主节点的唯一标识，重启或切换主节点时会改变。</li><li><strong>Offset</strong>：记录主从节点的数据同步偏移量。若从节点的 Offset 仍在主节点的复制积压缓冲区（<code>repl_backlog</code>）范围内，则触发增量同步。</li></ul></li></ul><p>主要有三个步骤：</p><ul><li>从服务器在恢复网络后，会发送psync命令给主服务器，此时的psync命令里的offset参数不是-1;</li><li>主服务器收到该命令后，然后用CONTINUE响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li><li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li></ul><h5 id="增量数据"><a href="#增量数据" class="headerlink" title="增量数据"></a>增量数据</h5><p>在 Redis 的主从同步中，<strong>增量同步（Partial Sync）</strong> 是通过 <strong>复制偏移量（Replication Offset）</strong> 和 <strong>复制积压缓冲区（Replication Backlog）</strong> 来实现的。</p><p><strong>复制偏移量（Replication Offset）</strong></p><ul><li><strong>主节点</strong>：每次执行写操作后，会记录一个全局的复制偏移量（<code>master_repl_offset</code>），表示当前写操作的字节位置。</li><li><strong>从节点</strong>：从节点也会记录自己已经复制的偏移量（<code>slave_repl_offset</code>），表示从节点已经同步到主节点的哪个位置。</li></ul><p><strong>复制积压缓冲区（Replication Backlog）</strong></p><ul><li><strong>作用</strong>：主节点会将最近的写操作命令存储在一个固定大小的环形缓冲区（<code>repl_backlog</code>）中，用于支持增量同步。</li><li><strong>大小</strong>：通过 <code>repl-backlog-size</code> 参数配置，默认大小为 1MB。</li><li><strong>内容</strong>：缓冲区中存储的是写操作的字节流，而不是具体的命令。</li></ul><p><strong>复制 ID（Replication ID）</strong></p><ul><li><strong>作用</strong>：每个主节点都有一个唯一的复制 ID，用于标识主节点的复制流。</li><li><strong>变化</strong>：当主节点重启或发生主从切换时，复制 ID 会改变。</li></ul><p>增量同步的触发条件是：</p><ol><li><strong>从节点与主节点的复制 ID 一致</strong>：表示从节点之前是从该主节点同步的。</li><li><strong>从节点的复制偏移量仍在主节点的复制积压缓冲区范围内</strong>：即 <code>slave_repl_offset</code> 在 <code>master_repl_offset - repl_backlog_size</code> 到 <code>master_repl_offset</code> 之间。</li></ol><p>如果满足以上条件，主节点会从复制积压缓冲区中提取从节点缺失的数据，并发送给从节点。</p><ol><li><p><strong>从节点连接主节点</strong>：<br>从节点向主节点发送 <code>PSYNC</code> 命令，携带自己的复制 ID 和复制偏移量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token constant">PSYNC</span> <span class="token operator">&lt;</span>replication<span class="token operator">-</span>id<span class="token operator">&gt;</span> <span class="token generics"><span class="token punctuation">&lt;</span>offset<span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>主节点检查复制 ID 和偏移量</strong>：</p><ul><li>如果复制 ID 匹配且偏移量在复制积压缓冲区范围内，主节点回复 <code>+CONTINUE</code>，表示可以执行增量同步。</li><li>否则，主节点回复 <code>+FULLRESYNC</code>，表示需要执行全量同步。</li></ul></li><li><p><strong>主节点发送增量数据</strong>：</p><ul><li>主节点从复制积压缓冲区中提取从节点缺失的数据（从 <code>slave_repl_offset</code> 到 <code>master_repl_offset</code> 之间的数据）。</li><li>将这些数据以字节流的形式发送给从节点。</li></ul></li><li><p><strong>从节点应用增量数据</strong>：</p><ul><li>从节点接收到增量数据后，将其应用到自己的数据库中。</li><li>更新自己的复制偏移量（<code>slave_repl_offset</code>）。</li></ul></li></ol><h4 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h4><p>Redis 哨兵（Sentinel）是 Redis 官方提供的 <strong>高可用性（HA）解决方案</strong>，用于管理主从架构中的故障自动检测与恢复。通过哨兵机制，Redis 可以实现<strong>主节点的自动故障转移（Failover）</strong>、配置中心化和客户端服务发现。</p><img src="https://cdn.xiaolincoding.com//picgo/1720094217984-6192d46c-16ba-47d2-a58d-ee8ddb1d49de.png" alt="img" style="zoom: 33%;"><p>Redis在2.8版本以后提供的哨兵（Sentinel）机制，它的作用是实现主从节点故障转移。它会<strong>监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</strong></p><p>哨兵其实是一个运行在特殊模式下的Redis进程，所以它也是一个<strong>节点</strong>。从“哨兵”这个名字也可以看得出来，它相当于是“观察者节点”，观察的对象是主从节点。当然，它不仅仅是观察那么简单，在它观察到有异常的状况下，会做出一些”动作”，来修复异常状态。</p><p>哨兵节点主要负责三件事情：<strong>监控、选主、通知。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>黑马程序员redis：<a href="https://www.bilibili.com/video/BV1cr4y1671t/?p=16&amp;spm_id_from=pageDriver&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba">https://www.bilibili.com/video/BV1cr4y1671t/?p=16&amp;spm_id_from=pageDriver&amp;vd_source=bf952648bf410c0b9b23bf213e3d24ba</a></p><p>redis常用命令：<a href="https://blog.csdn.net/weixin_49851451/article/details/134311296">https://blog.csdn.net/weixin_49851451/article/details/134311296</a></p><p><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E8%AF%B4%E4%B8%80%E4%B8%8B-redis-%E5%92%8C-memcached-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9">Redis常见面试题总结(上) | JavaGuide</a></p><p>数据结构：<a href="https://blog.csdn.net/weixin_44772566/article/details/137008421">一文彻底搞懂Redis底层数据结构-CSDN博客</a> 博客部分内容有误，借鉴文字</p><p>图源：<a href="https://blog.csdn.net/weixin_41519463/article/details/109208476">redis的5种数据结构及其底层实现原理_redis5种数据类型对应底层结构-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;p&gt;使用阿里云hit账号数据库，密码首字母大写&lt;/p&gt;
&lt;p&gt;Redis诞生于2009年全称是&lt;strong&gt;Re&lt;/s</summary>
      
    
    
    
    <category term="后端" scheme="http://wolf-ll.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="数据库" scheme="http://wolf-ll.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Redis" scheme="http://wolf-ll.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
